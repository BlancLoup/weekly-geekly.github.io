<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reactive programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, the functional approach to programming has its own specifics: in it we convert the data, not change them. But this imposes its own limita...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reactive programming</h1><div class="post__text post__text-html js-mediator-article">  As you know, the functional approach to programming has its own specifics: in it we convert the data, not change them.  But this imposes its own limitations, for example, when creating programs that actively interact with the user.  In an imperative language, it is much easier to implement this behavior, because we can react to any events ‚Äúin real time‚Äù, while in pure functional languages ‚Äã‚Äãwe will have to postpone communication with the system until the very end.  However, relatively recently, a new programming paradigm has begun to develop that solves this problem.  And her name is <b>Functional Reactive Programming</b> (FRP).  In this article I will try to show the basics of FRP using the example of writing a snake in Haskell using the reactive-banana library. <br><a name="habracut"></a><br>  <i>The rest of this article assumes that the reader is familiar with functors.</i>  <i>If this is not the case, I strongly recommend that you read them, since the understanding of the entire article depends on it.</i> <br><br><h4>  Main ideas </h4><br>  Two new data types appear in FRP: <b>Event</b> and <b>Behavior</b> .  Both of these types are functors, and many actions on them will be performed by combinators of functors.  We describe these types. <br><br><h5>  Event </h5><br>  An event is a stream of events that have an exact time stamp.  You can imagine it as (just imagine, because in reality it‚Äôs not so simple): <br><pre><code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Event</span></span></span><span class="hljs-class"> a = [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Time</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)]</span></span></code> </pre>  For example, an Event String can be a stream of chat users. <br>  As already mentioned, Event belongs to the class of functors, which means we can perform some actions with it. <br>  For example: <br><pre> <code class="hljs mel">(<span class="hljs-string"><span class="hljs-string">"Wellcome, "</span></span> ++) &lt;$&gt; eusers</code> </pre>  will create a stream of greetings from users who have entered the chat. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Behavior </h5><br>  Behavior denotes a value that changes over time. <br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Behavior</span></span></span></span> a = Time -&gt; a</code> </pre>  This type is well suited for game objects, the snake in our game will be Behavior. <br>  We can combine Behavior and Event using the apply function: <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">apply</span></span> :: <span class="hljs-type"><span class="hljs-type">Behavior</span></span> t (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Event</span></span> ta -&gt; <span class="hljs-type"><span class="hljs-type">Event</span></span> tb apply bf ex = [(time, bf time x) | (time, x) &lt;- ex]</code> </pre>  As can be seen from this definition, apply applies the function inside Behavior to the Event, taking into account the time. <br><br>  Let's go directly to the snake. <br><br><h4>  Game mechanics </h4><br>  For now, let's forget about reactive programming and get into the game mechanics.  For a start, the types are: <br><pre> <code class="hljs haskell"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Snake <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Segment</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pos</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Snake</span></span></span><span class="hljs-class"> = [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Segment</span></span></span><span class="hljs-class">]</span></span></code> </pre>  One segment of the snake is a pair of coordinates, and the snake itself is a chain of these segments.  Type Pos is needed only for convenience. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">startingSnake</span></span> :: Snake startingSnake = [(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (<span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)] wdth = <span class="hljs-number"><span class="hljs-number">64</span></span> hdth = <span class="hljs-number"><span class="hljs-number">48</span></span></code> </pre>  Create the initial position of the snake and the constant for the size of the playing field. <br><br><pre> <code class="hljs ruby">moveTo <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: Pos -&gt; Snake -&gt; Snake moveTo hs = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> h /= head s <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> h : init s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s keepMoving <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: Snake -&gt; Snake keepMoving s = let (x, y) = head s (x<span class="hljs-string"><span class="hljs-string">', y'</span></span>) = s !! <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> moveTo (<span class="hljs-number"><span class="hljs-number">2</span></span>*x - x<span class="hljs-string"><span class="hljs-string">', 2*y - y'</span></span>) s ifDied <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: Snake -&gt; Bool ifDied s@((x, y)<span class="hljs-symbol"><span class="hljs-symbol">:_</span></span>) = x&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span> x&gt;=wdth <span class="hljs-params"><span class="hljs-params">||</span></span> y&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-params"><span class="hljs-params">||</span></span> y&gt;=hdth <span class="hljs-params"><span class="hljs-params">||</span></span> head s <span class="hljs-string"><span class="hljs-string">`elem`</span></span> tail s</code> </pre>  The moveTo function shifts the snake to the specified location, keepMoving continues to move, and ifDied checks to see if the snake has died from samoiding or colliding with boundaries. <br>  This ends the mechanics, now comes the most difficult part - the logic of behavior. <br><br><h4>  Logics </h4><br>  We connect the necessary modules and describe some constants: <br><pre> <code class="hljs haskell"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE ScopedTypeVariables #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">when</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.IO <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Graphics.UI.SDL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> S <span class="hljs-keyword"><span class="hljs-keyword">hiding</span></span> (<span class="hljs-title"><span class="hljs-title">flip</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Graphics.Rendering.OpenGL <span class="hljs-keyword"><span class="hljs-keyword">hiding</span></span> (<span class="hljs-type"><span class="hljs-type">Rect</span></span>, <span class="hljs-title"><span class="hljs-title">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Reactive.Banana <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> R <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Word (<span class="hljs-type"><span class="hljs-type">Word32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Snake screenWidth = wdth*10 screenHeight = hdth*10 screenBpp = 32 ticks = 1000 `div` 20</code> </pre>  screenWidth, screenHeight is the width and height of the screen, respectively; ticks is the number of milliseconds by which the frame will linger on the screen. <br><br>  Now we define the inputs.  Only two events will come to us from the outside world: a keystroke and a clock signal.  So we need only two ‚Äúslots‚Äù for events and they are created by the newAddHandler function: <br><pre> <code class="hljs ruby">main <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: IO () main = withInit [InitEverything] $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> initScreen sources &lt;- (,) &lt;$&gt; newAddHandler &lt;*&gt; newAddHandler network &lt;- compile $ setupNetwork sources actuate network eventLoop sources network</code> </pre>  In setupNetwork, a ‚Äúnetwork‚Äù will be built from Event and Behavior, compile will compile NetworkDescription into EventNetwork, and actuate will launch it.  Events will be sent to the network from the eventLoop function, like signals to the brain from receptors. <br><br><pre> <code class="hljs pgsql">eventLoop :: (EventSource SDLKey, EventSource Word32) -&gt; EventNetwork -&gt; IO () eventLoop (essdl, estick) network = <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> lt k = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> s &lt;- pollEvent t &lt;- getTicks <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> (KeyDown (Keysym key _ _)) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> t (Just key) NoEvent -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> maybe (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ()) (fire essdl) k fire estick t <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span> _ -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (s /= Quit) (<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> tk)</code> </pre>  This is the ‚Äúreceptor‚Äù of our program.  fire essdl - runs the essdl event, which contains the name of the key, if it is pressed at all.  estick runs regardless of user behavior and carries the time since the start of the program. <br><br>  Here, by the way, is the transition from the EventSource, which returns newAddHandler, to the AddHandler: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EventSource</span></span></span><span class="hljs-class"> a = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> ()) addHandler :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EventSource</span></span></span><span class="hljs-class"> a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddHandler</span></span></span><span class="hljs-class"> a addHandler = fst fire :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EventSource</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> () fire = snd</span></span></code> </pre> <br>  Now we will begin the most responsible part: the description of a network of events. <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">setupNetwork</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> t. (<span class="hljs-type"><span class="hljs-type">EventSource</span></span> <span class="hljs-type"><span class="hljs-type">SDLKey</span></span>, <span class="hljs-type"><span class="hljs-type">EventSource</span></span> <span class="hljs-type"><span class="hljs-type">Word32</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">NetworkDescription</span></span> t () setupNetwork (essdl, estick) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Keypress and tick events esdl &lt;- fromAddHandler (addHandler essdl) etick &lt;- fromAddHandler (addHandler estick)</span></span></code> </pre>  First we get the Event from those timer and keyboard events that we launched in eventLoop. <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">let</span></span> ekey = filterE (flip elem [<span class="hljs-type"><span class="hljs-type">SDLK_DOWN</span></span>, <span class="hljs-type"><span class="hljs-type">SDLK_UP</span></span>, <span class="hljs-type"><span class="hljs-type">SDLK_LEFT</span></span>, <span class="hljs-type"><span class="hljs-type">SDLK_RIGHT</span></span>]) esdl moveSnake :: <span class="hljs-type"><span class="hljs-type">SDLKey</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Snake</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Snake</span></span> moveSnake ks = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">SDLK_UP</span></span> -&gt; moveTo (x, y<span class="hljs-number"><span class="hljs-number">-1</span></span>) s <span class="hljs-type"><span class="hljs-type">SDLK_DOWN</span></span> -&gt; moveTo (x, y+<span class="hljs-number"><span class="hljs-number">1</span></span>) s <span class="hljs-type"><span class="hljs-type">SDLK_LEFT</span></span> -&gt; moveTo (x<span class="hljs-number"><span class="hljs-number">-1</span></span>, y) s <span class="hljs-type"><span class="hljs-type">SDLK_RIGHT</span></span> -&gt; moveTo (x+<span class="hljs-number"><span class="hljs-number">1</span></span>, y) s <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (x, y) = head s</code> </pre>  Now create an event that means pressing the arrow - we do not need other keys.  As you probably already guessed, filterE eliminates events that do not satisfy the predicate.  moveSnake simply moves the snake, depending on the key pressed. <br><br><pre> <code class="hljs rust">brandom &lt;- fromPoll randomFruits -- Snake <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bsnake :: Behavior t Snake bsnake = accumB startingSnake $ (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> startingSnake &lt;$ edie) `<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class">` (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">moveSnake</span></span></span></span> &lt;$&gt; ekey) `<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class">` (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">keepMoving</span></span></span></span> &lt;$ etick) `<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class">` ((\</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span></span> -&gt; s ++ [last s]) &lt;$ egot) edie = filterApply ((\s _ -&gt; ifDied s) &lt;$&gt; bsnake) etick</code> </pre>  fromPoll implements another way of interacting with the real world, but it is different from what we used before.  First, we get Behavior, not Event.  And secondly, the action in fromPoll should not be expensive.  For example, it is good to use fromPoll along with variables. <br>  Next, we describe the snake with the help of accumB (note that the snake type is not just the Behavior Snake, but the Behavior t Snake. This has its deep meaning, which we don‚Äôt need to know). <br>  accumB "collects" Behavior from Event and initial values: <br><pre> <code class="hljs erlang-repl">accumB :: a -&gt; Event t (a -&gt; a) -&gt; Behavior ta</code> </pre>  That is, roughly speaking, when an event occurs, the function inside it will be applied to the current value. <br>  For example: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">accumB</span></span> <span class="hljs-string"><span class="hljs-string">"x"</span></span> [(time1,(++<span class="hljs-string"><span class="hljs-string">"y"</span></span>)),(time2,(++<span class="hljs-string"><span class="hljs-string">"z"</span></span>))]</code> </pre>  will create a Behavior, which at time1 will hold ‚Äúxy‚Äù, and at time2 - ‚Äúxyz‚Äù. <br>  Another unknown function is the union.  It merges events into one (if two events occur at the same time, the union gives priority to that of the first argument). <br>  Now we can understand how bsnake works.  First, the snake is equal to startingSnake, and then a number of changes happen to it: <br><ul><li>  She returns to the beginning if she died (edie event) </li><li>  Turns when the arrow is pressed </li><li>  Continues to move on signal </li><li>  And grows if you eat fruit (event egot) </li></ul><br>  The edie event fires when the snake is dead, and this is achieved using filterApply: <br><pre> <code class="hljs erlang-repl">filterApply :: Behavior t (a -&gt; Bool) -&gt; Event ta -&gt; Event ta</code> </pre>  This function discards events that do not satisfy the predicate inside Behavior.  As the name suggests, this is something like filter + apply. <br>  Notice how often we use combinators of functors to turn anything into a function. <br><br>  Now for the fruit: <br><pre> <code class="hljs xml">-- Fruits bfruit :: Behavior t Pos bfruit = stepper (hdth `div` 2, wdth `div` 2) (brandom <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">@</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">egot</span></span></span><span class="hljs-tag">) </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">egot</span></span></span><span class="hljs-tag"> = </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">filterApply</span></span></span><span class="hljs-tag"> ((\</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fsr</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">_</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span><span class="hljs-tag">&gt;</span></span> elem fs &amp;&amp; notElem rs) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">$</span></span></span><span class="hljs-tag">&gt;</span></span> bfruit <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">*</span></span></span><span class="hljs-tag">&gt;</span></span> bsnake <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">*</span></span></span><span class="hljs-tag">&gt;</span></span> brandom) etick</code> </pre>  A new fruit with coordinates in brandom appears as soon as the snake has collected the current one.  The combinator &lt;@ "transfers" the contents of one Behavior to the Event, that is, in this case, the contents of the egot event will be replaced with a random coordinate from brandom.  The new stepper function for us creates Behavior from Event and initial values, and its only difference from accumB is that the new Behavior event will not depend on the previous one. <br>  The egot event is triggered on that timer signal when the snake picked up the fruit and the new fruit doesn‚Äôt get into her body. <br><br><pre> <code class="hljs ruby">-- Counter ecount = accumE <span class="hljs-number"><span class="hljs-number">0</span></span> $ ((+<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;$ egot) <span class="hljs-string"><span class="hljs-string">`union`</span></span> ((const <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt;$ edie)</code> </pre>  ecount is a scoring event.  It is easy to guess that accumE creates an Event, not a Behavior.  The counter will be incremented by one at the egot event, and zeroed at edie. <br><br><pre> <code class="hljs lisp">let edraw = apply ((,,) &lt;$&gt; bsnake &lt;*&gt; bfruit) etick</code> </pre>  edraw starts at every timer signal, and contains the current position of the snake and fruit. <br><br>  Now it remains for the small: display the image on the screen. <br><pre> <code class="hljs ruby">reactimate $ fmap drawScreen edraw reactimate $ fmap (flip setCaption [] . (++) <span class="hljs-string"><span class="hljs-string">"Snake. Points: "</span></span> . show) ecount</code> </pre>  The reactimate function launches an IO action from the Event.  drawScreen draws the screen, and setCaption changes the name of the window. <br>  At this setupNetwork ends, and we can only add the missing functions. <br>  Screen Initialization: <br><pre> <code class="hljs mel">initScreen = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> glSetAttribute glDoubleBuffer <span class="hljs-number"><span class="hljs-number">1</span></span> screen &lt;- setVideoMode screenWidth screenHeight screenBpp [OpenGL] setCaption <span class="hljs-string"><span class="hljs-string">"Snake. Points: 0"</span></span> [] clearColor $= Color4 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> matrixMode $= Projection loadIdentity ortho <span class="hljs-number"><span class="hljs-number">0</span></span> (fromIntegral screenWidth) (fromIntegral screenHeight) <span class="hljs-number"><span class="hljs-number">0</span></span> (<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span> matrixMode $= Modelview <span class="hljs-number"><span class="hljs-number">0</span></span> loadIdentity</code> </pre> <br>  Random position generator: <br><pre> <code class="hljs xml">randomFruits :: IO Pos randomFruits = (,) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">$</span></span></span><span class="hljs-tag">&gt;</span></span> (randomRIO (0, wdth-1)) <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">*</span></span></span><span class="hljs-tag">&gt;</span></span> (randomRIO (0, hdth-1))</code> </pre> <br>  Well, and finally the drawing functions: <br><pre> <code class="hljs ruby">showSquare <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: (GLfloat, GLfloat, GLfloat, GLfloat) -&gt; Pos -&gt; IO () showSquare (r, g, b, a) (x, y) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> -- Move to offset translate $ Vector3 (fromIntegral x*<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: GLfloat) (fromIntegral y*<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span> -- Start quad renderPrimitive Quads $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> -- Set color color $ Color4 rgba -- Draw square vertex $ Vertex3 (<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: GLfloat) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> vertex $ Vertex3 (<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: GLfloat) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> vertex $ Vertex3 (<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: GLfloat) <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> vertex $ Vertex3 (<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: GLfloat) <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> loadIdentity showFruit <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: Pos -&gt; IO () showFruit = showSquare (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) showSnake <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: Snake -&gt; IO () showSnake = mapM<span class="hljs-number"><span class="hljs-number">_</span></span> (showSquare (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) drawScreen (s, f, t) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> clear [ColorBuffer] showSnake s showFruit f glSwapBuffers t<span class="hljs-string"><span class="hljs-string">' &lt;- getTicks when ((t'</span></span>-t) &lt; ticks) (delay $ ticks - t<span class="hljs-string"><span class="hljs-string">' + t)</span></span></code> </pre> <br>  That's all.  To compile, you'll need: reactive-banana, opengl, sdl.  From here you can download program source files: <a href="http://minus.com/mZyZpD4Hx/1f">minus.com/mZyZpD4Hx/1f</a> <br><br><h4>  Conclusion </h4><br>  Using the example of a small game, I tried to show the basic principles of working with FRP: the presentation of program mechanics as a network of Event and Behavior, separation of input and output data.  Even with such a simple program, you can see the advantages of FRP, for example, we did not have to start a type for the game state, as we would have done without using this paradigm.  I hope that this article will help in the study of reactive programming and facilitate its understanding. <br><br><h4>  Links </h4><br>  <a href="http://hackage.haskell.org/package/reactive-banana">hackage.haskell.org/package/reactive-banana</a> - reactive-banana to hackage <br>  <a href="http://github.com/HeinrichApfelmus/reactive-banana">github.com/HeinrichApfelmus/reactive-banana</a> - project repository on github.  There are examples. </div><p>Source: <a href="https://habr.com/ru/post/140719/">https://habr.com/ru/post/140719/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140714/index.html">Rapid development environment deployment</a></li>
<li><a href="../140715/index.html">Introduction to CSS3 Grid Layout. We work with nets</a></li>
<li><a href="../140716/index.html">Skype 5.5 decrypted for reverse engineering</a></li>
<li><a href="../140717/index.html">Speech Synthesis through Microsoft Translator for Asterisk</a></li>
<li><a href="../140718/index.html">Runet Today, March 26, 2012. Experts of the issue: Pavel Cherkashin, Askar Tuganbayev</a></li>
<li><a href="../140720/index.html">Features of restoring / transferring FreeBSD to a host with a different hardware configuration</a></li>
<li><a href="../140721/index.html">Packet Compression and Open Source C # Client Protection</a></li>
<li><a href="../140722/index.html">Is there a community on the site and in social networks? Cat analogy</a></li>
<li><a href="../140723/index.html">New Notepad ++ 6.0</a></li>
<li><a href="../140725/index.html">Android Overview of combat applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>