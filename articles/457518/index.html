<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Plasma Cash Chain as a solution to the blockchain scalability trilemma</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, dear readers! 

 This article focuses on the Plasma Cash Chain and sheds light on the following topics: 



- trilemma scalability and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Plasma Cash Chain as a solution to the blockchain scalability trilemma</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon, dear readers! <br><br>  This article focuses on the Plasma Cash Chain and sheds light on the following topics: <br><br><ul><li>  trilemma scalability and ways to solve it; </li><li>  Child Cheyne data structures and their display in rutchein; </li><li>  implementation of input in rutcheyn; </li><li>  implementation of output from rutchain. </li></ul><br>  Opporty used the Javascript programming language to implement childchain, as well as Solidity for rutchain.  Code examples are provided in these languages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><a name="habracut"></a><br>  Blockchain and decentralization provide an opportunity to optimize and improve the work of almost any sphere of life, which uses the Internet and information technology.  They increase reliability, financial efficiency, and also facilitate the digitalization of real things and goods. <br><br>  Smart contracts bring business logic to decentralized networks.  This allows you to build new DAPP applications. <br><br>  The execution of smart contracts and the rapid operation of applications with a distributed database can only be possible if the condition of high scalability is fulfilled. <br><br>  Modern decentralized blockchains have several drawbacks.  The main one is scalability.  Ethereum processes about 20 tx / s.  This is not enough in today's financial realities.  At the same time, Ethereum has the highest degree of protection against hacking and network breakdowns.  Other cryptocurrencies and systems built on the blockchain do not have such a high degree of decentralization, which reduces trust in the network. <br><br><h2>  Trilemma scalability </h2><br>  There is a blockchain scalability trilemma that includes three components: <br><br><ul><li>  decentralization; </li><li>  security; </li><li>  scalability. </li></ul><br><h3>  Deleralization in the trilemma </h3><br>  Decentralization, as the term implies, reflects the degree of diversification of ownership of activity in the blockchain, as well as the degree of diversification of the creation of blocks and the generation of new Ledger records. <br><br>  For clarity, you need to talk about the most centralized organizations.  Usually a simple database is used instead of the blockchain.  This organization is managed by special administrators.  All transactions can be canceled by manual intervention. <br><br>  In a fully decentralized network, each user can participate in building a network. <br><br>  The most important consequence of decentralization is that the majority of the value goes to the community that participates in the creation of the blockchain.  There is no intermediate team of managers who receive all the benefits instead of those who generate the very structure of the network.  In fact, most crypto projects belong entirely to their distributors or users, and not to the founders.  This is obviously a more attractive model for those who are not the founders. <br><br><h3>  Safety in the trilemma </h3><br>  We are talking about the ability of the blockchain to resist attacks from external sources and to keep the system intact.  Most blockchains are subject to many potential security threats.  It is extremely important to know about the most common attack vectors and protection options. <br><br>  In this case, decentralization and security go hand in hand.  The more nodes, the less network depends on the centralized side and, consequently, less risk of having a central point of failure.  However, there are many other attack vectors that pose a danger to decentralized networks, including: <br>  &gt; <b>50% attack</b> - an object that owns more than 50% of the total number of unpaid tokens, actually owns the network; <br>  &gt; <b>Sybil Attack</b> - the user can generate multiple identifiers in the system in order to effectively control a significant share in the ownership and / or decision making in the network; <br>  &gt; <b>DDoS</b> ‚Äî A distributed denial of service (DDoS) attack occurs when there is an intention to disrupt traffic on the network by filling the network with malicious transactions; <br>  &gt; <b>Collusion attack</b> - one or more objects (or nodes) decide to unite to perform any malicious operation on the network. <br><br><h3>  Scalability in the trilemma </h3><br>  The degree of scalability is important because it determines the ultimate throughput, in other words, the upper limit of the size of the network.  The most important question to ask when evaluating the network is: ‚ÄúHow many users can this system withstand?‚Äù Bitcoin currently has between 2.9 and 5.8 million purse holders.  The EOS has several thousand members. <br><br>  Scalability and decentralization can coexist, but security is reduced.  Developers choose the platforms that best suit their needs.  Users do the same.  Opinions of the two sides sometimes diverge.  Some users are willing to sacrifice security for the sake of scalability, others for scalability for the sake of security, but achieving balance is more difficult. <br><br><h2>  ‚ÄúHoly Grail‚Äù in blockchain technology </h2><br>  By definition, a blockchain has only two of the following three properties: <br><br><ul><li>  <b>Decentralization</b> (each participant has access only to the resources of O ¬©, that is, to a regular laptop or a small VPS); </li><li>  <b>Scalability</b> (ability to handle transactions O (n)&gt; O ¬©); </li><li>  <b>Security</b> (protection against intruders using O (n) resources). </li></ul><br><img src="https://habrastorage.org/webt/ek/zg/zr/ekzgzredr00odj5mwae4f549hzs.png"><br>  Green: a balanced state of the three conditions. <br>  Red: strong security, but limited decentralization and scalability. <br>  Blue: efficiency is high, but security and decentralization are limited. <br>  Black: decentralization is high, but there are some aspects of scalability and security. <br>  Gray: full decentralization, with minimal or no security features and scalability. <br>  Purple: Equal Balance between Security and Scalability, Non-decentralization. <br><br>  ‚ÄúHoly Grail‚Äù in the blockchain technology means the unification of all three aspects. <br>  In most current projects working with cryptocurrencies, two basic properties are achieved: decentralization and security.  However, scalability suffers. <br><br><h2>  Promising options for solving the trilemma </h2><br><h3>  Proof of Stake (PoS) </h3><br>  Proof of Stake (PoS) provides potential scalability enhancement.  POS replaces cryptocurrency mining based on the Proof of Work (PoW) system.  The selection of the validator is very fast - in a deterministic way.  At the same time there is no electricity consumption and it is environmentally beneficial. <br><br><h3>  Sidechains </h3><br>  In the Ethereum virtual network, it is possible to create a side network in which the project can process its individual transactions, and then record only the initial and final results in the Ethereum network.  This reduces the load on EVM, but causes greater trust in the management of the sidechain.  Thus, trust to a third party reduces decentralization. <br><br><h3>  Sharding </h3><br>  Sharding breaks transactions into smaller ‚Äúpieces‚Äù of data.  Instead of each individual node in the network processing whole transactions, the nodes are divided into groups, and these groups of nodes process certain pieces of data.  Later, during processing, these pieces of data are re-assimilated for permanent storage in the blockchain. <br><br><h3>  Increase block size </h3><br>  Litecoin and Bitcoin Cash (BCH) are forks for Bitcoin blockchain.  Forking basically copies one blockchain.  After branching, you can make changes.  Both LTC and BCH increased the size of each block, which allowed storing more transactions per block, thereby increasing transaction processing speed. <br><br><h3>  Lightning network </h3><br>  The very first sidechain solution was lightning.  The main idea of ‚Äã‚Äãthe Lightning Network is that not all transactions should be recorded in the blockchain, as this overloads the network.  If users transfer funds to each other several times, then it is not necessary to register each transfer.  Simply open a kind of payment channel and record the data on its opening in the blockchain.  This channel will remain open as needed.  When it is necessary to close it, the result of all transactions made in this channel will simply be recorded in the blockchain.  Following this idea, you can create a whole network of channels for payments.  Then transactions in the blockchain will be used much less frequently. <br><br>  A payment channel is just a merger of several transactions.  The channel can close any of its members.  This action will be similar to opening a safe, allowing you to collect funds belonging to participants and write down the data on their transfer to the blockchain. <br>  This technology becomes really powerful when several similar channels join together in a network called The Lightning Network.  This network is specifically built for Bitcoin. <br><br><h3>  Raiden network </h3><br>  For Ethereum, the best known equivalent of Lightning is the Raiden Network. <br>  This solution is for scaling outside the main blockchain.  It is compatible with the transfer of ERC-20 tokens in bidirectional payment channels. <br><br>  Its basic architecture is complex, but interacting with Raiden requires developers to only interact with the API to create scalable applications on Raiden. <br><br>  Raiden is designed to provide instant payments and low commissions, increasing the confidentiality of transactions and micropayments.  Most of the payment channels exist outside the network and only occasionally form transactions within the ruthchan, which significantly reduces the throughput of child labor. <br><br><h2>  Optimal solution </h2><br>  Lightning ideologists have created a new childchain concept that solves the problems of the speed of the blockchain. <br><br>  Opporty practically implements the concept of Plasma and Plasma Cash. <br><br>  Plasma is a set of smart contracts that run over Ethereum rutchain and consist of a network of child chains connected to a root chain in a hierarchical tree structure. <br><br>  That is, Ethereum rutchain security is used to optimize scalability. <br><br><h2>  Plasma Cash: an implementation option from Opporty </h2><br>  <b>Opporty uses the Plasma Cash implementation in the first version.</b> <br><br>  This model is the most effective plasma implementation in terms of scalability. <br>  Plasma Cash is a system based on the use of unique identifiers for each token in the Plasma chain.  That is, NFT is used and tokens on the network receive unique serial numbers. <br><br>  Plasma Cash features: <br><br><ul><li>  Sharded client side validation ‚Äî clients just need to follow their Plasma chain to get their tokens.  This means that transaction throughput can increase without increasing the burden on individual users. </li><li>  Simplify Mass Exit ‚Äî Mass exits become less of a threat to the network, since the thief must submit an exit transaction for each token he wants to steal. </li><li>  No two-way confirmations ‚Äî transactions no longer require two-step submission and confirmation.  Instead, a transaction can be spent as soon as it is included in the main chain. </li></ul><br>  Disadvantage: <br><br>  Large token values ‚Äã‚Äã- since each token must be assigned a serial number, it is not possible to produce arbitrarily small tokens.  This is due to the fact that at some point the cost of buying a token will be more than the cost of the token itself. <br><br><h3>  Transaction structure in Opporty Plasma Cash </h3><br>  Opporty used Javascript to implement childchain.  Each transaction in Opporty Plasma Cash is a similar structure: <br><br><pre><code class="plaintext hljs">const transactionFields = [ {name: 'prevHash'}, {name: 'prevBlock', int: true, default: 0}, {name: 'tokenId', isDecimal: true}, {name: 'newOwner'}, {name: 'type'}, {name: 'signature'}, ]</code> </pre> <br>  The main elements here are the link to the previous prevBlock block (it is needed to move along the block chain), the tokenId token identifier (it must be unique), and also the newOwner last owner of the token. <br><br>  Further, in order to assemble a block and get a rutchain hash, a special type of tree Patricia Merkle Trie is used.  The same tree is used in Ethereum.  It has a compressed appearance.  At the same time, it is still possible to receive proofs of the inclusion or non-inclusion of a transaction in a block. <br>  Signature is a signature on elliptic curves. <br><br>  A transaction that spends a token with a given tokenId is valid only if it is included in the Merkle tree in the tokenId position, that is, for each token in the Merkle tree, there is only one ‚Äúplace‚Äù that spends this token where transactions are allowed to take place.  This format allows users to check the complete history of the Plasma chain, as well as to prove and disprove possession for specific tokens. <br><br>  In order to spend a token, you need to validate the chain, check it for missing blocks and only then re-sign the transaction along with the entire history. <br><br>  The block looks like this: <br><br><pre> <code class="plaintext hljs">const blockFields = [ {name: 'prevHash'}, {name: 'blockNum', isDecimal: true}, {name: 'transactions'}, {name: 'merkleRoot'}, {name: 'time'} ]</code> </pre> <br>  At a basic level, a blockchain is just a chain of blocks with reference to the previous block.  Such a structure makes it possible to obtain the property of immutability, that is, not rewriting history.  merkleRoot allows you to write checkpoints in rutchain. <br><br>  In rutchain, at the level of a smart contract, it looks like this (Solidity language): <br><br><pre> <code class="plaintext hljs">/* * Block structure (represents one block in a chain) */ struct Block { uint block_num; bytes32 merkle_root; uint time; /* * Transaction structure (decoded from RLP form) */ struct Transaction { bytes32 prevhash; uint prev_block; uint token_id; address new_owner; }</code> </pre><br>  Encoding is performed using the encoding / decoding functions ‚Äî RLP serialization / deserialization. <br><br><h3>  Input Methods in Plasma Cash </h3><br>  Anyone can enter funds into Plasma Cash simply by transferring the broadcast to a smart contract.  As a result, an OPP token will be received at a specific tokenId position. <br><br>  Here is the implementation in the Solidity language: <br><br><pre> <code class="plaintext hljs">function deposit() public payable { uint token_id = uint(keccak256(msg.sender, msg.value, deposit_blk)); // token.index = deposit_blk; tokens[token_id] = msg.value; deposit_blk += 1; emit DepositAdded(msg.sender, msg.value, token_id, current_blk); }</code> </pre> <br>  That is, tokenId is generated as a random number (hash).  Next, an event is generated that is scanned in the child chain. <br><br><h3>  Withdrawal methods in Plasma Cash </h3><br>  Each person can withdraw their token by providing the last two transactions in the history of ownership of the token. <br><br>  Implementing an output from rutchain: <br><br><pre> <code class="plaintext hljs">function startExit(uint block_num, bytes tx1, bytes tx0, bytes proof1, bytes proof0) public returns (uint exit_id) { require(checkPatriciaProof(keccak256(tx1), childChain[block_num].merkle_root, proof1)); bytes32 prev_hash; uint prev_blk; uint token_id; address new_owner; (prev_hash, prev_blk, token_id, new_owner,) = getTransactionFromRLP(tx1); require(msg.sender == new_owner); require(tokens[token_id] &gt; 0); bytes32 hashPrevTx = keccak256(tx0); require(checkPatriciaProof(hashPrevTx, childChain[prev_blk].merkle_root, proof0)); require(prev_hash == hashPrevTx); Exit storage record = exitRecords[token_id]; require(record.block_num == 0); record.block_num = block_num; record.new_owner = msg.sender; record.prev_block = prev_blk; if (childChain[block_num].time &gt; block.timestamp - week) record.priority = childChain[block_num].time; else record.priority = block.timestamp - week; exits.add(record.priority); exit_ids[record.priority].push(token_id); emit ExitAdded(msg.sender, record.priority, token_id); return token_id; }</code> </pre><br>  First, the presence of two transactions is checked.  If the current user is the owner of the transaction, then we simply add his output to the structure and leave two weeks to be able to challenge the output. <br><br>  The conclusion can be challenged in three ways: <br><br><ul><li>  Providing confirmation of spend on the transaction: </li></ul><br><pre> <code class="plaintext hljs">function challengeSpent(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); require(prev_block == record.block_num &amp;&amp; record.block_num &lt; blk_num); require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  If there is a transaction that is already spending the token to be displayed, then such a withdrawal will be canceled! <br><br><ul><li>  Providing evidence of the costs of the previous transaction: </li></ul><br><pre> <code class="plaintext hljs">/* * Challenge exit by providing * a proof of a transaction spending P(C) that appears before C */ function challengeDoubleSpend(uint exit_id, uint blk_num, bytes tx1, bytes proof) public { require(checkPatriciaProof(keccak256(tx1), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); // bytes32 prev_hash; uint prev_block; uint token_id; (, prev_block , token_id, ) = getTransactionFromRLP(tx1); require(tokens[token_id] &gt; 0); // check if token double spent require(prev_block == record.prev_block &amp;&amp; blk_num &lt; record.block_num); // require(token_id == exit_id); exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); }</code> </pre><br>  This is the same test as if the token was spent before the withdrawal.  First, the presence of the transaction in the root hash is checked.  Next, we delete the output if it has already been spent. <br><br><ul><li>  providing a transaction in the transaction history of the token to it. </li></ul><br>  This may be the wrong story, so you need to confirm it with a child transaction: <br><br><pre> <code class="plaintext hljs">// */ function challengeInvalidHistory(uint exit_id, uint blk_num, bytes tx0, bytes proof) public { // check if proof is valid require(checkPatriciaProof(keccak256(tx0), childChain[blk_num].merkle_root, proof)); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); bytes32 prev_hash; uint token_id; (prev_hash, , token_id, ) = getTransactionFromRLP(tx0); //require(exit_id == token_id); require(tokens[token_id] &gt; 0); // transaction should be before exit tx in history require(blk_num &lt; record.block_num - 1); challenged[exit_id] = blk_num; emit ChallengedInvalidHistory(exit_id, token_id); }</code> </pre><br>  Calling the first and second script blocks the output immediately. <br><br>  The call to the third scenario can be answered by providing a direct descendant.  It must be equal to or ahead of the parent transaction. <br><br><pre> <code class="plaintext hljs">/* * Respond to invalid history challenge by providing * the direct child of C*, which must be either equal to or before P( C ) */ function respondChallenge(uint exit_id, uint blk_num, bytes childtx, bytes proof) public { require(challenged[exit_id] &gt; 0); Exit memory record = exitRecords[exit_id]; require(record.block_num &gt; 0); require(checkPatriciaProof(keccak256(childtx), childChain[blk_num].merkle_root, proof)); // get transaction from rlpencoded form bytes32 prev_hash; uint prev_block; uint token_id; (prev_hash, prev_block, token_id, ) = getTransactionFromRLP(childtx); // if direct child if (prev_block == challenged[exit_id] ) { if (blk_num &lt;= record.prev_block &amp;&amp; token_id == exit_id ) { delete challenged[exit_id]; emit ExitRespondedEvent(exit_id); } else { exit_ids[record.priority].remove(exit_id); delete exitRecords[exit_id]; emit ExitChallengedEvent(exit_id); } } }</code> </pre><br>  That is, if the correct child transaction is received, the output is disputed and remains in the queue! <br>  After constructing part of the Opporty Plasma Cash protocol, the following conclusion was made: <br>  This protocol provides security by rutchain in Ethereum. <br><br>  By complicating the procedure of input and output from the Routchein and state compression (transaction blocks), all methods of output and input into the Routchain were examined, and basic data structures were investigated: transactions and blocks. <br><br>  Using the sidebar on the basis of the Ethereum network, you can significantly speed up the execution of transactions.  Opporty received up to <b>300,000</b> transactions per second on a single statement.  This is much more than what current payment systems can provide. <br><br>  Despite some data availability problems, the operator provides a high level of blockchain stability and makes it possible to perform effective international business transactions. <br><br>  Plasma Cash brings a huge increase in scalability.  Therefore, Opporty uses Plasma as part of its PoE protocol. <br><br><h3>  useful links </h3><br><ol><li>  <a href="https://plasma.io/plasma.pdf">White paper plasma</a> </li><li>  <a href="https://github.com/opporty-com/Plasma-Cash">Git hub</a> </li><li>  <a href="https://clever-solution.com/case-studies/scalability-opporty-plasma-cash">Use cases and architecture description</a> </li><li>  <a href="https://lightning.network/lightning-network-paper.pdf">Lightning network paper</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/457518/">https://habr.com/ru/post/457518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457508/index.html">Raising a child vs Machine learning: compares a young mother</a></li>
<li><a href="../457510/index.html">Use mcrouter to scale memcached horizontally.</a></li>
<li><a href="../457512/index.html">Logical replication between PostgreSQL versions</a></li>
<li><a href="../457514/index.html">Nevangary</a></li>
<li><a href="../457516/index.html">Writing a threat model</a></li>
<li><a href="../457520/index.html">Creating a 3-level menu using the Htmlix framework - part 2 mobile menu version</a></li>
<li><a href="../457522/index.html">Raise your mailing service or use ready-made solutions? What I learned for 5 years of work in UniSender</a></li>
<li><a href="../457524/index.html">Depth cameras - silent revolution (when robots see) Part 1</a></li>
<li><a href="../457526/index.html">Technical media as a bazaar</a></li>
<li><a href="../45753/index.html">DARPA Binoculars beats the diffraction limit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>