<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Technical diary: the second half year of the development of a new mobile PvP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am the lead team in Pixonic, where I work for a year. About the start and development of one of our new projects, I previously wrote an article on H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Technical diary: the second half year of the development of a new mobile PvP</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/zu/ly/aj/zulyajp-rag8nyiivotnt13jowu.jpeg"><br><br>  I am the lead team in Pixonic, where I work for a year.  About the start and development of one of our new projects, I previously <a href="https://habr.com/company/pixonic/blog/343820/">wrote</a> an article on Habr√©.  In the course of further production, after another six months, I have accumulated a large number of interesting experience, which I wanted to share again.  This time we will talk about the process of increasing the functionality in the mobile client and maintaining the code in a flexible state. <br><br>  I am sure the vast majority at least once launched some multiplayer game.  At the start, the client, as a rule, writes several magical messages and after a few seconds (although in the case of one well-known desktop shooter - a few minutes), the player enters the main menu, where there is a cherished button ‚ÄúTo battle‚Äù or something like that.  But the launch process consists of a huge number of stages that occur very quickly and without player intervention: <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  selection of the best region for the player; </li><li>  check changes and download new settings for the game; </li><li>  connection establishment and successful authorization; </li><li>  obtaining relevant data on the player's profile; </li><li>  many other actions without immersing a player in technical details. </li></ul><br>  Moreover, this functionality is not written immediately completely, but gradually expands and is constantly improving throughout the life of the project.  One of the difficult tasks of a designer is to prevent such development of the code in which he loses such good properties as <b>loose coupling (loose coupling)</b> and <b>re-usability</b> . <br><br>  But it often happens that a code module that looks concise and versatile turns into a monster because of any one little nuance in the TK.  In a word: <i>in no case should you allow macaroni in the code - they will not be untangled quickly if changes occur</i> . <br><br>  This design task fell to me and, after a year of development, I will talk about the logic that guided the design of the game client modules (then all the material goes in chronological order as you add or change functionality). <br><br>  For some, this material may seem just another interpretation of the SOLID principles, but examples from real and large-scale practice only help to consolidate and improve their understanding. <br><br>  Each time describing the application module, I will add it to the diagram of links.  In the diagrams, the modules will be linked by arrows, which mean sole possession and use of one module by another.  The slave module has no user information.  Following this rule, your architecture will always look like a tree.  In my opinion, the tree is the symbol of a flexible code and its correct extension. <br><br>  But before continuing, I must again make a reservation: <br><br><ul><li>  I still can not clarify the features of game design or show footage from the game before the official release; </li><li>  the given code is not an exact copy of the code in the project (this is done to simplify the examples); </li><li>  These practices, tips and code may not be applicable in other projects (but they work effectively with us - with our requirements and technology stack). </li></ul><br>  So, let's start with the lowest level, the direct interaction between the game server and the mobile client. <br><br><h2>  Transport layer </h2><br><img src="https://habrastorage.org/webt/zn/fh/3h/znfh3hlzpue8akitoyvakbcik1s.jpeg"><br>  In any multiplayer game there are integrated or independently written data transports - some network protocols that take responsibility for the delivery, integrity, opposition to duplication and incorrect sequence of transmitted data. <br><br>  In our new project, I decided from the very beginning to abstract their implementations in order to make the API universal and synchronous, as well as for the additional possibility of substitution of implementations.  First of all - the protocol of high-frequency delivery in the gameplay process. <br><br>  We use the Low Level Photon Network to transfer data from the game server to the client and back directly during the game with high frequency.  Creating an abstraction in the code looked like this: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INetworkPeer</span></span> { PeerStatus PeerStatus { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//  int Ping { get; } IQueue&lt;byte[]&gt; ReciveQueue { get; } //   void Connect(); void Send(byte[], bool sendReliable); void Update(); //    ,  Service  PhotonPeer void Disconnect(); } public enum PeerStatus { Disconnected = 0, Connecting = 1, Connected = 2, }</span></span></code> </pre> <br>  "Thread safety" or, if you like - "flow-evident", should be read on the interface.  As you can see, the INetworkPeer interface API is synchronous, the Update method hints that some of the work will be performed in the context of the caller‚Äôs execution. <br><br>  <b>What did it give us</b> <br><br>  While working on the simulation code, the fastest way to work with the new functionality is not to deploy a local server with modified code on your work computer at all.  We had the opportunity to write a second implementation for this interface, inside which the code from the common submodule was already used - so the client becomes the server itself. <br><br>  A little later, we used this substitution to create a local simulation with modified rules (this is how the training system works in the client now).  This mode does not load the server unnecessarily and does not require an Internet player in the early stages, and this, in turn, improves the passing funnel. <br><br>  We are experimenting with other implementations of transports and changing them if necessary.  The main reasons are the optimization of work with memory and system calls to increase the capacity and performance of servers. <br><br><h2>  Deserialization stream </h2><br><img src="https://habrastorage.org/webt/hv/xz/fi/hvxzfit06e9kftusbxuu0z-wpys.jpeg"><br>  The next task is to transform the arrays of the received bytes into data transfer objects (type GameClientMessage).  I hid these responsibilities behind this interface (note that this interface is not tied to the implementation of INetworkPeer): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INetworkPeerService</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Ping { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } NetworkServiceStatus Status { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//     void Connect(INetworkPeer peer); void SendMessage(GameClientMessage message, bool sendReliable); //   DTO ,   . void Disconnect(); bool HasMessage(); // ,    . GameClientMessage DequeueMessage(); //    } public enum NetworkServiceStatus { Disconnected = 0, Connecting = 1, Connected = 2, }</span></span></code> </pre> <br>  Please note that INetworkPeerService is aware of the INetworkPeer type and uses it in the Connect method, while the implementations of INetworkPeer, at the same time, know nothing about INetworkPeerService. <br><br>  <b>What did it give us</b> <br><br>  Inside this abstraction, you can encapsulate and safely develop the functionality associated with the serialization of messages.  In our case, under the hood is the composition of the following responsibilities: <br><br><ul><li>  Compression by LZ4 algorithm. </li><li>  Serialization with Protocol Buffers. </li><li>  Pulling arrays and DTO to optimize memory usage. </li><li>  Code execution in a separate thread. </li></ul><br>  The last point is very important, since your frame rate should not depend on the number of messages received per frame.  We are also protected from the spontaneous laboriousness of the operation to expand the pool of objects. <br><br><h2>  Network model, its state and handshake procedure </h2><br><img src="https://habrastorage.org/webt/is/r2/hp/isr2hp05qikg32ehmk69xxmm9za.jpeg"><br>  When connecting to the game, it is not enough just to establish a connection.  The game server must understand: who you are, why you are connected and what to do with you.  And on the client the sequence of states should change: <br><br><ol><li>  Initiate a connection to the server. </li><li>  Wait for a successful connection or give an error. </li><li>  Send information about intentions (who I am and what game I was sent by the player selection service). </li><li>  Wait for a positive response from the server and get a session identifier from it. </li><li>  Start work related to the game, send input and provide access to the data. </li><li>  In case of disconnection from the server, accept the required state. </li></ol><br>  In my opinion, the State design pattern obviously begs here.  As can be seen from the example below, this machine is closed from the user and is able to make decisions in its area of ‚Äã‚Äãresponsibility: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IGameplayNetworkModel</span></span> { NetworkState NetworkState { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//     int SessionId { get; } //       IQueue&lt;GameState&gt; GameStates { get; } //    float Ping { get; } void ProcessNetwork(TimeData timeData); //Update ,  , Service void ConnectToServer(INetworkPeer peer, string roomId, string playerId); //INetworPeer    INetworkPeerService.Connect(peer). void SendInput(IEnumerable&lt;InputFrame&gt; input); void ExitGameplay(); }</span></span></code> </pre> <br>  In the implementation of the IGameplayNetworkModel interface, the constructor looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameplayNetworkModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">INetworkPeerService networkPeerService</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  This is a classic injection through the designer of the lower level entity into the essence of the upper level.  INetworkPeerService does not know anything about GameplayNetworkModel or even IGameplayNetworkModel.  Both NetworkPeerService and GameplayNetworkModel are created once for an application and exist for the entire duration of the client operation.  A higher level user who will use IGameplayNetworkModel for work should not know anything about entities that are hidden from him - such as INetworkPeerService and even lower. <br><br>  <b>What did it give us</b> <br><br>  The most important thing is that the user of this interface will be protected from all the details of working with network states.  What is the difference, why you can‚Äôt send the input, get the latest data about the game and have to show the connection loss window?  The main thing is to trust the implementation. <br><br>  By itself, a state pattern is a very powerful tool for hiding functionality.  It is very easy to add new states to a discharged execution chain with more complex requirements.  I will mention this pattern again and again in the following examples. <br><br><h2>  Model match game.  Encapsulation of interpolation and game data storage </h2><br><img src="https://habrastorage.org/webt/bb/a7/vm/bba7vm80lvqgh6a50uqcysschj4.jpeg"><br>  When in Unity, via the Update () call, your code gets execution control, in online games you usually need to do 3 things (simplified): <br><br><ol><li>  Collect the input to be sent to the server (if there is one and if the state of the network allows). </li><li>  Update network status and accept what has come and is ready to be processed for this frame. </li><li>  Pick up data and start its visualization. </li></ol><br>  But fighting for the smoothness of the picture in the conditions of a poor mobile connection and non-guaranteed delivery, you need to additionally implement the following functionalities: <br><br><ul><li>  The collection and storage of player input (since the frame rate of rendering we do not equal the frequency of sending). </li><li>  Duplication of data on entry when sending to improve the reliability of delivery. </li><li>  Storage of incoming states of the world and their ordering. </li><li>  Interpolate the data needed to build the current frame, based on the incoming states. </li><li>  Abstraction from DTO types. </li><li>  Keeping statistics on the frequency of transmissions. </li><li>  Work with time: analysis of time on the server, adaptation of data to temporary problems (acceleration of time to reduce input lag and short time deceleration / time offset in case of connection degradation or lack of data). </li></ul><br>  In our case, this is encapsulated behind the gameplay model interface: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IGameplayModel</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PlayerSessionId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//      ICurrentState CurrentState { get; } //      ,   . void SetCurrentInputTo(InputData input); //    . void ConnectToGame(string roomId, string playerName, string playerId, INetworkPeer networkPeer); //    void ExitGamePlay(); //  void UpdateFrame(TimeData timeData); //     . }</span></span></code> </pre> <br>  In the implementation of the UpdateFrame method, IGameplayNetworkModel.ProcessNetwork (timeData) is called at the required moment.  The implementation constructor looks like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameplayModel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IGameplayNetworkModel gameplayNetworkModel</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  <b>What did it give us</b> <br><br>  This is already a full-fledged network client model for our game.  Theoretically, nothing more is needed to play.  Good practice is to write a separate user implementation of this abstraction as a console application.  The dotTrace and dotMemory tools came to our rescue, they are much clearer than the Unity profiler, and can additionally tell you what the problems are. <br><br>  In the process, we wrote several implementations of this interface, which gave us very cheap useful functionality: <br><br><ul><li>  <b>Record and play replays.</b>  When writing, the implementation stores the incoming data in a separate buffer.  And during playback, the implementation ignores user input and simply loses from the buffer, without requiring an instance of IGameplayNetworkModel at all. </li><li>  <b>Connection for technical tasks and testing.</b>  All that can be abstracted, it is often possible to automate: integration tests look succinctly and do not pull a bunch of tools of higher levels.  We also use this model to create test rooms and transfer the modified configuration from game designers within a specific batch. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Artifacts</b> <div class="spoiler_text">  <i>From a certain point on, graphic artifacts began to appear.</i>  <i>Characters and objects began to move with minor jerks and this was reproduced only on Android assemblies.</i>  <i>We had to go through everything - from the synchronization of time with the server to the interpolator formulas.</i>  <i>But in the end it turned out that the bug began to be reproduced after the transition from Unity version 2017.1.1p1 to 2017.4.1f1.</i>  <i>After research and communication with support, it turned out that there is a bug in the calculation of the Time.deltaTime engine - the time deltas do not correspond to the physical flow of time (they promised to <a href="https://issuetracker.unity3d.com/issues/android-unscaleddeltatime-and-deltatime-return-abnormal-slash-negtaive-values">fix it</a> in Unity 2018.2).</i>  <i>Due to the fact that we do not use Time.deltaTime directly in the code, we send TimeData through the Update tree, we easily edited it like this: we got Stopwatch at the very beginning of the code tree and used Stopwatch.Elapsed and counted the deltas manually, correcting only with Time. timeScale.</i> <br></div></div><br><h2>  General application model.  Encapsulating the launch of the application and reconnect to the game </h2><br><img src="https://habrastorage.org/webt/-5/jq/an/-5jqan6e1cgn8fiex51bvfe56gm.jpeg"><br>  At one point, our team came up with the task of reconnecting the player to the game if he somehow disappeared from the battlefield.  If everything is clear with the Internet turned off, in case <s>of the</s> application shutting down and its subsequent restarting, it didn‚Äôt immediately become clear how this feature should work.  It was not enough to expand the state collection of IGameplayModel, since its interface clearly indicates control over the work from the outside. <br><br>  The solution was: to create a state machine of a higher level, which would monitor the state of the gameplay model and re-connect when necessary.  In addition, at the start, the initial states of this machine should check the records of unfinished games and, if there are any, try to connect to the game to continue.  And in the final case, if such a game no longer exists on the server, then return to the standard state of readiness. <br><br>  List of states: <br><br><ul><li>  Starting an application with checking game entries. </li><li>  State of readiness for work. </li><li>  State "in the process of the game." </li><li>  Reconnect state. </li></ul><br>  The interface of this highest level model at the time looked like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IAppModel</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { ApplicationState ApplicationState { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//    .             . GameplayData GamePlayData { get; } //      void StartGamePlay(GameplayStartParameters parameters); void PlayReplay(Replay replay); void RefreshRoomsList(string serverAddress); // ,      void ExitGamePlay(); void SetLastGamePlayInput(Vector2 input, ISafeList&lt;SkillInputData&gt; skillButtonStates); //       . void SelectHero(int dropTeamMemberId, bool isConfirmed); //     void Update(TimeData timeData); // ,    . }</span></span></code> </pre> <br>  <b>What did it give us</b> <br><br>  This gave us not only an elegant solution to reconnecting between sessions, but also an extension tool for the initialization stages.  Somehow I will show how we used this tool to the fullest. <br><br><h2>  Preliminary results </h2><br>  By separating responsibilities and encapsulating responsibilities, our application combines many functions.  All components are interchangeable and some changes have little effect on others.  Dependencies can be displayed on a graph as a chain of links from wider elements to more specialized ones. <br><br>  In practice, this design gives very good indicators of support and code variability.  For us (taking into account all deadlines, short deadlines and ordinary everyday fabrication / change of features), code changes are lightweight, and the tasks on refactoring are not calculated in weeks. <br><br>  By the way, you may have noticed that I completely did not touch on the topic of interaction with the second server: <br><br><ul><li>  how the user is authorized; </li><li>  how the client receives data about the current player; </li><li>  how does the procedure of getting into battle; </li><li>  how do we get the result of the battle; </li><li>  how we restore the connection, taking into account already two connections to two servers. </li></ul><br>  This set of client responsibilities is also embedded in the dependency tree at the application model level and forms a separate large branch of types and relationships.  But more about that next time. </div><p>Source: <a href="https://habr.com/ru/post/354336/">https://habr.com/ru/post/354336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354324/index.html">Make Windows slower! Part One: File Access</a></li>
<li><a href="../354326/index.html">Using the MVC pattern when designing the tableview</a></li>
<li><a href="../354328/index.html">HOPE X. Conference "Breaking the elevator: from the basement to the penthouse." Part 1. "Elevator equipment"</a></li>
<li><a href="../354332/index.html">Edimax Office1-2-3 and what it is eaten with</a></li>
<li><a href="../354334/index.html">How we build DevOps in a team of 125 developers</a></li>
<li><a href="../354338/index.html">Miners will not pass</a></li>
<li><a href="../354340/index.html">We increase the disk mass without steroids. Overview of the Western Digital Ultrastar Data102 102 Disk Shelf and Storage Configuration</a></li>
<li><a href="../354342/index.html">Internship for atypical programmers</a></li>
<li><a href="../354344/index.html">Quest to eliminate heart arrhythmia</a></li>
<li><a href="../354346/index.html">HR Meetup. How to survive the explosive growth of the IT team</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>