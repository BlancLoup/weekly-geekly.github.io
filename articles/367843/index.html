<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32, C ++ and FreeRTOS. Development from scratch. Part 4 (Interrupts, UART and UnHART)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Conducting 
 Once on vacation in the city on the Neva and visiting many beautiful places, I still, in the evenings over a cup of beer, dealt with the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32, C ++ and FreeRTOS. Development from scratch. Part 4 (Interrupts, UART and UnHART)</h1><div class="post__text post__text-html js-mediator-article"><h4>  Conducting </h4><br>  Once on vacation in the city on the Neva and visiting many beautiful places, I still, in the evenings over a cup of beer, dealt with the UART.  Moreover, I bought good Fisher FA011 headphones, which I had to buy USB SOUND BLASTER X-FI HD and wanted to listen to music. <br>  Previous articles first moved to Geektime, then I overtook them back, I don‚Äôt even know where to put them now :) <br>  But just in case they are here: <br>  <a href="http://habrahabr.ru/post/261807//">STM32, C ++ and FreeRTOS.</a>  <a href="http://habrahabr.ru/post/261807//">Development from scratch.</a>  <a href="http://habrahabr.ru/post/261807//">Part 1</a> <br>  <a href="http://habrahabr.ru/post/261823/">STM32, C ++ and FreeRTOS.</a>  <a href="http://habrahabr.ru/post/261823/">Development from scratch.</a>  <a href="http://habrahabr.ru/post/261823/">Part 2</a> and <br>  <a href="http://habrahabr.ru/post/261837/">STM32, C ++ and FreeRTOS.</a>  <a href="http://habrahabr.ru/post/261837/">Development from scratch.</a>  <a href="http://habrahabr.ru/post/261837/">Part 3 (LCD and Screens)</a> <br><br><h4>  UART </h4><br>  After a detailed study of the microcontroller, it seemed to me that everything is simple.  Setup and test sending of a byte to the port went without a hitch, everything worked like a clock, and then I decided to use interrupts.  It was necessary to make the interrupt handler be a static class method.  And IAR in the compiler manual, and wrote: <br><blockquote>  Special function types can be used for static member functions.  For example, in the <br>  The following example is the interrupt function: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Device</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> __<span class="hljs-function"><span class="hljs-function">irq </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> </blockquote><br>  But bad luck, for Cortex M this method does not fit and <br><blockquote>  On the ARM Cortex-M, an interrupt service line <br>  normal function, which means no special keywords are required.  <b>Thus, the keywords</b> <b><br></b>  <b>__irq, __fiq, and __nested are not available when you compile for ARM Cortex-M.</b> <br>  These exception function names are defined in cstartup_M.c and cstartup_M.s. <br>  Vector code: <br>  NMI_Handler <br>  HardFault_Handler <br>  MemManage_Handler <br>  BusFault_Handler <br>  ... <br>  The vector table is implemented as an array.  It should always have the name <br>  __vector_table <br></blockquote><br>  Or simply, your interrupt handler must have the same name as it has in the vector table defined in the startup file.  This is done using a special keyword - the weak link __weak (in the PUBWEAK assembler), which means that this definition will be used until it is found that at least one matching letter is written without the keyword __week.  Well, that is, if you define a function with the exact same name without this directive, then the compiler will use this definition, and if you do not define, then it is marked with __weak. <br>  It is clear that I can‚Äôt insert C in the <b>startup_stm32l1xx_md.s</b> or <b>startup_stm32l1xx_md.c</b> file <b>.</b> C ++ name of the static method of the type <i>cUart :: USART2_IRQHandler ()</i> , the assembler simply won‚Äôt understand it. <br>  And just <i>‚ÄúUSART2_IRQHandler‚Äù</i> does not match the definition of <i>‚ÄúcUart :: USART2_IRQHandler ()‚Äù</i> . <br>  You can use <i>extern "C" {void USART2_IRQHandler (void) {...}}</i> , but this means that I will insert C from here, which I do not need at all, and in general access from such a function to the attributes of my class, for example the buffer will not, and it will be necessary to fence a bunch of ugly code :). <br>  Therefore, I decided to go the other way and create the <b>startup_stm32l1xx_md.cpp</b> file.  An Internet search found that some people had the exact same problem. <a href="http://community.arm.com/message/6214">For example,</a> <br>  In general, the idea is as follows: <b>We declare</b> classes with static methods in <b>startup_stm32l1xx_md.cpp</b> (which will be interrupt handlers), create a table __vector_table, where each interrupt vector has a pointer to these static methods.  Further we do __weak definition of each method <br>  And now when in the code the compiler sees the implementation of <i>void cUart1 :: handler ()</i> , it takes it without a second thought.  Of course, your classes and methods should be named exactly as defined in <b>startup_stm32l1xx_md.cpp</b> . <br>  It is necessary not to forget about the functions of FreeRtos: <i>vPortSVCHandler</i> , <i>xPortPendSVHandler</i> , <i>xPortSysTickHandler</i> and put them on the right interrupt and voila - everything works: <br><div class="spoiler">  <b class="spoiler_title">startup_stm32l1xx_md.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> language = extended #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> segment = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CSTACK"</span></span></span><span class="hljs-meta"> extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> void __iar_program_start( void ); extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> void vPortSVCHandler(void); extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> void xPortPendSVHandler(void); extern </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"C"</span></span></span><span class="hljs-meta"> void xPortSysTickHandler(void); class cNMI { public: static void handler(void); }; class cHardFault { public: static void handler(void); }; class cMemManage { public: static void handler(void); }; class cBusFault { public: static void handler(void); }; class cUsageFault { public: static void handler(void); }; class cDebugMon { public: static void handler(void); }; class cWindowWatchdog { public: static void handler(void); }; class cPvd { public: static void handler(void); }; class cTamperTimeStamp { public: static void handler(void); }; class cRtcWakeup { public: static void handler(void); }; class cFlash { public: static void handler(void); }; class cRcc { public: static void handler(void); }; class cExti { public: static void line0Handler(void); static void line1Handler(void); static void line2Handler(void); static void line3Handler(void); static void line4Handler(void); static void line9Handler(void); static void line15_10Handler(void); }; class cDma { public: static void channellHandler(void); static void channel2Handler(void); static void channel3Handler(void); static void channel4Handler(void); static void channel5Handler(void); static void channel6Handler(void); static void channel7Handler(void); }; class cAdc { public: static void handler(void); }; class cDac { public: static void handler(void); }; class cUsb { public: static void highPriorityHandler(void); static void lowPriorityHandler(void); static void fsWakeupHandler(void); }; class cComp { public: static void handler(void); }; class cLcdDriver { public: static void handler(void); }; class cTim9 { public: static void handler(void); }; class cTim2 { public: static void handler(void); }; class cTim3 { public: static void handler(void); }; class cTim4 { public: static void handler(void); }; class cTim10 { public: static void handler(void); }; class cTim6 { public: static void handler(void); }; class cTim7 { public: static void handler(void); }; class cTim11 { public: static void handler(void); }; class cI2C1 { public: static void eventHandler(void); static void errorHandler(void); }; class cI2C2 { public: static void eventHandler(void); static void errorHandler(void); }; class cSpi1 { public: static void handler(void); }; class cSpi2 { public: static void handler(void); }; class cUart1 { public: static void handler(void); }; class cUart2 { public: static void handler(void); }; class cUart3 { public: static void handler(void); }; class cRtcAlarm { public: static void handler(void); }; typedef void( *intfunc )( void ); typedef union { intfunc __fun; void * __ptr; } intvec_elem; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// The vector table is normally located at address 0. // When debugging in RAM, it can be located in RAM, aligned to at least 2^6. // If you need to define interrupt service routines, // make a copy of this file and include it in your project. // The name "__vector_table" has special meaning for C-SPY: // it is where the SP start value is found, and the NVIC vector // table register (VTOR) is initialized to this address if != 0. #pragma location = ".intvec" extern "C" const intvec_elem __vector_table[] = { { .__ptr = __sfe( "CSTACK" ) }, __iar_program_start, cNMI::handler, cHardFault::handler, cMemManage::handler, cBusFault::handler, cUsageFault::handler, 0, 0, 0, 0, vPortSVCHandler, // freeRTOS  ! cDebugMon::handler, 0, xPortPendSVHandler, // freeRTOS  ! xPortSysTickHandler, // freeRTOS  ! //External Interrupts cWindowWatchdog::handler, //Window Watchdog cPvd::handler, //PVD through EXTI Line detect cTamperTimeStamp::handler, //Tamper and Time Stamp cRtcWakeup::handler, //RTC Wakeup cFlash::handler, //FLASH cRcc::handler, //RCC cExti::line0Handler, //EXTI Line 0 cExti::line1Handler, //EXTI Line 1 cExti::line2Handler, //EXTI Line 2 cExti::line3Handler, //EXTI Line 3 cExti::line4Handler, //EXTI Line 4 cDma::channellHandler, //DMA1 Channel 1 cDma::channel2Handler, //DMA1 Channel 2 cDma::channel3Handler, //DMA1 Channel 3 cDma::channel4Handler, //DMA1 Channel 4 cDma::channel5Handler, //DMA1 Channel 5 cDma::channel6Handler, //DMA1 Channel 6 cDma::channel7Handler, //DMA1 Channel 7 cAdc::handler, //ADC1 cUsb::highPriorityHandler, //USB High Priority cUsb::lowPriorityHandler, //USB Low Priority cDac::handler, //DAC cComp::handler, //COMP through EXTI Line cExti::line9Handler, //EXTI Line 9..5 cLcdDriver::handler, //LCD cTim9::handler, //TIM9 cTim10::handler, //TIM10 cTim11::handler, //TIM11 cTim2::handler, //TIM2 cTim3::handler, //TIM3 cTim4::handler, //TIM4 cI2C1::eventHandler, //I2C1 Event cI2C1::errorHandler, //I2C1 Error cI2C2::eventHandler, //I2C2 Event cI2C2::errorHandler, //I2C2 Error cSpi1::handler, //SPI1 cSpi2::handler, //SPI2 cUart1::handler, //USART1 cUart2::handler, //USART2 cUart3::handler, //USART3 cExti::line15_10Handler, //EXTI Line 15..10 cRtcAlarm::handler, //RTC Alarm through EXTI Line cUsb::fsWakeupHandler, //USB FS Wakeup from suspend cTim6::handler, //TIM6 cTim7::handler //TIM7 }; __weak void cNMI::handler() { while (1) {} } __weak void cHardFault::handler() { while (1) {} } __weak void cMemManage::handler() { while (1) {} } __weak void cBusFault::handler() { while (1) {} } __weak void cUsageFault::handler() { while (1) {} } __weak void cDebugMon::handler() { while (1) {} } __weak void cWindowWatchdog::handler() { while (1) {} } __weak void cPvd::handler() { while (1) {} } __weak void cTamperTimeStamp::handler() { while (1) {} } __weak void cRtcWakeup::handler() { while (1) {} } __weak void cFlash::handler() { while (1) {} } __weak void cRcc::handler() { while (1) {} } __weak void cExti::line0Handler() { while (1) {} } __weak void cExti::line1Handler() { while (1) {} } __weak void cExti::line2Handler() { while (1) {} } __weak void cExti::line3Handler() { while (1) {} } __weak void cExti::line4Handler() { while (1) {} } __weak void cExti::line9Handler() { while (1) {} } __weak void cExti::line15_10Handler() { while (1) {} } __weak void cDma::channellHandler() { while (1) {} } __weak void cDma::channel2Handler() { while (1) {} } __weak void cDma::channel3Handler() { while (1) {} } __weak void cDma::channel4Handler() { while (1) {} } __weak void cDma::channel5Handler() { while (1) {} } __weak void cDma::channel6Handler() { while (1) {} } __weak void cDma::channel7Handler() { while (1) {} } __weak void cAdc::handler() { while (1) {} } __weak void cUsb::fsWakeupHandler() { while (1) {} } __weak void cUsb::highPriorityHandler() { while (1) {} } __weak void cUsb::lowPriorityHandler() { while (1) {} } __weak void cDac::handler() { while (1) {} } __weak void cComp::handler() { while (1) {} } __weak void cLcdDriver::handler() { while (1) {} } __weak void cTim2::handler() { while (1) {} } __weak void cTim3::handler() { while (1) {} } __weak void cTim4::handler() { while (1) {} } __weak void cTim6::handler() { while (1) {} } __weak void cTim7::handler() { while (1) {} } __weak void cTim9::handler() { while (1) {} } __weak void cTim10::handler() { while (1) {} } __weak void cTim11::handler() { while (1) {} } __weak void cI2C1::errorHandler() { while (1) {} } __weak void cI2C1::eventHandler() { while (1) {} } __weak void cI2C2::errorHandler() { while (1) {} } __weak void cI2C2::eventHandler() { while (1) {} } __weak void cSpi1::handler() { while (1) {} } __weak void cSpi2::handler() { while (1) {} } __weak void cUart1::handler() { while (1) {} } __weak void cUart2::handler() { while (1) {} } __weak void cUart3::handler() { while (1) {} } __weak void cRtcAlarm::handler() { while (1) {} } extern "C" void __cmain( void ); extern "C" __weak void __iar_init_core( void ); extern "C" __weak void __iar_init_vfp( void ); #pragma required=__vector_table void __iar_program_start( void ) { __iar_init_core(); __iar_init_vfp(); __cmain(); }</span></span></span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/files/90c/88d/ced/90c88dcedc674d00b441b6193653f0e0.png" alt="image"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  DWART.  Receive message transfer </h4><br>  So, with the interrupts figured out, now you can take up the implementation of a thread of a simple protocol.  Modbus was dropped immediately - not very difficult :).  Search for popular protocols for devices issued - HART, an industrial protocol for devices such as pressure sensors, temperature sensors and flowmeters - is perfect. <br>  And the task that I set for myself will be communicating via this protocol with the device setup program, say <b>Pactware</b> , or the <b>Elemental</b> <a href="http://www.elemer.ru/po/hart_config.php">HARTConfig</a> , <b>having</b> <a href="http://www.elemer.ru/po/hart_config.php">faked</a> some popular sensor, for example, a pressure sensor - Yokogawa EJA, so that this program doesn‚Äôt detect .  I must say that everything turned out :) <br><img src="https://habrastorage.org/files/c0b/6bb/118/c0b6bb11812a4019ae5b1259db13da75.png" alt="image"><br>  And even managed to remove the trend in air temperature, measured by the internal temperature sensor of the microcontroller: <br><img src="https://habrastorage.org/files/20a/8de/226/20a8de226020413fb04a83fe55cbe3cd.png" alt="image"><br><br>  This is how my Pactware device is seen :) <br><img src="https://habrastorage.org/files/ff7/db5/a14/ff7db5a146c14330bf1469aa0397218a.png" alt="image"><br><br>  Normal HART documentation is closed.  But I managed to find fragmentary descriptions that would be fine for my demo project.  Here is an example of one of these resources: <a href="http://hart2dde.narod.ru/hartdesc.html">Description of the HART protocol</a> or here is the <a href="http://cyberleninka.ru/article/n/realizatsiya-hart-protokola-na-osnove-modeli-iso-osi">OSI HART Model Protocol</a> <br>  In short - on the line there is a master (main) and slave (slave) device.  The main thing sends requests, the slave responds at a speed of 1200 bits per second - everything is simple. <br>  There may be two main devices on the line, but I will simply communicate with ONE RS232 master. <br>  For the same reason, I don‚Äôt need to particularly follow the bus arbitration and determine when it‚Äôs difficult to have a token, and when not, and the whole arbitration in my case is only that - I have the token, after 2 symbols of silence on the line.  At a speed of 1200 bits per second it is approximately 19 ms.  Those.  if within 19 ms, I have no interruption in reception - the parcel is considered accepted, and the token is with me, I can answer and should start responding within about 250 ms, otherwise the token will go to the master again. <br>  In general, I called this protocol <b>Dwart</b> , a symbiosis between Dwarf - dwarf, gnome and HART. <br>  First you need to select the entity that will operate: <br><br><ul><li>  Link level ( <b>LinkLayer</b> ) - will be responsible just for sending and transmitting messages, as well as for determining the end of receiving a request from the master </li><li>  The transmission end determination timer ( <b>LinkLayerTimer</b> ) is a 19 ms timer, after which it will be considered that the request from the master has been accepted.  The timer should start after each received byte. </li><li>  Frame ( <b>Frame</b> ) - is responsible for parsing and framing HART parcels. </li><li>  Commands ( <b>Command</b> ) - is responsible for the implementation of a separate command. </li><li>  The main class itself ( <b>Dwart</b> ) - he will manage all this business </li></ul><br>  In order to observe the principle of puff pie - the classes of the lower layer will not know about the classes of the layer located above, i.e.  For example, Command will work only with Frame, and Frame with LinkLayer, while LinkLayer will not know anything about Command and Frame, and Frame about Command. <br>  So what is the idea - to accept bytes until the silence timer has been activated, then to notify Dwart, which will call the parsing method of the received message and, depending on the request, execute the necessary command. <br>  In general, ideally, say when requesting command 1 from the master, I want the answer to it to look something like this: <br><pre> <code class="cpp hljs">Command1.Response.PrimaryVariable = <span class="hljs-number"><span class="hljs-number">3.54</span></span> Command1.Send();</code> </pre><br>  First, let's estimate the channel level, this figure shows only public methods, so as not to litter the picture. <br><img src="https://habrastorage.org/files/792/bdc/a96/792bdca962244370aa6fc3deca463561.png" alt="image"><br><br>  I will clarify the picture a bit, the methods of the interrupt handler are static, and in order to access the methods and fields of the class instance in these static methods, it is necessary that either the fields and methods are also static, or they can be addressed directly to the class instance.  I went to the second - the right way, referring to a specific instance of the class, which I initialize in the constructor with the <b>this</b> pointer. <br>  LinkLayer will receive bytes from the UART port and add them to the receive buffer. <br>  But since HART has 0xFF synchronization bytes, called preambles, and their number can reach 20, (and we don‚Äôt need them at all, because they don‚Äôt carry any information, and all we need is to determine the beginning of the frame by sequence ( 0xFF 0xFF &lt;start byte&gt;)), it will waste 20 preambles to the buffer, so I‚Äôll just watch them right in the interrupt and as soon as they run out, I‚Äôll start to add bytes to the buffer. <br>  After receiving each byte, I will restart the timer for 19 ms, if it works, the package is considered to be accepted. <br>  Another task is to notify the linklayer from the linklayertimer class as soon as the timer interrupt is triggered, indicating the end of receiving the request from the master.  For this, I used the Designer Observer template, as a result LinkLayer simply subscribes to events from LinkLayerTimer. It looks like this: <br><div class="spoiler">  <b class="spoiler_title">linklayertimer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537    #include "observable.h" //lint !e537  iObservable class cLinkLayerTimer : public iObservable { public: explicit cLinkLayerTimer(tU16 timeout); void start(void) const; private: static void irqHandler(void); static cLinkLayerTimer* instance; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">linklayertimer.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"linklayertimer.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537    #include "susuassert.h" //lint !e537  ASSERT #include &lt;stdio.h&gt; //lint !e537  NULL cLinkLayerTimer* cLinkLayerTimer::instance = NULL; /******************************************************************************* * Function: constructor * Description:    TIM2 ******************************************************************************/ cLinkLayerTimer::cLinkLayerTimer(tU16 timeout) { ASSERT(instance != NULL); this-&gt;instance = this; TIM2-&gt;ARR = (uint16_t)timeout; } /******************************************************************************* * Function: start * Description:  .     ******************************************************************************/ void cLinkLayerTimer::start(void) const { TIM2-&gt;CNT = (uint16_t)0; TIM2-&gt;CR1 |= TIM_CR1_CEN; } /******************************************************************************* * Function: irqHandler * Description:     . *     ,   ******************************************************************************/ void cLinkLayerTimer::irqHandler(void) { ASSERT(instance != NULL); instance-&gt;notifyObservers(); TIM2-&gt;CR1 &amp;=~ TIM_CR1_CEN; TIM2-&gt;SR &amp;= ~TIM_SR_UIF; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">linklayer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537    #include "linklayertimer.h" //lint !e537  cLinkLayerTimer #include "observer.h" //lint !e537  iObserver #define PREAMBUL_SYMBOL (uint16_t) 0xFF typedef enum { LLS_none = 0, LLS_write = 1, LLS_writeComplete = 2, LLS_readComplete = 3, LLS_error = 4 } tLinkLayerStatus; class cLinkLayer : private iObserver, public iObservable { public: explicit cLinkLayer(tU8 *pRxBuf, const tU8 rxBufSize,tU8 *pTxBuf, const tU8 preambulCount); void writeData(tU8 dataSize); tLinkLayerStatus getStatus() const { return eStatus; }; virtual void eventHandle(const iObservable* pObservable); tU8* pTxBuffer; tU8* pRxBuffer; private: static void irqHandler(void); static cLinkLayer* instance; void endMessageHandler(void); void enableReceive(void) const { USART2-&gt;CR1 |= USART_CR1_RXNEIE;}; //lint !e639 !e511    void disableReceive(void){USART2-&gt;CR1 &amp;=~ USART_CR1_RXNEIE;};//lint !e639 !e511    void enableTransmit(void) const { USART2-&gt;CR1 |= USART_CR1_TCIE; };//lint !e639 !e511    void disableTransmit(void) const { USART2-&gt;CR1 &amp;=~ USART_CR1_TCIE; };//lint !e639 !e511    tLinkLayerStatus eStatus; cLinkLayerTimer* pEndTransmitTimer; tU8 rxBufferSize; tU8 rxBufferIndex; tU8 txBufferIndex; tU8 txBufferSize; tU8 preambulsCount; tU8 preambulIndex; tBoolean readPreambuls; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">linllayer.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stm32l1xx.h&gt; //lint !e537  STM32 #include "linklayer.h" //lint !e537    #include "susuassert.h" //lint !e537  ASSERT #include "bitutil.h" //lint !e537      SETBIT, CLRBIT #include &lt;stdio.h&gt; //lint !e537  NULL #define END_MESSAGE_TIMEOUT (tU16) 19 #define GOOD_COUNT_RX_PREAMBULS (tU8) 2 cLinkLayer* cLinkLayer::instance = NULL; /******************************************************************************* * Function: constructor * Description:       ******************************************************************************/ cLinkLayer::cLinkLayer(tU8 *pRxBuf, const tU8 rxBufSize,tU8 *pTxBuf, const tU8 preambulCount) { ASSERT (rxBuffer != NULL); ASSERT (txBuffer != NULL); //     3 ASSERT(preambulCount &gt; (tU8)2); this-&gt;preambulsCount = preambulCount; this-&gt;preambulIndex = (tU8)0; this-&gt;readPreambuls = TRUE; this-&gt;pRxBuffer = pRxBuf; this-&gt;rxBufferSize = rxBufSize; this-&gt;rxBufferIndex = (tU8)0; this-&gt;pTxBuffer = pTxBuf; this-&gt;txBufferSize = (tU8)0; this-&gt;txBufferIndex = (tU8)0; this-&gt;eStatus = LLS_none; this-&gt;instance = this; this-&gt;pEndTransmitTimer = new cLinkLayerTimer(END_MESSAGE_TIMEOUT); //    this-&gt;pEndTransmitTimer-&gt;addObserver(this); this-&gt;disableTransmit(); this-&gt;enableReceive(); } /******************************************************************************* * Function: writeData * Description:  ,     ******************************************************************************/ void cLinkLayer::writeData(tU8 dataSize) { //    ,     ,    // if (this-&gt;eStatus != LLS_write) { this-&gt;disableReceive(); this-&gt;txBufferSize = dataSize; this-&gt;eStatus = LLS_write; USART2-&gt;DR = PREAMBUL_SYMBOL; this-&gt;preambulIndex ++; this-&gt;enableTransmit(); } } /******************************************************************************* * Function: handler * Description:   ******************************************************************************/ void cLinkLayer::irqHandler(void) { ASSERT(instance != NULL); // if (USART2-&gt;SR &amp; USART_SR_TC) { //    ,   3   if (instance-&gt;preambulIndex != instance-&gt;preambulsCount) { USART2-&gt;DR = PREAMBUL_SYMBOL; instance-&gt;preambulIndex ++; } else { //  -    if(instance-&gt;txBufferIndex &lt; instance-&gt;txBufferSize) { USART2-&gt;DR = (uint16_t)instance-&gt;pTxBuffer[instance-&gt;txBufferIndex++]; } else { instance-&gt;txBufferIndex = (tU8)0; instance-&gt;txBufferSize = (tU8)0; instance-&gt;disableTransmit(); instance-&gt;eStatus = LLS_writeComplete; instance-&gt;preambulIndex = (tU8)0; instance-&gt;readPreambuls = TRUE; instance-&gt;enableReceive(); } } USART2-&gt;SR &amp;=~ USART_SR_TC; }; // if (USART2-&gt;SR &amp; USART_SR_RXNE) { instance-&gt;pRxBuffer[instance-&gt;rxBufferIndex] = (tU8)USART2-&gt;DR; instance-&gt;pEndTransmitTimer-&gt;start(); //    if (instance-&gt;readPreambuls) { if (instance-&gt;pRxBuffer[instance-&gt;rxBufferIndex] == (tU8)PREAMBUL_SYMBOL) { instance-&gt;preambulIndex++; } else { instance-&gt;readPreambuls = FALSE; instance-&gt;rxBufferIndex++; } } else { //      2 if ((instance-&gt;rxBufferIndex &lt;= instance-&gt;rxBufferSize) &amp;&amp; (instance-&gt;preambulIndex &gt;= GOOD_COUNT_RX_PREAMBULS)) { instance-&gt;rxBufferIndex++; } else { instance-&gt;eStatus = LLS_error; instance-&gt;preambulIndex = (tU8)0; } } } } /******************************************************************************* * Function: endMessageHandler * Description:    ******************************************************************************/ void cLinkLayer::endMessageHandler(void) { this-&gt;eStatus = LLS_readComplete; this-&gt;rxBufferIndex = (tU8) 0; this-&gt;readPreambuls = TRUE; instance-&gt;preambulIndex = (tU8)0; } /******************************************************************************* * Function: eventHandle * Description:     ******************************************************************************/ void cLinkLayer::eventHandle(const iObservable* pObservable) { this-&gt;endMessageHandler(); this-&gt;notifyObservers(); } //lint !e715    pObservable</span></span></span></span></code> </pre><br></div></div><br>  LinkLayer itself also notifies the end of the acceptance of the request from the master of its subscribers - we need it later <br><br><h4>  DWART.  Parsing and shaping the HART frame </h4><br>  Next, let's deal with the cFrame class, it will decode requests from the wizard, as well as form response frames and use LinkLayer to send them: <br><img src="https://habrastorage.org/files/2bf/dcb/294/2bfdcb294773472eadbd57fc162eca95.png" alt="image"><br><br>  Implementation: <br><div class="spoiler">  <b class="spoiler_title">frame.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537    tBoolean #include "linklayer.h" //lint !e537  cLinkLayer #define LONG_ADDRESS_LENGTH (tU8)5 #define DATA_LENGTH (tU8)255 typedef enum { FE_good = 0, FE_addrError = 1, FE_comError = 2, FE_dataCountError = 3, FE_checkSummError = 4, FE_preambulsError = 5, FE_genericError = 6 } tFrameError; typedef struct { //   tU8 preambulsCount; //   tU8 startByte; //   tU8 shortAddr; //   tU8 longAddr[LONG_ADDRESS_LENGTH]; //  tU8 command; //   tU8 dataCount; // tU8 *pData; //   tU8 checkSumm; } tMasterFrame; class cFrame { public: cFrame(tU8* pLongAddress, const tU8 shortAddress, cLinkLayer *pLnkLayer); tU8* buildFrameBeforeData (const tU8 commandNumber, const tU8 dataLength); tU8 getCurrentCommand(void) const { return this-&gt;masterFrame.command; } tFrameError decode(void); void setCheckSumm(void); void send(void); private: tU8 getCheckSumm(const tU8 *pData, const tU8 dataLength) const; cLinkLayer *pLinkLayer; tU8 deviceShortAddress; tU8 *pDeviceId; tU8 bufferSize; tMasterFrame masterFrame; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">frame.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susuassert.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537  ASSERT #include "frame.h" //lint !e537     #include &lt;stddef.h&gt; //lint !e537  NULL #define LONG_ADDRESS_MASK (tU8)0x80 #define SLAVE_MASK (tU8)0x7F #define START_BYTE_SLAVE_SHORT_FRAME (tU8) 6 #define START_BYTE_SLAVE_LONG_FRAME (tU8) 0x86 /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ cFrame::cFrame(tU8* pLongAddress, const tU8 shortAddress, cLinkLayer *pLnkLayer) { ASSERT(pLnkLayer != NULL); ASSERT(pLongAddress != NULL); //      64 ASSERT(shortAddress &lt;= (tU8)64); this-&gt;pLinkLayer = pLnkLayer; this-&gt;pDeviceId = pLongAddress; this-&gt;deviceShortAddress = shortAddress; this-&gt;bufferSize = (tU8)0; } /******************************************************************************* * Function: decode * Description:  ,   ******************************************************************************/ tFrameError cFrame::decode(void) { tU8 index = (tU8)0; tU8 cnt = (tU8)0; tFrameError eResult = FE_good; this-&gt;masterFrame.startByte = this-&gt;pLinkLayer-&gt;pRxBuffer[index]; index ++; //         if (this-&gt;masterFrame.startByte &amp; LONG_ADDRESS_MASK) { for (tU8 i = (tU8)0; i &lt; LONG_ADDRESS_LENGTH; i ++) { this-&gt;masterFrame.longAddr[i] = this-&gt;pLinkLayer-&gt;pRxBuffer[index]; index ++; } } else { this-&gt;masterFrame.shortAddr = this-&gt;pLinkLayer-&gt;pRxBuffer[index]; index ++; } //   this-&gt;masterFrame.command = this-&gt;pLinkLayer-&gt;pRxBuffer[index]; index ++; //     this-&gt;masterFrame.dataCount = this-&gt;pLinkLayer-&gt;pRxBuffer[index]; index ++; //        if (this-&gt;masterFrame.dataCount != (tU8)0) { this-&gt;masterFrame.pData = (tU8*)&amp;this-&gt;pLinkLayer-&gt;pRxBuffer[index]; } index = index + this-&gt;masterFrame.dataCount; //,      DATA_LENGTH if(masterFrame.dataCount &lt; DATA_LENGTH ) { //    this-&gt;masterFrame.checkSumm = this-&gt;getCheckSumm((tU8*)&amp;this-&gt;pLinkLayer-&gt;pRxBuffer[cnt], index - cnt); //************************   *********************** //    if(this-&gt;pLinkLayer-&gt;pRxBuffer[index] != this-&gt;masterFrame.checkSumm) { eResult = FE_checkSummError; } //    if (this-&gt;masterFrame.startByte &amp; LONG_ADDRESS_MASK) { if ((this-&gt;masterFrame.longAddr[0] &amp; SLAVE_MASK) != (this-&gt;pDeviceId[0] &amp; SLAVE_MASK)) { eResult = FE_addrError; } else { for (tU8 i = (tU8)1; i &lt; LONG_ADDRESS_LENGTH; i ++) { if (this-&gt;masterFrame.longAddr[i] != this-&gt;pDeviceId[i]) { eResult = FE_addrError; break; } this-&gt;pDeviceId[0] = this-&gt;masterFrame.longAddr[0]; } } } else { if((this-&gt;masterFrame.shortAddr &amp; SLAVE_MASK) != (this-&gt;deviceShortAddress &amp; SLAVE_MASK)) { eResult = FE_addrError; } else { this-&gt;deviceShortAddress = this-&gt;masterFrame.shortAddr; } } } else { eResult = FE_dataCountError; } return eResult; } /******************************************************************************* * Function: buildFrameBeforeData * Description:    ,      *  .      ******************************************************************************/ tU8* cFrame::buildFrameBeforeData(const tU8 commandNumber, const tU8 dataLength) { tU8 index = (tU8)0; // ,         if (!(this-&gt;masterFrame.startByte &amp; LONG_ADDRESS_MASK)) { this-&gt;pLinkLayer-&gt;pTxBuffer[index] = START_BYTE_SLAVE_SHORT_FRAME; index ++; this-&gt;pLinkLayer-&gt;pTxBuffer[index] = this-&gt;deviceShortAddress; index ++; } else { this-&gt;pLinkLayer-&gt;pTxBuffer[index] = START_BYTE_SLAVE_LONG_FRAME; index ++; for (tU8 i = (tU8)0; i &lt; LONG_ADDRESS_LENGTH; i ++) { this-&gt;pLinkLayer-&gt;pTxBuffer[index] = this-&gt;pDeviceId[i]; index ++; } } //       this-&gt;pLinkLayer-&gt;pTxBuffer[index] = commandNumber; index ++; this-&gt;pLinkLayer-&gt;pTxBuffer[index] = dataLength; index ++; this-&gt;bufferSize = index + dataLength; return (tU8*)&amp;this-&gt;pLinkLayer-&gt;pTxBuffer[index]; } /******************************************************************************* * Function: setCheckSumm * Description:        ******************************************************************************/ void cFrame::setCheckSumm(void) { this-&gt;pLinkLayer-&gt;pTxBuffer[this-&gt;bufferSize] = this-&gt;getCheckSumm(this-&gt;pLinkLayer-&gt;pTxBuffer, this-&gt;bufferSize); this-&gt;bufferSize++; } /******************************************************************************* * Function: getCheckSumm * Description:    ******************************************************************************/ tU8 cFrame::getCheckSumm(const tU8 *pData, const tU8 dataLength) const { tU8 index = (tU8) 0; tU8 checkSumm = (tU8)0; for (index = (tU8)0; index &lt; dataLength; index ++) { if(pData != NULL) { checkSumm = checkSumm ^ pData[index]; } else { checkSumm = (tU8) 0; } } return checkSumm; } /******************************************************************************* * Function: send * Description:   ******************************************************************************/ void cFrame::send(void) { this-&gt;pLinkLayer-&gt;writeData(this-&gt;bufferSize); }</span></span></span></span></code> </pre><br></div></div><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DWART. </font><font style="vertical-align: inherit;">Team building</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now the most interesting thing is that the teams, as I have already said, would like to make everything look beautiful, and it was possible to contact the teams comfortably ‚Äî and </font></font><pre> <code class="cpp hljs"> Command0.Response.PrimaryVariable = <span class="hljs-number"><span class="hljs-number">3.54</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is clear that if for each command I keep the whole Response response structure, and there can be 254 commands, then I don‚Äôt have enough memory, so I will only store a pointer to the Response response structure, and each time assign this pointer a pointer to the data in the transfer buffer, which I will receive using the buildFrameBeforeData class method withFrame. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For all the teams I will do the basic interface iBaseDwartCommand with common methods, and since I have requests and responses from each command of different lengths and different types, I will create a template class derived from iDwartCommand. Approximately it looks like this: </font></font><br><img src="https://habrastorage.org/files/043/332/ce9/043332ce9f194ae1a7c3065fd08ee131.png" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Command 0 - returns just information about the device.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commands 1 - returns the value of the primary variable, in my case it is with Trimmer, access to which is provided by the cVariablesDirector class, so I must pass it in the constructor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, filling in the data of command 1 looks like this:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> cCommand1::setNewData(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//          this-&gt;pResponse = (tCommand1Response*) this-&gt;pFrame-&gt;buildFrameBeforeData(COMMAND1, (tU8)sizeof(tCommand1Response)); //lint !e826   this-&gt;pResponse-&gt;status1 = (tU8)0; this-&gt;pResponse-&gt;status2 = (tU8)0; this-&gt;pResponse-&gt;PrimaryVariableUnits = (tU8) pVariablesDirector-&gt;pTrimmer-&gt;getUnits(); this-&gt;pResponse-&gt;PrimaryVariableValue = cConversion&lt;tF32&gt;::swap(pVariablesDirector-&gt;pTrimmer-&gt;getValue()); this-&gt;pFrame-&gt;setCheckSumm(); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, the cConversion class's swap method is used to swap bytes in places, since HART uses the Big Endian view, and my microcontroller is Little Endian. </font><font style="vertical-align: inherit;">Well, almost got what I wanted :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fully the whole implementation looks like this:</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basedwartcommand.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iBaseDwartCommand</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setNewData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dwartcommand.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"frame.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537  cFrame #include "basecommand.h" //lint !e537  iBaseDwartCommand #include "susuassert.h" //lint !e537  ASSERT template &lt;class req, class resp&gt; class iDwartCommand : public iBaseDwartCommand { public: explicit iDwartCommand(cFrame *pDwratFrame); req *pRequest; resp *pResponse; void send(void); protected: cFrame *pFrame; }; /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ template &lt;class req, class resp&gt; iDwartCommand&lt;req, resp&gt;::iDwartCommand(cFrame *pDwartFrame) { ASSERT (pFrame != NULL); this-&gt;pFrame = pDwartFrame; } /******************************************************************************* * Function: send * Description:   ******************************************************************************/ template &lt;class req, class resp&gt; void iDwartCommand&lt;req, resp&gt;::send(void) { this-&gt;pFrame-&gt;send(); }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">command0.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537  iDwartCommand #define COMMAND0 (tU8)0 #pragma pack(push, 1) typedef struct { tU8 status1; tU8 status2; tU8 expansion; tU8 manufacturer; tU8 deviceType; tU8 numberOfpreambuls; tU8 universalCommandRevision; tU8 deviceSpecificCommandRevision; tU8 softwareRevision; tU8 hardwareRevision; tU8 deviceFlags; tU8 deviceID[3]; } tCommand0Response; typedef struct { } tCommand0Request; #pragma pack(pop) class cCommand0: public iDwartCommand&lt;tCommand0Request, tCommand0Response&gt; { public: explicit cCommand0(cFrame *pDwartFrame); virtual void setNewData(void); };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">command0.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">include <span class="hljs-string"><span class="hljs-string">"susuassert.h"</span></span> <span class="hljs-comment"><span class="hljs-comment">//lint !e537  ASSERT #include "command0.h" //lint !e537   #include "frame.h" //lint !e537  Frame #include "conversion.h" //lint !e537  cConversion /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ cCommand0::cCommand0(cFrame *pDwartFrame): iDwartCommand(pDwartFrame) { } /******************************************************************************* * Function: setNewData * Description:     ******************************************************************************/ void cCommand0::setNewData(void) { //          this-&gt;pResponse = (tCommand0Response*) this-&gt;pFrame-&gt;buildFrameBeforeData(COMMAND0, (tU8)sizeof(tCommand0Response)); //lint !e826   this-&gt;pResponse-&gt;status1 = (tU8)0; this-&gt;pResponse-&gt;status2 = (tU8)0; this-&gt;pResponse-&gt;manufacturer = (tU8)0x37; this-&gt;pResponse-&gt;deviceType = (tU8)0x04; this-&gt;pResponse-&gt;expansion = (tU8)0; this-&gt;pResponse-&gt;deviceSpecificCommandRevision = (tU8)5; this-&gt;pResponse-&gt;universalCommandRevision = (tU8)5; this-&gt;pResponse-&gt;hardwareRevision = (tU8)1; this-&gt;pResponse-&gt;softwareRevision = (tU8)201; this-&gt;pResponse-&gt;numberOfpreambuls = (tU8)5; this-&gt;pResponse-&gt;deviceID[0] = (tU8)0; this-&gt;pResponse-&gt;deviceID[1] = (tU8)0; this-&gt;pResponse-&gt;deviceID[2] = (tU8)1; this-&gt;pResponse-&gt;deviceFlags = (tU8)0; this-&gt;pFrame-&gt;setCheckSumm(); }</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">command1.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537  iDwartCommand #include "variablesdirector.h" //lint !e537  cVariablesDirector #define COMMAND1 (tU8)1 #pragma pack(push, 1) typedef struct { tU8 status1; tU8 status2; tU8 PrimaryVariableUnits; tF32 PrimaryVariableValue; } tCommand1Response; typedef struct { } tCommand1Request; #pragma pack(pop) class cCommand1: public iDwartCommand&lt;tCommand1Request, tCommand1Response&gt; { public: explicit cCommand1(cFrame *pDwartFrame,cVariablesDirector *pVarsDirector); virtual void setNewData(void); private: cVariablesDirector *pVariablesDirector; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">command1.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susuassert.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537  ASSERT #include "command1.h" //lint !e537   #include "frame.h" //lint !e537  Frame #include "conversion.h" //lint !e537  cConversion /******************************************************************************* * Function: constructor * Description: ******************************************************************************/ cCommand1::cCommand1(cFrame *pDwartFrame, cVariablesDirector *pVarsDirector): iDwartCommand(pDwartFrame) { ASSERT(pVarsDirector != NULL); this-&gt;pVariablesDirector = pVarsDirector; } /******************************************************************************* * Function: setNewData * Description:     ******************************************************************************/ void cCommand1::setNewData(void) { //          this-&gt;pResponse = (tCommand1Response*) this-&gt;pFrame-&gt;buildFrameBeforeData(COMMAND1, (tU8)sizeof(tCommand1Response)); //lint !e826   this-&gt;pResponse-&gt;status1 = (tU8)0; this-&gt;pResponse-&gt;status2 = (tU8)0; this-&gt;pResponse-&gt;PrimaryVariableUnits = (tU8) pVariablesDirector-&gt;pTrimmer-&gt;getUnits(); this-&gt;pResponse-&gt;PrimaryVariableValue = cConversion&lt;tF32&gt;::swap(pVariablesDirector-&gt;pTrimmer-&gt;getValue()); this-&gt;pFrame-&gt;setCheckSumm(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other teams are built on the same principle. </font><font style="vertical-align: inherit;">I have a large memory reserve, I decided that it would be nice for all the teams, and they could be up to 254 to throw them into one array, then I will explain why I thought it was convenient. </font><font style="vertical-align: inherit;">I just created the cCommandSet container class:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"command.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537  iDwartCommand #include "variablesdirector.h" //lint !e537  cVariablesDirector #define COMMANDS_COUNT 254 class cCommandSet { public: cCommandSet(cFrame *pFrame, cVariablesDirector *pVariablesDirector); iBaseDwartCommand *pCommands[COMMANDS_COUNT]; };</span></span></span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order for the two programs Pactware and HartConfig to take me for Yokogawa, I need to implement a minimum set of commands, and put them in a container. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commandset.cpp looks like this:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susuassert.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537  ASSERT #include "commandset.h" //lint !e537   #include "command0.h" //lint !e537  cCommand0 #include "command1.h" //lint !e537  cCommand1 #include "command2.h" //lint !e537  cCommand2 #include "command3.h" //lint !e537  cCommand3 #include "command12.h" //lint !e537  cCommand12 #include "command13.h" //lint !e537  cCommand13 #include "command14.h" //lint !e537  cCommand14 #include "command15.h" //lint !e537  cCommand15 #include "command157.h" //lint !e537  cCommand157 #include "command159.h" //lint !e537  cCommand159 #include "command160.h" //lint !e537  cCommand160 #include "command180.h" //lint !e537  cCommand180 cCommandSet::cCommandSet(cFrame *pFrame, cVariablesDirector *pVariablesDirector) { this-&gt;pCommands[COMMAND0] = new cCommand0(pFrame); this-&gt;pCommands[COMMAND1] = new cCommand1(pFrame, pVariablesDirector ); this-&gt;pCommands[COMMAND2] = new cCommand2(pFrame, pVariablesDirector ); this-&gt;pCommands[COMMAND3] = new cCommand3(pFrame, pVariablesDirector ); this-&gt;pCommands[COMMAND13] = new cCommand13(pFrame); this-&gt;pCommands[COMMAND12] = new cCommand12(pFrame); this-&gt;pCommands[COMMAND14] = new cCommand14(pFrame); this-&gt;pCommands[COMMAND15] = new cCommand15(pFrame, pVariablesDirector); this-&gt;pCommands[COMMAND160] = new cCommand160(pFrame); this-&gt;pCommands[COMMAND157] = new cCommand157(pFrame); this-&gt;pCommands[COMMAND159] = new cCommand159(pFrame); this-&gt;pCommands[COMMAND180] = new cCommand180(pFrame); }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I have a mistake, because almost the entire array is not initialized, but I was too lazy to score it :) We keep in mind that there is a mistake. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have no idea what teams 157, 159 and 160 do (I assume only that there is some user variable that is calculated based on a variable pressure, for example, to calculate the flow rate (because, as you know, the flow rate is a function of root extraction from differential pressure, or let's say to count the level, which also depends on the pressure difference)), but I just filled them with some kind of biliberdah, and the programs were swallowed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to the fact that I made an array of commands, the appeal to the commands will look very elegant - like this</font></font><br><pre> <code class="cpp hljs">pCommandSet-&gt;pCommands[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;pFrame-&gt;getCurrentCommand()]-&gt;setNewData(); pCommandSet-&gt;pCommands[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;pFrame-&gt;getCurrentCommand()]-&gt;send();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As you can see, there are no need for any case, but it took ‚Äúa bit of memory‚Äù :) </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DWART. </font><font style="vertical-align: inherit;">Completion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All that remains is to make an active class that will parse the request received from the master. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said before, this class subscribes to the accept accept event from cLinkLayer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The event handler is called from the timer interrupt, and I have to quickly do something in it and exit, so I‚Äôll just set the request readiness check from the master for processing, and in the active task I‚Äôll poll this checkbox, if it is, then I‚Äôll go to cFrame to decode the message for me and if everything went well, I‚Äôll call the necessary command and send it.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same class will create instances of cFrame, cLinkLayer and CommandSet and pass cLinkLayer a pointer to the receive and transmit buffer. </font><font style="vertical-align: inherit;">And since my work will be in the request-response mode, the buffer will be one for transmission and reception, and at the same time we will save memory.</font></font><br><img src="https://habrastorage.org/files/5c6/168/4d1/5c61684d197c409693d6363c1d290015.png" alt="image"><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dwart.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"types.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537    tBoolean #include "frame.h" //lint !e537  oFrame #include "observer.h" //lint !e537  iObserver #include "linklayer.h" //lint !e537  cLinkLayer #include "variablesdirector.h" //lint !e537  cVariablesDirector #include "commandset.h" //lint !e537  cCommandSet #include "frtosWrapper.h" //lint !e537  iActiveObject #define MAX_BUFFER_SIZE (tU8)255 class cDwart: private iObserver, public iActiveObject { public: cDwart(cVariablesDirector *pVariableDirector); virtual void eventHandle(const iObservable* pObservable); virtual void run(void); private: cCommandSet *pCommandSet; cLinkLayer *pLinkLayer; cFrame *pFrame; tU8 buffer[MAX_BUFFER_SIZE]; tBoolean isToken; static const tU8 deviceID[5]; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dwart.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"susuassert.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//lint !e537  ASSERT #include "frame.h" //lint !e537     #include &lt;stddef.h&gt; //lint !e537  NULL #include "dwart.h" //lint !e537   #define SHORT_ADDR (tU8)0 #define PREAMBULS_COUNT (tU8)7 #define DWART_WAITING (tU32) (50/portTICK_PERIOD_MS) const tU8 cDwart::deviceID[5] = {(tU8)0x37,(tU8)0x04,(tU8)0x00,(tU8)0x00,(tU8)0x01}; /******************************************************************************* * Function: constructor * Description:    cLinkLayer, cFrame cCommandSet  *         ******************************************************************************/ cDwart::cDwart(cVariablesDirector *pVariablesDirector) { this-&gt;pLinkLayer = new cLinkLayer(this-&gt;buffer,MAX_BUFFER_SIZE, this-&gt;buffer, PREAMBULS_COUNT); this-&gt;pFrame = new cFrame((tU8*)deviceID, SHORT_ADDR,this-&gt;pLinkLayer); this-&gt;pCommandSet = new cCommandSet(this-&gt;pFrame, pVariablesDirector); this-&gt;pLinkLayer-&gt;addObserver(this); this-&gt;isToken = FALSE; } /******************************************************************************* * Function: eventHandle * Description:    .       ******************************************************************************/ void cDwart::eventHandle(const iObservable* pObservable) { ASSERT(pObservable != NULL); this-&gt;isToken = TRUE; } //lint !e715    pObservable /******************************************************************************* * Function: run * Description:      ******************************************************************************/ void cDwart::run(void) { for(;;) { if (this-&gt;isToken) { this-&gt;isToken = FALSE; if (this-&gt;pFrame-&gt;decode() == FE_good) { pCommandSet-&gt;pCommands[this-&gt;pFrame-&gt;getCurrentCommand()]-&gt;setNewData(); pCommandSet-&gt;pCommands[this-&gt;pFrame-&gt;getCurrentCommand()]-&gt;send(); } } oRTOS.taskDelay(DWART_WAITING); } }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It remains to add the creation of a new cDwart class in main.cpp and run for verification. </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cAdcDirector* pAdcDirector = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> cAdcDirector(); <span class="hljs-comment"><span class="hljs-comment">//lint !e429    . pAdcDirector-&gt;startConversion(); cVariablesDirector *pVariablesDirector = new cVariablesDirector(pAdcDirector); oRTOS.taskCreate(pVariablesDirector, VARIABLESDIRECTOR_STACK_SIZE, VARIABLESDIRECTOR_PRIORITY, "Var"); cDwart *pDwart = new cDwart(pVariablesDirector); oRTOS.taskCreate(pDwart, DWART_STACK_SIZE, DWART_PRIORITY, "Dwart"); ... oRTOS.startScheduler(); } //lint !e429    .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the German miracle called Pactware sees the Japanese pressure sensor, without even noticing that all this is a fake. </font></font><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/S0qeAysH2Jk%3Ffeature%3Doembed&amp;xid=17259,15700021,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhEmdknwPTSuna_jUNmj6sznNwpyQ" frameborder="0" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And our domestic software also does not notice the catch. </font></font><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/hR5AvBr2c-k%3Ffeature%3Doembed&amp;xid=17259,15700021,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhgISI3vhztc22EZiB7EusUdbQ5Mw" frameborder="0" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, a lot of things are not very optimally done, for example, an array of 255 pointers to commands, it can be removed, and you can execute commands through the usual switch case, you can also use one placeholder for all commands equal in size to the largest team and every time create the necessary command, and then delete. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in my case, my memory is unmeasured, and there were no optimization problems. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The project itself as usual in a </font></font><a href="https://yadi.sk/d/XHXC4v1BiECdQ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secret place</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/367843/">https://habr.com/ru/post/367843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../367831/index.html">How to make parking a gaming company irresistible (Black Mesa approved)</a></li>
<li><a href="../367833/index.html">Watching movies / TV shows / TED in Anki</a></li>
<li><a href="../367835/index.html">Ask Ethan # 21: Why does life exist?</a></li>
<li><a href="../367837/index.html">Google cars travel 5 million kilometers a day in a virtual environment.</a></li>
<li><a href="../367841/index.html">Mice live 25% to 35% longer if they get rid of ‚Äúworn out‚Äù cells.</a></li>
<li><a href="../367845/index.html">What society wants: the desire of Russians to control the Internet</a></li>
<li><a href="../367847/index.html">Spacecraft Observation Part 2</a></li>
<li><a href="../367849/index.html">DIY: automatic rechargeable snow gun</a></li>
<li><a href="../367851/index.html">China posted a photo from the lunar surface</a></li>
<li><a href="../367853/index.html">Magnus effect: interesting properties</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>