<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Operator Overloading" in Scala</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago I announced a course on Scala . He started and laid out on the UDEMY MOOC platform - ‚ÄúScala for Java Developers‚Äù . You can read more abo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Operator Overloading" in Scala</h1><div class="post__text post__text-html js-mediator-article">  Some time ago <a href="http://habrahabr.ru/company/golovachcourses/blog/251239/">I announced a course on Scala</a> .  He started and laid out on the UDEMY MOOC platform - <a href="https://www.udemy.com/scala-for-java-developers-ru/%3FcouponCode%3DHABR-OPERATOR">‚ÄúScala for Java Developers‚Äù</a> .  You can read more about the course <a href="http://habrahabr.ru/company/golovachcourses/blog/255631/">at the end of the article</a> . <br><br>  Now I would like to present material on one of the topics of the course - operator overloading in Scala. <br><br><ul><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/255631/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/255631/">Infix operators</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/255631/">"Pointless style" (infix notation) is not "point-free style" (tacit programming)</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/255631/">Operators priority</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/255631/">Operators Associativity</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/255631/">Infix types</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/255631/">Prefix operators</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/255631/">Postfix operators</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/255631/">About the course</a> </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><a name="0"></a><br><h2>  Introduction </h2><br>  in Scala there is no operator overload, as there are no operators (as entities other than methods).  There are methods with symbolic (operator) names of the form '+', '/', '::', '&lt;~' and the prefix / infix / posfix form of the record.  However, for convenience, the term operator will be used further. <br><br><a name="1"></a><br><h2>  Infix operators </h2><br><br>  In Scala, the methods of a single argument can be written in the so-called infix form ( <a href="http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html">infix operations</a> ).  Namely <br><ul><li>  without using a dot between the link and the method </li><li>  without brackets framing the argument </li></ul><br><br>  Example: <br><pre><code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// "normal" notation val x0 = I(1).add(I(2)) // infix notation val x1 = I(1) add I(2) } case class I(k: Int) { def add(that: I): I = I(this.k + that.k) }</span></span></code> </pre> <br>  In the examples below, case-class I will appear, which I will endow in each case with different methods.  It is made case exclusively for short code (fields are automatically generated and initialized by the primary constructor + automatically generated by the companion object with the apply method with a signature identical to the primary constructor, which allows you to create instances through I (k) and not new I (k). I recall that I (k) is equivalent to I.apply (k), and the apply method in Scala can be omitted).  Class I is a ‚Äúwrapper‚Äù around one Int and can be considered as a prototype for a full-fledged class of complex numbers, polynomials, matrices. <br><br>  Everything becomes more interesting if the method is given a "symbolic" / "operator" name <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// "normal" notation val x0 = I(1).+(I(2)) // infix notation val x1 = I(1) + I(2) } case class I(k: Int) { def +(that: I): I = I(this.k + that.k) }</span></span></code> </pre><br>  The JVM (class file format) does not support names from ‚Äúoperator characters‚Äù, therefore, synthetic names are generated during compilation. <br><br>  Launch the class <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">+</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">*</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">/</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">\</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span></span>::(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-&gt;</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&lt;~</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span> }</code> </pre><br><br>  java reflection <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.Method; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Method m: I.class.getDeclaredMethods()) { System.out.println(m); } } } &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I.$plus(I) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I.$minus(I) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I.$times(I) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I.$div(I) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I.$bslash(I) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I.$colon$colon(I) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I.$minus$greater(I) &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I.$less$tilde(I)</code> </pre><br><br>  Yes, Java methods are visible with such names (as in the class file) <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I().$plus(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I()); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I().$minus(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I()); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I().$times(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I()); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I().$div(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I()); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I().$bslash(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I()); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I().$colon$colon(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I()); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I().$minus$greater(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I()); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I().$less$tilde(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> I()); } }</code> </pre><br>  You remember about the transparent integration of all languages ‚Äã‚Äãcompiled for JVM? <br><br>  In general, half of Scala's ‚Äúsyntactic tricks‚Äù consist of a mixture of infix notation and implicit conversions. <br><br>  <b>Example # 1</b> : <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (k &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">10</span></span>) { println(k) } }</code> </pre><br><br>  Infix notation is converted to normal <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (k &lt;- <span class="hljs-number"><span class="hljs-number">1.</span></span>to(<span class="hljs-number"><span class="hljs-number">10</span></span>)) { println(k) }</code> </pre><br><br>  Int does not have a 'to' method, so an implicit conversion is sought that allows Int to be converted to some type with a 'to' method and a suitable signature. <br><br>  And it is located in Predef.scala (I remind you that java.lang. * + Scala. * + Predef. * Are implicitly imported into each file before compiling) <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   Predef.scala package scala object Predef extends LowPriorityImplicits with DeprecatedPredef {...} private[scala] trait DeprecatedPredef {...} private[scala] abstract class LowPriorityImplicits { ... @inline implicit def byteWrapper(x: Byte) = new runtime.RichByte(x) @inline implicit def shortWrapper(x: Short) = new runtime.RichShort(x) @inline implicit def intWrapper(x: Int) = new runtime.RichInt(x) @inline implicit def charWrapper(c: Char) = new runtime.RichChar(c) @inline implicit def longWrapper(x: Long) = new runtime.RichLong(x) @inline implicit def floatWrapper(x: Float) = new runtime.RichFloat(x) @inline implicit def doubleWrapper(x: Double) = new runtime.RichDouble(x) @inline implicit def booleanWrapper(x: Boolean) = new runtime.RichBoolean(x) ... }</span></span></code> </pre><br><br>  RichInt already has a 'to' method with one argument of type Int. <br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   scala.runtime.RichInt package scala.runtime import scala.collection.immutable.Range final class RichInt(val self: Int) ... { ... def to(end: Int): Range.Inclusive = Range.inclusive(self, end) ... }</span></span></code> </pre><br><br>  And therefore, when compiled, it "spins" into something like <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.runtime.<span class="hljs-type"><span class="hljs-type">RichInt</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tmp: <span class="hljs-type"><span class="hljs-type">Range</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">RichInt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>).to(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (k &lt;- tmp) { println(k) } }</code> </pre><br><br>  After ‚Äúpromotion‚Äù for in map / flatMap / foreach we have <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.runtime.<span class="hljs-type"><span class="hljs-type">RichInt</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tmp: <span class="hljs-type"><span class="hljs-type">Range</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">RichInt</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>).to(<span class="hljs-number"><span class="hljs-number">10</span></span>) tmp.foreach(elem =&gt; println(elem)) }</code> </pre><br><br>  <b>Example # 2</b> : <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"France"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"Paris"</span></span>) map += <span class="hljs-string"><span class="hljs-string">"Japan"</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"Tokyo"</span></span> }</code> </pre><br><br>  After the transition from the infix form of calling the '-&gt;' and '+' methods to normal <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = <span class="hljs-type"><span class="hljs-type">Map</span></span>(<span class="hljs-string"><span class="hljs-string">"France"</span></span>.-&gt;(<span class="hljs-string"><span class="hljs-string">"Paris"</span></span>)) map = map.+(<span class="hljs-string"><span class="hljs-string">"Japan"</span></span>.-&gt;(<span class="hljs-string"><span class="hljs-string">"Tokyo"</span></span>)) }</code> </pre><br><br>  and searching for a suitable implicit conversion String to some type with the '-&gt;' method (again found in Predef.scala) gets a ‚Äúdesaccharized form‚Äù (String in Scala is, in fact, java.lang.String and it doesn't have method '-&gt;') <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-type"><span class="hljs-type">Map</span></span>.apply(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">ArrowAssoc</span></span>(<span class="hljs-string"><span class="hljs-string">"France"</span></span>).-&gt;(<span class="hljs-string"><span class="hljs-string">"Paris"</span></span>)) map = map.+((<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">ArrowAssoc</span></span>(<span class="hljs-string"><span class="hljs-string">"Japan"</span></span>).-&gt;(<span class="hljs-string"><span class="hljs-string">"Tokyo"</span></span>))) }</code> </pre><br><br>  From the funny: here is the source code (abbreviated) of the ArrowAssoc class from Predef.scala <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrowAssoc</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">private val self: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyVal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-&gt;</span></span></span><span class="hljs-function"> </span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>](y: <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Tuple2</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>] = <span class="hljs-type"><span class="hljs-type">Tuple2</span></span>(self, y) }</code> </pre><br>  thanks to generics, we can put an arrow between representatives of ANY TWO TYPES!  If you make 1 -&gt; true, then the type variable A will be taken as Int, and the type variable B - as Boolean! <br><br><a name="2"></a><br><h2>  "Pointless style" (infix notation) is not "point-free style" (tacit programming) </h2><br><br>  Do not confuse the pointless style (infix notation), which we are considering, with the so-called <a href="https://wiki.haskell.org/Pointfree">point-free</a> style or otherwise - <a href="http://en.wikipedia.org/wiki/Tacit_programming">tacit programming</a> . <br><br>  Point-free style assumes that you build new functions from certain primitives and other functions without explicitly specifying arguments, without entering formal parameter names.  The name comes from topology, where thoughts often are conducted in terms of neighborhoods and not specific points. <br><br>  Consider a simple example: the function Int =&gt; Int, which returns an argument increased by 1. <br><br>  Here is NOT pointless and NOT point-free style <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = x =&gt; <span class="hljs-number"><span class="hljs-number">1.</span></span>+(x) }</code> </pre><br>  Let me remind you that in Scala '+' is a method belonging to the type Int, and not an operator.  Although compiled under JVM is converted to the same operator '+' over the primitive int. <br><br>  Here is pointless and NOT point-free style. <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = x =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> + x }</code> </pre><br><br>  Here is NOT pointless and point-free style (f - with placeholder, g - without placeholder) <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">1.</span></span>+(_) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> g: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">1.</span></span>+ }</code> </pre><br><br>  That's pointless and point-free style (f - with placeholder, g - without placeholder) <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> + _ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> g: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> + }</code> </pre><br><br>  Further, we will not consider point-free / tacit-programming, this can be the subject of a separate article. <br><br><a name="3"></a><br><h2>  Operators priority </h2><br><br>  If we start defining our "operators", we may face a lack of priorities. <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ println(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) add <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) mul <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k + that.k) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k * that.k) } &gt;&gt; <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br><br>  we would like the multiplication (mul) to have priority over addition (add) (that is, we want 1 + (2 * 3) = 7, not (1 + 2) * 3 = 9).  However, the record type <br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) add <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) mul <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br><br>  Equivalent to the following <br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>).add.(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)).mul(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre><br><br>  Which is equivalent to such <br><pre> <code class="scala hljs">( <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>).add.(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>)) ).mul(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre><br><br>  But not <br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>).add( <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>).mul(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)) )</code> </pre><br><br>  Since the <b>method call is a left-associative operation</b> , that is, there is an arrangement of brackets (convolution) from left to right. <br><br>  This can be fixed by explicitly setting parentheses. <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ println(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) add ( <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) mul <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) )) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k + that.k) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k * that.k) } &gt;&gt; <span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre><br><br>  or using the <b>priority of normal calls before infix calls</b> (not recommended style, do not mix infix calls and normal call forms, brackets are better) <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ println(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) add <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>).mul(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>))) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k + that.k) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k * that.k) } &gt;&gt; <span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre><br><br>  However, if we rename the methods ('mul' -&gt; '*', 'add' -&gt; '+'), then a bit of magic will happen without any indication of the priority '*' over '+'! <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ println(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">+</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k + that.k) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">*</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k * that.k) } &gt;&gt; <span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre><br><br>  Open the <a href="http://www.scala-lang.org/files/archive/spec/2.11/">Holy Book</a> on the <a href="">‚Äú6.12.3 Infix Operations‚Äù section</a> and read: <br><blockquote>  The operator is determined by the operator's first character.  The characters are in the same line. <br><pre> (all letters)
 |
 ^
 &amp;
 =!
 &lt;&gt;
 :
 + -
 * /%
 (all other special characters)
</pre><br></blockquote><br><br>  So, if our method starts with '*', then it takes precedence over the method starting with '+'.  Which, in turn, takes precedence over any name starting with a "normal letter." <br><br>  So this will also work like this (it is not recommended to call similar operators (multiplication, addition) both string and operator names) <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ println(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) add <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k + that.k) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">*</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k * that.k) } &gt;&gt; <span class="hljs-number"><span class="hljs-number">7</span></span></code> </pre><br><br>  Consider the following expression: 1 * 2 * 3 + 4 * 5 * 6 + 7 * 8 * 9. <br><br>  If operators "add" and "multiply" give string names add and mul <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ println(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) mul <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) mul <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) add <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>) mul <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>) mul <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) add <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">7</span></span>) mul <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>) mul <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k + that.k) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mul</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k * that.k) }</code> </pre><br>  then everything will collapse on the left <br>  1 * 2 * 3 + 4 * 5 * 6 + 7 * 8 * 9 -&gt; (((((((1 * 2) * 3) + 4) * 5) * 6) + 7) * 8) * 9 <br><br>  But in the case of the names '+' and '*' <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ println(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) * <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) + <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>) * <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) + <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">7</span></span>) * <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>) * <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">+</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k + that.k) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">*</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k * that.k) }</code> </pre><br>  the line will be divided into groups by equal priorities <br><pre> 1 * 2 * 3 + 4 * 5 * 6 + 7 * 8 * 9 -&gt; 
 (1 * 2 * 3) + (4 * 5 * 6) + (7 * 8 * 9)
</pre><br><br>  inside each group (groups are taken from left to right) there will be a convolution from left to right <br><pre> (1 * 2 * 3) + (4 * 5 * 6) + (7 * 8 * 9) -&gt;
 ((1 * 2) * 3) + ((4 * 5) * 6) + ((7 * 8) * 9)
</pre><br><br>  after which, addition operands will be folded from left to right <br><pre> ((1 * 2) * 3) + ((4 * 5) * 6) + ((7 * 8) * 9) -&gt;
 (((1 * 2) * 3) + ((4 * 5) * 6)) + ((7 * 8) * 9)
</pre><br><br><a name="4"></a><br><h2>  Operators Associativity </h2><br><br>  We read the <a href="http://www.scala-lang.org/files/archive/spec/2.11/">Sacred Book</a> , section <a href="">‚Äú6.12.3 Infix Operations‚Äù</a> further: <br><blockquote>  The associativity of an operator is determined by the operator's last character.  Operators ending in a colon `: 'are right-associative.  All other operators are left-associative. <br>  ... <br>  The right-hand operand of a left-associative operator may consist of several arguments in parentheses, eg e; op; (e1, ..., en).  This expression is then interpreted as e.op (e1, ..., en). <br><br>  A left-associative binary operation e1; op; e2 is interpreted as e1.op (e2).  If op is right associative, the same operation is interpreted as {val x = e1;  e2.op (x)}, where x is a fresh name. <br></blockquote><br><br>  What does this mean in practice?  This means that left-associative convolutions are by default, but for methods in the infix form, ending in a colon works - right associative.  Moreover, the arguments of the operator are reversed. <br><br>  This means that in the following code <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ println(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) ++ <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) ++ <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) ++ <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)) println(<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) +: <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) +: <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) +: <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">++</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k + that.k) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">+</span></span></span></span>:(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k + that.k) }</code> </pre><br>  line <br><pre> I (1) ++ I (2) ++ I (3) ++ I (4)
</pre><br>  minimized to (left associative) <br><pre> ((I (1) ++ I (2)) ++ I (3)) ++ I (4)
</pre><br>  and then to <br><pre> ((((I (1). ++ (I (2))). ++ (I (3)) ++ I (4)
</pre><br><br>  and string <br><pre> I (1) +: I (2) +: I (3) +: I (4)
</pre><br>  collapses to (right associative) <br><pre> I (1) +: (I (2) +: (I (3) +: I (4)))
</pre><br>  and <b>when passing from the infix form to the usual one, inversion of the operator's arguments occurs</b> (magic ':' at the end of the operator's name) <br><pre> I (1) +: (I (2) +: (I (3) +: I (4))) -&gt; 
 I (1) +: (I (2) +: (I (4). + :( I (3)))) -&gt;
 I (1) +: ((I (4). + :( I (3))). + :( I (2))) -&gt;
 ((I (4). + :( I (3))). + :( I (2))). + :( I (1))
</pre><br><br>  Question: What sick mind can this be useful for? <br><br>  Well ... here's an example from the standard library (List creation) <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list = <span class="hljs-number"><span class="hljs-number">0</span></span> :: <span class="hljs-number"><span class="hljs-number">1</span></span> :: <span class="hljs-number"><span class="hljs-number">2</span></span> :: <span class="hljs-type"><span class="hljs-type">Nil</span></span> }</code> </pre><br>  Question: how did this magic happen?  And why is there an empty Nil list at the end? <br>  Everything is extremely simple: '::' is a method of the List class!  With the right associativity and reverse operands. <br><br>  List is defined like this (abbreviated and modified version) <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tail</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">MyList</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEmpty</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span></span>::[<span class="hljs-type"><span class="hljs-type">B</span></span> &gt;: <span class="hljs-type"><span class="hljs-type">A</span></span>](x: <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span>(x, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">head: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, tail: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">List</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEmpty</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nil</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">head</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tail</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">MyList</span></span>[<span class="hljs-type"><span class="hljs-type">Nothing</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Error</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEmpty</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br><br>  And code <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list = <span class="hljs-number"><span class="hljs-number">0</span></span> :: <span class="hljs-number"><span class="hljs-number">1</span></span> :: <span class="hljs-number"><span class="hljs-number">2</span></span> :: <span class="hljs-type"><span class="hljs-type">Nil</span></span> }</code> </pre><br><br>  untapped by the compiler in <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list = ( ( <span class="hljs-type"><span class="hljs-type">Nil</span></span>.::(<span class="hljs-number"><span class="hljs-number">2</span></span>) ).::(<span class="hljs-number"><span class="hljs-number">1</span></span>) ).::(<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre><br>  That is, we simply fill the elements into a single-linked list (stack), starting with an empty list (Nil). <br><br><a name="5"></a><br><h2>  Infix types </h2><br><br>  <a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html">Infix types (infix types)</a> is simply a record of type constructors from two arguments in infix form. <br><br>  So, in order.  What is a type constructor from two arguments?  This is just a generic class / trait with two type variable.  Having such a class (let's call it 'ab'), we give it two types, for example, Int and String, and we get (construct) the type ab [Int, String] <br><br>  We look <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x0: ab[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x1: <span class="hljs-type"><span class="hljs-type">Int</span></span> ab <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ab</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">a: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  The type ab [Int, String] can simply be written in infix form as an Int ab String. <br><br>  Everything becomes more fun if we call the type constructor not trivially 'ab' but magically, for example, '++'. <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x0: ++[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x1: <span class="hljs-type"><span class="hljs-type">Int</span></span> ++ <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x2: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span> ++ <span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: <span class="hljs-type"><span class="hljs-type">Int</span></span> ++ <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> ++ <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">++</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">a: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre><br><br>  If you meet somewhere the magic of the form <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](x: <span class="hljs-type"><span class="hljs-type">A</span></span> &lt;:&lt; <span class="hljs-type"><span class="hljs-type">B</span></span>)</code> </pre><br>  or <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](x: <span class="hljs-type"><span class="hljs-type">A</span></span> =:= <span class="hljs-type"><span class="hljs-type">B</span></span>)</code> </pre><br><br>  Just know that there are a couple of classes in Predef.scala with the names '=: =' and '&lt;: &lt;' <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Predef</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> ... </span></span>{ .. ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;</span></span></span></span>:&lt;[-<span class="hljs-type"><span class="hljs-type">From</span></span>, +<span class="hljs-type"><span class="hljs-type">To</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> ... ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span></span>=:=[<span class="hljs-type"><span class="hljs-type">From</span></span>, <span class="hljs-type"><span class="hljs-type">To</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> ... .. }</code> </pre><br><br><a name="6"></a><br><h2>  Prefix operators </h2><br><br>  From Scala specification <br><blockquote>  A prefix operation op; it is a prefix operator op; it is a '+', '-', '!'  or '~'.  The expression op; e is equivalent to the postfix method application e.unary_op. <br><br>  Prefix operators must be atomic.  For example, the sync signal is read as - (sin (x)), and it should be noted. . </blockquote><br><br>  In Scala, a programmer can define only 4 prefix operators with the names '+', '-', '!', '~'.  They are defined as methods without arguments with the names 'unary_ +', 'unary_-', 'unary_!', 'Unary_ ~'. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x0 = +<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x1 = -<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x2 = !<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x3 = ~<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      def unary_+(): I = I(2 * this.k) def unary_-(): I = I(3 * this.k) def unary_!(): I = I(4 * this.k) def unary_~(): I = I(5 * this.k) }</span></span></code> </pre><br><br>  If we look through the Java Redflection API, we will see what these methods are compiled into. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.lang.reflect.Method; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Class clazz = I.class; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Method m : clazz.getDeclaredMethods()) { System.out.println(m); } } } &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I I.unary_$plus() &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I I.unary_$minus() &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I I.unary_$bang() &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> I I.unary_$tilde() ...</code> </pre><br><br>  It should be noted that along with the prefix form, the original names are preserved (that is, the short form '+' / '-' / '!' / '~' Is just syntactic sugar to the existing one after compiling the full form of 'unary _ +' / ' unary _- '/' unary _! '/' unary_ ~ ') <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x0 = +<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x1 = -<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x2 = !<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x3 = ~<span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    val y0 = I(0).unary_+() val y1 = I(0).unary_-() val y2 = I(0).unary_!() val y3 = I(0).unary_~() } case class I(k: Int) { //      def unary_+(): I = I(2 * this.k) def unary_-(): I = I(3 * this.k) def unary_!(): I = I(4 * this.k) def unary_~(): I = I(5 * this.k) }</span></span></code> </pre><br><br><a name="7"></a><br><h2>  Postfix operators </h2><br><br>  Methods in the postfix form are methods without an argument that were called without a dot.  For a number of reasons, methods in the postfix notation are the cause of many errors (see for a start <a href="http://docs.scala-lang.org/style/method-invocation.html">here</a> and <a href="http://stackoverflow.com/questions/13011204/scalas-postfix-ops">here</a> ). <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tailList0 = <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>).tail <span class="hljs-comment"><span class="hljs-comment">// "normal" notation val tailList1 = List(0, 1, 2) tail // postfix/suffix notation }</span></span></code> </pre><br><br>  Let's try to determine factorial on integers (def!). <br>  First, let's turn our attention to 100,500 ways to call a method in Scala <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>).!() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>).! <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) !() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) ! <span class="hljs-comment"><span class="hljs-comment">// postfix notation } case class I(k: Int) { def !(): I = I(2 * this.k) //    ,    }</span></span></code> </pre><br><br>  Make the method '!'  on the wrapper class <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">5</span></span>)!; println(x) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">!</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span>(k) * (<span class="hljs-type"><span class="hljs-type">I</span></span>(k - <span class="hljs-number"><span class="hljs-number">1</span></span>)!) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">*</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k * that.k) } &gt;&gt; <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">120</span></span>)</code> </pre><br>  Note that the semicolon is obligatory at the end of the first line, otherwise it is NOT COMPILATED (postfix is ‚Äã‚Äãpain, yes)! <br><br>  Hide the explicit presence of a wrapper class under implicit (Int -&gt; I, I -&gt; Int) <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">!</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span>(k) * (<span class="hljs-type"><span class="hljs-type">I</span></span>(k - <span class="hljs-number"><span class="hljs-number">1</span></span>)!) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">*</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k * that.k) } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toInt</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = xk <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>!; println(x) } &gt;&gt; <span class="hljs-number"><span class="hljs-number">120</span></span></code> </pre><br><br>  Now let's hide the implicit ones <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">MathLib</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>!; println(x) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MathLib</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val k: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">!</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">I</span></span>(k) * (<span class="hljs-type"><span class="hljs-type">I</span></span>(k - <span class="hljs-number"><span class="hljs-number">1</span></span>)!) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">*</span></span></span></span>(that: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">I</span></span> = <span class="hljs-type"><span class="hljs-type">I</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.k * that.k) } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toInt</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">I</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = xk } &gt;&gt; <span class="hljs-number"><span class="hljs-number">120</span></span></code> </pre><br><br><a name="8"></a><br><h2>  About the course </h2><br><br>  Announced a <a href="http://habrahabr.ru/company/golovachcourses/blog/251239/">course on Scala is</a> laid out on the UDEMY MOOC platform - <a href="https://www.udemy.com/scala-for-java-developers-ru/%3FcouponCode%3DHABR-OPERATOR">"Scala for Java Developers"</a> .  The initial idea of ‚Äã‚Äãwriting a comprehensive course on all aspects of the language and the most popular type acrobatic libraries (scalaz, shapeless) has been preserved, but has undergone minor changes. <br>  It was decided to cut the original 32-hour large course for $ 399 into two 16-hour courses for $ 199 each (if you enter the coupon code HABR-OPERATOR on UDEMY or simply follow the link <a href="https://www.udemy.com/scala-for-java-developers-ru/%3FcouponCode%3DHABR-OPERATOR">udemy.com/scala-for-java-developers- ru /? couponCode = HABR-OPERATOR</a> , then the price with a discount will be $ 179, the number and duration of coupon codes is limited).  It was decided to saturate the course with tests (there will be more than 50 tests for 5-15 questions with code examples for each part of the course). <br>  The first course was shot at 75% (12 hours out of 16) and uploaded to UDEMY by 50% (8 hours out of 16), as part of the video is being processed. <br><br>  The first part includes such topics. <br><ul><li>  <b>Intro: HelloWorld, Scala and JVM, Scala and Reflection</b> </li><li>  <b>OOP - I: class, object, trait, case class, package, method, constructor, field</b> </li><li>  <b>OOP - II: operator overloading (prefix, infix, postfix)</b> </li><li>  <b>Types - I: Scala type hierarchy, top and bottom types, Unit</b> </li><li>  <b>Types - II: tuples, structural types</b> </li><li>  <b>Generics - I: covariance / contravariance, Scala vs Java</b> </li><li>  <b>Collections - I: Array, List, Set, Map</b> </li><li>  <b>Implicits / type classes: conversions, arguments, view bounds</b> </li><li>  <b>Functional Programming - I: functional literals, closures, eta-expansions, curring, partial application</b> </li><li>  <b>Lazyness: call-by-name, keyword 'lazy', trait DelayedInit</b> </li><li>  <b>Control - I: build-in control flow constructions, expression-oriented programming - if, while, for, case, try, throw</b> </li><li>  <b>Control - II: create your own control flow constructions</b> </li><li>  <b>Pattern matching: classes, extractors</b> </li><li>  <b>List-comprehentions: MonadicFilter trait, translation to composition of higher-order functions, monads</b> </li><li>  <b>Combinatorics: the generation of combinatorial objects (permutations, partitions, subsets, trees)</b> </li><li>  <b>Algebra - I: magma, semigroup, monoid, group</b> </li><li>  <b>Set theory: binary relations (equivalence, order, partial order, preorder), equivalence classes, factor sets</b> </li><li>  <b>Set theory: morphisms, automorphisms, homomorphisms, mapping of the structure of a set</b> </li></ul><br><br>  The second part (while at the stage of elaboration) includes such topics. <br><ul><li>  <b>Annotations</b> </li><li>  <b>OOP - III: inheritance, inheritance linearization, cake pattern</b> </li><li>  <b>Types - III: abstract type members, singleton types, shapeless: HList</b> </li><li>  <b>Generics - II: existential types, higher-kind types</b> </li><li>  <b>Collections - II: internals and architecture</b> </li><li>  <b>Collections - III: parallel collections</b> </li><li>  <b>Concurrency - I: Futures and Promises</b> </li><li>  <b>Concurrency - II: actors, supervisors</b> </li><li>  <b>Streams: recursion and co-recursion, lazy data structures</b> </li><li>  <b>Functional Programming - II: Functional patterns and pearls</b> </li><li>  <b>Introduction to category theory: Scalaz: Monad, Scalaz: ApplicativeFunctor</b> </li><li>  <b>Introduction to Mathematical Logic</b> </li><li>  <b>Algebra - II</b> </li><li>  <b>Path dependent types</b> </li><li>  <b>Formal languages ‚Äã‚Äã- I: theory</b> </li><li>  <b>Formal languages ‚Äã‚Äã- II: parser combinators (scala.util.parsing. {Ast, combinator, input, json})</b> </li><li>  <b>Metaprogramming - I: Reflection</b> </li><li>  <b>Metaprogramming - II: Macroses</b> </li></ul><br><br>  <b>Note # 1</b> : a number of topics (OOP, Generics, Scala types, ...) were decided to be divided into 2 or even 3 parts because of the complexity and importance of the issue (the first parts are located in the first part of the course, the last - in the second part of the course (‚ÄúOOP -III: inheritance, Cake Pattern ‚Äù,‚Äú Generics-II: existential types, higher-king types ‚Äù, ...)). <br><br>  <b>Note # 2</b> : in view of the fact that many programmers have certain problems with mathematics (we teach 3 semesters "matan", but no more useful for a programmer "discrete disciplines" - set theory, discrete mathematics, mathematical logic, algebra, combinatorics, theory categories, formal languages ‚Äã‚Äã/ grammars, ...) and because functional programming is strongly using mathematical concepts, several sections of mathematics are introduced into the course (all mathematics are ‚Äúencoded in Scala‚Äù, so without university ‚Äúspherical codes  s in vacuo "). <br><br>  PS I will answer all questions in the comments / messages in the "lichku" or by contact <br>  skype: GolovachCourses <br>  email: GolovachCourses@gmail.com <br><br>  PPS Simultaneously with the development of the Scala course, the author conducts internal trainings on Scala in IT companies, <a href="http://jeeconf.com/program/quick-dive-into-scala/">trainings at conferences</a> , gives reports on Scala and provides consulting services when translating projects from Java to Scala. </div><p>Source: <a href="https://habr.com/ru/post/255631/">https://habr.com/ru/post/255631/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255621/index.html">Dagaz: Kicks to common sense (part 5)</a></li>
<li><a href="../255623/index.html">Comparison of technical support of the largest software vendors in the field of network security</a></li>
<li><a href="../255625/index.html">Features of creating programs in NODEMCU ESP8266 for the ‚ÄúInternet of Things‚Äù</a></li>
<li><a href="../255627/index.html">Building signs and comparing images: global signs. Lectures from Yandex</a></li>
<li><a href="../255629/index.html">Reports and competitions for NeoQUEST-2015</a></li>
<li><a href="../255633/index.html">Nakapcha Mail.Ru - captcha, which is not shown</a></li>
<li><a href="../255637/index.html">Is there a USB in this MK?</a></li>
<li><a href="../255643/index.html">Online streaming. Monitoring: from server to application. System Center Operations Manager 2012 R2</a></li>
<li><a href="../255645/index.html">Again about AUTO_INCREMENT</a></li>
<li><a href="../255647/index.html">Levitron on Arduino</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>