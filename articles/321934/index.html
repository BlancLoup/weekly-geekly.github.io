<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pass pointers to member functions in the C API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Enno time ago in one XMPP-room dedicated to C ++, one visitor asked if there was any way in modern pluses without extra code to pass a pointer to a cl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pass pointers to member functions in the C API</h1><div class="post__text post__text-html js-mediator-article">  Enno time ago in one XMPP-room dedicated to C ++, one visitor asked if there was any way in modern pluses without extra code to pass a pointer to a class member function as a callback to the C API.  Well, something like: <br><br><pre><code class="hljs lisp">// C API void doWithCallback (<span class="hljs-name"><span class="hljs-name">void</span></span> (<span class="hljs-name"><span class="hljs-name">*fn</span></span>) (<span class="hljs-name"><span class="hljs-name">int</span></span>, void*), void *userdata); // C++ code struct Foo { void doFoo (int param); }; int main () { Foo foo; doWithCallback (MAGIC (/* <span class="hljs-symbol"><span class="hljs-symbol">&amp;Foo</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:doFoo</span></span> */), &amp;foo); }</code> </pre> <br>  It is clear that as a <code>MAGIC</code> you can use a free function, a static member function or even a lambda (2017 is the year outside, after all), but writing the appropriate construction each time for each function with your hands is somewhat lazy, and the preprocessor, as we all Of course, we know - moveton. <br><br>  In this post we will try (and, characteristically, we will succeed) to write a universal wrapper, and at the same time we will see how some C ++ 17 chip will help us to further reduce the amount of redundant code.  There will be no cool templates here, the solution, in my opinion, is rather trivial, but perhaps it still makes sense to share them (and at the same time once again promote new C ++ 17 features). <br><a name="habracut"></a><br>  First, we solve the problem more simply: suppose that the member function does not take any arguments (except for the implicit <code>this</code> , of course, which we have to pass).  A typical frontal solution would then look something like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs cpp">doWithCallback ([] (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *udata) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Foo*&gt; (udata)-&gt;doFoo (); }, &amp;foo);</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Draft code from which we will build</b> <div class="spoiler_text"><pre> <code class="hljs delphi">#include &lt;iostream&gt; void doWithCallback (void <span class="hljs-comment"><span class="hljs-comment">(*fn) (void*)</span></span>, void *userdata) <span class="hljs-comment"><span class="hljs-comment">{ fn (userdata); }</span></span> struct Foo <span class="hljs-comment"><span class="hljs-comment">{ int m_i = 0; void doFoo () { std::cout &lt;&lt; m_i &lt;&lt; std::endl; }</span></span> }; int main () <span class="hljs-comment"><span class="hljs-comment">{ Foo foo { 42 }</span></span>; doWithCallback ([] (void *udata) <span class="hljs-comment"><span class="hljs-comment">{ return static_cast&lt;Foo*&gt; (udata)-&gt;doFoo (); }</span></span>, &amp;foo); }</code> </pre><br></div></div><br>  If we want to make a generalized wrapper, then, of course, it must somehow be passed at the point of creation of the callback, which function over which particular class we want to call.  In addition, the wrapper must be saved, in fact, what exactly it needs to call.  If everything is simple with the transfer (we took a pointer to a member function and passed it), then saving it will not be so easy: <br><br>  code like: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Ptr&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeWrapper</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Ptr ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ptr] (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *udata) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Foo*&gt; (udata)-&gt;*ptr) (); }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo foo { <span class="hljs-number"><span class="hljs-number">42</span></span> }; doWithCallback (MakeWrapper (&amp;Foo::doFoo), &amp;foo); }</code> </pre><br>  it is expected not to be collected, since lambdas with a non-empty capture list cannot be converted to a function pointer: <br><br><pre> <code class="hljs delphi">prog.cc:<span class="hljs-number"><span class="hljs-number">36</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span>: error: no matching <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">to</span></span></span><span class="hljs-function"> '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWithCallback</span></span></span><span class="hljs-function">' </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doWithCallback</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MakeWrapper (&amp;Foo::doFoo)</span></span></span><span class="hljs-function">, &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">);</span></span> ^~~~~~~~~~~~~~ prog.cc:<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>: note: candidate <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">not</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viable</span></span></span><span class="hljs-function">:</span></span> no known conversion from <span class="hljs-string"><span class="hljs-string">'(lambda at prog.cc:29:12)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-string"><span class="hljs-string">'void (*)(void *)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>st argument void doWithCallback (void <span class="hljs-comment"><span class="hljs-comment">(*fn) (void*)</span></span>, void *userdata) ^</code> </pre><br>  It makes sense: there is not enough ‚Äúspace‚Äù in the function pointer to save, in addition to the function itself, to save some context (or at least a pointer to it). <br><br>  So what to do?  We are doomed? <br><br>  Not!  Non-type parameters come to the rescue: in the overwhelming majority of cases, when transferring a callback, we know at the compilation stage what function we want to call, which means we can parameterize some template with this, and we don‚Äôt have to carry any information in runtime. <br><br>  Just as we can parameterize a template with, say, an integer, we can parameterize it with a function pointer.  Let's try: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C, R (C::*Ptr) ()&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeWrapper</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *udata) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;C*&gt; (udata)-&gt;*Ptr) (); }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo foo { <span class="hljs-number"><span class="hljs-number">42</span></span> }; doWithCallback (MakeWrapper&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, Foo, &amp;Foo::doFoo&gt; (), &amp;foo); }</code> </pre><br>  Works!  But there is one problem: the type of the return value, the type of the class, and the list of the types of the parameters of the function (in our case it is empty) must be specified each time by hand.  But laziness is the same.  Can we do better? <br><br>  In C ++ 11/14, we can force the compiler to infer the above types, but for this we have to specify the desired member function twice: once to infer the <em>type of the</em> variable corresponding to the pointer to this function, from which we can already get everything we need to form the correct ‚Äúsignature‚Äù for the non-type argument of the template.  Something like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MakeWrapperHelper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> R </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetectReturnImpl</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (C::*) ())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> C </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetectClassImpl</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (C::*) ())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DetectReturn = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (DetectReturnImpl (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;U&gt; ())); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DetectClass = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (DetectClassImpl (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;U&gt; ())); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> R = DetectReturn&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> C = DetectClass&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;R (C::*Ptr) ()&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Make</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *udata) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;C*&gt; (udata)-&gt;*Ptr) (); }; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeWrapper</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MakeWrapperHelper&lt;T&gt; {}; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo foo { <span class="hljs-number"><span class="hljs-number">42</span></span> }; doWithCallback (MakeWrapper (&amp;Foo::doFoo).Make&lt;&amp;Foo::doFoo&gt; (), &amp;foo); }</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Full code</b> <div class="spoiler_text"><pre> <code class="hljs rust">#include &lt;iostream&gt; #include &lt;tuple&gt; void doWithCallback (void (*<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">) </span></span>(void*), void *userdata) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span></span>(userdata); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { int m_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; void doFoo () { std::cout &lt;&lt; m_i &lt;&lt; std::endl; } }; template&lt;typename T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MakeWrapperHelper</span></span></span></span> { template&lt;typename R, typename C&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> R DetectReturnImpl (R (C::*) ()); template&lt;typename R, typename C&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> C DetectClassImpl (R (C::*) ()); template&lt;typename U&gt; using DetectReturn = decltype (DetectReturnImpl (std::declval&lt;U&gt; ())); template&lt;typename U&gt; using DetectClass = decltype (DetectClassImpl (std::declval&lt;U&gt; ())); using R = DetectReturn&lt;T&gt;; using C = DetectClass&lt;T&gt;; template&lt;R (C::*Ptr) ()&gt; auto Make () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] (void *udata) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (static_cast&lt;C*&gt; (udata)-&gt;*Ptr) (); }; } }; template&lt;typename T&gt; auto MakeWrapper (T) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MakeWrapperHelper&lt;T&gt; {}; } int main () { Foo foo { <span class="hljs-number"><span class="hljs-number">42</span></span> }; doWithCallback (MakeWrapper (&amp;Foo::doFoo).Make&lt;&amp;Foo::doFoo&gt; (), &amp;foo); }</code> </pre><br></div></div><br><br>  But it all looks scary and smells bad.  Can we do better? <br><br>  Perhaps in the framework of C ++ 14 we can, but I did not think of how, but rather I found evidence that this cannot be done, but the fields of this article are too narrow for it. <br><br>  So, the main problem is that we have to explicitly specify the type of the template non-type argument, for which we need to explicitly specify all these types of return values ‚Äã‚Äãand other similar things in one form or another.  Fortunately, in C ++ 17 we added exactly what we needed: automatic output of the type of the template argument (it works so far only in the developed clang and gcc branches).  The required code is significantly simplified: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C&gt; <span class="hljs-function"><span class="hljs-function">C </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetectClassImpl</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(R (C::*) ())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeWrapper</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> C = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (DetectClassImpl (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *udata) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;C*&gt; (udata)-&gt;*T) (); }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Foo foo { <span class="hljs-number"><span class="hljs-number">42</span></span> }; doWithCallback (MakeWrapper&lt;&amp;Foo::doFoo&gt; (), &amp;foo); }</code> </pre><br>  Everything. <br><br>  Oh, no, not all.  Recall that initially our member function could accept an arbitrary set of parameters.  Similarly, <code>DetectArgsImpl</code> , which returns a list of argument types, can be defined: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> R, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Args...&gt; DetectArgsImpl (R (C::*) (Args...));</code> </pre><br>  and use partial specialization to deploy it: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MakeWrapperHelper</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MakeWrapperHelper</span></span></span><span class="hljs-class">&lt;T, std::tuple&lt;Args...&gt;&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> C = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (DetectClassImpl (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] (Args... args, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *udata) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;C*&gt; (udata)-&gt;*T) (args...); }; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeWrapper</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MakeWrapperHelper&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span> (DetectArgsImpl (T))&gt; {} (); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Together</b> <div class="spoiler_text"><pre> <code class="hljs rust">#include &lt;iostream&gt; #include &lt;tuple&gt; void doWithCallback (void (*<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">) </span></span>(int, void*), void *userdata) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span></span>(<span class="hljs-number"><span class="hljs-number">7831505</span></span>, userdata); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> { int m_i = <span class="hljs-number"><span class="hljs-number">0</span></span>; void doFoo (int val) { std::cout &lt;&lt; m_i &lt;&lt; <span class="hljs-string"><span class="hljs-string">" vs "</span></span> &lt;&lt; val &lt;&lt; std::endl; } }; template&lt;typename R, typename C, typename... Args&gt; C DetectClassImpl (R (C::*) (Args...)); template&lt;typename R, typename C, typename... Args&gt; std::tuple&lt;Args...&gt; DetectArgsImpl (R (C::*) (Args...)); template&lt;auto, typename&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MakeWrapperHelper</span></span></span></span>; template&lt;auto T, typename... Args&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MakeWrapperHelper</span></span></span></span>&lt;T, std::tuple&lt;Args...&gt;&gt; { auto operator() () { using C = decltype (DetectClassImpl (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] (Args... args, void *udata) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (static_cast&lt;C*&gt; (udata)-&gt;*T) (args...); }; } }; template&lt;auto T&gt; auto MakeWrapper () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MakeWrapperHelper&lt;T, decltype (DetectArgsImpl (T))&gt; {} (); } int main () { Foo foo { <span class="hljs-number"><span class="hljs-number">42</span></span> }; doWithCallback (MakeWrapper&lt;&amp;Foo::doFoo&gt; (), &amp;foo); }</code> </pre><br></div></div><br>  So it goes.  You can safely take the Tox API, the libpurple API, the gstreamer API, any kind of API and avoid the heap of boilerplate. <br><br>  As an exercise, an interested reader can add an indication of the arguments that are passed to the callback sishny API, but which should be ignored - for example, Tox first argument passes a pointer to the same, which may well be available in our plus code. <br><br>  And the habrahrabrovsky syntax coloring from all this is bad, it seems. </div><p>Source: <a href="https://habr.com/ru/post/321934/">https://habr.com/ru/post/321934/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321922/index.html">How to make your games for free? T3 indie games development guide</a></li>
<li><a href="../321924/index.html">Web push notifications quick and easy</a></li>
<li><a href="../321926/index.html">Security Week 07: RSA and Artificial Intelligence, Android Security, State Regulation IoT</a></li>
<li><a href="../321928/index.html">Console to the masses. Go to the bright side. Automate routine tasks</a></li>
<li><a href="../321932/index.html">The secret of fast programming: do not hesitate</a></li>
<li><a href="../321936/index.html">Octodon tries his hand at MotoModoStroenii</a></li>
<li><a href="../321938/index.html">Hanami v1.0.0.beta1 released</a></li>
<li><a href="../321940/index.html">How to get work experience without having work experience: tearing the vicious circle of a novice designer</a></li>
<li><a href="../321944/index.html">How 3 thousand rubles and simple methods to improve the efficiency of the data center helped save a lot of money</a></li>
<li><a href="../321946/index.html">Google released TensorFlow 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>