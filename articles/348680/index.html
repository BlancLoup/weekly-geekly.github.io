<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learning to intercept unprocessed messages or an example of how SObjectizer is cluttered with new features ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We are very pleased when new features are added to SObjectizer resulting from the prompts and / or wishes of SObjectizer users. Although it is not alw...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learning to intercept unprocessed messages or an example of how SObjectizer is cluttered with new features ...</h1><div class="post__text post__text-html js-mediator-article">  We are very pleased when new features are added to <a href="https://sourceforge.net/projects/sobjectizer/">SObjectizer</a> resulting from the prompts and / or wishes of SObjectizer users.  Although <a href="http://eao197.blogspot.com.by/2018/02/progc-sobjectizer-v5521-so5extra-v104.html">it is not always easy</a> .  After all, on the one hand, we, as a team of developers and old users of SObjectizer, already have our own stereotypes about how SObjectizer is commonly used.  And it is not always possible to immediately appreciate the ‚Äúfresh look from the outside‚Äù, to understand what the user really wants to see in the framework and why he is not satisfied with the available means.  On the other hand, SObjectzer is not such a small framework, adding new features requires some caution.  It is necessary that the new functionality does not conflict with existing features.  And, all the more so that after adding something new, something that already exists and has been working for a long time does not break.  Plus, we have a point about maintaining compatibility between versions of SObjectizer, so we are strongly opposed to major changes ... <br><br>  In general, adding a new one to SObjectizer is always a pleasure in terms of increasing the capabilities of the framework and increasing its usability.  But this is not always as pleasant and simple from the point of view of implementation. <br><br>  Under the cut there is a small story about how one new feature was added to SObjectizer.  Maybe someone from the readers will be interested to see how the old framework adapts to the requests of new users. <br><a name="habracut"></a><br><h1>  Preamble </h1><br>  So, it all started with the fact that one of the SObjectizer users, <a href="https://habrahabr.ru/users/pavelvainerman/" class="user_link">PavelVainerman</a> , drew our attention to the fact that SObjectizer does not have ready-made convenient means for performing episodic one-time interactions between agents. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It turned out that I mean this.  Suppose Agent A wants to send a request to Agent B and wants to receive a response message from Agent B. But at the same time, Agent A does not want to wait for a response longer than 5 seconds.  A trivial ‚Äúhead-on‚Äù solution that immediately comes to mind may look like this: <br><br><pre><code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  -. struct request { const so_5::mbox_t reply_to_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   .. }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -. struct reply { ... }; class A : public so_5::agent_t { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,       -. struct reply_timed_out final : public so_5::signal_t {}; ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . void on_reply(mhood_t&lt;reply&gt; cmd) {...} void on_reply_timeout(mhood_t&lt;reply_timed_out&gt;) {...} ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,       B. void ask_something(const so_5::mbox_t &amp; B_mbox) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         -. so_subscribe_self().event(&amp;A::on_reply); so_subscribe_self().event(&amp;A::on_reply_timeout); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   .     mbox,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . so_5::send&lt;request&gt;(B_mbox, so_direct_mbox(), ...); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       ,   -. so_5::send_delayed&lt;reply_timed_out&gt;(*this, 5s); };</span></span></code> </pre> <br>  Unfortunately, this simple version is only a clear demonstration of the veracity of the aphorism that "any difficult task has a simple, easy to understand wrong solution."  There are several problems here. <br><br>  The first problem is related to the deferred message A :: reply_timed_out.  If the response from Agent B did not come in time, then everything is fine with reply_timed_out.  We receive it, process it and forget about it.  But what will happen if the answer from Agent B came on time?  What happens to reply_timed_out? <br><br>  It will still come to Agent A. After all, no one has canceled reply_timed_out.  So, as soon as the SObjectizer timer thread counts 5 seconds, the reply_timed_out message will be delivered to Agent A. And we will receive and process it despite the fact that we no longer need it.  What is wrong.  It would be correct to prevent the reply_timed_out message from getting to us after we received a reply from agent B. <br><br>  The surest way to do this is to unsubscribe from reply_timed_out.  Why this is the case is a topic for another big conversation.  If someone is interested, you can separately talk on this topic.  In the meantime, we confine ourselves to the fact that unsubscribing from a deferred message is a ‚Äúreinforced concrete‚Äù solution to problems with a deferred message. <br><br>  The second problem is that it is unlikely that Agent A will need to communicate in this way only with Agent B. Most likely Agent A exchanges request / reply messages with several agents at once.  Accordingly, when request flies simultaneously to agents B and C, then agent A needs to somehow understand who the answer came from.  Or whose answer was not received within 5 seconds. <br><br>  The second problem is more or less conveniently solved by eliminating the use of Agent A's own mbox as the return address.  It's easier to create a new mbox for each new interaction.  And it is this new mbox that will be used to receive a response, and for a pending message for this particular request. <br><br>  However, as soon as we introduce a new mbox, we must ensure that the mbox is removed after it is no longer needed.  To do this, we must remove the subscriptions to this mbox.  If subscriptions are not removed, then mbox will remain alive, and this will lead to a constant increase in memory consumption - we will create new mboxes for each new request, and these mboxes will not be deleted. <br><br>  In general, if we consider these two problems, the simple solution will be transformed into a not very simple one: <br><br><pre> <code class="hljs markdown">class A : public so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::agent_</span></span>t { // ,       -. struct reply<span class="hljs-emphasis"><span class="hljs-emphasis">_timed_</span></span>out final : public so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::signal_</span></span>t {}; ... //       , //     ,    . void on<span class="hljs-emphasis"><span class="hljs-emphasis">_reply(const request_</span></span>info &amp; info, mhood<span class="hljs-emphasis"><span class="hljs-emphasis">_t&lt;reply&gt; cmd) {...} void on_</span></span>reply<span class="hljs-emphasis"><span class="hljs-emphasis">_timeout(const request_</span></span>info &amp; info, mhood<span class="hljs-emphasis"><span class="hljs-emphasis">_t&lt;reply_</span></span>timed<span class="hljs-emphasis"><span class="hljs-emphasis">_out&gt;) {...} ... // ,       . //       ,  . void ask_</span></span>something(const request<span class="hljs-emphasis"><span class="hljs-emphasis">_info &amp; info, const so_</span></span>5::mbox<span class="hljs-emphasis"><span class="hljs-emphasis">_t &amp; dest) { //    mbox      . const auto uniq_</span></span>mbox = so<span class="hljs-emphasis"><span class="hljs-emphasis">_environment().create_</span></span>mbox(); //       . auto subscriptions<span class="hljs-emphasis"><span class="hljs-emphasis">_dropper = [this, uniq_</span></span>mbox] { so<span class="hljs-emphasis"><span class="hljs-emphasis">_drop_</span></span>subscription<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">reply</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(uniq<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox); so_</span></span>drop<span class="hljs-emphasis"><span class="hljs-emphasis">_subscription&lt;reply_</span></span>timed<span class="hljs-emphasis"><span class="hljs-emphasis">_out&gt;(uniq_</span></span>mbox); }; //         -. so<span class="hljs-emphasis"><span class="hljs-emphasis">_subscribe(uniq_</span></span>mbox) .event([<span class="hljs-string"><span class="hljs-string">this, info, subscriptions_dropper</span></span>](<span class="hljs-link"><span class="hljs-link">mhood_t&lt;reply&gt; cmd</span></span>) { //  . subscription<span class="hljs-emphasis"><span class="hljs-emphasis">_dropper(); //   . on_</span></span>reply(info, cmd); }) .event([<span class="hljs-string"><span class="hljs-string">this, info, subscriptions_dropper</span></span>](<span class="hljs-link"><span class="hljs-link">mhood_t&lt;reply_timed_out&gt; cmd</span></span>) { subscription<span class="hljs-emphasis"><span class="hljs-emphasis">_dropper(); on_</span></span>reply<span class="hljs-emphasis"><span class="hljs-emphasis">_timeout(info, cmd); }); //   .      mbox,  //      . so_</span></span>5::send<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">request</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(B<span class="hljs-emphasis"><span class="hljs-emphasis">_mbox, uniq_</span></span>mbox, ...); //       ,   -. so<span class="hljs-emphasis"><span class="hljs-emphasis">_5::send_</span></span>delayed<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">reply_timed_out</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>(so<span class="hljs-emphasis"><span class="hljs-emphasis">_environment(), uniq_</span></span>mbox, 5s); } };</code> </pre><br>  It turns out is not as simple and compact as we would like.  But that's not all.  So, in this decision there is no exception safety.  There is no explicit cancellation of a deferred message when it is no longer needed.  But, more importantly, if Agent A wants to have more than one default state, as in the example above, but several states, in each of which he needs to react to messages differently, then everything will become even worse.  Well, everything will be even worse if an exchange between A and B requires more than one response message, but several.  For example, if successful_reply and failed_reply instead of reply, then the amount of work for the developer of agent A will increase significantly. <br><br><h2>  Why we did not face such a problem? </h2><br>  A small retreat to the side.  When it became clear to us what <a href="https://habrahabr.ru/users/pavelvainerman/" class="user_link">PavelVainerman</a> tells <a href="https://habrahabr.ru/users/pavelvainerman/" class="user_link">us</a> , we ourselves were surprised.  After all, the problem is really obvious.  But why did we not encounter it ourselves?  At least, they did not come across so often to pay attention to it and include a solution for this problem in SObjectizer. <br><br>  Probably, there were two factors. <br><br>  First, we quickly <a href="https://habrahabr.ru/post/335304/">came to the ideas of the SEDA approach</a> .  There, the number of agents is small, stable ties are established between them, so there are no such problems there in principle. <br><br>  Secondly, probably, a one-time one-time interaction is most often used between short-lived agents.  And for an agent who lives only to handle a single operation, these problems are not relevant. <br><br>  Anyway, it is impossible not to note the fact that as soon as new people start using your tool, it immediately turns out that they want to use the tool in a completely different way than you yourself used to do it. <br><br><h1>  What did we do in the end? </h1><br>  As a result, we expanded our add-on over SObjectizer called <a href="https://sourceforge.net/p/sobjectizer/wiki/About%2520so5extra/">so_5_extra</a> , adding support for the so-called.  <i>asynchronous operations</i> .  Through asynchronous operations, the above example can be rewritten as follows: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : public so_5::agent_t { // ,       -. struct reply_timed_out final : public so_5::signal_t {}; ... //     , //     ,    . void on_reply(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_info</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mhood_t</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reply</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">) {...} void on_reply_timeout(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_info</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mhood_t</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reply_timed_out</span></span></span><span class="hljs-class">&gt;) {...} ... // ,       . //       ,  . void ask_something(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_info</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_5</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbox_t</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dest</span></span></span><span class="hljs-class">) { //    mbox      . const auto uniq_mbox = so_environment().create_mbox(); //     . so_5::extra::async_op::time_limited::make&lt;reply_timed_out&gt;(*</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">) .completed_on(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uniq_mbox</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_default_state</span></span></span><span class="hljs-class">(), [this, info](</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mhood_t</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reply</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">) { on_reply(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">); }) .timeout_handler(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_default_state</span></span></span><span class="hljs-class">(), [this, info](</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mhood_t</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reply_timed_out</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">) { on_reply_timeout(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">info</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">); }) .activate(5</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">); //   .      mbox,  //      . so_5::send&lt;request&gt;(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B_mbox</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uniq_mbox</span></span></span><span class="hljs-class">, ...); } };</span></span></code> </pre><br>  Learn more about new asynchronous operations in so_5_extra <a href="https://sourceforge.net/p/sobjectizer/wiki/so5extra%25201.0%2520Async%2520Operations/">here</a> . <br><br>  But today it‚Äôs not about how the asynchronous messages themselves are made.  And what it took to do in SObjectizer for asynchronous messages to work in so_5_extra. <br><br><h1>  What was the problem with the implementation of time_limited asynchronous operations? </h1><br>  Two implementations of asynchronous operations are included in so_5_extra: time_unlimited, when no restrictions are imposed on the execution time of the operation, and time_limited, when the operation needs to be completed in the allotted time.  Above, it was just about time_limited-operations, since  with their implementation was one of the main snags. <br><br>  The bottom line is that when we start a time_limited operation, we must receive and process a deferred message, which limits the time of an asynchronous operation.  And with this "necessarily" just something was not all simple. <br><br>  The fact is that one of the key features of SObjectizer are <a href="https://habrahabr.ru/post/308486/">agent states</a> .  States allow agents to process different sets of messages in each of the states.  Or process the same messages in different states in different ways.  But there is a downside: if some message needs to be processed in all states, then you need to explicitly sign the handler of this message for each of the states.  Those.  write something like: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_msg_handler_demo</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public so_5::agent_t { //   . state_t st_first{this}</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">st_second{this}</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">st_third{this}; ... // </span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">      . void some_msg_default_handler</span></span></span></span>(mhood_t&lt;some_msg&gt; cmd) {...} ... virtual void so_define_agent() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> { ... <span class="hljs-comment"><span class="hljs-comment">//    " ". so_subscribe(some_mbox) .in(st_first).in(st_second).in(st_third) .event(&amp;default_msg_handler_demo::some_msg_default_handler); ... } };</span></span></code> </pre> <br>  Naturally, this is not the best and most convenient solution. <br><br>  By using the capabilities of hierarchical finite automata, you can make it simpler, more convenient, and more reliable: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_msg_handler_demo</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public so_5::agent_t { //   . //   . state_t st_parent{this}</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">//    </span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">  . st_first{initial_substate_of{st_parent}}</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">st_second{substate_of{st_parent}}</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">st_third{substate_of{st_parent}}; ... // </span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">      . void some_msg_default_handler</span></span></span></span>(mhood_t&lt;some_msg&gt; cmd) {...} ... virtual void so_define_agent() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> { ... <span class="hljs-comment"><span class="hljs-comment">//    " "    . so_subscribe(some_mbox) .in(st_parent) .event(&amp;default_msg_handler_demo::some_msg_default_handler); ... } };</span></span></code> </pre> <br>  Now the ‚Äúdefault‚Äù handler will be called regardless of which state the agent is in. <br><br>  But, unfortunately, this approach requires that the agent was originally designed using hierarchical finite automata.  It is unlikely that it would be convenient to use asynchronous operations from so_5_extra if they imposed such a strict requirement on users: they say, if you want to use asynchronous operations, you can create a parent state in your agent. <br><br>  And it is not always possible to do this in principle.  Suppose someone wrote you a library of agents in which there is a basic type of basic_device_manager.  You make your own inheritance class my_device_manager and you need to use asynchronous operations in my_device_manager.  If the developer has not done something like st_parent in basic_device_manager, then you will not add your own st_parent there. <br><br>  In general, it was necessary to do something that would allow catching messages that were addressed to the agent, but which were not processed by the agent.  Such messages are sometimes called <i>deadletters</i> . <br><br><h1>  What and how did we end up doing? </h1><br><h2>  Deadletter handlers </h2><br>  We made it so that now the developer can hang his own handler on the message that was not processed by the ‚Äúnormal‚Äù handler.  For example: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deadletter_handler_handler_demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_first{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, st_second{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, st_third{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deadletter_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;some_msg&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normal_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;some_msg&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">//  ""    st_first. so_subscribe(some_mbox) .in(st_first).event(&amp;deadletter_handler_demo::normal_handler); //   "" . so_subscribe_deadletter_handler(some_mbox, &amp;deadletter_handler_demo::deadletter_handler); ... } };</span></span></code> </pre> <br>  Now, if the agent receives the some_msg message from the mailbox some_mbox in the st_first state, then normal_handler will be called to process the message.  But if the agent is in any other state, then the deadletter_handler will be called to process this message. <br><br>  This feature is just used time_limited-operations.  When the operation is activated, deadletter_handler hangs on the message about the expiration of the timeout.  And in whatever state the agent is at the time of arrival of this message, the message will be received and processed.  As allows to complete asynchronous operation.  Even in the case when the developer made a mistake and did not identify all the timeout handlers he needed. <br><br><h2>  Attractive idea that was not implemented </h2><br>  The first thought, which arose as soon as the problem of the deadletter handlers was formulated, was to provide each agent with a certain parental state.  And all the other states to automatically become children of him.  Those.  there was an idea to force some kind of superstate into each agent.  That just is and nothing to do with it :) <br><br>  This idea was very attractive from the point of view of the current mechanism for storing and searching subscriptions (this mechanism is not so simple). <br><br>  Also this idea is very beautiful from an ideological point of view.  Hierarchical finite automata as they are. <br><br>  But I had to give it up (maybe for a while?). <br><br>  The main reason for the failure is that the state_t object is rather heavy.  Depending on the compiler, standard library and compilation parameters, the state_t in 64-bit mode can occupy from 150 to 250 bytes.  If forcibly add superstate to each agent, then the ‚Äúweight‚Äù of each agent increases by one and a half to two hundred bytes.  Just like that, out of the blue.  Even if this agent does not need a super state at all. <br><br>  There was, and there is, in fact, another reason.  Superstate for each agent is too great an innovation for a SObjectizer to make it from the bay, <br>  not weighing carefully all the consequences.  I personally have a lot of suspicions about <br>  that it is worth adding superstates to SObjectizer and they will be abused. <br><br>  In general, the idea of ‚Äã‚Äãa superstate did not go to work on version 5.5.21.  But the notch for memory remained.  Perhaps she will still find her embodiment.  If someone has thoughts on this, it would be interesting to hear and discuss. <br><br><h2>  Actual decision </h2><br>  From the idea of ‚Äã‚Äãa superstate refused, but the current mechanism for storing subscriptions did not want to change.  Therefore, a solution was found that still required an additional state_t object.  But <a href="">he exists one for all</a> and all agents refer to him. <br><br>  Due to this, it was possible to use the same tools for registering deadletters handler-s and for their search.  In fact, so_subscribe_deadletter_handler is nothing more than <a href="">subscribing a message handler for a special, invisible state for the user</a> .  Well, the search for a deadletter handler for a message is just an <a href="">ordinary search for a handler</a> , but not for the current state of the agent, but for this special, invisible state.  There, however, there are <a href="">some additional actions</a> for the case when the trace mode of the message delivery mechanism is enabled, but these are boring details. <br><br><h2>  Was everything so obvious and simple? </h2><br>  When I read this article before publication, I caught myself thinking that some sort of trivialism was being told.  Well, everything seems to be simple and clear.  Only now the path to this ‚Äúsimple and understandable‚Äù turned out to be far from fast, not direct and not obvious.  If anyone is interested, then traces of the evolution of the idea of ‚Äã‚Äãasynchronous operations can be found in this mini-series of blog posts: <a href="http://eao197.blogspot.com.by/2017/12/progc-so-5.html"># 1</a> , <a href="http://eao197.blogspot.com.by/2017/12/progc-so-5_18.html"># 2,</a> and <a href="http://eao197.blogspot.com.by/2018/01/progc-sobjectizer.html"># 3</a> .  Although, as it turned out, even in the final post of this series, not a resultant solution was described.  I had to stumble upon a serious personal miscalculation and break my head over how to prevent memory leaks in the presence of cyclic references between objects.  But that's another story ... <br><br><h1>  A few words in conclusion </h1><br><h2>  First thanks ... </h2><br>  I would like to thank everyone who helps us develop SObjectizer: to those who use SO-5 and express their thoughts and suggestions (special thanks here to <a href="https://habrahabr.ru/users/pavelvainerman/" class="user_link">PavelVainerman</a> ), to those who have not yet used SO-5, but who help with advice and not only (great thanks, in particular, <a href="https://habrahabr.ru/users/masterspline/" class="user_link">masterspline</a> ), and simply those who are not too lazy to put +1 on the news about SObjectizer on various resources and asterisks <a href="https://github.com/eao197/so-5-5">on github-e</a> :) Thank you all very much! <br><br><h2>  ... and short plans for the near future </h2><br>  We are going to start work on the next version of SObjectizer, number 5.5.22, in the near future.  The main new feature that we want to see in 5.5.22 is parallel state support for agents.  Agents can already use advanced features of hierarchical states.  Like: state nesting, shallow and deep-history for states, input-output handlers, time limits for staying in state.  But what was not yet in SObjectizer was parallel states. <br><br>  At one time we did not do them for some reason.  But practice has shown that for some of the users, parallel states are necessary and make their lives easier.  So we will do them.  All interested persons are invited to discuss: any constructive considerations, and especially, examples from practice and personal experience will be very useful to us. <br><br>  Well, in general it would be interesting to know what impressions you have about SObjectizer, what you like, what you don‚Äôt like, what I would like to have in SO-5, what's stopping you ... Well, of course, we are ready to answer any questions about SObjectizer . </div><p>Source: <a href="https://habr.com/ru/post/348680/">https://habr.com/ru/post/348680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348670/index.html">How to stop spending a lot of time shopping?</a></li>
<li><a href="../348672/index.html">Blockchain on Go. Part 1: Prototype</a></li>
<li><a href="../348674/index.html">When work is your second family</a></li>
<li><a href="../348676/index.html">Cluster of Puppets: Amazon ECS Experience with iFunny</a></li>
<li><a href="../348678/index.html">IT events digest for February and March</a></li>
<li><a href="../348682/index.html">Deploy your Java environment with Ansible</a></li>
<li><a href="../348684/index.html">BLE400 board and development for nRF51822</a></li>
<li><a href="../348686/index.html">Journal of the work with the network. Part 1</a></li>
<li><a href="../348688/index.html">Run a full-fledged cluster on Kubernetes from scratch on Ubuntu 16.04</a></li>
<li><a href="../348690/index.html">Five problems and trends in information security: what to expect in 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>