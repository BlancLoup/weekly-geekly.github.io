<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a non-blocking TCP server using OTP principles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 It is assumed that the reader of this guide is already familiar with gen_server and gen_fsm behaviors, TCP socket interactions using th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a non-blocking TCP server using OTP principles</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  It is assumed that the reader of this guide is already familiar with <i>gen_server</i> and <i>gen_fsm</i> behaviors, TCP socket interactions using the <i>gen_tcp</i> module, active and passive socket modes, and the ‚ÄúOTP Supervisor‚Äù principle. <br><br>  OTP provides convenient tools for creating reliable applications.  In part, this is accomplished by abstracting the overall functionality into behaviors, such as <i>gen_server</i> and <i>gen_fsm</i> , which are related by the hierarchy of OTP supervisors. <br><br>  There are several known TCP server templates.  The one we are going to consider includes one listening process and the process of creating a new FSM process for each connected client.  Although there is support for TCP connections in OTP through the <i>gen_tcp</i> module, there is no standard behavior for creating a non-blocking TCP server based on the principles of OTP.  By a non-blocking server, we mean that the listening process and the FSM process should not make any blocking calls and quickly respond to incoming messages (for example, changes in configuration, restart, etc.) without causing timeouts.  Note that locking in the Erlang context means locking the Erlang process, not the operating system process. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this tutorial, we show how to create a non-blocking TCP server using <i>gen_server</i> and <i>gen_fsm</i> , which provide control over application behavior and fully comply with OTP principles. <br><br>  A reader who is not familiar with OTP is advised to pay attention to Joe Armstrong's guide on how to build fault-tolerant servers using <i>gen_tcp: connect / 3</i> and <i>gen_tcp: acceept / 1</i> blocking calls without using OTP. <br><a name="habracut"></a><br><h4>  Server structure </h4><br>  The design of our server will include the main process supervisor of the <i>tcp_server_app</i> application with the restart strategy <i>one_for_one</i> and two child processes.  The first of which is a listening process, implemented as <i>gen_server</i> , which will wait for asynchronous notifications about client connections.  The second is another application supervisor, <i>tcp_client_sup,</i> and is responsible for starting the FSM process for handling client requests and registering abnormal outages using standard SASL error reports. <br><br>  For the sake of simplicity, the client request handler (tcp_echo_fsm) will provide an ‚ÄúEcho‚Äù server that will return client requests back. <br><br><h4>  Application Behavior and Supervisors </h4><br>  In order to create our application, we need to write modules that implement the callback functions of the ‚ÄúSupervisor‚Äù and ‚ÄúApplication‚Äù behaviors.  Although traditionally these functions are implemented in separate modules, given their brevity, we combine them into one. <br><br>  As an added bonus, we will implement the <i>get_app_env</i> function, which shows how to handle the configuration parameters, as well as the command line parameters of the emulator at startup. <br><br>  Two instances of the <i>init / 1</i> function are needed for two levels of the supervisor hierarchy.  Since two different restart strategies are used, we implement them at different levels. <br><br>  After the application starts, the callback function <i>tcp_server_app: start / 2</i> calls the <i>supervisor: start_link / 2</i> function, which creates the application's main supervisor by calling <i>tcp_server_app: init ([Port, Module])</i> .  This supervisor creates the <i>tcp_listener</i> process and the child supervisor <i>tcp_client_sup</i> responsible for handling client connections.  The <i>Module</i> argument in the <i>init</i> function is the name of the FSM handler for client connections (in this case, <i>tcp_echo_fsm</i> ). <br><br>  TCP Server Application (tcp_server_app.erl): <br><pre><code class="hljs mel">-module(tcp_server_app). -author(<span class="hljs-string"><span class="hljs-string">'saleyn@gmail.com'</span></span>). -behaviour(application). %% Internal API -export([start_client/<span class="hljs-number"><span class="hljs-number">0</span></span>]). %% Application and Supervisor callbacks -export([start/<span class="hljs-number"><span class="hljs-number">2</span></span>, stop/<span class="hljs-number"><span class="hljs-number">1</span></span>, init/<span class="hljs-number"><span class="hljs-number">1</span></span>]). -define(MAX_RESTART, <span class="hljs-number"><span class="hljs-number">5</span></span>). -define(MAX_TIME, <span class="hljs-number"><span class="hljs-number">60</span></span>). -define(DEF_PORT, <span class="hljs-number"><span class="hljs-number">2222</span></span>). %% A startup function <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> spawning new client connection handling FSM. %% To be called by the TCP listener process. start_client() -&gt; supervisor:start_child(tcp_client_sup, []). %%---------------------------------------------------------------------- %% Application behaviour callbacks %%---------------------------------------------------------------------- start(_Type, _Args) -&gt; ListenPort = get_app_env(listen_port, ?DEF_PORT), supervisor:start_link({local, ?MODULE}, ?MODULE, [ListenPort, tcp_echo_fsm]). stop(_S) -&gt; ok. %%---------------------------------------------------------------------- %% Supervisor behaviour callbacks %%---------------------------------------------------------------------- init([Port, Module]) -&gt; {ok, {_SupFlags = {one_for_one, ?MAX_RESTART, ?MAX_TIME}, [ % TCP Listener { tcp_server_sup, % Id = internal id {tcp_listener,start_link,[Port,Module]}, % StartFun = {M, F, A} permanent, % Restart = permanent | transient | temporary <span class="hljs-number"><span class="hljs-number">2000</span></span>, % Shutdown = brutal_kill | <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>() &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> | infinity worker, % Type = worker | supervisor [tcp_listener] % Modules = [Module] | dynamic }, % Client <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> supervisor { tcp_client_sup, {supervisor,start_link,[{local, tcp_client_sup}, ?MODULE, [Module]]}, permanent, % Restart = permanent | transient | temporary infinity, % Shutdown = brutal_kill | <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>() &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> | infinity supervisor, % Type = worker | supervisor [] % Modules = [Module] | dynamic } ] } }; init([Module]) -&gt; {ok, {_SupFlags = {simple_one_for_one, ?MAX_RESTART, ?MAX_TIME}, [ % TCP Client { undefined, % Id = internal id {Module,start_link,[]}, % StartFun = {M, F, A} temporary, % Restart = permanent | transient | temporary <span class="hljs-number"><span class="hljs-number">2000</span></span>, % Shutdown = brutal_kill | <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>() &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> | infinity worker, % Type = worker | supervisor [] % Modules = [Module] | dynamic } ] } }. %%---------------------------------------------------------------------- %% Internal functions %%---------------------------------------------------------------------- get_app_env(Opt, Default) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> application:get_env(application:get_application(), Opt) of {ok, Val} -&gt; Val; _ -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> init:get_argument(Opt) of [[Val | _]] -&gt; Val; <span class="hljs-keyword"><span class="hljs-keyword">error</span></span> -&gt; Default end end.</code> </pre> <br><br><h4>  Listening process </h4><br>  One of the drawbacks of the <i>gen_tcp</i> module is that it provides an interface only for blocking acceptance of connections. <br><br>  Testing the <i>prim_inet</i> module showed an interesting fact that the command to the network driver to accept the client connection is asynchronous.  Although it is not documented, which means that the OTP team can change this at any time, we will use this functionality in creating our server. <br><br>  The listening process is implemented as <i>gen_server</i> . <br>  TCP Listener Process (tcp_listener.erl): <br><pre> <code class="hljs scala">-module(tcp_listener). -author(<span class="hljs-symbol"><span class="hljs-symbol">'saleyn</span></span><span class="hljs-meta"><span class="hljs-meta">@gmail</span></span>.com'). -behaviour(gen_server). %% <span class="hljs-type"><span class="hljs-type">External</span></span> <span class="hljs-type"><span class="hljs-type">API</span></span> -export([start_link/<span class="hljs-number"><span class="hljs-number">2</span></span>]). %% gen_server callbacks -export([init/<span class="hljs-number"><span class="hljs-number">1</span></span>, handle_call/<span class="hljs-number"><span class="hljs-number">3</span></span>, handle_cast/<span class="hljs-number"><span class="hljs-number">2</span></span>, handle_info/<span class="hljs-number"><span class="hljs-number">2</span></span>, terminate/<span class="hljs-number"><span class="hljs-number">2</span></span>, code_change/<span class="hljs-number"><span class="hljs-number">3</span></span>]). -record(state, { listener, % <span class="hljs-type"><span class="hljs-type">Listening</span></span> socket acceptor, % <span class="hljs-type"><span class="hljs-type">Asynchronous</span></span> acceptor<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> internal reference module % <span class="hljs-type"><span class="hljs-type">FSM</span></span> handling module }). %%-------------------------------------------------------------------- %% <span class="hljs-meta"><span class="hljs-meta">@spec</span></span> (<span class="hljs-type"><span class="hljs-type">Port</span></span>::integer(), <span class="hljs-type"><span class="hljs-type">Module</span></span>) -&gt; {ok, <span class="hljs-type"><span class="hljs-type">Pid</span></span>} | {error, <span class="hljs-type"><span class="hljs-type">Reason</span></span>} % %% <span class="hljs-meta"><span class="hljs-meta">@doc</span></span> <span class="hljs-type"><span class="hljs-type">Called</span></span> by a supervisor to start the listening process. %% <span class="hljs-meta"><span class="hljs-meta">@end</span></span> %%---------------------------------------------------------------------- start_link(<span class="hljs-type"><span class="hljs-type">Port</span></span>, <span class="hljs-type"><span class="hljs-type">Module</span></span>) when is_integer(<span class="hljs-type"><span class="hljs-type">Port</span></span>), is_atom(<span class="hljs-type"><span class="hljs-type">Module</span></span>) -&gt; gen_server:start_link({local, ?<span class="hljs-type"><span class="hljs-type">MODULE</span></span>}, ?<span class="hljs-type"><span class="hljs-type">MODULE</span></span>, [<span class="hljs-type"><span class="hljs-type">Port</span></span>, <span class="hljs-type"><span class="hljs-type">Module</span></span>], []). %%%------------------------------------------------------------------------ %%% <span class="hljs-type"><span class="hljs-type">Callback</span></span> functions from gen_server %%%------------------------------------------------------------------------ %%---------------------------------------------------------------------- %% <span class="hljs-meta"><span class="hljs-meta">@spec</span></span> (<span class="hljs-type"><span class="hljs-type">Port</span></span>::integer()) -&gt; {ok, <span class="hljs-type"><span class="hljs-type">State</span></span>} | %% {ok, <span class="hljs-type"><span class="hljs-type">State</span></span>, <span class="hljs-type"><span class="hljs-type">Timeout</span></span>} | %% ignore | %% {stop, <span class="hljs-type"><span class="hljs-type">Reason</span></span>} %% %% <span class="hljs-meta"><span class="hljs-meta">@doc</span></span> <span class="hljs-type"><span class="hljs-type">Called</span></span> by gen_server framework at process startup. %% <span class="hljs-type"><span class="hljs-type">Create</span></span> listening socket. %% <span class="hljs-meta"><span class="hljs-meta">@end</span></span> %%---------------------------------------------------------------------- init([<span class="hljs-type"><span class="hljs-type">Port</span></span>, <span class="hljs-type"><span class="hljs-type">Module</span></span>]) -&gt; process_flag(trap_exit, <span class="hljs-literal"><span class="hljs-literal">true</span></span>), <span class="hljs-type"><span class="hljs-type">Opts</span></span> = [binary, {packet, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {reuseaddr, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {keepalive, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {backlog, <span class="hljs-number"><span class="hljs-number">30</span></span>}, {active, <span class="hljs-literal"><span class="hljs-literal">false</span></span>}], <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> gen_tcp:listen(<span class="hljs-type"><span class="hljs-type">Port</span></span>, <span class="hljs-type"><span class="hljs-type">Opts</span></span>) of {ok, <span class="hljs-type"><span class="hljs-type">Listen_socket</span></span>} -&gt; %%<span class="hljs-type"><span class="hljs-type">Create</span></span> first accepting process {ok, <span class="hljs-type"><span class="hljs-type">Ref</span></span>} = prim_inet:async_accept(<span class="hljs-type"><span class="hljs-type">Listen_socket</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>), {ok, #state{listener = <span class="hljs-type"><span class="hljs-type">Listen_socket</span></span>, acceptor = <span class="hljs-type"><span class="hljs-type">Ref</span></span>, module = <span class="hljs-type"><span class="hljs-type">Module</span></span>}}; {error, <span class="hljs-type"><span class="hljs-type">Reason</span></span>} -&gt; {stop, <span class="hljs-type"><span class="hljs-type">Reason</span></span>} end. %%------------------------------------------------------------------------- %% <span class="hljs-meta"><span class="hljs-meta">@spec</span></span> (<span class="hljs-type"><span class="hljs-type">Request</span></span>, <span class="hljs-type"><span class="hljs-type">From</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>) -&gt; {reply, <span class="hljs-type"><span class="hljs-type">Reply</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>} | %% {reply, <span class="hljs-type"><span class="hljs-type">Reply</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>, <span class="hljs-type"><span class="hljs-type">Timeout</span></span>} | %% {noreply, <span class="hljs-type"><span class="hljs-type">State</span></span>} | %% {noreply, <span class="hljs-type"><span class="hljs-type">State</span></span>, <span class="hljs-type"><span class="hljs-type">Timeout</span></span>} | %% {stop, <span class="hljs-type"><span class="hljs-type">Reason</span></span>, <span class="hljs-type"><span class="hljs-type">Reply</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>} | %% {stop, <span class="hljs-type"><span class="hljs-type">Reason</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>} %% <span class="hljs-meta"><span class="hljs-meta">@doc</span></span> <span class="hljs-type"><span class="hljs-type">Callback</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> synchronous server calls. <span class="hljs-type"><span class="hljs-type">If</span></span> `{stop, ...}' tuple %% is returned, the server is stopped and `terminate/<span class="hljs-number"><span class="hljs-number">2</span></span>' is called. %% <span class="hljs-meta"><span class="hljs-meta">@end</span></span> %% <span class="hljs-meta"><span class="hljs-meta">@private</span></span> %%------------------------------------------------------------------------- handle_call(<span class="hljs-type"><span class="hljs-type">Request</span></span>, _From, <span class="hljs-type"><span class="hljs-type">State</span></span>) -&gt; {stop, {unknown_call, <span class="hljs-type"><span class="hljs-type">Request</span></span>}, <span class="hljs-type"><span class="hljs-type">State</span></span>}. %%------------------------------------------------------------------------- %% <span class="hljs-meta"><span class="hljs-meta">@spec</span></span> (<span class="hljs-type"><span class="hljs-type">Msg</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>) -&gt;{noreply, <span class="hljs-type"><span class="hljs-type">State</span></span>} | %% {noreply, <span class="hljs-type"><span class="hljs-type">State</span></span>, <span class="hljs-type"><span class="hljs-type">Timeout</span></span>} | %% {stop, <span class="hljs-type"><span class="hljs-type">Reason</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>} %% <span class="hljs-meta"><span class="hljs-meta">@doc</span></span> <span class="hljs-type"><span class="hljs-type">Callback</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> asyncrous server calls. <span class="hljs-type"><span class="hljs-type">If</span></span> `{stop, ...}' tuple %% is returned, the server is stopped and `terminate/<span class="hljs-number"><span class="hljs-number">2</span></span>' is called. %% <span class="hljs-meta"><span class="hljs-meta">@end</span></span> %% <span class="hljs-meta"><span class="hljs-meta">@private</span></span> %%------------------------------------------------------------------------- handle_cast(_Msg, <span class="hljs-type"><span class="hljs-type">State</span></span>) -&gt; {noreply, <span class="hljs-type"><span class="hljs-type">State</span></span>}. %%------------------------------------------------------------------------- %% <span class="hljs-meta"><span class="hljs-meta">@spec</span></span> (<span class="hljs-type"><span class="hljs-type">Msg</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>) -&gt;{noreply, <span class="hljs-type"><span class="hljs-type">State</span></span>} | %% {noreply, <span class="hljs-type"><span class="hljs-type">State</span></span>, <span class="hljs-type"><span class="hljs-type">Timeout</span></span>} | %% {stop, <span class="hljs-type"><span class="hljs-type">Reason</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>} %% <span class="hljs-meta"><span class="hljs-meta">@doc</span></span> <span class="hljs-type"><span class="hljs-type">Callback</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> messages sent directly to server<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> mailbox. %% <span class="hljs-type"><span class="hljs-type">If</span></span> `{stop, ...}' tuple is returned, the server is stopped and %% `terminate/<span class="hljs-number"><span class="hljs-number">2</span></span>' is called. %% <span class="hljs-meta"><span class="hljs-meta">@end</span></span> %% <span class="hljs-meta"><span class="hljs-meta">@private</span></span> %%------------------------------------------------------------------------- handle_info({inet_async, <span class="hljs-type"><span class="hljs-type">ListSock</span></span>, <span class="hljs-type"><span class="hljs-type">Ref</span></span>, {ok, <span class="hljs-type"><span class="hljs-type">CliSocket</span></span>}}, #state{listener=<span class="hljs-type"><span class="hljs-type">ListSock</span></span>, acceptor=<span class="hljs-type"><span class="hljs-type">Ref</span></span>, module=<span class="hljs-type"><span class="hljs-type">Module</span></span>} = <span class="hljs-type"><span class="hljs-type">State</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> set_sockopt(<span class="hljs-type"><span class="hljs-type">ListSock</span></span>, <span class="hljs-type"><span class="hljs-type">CliSocket</span></span>) of ok -&gt; ok; {error, <span class="hljs-type"><span class="hljs-type">Reason</span></span>} -&gt; exit({set_sockopt, <span class="hljs-type"><span class="hljs-type">Reason</span></span>}) end, %% <span class="hljs-type"><span class="hljs-type">New</span></span> client connected - spawn a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> process using the simple_one_for_one %% supervisor. {ok, <span class="hljs-type"><span class="hljs-type">Pid</span></span>} = tcp_server_app:start_client(), gen_tcp:controlling_process(<span class="hljs-type"><span class="hljs-type">CliSocket</span></span>, <span class="hljs-type"><span class="hljs-type">Pid</span></span>), %% <span class="hljs-type"><span class="hljs-type">Instruct</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">FSM</span></span> that it owns the socket. <span class="hljs-type"><span class="hljs-type">Module</span></span>:set_socket(<span class="hljs-type"><span class="hljs-type">Pid</span></span>, <span class="hljs-type"><span class="hljs-type">CliSocket</span></span>), %% <span class="hljs-type"><span class="hljs-type">Signal</span></span> the network driver that we are ready to accept another connection <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> prim_inet:async_accept(<span class="hljs-type"><span class="hljs-type">ListSock</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) of {ok, <span class="hljs-type"><span class="hljs-type">NewRef</span></span>} -&gt; ok; {error, <span class="hljs-type"><span class="hljs-type">NewRef</span></span>} -&gt; exit({async_accept, inet:format_error(<span class="hljs-type"><span class="hljs-type">NewRef</span></span>)}) end, {noreply, <span class="hljs-type"><span class="hljs-type">State</span></span>#state{acceptor=<span class="hljs-type"><span class="hljs-type">NewRef</span></span>}} <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> exit:<span class="hljs-type"><span class="hljs-type">Why</span></span> -&gt; error_logger:error_msg(<span class="hljs-string"><span class="hljs-string">"Error in async accept: ~p.\n"</span></span>, [<span class="hljs-type"><span class="hljs-type">Why</span></span>]), {stop, <span class="hljs-type"><span class="hljs-type">Why</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>} end; handle_info({inet_async, <span class="hljs-type"><span class="hljs-type">ListSock</span></span>, <span class="hljs-type"><span class="hljs-type">Ref</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>}, #state{listener=<span class="hljs-type"><span class="hljs-type">ListSock</span></span>, acceptor=<span class="hljs-type"><span class="hljs-type">Ref</span></span>} = <span class="hljs-type"><span class="hljs-type">State</span></span>) -&gt; error_logger:error_msg(<span class="hljs-string"><span class="hljs-string">"Error in socket acceptor: ~p.\n"</span></span>, [<span class="hljs-type"><span class="hljs-type">Error</span></span>]), {stop, <span class="hljs-type"><span class="hljs-type">Error</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>}; handle_info(_Info, <span class="hljs-type"><span class="hljs-type">State</span></span>) -&gt; {noreply, <span class="hljs-type"><span class="hljs-type">State</span></span>}. %%------------------------------------------------------------------------- %% <span class="hljs-meta"><span class="hljs-meta">@spec</span></span> (<span class="hljs-type"><span class="hljs-type">Reason</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>) -&gt; any %% <span class="hljs-meta"><span class="hljs-meta">@doc</span></span> <span class="hljs-type"><span class="hljs-type">Callback</span></span> executed on server shutdown. <span class="hljs-type"><span class="hljs-type">It</span></span> is only invoked <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> %% `process_flag(trap_exit, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)' is set by the server process. %% <span class="hljs-type"><span class="hljs-type">The</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value is ignored. %% <span class="hljs-meta"><span class="hljs-meta">@end</span></span> %% <span class="hljs-meta"><span class="hljs-meta">@private</span></span> %%------------------------------------------------------------------------- terminate(_Reason, <span class="hljs-type"><span class="hljs-type">State</span></span>) -&gt; gen_tcp:close(<span class="hljs-type"><span class="hljs-type">State</span></span>#state.listener), ok. %%------------------------------------------------------------------------- %% <span class="hljs-meta"><span class="hljs-meta">@spec</span></span> (<span class="hljs-type"><span class="hljs-type">OldVsn</span></span>, <span class="hljs-type"><span class="hljs-type">State</span></span>, <span class="hljs-type"><span class="hljs-type">Extra</span></span>) -&gt; {ok, <span class="hljs-type"><span class="hljs-type">NewState</span></span>} %% <span class="hljs-meta"><span class="hljs-meta">@doc</span></span> <span class="hljs-type"><span class="hljs-type">Convert</span></span> process state when code is changed. %% <span class="hljs-meta"><span class="hljs-meta">@end</span></span> %% <span class="hljs-meta"><span class="hljs-meta">@private</span></span> %%------------------------------------------------------------------------- code_change(_OldVsn, <span class="hljs-type"><span class="hljs-type">State</span></span>, _Extra) -&gt; {ok, <span class="hljs-type"><span class="hljs-type">State</span></span>}. %%%------------------------------------------------------------------------ %%% <span class="hljs-type"><span class="hljs-type">Internal</span></span> functions %%%------------------------------------------------------------------------ %% <span class="hljs-type"><span class="hljs-type">Taken</span></span> from prim_inet. <span class="hljs-type"><span class="hljs-type">We</span></span> are merely copying some socket options from the %% listening socket to the <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> client socket. set_sockopt(<span class="hljs-type"><span class="hljs-type">ListSock</span></span>, <span class="hljs-type"><span class="hljs-type">CliSocket</span></span>) -&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> = inet_db:register_socket(<span class="hljs-type"><span class="hljs-type">CliSocket</span></span>, inet_tcp), <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> prim_inet:getopts(<span class="hljs-type"><span class="hljs-type">ListSock</span></span>, [active, nodelay, keepalive, delay_send, priority, tos]) of {ok, <span class="hljs-type"><span class="hljs-type">Opts</span></span>} -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> prim_inet:setopts(<span class="hljs-type"><span class="hljs-type">CliSocket</span></span>, <span class="hljs-type"><span class="hljs-type">Opts</span></span>) of ok -&gt; ok; <span class="hljs-type"><span class="hljs-type">Error</span></span> -&gt; gen_tcp:close(<span class="hljs-type"><span class="hljs-type">CliSocket</span></span>), <span class="hljs-type"><span class="hljs-type">Error</span></span> end; <span class="hljs-type"><span class="hljs-type">Error</span></span> -&gt; gen_tcp:close(<span class="hljs-type"><span class="hljs-type">CliSocket</span></span>), <span class="hljs-type"><span class="hljs-type">Error</span></span> end.</code> </pre><br><br>  In this module, <i>init / 1</i> takes two parameters ‚Äî the port number that the listening process should open and the name of the client connection handler.  The initialization function opens the socket in passive mode.  This is done so that we have control over the flow of data received from the client. <br><br>  The most interesting part of this code is the <i>priminet</i> call <i>: async_accept / 2</i> .  In order to make it work, we need to copy part of the internal OTP code from the <i>set_sockopt / 2</i> function, which handles registering sockets and copying some options for a client socket. <br><br>  As soon as the client socket is connected, the network driver will notify the listening process with the message <i>{inet_async, ListSock, Ref, {OK, CliSocket}}</i> .  At the moment, we are launching an instance of the process of processing client requests and transferring it to CliSocket. <br><br><h4>  Client Message Processing </h4><br>  While <i>tcp_listener</i> is a generic implementation, <i>tcp_echo_fsm</i> is nothing more than a FSM stub for describing how to create a TCP server.  Two functions must be exported from this module ‚Äî <i>start_link / 0</i> for the <i>tcp_client_sup</i> and <i>set_socket / 2</i> supervisors for the listening process so that the latter notifies the processing of client messages that it becomes the owner of the socket and can start receiving messages by setting <i>{active, once}</i> or <i>{active, true}</i> option. <br><br>  We would like to emphasize the synchronization pattern used between the listening process and the client, in order to avoid possible loss of a message in connection with the transfer of them to the wrong (listening) process.  A process owning a socket keeps it open in passive mode.  Next, the client process accepts a socket that inherits the options (including the passive mode) from the listening process.  Ownership of the socket is passed to the client process by calling <i>gen_tcp: controlling_process / 2</i> and <i>set_socket / 2</i> , which notifies the client process that it can start receiving messages from the socket.  Until the moment when the socket is set to active mode, all received data will be stored in the socket buffer. <br><br>  When the ownership of the socket is transferred to the client's FSM-process in the <i>‚ÄúWAIT_FOR_SOCKET‚Äù</i> state, <i>{active, once}</i> mode is set to allow the network driver to send one message at a time.  This is the OTP principle used to maintain control over the flow of data and avoid mixing messages and TCP traffic in the process queue. <br><br>  FSM states are implemented using special functions in the <i>tcp_echo_fsm</i> module, which uses the naming convention.  FSM consists of two states.  <i>WAIT_FOR_SOCKET</i> is the initial state in which the FSM is waiting for ownership of the socket, and <i>WAIT_FOR_DATA</i> , which is the wait state of the TCP message from the client.  In this state, the FSM also processes a special ‚Äútimeout‚Äù message, which means there is no activity from the client and causes the process to close the connection with the client. <br><br><pre> <code class="hljs mel">-module(tcp_echo_fsm). -author(<span class="hljs-string"><span class="hljs-string">'saleyn@gmail.com'</span></span>). -behaviour(gen_fsm). -export([start_link/<span class="hljs-number"><span class="hljs-number">0</span></span>, set_socket/<span class="hljs-number"><span class="hljs-number">2</span></span>]). %% gen_fsm callbacks -export([init/<span class="hljs-number"><span class="hljs-number">1</span></span>, handle_event/<span class="hljs-number"><span class="hljs-number">3</span></span>, handle_sync_event/<span class="hljs-number"><span class="hljs-number">4</span></span>, handle_info/<span class="hljs-number"><span class="hljs-number">3</span></span>, terminate/<span class="hljs-number"><span class="hljs-number">3</span></span>, code_change/<span class="hljs-number"><span class="hljs-number">4</span></span>]). %% FSM States -export([ <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_SOCKET'</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_DATA'</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> ]). -record(state, { socket, % client socket addr % client address }). -define(TIMEOUT, <span class="hljs-number"><span class="hljs-number">120000</span></span>). %%%------------------------------------------------------------------------ %%% API %%%------------------------------------------------------------------------ %%------------------------------------------------------------------------- %% @spec (Socket) -&gt; {ok,Pid} | ignore | {<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>,Error} %% @doc To be called by the supervisor <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> order to start the server. %% If init/<span class="hljs-number"><span class="hljs-number">1</span></span> fails with Reason, the function returns {<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>,Reason}. %% If init/<span class="hljs-number"><span class="hljs-number">1</span></span> returns {stop,Reason} or ignore, the process is %% terminated and the function returns {<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>,Reason} or ignore, %% respectively. %% @end %%------------------------------------------------------------------------- start_link() -&gt; gen_fsm:start_link(?MODULE, [], []). set_socket(Pid, Socket) when is_pid(Pid), is_port(Socket) -&gt; gen_fsm:send_event(Pid, {socket_ready, Socket}). %%%------------------------------------------------------------------------ %%% Callback functions from gen_server %%%------------------------------------------------------------------------ %%------------------------------------------------------------------------- %% Func: init/<span class="hljs-number"><span class="hljs-number">1</span></span> %% Returns: {ok, StateName, StateData} | %% {ok, StateName, StateData, Timeout} | %% ignore | %% {stop, StopReason} %% @private %%------------------------------------------------------------------------- init([]) -&gt; process_flag(trap_exit, true), {ok, <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_SOCKET'</span></span>, #state{}}. %%------------------------------------------------------------------------- %% Func: StateName/<span class="hljs-number"><span class="hljs-number">2</span></span> %% Returns: {next_state, NextStateName, NextStateData} | %% {next_state, NextStateName, NextStateData, Timeout} | %% {stop, Reason, NewStateData} %% @private %%------------------------------------------------------------------------- <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_SOCKET'</span></span>({socket_ready, Socket}, State) when is_port(Socket) -&gt; % Now we own the socket inet:setopts(Socket, [{active, once}, {packet, <span class="hljs-number"><span class="hljs-number">2</span></span>}, binary]), {ok, {IP, _Port}} = inet:peername(Socket), {next_state, <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_DATA'</span></span>, State#state{socket=Socket, addr=IP}, ?TIMEOUT}; <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_SOCKET'</span></span>(Other, State) -&gt; error_logger:error_msg(<span class="hljs-string"><span class="hljs-string">"State: 'WAIT_FOR_SOCKET'. Unexpected message: ~p\n"</span></span>, [Other]), %% Allow to receive async messages {next_state, <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_SOCKET'</span></span>, State}. %% Notification <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> coming from client <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_DATA'</span></span>({data, Data}, #state{socket=S} = State) -&gt; ok = gen_tcp:send(S, Data), {next_state, <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_DATA'</span></span>, State, ?TIMEOUT}; <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_DATA'</span></span>(timeout, State) -&gt; error_logger:error_msg(<span class="hljs-string"><span class="hljs-string">"~p Client connection timeout - closing.\n"</span></span>, [self()]), {stop, normal, State}; <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_DATA'</span></span>(Data, State) -&gt; io:<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>(<span class="hljs-string"><span class="hljs-string">"~p Ignoring data: ~p\n"</span></span>, [self(), Data]), {next_state, <span class="hljs-string"><span class="hljs-string">'WAIT_FOR_DATA'</span></span>, State, ?TIMEOUT}. %%------------------------------------------------------------------------- %% Func: handle_event/<span class="hljs-number"><span class="hljs-number">3</span></span> %% Returns: {next_state, NextStateName, NextStateData} | %% {next_state, NextStateName, NextStateData, Timeout} | %% {stop, Reason, NewStateData} %% @private %%------------------------------------------------------------------------- handle_event(Event, StateName, StateData) -&gt; {stop, {StateName, undefined_event, Event}, StateData}. %%------------------------------------------------------------------------- %% Func: handle_sync_event/<span class="hljs-number"><span class="hljs-number">4</span></span> %% Returns: {next_state, NextStateName, NextStateData} | %% {next_state, NextStateName, NextStateData, Timeout} | %% {reply, Reply, NextStateName, NextStateData} | %% {reply, Reply, NextStateName, NextStateData, Timeout} | %% {stop, Reason, NewStateData} | %% {stop, Reason, Reply, NewStateData} %% @private %%------------------------------------------------------------------------- handle_sync_event(Event, _From, StateName, StateData) -&gt; {stop, {StateName, undefined_event, Event}, StateData}. %%------------------------------------------------------------------------- %% Func: handle_info/<span class="hljs-number"><span class="hljs-number">3</span></span> %% Returns: {next_state, NextStateName, NextStateData} | %% {next_state, NextStateName, NextStateData, Timeout} | %% {stop, Reason, NewStateData} %% @private %%------------------------------------------------------------------------- handle_info({tcp, Socket, Bin}, StateName, #state{socket=Socket} = StateData) -&gt; % Flow <span class="hljs-keyword"><span class="hljs-keyword">control</span></span>: enable forwarding of next TCP message inet:setopts(Socket, [{active, once}]), ?MODULE:StateName({data, Bin}, StateData); handle_info({tcp_closed, Socket}, _StateName, #state{socket=Socket, addr=Addr} = StateData) -&gt; error_logger:info_msg(<span class="hljs-string"><span class="hljs-string">"~p Client ~p disconnected.\n"</span></span>, [self(), Addr]), {stop, normal, StateData}; handle_info(_Info, StateName, StateData) -&gt; {noreply, StateName, StateData}. %%------------------------------------------------------------------------- %% Func: terminate/<span class="hljs-number"><span class="hljs-number">3</span></span> %% Purpose: Shutdown the fsm %% Returns: any %% @private %%------------------------------------------------------------------------- terminate(_Reason, _StateName, #state{socket=Socket}) -&gt; (<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> gen_tcp:close(Socket)), ok. %%------------------------------------------------------------------------- %% Func: code_change/<span class="hljs-number"><span class="hljs-number">4</span></span> %% Purpose: Convert process state when code is changed %% Returns: {ok, NewState, NewStateData} %% @private %%------------------------------------------------------------------------- code_change(_OldVsn, StateName, StateData, _Extra) -&gt; {ok, StateName, StateData}.</code> </pre><br><br><h4>  Application Description </h4><br>  Another necessary part of creating an OTP application is to create a configuration file that contains the application name, version, start module, and environment variables. <br><br>  Application File (tcp_server.app): <br><pre> <code class="hljs mel">{application, tcp_server, [ {description, <span class="hljs-string"><span class="hljs-string">"Demo TCP server"</span></span>}, {vsn, <span class="hljs-string"><span class="hljs-string">"1.0"</span></span>}, {id, <span class="hljs-string"><span class="hljs-string">"tcp_server"</span></span>}, {modules, [tcp_listener, tcp_echo_fsm]}, {registered, [tcp_server_sup, tcp_listener]}, {applications, [kernel, stdlib]}, %% %% mod: Specify the module name to start the application, plus args %% {mod, {tcp_server_app, []}}, {<span class="hljs-keyword"><span class="hljs-keyword">env</span></span>, []} ] }.</code> </pre> <br><br><h4>  Compilation </h4><br>  Create the following directory structure for this application: <br><br><pre> <code class="hljs coffeescript">.<span class="hljs-regexp"><span class="hljs-regexp">/tcp_server ./tcp_server/ebin/</span></span> ./tcp_server/ebin/tcp_server.app ./tcp_server/src/tcp_server_app.erl ./tcp_server/src/tcp_listener.erl ./tcp_server/src/tcp_echo_fsm.erl</code> </pre><br><pre> <code class="hljs ruby">$ cd tcp_server/src $ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tcp*.erl ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> erlc +debug_info -o ../ebin $f</code> </pre><br><h4>  Launch </h4><br>  We are going to run an Erlang shell with SASL support so that we can see the status of processes and error reports for our application.  In addition, we are going to zapsutit appmon application in order to visually examine the hierarchy of supervisors. <br><br><pre> <code class="hljs dos">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../ebin $ erl -boot start_sasl ... <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; appmon:<span class="hljs-built_in"><span class="hljs-built_in">start</span></span>(). {ok,&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">44</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;} <span class="hljs-number"><span class="hljs-number">2</span></span>&gt; application:<span class="hljs-built_in"><span class="hljs-built_in">start</span></span>(tcp_server). ok</code> </pre><br><br>  Now click on the <i>tcp_server</i> button in the appmon application to display the hierarchy of application supervisors. <br><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">3&gt; </span></span>{ok,S} = gen_tcp:connect({<span class="hljs-number"><span class="hljs-number">127</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>},<span class="hljs-number"><span class="hljs-number">2222</span></span>,[{packet,<span class="hljs-number"><span class="hljs-number">2</span></span>}]). {ok,#Port&lt;<span class="hljs-number"><span class="hljs-number">0.150</span></span>&gt;}</code> </pre><br><br>  We have just initiated a new connection for the Echo Server client. <br><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">4&gt; </span></span>gen_tcp:send(S,&lt;&lt;<span class="hljs-string"><span class="hljs-string">"hello"</span></span>&gt;&gt;). ok <span class="hljs-number"><span class="hljs-number">5</span></span>&gt; f(M), receive M -&gt; M end. {tcp,#Port&lt;<span class="hljs-number"><span class="hljs-number">0.150</span></span>&gt;,<span class="hljs-string"><span class="hljs-string">"hello"</span></span>}</code> </pre><br><br>  We checked that the echo server was working as expected.  Now let's try to ‚Äúput‚Äù the client connection on the server and look at the generation of the error message. <br><br><pre> <code class="hljs erlang-repl"><span class="hljs-meta"><span class="hljs-meta">6&gt; </span></span>[{_,Pid,_,_}] = supervisor:which_children(tcp_client_sup). [{undefined,&lt;<span class="hljs-number"><span class="hljs-number">0.64</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;,worker,[]}] <span class="hljs-number"><span class="hljs-number">7</span></span>&gt; exit(Pid,kill). true =SUPERVISOR REPORT==== <span class="hljs-number"><span class="hljs-number">31</span></span>-Jul-<span class="hljs-number"><span class="hljs-number">2007</span></span>::<span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">33</span></span>:<span class="hljs-number"><span class="hljs-number">49</span></span> === Supervisor: {local,tcp_client_sup} Context: child_terminated Reason: killed Offender: [{pid,&lt;<span class="hljs-number"><span class="hljs-number">0.77</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;}, {name,undefined}, {mfa,{tcp_echo_fsm,start_link,[]}}, {restart_type,temporary}, {shutdown,<span class="hljs-number"><span class="hljs-number">2000</span></span>}, {child_type,worker}]</code> </pre><br><br>  Note that if you get the server under load using a large number of connections, the listening process may not accept new connections after a certain limit set in the operating system.  In this case, you will see an error message: <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"too many open files"</span></span></code> </pre><br><br><h4>  Conclusion </h4><br>  OTP provides building blocks for building non-blocking TCP servers.  This guide shows how to create a simple server using standard OTP behavior. </div><p>Source: <a href="https://habr.com/ru/post/111268/">https://habr.com/ru/post/111268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111262/index.html">"The escape"</a></li>
<li><a href="../111264/index.html">Drupal Forms API. Part 1 - for Drupal 6</a></li>
<li><a href="../111265/index.html">Organization of team development of database structures</a></li>
<li><a href="../111266/index.html">Intercepting system calls with ptrace</a></li>
<li><a href="../111267/index.html">Zappos.com: How to earn $ 1 billion on shoes?</a></li>
<li><a href="../111270/index.html">Animation in Google Docs</a></li>
<li><a href="../111271/index.html">Lexicon for the market of advanced tactile technology</a></li>
<li><a href="../111272/index.html">Programming on the machine Post</a></li>
<li><a href="../111274/index.html">Cloud computing, a quick tour or article for a boss</a></li>
<li><a href="../111275/index.html">Assembler for Windows using Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>