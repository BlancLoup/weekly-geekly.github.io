<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>One for all: how to break the vicious circle of difficulties in developing a boxed product</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We make software for video surveillance systems with video analysis functions, and this is a boxed product. And the boxed product in the same form is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>One for all: how to break the vicious circle of difficulties in developing a boxed product</h1><div class="post__text post__text-html js-mediator-article">  We make software for video surveillance systems with video analysis functions, and this is a boxed product.  And the boxed product in the same form is provided at once to many users and is used by all of them the way it is. <br><br>  Does it matter if we make a universal product for many or are we developing it individually for a specific user?  When it comes to video analysis, it is simply of fundamental importance. <a name="habracut"></a><br><br><h2>  Let's understand </h2><br>  Take two companies: N and M. Let company N develop an ‚Äúindividual‚Äù software product, and M - a boxed one.  Company N develops a product on order, for use in one particular place.  And makes everything work in the conditions for which the product is developed.  And company M, which makes a boxed product, must design it so that it provides target parameters (for accuracy, for example) for the most different users in the most different conditions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For a boxed video analysis software, two factors are true: <br><br>  1. A variety of conditions of applicability; <br>  2. The inability of the new user to adjust and adjust the algorithm every time. <br><br>  Accordingly, during its development it is necessary to satisfy two conditions: <br><br>  1. The algorithm should work in automatic mode.  That is, without the participation of a person who can "tweak" something and adjust it in a particular place. <br>  2. Conditions can be very different.  And with all parameters, the product must provide target values, for example, in accuracy. <br><br>  And with regard to shooting conditions and video analysis, the range of possible parameters is very wide: these are sharpness, contrast, color saturation, optical noise level, structure level and spatial-temporal distribution of noise movement, camera angle, color rendering parameters, background (scene) complexity, etc. d. <br><br><h2>  What is written in smart books? </h2><br>  If you take a scientific article, then you can see, for example, such illustrations for detecting a moving object: <br><br><img src="https://habrastorage.org/webt/if/yh/5l/ifyh5l2t5wgsdxugwi2mnak6hvo.jpeg"><br><br>  Take a look!  This is just something sterile: here are two pictures - this is a moving object.  And, of course, in such a situation, we will detect everything perfectly. <br>  But these are unreal, ideal conditions. <br><br>  If all in the same scientific papers take more realistic illustrations, this is what they are: <br><br><img src="https://habrastorage.org/webt/sa/kr/re/sakrreoxsdl88vmktj8q1fitu98.jpeg"><br><br>  This is a frame from this camera.  But conditions are still very good. <br><br><h2>  And how really? </h2><br>  But what we face in fact?  We are faced with the fact that our algorithms should work in these conditions: <br><br><img src="https://habrastorage.org/webt/kb/sp/y3/kbspy3jhj-c5s2bw-swgizl-vfu.jpeg"><br><br>  and in such <br><br><img src="https://habrastorage.org/webt/jr/vg/tq/jrvgtq6aypyctm5oclurhuhiecs.jpeg"><br><br>  and even in such <br><br><img src="https://habrastorage.org/webt/oq/zw/4j/oqzw4jxdlr3hcjacau8-24gzr6g.jpeg"><br><br>  This is the reality of the use of video analysis algorithms in the boxed product: the conditions are completely different.  In addition, they may change over time.  Nevertheless, each algorithm should work well in all such conditions and provide target indicators for accuracy. <br><br>  And therefore, when developing a boxed product, a special non-trivial approach should be sought. <br><br><h2>  And that is not all </h2><br>  There is another very difficult task in our development specifics. <br>  When an algorithm is developed, a sample of frames or video is created for it: videos are being prepared on which work is being tracked.  Developers are trying to prepare very different videos, with very different shooting conditions and parameters.  But in fact it turns out that these videos somehow fall into some rather narrow area of ‚Äã‚Äãinput conditions. <br><br><img src="https://habrastorage.org/webt/kx/6-/b6/kx6-b6ozkquhxegibfhwazhagiy.jpeg"><br><br>  And when an algorithm that works fine on the sample will be applied under completely different conditions, it may work very poorly or not at all.  Because all the development was carried out, adjusting to these narrow input conditions. <br>  And this is a global problem. <br><br>  But an even bigger problem is that in fact this ‚Äúcondition space‚Äù is not two-dimensional as on the graph above.  It is multidimensional.  And all parameters can vary within wide limits.  And in view of the fact that we are considering a boxed product, its algorithms must work correctly and accurately within all bounds. <br><br><img src="https://habrastorage.org/webt/1g/7d/ir/1g7dir4ipuevhqyoc9ciarrwgze.jpeg"><br><br>  So, we get a huge multidimensional space of conditions and parameters.  And our task in the development of the algorithm is to place the input points more or less evenly in this space and not to miss any area. <br><br><h2>  How to do it? </h2><br>  There is no universal method.  The only thing that can be recommended here is to go and take in a selection of real videos of real cameras from real objects.  And try to make them cover the entire parameter space as much as possible. <br>  In this case, the algorithm will still somehow adjust to the specific conditions of these input sample rollers. <br><br>  The way to avoid such an adjustment is to test and measure accuracy on a different set of videos: develop on some, test on others.  Then the chances are increased, because if, during testing, the algorithms do not work on what they were developed on, then there is no adjustment. <br><br>  But this is not all :) It often happens that you develop on some, test on others and find out that it does not work for you or does not work well enough.  You start to understand why it does not work, you understand why, you change something and ensure good work on the test videos.  But in this case, there is already a new adjustment ... for them. <br><br><h2>  How to break out of this endless series of adjustments? </h2><br>  1 way - all the time to test on new videos. <br><br>  It is very effective, but very time consuming.  Believe me, it is very difficult to collect videos for input samples and tests from real objects (also because we are talking about video security systems).  And in view of the fact that sometimes the testing of the algorithm can take place several times a day, you need to stock up on some unreal amount of video. <br>  This approach increases the chances of success, reduces the risk of adjustment, but is very resource-intensive. <br><br>  2 way - to do so that developers do not see why it does not work during tests <br><br>  Let the developers write the algorithm, and there will be some kind of external person who will test it on new videos, which will simply tell them whether accuracy is achieved or not, something needs to be improved or not.  The developers of these videos should not see, in order to exclude corrections fixes. <br><br>  But in this case, developers should refine the algorithm, not understanding why something is not working for them ... <br><br>  Neither path is realistic.  It is necessary every time to look for some kind of compromise.  And the one who manages the development must properly maintain this balance: how, on the one hand, not to complicate your life so much so that under each testing you can recruit a new set of test clips, on the other hand - to minimize the risks of adjustment.  Or how not to show the developers on which the testing takes place, but at the same time letting them know what works wrong for what and why. <br><br>  And this is the reality in which we develop. <br><br><h2>  But that's not all. </h2><br>  In development, there is a concept of degradation: when a developer improves something in an algorithm, at the same time something worsens in it.  This is a normal, real phenomenon.  Therefore, any change in the algorithm must pass the test for introducing degradation into other parameters. <br><br>  It requires an insane amount of effort.  You can do it manually and spend a lot of time and effort, and you can automate the process.  But this again triggers the adjustment problem: when you automate, you adjust everything to a finite set of videos.  ‚ÄúAutomatically‚Äù is when everything is marked up: it is said that such conditions and parameters are on this video, and such are on this one. <br>  And again, you need to find a balance when testing degradation ... <br><br><h2>  To drive into the framework not yourself, but the user? </h2><br>  All this looks like some kind of vicious circle: achieve high accuracy for any conditions, but waste on this unreal amount of time and effort, or deny the universality of the product, but develop it faster and easier. <br><br>  It seems that there is one simple way out of this situation (looking ahead, let's say that it is not easy, and it is not a way out :)). <br><br>  When there is a wide range of parameters, it is possible to clearly formulate the user the conditions under which this algorithm should work.  Any program, module or algorithm for video analysis has recommended working conditions under which they provide the stated accuracy. <br><br>  However, with this approach, you need to understand this: <br><br>  1. You can tell users that they must provide certain parameters, but often in reality it is simply impossible to comply with all the parameters.  And when it comes to the boxed product, it should work in real conditions ... <br><br>  2. But the main snag is that even if users are ready to comply with all recommended conditions, they are often difficult to formalize. <br><br>  For example, the contrast can be described (although the contrast for the whole image may be one, and in the specific area where you are analyzing it is different).  But how to formalize, for example, the complexity of the background?  How do you tell the user what conditions they must comply with in relation to such badly digitized things? <br><br><h2>  "The devil is not so bad ..." </h2><br>  No matter how difficult and hopeless these situations may seem, this is a reality in which both we and other companies work, develop, and do so quite successfully.  It is necessary to understand and accept that the development of a boxed product for video analysis, which should work in real conditions, is plus several orders of magnitude to complexity. <br><br>  Regardless of the way in which complex and contradictory tasks will be solved, it is necessary to develop and test in close conjunction with the user and the actual conditions in which he applies the product. </div><p>Source: <a href="https://habr.com/ru/post/342592/">https://habr.com/ru/post/342592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342578/index.html">Jest and Puppeteer: automation of testing web interfaces</a></li>
<li><a href="../342580/index.html">ShellCheck Static Analyzer and Script Improvement for Linux and Unix</a></li>
<li><a href="../342582/index.html">Top Ten Antivirus for Linux</a></li>
<li><a href="../342588/index.html">Microservices: deploy, coordination and data consistency</a></li>
<li><a href="../342590/index.html">7 habits of successful Site Reliability Engineers (according to the version of New Relic)</a></li>
<li><a href="../342596/index.html">Are developers needed in the future?</a></li>
<li><a href="../342598/index.html">Private cloud: "blue electrical tape" for the harsh enterprise</a></li>
<li><a href="../342600/index.html">How to get more than 3500 stars on GitHub in a week and why?</a></li>
<li><a href="../342602/index.html">Base stations: how it all began</a></li>
<li><a href="../342604/index.html">Pygest # 18. Releases, articles, interesting projects, packages and libraries from the world of Python [November 5, 2017 - November 15, 2017]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>