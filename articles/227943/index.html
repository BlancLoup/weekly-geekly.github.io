<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cluster service on Erlang: from idea to deb-package</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Task 
 You need to write a real service on the Erlang, which will work in a cluster. In addition, you need to maximally simplify the lives of those wh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cluster service on Erlang: from idea to deb-package</h1><div class="post__text post__text-html js-mediator-article"><h4>  Task </h4><br>  You need to write a real service on the Erlang, which will work in a cluster.  In addition, you need to maximally simplify the lives of those who will service the service. <br>  Requirements: <br><ul><li>  The service will have a RESTful interface (it is fashionable and modern) </li><li>  The main settings of the service should be made into a small file with clear syntax. </li><li>  the service should write an optional access-log </li><li>  the service should start upstart </li></ul><br>  For the sake of simplicity, the service will be a counter, which is given to each client by an integer increasing with each request (unique until the counter is restarted). <br><br><h4>  Technology </h4><br>  Choose all the most fashionable and modern: <br><ul><li>  HTTP server - <a href="">cowboy 0.10.0</a> </li><li>  logger - <a href="https://github.com/basho/lager">lager</a> </li><li>  build system - <a href="">erlang.mk</a> </li><li>  release <a href="https://github.com/erlware/relx">builder</a> - <a href="https://github.com/erlware/relx">relx</a> </li></ul><br><a name="habracut"></a><br><br><h4>  Architecture </h4><br>  The cowboy will hang on some port, the request will be processed by our handler, who will make a call to the counter, then respond to the client and write an entry to the log. <br>  The counter will be registered in global so that it can be easily accessed from any node in the cluster. <br>  When starting, the counter tries to register if it does not exit (the counter is already registered on another node) - waiting for the opportunity to do it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Application skeleton </h4><br>  We need to make an OTP application according to all canons, but with a minimum of effort. <br>  Create an erdico directory for the project, do git init in it, download the erlang.mk file from the repository of the project of the same name and create a simple Makefile: <br><pre><code class="bash hljs">PROJECT = erdico ERLC_OPTS= <span class="hljs-string"><span class="hljs-string">"+{parse_transform, lager_transform}"</span></span> DEPS = cowboy lager dep_cowboy = pkg://cowboy 0.10.0 dep_lager = https://github.com/basho/lager.git 2.0.3 include erlang.mk</code> </pre> <br>  <i>Mac OS / BSD users</i> : It will take wget.  In Linux, he seems to be everywhere now out of the box. <br>  Note that the cowboy is included as a known package.  The erlang.mk repository, although small, is small. <br><br>  In the src / erdico.app.src file we describe our application (all parameters are required, otherwise erlang.mk or relx will break): <br><pre> <code class="erlang hljs">{application, erdico, [ {description, <span class="hljs-string"><span class="hljs-string">"Hello, Upstart distributed Erlang service"</span></span>}, {id, <span class="hljs-string"><span class="hljs-string">"ErDiCo"</span></span>}, {vsn, <span class="hljs-string"><span class="hljs-string">"0.1"</span></span>}, {applications, [kernel, stdlib, lager, cowboy]}, <span class="hljs-comment"><span class="hljs-comment">% run-time dependencies {modules, []}, % here erlang.mk inserts all application modules, not added automatically, required by relx {mod, {erdico, []}}, % application callback module {registered, [erdico]} % required by relx ]}.</span></span></code> </pre><br><br>  The src / erdico.erl file is created, but so far, apart from the -module (erdico) directive.  write nothing there. <br>  In <a href="https://github.com/stolen/erdico/tree/b67b57337ba00e0546c6487a0ef9c96473b79c42">this</a> state, make should deflate the dependencies and collect everything it finds. <br><br><h4>  Application launch, cowboy and simplest request handler ( <a href="">launcher</a> , <a href="">handler</a> ) </h4><br>  For simplicity, I have assembled the entire control code in one erdico module.  Fanatics can make 4 modules here, and all the rest will take out those pieces, the logic of which suddenly becomes noticeably non-trivial and therefore worthy of a separate module. <br><br><h5>  HTTP server </h5><br>  It contains roughly the minimum configuration.  What else happens there, you can read in the <a href="http://ninenines.eu/docs/en/cowboy/HEAD/guide/routing/">documentation</a> <br><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_cowboy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> -&gt;</span></span> DefPath = {'_', erdico_handler, []}, <span class="hljs-comment"><span class="hljs-comment">% Catch-all path Host = {'_', [DefPath]}, % No virtualhosts Dispatch = cowboy_router:compile([Host]), Env = [{env, [{dispatch, Dispatch}]}], cowboy:start_http(?MODULE, 10, [{port, 2080}], Env).</span></span></code> </pre><br><br><h5>  Request handler </h5><br>  Here, while everything is primitive: <br><pre> <code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(erdico_handler)</span></span>. -behavior(cowboy_http_handler). -export([init/<span class="hljs-number"><span class="hljs-number">3</span></span>, handle/<span class="hljs-number"><span class="hljs-number">2</span></span>, terminate/<span class="hljs-number"><span class="hljs-number">3</span></span>]). init(_Type, Req, _Options) -&gt; {ok, Req, nostate}. handle(Req, nostate) -&gt; {ok, Replied} = cowboy_req:reply(<span class="hljs-number"><span class="hljs-number">200</span></span>, [], &lt;&lt;<span class="hljs-string"><span class="hljs-string">"hello\n"</span></span>&gt;&gt;, Req), {ok, Replied, nostate}. terminate(_Reason, _Req, nostate) -&gt; ok.</code> </pre><br><br><h5>  We collect, we start, we check </h5><br>  To build, just make. <br>  To start, you need to specify the directory with dependencies and the directory with the binaries of our application. <br><pre>  stolen @ node1: ~ / erdico $ ERL_LIBS = deps erl -pa ebin -s erdico </pre><br><div class="spoiler">  <b class="spoiler_title">Erlang console</b> <div class="spoiler_text"><pre> Erlang / OTP 17 [erts-6.1] [source-d2a4c20] [64-bit] [async-threads: 10] [hipe] [kernel-poll: false]<font></font>
<font></font>
 Eshell V6.1 (abort with ^ G)
 1&gt; 15: 01: 14.486 [info] Application lager started on node nonode @ nohost
 15: 01: 14.493 [info] Application ranch started on node nonode @ nohost
 15: 01: 14.506 [info] Application crypto started on node nonode @ nohost
 15: 01: 14.506 [info] Application cowlib started on node nonode @ nohost
 15: 01: 14.513 [info] Application cowboy started on node nonode @ nohost
 15: 01: 14.530 [info] Application erdico started on node nonode @ nohost<font></font>
<font></font>
 1&gt; 
</pre></div></div><br>  It can be seen that even lager began to work somehow (apart from the console, he also wrote to the disk). <br><br><pre> stolen @ node2: ~ $ curl node1: 2080
 hello
</pre><br><br><h4>  Counter </h4><br>  Well, the application starts and runs.  It is time to add meaning to its existence. <br>  I will not go into the details of the implementation, just read the <a href="https://github.com/stolen/erdico/commit/0f14927644194222993f0da72004bdbfc212637c">patch</a> . <br><br><h5>  Demonstration </h5><br>  So far, we will run both Erlang nodes on the same host node1 - e1 @ node1 and e2 @ node1.  To do this, the port on which the server hangs is configured from the command line. <br>  On the first node, we wind the counter up to 20, on the second one - up to 1. We collect the cluster and see that the counter on the second node is killed, after which the first counter calls the counter from the second node. <br><div class="spoiler">  <b class="spoiler_title">e1 @ node1</b> <div class="spoiler_text"><pre> stolen @ node1: ~ / erdico $ ERL_LIBS = deps erl -pa ebin -s erdico -setcookie erdico -sname e1 -erdico port 2081
 Erlang / OTP 17 [erts-6.1] [source-d2a4c20] [64-bit] [async-threads: 10] [hipe] [kernel-poll: false]
 ...............
 (e1 @ node1) 2&gt; erdico_counter: inc (10).
 {ok, 20}
 (e1 @ node1) 3&gt; 16: 11: 30.422 [info] global: Name conflict terminating {erdico_counter, &lt;10869.102.0&gt;}
 (e1 @ node1) 3&gt; erdico_counter: inc ().  
 {ok, 22}
</pre></div></div><div class="spoiler">  <b class="spoiler_title">e2 @ node1</b> <div class="spoiler_text"><pre> stolen @ node1: ~ / erdico $ ERL_LIBS = deps erl -pa ebin -s erdico -setcookie erdico -sname e2 -erdico port 2082
 Erlang / OTP 17 [erts-6.1] [source-d2a4c20] [64-bit] [async-threads: 10] [hipe] [kernel-poll: false]
 ..............
 (e2 @ node1) 1&gt; erdico_counter: inc ().
 {ok, 1}
 (e2 @ node1) 2&gt; net_adm: ping (e1 @ node1).
 pong
 (e2 @ node1) 3&gt; 16: 11: 30.423 [error] Supervisor erdico child counter started with erdico_counter: start_link () at &lt;0.102.0&gt;
 (e2 @ node1) 3&gt; erdico_counter: inc ().  
 {ok, 21}
</pre></div></div><br><br><h4>  Cowboy and counter </h4><br>  Well, it's <a href="https://github.com/stolen/erdico/commit/33b6a08aae08a3c2d097d094c95b5d467832eea1">simple</a> . <br><div class="spoiler">  <b class="spoiler_title">Works!</b> <div class="spoiler_text"><pre> stolen @ node2: ~ $ curl node1: 2081
 value = 1
 stolen @ node2: ~ $ curl node1: 2082
 value = 2
 stolen @ node2: ~ $ curl node1: 2081
 value = 3
 stolen @ node2: ~ $ curl node1: 2082
 value = 4
 stolen @ node2: ~ $ curl node1: 2082
 value = 5
 stolen @ node2: ~ $ curl node1: 2081
 value = 6
</pre></div></div><br><br>  <b>The simple part of the post came to an end</b> . <br><h4>  access.log </h4><br>  <a href="https://github.com/basho/lager">Lager</a> is about the only living framework for writing logs in Erlang.  Unfortunately, he lacks concise documentation with examples from life.  I hope this post will become such an example for at least RuNet. <br>  In addition, the Internet is not very generous with access.log entry examples for a <a href="https://github.com/extend/cowboy">cowboy</a> .  This, I hope, is also corrected by this post. <br><br><h5>  lager tracing </h5><br>  In the lager configuration, events are distributed to files according to their severity.  This does not suit us, because to write HTTP server logs, we need to explicitly send an event to a specific log.  To do this, there is a special lager in the lager called tracing, which we will use. <br>  At this stage, we already need a config file. <br>  Here we will redirect the crash log, create a log with more or less significant events, and also declare access.log, which will be written only through tracing when {tag, access} is in the event metadata.  The format is more or less clear - the lines are inserted as strings, and the atoms are replaced with the values ‚Äã‚Äãfrom the metadata for the corresponding keys (hereinafter, I will tell you how to use it). <br>  For all the configured logs, rotation is turned on at midnight with saving of 5 old files.  Rotation by log size is disabled. <br><div class="spoiler">  <b class="spoiler_title">erdico.config</b> <div class="spoiler_text">  <a href="https://github.com/stolen/erdico/blob/e71870c6bf045364cf3250772271f49a13352b5e/erdico.config">Whole file</a> <br><pre> <code class="erlang hljs">[ {lager, [ {crash_log, <span class="hljs-string"><span class="hljs-string">"logs/crash.log"</span></span>}, {crash_log_size, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {crash_log_date, <span class="hljs-string"><span class="hljs-string">"$D0"</span></span>}, {crash_log_count, <span class="hljs-number"><span class="hljs-number">5</span></span>}, {error_logger_hwm, <span class="hljs-number"><span class="hljs-number">20</span></span>}, {async_threshold, <span class="hljs-number"><span class="hljs-number">30</span></span>}, {async_threshold_window, <span class="hljs-number"><span class="hljs-number">10</span></span>}, {handlers, [ {lager_file_backend, [{file, <span class="hljs-string"><span class="hljs-string">"logs/events.log"</span></span>}, {level, notice}, {size, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {date, <span class="hljs-string"><span class="hljs-string">"$D0"</span></span>}, {count, <span class="hljs-number"><span class="hljs-number">5</span></span>}, {formatter, lager_default_formatter}, {formatter_config, [date, <span class="hljs-string"><span class="hljs-string">" "</span></span>, time,<span class="hljs-string"><span class="hljs-string">" ["</span></span>,severity,<span class="hljs-string"><span class="hljs-string">"] "</span></span>,pid, <span class="hljs-string"><span class="hljs-string">" "</span></span>, message, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>]}]}, {lager_file_backend, [{file, <span class="hljs-string"><span class="hljs-string">"logs/access.log"</span></span>}, {level, none}, {size, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {date, <span class="hljs-string"><span class="hljs-string">"$D0"</span></span>}, {count, <span class="hljs-number"><span class="hljs-number">5</span></span>}, {formatter, lager_default_formatter}, {formatter_config, [date, <span class="hljs-string"><span class="hljs-string">" "</span></span>, time,<span class="hljs-string"><span class="hljs-string">" ["</span></span>,severity,<span class="hljs-string"><span class="hljs-string">"] "</span></span>,pid, <span class="hljs-string"><span class="hljs-string">" "</span></span>, peer, <span class="hljs-string"><span class="hljs-string">" \""</span></span>, method, <span class="hljs-string"><span class="hljs-string">" "</span></span>, url, <span class="hljs-string"><span class="hljs-string">"\" "</span></span>, status, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>]}]} ]}, {traces, [ {{lager_file_backend, <span class="hljs-string"><span class="hljs-string">"logs/access.log"</span></span>}, [{tag, access}], info} ]} ]} ].</code> </pre></div></div><div class="spoiler">  <b class="spoiler_title">Run, check</b> <div class="spoiler_text"><pre> stolen @ node1: ~ / erdico $ ERL_LIBS = deps erl -pa ebin -config erdico.config -s erdico -setcookie erdico -sname e1 -erdico port 2081
 Erlang / OTP 17 [erts-6.1] [source-d2a4c20] [64-bit] [async-threads: 10] [hipe] [kernel-poll: false]<font></font>
<font></font>
 Eshell V6.1 (abort with ^ G)
 (e1 @ node1) 1&gt; lager: log (notice, [{pid, self ()}], "hello ~ s ~ w", [world, 2.7]).
 ok
 (e1 @ node1) 3&gt; lager: log (info, [{pid, self ()}, {tag, access}, {peer, "fake"}, {status, 418}], "", []).
 ok
</pre><br>  Result: <br><pre> stolen @ node1: ~ / erdico $ cat logs / events.log 
 2014-06-28 17: 22: 43.994 [notice] &lt;0.39.0&gt; hello world 2.7
 stolen @ node1: ~ / erdico $ cat logs / access.log 
 2014-06-28 17: 25: 57.286 [info] &lt;0.39.0&gt; fake "Undefined Undefined" 418
</pre></div></div><br><br><h5>  cowboy onresponse hook </h5><br>  I'd like to dump the maximum work on the already ready code.  Therefore, instead of inserting logging into every place that causes cowboy_req: reply / 4, we will insert logging into the cowboy itself.  For this, as it turned out, there is even a special place in the form of a hook in response.  <a href="">Documentation</a> is your friend. <br>  The solution "on the forehead" looks like <a href="https://github.com/stolen/erdico/commit/f82c5f3f486b6b9c49e84ccb7d102305c113784d">this</a> and writes <br><div class="spoiler">  <b class="spoiler_title">good logs</b> <div class="spoiler_text"><pre> stolen @ node1: ~ / erdico $ cat logs / access.log 
 2014-06-28 17: 54: 44.429 [info] &lt;0.103.0&gt; 10.0.2.4 "GET http: // node1: 2081 /" 200
 2014-06-28 17: 54: 46.085 [info] &lt;0.104.0&gt; 10.0.2.4 "GET http: // node1: 2081 /" 200
</pre></div></div><br><br><h5>  non-blocking hook </h5><br>  Those who read the onresponse-hook documentation have already guessed that in the solution described above, the answer will be sent strictly after writing to the log. <br>  This means that the podzalipshy logger (the disk, for example, is slow) will increase the response time. <br>  And it also means that if we decide to write the request processing time to the log, then it will not include the time spent on logging, and may differ greatly from the point of view of the client. <br>  Therefore, we once again look at the documentation and redo the hook so that the logging is done strictly after sending the answer to the client. <br><div class="spoiler">  <b class="spoiler_title">More correct hook</b> <div class="spoiler_text"><pre> <code class="erlang hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">access_log_hook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Status, Headers, Body, Req)</span></span></span><span class="hljs-function"> -&gt;</span></span> {[{PeerAddr, _}, Method, Url], Req2} = lists:mapfoldl(fun get_req_prop/2, Req, [peer, method, url]), {ok, ReqReplied} = cowboy_req:reply(Status, Headers, Body, Req2), PeerStr = inet_parse:ntoa(PeerAddr), lager:info([{tag, access}, {peer, PeerStr}, {method, Method}, {url, Url}, {status, Status}], <span class="hljs-string"><span class="hljs-string">""</span></span>), ReqReplied. get_req_prop(Prop, Req) -&gt; cowboy_req:Prop(Req).</code> </pre></div></div><br><br><h5>  switchable log </h5><br>  For cases when you want to measure RPS, you need to be able not to write a line in the log for each request. <br>  Let there be no hook if the configuration explicitly states that the log is not needed. <br>  After <a href="https://github.com/stolen/erdico/commit/c3e134cbe3a41734ff937494a7882b90dd218286">this</a> patch, adding the ‚Äú-erdico log_access false‚Äù parameter to the launch string disables the log. <br><br><h4>  Releases and relx </h4><br>  Releases - probably one of the biggest pains in the development on Erlang.  <a href="https://github.com/erlware/relx">relx</a> is made to save the user from this pain.  (Spoiler: not really) <br><br><h5>  Just build release </h5><br>  After filling this file, the make call will compile the release in the _rel directory: <br><div class="spoiler">  <b class="spoiler_title">relx.config</b> <div class="spoiler_text"><pre> <code class="erlang hljs">{release, {erdico, <span class="hljs-string"><span class="hljs-string">"0.1"</span></span>}, [erdico]}. {extended_start_script, true}.</code> </pre></div></div><br>  I didn‚Äôt take off without an extended start script, but we still need it later. <br><div class="spoiler">  <b class="spoiler_title">Launch release</b> <div class="spoiler_text"><pre> stolen @ node1: ~ / erdico $ _rel / erdico / bin / erdico console
 Exec: /home/stolen/erdico/_rel/erdico/erts-6.1/bin/erlexec -boot /home/stolen/erdico/_rel/erdico/releases/0.1/erdico -env ERL_LIBS / home / stolen / erdico / _rel / erdico / releases / 0.1 / lib -config /home/stolen/erdico/_rel/erdico/releases/0.1/sys.config -args_file /home/stolen/erdico/_rel/erdico/releases/0.1/vm.args - console
 Root: / home / stolen / erdico / _rel / erdico
 / home / stolen / erdico / _rel / erdico
 Erlang / OTP 17 [erts-6.1] [source-d2a4c20] [64-bit] [async-threads: 10] [hipe] [kernel-poll: false]<font></font>
<font></font>
 18: 39: 18.318 [info] Application lager started on node 'erdico@127.0.0.1'
 18: 39: 18.321 [info] Application cowboy started on node 'erdico@127.0.0.1'
 18: 39: 18.343 [info] Application erdico started on node 'erdico@127.0.0.1'
 Eshell V6.1 (abort with ^ G)
 (erdico@127.0.0.1) 1&gt; 
</pre></div></div><br>  As you can easily see, the lager settings were not included in the release.  And also this thing inscribed a node name that is not very suitable for working in a cluster.  These and other problems we will solve further. <br><br><h5>  Inclusion in the release of suitable settings </h5><br>  So, we want the release to start with the correct name of the node, and also to launch the node to connect to the sisters in the cluster.  And so that these and other settings can be set in a file with a clear syntax that does not fall apart from the missing comma. <br>  To begin, all <a href="https://github.com/stolen/erdico/commit/7854aa8a071fe81df5fba96fa418570c53118220">zakardkodim</a> . <br>  Pay attention to the sync_nodes_optional and sync_nodes_timeout kernel options - together they make the node connect to the specified sisters at startup and wait for a response from them for 1 second.  During this second, the global: sync () call in the counter is blocked, eliminating unnecessary deaths at the start. <br>  In vm.args, obviously, you can write other options.  But if you do not specify -name or -sname, the release does not start. <br>  Now the release can be copied entirely to the second node, and after launching the cluster will magically assemble - the check with curl is passed.  It is important that the erlang on the second node is not installed, that is, the release is self-sufficient. <br><br><h5>  Disclosure of variables release script </h5><br>  One of the great features relx gives us is variable disclosure.  How this happens, you can see by finding the string RELX_REPLACE_OS_VARS in the launch script _rel / erdico / bin / erdico.  Everything is so simple that it is not even flexible. <br><div class="spoiler">  <b class="spoiler_title">Parameterized config</b> <div class="spoiler_text">  Parameterize the list of sisters: <br><pre> <code class="erlang hljs">{sync_nodes_optional, [${CLUSTERNODES}]}</code> </pre><br>  Run like this: <pre>  RELX_REPLACE_OS_VARS = 1 CLUSTERNODES = erdico @ node2 _rel / erdico / bin / erdico console </pre><br></div></div><br>  One problem: without disclosing variables, the release does not start now. <br><br><h5>  Hack: Non disclosure of variables by the release script </h5><br>  To release was launched with the disclosure, and without disclosure, I came up with such a hack.  Since the disclosure will still go to the upstart script, in which the human config will be read at the same time, we will hide all the variables in the comment and add the variable that completes the comment.  <a href="https://github.com/stolen/erdico/commit/503d7b3babdd40e2c5d7f673c179362954c2bf6c">a patch</a> that allows you to run the release as it is or with the indication of neighboring nodes - <pre>  RELX_REPLACE_OS_VARS = 1 CLUSTERNODES = "erdico @ node2, erdico @ node1" NL = $ '\ n' _rel / erdico / bin / erdico console </pre><br><br><h5>  Combo Hack: Name Overlap </h5><br>  Let's make it so that the release can be started with dirty hands, without conflicting with the production.  For this we need the parameter name to be parameterized too.  At the same time through the parameterization we will enter the full name there (with FQDN). <br>  On the one hand, you cannot leave vm.args without a node name.  On the other - the previous hack allows you to add a line to the config, but does not allow to remove.  On the third - if you give the erlang several names, but his choice is not very predictable. <br>  It turned out that in vm.args everything that is written after the -extra directive goes into a separate section of the parameters and is not read by the kernel.  We will <a href="https://github.com/stolen/erdico/commit/a400cf5883611063bdc8e661df3ffa9b0ee3e7f7">take advantage of this</a> . <br>  Parameterized startup now happens like this: <pre>  RELX_REPLACE_OS_VARS = 1 CLUSTERNODES = "'erdico@node2.example.net', 'erdico@node1.example.net'" FQDN = `hostname -f` NL = $ '\ n' _rel / erdico / bin / erdico console </pre><br><br><h4>  Build a deb package </h4><br>  Debian gives the developer a lot of pain.  The pain begins with a heap of files in the debian directory, continues with the inability to specify either the root of the project, the alternative location of the debian directory, or the path for folding the assembled packages. <br>  It is known that the collected packages are sent to the directory level above the directory with the source code of the project.  From this it follows that all this filth must be buried deep. <br>  Even in the upstart config, the options for scripting are very poor, so I had to wrap the start script in another conf_erdico.sh script, which prepares a valid environment. <br>  It turned out that lager cannot write logs located under the symlink (due to the filelib features: ensure_dir / 1).  Therefore it was necessary to stick hacks in the config to replace the paths to the logs. <br>  In fact, since the external script was written anyway, it was possible to do all the replacements in the configs using sed.  Let it remain as it is, there will be a proof-of-concept. <br><div class="spoiler">  <b class="spoiler_title">Used in packaging tricks</b> <div class="spoiler_text">  ( <a href="https://github.com/stolen/erdico/commit/cbd72ad8a636bf71ad2ccf385ebe1809f6cf5aff">whole commit</a> ) <br><ul><li>  the directory for the pkg / erdico assembly is made, which is put on the debian directory with all the giblets and additional files </li><li>  Top-level Makefile acquired a deb target that refers to a Makefile in the package directory </li><li>  A makefile in the package directory for the all target (build) calls top at make to build the current release. </li><li>  To make upstart satisfied, the startup script is given a foreground parameter.  When using traditional init, you can use parameters start, stop, ping </li><li>  Since the startup script when editing configs puts the generated files strictly next to the originals, I had to make symlinks from / var / lib / erdico / </li><li>  when hacks were stuck on the disclosure of variables in the lager configuration, the proplists work features were used </li><li>  using the shell, the host list (FQDN) in /etc/erdico.conf is expanded to a list of nodes (with single quotes so that there are atoms) </li></ul><br></div></div><br><br><h4>  We collect, install, customize, run! </h4><br><div class="spoiler">  <b class="spoiler_title">The first (assembly) machine</b> <div class="spoiler_text"><pre> stolen @ node1: ~ / erdico $ make deb
 stolen @ node1: ~ / erdico $ sudo dpkg -i pkg / erdico_0.1_amd64.deb
 stolen @ node1: ~ / erdico $ scp pkg / erdico_0.1_amd64.deb node2:
 stolen @ node1: ~ / erdico $ sudo vim /etc/erdico.conf # CLUSTERHOSTS = "node1.example.net node2.example.net"
 stolen @ node1: ~ / erdico $ sudo service erdico start
</pre></div></div><div class="spoiler">  <b class="spoiler_title">Second car</b> <div class="spoiler_text"><pre> stolen @ node2: ~ $ sudo dpkg -i erdico_0.1_amd64.deb
 stolen @ node2: ~ $ sudo vim /etc/erdico.conf # CLUSTERHOSTS = "node1.example.net node2.example.net"
 stolen @ node2: ~ $ sudo service erdico start
</pre></div></div><br><br><h4>  Works! </h4><br><div class="spoiler">  <b class="spoiler_title">After rebooting both machines</b> <div class="spoiler_text"><pre> stolen @ node1: ~ $ curl node1: 2080
 value = 1
 stolen @ node1: ~ $ curl node2: 2080
 value = 2
 stolen @ node1: ~ $ curl node1: 2080
 value = 3
 stolen @ node1: ~ $ curl node2: 2080
 value = 4
 stolen @ node1: ~ $ tail -5 /var/log/erdico/access.log
 2014-06-29 00: 43: 03.044 [info] &lt;0.380.0&gt; 10.0.2.4 "GET http: // node1: 2080 /" 200
 2014-06-29 00: 54: 34.563 [info] &lt;0.424.0&gt; 10.0.2.4 "GET http: // node1: 2080 /" 200
 2014-06-29 00: 54: 36.932 [info] &lt;0.425.0&gt; 10.0.2.4 "GET http: // node1: 2080 /" 200
 2014-06-29 00: 56: 10.709 [info] &lt;0.383.0&gt; 10.0.2.15 "GET http: // node1: 2080 /" 200
 2014-06-29 00: 56: 14.490 [info] &lt;0.384.0&gt; 10.0.2.15 "GET http: // node1: 2080 /" 200
</pre></div></div><br><br><h4>  Promised REST </h4><br>  <a href="https://github.com/stolen/erdico/commit/a1103c48fdacd7a443f43107b718072b226fb13c">Here</a> , put. <br><div class="spoiler">  <b class="spoiler_title">Demo</b> <div class="spoiler_text"><pre> stolen @ node1: ~ $ curl node1: 2080
 value = 1
 stolen @ node1: ~ $ curl node2: 2080
 value = 2
 stolen @ node1: ~ $ curl node1: 2080 / inc / 400
 value = 402
 stolen @ node1: ~ $ curl node2: 2080
 value = 403
 stolen @ node1: ~ $ curl node1: 2080
 value = 404
</pre></div></div><br><br><h4>  Morality </h4><br>  Life is pain. <br>  Lager is good, but it lacks the flexibility of the config (for example, once on a config, specify the root directory and the default file log options). <br>  The cowboy is good, but you need to understand how it works so that the performance does not sag. <br>  Debian is good, but the assembly of packages for it is made by mutants and for mutants. <br>  Upstart is good, but it allows you to do too little in the configuration of the service, you have to put the logic into an additional script. <br>  Erlang is good, until there is a need to give the application on it to support those who do not know it. <br>  Managers of dependencies for erlang are, they work, but they have not solved the problem of dependency hell. <br>  Build releases in Erlang still hurts, though less and less.  Relx waits for commits, without which it is still inconvenient to use.  In addition, he can go crazy if there is a cycle of symlinks or an assembled release somewhere in dependencies. <br><br><h4>  What else can be done in this application </h4><br>  First, you can replicate the counter.  But if you send a notification about each request to all the nodes of the cluster, it will create a bottleneck. <br>  Secondly, you can add a process that will constantly ping the neighbors specified in the settings.  Without this, the Erlang is experiencing bad network gaps. <br>  Thirdly, add a pen with status.  Show on which nodes of the cluster this application is running, and on which of them the master is now. <br>  Fourth, give the host in the header where the master is now located.  A smart client will be able to go there immediately next time, so as not to drive traffic between nodes. <br>  Fifthly, to cut out all the hacks from configs and make all substitutions with the help of sed and his friends. <br>  Sixth, you can put the onresponse hook for a cowboy-lager bundle into a separate project, and learn how to automatically translate the format atoms into the values ‚Äã‚Äãof the request properties.  In addition, you can also organize all sorts of metrics such as processing time and traffic to service the request. <br>  Seventh, examine <a href="https://github.com/ahmednawras/log4erl">log4erl</a> . <br>  Eighth, examine <a href="https://github.com/flussonic/epm">epm</a> .  Make friends with dependency managers as a maximum task. </div><p>Source: <a href="https://habr.com/ru/post/227943/">https://habr.com/ru/post/227943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227931/index.html">Marketing for financial institutions. Part Two: Campaigning</a></li>
<li><a href="../227933/index.html">As I walked on campus: notes of a bystander</a></li>
<li><a href="../227935/index.html">Another Pattern Matching in C # - now with context building</a></li>
<li><a href="../227937/index.html">History of one logo</a></li>
<li><a href="../227939/index.html">Samsung and Google will increase the level of information protection in Android</a></li>
<li><a href="../227945/index.html">Generating CSS Sprites with Gulp</a></li>
<li><a href="../227949/index.html">How are Internet things created ?!</a></li>
<li><a href="../227951/index.html">Happy birthday, Elon Musk!</a></li>
<li><a href="../227953/index.html">Energy transfer by water and single wire transmission</a></li>
<li><a href="../227957/index.html">Parallella board sales from Adapteva resumed.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>