<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>(Archive) Matreshka.js 1.1: even more cool</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Matreshka.js: From simple to simple 
- 10 reasons to try the Russian doll 
- Matreshka.js 1.1: even more cool 
- Matreshka.js: events 
 Documentatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>(Archive) Matreshka.js 1.1: even more cool</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://matreshka.io/"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/7dd/c95/2c17ddc954b9bb6c001888f64f42d865.png" alt="image"></a> <br><ul><li>  <a href="http://habrahabr.ru/company/matreshka/blog/254889/">Matreshka.js: From simple to simple</a> </li><li>  <a href="http://habrahabr.ru/company/matreshka/blog/254927/">10 reasons to try the Russian doll</a> </li><li>  <b>Matreshka.js 1.1: even more cool</b> </li><li>  <a href="http://habrahabr.ru/company/matreshka/blog/267513/">Matreshka.js: events</a> </li></ul><br>  <a href="http://ru.matreshka.io/">Documentation in Russian</a> <br>  <a href="https://github.com/finom/matreshka">Github repository</a> <br><br>  Hello.  Today, September 28 marks two years from the first commit to the Matryoshka repository.  Coincidentally, by this time, a new release arrived with all sorts of goodies for any JavaScript developer (even for those who don‚Äôt want to use Matryoshka as a framework). <br><br>  Matryoshka is a JavaScript framework (or, if you like, a library) based on accessors, and squeezing out of them incredible, at first glance, possibilities.  Remember the time when the JavaScript getters and setters just appeared?  How much noise was around them ... Articles, conversations ... Then, everything calmed down: many did not understand how to use these opportunities, except in simple examples.  The nested doll is an excellent answer to the question of why we need accessors in JavaScript. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <habracut><br><br>  By tradition, let me remind you that this framework is able with the help of a small piece of code. <br><br>  Previously, you could only do this: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// this -   //   "x"     this.bindNode('x', 'input.my-node'); //  ,  alert this.on('change:x', function() { alert(this.x); }); //  ,   //     "x"  this.x = 'Wow!';</span></span></code> </pre> <br>  Now you can also: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object = {}; <span class="hljs-comment"><span class="hljs-comment">//   "x"     MK.bindNode(object, 'x', 'input.my-node'); //  ,  alert MK.on(object, 'change:x', function() { alert(object.x); }); //  ,   //     "x"  object.x = 'Wow!';</span></span></code> </pre><br>  Due to the fact that the latest versions of Chrome and NodeJS have finally begun to support most elements of the ES6 syntax, all the examples below in this post will be written on ES6.  In such a simple way, I want to congratulate all those who consider these innovations to be incredibly cool and draw attention to those who are not familiar with them to ES.next. <br><a name="habracut"></a><br><h1>  <font color="#8bc34a">Support for native objects</font> </h1><br>  The most important innovation was the support Matryoshka arbitrary objects.  Yes, in order to declare a binding or to do something else cool, it is not necessary to create a copy of the Matryoshka. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = {}; <span class="hljs-comment"><span class="hljs-comment">//  "x‚Äù   '.my-node' MK.bindNode(object, 'x', '.my-node'); // "y‚Äù      x  z MK.linkProps(object, 'y', 'x z', (x, z) =&gt; x + z); //‚Äùz‚Äù -   ,   ,      MK.mediate(object, 'z', Number); // ...</span></span></code> </pre><br>  As you can see from the example, the new static methods completely repeat the dynamic ones with one small difference: they need to pass the original object as the first argument: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// this.bindNode('x', '.my-node'); // MK.bindNode(object, 'x', '.my-node');</span></span></code> </pre><br>  In addition, collections that are able to render themselves, now do not require specifying a <a href="http://ru.matreshka.io/">model</a> that previously had to be inherited from the <a href="http://ru.matreshka.io/">Matreshka</a> class. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyArray</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MK</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Array</span></span></span><span class="hljs-class"> </span></span>{ itemRenderer() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;li&gt;'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>().bindNode(<span class="hljs-string"><span class="hljs-string">'sandbox'</span></span>, <span class="hljs-string"><span class="hljs-string">'.some-node'</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyArr(); arr.push(someData);</code> </pre><br>  A complete list of new static methods is listed in the <a href="http://ru.matreshka.io/">MatreshkaMagic</a> section. <br><br><h1>  <font color="#8bc34a"><a href="http://ru.matreshka.io/">MatreshkaMagic</a> library</font> </h1><br>  Thanks to the support of native objects, it became possible to put all the "magic" functions into a separate, more compact library that does not include the <a href="http://ru.matreshka.io/">Matreshka</a> , <a href="http://ru.matreshka.io/">Matreshka.Array</a> , <a href="http://ru.matreshka.io/">Matreshka.Object</a> classes and the <a href="http://ru.matreshka.io/">Class</a> function.  The developer has access to the object <code>MatreshkaMagic</code> or a shorter version of <code>magic</code> , which contains all the static methods of the <code>Matreshka</code> class. <br><br>  The library is located in the <a href="https://github.com/finom/matreshka/tree/master/magic">magic /</a> repository folder. <br><br><pre> <code class="javascript hljs">magic.bindNode(object, <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-node'</span></span>); magic.linkProps(object, <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-string"><span class="hljs-string">'x z'</span></span>, (x, z) =&gt; x + z); <span class="hljs-comment"><span class="hljs-comment">//  . .</span></span></code> </pre><br>  More information about the library <a href="http://ru.matreshka.io/">in the documentation</a> . <br><br><h1>  <font color="#8bc34a">"Deep binding"</font> </h1><br>  Another cool feature that appeared due to the support of native objects is the so-called ‚Äúdeep binding‚Äù.  Having an object of arbitrary nesting, you can associate a DOM node with any property somewhere in the depth of this object. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = {<span class="hljs-attr"><span class="hljs-attr">b</span></span>: {<span class="hljs-attr"><span class="hljs-attr">c</span></span>: {<span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">41</span></span>}}} <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'abcd'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-node'</span></span>);</code> </pre><br>  The Matryoshka kernel keeps track of the entire branch of objects and reinstalls the binding if one of the branch objects is redefined <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ab = {<span class="hljs-attr"><span class="hljs-attr">c</span></span>: {<span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>}};</code> </pre><br><br><h1>  <font color="#8bc34a">‚ÄúDeep Links‚Äù</font> </h1><br>  The doll for a long time includes the <a href="http://ru.matreshka.io/">linkProps</a> method, which allows you to set the dependence of some properties on others. <br><br>  You can set the dependence on your own properties: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linkProps(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'bc d'</span></span>, (b, c, d) =&gt; b + c + d); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.c = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.d = <span class="hljs-number"><span class="hljs-number">3</span></span>; alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a); <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre><br>  You can set the dependence on the properties of other objects: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linkProps(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, [ externalObject, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, externalObject2, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span> ]); externalObject.b = <span class="hljs-number"><span class="hljs-number">1</span></span>; externalObject2.c = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.d = <span class="hljs-number"><span class="hljs-number">3</span></span>; alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a); <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre><br>  Now <code>linkProps</code> supports specifying the path to the property: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linkProps(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'bcd e.f'</span></span>, (d, f) =&gt; d + f); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = {<span class="hljs-attr"><span class="hljs-attr">c</span></span>: {<span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">40</span></span>}}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.e = {<span class="hljs-attr"><span class="hljs-attr">f</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>}; alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a); <span class="hljs-comment"><span class="hljs-comment">// 42</span></span></code> </pre><br>  When something changes in the chain of the path to the property, the Matryoshka intercepts this change, breaks the link with the old chain and creates a dependence on the new chain. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bc = {<span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre><br>  As before, you can create a dependency on the properties of other objects, while, as mentioned above, any object can act as a source object: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> targetObject = {}, o1 = {<span class="hljs-attr"><span class="hljs-attr">b</span></span>: {<span class="hljs-attr"><span class="hljs-attr">c</span></span>: {<span class="hljs-attr"><span class="hljs-attr">d</span></span>: <span class="hljs-number"><span class="hljs-number">40</span></span>}}}, o2 = {<span class="hljs-attr"><span class="hljs-attr">e</span></span>: {<span class="hljs-attr"><span class="hljs-attr">f</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>}}; MK.linkProps(targetObject, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, [ o1, <span class="hljs-string"><span class="hljs-string">'bcd'</span></span>, o2, <span class="hljs-string"><span class="hljs-string">'ef'</span></span> ], (d, f) =&gt; d + f); alert(targetObject.a); <span class="hljs-comment"><span class="hljs-comment">// 42</span></span></code> </pre><br><br><h1>  <font color="#8bc34a">Transparent syntax of delegated events</font> </h1><br>  Let me remind you that in previous versions it was possible to hang an event not only on the current object ( <code>this</code> ), but also on an object of arbitrary nesting.  But the syntax made you want something better.  I will give a small example.  Say, an instance of the Matryoshka has or should appear a certain property, which, in turn, is also an instance of the Matryoshka. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matreshka();</code> </pre><br>  You could, before or after assigning the property, create an event handler for any event that relates to this property.  To do this, use the syntax with the "dog". <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'a@someevent'</span></span>, handler); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a.trigger(<span class="hljs-string"><span class="hljs-string">'someevent'</span></span>);</code> </pre><br>  For <a href="http://ru.matreshka.io/">arrays</a> and <a href="http://ru.matreshka.io/">objects</a> (which are collections of key-value type in Matryoshka), it was possible not to specify the target property, since the event is listened to in all elements included in the collection: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'@someevent'</span></span>, handler); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matreshka()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>].trigger(<span class="hljs-string"><span class="hljs-string">'someevent'</span></span>);</code> </pre><br>  At first glance, it looks simple.  But what if our object tree is a bit more complicated?  For example, the property <code>"a"</code> contains a collection: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MK.Array(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matreshka());</code> </pre><br>  How to catch an event inside such a collection?  You can combine two dogs that say: ‚Äúin the object <code>"a"</code> catch the event <code>"@someevent"</code> -&gt; in the array element, catch the event <code>"someevent"</code> ‚Äù. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'a@@someevent'</span></span>, handler); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a[<span class="hljs-number"><span class="hljs-number">0</span></span>].trigger(<span class="hljs-string"><span class="hljs-string">'someevent'</span></span>);</code> </pre><br>  This can still be experienced (if you drink enough coffee).  And what if we want to go deeper?  Then the number of "dogs" will increase and coffee will no longer help ... <br><br>  Agree, the potential of this feature is very large.  We can listen to data events of any nesting, for example, to learn about changing the properties of an object contained in an array of arrays, etc. Therefore, it was decided to somewhat change the syntax of delegated events.  ‚ÄúDog‚Äù remained, but as the only separator of the path to the object and the name of the event.  If an event concerns a nested object, the dogs are replaced with dots.  If we want to learn about something in the collection, instead of a faceless dog we use an asterisk.  Then I probably need to stop and give a couple of examples. <br>  If we want to hang the handler on the property <code>""</code> then the syntax remains the same: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'a@someevent'</span></span>, handler);</code> </pre><br>  If we want to catch an event from a collection item, then instead of this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'@someevent'</span></span>, handler);</code> </pre><br>  We write this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'*@someevent'</span></span>, handler);</code> </pre><br>  An asterisk means ‚Äúany property responsible for the data in <a href="http://matreshka.io/">MK.Object</a> ‚Äù or ‚Äúany element of the <a href="http://matreshka.io/">MK.Array</a> collection‚Äù. <br><br>  We go deeper.  We need to comb the following example described above: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'a@@someevent'</span></span>, handler);</code> </pre><br>  Now we write this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'a.*@someevent'</span></span>, handler);</code> </pre><br>  The syntax has become much cleaner.  You just need to specify the path to the object before @, and after it specify the name of the event. <br><br>  <a href="http://habrahabr.ru/company/matreshka/blog/267513/">Detailed article about the events.</a> <br><br><h1>  <font color="#8bc34a">setClassFor</font> </h1><br>  <a href="http://ru.matreshka.io/">setClassFor</a> is another incredibly cool feature.  It indicates which class should be the specified property.  When you try to overwrite a property, the internal interceptor, instead of assignment, updates it with new data.  We will understand by example. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ( ) this.x = {a: 41}; //     this.setClassFor('x', MyClass); // ,      MyClass console.log(this.x instanceof MyClass); // true //   "a‚Äù  console.log(this.xa); // 41 //    //   "x‚Äù    var x = this.x; //    this.x = {a: 42}; // ,    console.log(xa); // 42 // ,       console.log(x === this.x); // true // Wow!    ,   !</span></span></code> </pre><br>  If you have a deep structure of objects and <code>setClassFor</code> also running in nested objects, you can do interesting things.  For example, save the presentation of multi-level data in the local storage. <br><br><pre> <code class="javascript hljs">localStorage.x = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x);</code> </pre><br>  And then restore them with a wave of a magic wand: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(localStorage.x);</code> </pre><br>  Or, drive back and forth to the server. <br><br>  Cases where such logic may need an incredible amount.  As another example, here‚Äôs the code from the documentation (for brevity, the <a href="https://github.com/jeffmo/es-class-properties">class properties</a> from ECMAScript 7 are used): <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// app.js class App extends MK { constructor(appData) { this.appData = appData; this.setClassFor('appData', AppData); } } // app-data.js class AppData extends MK.Object { constructor(data) { super(data) .setClassFor({ friends: Friends, settins: Settings }); } } // friend.js class Friend extends MK.Object { constructor(data) { super(data); } } // friends.js class Friends extends MK.Array { Model = Friend; constructor(data) { super(...data); } } // settings.js class Settings extends MK.Object { constructor(data) { super(data) .setClassFor('credentials', Credentials); } } // credentials.js class Credentials extends MK.Object { constructor(data) { super(data); } } // app-init.js var app = new App({ settings: { name: 'Vasiliy Vasiliev', credentials: { email: 'vasia.vasia@gmail.com' } }, friends: [{ name: 'Yulia Zuyeva', id: 1 }, { name: 'Konstantin Konstantinopolsky', id: 2 }, { name: 'nagibator3000', id: 3 }] }); //        JSON.stringify(app.appData); //       appData //  ,     app.appData = { settings: { name: 'Petr Petrov', credentials: { email: 'petr.petrov@gmail.com' } }, friends: [{ name: 'Yulechka Zuyeva', id: 1 }, { name: 'Konstantin Konstantinopolsky', id: 2 }] };</span></span></code> </pre><br>  More details in the <a href="http://ru.matreshka.io/">documentation for the method</a> . <br><br><h1>  <font color="#8bc34a">DOM template engine</font> </h1><br>  Matryoshka is a framework that professes the idea that logic should be contained in JS files, as opposed to frameworks that implement the MVVM pattern, forcing to describe logic in HTML code. <br><br>  Implementing logic in JS files is really very convenient.  But, sometimes, there are situations when the description of all bayding is too expensive in terms of the number of lines of code. <br><br>  Therefore, it was decided to improve and speed up the DOM template engine, which was absent until recently in the official API.  What is he doing?  It takes a DOM node, a collection of DOM nodes, an HTML code, or a sandbox for the current object, parses it, finding angular-like constructions like <code>{{KEY}}</code> and creates bindings where these constructs are found. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://{{website.domain}}/{{category}}/{{page}}"</span></span></span><span class="hljs-tag">&gt;</span></span>Look at the {{info.title}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parseBindings(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.website.domain = <span class="hljs-string"><span class="hljs-string">'example.com'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.category = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.page = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.info.title = <span class="hljs-string"><span class="hljs-string">'cool stuff'</span></span>;</code> </pre><br>  The method is described <a href="http://ru.matreshka.io/">in</a> more detail <a href="http://ru.matreshka.io/">in the documentation</a> . <br><br>  The method does not contradict the ideology of Matryoshka, since there can be no logic (cycles, conditions, handlers) in the pattern. <br><br>  In addition to publishing the API of the method itself, the template engine for collections is now enabled by default (you no longer have to write <code>useBindingsParser: true</code> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyArray</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MK</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Array</span></span></span><span class="hljs-class"> </span></span>{ itemRenderer = <span class="hljs-string"><span class="hljs-string">'&lt;span&gt;Hello, {{name}}&lt;/span&gt;'</span></span>; ... }</code> </pre><br><br><h1>  <font color="#8bc34a">More sugar for ECMAScript 2015</font> </h1><br><br>  From the example to <code>setClassFor</code> can see that the methods are run immediately after <code>super()</code> .  This possibility became real thanks to a very simple change: all three constructors ( <code>Matreshka</code> , <code>Matreshka.Array</code> , <code>Matreshka.Object</code> ) return <code>this</code> instead of <code>undefined</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MK</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(data) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(data) .bindNode(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-node'</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">//   MyObject   a  b, //    myObject = new MyObject({a: 1, b: 2}); class MyCollection extends MK.Array { constructor(data) { super(...data) .bindNode('x', '.my-node'); } } //  ,   5  myCollection = new MyCollection([1,2,3,4,5]);</span></span></code> </pre><br><br><h1>  <font color="#8bc34a">Support for event-type objects in the <a href="http://ru.matreshka.io/">on</a> , <a href="http://ru.matreshka.io/">once</a> , <a href="http://ru.matreshka.io/">onDebounce methods</a></font> </h1><br>  In previous versions, the only syntax for declaring event handlers was available to the developer. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'eventname1'</span></span>, handler1); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on(<span class="hljs-string"><span class="hljs-string">'eventname2'</span></span>, handler2);</code> </pre><br>  Now you can declare several handlers by calling the corresponding method only once: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on({ <span class="hljs-string"><span class="hljs-string">'eventname1'</span></span>: handler1, <span class="hljs-string"><span class="hljs-string">'eventname2'</span></span>: handler2 });</code> </pre><br>  This news would not have been mentioned in this post if it were not for one thing: using ECMAScript 2015, you can greatly shorten the code in microtasks. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on({ <span class="hljs-string"><span class="hljs-string">'eventname1'</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">'eventname2'</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function"> =&gt;</span></span> doSomethingElse() });</code> </pre><br>  Against the ‚Äúold‚Äù syntax: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.on({ <span class="hljs-string"><span class="hljs-string">'eventname1'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">42</span></span> }, <span class="hljs-string"><span class="hljs-string">'eventname2'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">evt</span></span></span><span class="hljs-function">) </span></span>{ doSomethingElse(); } });</code> </pre><br><br><h1>  <font color="#8bc34a">Override <a href="http://ru.matreshka.io/">itemRenderer</a></font> </h1><br>  <code>itemRenderer</code> is a virtual property of the collection ( <code>Matreshka.Array</code> ), which tells how to draw the elements of the collection. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,  ES7 class MyCollection extends MK.Array { itemRenderer = "&lt;div&gt;Hi there!&lt;/div&gt;"; constructor() { super() .bindNode('sandbox', '.array-sandbox') .push({a: 1}, {a: 2}); } }</span></span></code> </pre><br>  See <a href="http://ru.matreshka.io/">the itemRenderer documentation for</a> more details. <br><br>  Starting with the new version, when overriding <code>itemRenderer</code> , the collection is automatically redrawn. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   - span this.itemRenderer = '&lt;span&gt;I'm a span&lt;/spam&gt;'; //   - div this.itemRenderer = '&lt;div&gt;I'm a div&lt;/div&gt;';</span></span></code> </pre><br>  You can create several user cases: you want to change the design of the collection with one button, or your template resides on the server (in the example below, the <a href="http://habrahabr.ru/post/252941/">Fetch API is used</a> ). <br><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">'templates/my-template.html'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resp</span></span></span><span class="hljs-function"> =&gt;</span></span> resp.text()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.itemRenderer = text);</code> </pre><br>  You can work with the collection as usual: insert, delete, sort elements, while you do not need to wait until the server returns the template.  Upon returning from the server, the collection itself will be displayed on the page <br><br><h1>  <font color="#8bc34a">New binders</font> </h1><br>  Let me remind you that a binder is an object that indicates how to associate a property with an element on a page.  Binder is used by the <a href="http://ru.matreshka.io/">bindNode</a> method, which implements one or two-way binding. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-node'</span></span>, binder); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre><br>  Detailed descriptions can be found in the <a href="http://ru.matreshka.io/">documentation for the method</a> . <br><br>  <a href="http://ru.matreshka.io/">MK.binders.progress</a> - associates a property with the HTML5 state of the <a href="http://htmlbook.ru/html/progress">progress</a> element.  The binder does not need to be called manually, as it belongs to the standard binders collection. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-progress'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     42</span></span></code> </pre><br>  <a href="http://ru.matreshka.io/">MK.binders.innerText</a> - associates a property with the text value of any element that has a <code>textContent</code> or <code>innerText</code> property. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-node'</span></span>, MK.binders.innerText()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-string"><span class="hljs-string">'Some &lt;i&gt;Text&lt;/i&gt;'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    " ‚Äù,   </span></span></code> </pre><br>  <a href="http://ru.matreshka.io/">MK.binders.style</a> - associates a property of an object with a property of an object's <code>style</code> element. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-node'</span></span>, MK.binders.style(<span class="hljs-string"><span class="hljs-string">'color'</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-string"><span class="hljs-string">'red'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre><br>  And the most interesting: <a href="http://ru.matreshka.io/">MK.binders.file</a> .  This new binder will not only catch the change in the user <code>input[type=‚Äùfile‚Äù]</code> , but also read the file in the format you need: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-file'</span></span>, MK.binders.file(<span class="hljs-string"><span class="hljs-string">'dataURL'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//   ,    this.on('change:x', function() { console.log(this.x.readerResult); // "data:image/png;base64,iVBO..." });</span></span></code> </pre><br>  For more information, <a href="http://ru.matreshka.io/">see the documentation for the binder</a> . <br><br><h1>  <font color="#8bc34a">getValue for <a href="http://ru.matreshka.io/">innerHTML</a> , <a href="http://ru.matreshka.io/">className</a> , <a href="http://ru.matreshka.io/">property</a> and <a href="http://ru.matreshka.io/">attribute</a> <a href="http://ru.matreshka.io/">binders</a></font> </h1><br>  Now, when using the above listed binders, the Matryoshka kernel will check if there is a corresponding property in the current object and, if the answer is negative, extract the value from the element and assign it to the property. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-div"</span></span></span><span class="hljs-tag">&gt;</span></span>Some data<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,  this.x  . this.bindNode('x', '.my-div', MK.binders.innerHTML()); alert(this.x); //"Some data"</span></span></code> </pre><br><br><h1>  <font color="#8bc34a"><a href="http://ru.matreshka.io/">onItemRender</a></font> </h1><br>  <code>Matreshka.Array</code> has a new virtual method <code>onItemRender</code> .  It is called when one of the elements of the collection has been drawn.  The method makes the code more flat, allowing you to avoid listening to the <code>"render"</code> event. <br><br>  The <code>"render"</code> event has always been a standard pattern that allows you to add the necessary bindings when rendering. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCollection</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MK</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Array</span></span></span><span class="hljs-class"> </span></span>{ Model: MyModel; itemRenderer = <span class="hljs-string"><span class="hljs-string">'&lt;li&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>() .bindNode(<span class="hljs-string"><span class="hljs-string">'sandbox'</span></span>, <span class="hljs-string"><span class="hljs-string">'.array-sandbox'</span></span>) .on(<span class="hljs-string"><span class="hljs-string">'*@render'</span></span>, evt =&gt; { evt.self.bindNode(...); }); } }</code> </pre><br>  Now you can do this: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCollection</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MK</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Array</span></span></span><span class="hljs-class"> </span></span>{ Model: MyModel; itemRenderer = <span class="hljs-string"><span class="hljs-string">'&lt;li&gt;'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>() .bindNode(<span class="hljs-string"><span class="hljs-string">'sandbox'</span></span>, <span class="hljs-string"><span class="hljs-string">'.array-sandbox'</span></span>); } onItemRender(item, evt) { item.bindNode(...); } }</code> </pre><br>  The ‚Äúmodels‚Äù have a similar virtual method: <code>onRender</code> . <br>  It used to be like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MK</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>() .on(<span class="hljs-string"><span class="hljs-string">'render'</span></span>, evt =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(...); }); } }</code> </pre><br>  Now you can write like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MK</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>() } onRender() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(...); } }</code> </pre><br><br><h1>  <font color="#8bc34a">Properties <a href="http://ru.matreshka.io/">nodes</a> and <a href="http://ru.matreshka.io/">$ nodes</a></font> </h1><br>  After declaring a data binding and a DOM node, the developer could access the linked nodes using the <a href="http://ru.matreshka.io/">bound</a> and <a href="http://ru.matreshka.io/">$ bound</a> methods.  <code>bound</code> returns the first bound element, <code>$bound</code> - all elements as a jQuery or Balalaika collection. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-node'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boundNode = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bound(<span class="hljs-string"><span class="hljs-string">'x'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> allBoundNodes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$bound(<span class="hljs-string"><span class="hljs-string">'x'</span></span>);</code> </pre><br>  The <code>nodes</code> and <code>$nodes</code> properties allow you to do the same, but practically for free, in terms of performance, since these properties are ordinary objects. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'.my-node'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boundNode = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nodes.x; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> allBoundNodes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$nodes.x;</code> </pre><br><br><h1>  <font color="#8bc34a">Some more new methods</font> </h1><br>  <a href="http://ru.matreshka.io/">Matreshka.to</a> converts an arbitrary object into instances of <code>MK.Object</code> and <code>MK.Array</code> . <br>  <a href="http://ru.matreshka.io/">MK.Array.of</a> , which works in the same way as <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/of">Array.of</a> , but returns an instance of <code>MK.Array</code> . <br>  <a href="http://ru.matreshka.io/">MK.Array.from</a> , which works the same way as <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/from">Array.from</a> , but returns an instance of <code>MK.Array</code> . <br>  <a href="http://ru.matreshka.io/">MK.trim</a> for browsers that do not support <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/Trim">String.prototype.trim</a> . <br>  <a href="http://ru.matreshka.io/">MK.toArray</a> , which converts an array-like array to a native <code>Array</code> is twice as fast as <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/slice">Array.prototype.slice</a> does. <br><br><h1>  <font color="#8bc34a">Increase in productivity</font> </h1><br>  Using micro-optimizations (for example, using the <code>for..in</code> loop instead of the <code>each</code> function) and larger changes, it turned out to achieve excellent results.  For example, in a benchmark with small collections (10 items), the Matryoshka fell behind React by 10-20 percent in Chrome and Firefox (although it overtook in benchmarks with a large number of collection items).  Now in the same test, Matryoshka is 50% faster than React in Chrome, and 3 times faster in Firefox. <br><br>  Here is a list of benchmarks to see for yourself: <a href="http://jsperf.com/angular-vs-knockout-vs-react-vs-matreshka/20">10 elements</a> , <a href="http://jsperf.com/angular-vs-knockout-vs-react-vs-matreshka/21">50 elements</a> , <a href="http://jsperf.com/angular-vs-knockout-vs-react-vs-matreshka/22">100 elements</a> , <a href="http://jsperf.com/angular-vs-knockout-vs-react-vs-matreshka/23">500 elements</a> , <a href="http://jsperf.com/angular-vs-knockout-vs-react-vs-matreshka/24">1000 elements</a> . <br><br><h1>  <font color="#8bc34a">Bug work: tests</font> </h1><br>  Matryoshka finally tested automatically.  At the time of this writing, 148 tests have been implemented that test the performance of methods before they develop.  The delegated events are especially meticulously tested, which are obliged to work in a variety of different circumstances and do not break anything. <br><br><h1>  <font color="#8bc34a">Browser Support</font> </h1><br>  A warning appeared on the documentation site that the use of Matryoshka in Internet Explorer 8 is not recommended due to the mass of methods that cannot be implemented for this version of the donkey.  In fact, this is only a disclaimer on cases when a developer tries to use such methods without thinking.  One thing to be remembered: static methods that add "magic" to native objects do not work in IE8. <br><br>  Such code will work in IE8, in case <code>this</code> is an instance of Matryoshka. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bindNode(<span class="hljs-string"><span class="hljs-string">'key'</span></span>, <span class="hljs-string"><span class="hljs-string">'.node'</span></span>);</code> </pre><br>  And this will work: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mk = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matreshka(); mk.bindNode(<span class="hljs-string"><span class="hljs-string">'key'</span></span>, <span class="hljs-string"><span class="hljs-string">'.node'</span></span>);</code> </pre><br>  And this code will work only in IE9 + and in other browsers (including the ancient WebKit and Opera Mini): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object = {}; MK.bindNode(object, <span class="hljs-string"><span class="hljs-string">'key'</span></span>, <span class="hljs-string"><span class="hljs-string">'.node'</span></span>);</code> </pre><br>  If your hands are itching to use static methods in the eighth donkey, you can convert the object into an instance of the Nested dolls: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object = MK.to({}); MK.bindNode(object, <span class="hljs-string"><span class="hljs-string">'key'</span></span>, <span class="hljs-string"><span class="hljs-string">'.node'</span></span>);</code> </pre><br>  Thus, <a href="http://semver.org/">semantic versioning is</a> respected. <br><br><h1>  <font color="#8bc34a">Other changes</font> </h1><br>  - The <a href="http://ru.matreshka.io/">bindNode</a> syntax <a href="http://ru.matreshka.io/">has</a> expanded a bit. <br>  - Errors about missing nodes using the <code>bindNode</code> method <code>bindNode</code> more informative: now in the text, besides the key, the selector is indicated (if a selector is transmitted). <br>  - The source code is broken into small components. <br>  - Unnecessary spaces ( <code>f(x)</code> instead of <code>f( x )</code> ) are removed from the code and from the examples on the site. <br>  - As already stated above, Matryoshka supports Opera Mini and old WebKit. <br><br>  For other changes and a list of corrected errors, you can find out <a href="http://ru.matreshka.io/">in the corresponding section on the site</a> . <br><br><h1>  <font color="#8bc34a">And further</font> </h1><br>  You can look at what has been done and is planned in <a href="https://trello.com/b/E5KcQESk/matreshka-js-features">Trello</a> .  In the same place, you can also request it by raising the priority of the cards. <br><br>  In the <a href="https://gitter.im/finom/matreshka/ru">Gitter chat</a> , discussions of new features occur quite often.  Because of this, the questions that users ask, and the answers to them are lost somewhere in the dark basements of the Internet.  Therefore, it was decided to launch, as an experiment, a forum based on <a href="http://muut.com/">Muut</a> ( <a href="http://ru.matreshka.io/forum/">in Russian</a> and <a href="http://matreshka.io/forum/">in English</a> ).  If a question arises, feel free to ask it there (even if you think the question is stupid). <br><br>  For an example, here‚Äôs one of the great <a href="https://habrahabr.ru/users/rendol/" class="user_link">Rendol</a> questions with an upside-down answer to it: <br><blockquote>  Greetings <br>  Again, the same question that I previously had, but the answer I did not find it beautiful. <br>  For example, the correspondence as in VK: <br><pre> <code class="javascript hljs">User = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fedor'</span></span>, <span class="hljs-attr"><span class="hljs-attr">online</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  We place this user in different rooms: room1, room2, room3. <br>  If User.online = false, then in all 3 rooms, for example, the color should change. <br>  So  3 collections that contain one object and at the same time this object is displayed in 3 places. <br>  Note: it is not necessary that these collections will be of the same type (not only rooms), they can be of different types and representations. <br>  Is it possible to bind one object to multiple views? </blockquote><br>  Answer: <br><blockquote>  Yes, collections containing an object can be different.         <code>bindRenderedAsSandbox: false</code> ,       ,      (,      ,      ).   .    <code>render</code>  ,       ,   ,  . <br>    : <a href="http://jsbin.com/cidise/12/edit">jsbin.com/cidise/12/edit</a> .  <code>user</code>      (    ul),   -.     <code>tableUsers[0].name = 'xxx'</code>   ,    , . ,           . <br>  Shl.   IE 8,   ,     ,    <code>.instanceOf</code> <br><pre> <code class="javascript hljs">object.instanceOf( MyClass ); <span class="hljs-comment"><span class="hljs-comment">//  object instanceof MyClass</span></span></code> </pre><br></blockquote><br> ,   .   . </habracut></div><p>Source: <a href="https://habr.com/ru/post/267483/">https://habr.com/ru/post/267483/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267469/index.html">Search tips from the inside</a></li>
<li><a href="../267471/index.html">gulpfile in 10 lines? Easy! - we simplify the creation of standard tasks</a></li>
<li><a href="../267473/index.html">Understand Open Source</a></li>
<li><a href="../267475/index.html">How to bypass the lock screen in iOS without knowing the password</a></li>
<li><a href="../267477/index.html">Create a REST service on PostgreSQL and Rust. Part 1: prototype</a></li>
<li><a href="../267487/index.html">Embarcadero Technologies sold to Idera</a></li>
<li><a href="../267491/index.html">About UEFI security, part four</a></li>
<li><a href="../267495/index.html">New in Runkit 1.0.4: PHP 5.6+, closures everywhere and 12 more new features</a></li>
<li><a href="../267497/index.html">Recipes for Android: How to make a delicious LayoutManager</a></li>
<li><a href="../267499/index.html">Messy about developing letters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>