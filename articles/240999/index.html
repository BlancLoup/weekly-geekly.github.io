<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>TeaVM is another way to launch Java in the browser</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dear readers! I want to share with you my open-source project, on which I have been working in my spare time for quite some time, TeaVM . TeaVM is a J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>TeaVM is another way to launch Java in the browser</h1><div class="post__text post__text-html js-mediator-article"> Dear readers!  I want to share with you my open-source project, on which I have been working in my spare time for quite some time, <a href="http://teavm.org/">TeaVM</a> .  TeaVM is a Java bytecode translator to JavaScript.  There are several attempts to create a JVM in JavaScript, one of the most successful is <a href="https://github.com/plasma-umass/doppio">Doppio</a> .  However, apart from the academic, they do not represent any value, since the speed of interpretation of the byte code leaves much to be desired.  Moreover, in order to interpret bytecode, it is necessary at least to load this bytecode into the browser, and this degenerates into downloading tens of megabytes of <code>class</code> files. <br><br>  In contrast, TeaVM does not interpret bytecode, but generates JavaScript, which performs exactly what baytcode would do if it were run in a real JVM.  Simply put, TeaVM decompiles Java bytecode, but not back to Java, but to JavaScript.  Of course, all this is true to certain limits.  First, JavaScript simply lacks certain things familiar to Java developers, such as threads, full Unicode support (for example, support for character classes, regular expressions), blocking I / O.  Secondly, this is due to the requirements that I imposed on the compiler.  For example, in TeaVM, reflection support is very limited.  This is a consequence of one of the advantages of TeaVM - the relatively small size of the generated file.  No, TeaVM does not generate the lowest possible javascript, however, it will not generate huge multi-megabyte scripts for every sneeze.  Reflection makes it impossible for any static analysis, so it was decided to abandon it. <br><br>  Before I continue, I want to show for the beginning what TeaVM is capable of.  Firstly, it is able to <a href="http://teavm.org/live-examples/jbox2d-benchmark/teavm.html">simulate physics</a> in real time.  Secondly, he is still able to draw <a href="http://teavm.org/live-examples/geobot/">beautiful pictures</a> in Canvas by this physics.  You can see that the javascript files are relatively small.  By the way, I didn‚Äôt implement the physics calculation myself, I just took the existing <a href="https://github.com/jbox2d/jbox2d">JBox2D</a> library. <br><a name="habracut"></a><br>  TeaVM was conceived as a tool for a developer who would be suitable for developing browser-based Java applications, and not as another academic project.  I believe that this kind of tool should have the following characteristics: <br><ul><li>  Acceptable performance.  No one will wait for the compiler for hours.  And even better - a very fast speed of work so that the developer does not wait for a few minutes in order to see if the button has moved after his edits in the code. </li><li>  Fast javascript. </li><li>  Compact JavaScript.  The user will be very angry with the developer when he sees that the page is pulling over megabytes of JavaScript.  More precisely, the user will not look at the size, but he will notice a decrease in page loading speed with the naked eye. </li><li>  Good support for the JDK class set.  Java is not only a programming language, but also a set of classes from the standard library that Java developers are used to using in their daily work. </li><li>  Support popular build systems.  Such in the Java world is, above all, Maven, although lately Gradle has been gaining popularity. </li><li>  Support for popular IDEs: Eclipse, Netbeans, IntelliJ IDEA. </li><li>  Ability to debug code, "running" in TeaVM.  Believe me, it is very unpleasant to debug generated JavaScript, I personally tried. </li><li>  Ability to integrate with existing JavaScript libraries and browser APIs. </li></ul><br>  All of the above is somehow implemented in TeaVM.  True, I can't just take it and implement it all at once, so only Maven is supported from the build systems, while Eclipse is supported from the IDE.  Plans to make support for other IDE and build systems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Project creation </h2><br>  I tried to make the creation of a new project as simple as possible.  To do this, just execute the following command in the console: <br><pre> <code class="bash hljs">mvn -DarchetypeCatalog=<span class="hljs-built_in"><span class="hljs-built_in">local</span></span> \ -DarchetypeGroupId=org.teavm \ -DarchetypeArtifactId=teavm-maven-webapp \ -DarchetypeVersion=0.2.1 \ archetype:generate</code> </pre><br>  If you are a Windows user, you will need to rewrite this command slightly.  And even easier - take the appropriate details and use them to create a new Maven-project in the IDE.  By the way, if your IDE is Eclipse, then it makes sense to install the plugin from the <a href="">repository</a> . <br><br>  With the existing project can play.  If you have questions, you can refer to the <a href="https://github.com/konsoletyper/teavm/wiki">documentation</a> .  And if you did not find the answer to your question in the documentation, publish it in the form of an issue in GitHub. <br><br><h2>  Eclipse plugin </h2><br>  The code for production is generated by the build system, but when developing, rebuilding the project each time is not very convenient.  After all, this requires each time to launch maven, that is, to start a new JVM, which takes time to warm up.  This means that the assembly will be slow.  By running the same build in the already-heated JVM in which the IDE runs, you can achieve a significant increase in build speed.  In addition, in the IDE, it is possible to start building and publishing JavaScript when the source code changes.  In this way, you can achieve the cycle that is traditional for regular JavaScript - you saved and updated the page in the browser.  Actually, this feature is implemented in the plugin for Eclipse. <br><br>  Another thing I consider necessary is the automatic setup of the project.  For example, if a new participant comes to the project, then you really do not want to force him to read a long manual on setting up the project in the IDE, which, moreover, contains errors, so you also have to spend your time to help the newcomer.  Or, if I wanted to work on a project in the country with a laptop, I really do not want to repeat the steps that I once did in the office.  If the project is going to Maven, then IDE will open and configure it as needed.  I did not want to deprive this opportunity of developers who use TeaVM, so I also created a configurator for the m2e.  This made it possible for the developer to only import the Maven project or create a project from the archetype, after which the project can be run on a ready-made server and enjoy the development, as can be seen from the <a href="https://github.com/konsoletyper/teavm/wiki/Eclipse-tutorial">tutorial</a> . <br><br>  Finally, the ability to debug code is very important.  GWT has DevMode, which runs the code in the JVM and connects to the browser, passing all native JavaScript calls to it.  However, due to the <a href="http://blog.chromium.org/2013/09/saying-goodbye-to-our-old-friend-npapi.html">termination of</a> <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D1%2580%25D1%2584%25D0%25B5%25D0%25B9%25D1%2581_%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B0%25D0%25B5%25D0%25BC%25D1%258B%25D1%2585_%25D0%25BC%25D0%25BE%25D0%25B4%25D1%2583%25D0%25BB%25D0%25B5%25D0%25B9_Netscape">NPAPI</a> support in some browsers, it became impossible to further support the browser plugin, which accepted connections and executed DevMode commands.  I must say that these are not the GWT developers who are so bad that they don‚Äôt want to rewrite the plugin, these browser developers are so bad that they won‚Äôt figure out how to make friends with JavaScript with synchronous I / O. <br><br>  Alternatively, the GWT team suggests using <a href="http://www.gwtproject.org/articles/superdevmode.html">SuperDevMode</a> , which <br>  based on <a href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">source maps</a> .  Source maps are bad because the developer is forced to debug the code in the wrong place in which he writes it.  Moreover, the browser does not provide all the cool chips that are available in the IDE.  Finally, source maps simply cannot translate such things as the names of variables, fields, methods, classes. <br><br>  What did I do?  If the browser understands source maps, then let source maps understand the IDE.  But just let it be improved source maps.  As a result, in addition to the standard source maps, TeaVM generates its debugging information, and also contains a plugin that allows you to use this debugging information in Eclipse.  If you want to see what happened, you can <a href="https://github.com/konsoletyper/teavm/wiki/Debugging">try it</a> yourself. <br><br>  Summing up, I want to note that the plugin for Eclipse is not just a tool, but also a kind of proof of concept, showing that based on the functionality available in TeaVM, it is quite possible to create plugins for the IDE.  Implementing plugins to other IDEs is now a matter of technology. <br><br><h2>  Plans </h2><br>  In fact, the project is still evolving and developing.  There are many plans, just some of them: <br><ul><li>  The plan for the near future is to implement an alternative backend for <a href="http://libgdx.badlogicgames.com/">libGDX</a> .  GWT does not quite satisfy the authors of the framework, in addition, TeaVM is already running faster, and there is still room for further optimizations. </li><li>  Cool library for client development.  Now all that is is thin wrappers around some browser-based APIs.  Of course, to develop applications you need something more comfortable.  TeaVM itself will never include any libraries for developing client applications.  This is a completely different project.  It may be possible to take a ready-made library that runs on the same GWT, and adapt it for TeaVM.  However, there is already one such framework, <a href="http://dukescript.com/">DukeScript</a> , but I absolutely do not like either its implementation or how it is <s>not</s> documented;  nevertheless, I included his support in TeaVM. </li><li>  Automatic generation of asynchronous code.  I do not like noodles from callbacks.  And due to the fact that blocking operations in JavaScript are absent as a class, they can be emulated by special conversion of the code. </li><li>  Many optimizations.  JavaScript engines have very good optimizers, but they don‚Äôt always know about the code what is available to the static optimizer.  Due to the fact that TeaVM inside uses the <a href="https://ru.wikipedia.org/wiki/SSA">SSA</a> view, various optimizations are implemented quite simply and painlessly. </li><li>  Implement even more classes from the JDK. </li><li>  Implement support for INVOKEDYNAMIC instructions, in particular, so that you can run lambdas from Java 8. </li><li>  Make TeaVM friends with Kotlin and Scala.  There is nothing special about the bytecode that they generate, and TeaVM perfectly translates it into JavaScript.  However, runtime of these languages ‚Äã‚Äãuse JDK classes that are not implemented in TeaVM.  This is solved by either implementing these classes or rewriting the corresponding part of the runtime. </li></ul><br><br><h2>  Why not ... </h2><br><br><h3>  ... GWT? </h3><br>  I write quite a lot on GWT, and I am very unhappy with this framework.  The idea to generate javascript from source is extremely unfortunate. <br><ul><li>  It is necessary to produce crutches at the level of the build system in order to properly connect the sources of all libraries to the build system. </li><li>  No support for other languages.  For some languages, there is its own GWT analogues, for example, <a href="http://www.scala-js.org/">Scala.js</a> and native support in <a href="http://kotlinlang.org/">Kotlin</a> .  However, they have another drawback: the inability to interact with existing Java libraries. </li><li>  GWT does not integrate with utilities that convert or generate bytecode. </li></ul><br>  In addition, I have a number of complaints about how GWT is implemented, namely: <br><ul><li>  The GWT team actually refused to support DevMode - the only way to debug the code.  There is a SuperDevMode, but it is extremely inconvenient. </li><li>  GWT is pretty slow.  And the fact that it also generates permutations makes the assembly unbearably long. </li><li>  The idea of ‚Äã‚Äãkeeping generated JavaScript on a separate server leads to crutches and stumble upon all sorts of problems related to the fact that resources (images, CSS), RPC and code are on different servers during debugging, but at the same time on the same server - in combat conditions. </li></ul><br>  At the same time, I don‚Äôt like to write in JavaScript, especially because of the dynamic nature of the language.  Therefore, I choose GWT from two evils, but I want something better. <br><br><h3>  ... emscripten? </h3><br>  At first glance, TeaVM is very similar to <a href="https://github.com/kripken/emscripten">emscripten</a> .  So why don't I just translate java bytecode into LLVM?  After all, LLVM already contains a ready implementation of SSA.  The thing is that LLVM is very low-level.  This is good, when a program is compiled into a native code, but when it is decompiled into a high-level language, some overhead is obtained.  After all, JavaScript already has such concepts as fields, methods, GC.  And in LLVM, this would all have to be emulated again in JavaScript.  Another reason is that TeaVM is completely written in Java, the compiler can, for example, be zapped, which would not be possible in the case of LLVM and emscripten.  Finally, TeaVM uses slightly more powerful decompiling algorithms than the emscripen. </div><p>Source: <a href="https://habr.com/ru/post/240999/">https://habr.com/ru/post/240999/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240985/index.html">How will Apple Pay affect the mobile payment market?</a></li>
<li><a href="../240987/index.html">Announcement of the annual EMC forum</a></li>
<li><a href="../240993/index.html">China carries out MiTM-attack on iCloud users</a></li>
<li><a href="../240995/index.html">Courses of ethical hacking and penetration testing</a></li>
<li><a href="../240997/index.html">Gesture Recognition in sketchometry</a></li>
<li><a href="../241001/index.html">FTDI Strikes Back</a></li>
<li><a href="../241003/index.html">Exploit Analysis Dianti.A</a></li>
<li><a href="../241005/index.html">Organizing your personal knowledge base in Evernote</a></li>
<li><a href="../241009/index.html">Accident or predestination</a></li>
<li><a href="../241011/index.html">Good morning, Vietnam!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>