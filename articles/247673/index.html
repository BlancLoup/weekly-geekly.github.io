<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FAT32 media emulation on stm32f4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently this task has arisen - FAT32 media emulation on stm32f4. 

 Its unusualness lies in the fact that among the strapping of the microcontroller ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FAT32 media emulation on stm32f4</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/027/eb8/8e9/027eb88e900a4fad978684346a88f3b0.png"><br><br>  Recently this task has arisen - FAT32 media emulation on stm32f4. <br><br>  Its unusualness lies in the fact that among the strapping of the microcontroller there may be no drive at all. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In my case, the drive was, but the rules for working with it did not allow to place the file system.  In TK, however, there was a requirement to organize a Mass Storage interface for accessing data. <br><br>  The result of the work was the module, which I headlined "emfat", consisting of the same name .h and .c file. <br><br>  The module is platform independent.  In the attached example, it works on the stm32f4discovery board. <br><br>  The function of the module is to give out the pieces of the file system that the usb-host will request, substituting user data if it tries to read a certain file. <br><a name="habracut"></a><br><h4>  Who may be useful </h4><br>  <u>First of all</u> , it is useful in any technical solution, where the device offers a Mass Storage interface in read-only mode.  FAT32 emulation "on the fly" in this case will allow you to store data as you please, without the need to support FS. <br><br>  Secondarily, it is useful to aesthetes.  To those who do not have a physical drive, but want to see their device as a disk in the cherished "My Computer".  In the root of the disk, there may be instructions, drivers, a file with a description of the device version, and so on. <br><br>  In this case, it should be noted, instead of emulation of the carrier, you can give the host part of the ‚Äúcompiled‚Äù cast of the prepared FS.  However, in this case, most likely, the memory consumption of the MC will be significantly higher, and the flexibility of the solution will be zero. <br><br><h4>  So how it works. </h4><br><img src="https://habrastorage.org/files/7b0/06c/60a/7b006c60a20149589a083a30679456bd.png"><br><br>  When a user attempts to read or write a file, the corresponding call is translated into usb requests, which are transmitted to our device.  The essence of the query is simple - write or read the sector on the final media. <br><br>  At the same time, it should be noted, the Windows (or another OS) behaves like a hostess in terms of organizing storage on the carrier.  Only she knows what sector wants to read or write.  But he wants to - and completely defragments us, arranging a chaotic "jangling" by sectors ... Thus, the function of a typical USB MSC controller is to submit a portion of 512 bytes with a shift, or count portions, without a murmur. <br><br>  Now back to the emulation function. <br><br>  Immediately I warn you, we do not emulate writing to the media.  Our "carrier" is read only. <br><br>  This is due to the increased complexity of control over the formation of the file table. <br><br>  However, the emfat_write dummy function is present in the module API.  Perhaps in the future a solution will be found for the correct emulation of the record. <br><br>  The task of the module when requesting a read is to ‚Äúgive away‚Äù valid data.  This is his main work.  Depending on the requested sector, this data may be: <br><ul><li>  MBR Record; </li><li>  Boot sector; </li><li>  One of the sectors of the file table FAT1 or FAT2; </li><li>  Directory Description Sector; </li><li>  The data sector related to the file. </li></ul><br>  It should be noted that the acceleration of the decision "what data to give" emphasis was placed.  Therefore, overhead costs have been minimized. <br><br>  Due to the fact that we refused to maintain the recording on the drive, we are free to organize the storage structure, as we want: <br><br><img src="https://habrastorage.org/files/e2a/6d9/1f3/e2a6d91f3b074726bd1d94662629bdd3.png"><br><br>  Everything is absolutely standard, except for a few details: <br><br><ul><li>  Data is not fragmented; </li><li>  Some unnecessary FAT areas are missing; </li><li>  There are no free clusters (the size of the carrier is ‚Äúadjusted‚Äù to the size of the data); </li><li>  The size of the FAT tables is also ‚Äútailored‚Äù to the size of the data. </li></ul><br>  Naturally, you need to understand that this structure is imaginary.  In reality, it is not contained in RAM, but is formed accordingly, depending on the number of the sector read. <br><br><h4>  API module </h4><br>  The API is composed of only three functions: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emfat_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">emfat_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *emfat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *label, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">emfat_entry_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *entries)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emfat_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">emfat_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *emfat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sector, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num_sectors)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emfat_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">emfat_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *emfat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sector, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num_sectors)</span></span></span></span>;</code> </pre> <br>  Of these, the main function is emfat_init. <br><br>  Its user calls it once - when we connect our usb device or at the start of the controller. <br>  The function parameters are an instance of the file system (emfat), a label for the section (label) and a table of FS elements (entries). <br><br>  A table is defined as an array of emfat_entry_t structures as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">emfat_entry_t</span></span> entries[] = { <span class="hljs-comment"><span class="hljs-comment">// name dir lvl offset size max_size user read write { "", true, 0, 0, 0, 0, 0, NULL, NULL }, // root { "autorun.inf", false, 1, 0, AUTORUN_SIZE, AUTORUN_SIZE, 0, autorun_read_proc, NULL }, // autorun.inf { "icon.ico", false, 1, 0, ICON_SIZE, ICON_SIZE, 0, icon_read_proc, NULL }, // icon.ico { "drivers", true, 1, 0, 0, 0, 0, NULL, NULL }, // drivers/ { "readme.txt", false, 2, 0, README_SIZE, README_SIZE, 0, readme_read_proc, NULL }, // drivers/readme.txt { NULL } };</span></span></code> </pre><br>  The following fields are in the table: <br><br>  name: the display name of the element; <br>  dir: whether the item is a directory (otherwise, a file); <br>  lvl: nesting level of the element (you need emfat_init functions to understand if the element is assigned to the current directory, or to the directories above); <br>  offset: incremental offset when calling a custom callback function to read the file; <br>  size: file size; <br>  user: this value is transmitted ‚Äúas is‚Äù, the user callback function of reading the file; <br>  read: a pointer to a custom callback function to read the file. <br><br>  The callback function has the following prototype: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readcb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userdata)</span></span></span></span>;</code> </pre><br>  It sends the address ‚Äúwhere‚Äù to read the file (the parameter dest), the size of the data read (size), the offset (offset) and userdata. <br>  Also in the table there is a field max_size and write.  The max_size value should always be equal to the size value, and the write value should be NULL. <br><br>  The remaining two functions are emfat_write and emfat_read. <br><br>  The first, as mentioned earlier, is a dummy, which, however, we call if the OS receives a request to write the sector. <br>  The second is the function we need to call when reading a sector.  It fills in the data transmitted to it to the address (data) depending on the requested sector (sector). <br><br>  When reading a data sector pertaining to a file, the emfat module translates the sector number into the index of the file being read and the offset, and then calls the user‚Äôs callback read function.  The user, accordingly, gives a ‚Äúpiece‚Äù of a specific file.  Where it comes from the library is not interesting.  For example, in the project of the customer, I gave the configuration files from internal flash memory, other files from RAM and spi-flash. <br><br><h4>  Sample code </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usbd_msc_core.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usbd_usr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usbd_desc.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usb_conf.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"emfat.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AUTORUN_SIZE 50 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> README_SIZE 21 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ICON_SIZE 1758 const char *autorun_file = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"[autorun]\r\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"label=emfat test drive\r\n"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ICON=icon.ico\r\n"</span></span></span><span class="hljs-meta">; const char *readme_file = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"This is readme file\r\n"</span></span></span><span class="hljs-meta">; const char icon_file[ICON_SIZE] = { 0x00,0x00,0x01,0x00,0x01,0x00,0x18, ... }; USB_OTG_CORE_HANDLE USB_OTG_dev; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    emfat_t emfat; // callback    void autorun_read_proc(uint8_t *dest, int size, uint32_t offset, size_t userdata); void icon_read_proc(uint8_t *dest, int size, uint32_t offset, size_t userdata); void readme_read_proc(uint8_t *dest, int size, uint32_t offset, size_t userdata); //   static emfat_entry_t entries[] = { // name dir lvl offset size max_size user read write { "", true, 0, 0, 0, 0, 0, NULL, NULL }, // root { "autorun.inf", false, 1, 0, AUTORUN_SIZE, AUTORUN_SIZE, 0, autorun_read_proc, NULL }, // autorun.inf { "icon.ico", false, 1, 0, ICON_SIZE, ICON_SIZE, 0, icon_read_proc, NULL }, // icon.ico { "drivers", true, 1, 0, 0, 0, 0, NULL, NULL }, // drivers/ { "readme.txt", false, 2, 0, README_SIZE, README_SIZE, 0, readme_read_proc, NULL }, // drivers/readme.txt { NULL } }; // callback    "autorun.inf" void autorun_read_proc(uint8_t *dest, int size, uint32_t offset, size_t userdata) { int len = 0; if (offset &gt; AUTORUN_SIZE) return; if (offset + size &gt; AUTORUN_SIZE) len = AUTORUN_SIZE - offset; else len = size; memcpy(dest, &amp;autorun_file[offset], len); } // callback    "icon.ico" void icon_read_proc(uint8_t *dest, int size, uint32_t offset, size_t userdata) { int len = 0; if (offset &gt; ICON_SIZE) return; if (offset + size &gt; ICON_SIZE) len = ICON_SIZE - offset; else len = size; memcpy(dest, &amp;icon_file[offset], len); } // callback    "readme.txt" void readme_read_proc(uint8_t *dest, int size, uint32_t offset, size_t userdata) { int len = 0; if (offset &gt; README_SIZE) return; if (offset + size &gt; README_SIZE) len = README_SIZE - offset; else len = size; memcpy(dest, &amp;readme_file[offset], len); } //       ,     -   //   int main(void) { emfat_init(&amp;emfat, "emfat", entries); #ifdef USE_USB_OTG_HS USBD_Init(&amp;USB_OTG_dev, USB_OTG_HS_CORE_ID, &amp;USR_desc, &amp;USBD_MSC_cb, &amp;USR_cb); #else USBD_Init(&amp;USB_OTG_dev, USB_OTG_FS_CORE_ID, &amp;USR_desc, &amp;USBD_MSC_cb, &amp;USR_cb); #endif while (true) { } }</span></span></span></span></code> </pre><br>  Also the key part of the StorageMode.c module (USB MSC event handling): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> STORAGE_Read( <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> lun, <span class="hljs-comment"><span class="hljs-comment">// logical unit number uint8_t *buf, // Pointer to the buffer to save data uint32_t blk_addr, // address of 1st block to be read uint16_t blk_len) // nmber of blocks to be read { emfat_read(&amp;emfat, buf, blk_addr, blk_len); return 0; } int8_t STORAGE_Write(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len) { emfat_write(&amp;emfat, buf, blk_addr, blk_len); return 0; }</span></span></code> </pre><br><br><h4>  findings </h4><br>  To use Mass Storage in your project, it is not necessary to have a drive with a file system organized on it.  You can use the FS emulator. <br><br>  The library implements only basic functions and has several limitations: <br><ul><li>  No support for long names (only 8.3); </li><li>  The name must be in Latin lowercase. </li></ul><br>  Despite the limitations, I personally have enough functionality in the projects, but, depending on the demand, I allow the release of an updated version in the future. <br><br>  <a href="https://github.com/fetisov/emfat">Project repository</a> <br>  <a href="">Link to the project archive</a> </div><p>Source: <a href="https://habr.com/ru/post/247673/">https://habr.com/ru/post/247673/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247663/index.html">We program Arduino on pure C</a></li>
<li><a href="../247665/index.html">A drone based on the Raspberry Pi. Part 1</a></li>
<li><a href="../247667/index.html">Guide to the Car Tutorial (Unity3d) part 1 of 3</a></li>
<li><a href="../247669/index.html">Fast Data Recipe Based on Big Data Solution</a></li>
<li><a href="../247671/index.html">How to create a robotic startup: a textbook for the entrepreneur</a></li>
<li><a href="../247677/index.html">Calculate the average temperature at the hospital</a></li>
<li><a href="../247679/index.html">Qmpot - programmable sound editor</a></li>
<li><a href="../247681/index.html">Introduction to Distributed Switch Architecture: Network Management Technology as a Single Device</a></li>
<li><a href="../247683/index.html">Functions for solving quadratic comparisons. Implementation in MATLAB</a></li>
<li><a href="../247685/index.html">Online Arbitration or Arbitration Court on the Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>