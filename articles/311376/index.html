<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Authentication and authorization in microservice applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Author: Vyacheslav Mikhailov, Solutions Architect 

 This is an introductory piece of material based on a report I read last summer. Printed material ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Authentication and authorization in microservice applications</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/468/40f/d54/46840fd544d2494092b1855da29b3a32.png"><br>  <i>Author: Vyacheslav Mikhailov, Solutions Architect</i> <br><br>  This is an introductory piece of material based on a report I read last summer.  Printed material suggests more information, because  in one report it is usually not possible to talk about all the details. <br><br>  We will deal with the user authentication process, the work of the Single Sign-On technology (Single sign-on / SSO), we will give a general overview of OAuth2 technology and its principles, without going into particular technical implementation.  In the next article, as an example of successful implementation, we will look at the Thinktecture Identity Server v3 library; we‚Äôll discuss its functionality in more detail; let's talk about how to build the minimum set of components necessary for working in microservice architecture and worthy of use in a combat system.  In the third part, we will show how to expand this library, adjusting to the needs of your system, and will complete a series of articles reviewing various scenarios that many developers have met with recommendations for each case. <br><a name="habracut"></a><br><h1>  What is authentication? </h1><br>  The division of access rights is based on the authentication and authorization processes, without which no more or less serious application can do.  Therefore, to understand how they happened before and are happening now is very important, but before delving into the description of the technology, let's look at the key terms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Identification is the process of determining what kind of person is in front of us.  Authentication is the process of confirming that this person is exactly who he claims to be.  Authorization is the process of deciding what exactly this authenticated person is allowed to do.  That is, these are three different, consistent and mutually not replaceable concepts.  Identification is often implied as part of authentication.  The most important thing is to clearly distinguish between authentication and authorization. <br><br>  During the authentication process, we make sure that the person who came to us has proof of identity.  This article is mainly about authentication. <br><br><h1>  Authentication Methods </h1><br>  When using the HTTP protocol, the simplest authentication method is Basic access authentication.  In principle, this protocol is outdated and is rarely used on the Internet, especially in unprotected connections, but still remains in the intracorporate systems, simply because some of them have been created for a long time.  It is worth understanding how it works. <br><br><h2>  HTTP Basic Authentication </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/23a/fa1/dc4/23afa1dc47066c01e26406efaa5072f0.png" alt="Picture1"><br><br>  The first thing that, when accessing a protected resource, the server will give to a user who does not have access, will be error 401 Unauthorized.  The response also contains information about the type of authentication (in our case, Basic), which it can accept, and the context within which this authentication is valid (Realm).  The user enters a username and password, they are packaged in Base64 and sent to the server for verification.  There are various dangers here.  The most common is the threat of a man-in-the-middle attack, or a mediator attack, during which when using an unprotected connection, attackers can be intercepted by attackers at the time of transfer from the client to the server or vice versa. <br><br><h2>  HTTP Digest Authentication </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/3fa/2cc/54e/3fa2cc54e662f9cf0c48e24b869fa9c3.png"><br><br>  The next stage in the development of the technology was a slightly more complex HTTP digest authentication system, which eliminates the transfer of credentials in the clear form - here the MD5 hash with some impurities is used for verification, which avoids the selection of a login and password.  Of course, this algorithm looks more reliable, but it is also subject to a number of not very complicated attacks.  For example, <a href="http://resources.infosecinstitute.com/authentication-hacking-pt1/">here</a> you can read about attacks in more detail. <br><br><h2>  Forms Authentication </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/626/8fb/ab5/6268fbab585e76307c370d37d33088d3.png"><br><br>  Later, the Forms authentication process appeared, in which authentication occurs at a higher level of the abstraction model.  The HTTP server does not report an access error, but simply redirects the unauthenticated user to another page.  Usually this page displays the fields for entering a login and password, after filling in which a <em>POST</em> request with data is formed and is sent to the server via a secure channel.  The server side, in turn, returns the token to the user or the session identifier, which is stored in Cookies and later used to access the protected resource. <br><br><h2>  Token authentication </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/893/3cb/7ff/8933cb7ffab0879431fcc56b5d6bf47d.png"><br><br>  The next generation of authentication methods is Token Based Authentication, which is commonly used when building Single sign-on (SSO) systems.  When using it, the requested service delegates the function of validating user information to another service.  That is, the service provider trusts the delivery of the tokens necessary for access to the token provider itself (Identity provider).  This is what we see, for example, entering applications through accounts on social networks.  Outside IT, the simplest analogy of this process is using a civil passport.  The official document is the token issued to you - all state services by default trust the police department that handed it over, and considers the passport to be sufficient for your authentication throughout the entire validity period while maintaining its integrity. <br><br>  The diagram clearly shows how and in what sequence applications exchange information when using authentication by tokens. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c91/052/760/c9105276000186a491f20131c1e8ad5c.png"><br><br>  The following diagram additionally reflects the interaction stages in which the user is directly involved.  This moment is the disadvantage of such a scheme - we always need a user to access the resource. <br><img src="https://habrastorage.org/getpro/habr/post_images/8aa/2b5/6d4/8aa2b56d411886a0e5e37b6fcd091ab5.png"><br><br><h2>  OAuth2 &amp; Open ID Connect </h2><br>  Further improvement of the process was needed because token authentication requires the presence of the user at the time of accessing the protected resource.  Because the Identity provider, when transferring control to it, will interact with the user, requesting, for example, a login and password. <br><br>  In the case of a service that, on behalf of the user, must poll a certain third resource at certain intervals, say, access to the list of contacts in the social network, token-authentication will no longer work.  The fact is that session identifiers usually live for a very short time, so that if they are intercepted, attackers only get access to the service for a limited time.  But due to the short duration of the token is not enough, for example, on the night process. <br><br>  In 2006, in the course of working on the implementation of the Open ID protocol for Twitter, the need for a new open authorization protocol was discovered.  In 2007, Google and AOL engineers began working together on it, and in 2009, Twitter offered its users a solution that delegated access to accounts to third-party services and based on the OAuth protocol.  Three years later, a new version was published - OAuth 2, which simplified the development of client applications and received a number of new features, including the token update without user intervention.  Many services began to use this protocol even before its official approval. <br><br><h2><a name="whois"></a>  We understand in detail xy xy </h2><br>  At the moment, the following protocols are well known: <br><ol><li>  OpenID - to verify user credentials (identification &amp; authentication). </li><li>  OAuth is about accessing something. </li><li>  OpenID Connect - and about the one and the other at the same time. </li></ol><br>  All three protocols allow the user to not disclose their secret username and password to untrusted applications.  OpenID &amp; OAuth were developed in parallel until 2014 and eventually merged into OpenID connect. <br><br>  <a href="http://openid.net/specs/openid-authentication-1_1.html">OpenID 1.0</a> (2006) &amp; <a href="http://openid.net/specs/openid-authentication-2_0.html">OpenID 2.0</a> (2007) allowed the application (arb) to request from the trusted server (authority) user verification (user).  The differences between the versions are insignificant for us. <br><br><ul><li>  User -&gt; App: Hi, this is Misha. </li><li>  App -&gt; Authority: Here is ‚Äúthis‚Äù Misha? </li><li>  Authority and User communicate face to face. </li><li>  Authority -&gt; App: Yes, this is Misha. </li></ul><br>  <a href="http://openid.net/specs/openid-attribute-exchange-1_0.html">OpenID Attribute Exchange 1.0</a> (2007) extends OpenID 2.0 allowing you to retrieve and store a user profile. <br><br><ul><li>  User -&gt; App: Hi, this is Misha. </li><li>  App -&gt; Authority: Here is ‚Äúthis‚Äù Misha?  And if this is Misha, then send me his email. </li><li>  Authority and User communicate face to face. </li><li>  Authority -&gt; App: Yes, this is Misha.  And his email is <a href="">xxx@xxx.xxx</a> . <br></li></ul><br>  <a href="https://tools.ietf.org/html/rfc5849">OAuth 1.0</a> (2010) allows the user to allow an application to get limited access on third-party servers (trust servers) that trust the authentication center. <br><br><ul><li>  App -&gt; User: We would like to receive your pictures from another server. </li><li>  Authority and User communicate face to face. </li><li>  Authority -&gt; App: Here's a ticket (access token) for 15 minutes. </li><li>  App -&gt; Third-party server: We can get pictures for this user here with a ticket. </li></ul><br>  <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0</a> (2012) does the same thing as OAuth 1.0, but only the protocol has changed significantly and become simpler. <br><br>  <a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect</a> (2014) combines the capabilities of OpenID 2.0, OpenID Attribute Exchange 1.0, and OAuth 2.0 into one common protocol.  It allows applications to use a certification authority to: <br><ul><li>  Verify user credentials. </li><li>  Get user profile (or parts of it). </li></ul><br>  It is important to understand that OpenID Connect does not provide access to external resources.  It uses OAuth 2.0 to present profile parameters as if they were such resources. <br><br><h1>  Top view </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/2a9/8e8/d1a/2a98e8d1a542f955eb15c0bb7f4ffec4.png" alt="Picture7"><br><br>  Typically, systems have different components: users working through the browser, users interacting with the server through mobile applications, and just server applications that need data belonging to you, stored on other servers, which are accessed through the Web API. <br><br>  Single sign-on ‚Äî single sign-on technology ‚Äî allows the user to switch between different applications without re-authentication.  Using SSO, multiple logins can be avoided, so the user simply will not notice these switches.  At the same time, there are more than one such situations within your infrastructure where such applications occur.  Single sign-on technology is particularly useful in large enterprise systems consisting of dozens of applications that are loosely coupled.  It is unlikely that users will be satisfied by entering a username and password each time they access a time tracking system, corporate forum or internal document database. <br><br>  As an implementation, we consider the OAuth2 protocol.  In principle, there are others, for example, Kerberos, which successfully interacts with Windows, but in the case of a heterogeneous network in which there are computers using both Windows, and Mac, and UNIX systems, it is often inconvenient to use proprietary protocols.  Moreover, this applies to cases where access to your services through the web - here OAuth2 is the best candidate. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc9/ad8/618/bc9ad86182b31533cc26413abc67924f.png" alt="Picture8"><br><br>  The figure above shows which protocols are used for each type of interaction. <br><p>  As we know from the section ‚Äúwe <a href="https://habr.com/ru/company/dataart/blog/311376/">understand in detail xy from xy</a> ‚Äù, OpenID onnect is needed to get the user credentials from the user and check them.  OAuth 2.0 is needed to get access tokens and access resources with them. <br><br></p><h1>  OAuth2 &amp; OpenID Connect Terminology </h1><br><ul><li>  OpenID Connect Provider (OP) </li><li>  Client </li><li>  User </li><li>  Scope <br><ul><li> Identity scopes - openid, profile, email </li><li>  Resource scopes - various API </li></ul><br></li><li>  Authentication / Token Request </li><li>  Identity token </li><li>  Access token </li><li>  Refresh token </li></ul><br><h2><a name="sts"></a>  Token issuance service </h2><br>  Open ID Connect Provider is the most important object of the whole design of a centralized authentication service, it can also be called Security Token Service, Identity Provider authorization server, etc. Different sources call it differently, but in the sense it is a service that issues tokens to customers. <br><br>  Main functions: <br><ul><li>  Authenticate users using internal user storage or an external source (for example, Active Directory). </li><li>  Manage customers (store) and authenticate them. </li><li>  Provide session management and the ability to implement Single sing-on. </li><li>  Issue identity tokens and access tokens to clients. </li><li>  Check previously issued tokens. </li></ul><br><h2>  Customer </h2><br>  Client - a device or program (browser, application) that needs either a token to authenticate a user, or a token to access a resource (it is assumed that this resource is ‚Äúfamiliar‚Äù with the specific ‚Äú <a href="https://habr.com/ru/company/dataart/blog/311376/">Security Token Service</a> ‚Äù from which the client requests a token for access). <br><br><h2>  User </h2><br>  User - actually the end user - the person. <br><br><h2><a name="scope"></a>  Scope </h2><br>  Scope - the identifier of the resource to which the client wants to access.  The scope list is sent to the <a href="https://habr.com/ru/company/dataart/blog/311376/">token issuing service</a> as part of <a href="https://habr.com/ru/company/dataart/blog/311376/">the authentication request</a> . <br><br>  By default, all clients have the ability to request any areas, but this can (and should) be limited in the configuration <a href="https://habr.com/ru/company/dataart/blog/311376/">of the token issuing service</a> . <br><br>  Scopes come in two forms: <br><br><ol><li>  Identity scopes is a request for information about a user.  His name, profile, gender, photo, email address, etc. </li><li>  Resource scopes - the names of external resources (Web APIs) that the client wants to access. </li></ol><br><h2><a name="authrequest"></a>  Authentication Request </h2><br>  Authentication / Token Request is an authentication request process. <br><br>  Depending on which <a href="https://habr.com/ru/company/dataart/blog/311376/">areas (scopes) are</a> requested, the <a href="https://habr.com/ru/company/dataart/blog/311376/">service for issuing tokens</a> will return: <br><ol><li>  Only Identity Token if only Identity scopes is requested. </li><li>  Identity Token and Access Token if Resources scopes is also requested. </li><li>  Access Token and Refresh Token if Offline Access is requested. </li></ol><br>  You can read more about the authentication process in the ‚Äúauthentication <a href="https://habr.com/ru/company/dataart/blog/311376/">process</a> ‚Äù section. <br><br><h2><a name="identitytoken"></a>  Personality token </h2><br>  Identity Token - authentication confirmation.  This token contains the minimum set of user information. <br><br><h2><a name="accesstoken"></a>  Access token </h2><br>  Access Token - information that a specific user is allowed to do.  The client requests Access Token and then uses it to access resources (Web APIs).  Access Token contains information about the client and user, if present.  It is important to understand that there are such types of authorization, in which the user is not directly involved in the process (more on this in the next part) <br><br><h2><a name="refreshtoken"></a>  Update token </h2><br>  Refresh Token - the token by which the STS will return the new Access Token.  Depending on the mode of operation, Refresh Token can be reusable and disposable.  In the case of a one-time token, when requesting a new Access Token, a ready-made Refresh Token will also be generated, which should be used when re-updating.  Obviously, one-time tokens are safer. <br><br>  For more information about the composition of tokens in the section " <a href="https://habr.com/ru/company/dataart/blog/311376/">token structure</a> ". <br><br><h1><a name="authprocess"></a>  Authentication process </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/c13/afc/ee5/c13afcee5226ddb135df9836d3321b17.png" alt="Picture9"><br><br>  When a user accesses the client, he redirects the user to the Open ID Connect Provider, which prompts the user for a username and password.  If the verification of the authentication parameters is successfully passed, it returns back the <a href="https://habr.com/ru/company/dataart/blog/311376/">identity token</a> and <a href="https://habr.com/ru/company/dataart/blog/311376/">access token</a> with which the user can access the protected resource. <p></p><br><br><h1><a name="tokenstructure"></a>  Token structure </h1><br><h2>  Format </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/27d/f7e/0a3/27df7e0a35dc2e8c48833646beff13b9.png" alt="Picture10"><br><br>  The OAuth2 implementation uses a so-called jwt-token, which consists of three parts.  For example, when accessing the Identity provider, you send a login / password and receive a token in return.  It will include: Header (title), Payload (content) and Signature (signature).  On the website <a href="http://jwt.io/">jwt.io</a> you can decode it and view the contents of the JSON format.  On this site you will also find a description of the rules for the formation of jwt-tokens. <br><br>  The fact that tokens in the exchange process are transmitted unencrypted, there is nothing terrible.  We initially proceed from the assumption that communication takes place over a secure HTTPS channel, and re-encryption of the token would be redundant.  The only thing we need to make sure is that the token has not been changed or falsified on the client side, for this it is enough to have a signature and check it on the server.  In addition, the token does not contain any critical information. <br><br>  In addition to identity tokens, there is also access tokens, which contain information about the stamps issued to the user.  The duration of access token is quite short, because its theft can provide unauthorized access to the resource.  That is, an attacker, if he manages to get a token of this type, will receive access for a very short time.  To obtain a new access token, use the refresh token, which usually does not appear in unprotected environments, in particular, in the access mode from the browser, it is not used at all.  What kind of tokens will be returned to the client in the authentication process, let's look at the next part. <br><br><h2>  Primary Fields </h2><br>  Let us briefly discuss what standard fields in the token are and why they are needed: <br><br><ul><li>  iss is the address or name of the certification authority. </li><li>  sub - user ID.  Unique within the certification center, at least. </li><li>  aud is the client name for which the token is issued. </li><li>  exp - the validity of the token. </li><li>  nbf is the time from which it can be used (not earlier than). </li><li>  iat - time to issue a token. </li><li>  jti - unique identifier of the token (needed so that the token cannot be ‚Äúreleased‚Äù a second time). </li></ul><br><h1>  Conclusion of the first part </h1><br>  In this article we have tried to give a theoretical and terminological foundation that we will need to create a working solution in the following articles. <br><br>  Stay tuned. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler second part</b> <div class="spoiler_text">  The minimal implementation of integrating the Identity Server into your application looks like this: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAppBuilder app</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IdentityServerServiceFactory(); factory.UseInMemoryClients(Clients.Get()) .UseInMemoryScopes(Scopes.Get()) .UseInMemoryUsers(Users.Get()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> options = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IdentityServerOptions { SiteName = Constants.IdentityServerName, SigningCertificate = Certificate.Get(), Factory = factory, }; app.UseIdentityServer(options); }</code> </pre> <br><br>  Minimal implementation of web client integration with Identity Server: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAppBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseCookieAuthentication(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CookieAuthenticationOptions { AuthenticationType = <span class="hljs-string"><span class="hljs-string">"Cookies"</span></span> }); app.UseOpenIdConnectAuthentication(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OpenIdConnectAuthenticationOptions { ClientId = Constants.ClientName, Authority = Constants.IdentityServerAddress, RedirectUri = Constants.ClientReturnUrl, ResponseType = <span class="hljs-string"><span class="hljs-string">"id_token"</span></span>, Scope = <span class="hljs-string"><span class="hljs-string">"openid email"</span></span>, SignInAsAuthenticationType = <span class="hljs-string"><span class="hljs-string">"Cookies"</span></span>, }); }</code> </pre><br>  Minimal implementation of web API integration with Identity Server: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAppBuilder app</span></span></span><span class="hljs-function">)</span></span> { app.UseIdentityServerBearerTokenAuthentication( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IdentityServerBearerTokenAuthenticationOptions { Authority = Constants.IdentityServerAddress, RequiredScopes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"write"</span></span> }, ValidationMode = ValidationMode.Local, <span class="hljs-comment"><span class="hljs-comment">// credentials for the introspection endpoint ClientId = "write", ClientSecret = "secret" }); app.UseWebApi(WebApiConfig.Register()); }</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/311376/">https://habr.com/ru/post/311376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311352/index.html">New PostgreSQL 9.6 Release: Postgres Professional Contributions</a></li>
<li><a href="../311354/index.html">About degrees of freedom in statistics</a></li>
<li><a href="../311366/index.html">Will the formal verification of a microkernel code allow creating super-reliable OS?</a></li>
<li><a href="../311368/index.html">How not to do the network</a></li>
<li><a href="../311374/index.html">The results of the summer internship at Digital Security. Department of research</a></li>
<li><a href="../311378/index.html">Moderate usability testing</a></li>
<li><a href="../311380/index.html">Formation of web-studio products: hours, dates, profitability</a></li>
<li><a href="../311384/index.html">Announcement Rust 1.12</a></li>
<li><a href="../311388/index.html">Features of ProxyChanging software in Android. Part 1: From Jelly Bean to Lollipop</a></li>
<li><a href="../311390/index.html">The story of one obsession, or as I wrote a calendar script for Photoshop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>