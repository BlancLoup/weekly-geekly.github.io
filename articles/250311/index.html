<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Very fast JavaScript classes with nice syntax</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When writing serious projects before JavaScript programmers have a choice: to sacrifice the quality of the code and write classes with their hands, or...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Very fast JavaScript classes with nice syntax</h1><div class="post__text post__text-html js-mediator-article">  When writing serious projects before JavaScript programmers have a choice: to sacrifice the quality of the code and write classes with their hands, or sacrifice speed and use the class system.  And if you use the system, which one to choose? <br><br>  The article describes the author‚Äôs system, which is not inferior in speed to classes written ‚Äúby hand‚Äù (in other words, one of the fastest in the world).  But at the same time classes have a pleasant structure in the style of C. <br><br><h4>  Class systems </h4><br>  There is a joke that every programmer should write his own class system.  Who is not familiar with the problem - see <a href="http://habrahabr.ru/post/132698/">this comment</a> , there are at least 50 of them collected. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Each of these bikes differs in its set of features, its programming style and its drop in speed.  For example, creating a class MooTools is about 90 times slower than creating a class written by hand.  Why then do we need all these systems? <br><a name="habracut"></a><br>  In practice, it turns out that handwritten classes are very hard to maintain.  When your JS application grows to a decent size, the prototypes will no longer be as "cool" as before, and you will probably think: it may be worth sacrificing performance a little, but it will be easier for people to work with it.  Imagine, for example, what Ext.JS would look like, written on prototypes. <br><br>  Note: some serious projects still do not use the class system, and it does not seem to suffer much from this.  As an example - see the source code Derby.js.  But I perceive Derby as a black box that does something for you, so the developers do not strongly encourage digging into its guts (correct, if not right);  and in Ext, inheritance is quite the opposite. <br><br><h5>  System Benefits </h5><br>  What do we want from the system?  First of all, it is a call to parent methods.  Here is an example from MooTools: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Cat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class({ <span class="hljs-attr"><span class="hljs-attr">Extends</span></span>: Animal, <span class="hljs-attr"><span class="hljs-attr">initialize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, age</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent(age); <span class="hljs-comment"><span class="hljs-comment">//    } });</span></span></code> </pre> <br>  At first it looks very nice: inside any function you have a parent method.  And refactoring is convenient - if you rename the method, then the call of the parent will not break.  But for the beauty and convenience you have to pay a big price - every method in the class will be wrapped in such a terrible package: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrapper = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (method.$protected &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$caller == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'The method "'</span></span> + key + <span class="hljs-string"><span class="hljs-string">'" cannot be called.'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> caller = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.caller, current = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$caller; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.caller = current; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$caller = wrapper; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = method.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$caller = current; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.caller = caller; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }.extend({<span class="hljs-attr"><span class="hljs-attr">$owner</span></span>: self, <span class="hljs-attr"><span class="hljs-attr">$origin</span></span>: method, <span class="hljs-attr"><span class="hljs-attr">$name</span></span>: key});</code> </pre><br>  It strongly interferes with debugging, not to mention the fact that it is very slow - this code will be executed when any method of the class is called. <br><br>  What else is critically important?  Each class instance must have its own properties: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Cat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class({ <span class="hljs-attr"><span class="hljs-attr">food</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">initialize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cat1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cat2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cat(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   cat1.food.push(''); cat2.food.length == 0; //  </span></span></code> </pre><br>  As you can see, MooTools created its own food array for each class.  How would all this be done with the traditional approach?  We would assign the properties in the constructor: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.food = []; Cat.superclass.constructor.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } Cat.prototype.meow = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>}</code> </pre><br>  As for the methods, there are several options; in the example above, a variant with the Douglas Crockford extend function is shown.  With a traditional system in the code, a lot of garbage like ‚ÄúCat.prototype ...‚Äù and ‚Äúsuperclass.constructor.call (this ...)‚Äù, such code is hard to perceive and refactor. <br><br><h5>  A few words about private class members </h5><br>  What is absolutely normal in C ++ is very harmful in JavaScript.  I say this from my experience: if classes have private methods and variables, then such classes often become unsupported.  If you want to change something in such a piece of code, then sometimes you have nothing left but to throw away the old code and rewrite everything from scratch. <br><br>  Private members are bad practice.  It is correct to have protected members (the name begins with "_"), and if you are afraid that some monkey will start to get them from the outside, then this is his business.  Then it turns out that you hide them from the programmer who will inherit your class.  Perhaps this is your goal, but most often private members do not solve anything, they only complicate the class and create problems for adequate programmers. <br><br>  Now let's create a class system that is as convenient as C ++, but as fast as handwritten classes.  And to work without preprocessors. <br><br><h4>  We write fast classes </h4><br>  So, the fastest way to create a class in JS is to write it with your own hands, using prototypes: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Animal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} Animal.prototype.init = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}</code> </pre><br>  All browsers engines are optimized for this method.  Step aside - and get a performance drop, for example: <br><br><pre> <code class="javascript hljs">Animal.prototype = { <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }</code> </pre><br>  In this example, the prototype was assigned as an object.  Chrome is eating normally, but in Firefox the speed of creating classes drops significantly. <br><br><h5>  Fast inheritance </h5><br>  Now we need to call parent methods.  Is there anything faster than a prototype chain?  And let's just rename the parent method in the heir class! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cat</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-comment"><span class="hljs-comment">//  Animal Cat.prototype.Animal$init = Animal.prototype.init; Cat.prototype.init = function() { this.Animal$init(); //    }</span></span></code> </pre><br>  We copied the method from the prototype of the parent, and at the same time renamed it.  Faster is simply impossible.  Of course, we will not do it with our hands - the class system will do everything for us. <br><br>  In this example, the instanceof operator will not work, but in practice you can do fine without it.  I'm talking about real applications and tasks: if you need to distinguish the Animal type from the Cat, then this is a real task, and it is perfectly solved.  But if you want to do this with the instanceof operator, then excuse me, you go to another doctor. <br><br>  Even with this inheritance, there is no chain of prototypes (since the prototypes are copied) - this gives a slight acceleration compared to traditional solutions. <br><br><h5>  Convenient properties </h5><br>  Assigning the default properties in the constructor with your hands is also not very pleasant.  So, let the script do it for us, as in MooTools.  How it will work: the class system itself will generate a constructor function that will assign default properties.  It will look like this: <br><br><pre> <code class="javascript hljs">ClassManager.define( <span class="hljs-string"><span class="hljs-string">'Cat'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">Extends</span></span>: <span class="hljs-string"><span class="hljs-string">'Animal'</span></span>, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Animal$init(); } });</code> </pre><br>  As a result, we get: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   function Cat() { this.food = []; this.init.apply(this, arguments); } //      Cat.prototype.Animal$init = Animal.prototype.init; Cat.prototype.init = init: function() { this.Animal$init(); }</span></span></code> </pre><br>  Overridden parent methods are renamed according to this rule: <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">__</span></span></span><span class="hljs-tag">&gt;</span></span> + "$" + <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">_</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  This syntax is the least that we paid for speed, and in practice it does not cause any inconvenience.  And the classes themselves are nice debazhit, and nice to look at. <br><br><h4>  Classmanager </h4><br>  Now a little PR of my decision.  Speed ‚Äã‚Äãtest, ClassManager vs Native ( <a href="http://jsperf.com/liquidlava-class-system-performance/10">link to jsperf</a> ): <br><br><img src="https://habrastorage.org/files/3a3/4b9/774/3a34b977425e41e5855833cb3d5c1fed.png"><br><br>  The difference in the speed of creating classes can be attributed to the error jsperf (on the old charts, it is the same for all test variants).  For your information: in practice, I happened to have the same code running as 2 different tests ‚Äî it was executed with a 20% speed difference. <br><br>  Why the call to the Native method is so slow - it says: <br><br><pre> <code class="javascript hljs">NativeChildClass.prototype.method = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ NativeParentClass.prototype.method.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  Immediately noticeable difference in speed between the call from its own prototype and through apply.  If it seems to you that I counted here - then write your own tests, it will not be faster anyway. <br><br>  Separately, it‚Äôs worth mentioning Firefox: creating a class that is generated in the browser is now much slower (on my old laptop, only 400,000 operations per second).  But my ClassManager allows me to collect classes on the server - and in FF they work even faster than Native.  In addition, it will speed up page loading. <br><br><h5>  ClassManager vs other systems </h5><br>  I took the test of the author of DotNetWise as a basis, but ... his test is despicable: he is testing class generation plus 500 iterations of methods.  As you understand, the quality and speed of the generated code do not depend on the time of its generation, and for each tested framework this time introduces its own error.  Moreover, my classes can be collected on the server. <br><br>  So it will be much more fair to create classes first, and then test them.  And if you need to compare the time of class generation, then it will be right to create a separate test for this, and not to mix it with the speed of calling methods. <br><br>  In the original test - the author's system DNW, of course, leads.  But if you fix the test, then in Chrome in the first place will be my ClassManager, followed by Fiber, and then DNW.  In FF, TypeScript comes first, then Native, then ClassManager.  Even so, this is a very specific test - here the creation of a class is measured along with the call of methods (in the wrong proportions), so I believe that it does not reflect the real picture.  However, <a href="http://jsperf.com/js-inheritance-performance/62">here is the link</a> and the results: <br><br><img src="https://habrastorage.org/files/c93/776/4d1/c937764d133b49548792c9a8bb31f362.png"><br><br><h4>  ClassManager features </h4><br>  I'll start with a very important detail: IDE hints work for my classes!  At least in most cases (I use PhpStorm).  Here is an example of what classes might look like: <br><br><pre> <code class="javascript hljs">Lava.ClassManager.define( <span class="hljs-comment"><span class="hljs-comment">//      ,   'Lava.Animal', { //   on(), _fire()   Extends: 'Lava.mixin.Observable', //   : // Implements: 'Lava.mixin.Observable', name: null, toys: [], //    -   init: function(name) { this.name = name; }, takeToy: function(toy) { this.toys.push(toy) } }); Lava.ClassManager.define( 'Lava.Cat', { Extends: 'Lava.Animal', //   ,      Shared: ['_shared'], //      ,       _shared: { likes_food: ['', ''] }, breed: null, init: function(name, breed) { this.Animal$init(name); this.breed = breed; }, eat: function(food) { if (this._shared.likes_food.indexOf(food) != -1) { //  ,   Lava.mixin.Observable this._fire('eaten', food); } } }); var cat = new Lava.Cat('', ''); //   -     Lava.mixin.Observable cat.on('eaten', function(garfield, food) { console.log('  ' + food); }, {}); cat.eat(''); //    "  "</span></span></code> </pre><br><br>  Standard Directives: <br><ol><li>  Extends - direct inheritance.  A descendant can be inherited from only one parent. </li><li>  Implements - for mixins and multiple inheritance.  The properties and methods from the mixin retain their descendant, but everything that is redefined in the class takes precedence. </li><li>  Shared - takes the object to the prototype.  By default, all objects in the body of the class are copied for each instance, but they can be shared. </li></ol><br>  Bonuses: <br><ol><li>  There is the possibility of patching class methods on the fly and static constructors.  For example, you want to apply the bugfix inside IE, and disable it in other browsers.  In the class constructor, you can select the method you need and replace it in the prototype - even if your class is in the middle of the inheritance chain. </li><li>  Export generated classes.  You can generate constructors on the server - this will save page load time and speed up the creation of objects in Firefox. </li><li>  Namespaces and packages.  Read the documentation for details. </li></ol><br>  There are plans to add modifiers such as abstract and final. <br><br>  Disadvantages: <br><ol><li>  Now the Shared directive can only transfer objects to the prototype (not arrays).  As a temporary solution, you can create an object with an array property, so this is just a slight inconvenience.  There is a task for revision, but it is not yet a priority. </li><li>  And a more noticeable flaw: there is currently no tool that could compress the names of class members (if you simply rename them, the call to the parent methods will break).  There are plans to create it, it will definitely appear, but not tomorrow.  <i>Interestingly, if I didn‚Äôt tell about it myself, would you pay attention to it?</i> </li></ol><br><h5>  Where to get? </h5><br>  The standalone version lies in <a href="https://github.com/kogarashisan/ClassManager">this repository</a> .  It also contains a link to the site of the main framework - there you will find excellent documentation (in English), there you can also see examples in the code, and take several universal classes like Observable (events), Properties (properties with events) and Enumerable (‚Äúlive ¬ªArray). <br><br>  PS <br>  By the way: the main framework is called LiquidLava, and it was created as the best alternative to Angular and Ember.  Interesting? <br><br>  <b>UPD</b> <br>  In the comments I was fixed: the speed of calling the Native method can be increased by replacing apply with call.  The first test of ClassManager vs Native was updated: in FF, the speed of calling the Native method equaled the speed of ClassManager, and in Chrome it is still slightly inferior. </div><p>Source: <a href="https://habr.com/ru/post/250311/">https://habr.com/ru/post/250311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250293/index.html">10 skills needed today for an embedded system developer (free translation with comments)</a></li>
<li><a href="../250299/index.html">Social casual</a></li>
<li><a href="../250303/index.html">I want ThinkServer: your idea is our iron</a></li>
<li><a href="../250305/index.html">Seven Lessons I Learned from Mozilla by David Walsh</a></li>
<li><a href="../250309/index.html">Four short polls on data center</a></li>
<li><a href="../250313/index.html">What and why are they looking for on the sites ‚Äúbots of the dark side of power‚Äù</a></li>
<li><a href="../250315/index.html">Microsoft released a set of updates for its products, February 2015</a></li>
<li><a href="../250319/index.html">Eliminate spaces, learn Android</a></li>
<li><a href="../250321/index.html">Programming on PureData. Part 0</a></li>
<li><a href="../250323/index.html">Debugging with XDebug and PhpStorm (addition)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>