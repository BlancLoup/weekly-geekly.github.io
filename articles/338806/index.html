<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Loading OS on ARM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently asked to briefly tell serious people about loading the operating system on the ARM and assess the security threats to this process. In genera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Loading OS on ARM</h1><div class="post__text post__text-html js-mediator-article">  Recently asked to briefly tell serious people about loading the operating system on the ARM and assess the security threats to this process.  <i>In general, ARM-processors and OS in general</i> .  You understand, everyone has heard about these ARMs, and everyone also knows what the OS is.  It is desirable at the level of small squares with arrows. <br><br>  Download ARM in four rectangles - under the cut. <br><a name="habracut"></a><br>  Immediately limit the level of detail.  We are interested in <i>what is</i> happening, and not <i>how</i> , that is, we will set aside specific instructions of the processor.  We will try to find a common for all processors and all operating systems.  Look for security threats. <br><br><h2>  Varieties of ARM processors </h2><br>  If you know about ARM, then this section can be safely skipped. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the production and operation now there are ARM processors of five architectures: ARMv4, ARMv5, ARMv6, ARMv7 and ARMv8.  The ARM company gives these architectures commercial names, therefore ARMv4 is called, for example, ARM7, ARMv5 is ARM9, and the name Cortex has processors on ARMv6, v7, v8 architectures.  The following table lists the main varieties. <br><table><tbody><tr><td>  Architecture </td><td>  Commercial name </td><td>  Common species </td><td>  Run Linux </td></tr><tr><td>  ARMv4 </td><td>  ARM7 </td><td>  ARM7TDMI </td><td>  Impractical </td></tr><tr><td>  ARMv5 </td><td>  ARM9 </td><td>  ARM926EJ-S </td><td>  Yes </td></tr><tr><td>  ARMv6 </td><td>  ARM11 </td><td>  ARM1176JZF-S </td><td>  Yes </td></tr><tr><td></td><td>  Cortex-M0 </td><td>  Cortex-M0 </td><td>  Not </td></tr><tr><td>  ARMv7 </td><td>  Cortex-m </td><td>  Cortex-M3 </td><td>  Impractical </td></tr><tr><td></td><td>  Cortex-a </td><td>  Cortex-A9 </td><td>  Yes </td></tr><tr><td></td><td>  Cortex-R </td><td>  Cortex-R4 </td><td>  Yes </td></tr><tr><td>  ARMv8 </td><td>  Cortex-a </td><td>  Cortex-A53 </td><td>  Yes </td></tr></tbody></table><br>  For example, push-button telephones mostly use ARM7, and smartphones use Cortex-A.  Modern smartphones are built primarily on ARMv8, the only 64-bit.  The ARM7 and ARM9 processors were widely used in various industrial controllers, network equipment, and now the focus is shifting to using Cortex-A in them.  In various household appliances, small electronic devices, in the field of safety, etc.  Cortex-M microcontrollers are used. <br><br>  In general, all ARM devices can be conditionally divided into microcontrollers and the Application Processor. <br><br><ul><li>  Microcontrollers are distinguished by the presence of flash memory and working RAM on a chip.  Used for tasks related to small automation. <br></li><li>  Application Processor primarily uses external memory - DDRAM and Flash.  We will continue to call them simply - processors.  The scale of their tasks is greater. </li></ul><br>  For a long time, the same ARM7, ARM9 architectures were used both for building processors and microcontrollers.  With the advent of the Cortex line, separation occurred, and now the microcontrollers are called Cortex-M, and the Cortex-A and Cortex-R processors. <br><br><h2>  Types of OS </h2><br>  What are the options for running the OS: <br><br><ul><li>  microcontrollers usually run a small real-time OS (RTOS) or just a program without an OS; <br></li><li>  On processors, a common use OS (Linux, Android) is often launched, sometimes a small RTOS, sometimes a full-featured RTOS (such as vxWORKS). </li></ul><br>  For example, tablets and smartphones use Android, iOS, or the Linux variant.  Telecommunications equipment can be Linux or one of the variants of RTOS.  In more simple equipment, RTOS or a non-OS program can be used. <br><br>  In the future, we will only talk about the launch of the OS (Linux, Android) or RTOS on ARM.  By the way of launching, the ‚Äúbig‚Äù RTOSs fall into the same group with Linux, and the ‚Äúsmall‚Äù RTOSs are combined with the programs without OS. <br><br>  ARM9, ARM11, Cortex-A processors are well suited to run Linux.  A truncated version of Linux can also be downloaded to ARM7, Cortex-M4 and Cortex-M7, but this is not appropriate. <br><br>  Microcontrollers and processors ARM7, ARM9, Cortex-M are suitable for running small RTOS.  In some cases, initial models of Cortex-A, for example, Cortex-A5, are used for RTOS.  Most Cortex-A processors are so complex that their capabilities can only be used in conjunction with the Linux / Android SDK supplied by the manufacturer, which determines the choice in favor of Linux. <br><br><h2>  OS loader </h2><br>  From the point of view of the developer, the system software of the device is divided into the boot loader and the OS.  The main function is always performed by a program running under OS or RTOS. <br><br>  The loader provides OS booting and service functions, such as: <br><br><ul><li>  check the integrity of the OS image before launch; <br></li><li>  software update; <br></li><li>  service functions, initial initialization functions of the device; <br></li><li>  self test </li></ul><br>  In the case of RTOS, the bootloader is often written by the device developer and is a small specialized program.  In the case of general-purpose operating systems, open source loaders are widely used, for example, u-boot. <br><br>  Thus, from the point of view of the product developer, the launch of the OS is as follows: <br><br><div style="text-align:center;"><img width="600" hspace="5" src="https://habrastorage.org/webt/59/ca/63/59ca634e149ee313874728.png"></div><br>  Here the // sign indicates the moment of power supply or processor reset.  Such an easy way to run was some processors ARM7.  In subsequent versions, the launch process is more difficult in <i>reality</i> than in the diagram above, but for the developer of the final solution, this is usually not essential. <br><br>  The ‚ÄúLoader-OS‚Äù scheme is very convenient for practical reasons, because the loader takes over all the low-level work: <br><br><ul><li>  initializes the memory before starting the OS and loads the OS kernel into the memory; <br></li><li>  initializes part of the periphery; <br></li><li>  often implements the storage of two OS images: current and backup, or an image for recovery; <br></li><li>  controls the OS image before loading; <br></li><li>  gives a service mode even with a damaged OS image. </li></ul><br>  For example, to run Linux on ARM, the loader must initialize the memory, at least one terminal, load the kernel image and Device Tree into memory and transfer control to the kernel.  All of this is described in &lt; <a href="https://www.kernel.org/doc/Documentation/arm/Booting">https://www.kernel.org/doc/Documentation/arm/Booting</a> &gt;.  The Linux kernel initialization code will not do what the loader should do. <br><br>  At the same time, the bootloader is often weakly protected or not protected at all.  In most home routers, just open the lid and connect to the UART connector to enter the bootloader control menu.  In higher-class telecommunications equipment, entry to the bootloader menu is often possible by an undocumented key combination or by pressing a button when the device is turned on.  In other words, often the loader is not protected from a local intruder. <br><br>  Consider the work of the bootloader on the example of u-boot, loading Linux, step by step. <br><br><ol><li>  After powering on or resetting, the processor loads the u-boot image stored in Flash memory into RAM and transfers control to the first command of this image. <br></li><li>  The u-boot initializes DDRAM. <br></li><li>  The u-boot initializes bootable media (EAN) drivers, for example, eMMC, NAND Flash. <br></li><li>  The u-boot reads from the EIT a region of variable configurations.  In the configuration, the boot script is set, which u-boot then executes. <br></li><li>  U-boot displays in the console a suggestion to interrupt the boot process and configure the device.  If the user does not do this in 2-3 seconds, the download script runs. <br></li><li>  Sometimes the script begins by searching for a suitable OS image to load on all available media.  In other cases ZN is set in the script hard. <br></li><li>  The script loads the Linux kernel image (zImage), the Device Tree file with the kernel parameters (* .dtb) from ZN to DDRAM. <br></li><li>  In addition, the script can load into the DDRAM an image of the initrd - a small file system with the necessary device drivers to start.  Modern Linux distributions sometimes use initrd, and sometimes not. <br></li><li>  Placing the loaded 2 or 3 files in memory, the script transfers control to the first command of the zImage image (Linux kernel). <br></li><li>  zImage consists of a unpacker and a compressed kernel image.  The unpacker deploys the kernel in memory and the OS starts. </li></ol><br><h2>  Bootloader run - preloader </h2><br>  However, in reality, it almost never happens that the loader commands are executed first after powering on or resetting the processor.  It was still on the ARM7 processors, but almost never met further. <br><br>  Any core of the ARM processor, when reset, begins execution at address 0, where the ‚Äúreset‚Äù vector is recorded.  The old series of processors literally started to boot from external memory displayed at zero address, and then the first processor command was a command loader.  However, only parallel NOR Flash or ROM is suitable for such loading.  These types of memory work very simply - when submitting an address, they give out data.  A typical example of parallel NOR Flash is a BIOS microchip in personal computers. <br><br>  In modern systems, other types of memory are used, because they are cheaper and the volume is larger.  This is NAND, eMMC, SPI / QSPI Flash.  These types of memory no longer work according to the principle: I submitted an address ‚Äî you read the data, which means that they are not suitable for direct execution of commands.  Even for a simple reading, you need to write a driver here, and we have a ‚Äúchicken and egg‚Äù problem: you need to load the driver from somewhere in advance. <br><br>  For this reason, ROM is integrated with a preloader in modern ARM processors.  The ROM is mapped in processor memory to address 0, and it is from it that the processor begins execution of instructions. <br><br>  The preloader tasks include the following: <br><br><ul><li>  determining the configuration of the connected devices; <br></li><li>  definition of bootable media (MN); <br></li><li>  device initialization and MN; <br></li><li>  reading the bootloader from the OS; <br></li><li>  transfer control loader. </li></ul><br>  The preloader configuration is usually installed in one of two ways: <br><br><ul><li>  circuit design, by connecting specific pins of the processor to the ground or power bus; <br></li><li>  written to the one-time programmable processor memory at the production stage. </li></ul><br>  In general, it is almost always possible to specify a single boot option or the main one and several alternative ones.  At the same time, among the alternatives there may be an initial download via USB or a serial port, which is very convenient during initial initialization in production. <br><br>  Such a preloader is installed in ARM processors, such as the Cortex-A, and in microcontrollers, even small ones like the Cortex-M0.  Together with the preloader, the OS startup procedure looks like this: <br><div style="text-align:center;"><img width="600" hspace="5" src="https://habrastorage.org/webt/59/ca/63/59ca634e1a54f538952135.gif"></div><br><h2>  Threat analysis at this stage </h2><br>  The source code of the preloader is written by the processor manufacturer, not by ARM, is part of the chip as a product of the manufacturer and is protected by copyright.  For example, in the Atmel and NXP ARM processors, the preloaders are written, respectively, by Atmel and NXP. <br><br>  In some cases, the preloader can be read from ROM and analyzed, but sometimes access to it is limited.  For example, the pre-loader of the Cypress Psoc4000 series processor was covered with several layers of protection (but was <a href="http://dmitry.gr/index.php%3Fr%3D05.Projects%26proj%3D23.%2520PSoC4">hacked by a talented hacker</a> ). <br><br>  Using a preloader in most scenarios cannot be avoided.  You can consider it as a version of the BIOS, which is not in ARM-systems. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  In fact, ARMv8-A has ARM Trusted Firmware, this is system software that is responsible, for example, for power management (PSCI).  This code can be considered as BIOS for ARMv8.  ARMv7 and earlier have no such standard software. </div></div><br>  By itself, a preloader in ROM carries the risk of disrupting the order of loading and executing arbitrary code.  But after control is transferred to the OS loader, the preloader is already harmless.  We can simply not transfer control to it, reconfigure all interrupt handlers, and so on. <br><br>  In some small microcontrollers, manufacturers integrate into ROM libraries for working with peripheral devices that need to be called up throughout the microcontroller's work.  In this case, the system software (bootloader and OS) itself periodically transfers control somewhere to the preloader area, and the control transfer scheme is obtained as follows: <br><div style="text-align:center;"><img width="600" hspace="5" src="https://habrastorage.org/webt/59/ca/63/59ca634e3318c392769902.png"></div><br>  This is generally unsafe, but is found only in some microcontrollers on the ARM architecture.  Such microcontrollers usually run programs without an operating system or small RTOS, and the system designer can assess the risks. <br><br><h2>  Download from TrustZone </h2><br>  <a href="https://www.arm.com/products/security-on-arm/trustzone">TrustZone</a> technology is built into the ARM Cortex-A and Cortex-R processors.  This technology allows you to select two execution modes at the hardware level: Secure (Secure) and Non-Secure (Guest). <br><br>  These processors are mainly aimed at the market of smartphones and tablet computers, and TrustZone is used to create a trusted trusted sandbox in Secure mode for executing code related to cryptography, DRM, and storing user data. <br><br>  In Secure mode, this starts a special OS, generally called TEE (Trusted Execution Environment, trusted runtime environment), and a normal OS, such as Linux, Android, iOS, starts in Non-Secure mode.  At the same time, access rights to some devices are limited for a normal OS, therefore it is also called a <i>guest</i> OS. <br><br>  Due to the restrictions imposed, the guest OS has to call TEE functions from time to time to perform certain operations.  TEE continues to exist in parallel with the guest OS all the time, and the guest OS cannot do anything about it. <br><br>  For example, the guest OS uses TEE functions to: <br><br><ul><li>  turning on and off the processor cores (in ARMv8-A this happens through PSCI - part of ARM Trusted Firmware, and in ARMv7 - differently for each processor manufacturer); <br></li><li>  storing keys, bank card data, etc .; <br></li><li>  storing keys full disk encryption; <br></li><li>  operations with cryptography; <br></li><li>  display DRM content. </li></ul><br>  In this case, from the point of view of security, at the time of such calls, control is transferred to an unknown, untested code.  We cannot unequivocally say what Samsung KNOX or QSEE from Qualcomm is doing. <br><br>  Why do system developers agree to this mode of operation?  In TrustZone-enabled processors, the Secure Boot mechanism is also integrated in one form or another. <br><br>  With Secure Boot, the preloader verifies the signature of the boot image using the public key stitched during the production phase.  Thus, it is guaranteed that only the signed image will be downloaded.  This is a security feature. <br><br>  That is, the OS boot becomes the following: <br><br><ol><li>  start preloader in ROM.  It loads the keys to verify the TEE signature from ROM; <br></li><li>  the preloader loads the TEE image into memory, verifies the signature.  If the check is successful, TEE starts; <br></li><li>  TEE configures Secure and Non-Secure modes.  Next, TEE loads the main OS loader and switches to it in Non-Secure mode.  The TEE itself remains in secure mode and waits; <br></li><li>  the main OS loader loads the OS as usual; <br></li><li>  The OS is forced from time to time to call TEE functions to perform certain tasks. </li></ol><br>  However, a manufacturer typically supplies signed bootloader images and TEEs as part of the SDK for the processor and supplies processors that are already wired with the manufacturer's key.  In this case, the preloader from ROM will not execute any bootloader, unless it is signed by the manufacturer.  All the main processors for smartphones are now delivered already ‚Äústitched‚Äù for the execution of their own TEE before the execution of the OS loader. <br><br>  Then laziness works - with TEE everything works, and without TEE it does not even start.  Developers use SDK with TEE, call the closed binary code from the Linux kernel and do not worry. <br><br><h2>  How to check your project on appeals to TrustZone </h2><br>  It may even seem that all this TrustZone does not exist, at least in your particular design.  Check it out is a snap. <br><br>  The fact is that all processors with TrustZone start in Secure mode, and only then switch to Normal.  If your OS is running in Normal mode, then some kind of Secure OS (TEE) exists in the system and transferred it to this mode. <br><br>  The litmus test is a call to TEE to enable L2 Cache.  For some reason, the ARM architecture does not allow this to be done from Normal World.  Therefore, to enable the cache, the OS kernel will need to make at least one call to TrustZone.  This is done by a single command: <b>smc # 0</b> , and you can search for it yourself in the Linux or Android kernel. <br><br>  Of course, we ourselves searched and found such calls in the support code of a number of processors Qualcomm, Samsung, Mediatek, Rockchip, Spreadtrum, HiSilicon, Broadcom, Cavium. <br><br><h2>  ARM Cortex-A download and threat analysis </h2><br>  So, the promised process of loading the OS on ARM (here - Cortex-A) into four blocks: <br><div style="text-align:center;"> <a href=""><img width="600" hspace="5" src="https://habrastorage.org/webt/59/ca/63/59ca634e3edda639504234.png"></a> </div><br>  In the diagram, the dotted line indicates the path of circulation from the OS kernel to TEE. <br><br>  In two blocks - unknown to us code.  Let's see what this means. <br><br>  Technically, any of the components of the system software may contain errors, intentional bookmarks, and so on.  However, in most cases, the bootloader, OS, and system software can be checked by examining the source codes.  We will concentrate on possible threats emanating from the preloader and TEE, the source codes to which are closed. <br><br>  The preloader works at the earliest stage, when the connection scheme to the processor of various peripheral devices is not yet known, no communication devices (WiFi, 3G, etc.) are configured, communication protocols do not work.  At the same time, a preloader is a small program, with a code size of the order of several tens of kilobytes, and it is difficult to imagine the placement of full stacks of protocols or serious heuristics by definition of connected devices in it.  Therefore, the preloader hardly harbors serious bookmarks related to surveillance, data transfer, etc. <br><br>  TEE is a much more interesting point of attack, since its functions are called during OS operation, when all peripheral devices work and communication protocols are configured.  Creating a spy bookmark in the TEE code allows you to follow the CBT user almost unlimitedly. <br><br>  In a small study, we showed the feasibility of a bookmark in TEE, imperceptibly intercepting Linux system calls.  To activate a bookmark, you only need one call from the Linux kernel to TEE (for example, the one for the second level cache), after which the system becomes fully manageable.  This allows: <br><br><ul><li>  control reading and writing files, modify data "on the fly"; <br></li><li>  intercept user input, and the entered characters are intercepted even from the on-screen keyboard; <br></li><li>  quietly embed your data when communicating with remote servers, including the https protocol, masking the transfer of spyware information to ordinary encrypted Web traffic. </li></ul><br>  Undoubtedly, the identified opportunities are only the tip of the iceberg, and the creation of bookmarks was not the goal of the study. <br><br><h2>  findings </h2><br>  We reviewed the process of loading various microcontrollers and ARM processors. <br><br>  In microcontrollers, the OS is the most vulnerable place in the boot process. <br><br>  Modern ARM Cortex-A processors include the TrustZone - and there is no getting away from it.  TrustZone assumes the launch before the OS of the TEE trusted execution environment <br><br>  TEE is the most vulnerable point in the OS boot process on ARM Cortex-A, because calls to TEE lead to the execution of a closed system code known to the manufacturer, but hidden from us. <br><br>  <i>Without control over TEE, it is impossible to ensure the security and power of attorney for the execution of any OS on ARM Cortex-A.</i> </div><p>Source: <a href="https://habr.com/ru/post/338806/">https://habr.com/ru/post/338806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338796/index.html">Illusion of movement</a></li>
<li><a href="../338798/index.html">20 useful services for product managers</a></li>
<li><a href="../338800/index.html">SAP is looking for future specialists to work with data science and machine learning</a></li>
<li><a href="../338802/index.html">Dangerous game. Should I rely on a team of juniors</a></li>
<li><a href="../338804/index.html">$ mol_app_calc: Spreadsheet Party</a></li>
<li><a href="../338808/index.html">Review of music software code defects. Part 1. MuseScore</a></li>
<li><a href="../338810/index.html">"Kings of Mathematics": Big Data Analytics in a bank. Project GAUSS in VTB</a></li>
<li><a href="../338812/index.html">How can a never called function be called?</a></li>
<li><a href="../338814/index.html">We translate interfaces into fifty languages. Sketch</a></li>
<li><a href="../338816/index.html">MBLTdev 2017: Hardcore Android Development Reports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>