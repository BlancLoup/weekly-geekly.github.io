<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using PHP Closures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction to PHP 5.3 closures is one of its main innovations, and although several years have passed since the release, there is still no standard ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using PHP Closures</h1><div class="post__text post__text-html js-mediator-article">  Introduction to PHP 5.3 closures is one of its main innovations, and although several years have passed since the release, there is still no standard practice for using this language feature.  In this article, I tried to collect all the most interesting possibilities for applying closures in PHP. <br><a name="habracut"></a><br>  To begin, consider what it is - a closure and what are its features in PHP. <br><br><pre><code class="php hljs">$g = <span class="hljs-string"><span class="hljs-string">'test'</span></span>; $c = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($g)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $a . $b . $g; }; $g = <span class="hljs-string"><span class="hljs-string">'test2'</span></span>; var_dump($c); <span class="hljs-comment"><span class="hljs-comment">/* object(Closure)#1 (2) { ["static"]=&gt; array(1) { ["g"]=&gt; string(4) "test" } ["parameter"]=&gt; array(2) { ["$a"] =&gt; string(10) "" ["$b"]=&gt; string(10) "" } } */</span></span></code> </pre> <br>  As you can see, the closure, like the lambda function, is an object of the Closure class, which coordinates the passed parameters.  In order to call an object as a function, the magic method __invoke was introduced in PHP5.3. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getClosure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $g = <span class="hljs-string"><span class="hljs-string">'test'</span></span>; $c = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($g)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $a . $b . $g; }; $g = <span class="hljs-string"><span class="hljs-string">'test2'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $c; } $closure = getClosure(); $closure(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">//13test getClosure()-&gt;__invoke(1, 3); //13test</span></span></code> </pre><br>  Using the use construct, we inherit the variable from the parent scope to the local scope of the Lambda function. <br>  The syntax is simple and straightforward.  The use of such functionality in the development of web applications is not entirely clear.  I looked at the code of several modern frameworks that use the new features of the language and tried to bring together their various uses. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Callback functions </h4><br>  The most obvious use of anonymous functions is to use them as callbacks.  In PHP, there are many standard functions that accept a callback type or its synonym callable as entered in PHP 5.4.  The most popular ones are array_filter, array_map, array_reduce.  The array_map function is used for iterative processing of array elements.  The callback function is applied to each element of the array and the result is the processed array.  I immediately had a desire to compare the performance of the usual array processing in a loop using the built-in function.  Let's experiment. <br><br><pre> <code class="php hljs">$x = range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100000</span></span>); $t = microtime(<span class="hljs-number"><span class="hljs-number">1</span></span>); $x2 = array_map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $v + <span class="hljs-number"><span class="hljs-number">1</span></span>; }, $x); <span class="hljs-comment"><span class="hljs-comment">//Time: 0.4395 //Memory: 22179776 //--------------------------------------- $x2 = array(); foreach($x as $v){ $x2[] = $v + 1; } //Time: 0.0764 //Memory: 22174788 //--------------------------------------- function tr($v){ return $v + 1; } $x2 = array(); foreach($x as $v){ $x2[] = tr($v); } //Time: 0.4451 //Memory: 22180604</span></span></code> </pre><br>  As you can see, the overhead of a large number of function calls gives a noticeable drop in performance, which is to be expected.  Although the test is synthetic, the task of processing large arrays often arises, and in this case, the use of data processing functions can become the place where your application will significantly slow down.  Be careful.  However, in modern applications, this approach is used very often.  It allows you to make the code more concise, especially if the handler is declared somewhere else, and not when called. <br><br>  In fact, in this context, the use of anonymous functions is no different from the old way of passing a string name of a function or a callback array, except for one particular feature - now we can use closures, that is, save variables from the scope when creating a function.  Consider an example of processing an array of data before adding them to the database. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  . $quoter = function($v) use($pdo){ return $pdo-&gt;quote($v);//    ,    :-) } $service-&gt;register('quoter', $quoter); ‚Ä¶ //-    //      PDO $data = array(...);//  $data = array_map($this-&gt;service-&gt;getQuoter(), $data); //   .</span></span></code> </pre><br>  It is very convenient to use anonymous functions and to filter <br><br><pre> <code class="php hljs">$x = array_filter($data, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }); <span class="hljs-comment"><span class="hljs-comment">//vs $x = array(); foreach($data as $v) { if($v &gt; 0){$x[] = $v} }</span></span></code> </pre><br><h4>  Developments. </h4><br>  Closures are ideal as event handlers.  for example <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//-   . $this-&gt;events-&gt;on(User::EVENT_REGISTER, function($user){ //      .. }); $this-&gt;events-&gt;on(User::EVENT_REGISTER', function($user){ // email  . }); //    $this-&gt;events-&gt;trigger(User::EVENT_REGISTER, $user);</span></span></code> </pre><br>  Putting logic into event handlers on the one hand makes the code cleaner, on the other hand complicates the search for errors ‚Äî sometimes the behavior of the system becomes unexpected for a person who does not know which handlers are hung at the moment. <br><br><h4>  Validation </h4><br>  Closures essentially save some logic in a variable that can be executed or not executed in the course of the script.  This is what you need to implement validators: <br><br><pre> <code class="php hljs">$notEmpty = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strlen($v) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> : ‚Äú    ‚Äù; }; $greaterZero = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $v &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> : ‚Äú    ‚Äù; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRangeValidator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($min, $max)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($min, $max)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($v &gt;= $min &amp;&amp; $v &lt;= $max) ? <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> : ‚Äú    ‚Äù; }; }</code> </pre><br>  In the latter case, we apply a higher order function that returns another function ‚Äî a validator with predefined boundaries of values.  You can use validators, for example, as follows. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserForm</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseForm</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;addValidator(<span class="hljs-string"><span class="hljs-string">'email'</span></span>, Validators::$notEmpty); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;addValidator(<span class="hljs-string"><span class="hljs-string">'age'</span></span>, Validators::getRangeValidator(<span class="hljs-number"><span class="hljs-number">18</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;addValidator(<span class="hljs-string"><span class="hljs-string">'custom'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v)</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//some logic }); } /** *    . */ public function isValid() { ‚Ä¶ $validationResult = $validator($value); if($validationResult !== true){ $this-&gt;addValidationError($field, $validationResult); } ‚Ä¶ } }</span></span></code> </pre><br>  Using forms is a classic example.  Also, validation can be used in setters and getters of ordinary classes, models, etc.  It is true that declarative validation is considered to be a good way, when the rules are described not in the form of functions, but in the form of rules in configuration, however, sometimes this approach is very useful. <br><br><h4>  Expressions </h4><br>  Symfony has a very interesting use for closures.  The <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Config/Definition/Builder/ExprBuilder.php">ExprBuilder</a> class <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Config/Definition/Builder/ExprBuilder.php">defines</a> an entity that allows you to build expressions like <br><br><pre> <code class="php hljs">... -&gt;beforeNormalization() -&gt;ifTrue(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> is_array($v) &amp;&amp; is_int(key($v)); }) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array_map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'name'</span></span> =&gt; $v); }, $v); }) -&gt;end() ...</code> </pre><br>  In symfony, as I understand it, this is an internal class that is used to create processing of nested configuration arrays (correct me if not right).  An interesting idea is the implementation of expressions in the form of chains.  In principle, it is possible to implement a class that would describe expressions in the following form: <br><br><pre> <code class="php hljs">$expr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Expression(); $expr -&gt;if(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;v == <span class="hljs-number"><span class="hljs-number">4</span></span>;}) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;v = <span class="hljs-number"><span class="hljs-number">42</span></span>;}) -&gt;else(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{}) -&gt;elseif(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{}) -&gt;end() -&gt;while(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;v &gt;=<span class="hljs-number"><span class="hljs-number">42</span></span>}) -&gt;do(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;v --; }) -&gt;end() -&gt;apply(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{<span class="hljs-comment"><span class="hljs-comment">/*Some code*/</span></span>}); $expr-&gt;v = <span class="hljs-number"><span class="hljs-number">4</span></span>; $expr-&gt;exec(); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $expr-&gt;v;</code> </pre><br>  Application, of course, experimentally.  In essence, this is a record of some algorithm.  The implementation of such a functional is quite complicated - the expression in the ideal case should store a tree of operations.  An interesting concept, maybe somewhere such a construction would be useful. <br><br><h4>  Routing </h4><br>  In many mini frameworks, routing now works on anonymous functions. <br><br><pre> <code class="php hljs">App::router(<span class="hljs-string"><span class="hljs-string">'GET /users'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app)</span></span></span></span>{ $app-&gt;response-&gt;write(<span class="hljs-string"><span class="hljs-string">'Hello, World!'</span></span>); });</code> </pre><br>  Enough convenient and concise. <br><br><h4>  Caching </h4><br>  On Habr√©, this has already been discussed, nevertheless. <br><br><pre> <code class="php hljs">$someHtml = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;cashe-&gt;get(<span class="hljs-string"><span class="hljs-string">'users.list'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($app)</span></span></span></span>{ $users = $app-&gt;db-&gt;table(<span class="hljs-string"><span class="hljs-string">'users)-&gt;all(); return $app-&gt;template-&gt;render('</span></span>users.<span class="hljs-keyword"><span class="hljs-keyword">list</span></span><span class="hljs-string"><span class="hljs-string">', $isers); }, 1000);</span></span></code> </pre><br>  Here, the get method checks the validity of the cache using the 'users.list' key and if it is not valid, then it accesses the function for data.  The third parameter determines the duration of data storage. <br><br><h4>  Initialization On Demand </h4><br>  Suppose we have the Mailer service, which we call in some methods.  It must be configured before use.  In order not to initialize it every time, we will use lazy object creation. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//-   . $service-&gt;register('Mailer', function(){ return new Mailer('user', 'password', 'url'); }); //-   $this-&gt;service('Mailer')-&gt;mail(...);</span></span></code> </pre><br>  Object initialization will occur only before the very first use. <br><br><h4>  Change the behavior of objects </h4><br>  Sometimes it is useful to override the behavior of objects during script execution ‚Äî add a method, override an old one, and so on.  The closure will help us here too.  In PHP5.3, you had to use different workarounds for this. <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">publicMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{<span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">privateMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{<span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'private'</span></span>;} <span class="hljs-comment"><span class="hljs-comment">//       . public function __call($name, $arguments) { if($this-&gt;$name instanceof Closure){ return call_user_func_array($this-&gt;$name, array_merge(array($this), $arguments)); } } } $b = new Base; //   $b-&gt;method = function($self){ echo 'I am a new dynamic method'; $self-&gt;publicMethod(); //        }; $b-&gt;method-&gt;__invoke($b); //    $b-&gt;method(); //      //call_user_func($b-&gt;{'method'}, $b); //  </span></span></code> </pre><br><br>  In principle, it is possible to override the old method, but only if it was defined in a similar way.  Not quite comfortable.  Therefore, in PHP 5.4, it became possible to associate a closure with an object. <br><br><pre> <code class="php hljs">$closure = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;privateMethod(); } $closure-&gt;bindTo($b, $b); <span class="hljs-comment"><span class="hljs-comment">//     $closure();</span></span></code> </pre><br>  Of course, the modification of the object failed, however, the closure gains access to private functions and properties. <br><br><h4>  Passing as default parameters to data access methods </h4><br>  An example of getting a value from a GET array.  In case of its absence, the value will be obtained by calling the function. <br><pre> <code class="php hljs">$name = Input::get(<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>;});</code> </pre><br><br><h4>  Higher order functions </h4><br>  There was already an example of creating a validator.  I will give an example from the <a href="http://lithify.me/">lithium</a> framework <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Writes the message to the configured cache adapter. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $type * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $message * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> closure Function returning boolean `true` on successful write, `false` otherwise. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($type, $message)</span></span></span><span class="hljs-function"> </span></span>{ $config = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_config + <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_classes; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($self, $params)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($config)</span></span></span><span class="hljs-function"> </span></span>{ $params += <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'timestamp'</span></span> =&gt; strtotime(<span class="hljs-string"><span class="hljs-string">'now'</span></span>)); $key = $config[<span class="hljs-string"><span class="hljs-string">'key'</span></span>]; $key = is_callable($key) ? $key($params) : String::insert($key, $params); $cache = $config[<span class="hljs-string"><span class="hljs-string">'cache'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $cache::write($config[<span class="hljs-string"><span class="hljs-string">'config'</span></span>], $key, $params[<span class="hljs-string"><span class="hljs-string">'message'</span></span>], $config[<span class="hljs-string"><span class="hljs-string">'expiry'</span></span>]); }; }</code> </pre><br>  The method returns a closure that can then be used to write the message to the cache. <br><br><h4>  Transfer to templates </h4><br>  Sometimes it is convenient to transfer not just data to a template, but, for example, a configured function that can be called from the template code to get any values. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  $layout-&gt;setLink = function($setId) use ($userLogin) { return '/users/' . $userLogin . '/set/' . $setId; }; //  &lt;a href=</span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">&lt;?</span></span></span><span class="hljs-comment">=$this-&gt;setLink-&gt;__invoke($id);</span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span><span class="hljs-comment">&gt;Set name&lt;/a&gt;</span></span></code> </pre><br>  In this case, the template generated several links to the user's entities, and his login appeared in the addresses of these links. <br><br><h4>  Recursive closure definition </h4><br>  Finally, how to set recursive closures.  To do this, pass a reference to the closure in use, and call it in code.  Do not forget about the condition of the termination of recursion <br><br><pre> <code class="php hljs">$factorial = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( $n )</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( &amp;$factorial )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( $n == <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $factorial( $n - <span class="hljs-number"><span class="hljs-number">1</span></span> ) * $n; }; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $factorial( <span class="hljs-number"><span class="hljs-number">5</span></span> );</code> </pre><br><br>  Many of the examples look stiff.  How many years lived without them - and nothing.  However, sometimes using closures is natural enough for PHP.  Skillful use of this feature will make the code more readable and increase the efficiency of the programmer.  You just need to adjust your thinking a little under the new paradigm and everything will fall into place.  In general, I recommend to compare how such things are used in other languages ‚Äã‚Äãlike Python.  I hope that someone has found something new here.  And of course, if someone else knows any interesting applications of closures, then I‚Äôm really looking forward to your comments.  Thank! </div><p>Source: <a href="https://habr.com/ru/post/147620/">https://habr.com/ru/post/147620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147615/index.html">The project of the game console in less than 2 days collected $ 3 million on Kickstarter</a></li>
<li><a href="../147616/index.html">Save time on connecting fonts to the project</a></li>
<li><a href="../147617/index.html">Base on programming languages: How did languages ‚Äã‚Äãappear and why</a></li>
<li><a href="../147618/index.html">Base on programming languages: The principle of preserving functionality</a></li>
<li><a href="../147619/index.html">Base on programming languages: syntactic sugar or history of language development</a></li>
<li><a href="../147621/index.html">The cost of Google Nexus 7 was estimated by independent experts.</a></li>
<li><a href="../147622/index.html">Google spoke out against law No. 89417-6</a></li>
<li><a href="../147623/index.html">German operator opposes paid roaming</a></li>
<li><a href="../147625/index.html">New law threatens free internet</a></li>
<li><a href="../147626/index.html">Internet giants against the law on the site registry</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>