<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerate Viola-Jones Method</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, the Viola-Jones method, which for a long time has been the main method for detecting objects in an image, has been retreating under the onsl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerate Viola-Jones Method</h1><div class="post__text post__text-html js-mediator-article">  Recently, the Viola-Jones method, which for a long time has been the main method for detecting objects in an image, has been retreating under the onslaught of newer and more advanced algorithms.  Nevertheless, the relevance of this method is still preserved in the present tense. <br><br>  Yes, the cascade classifier based on the Haar attributes (Viola-Jones method) is inferior in speed to the cascade LBP classifier.  It is less accurate than a detector based on HOG signs, and even more so a detector based on convolutional neural networks.  And yet it has a certain niche, when accuracy is required higher than that of the LBP cascade, but the speed of operation of more accurate detectors is not high enough.  An equally important factor is that for the cascade Haar classifier, there are a large number of cascades already trained, including in the standard package of the <a href="https://opencv.org/">OpenCV library.</a>  Therefore, the speed of this algorithm is very important.  What prompted the author in his time to do his optimization. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/814/a00/34f/814a0034f5549e957ee61360d87457e5.png" alt="image"></div><br>  Well, what article about the detection of faces can do without a photo of Lena? <br><a name="habracut"></a><br><h2>  Ways to increase productivity </h2><br>  There are quite a few detailed descriptions of how the Viola-Jones method works, including on Habrahabr: <a href="https://habrahabr.ru/post/133826/">source 1</a> , <a href="https://habrahabr.ru/company/recognitor/blog/228195/">source 2</a> .  Therefore, I will not dwell on his description, who will be interested in reading this in the above sources.  I would like to say a few words about the possible ways in which the Viola-Jones method can be accelerated. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Viola-Jones method is not some kind of rigid fixed algorithm.  His cascades are formed as a result of training.  Therefore, the speed of work can vary greatly depending on the complexity of the object and the size of the object that we want to detect.  The simplest way to speed up its work is to set a limit on the minimum object or increase the step of the pyramid.  However, these methods have side effects in the form of reduced accuracy of operation or an increase in the number of false positives.  Re-training cascades can sometimes have a very significant effect in terms of the accuracy and speed of the work.  However, this is a rather costly process associated with collecting a large training sample.  And the learning itself is not to say that a very fast process. <br></li><li>  A fairly obvious way to accelerate is to process different parts of the image in parallel streams.  This method is already implemented in OpenCV, because here you do not need to do anything. </li><li>  Use a parallel accelerator for parallel processing.  Here, too, there is already an implementation in OpenCV.  The downside is the requirement for the presence of a graphics accelerator. </li><li>  Use to accelerate the algorithm vector instructions processor SIMD.  Vector instructions exist in almost all modern processors.  Unfortunately, they are different in different processors - so you have to have different implementations for different processors.  In addition, the effective use of vector instructions requires a significant alteration of the algorithm.  This method is devoted to this article. </li></ol><br><h2>  Original (scalar) version of the algorithm </h2><br>  If you take the <a href="https://github.com/opencv/opencv/tree/master/modules/objdetect/src">source code of</a> this algorithm from OpenCV, then you can see numerous attempts to speed it up using various SIMD (SSE, AVX, NEON) instructions.  I do not have accurate numerical estimates of how successful these attempts have been.  However, judging by the source codes, the acceleration was hardly significant, since either the vector instructions are not used in the optimizations <a href="">(only their scalar counterparts)</a> , or the data is loaded into vector registers <a href="">element</a> by <a href="">element</a> , which fatally affects the overall performance of the algorithm. <br><br>  And so, let's consider a <a href="">scalar version of</a> the cascade Haar classifier algorithm (the simplified version of it is given below) for a given scale: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HaarDetect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HaarCascade &amp; hid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Image &amp; mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Rect &amp; rect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step, Image &amp; dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> row = rect.top; row &lt; rect.bottom; row += step) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> p_offset = row * hid.sum.stride / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pq_offset = row * hid.sqsum.stride / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> col = rect.left; col &lt; rect.right; col += step) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask.At&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(col, row) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> norm = Norm(hid, pq_offset + col); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Detect(hid, p_offset + col, <span class="hljs-number"><span class="hljs-number">0</span></span>, norm) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) dst.At&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(col, row) = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre> <br>  Here an image is scanned over all its points (on a small scale, for acceleration, as a rule, an image is scanned in increments of 2).  For each point, the normalization factor is calculated (depending on the brightness and contrast of the image in the vicinity of this point): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> Sum(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ptr[<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr[<span class="hljs-number"><span class="hljs-number">0</span></span>][offset] - ptr[<span class="hljs-number"><span class="hljs-number">1</span></span>][offset] - ptr[<span class="hljs-number"><span class="hljs-number">2</span></span>][offset] + ptr[<span class="hljs-number"><span class="hljs-number">3</span></span>][offset]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Norm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HaarCascade &amp; hid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(Sum(hid.p, offset)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sqsum = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(Sum(hid.pq, offset)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> q = sqsum*hid.windowArea - sum *sum; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> q &lt; <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ? <span class="hljs-number"><span class="hljs-number">1.0f</span></span> : sqrtf(q); }</code> </pre><br>  And also the classification itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeightedSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> WeightedRect &amp; rect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = rect.p0[offset] - rect.p1[offset] - rect.p2[offset] + rect.p3[offset]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rect.weight*sum; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Detect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HaarCascade &amp; hid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startStage, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> norm)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HaarCascade::Stage * stages = hid.stages.data(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HaarCascade::Node * node = hid.nodes.data() + stages[startStage].first; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * leaves = hid.leaves.data() + stages[startStage].first * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = startStage, n = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)hid.stages.size(); i &lt; n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HaarCascade::Stage &amp; stage = stages[i]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HaarCascade::Node * end = node + stage.ntrees; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stageSum = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; node &lt; end; ++node, leaves += <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HaarCascade::Feature &amp; feature = hid.features[node-&gt;featureIdx]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum = WeightedSum(feature.rect[<span class="hljs-number"><span class="hljs-number">0</span></span>], offset) + WeightedSum(feature.rect[<span class="hljs-number"><span class="hljs-number">1</span></span>], offset); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (feature.rect[<span class="hljs-number"><span class="hljs-number">2</span></span>].p0) sum += WeightedSum(feature.rect[<span class="hljs-number"><span class="hljs-number">2</span></span>], offset); stageSum += leaves[sum &gt;= node-&gt;threshold*norm]; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stageSum &lt; stage.threshold) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -i; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  Here, the Haar traits are calculated using pre-calculated <a href="http://robocraft.ru/blog/computervision/536.html">integral images</a> . <br><br><h2>  Algorithm vectorization methods </h2><br>  Analysis of the above algorithm shows that the main computational resources are spent on the calculation of weighted integral sums ( <b>WeightedSum</b> function).  Therefore, they must first vectorize.  There are only 2 ways to do this: <br><br><ul><li>  We are trying to simultaneously calculate several Haar-signs in one SIMD vector at once. </li><li>  We are trying to simultaneously cheat several image points in one SIMD vector at once. </li></ul><br><h3>  Vectorized featured </h3><br>  At first glance, it is most optimal to perform vectorization by calculating Haar-signs (by the way, so it was done in <a href="">OpenCV</a> ).  However, there is one thing: the data over which you need to carry out calculations are randomly scattered in memory.  Therefore, they must first be collected from there using scalar read operations, and then the calculation results should be scattered using scalar write operations.  You can of course use the <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">gather-scatter</a> operations (they are in AVX2 and AVX-512), but their speed is comparable, and sometimes slower than if you just use a scalar code. <br><br><h3>  Point vectorization </h3><br>  Vectorization by image points is not so obvious (in fact, we perform vectorization almost along the outermost cycle).  However, the data in the integral image for neighboring points lie side by side, which allows them to be effectively loaded using vector operations.  In addition, the method is easily scaled for different lengths of SIMD vectors.  This is where the pluses end, and then the list of problems: <br><br><ol><li>  The effectiveness of the Viola-Jones algorithm is based on the fact that obviously incorrect points are rejected at each stage.  The proportion of points dropped depends on the learning parameters, and is 50% by default.  If we process a SIMD vector with several points, then we will have to continue calculating the stages until all its elements are discarded.  This reduces the effectiveness of the method in the calculation of subsequent stages.  Fortunately, the stages at which neighboring points are discarded correlate quite strongly.  In addition, if there is only one point in the vector for verification, then we can go on to the scalar version of the algorithm, which in this case will be more efficient. </li><li>  The original algorithm from OpenCV in order to optimize for small scale checks the points in steps of 2. This speeds up the scalar code, but reduces the efficiency of vector instructions, since we already have half of the calculations to do in the first stage in vain.  Fortunately, this problem has a rather elegant solution.  But we will write it in more detail later. </li></ol><br><h2>  SIMD version of the algorithm </h2><br>  In this article, I will provide a simplified version of the algorithm for <a href="">SSE4.1</a> , versions for <a href="">AVX2</a> , <a href="">AVX-512</a> and <a href="">NEON</a> use the same approach. <br><br>  First, consider the case when we scan all points of the image without gaps: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DetectionHaarDetect32fp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HidHaarCascade &amp; hid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Image &amp; mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Rect &amp; rect, Image &amp; dst)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rightAligned = rect.left + Simd::AlignLo(rect.Width(), <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> row = rect.top; row &lt; rect.bottom; row += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> p_offset = row * hid.sum.stride / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> pq_offset = row * hid.sqsum.stride / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> col = rect.left; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; col &lt; rightAligned; col += <span class="hljs-number"><span class="hljs-number">4</span></span>) { __m128i result = _mm_loadu_si128((__m128i*)(mask.Row&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(row) + col)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_mm_testz_si128(result, _mm_set1_epi32(<span class="hljs-number"><span class="hljs-number">1</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; __m128 norm = Norm32fp(hid, pq_offset + col); Detect32f(hid, p_offset + col, norm, result); _mm_storeu_si128((__m128i*)(dst.Row&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(row) + col), result); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; col &lt; rect.right; col += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask.At&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(col, row) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> norm = Norm32f(hid, pq_offset + col); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Detect(hid, p_offset + col, <span class="hljs-number"><span class="hljs-number">0</span></span>, norm) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) dst.At&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt;(col, row) = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } }</code> </pre><br>  Here, unlike the scalar version, the image is scanned not by single points, but by blocks of 4 points (only the edge points are processed in a scalar way).  The normalization factor for a block of four points is calculated as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> __<span class="hljs-function"><span class="hljs-function">m128 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidSqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128 value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm_blendv_ps(_mm_set1_ps(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>), _mm_sqrt_ps(value), _mm_cmpgt_ps(value, _mm_set1_ps(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>))); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> __<span class="hljs-function"><span class="hljs-function">m128i </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sum32ip</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ptr[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span><span class="hljs-function"> </span></span>{ __m128i s0 = _mm_loadu_si128((__m128i*)(ptr[<span class="hljs-number"><span class="hljs-number">0</span></span>] + offset)); __m128i s1 = _mm_loadu_si128((__m128i*)(ptr[<span class="hljs-number"><span class="hljs-number">1</span></span>] + offset)); __m128i s2 = _mm_loadu_si128((__m128i*)(ptr[<span class="hljs-number"><span class="hljs-number">2</span></span>] + offset)); __m128i s3 = _mm_loadu_si128((__m128i*)(ptr[<span class="hljs-number"><span class="hljs-number">3</span></span>] + offset)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm_sub_epi32(_mm_sub_epi32(s0, s1), _mm_sub_epi32(s2, s3)); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> __<span class="hljs-function"><span class="hljs-function">m128 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Norm32fp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HidHaarCascade &amp; hid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span><span class="hljs-function"> </span></span>{ __m128 area = _mm_set1_ps(hid.windowArea); __m128 sum = _mm_cvtepi32_ps(Sum32ip(hid.p, offset)); __m128 sqsum = _mm_cvtepi32_ps(Sum32ip(hid.pq, offset)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ValidSqrt(_mm_sub_ps(_mm_mul_ps(sqsum, area), _mm_mul_ps(sum, sum))); }</code> </pre><br>  The classification itself for a block of four points: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(__m128i result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> SIMD_ALIGNED(<span class="hljs-number"><span class="hljs-number">16</span></span>) buffer[<span class="hljs-number"><span class="hljs-number">4</span></span>]; _mm_store_si128((__m128i*)buffer, _mm_sad_epu8(result, _mm_setzero_si128())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] + buffer[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> __<span class="hljs-function"><span class="hljs-function">m128 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeightedSum32f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> WeightedRect &amp; rect, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span><span class="hljs-function"> </span></span>{ __m128i s0 = _mm_loadu_si128((__m128i*)(rect.p0 + offset)); __m128i s1 = _mm_loadu_si128((__m128i*)(rect.p1 + offset)); __m128i s2 = _mm_loadu_si128((__m128i*)(rect.p2 + offset)); __m128i s3 = _mm_loadu_si128((__m128i*)(rect.p3 + offset)); __m128i sum = _mm_sub_epi32(_mm_sub_epi32(s0, s1), _mm_sub_epi32(s2, s3)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _mm_mul_ps(_mm_cvtepi32_ps(sum), _mm_set1_ps(rect.weight)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StageSum32f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * leaves, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> threshold, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __m128 &amp; sum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __m128 &amp; norm, __m128 &amp; stageSum)</span></span></span><span class="hljs-function"> </span></span>{ __m128 mask = _mm_cmplt_ps(sum, _mm_mul_ps(_mm_set1_ps(threshold), norm)); stageSum = _mm_add_ps(stageSum, _mm_blendv_ps(_mm_set1_ps(leaves[<span class="hljs-number"><span class="hljs-number">1</span></span>]), _mm_set1_ps(leaves[<span class="hljs-number"><span class="hljs-number">0</span></span>]), mask)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Detect32f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HidHaarCascade &amp; hid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __m128 &amp; norm, __m128i &amp; result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> HidHaarCascade Hid; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> * leaves = hid.leaves.data(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Hid::Node * node = hid.nodes.data(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Hid::Stage * stages = hid.stages.data(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, n = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)hid.stages.size(); i &lt; n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Hid::Stage &amp; stage = stages[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stage.canSkip) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Hid::Node * end = node + stage.ntrees; __m128 stageSum = _mm_setzero_ps(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stage.hasThree) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; node &lt; end; ++node, leaves += <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Hid::Feature &amp; feature = hid.features[node-&gt;featureIdx]; __m128 sum = _mm_add_ps(WeightedSum32f(feature.rect[<span class="hljs-number"><span class="hljs-number">0</span></span>], offset), WeightedSum32f(feature.rect[<span class="hljs-number"><span class="hljs-number">1</span></span>], offset)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (feature.rect[<span class="hljs-number"><span class="hljs-number">2</span></span>].p0) sum = _mm_add_ps(sum, WeightedSum32f(feature.rect[<span class="hljs-number"><span class="hljs-number">2</span></span>], offset)); StageSum32f(leaves, node-&gt;threshold, sum, norm, stageSum); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; node &lt; end; ++node, leaves += <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Hid::Feature &amp; feature = hid.features[node-&gt;featureIdx]; __m128 sum = _mm_add_ps(WeightedSum32f(feature.rect[<span class="hljs-number"><span class="hljs-number">0</span></span>], offset), WeightedSum32f(feature.rect[<span class="hljs-number"><span class="hljs-number">1</span></span>], offset)); StageSum32f(leaves, node-&gt;threshold, sum, norm, stageSum); } } result = _mm_andnot_si128(_mm_castps_si128(_mm_cmpgt_ps(_mm_set1_ps(stage.threshold), stageSum)), result); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> resultCount = ResultCount(result); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resultCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//        ,  : { return; } else if (resultCount == 1) //      1 ,     : { uint32_t SIMD_ALIGNED(16) _result[4]; float SIMD_ALIGNED(16) _norm[4]; _mm_store_si128((__m128i*)_result, result); _mm_store_ps(_norm, norm); for (int j = 0; j &lt; 4; ++j) { if (_result[j]) { _result[j] = Detect32f(hid, offset + j, i + 1, _norm[j]) &gt; 0 ? 1 : 0; break; } } result = _mm_load_si128((__m128i*)_result); return; } } }</span></span></code> </pre><br>  As you can see, the algorithm is almost the same as for the scalar version (of course, adjusted for the use of SSE vectors instead of the usual real numbers). <br><br>  Now consider the situation when we need to perform the same algorithm in steps of 2. The simplest option is to load two vectors of 4 numbers from memory, and then form one of them (leaving only even numbers).  However, it shows a completely unsatisfactory performance.  Fortunately, you can do a little trick with reordering the source data - in the source integral images we move even points to the beginning of the line, and odd points to the end.  Then the loading of vectors with even / odd elements turns into a trivial operation.  In addition, we can use the same code for scanning. <br><br>  Optimization data is easy to implement in the same way for other vector sizes (8 for <a href="">AVX2</a> and 16 for <a href="">AVX-512</a> ) and for other platforms (for example, <a href="">NEON</a> for the ARM platform). <br><br><h2>  Optimization results </h2><br>  The table below shows the scan times (in milliseconds) of the image for different implementations of the algorithm.  An image of 1920x1080 was used for testing.  Scanning was performed without scaling the source image: <br><br><table cellpadding="2" border="1"><tbody><tr><th>  Function </th><th>  Scalar </th><th>  SSE4.1 </th><th>  AVX2 </th><th>  AVX-512 </th></tr><tr><td>  Common </td><td>  227.499 </td><td>  111.509 </td><td>  74.952 </td><td>  54.579 </td></tr><tr><td>  DetectionHaarDetect32fi (0) </td><td>  84.792 </td><td>  45.771 </td><td>  32.716 </td><td>  25.961 </td></tr><tr><td>  DetectionHaarDetect32fi (1) </td><td>  162.779 </td><td>  79.007 </td><td>  50.996 </td><td>  36.841 </td></tr><tr><td>  DetectionHaarDetect32fp (0) </td><td>  329.904 </td><td>  159.355 </td><td>  109.725 </td><td>  80.862 </td></tr><tr><td>  DetectionHaarDetect32fp (1) </td><td>  588.270 </td><td>  268.298 </td><td>  172.396 </td><td>  114.735 </td></tr></tbody></table>  Here, numbers in round brackets (0) and (1) - labeled results for different cascades used for testing.  <b>DetectionHaarDetect32fp</b> - a function that scans an image in increments of 1, <b>DetectionHaarDetect32fi</b> - in increments of 2. <b>Common</b> - geometric mean. <br><br>  The following table shows the acceleration achieved relative to the baseline (scalar) version: <br><br><table cellpadding="2" border="1"><tbody><tr><th>  Function </th><th>  SSE4.1 / Scalar </th><th>  AVX2 / Scalar </th><th>  AVX-512 / Scalar </th></tr><tr><td>  Common </td><td>  2.04 </td><td>  3.04 </td><td>  4.17 </td></tr><tr><td>  DetectionHaarDetect32fi (0) </td><td>  1.85 </td><td>  2.59 </td><td>  3.27 </td></tr><tr><td>  DetectionHaarDetect32fi (1) </td><td>  2.06 </td><td>  3.19 </td><td>  4.42 </td></tr><tr><td>  DetectionHaarDetect32fp (0) </td><td>  2.07 </td><td>  3.01 </td><td>  4.08 </td></tr><tr><td>  DetectionHaarDetect32fp (1) </td><td>  2.19 </td><td>  3.41 </td><td>  5.13 </td></tr></tbody></table>  Well, for a snack, the relative acceleration, when the vector size is doubled: <br><table cellpadding="2" border="1"><tbody><tr><th>  Function </th><th>  SSE4.1 / Scalar </th><th>  AVX2 / SSE4.1 </th><th>  AVX-512 / AVX2 </th></tr><tr><td>  Common </td><td>  2.04 </td><td>  1.49 </td><td>  1.37 </td></tr><tr><td>  DetectionHaarDetect32fi (0) </td><td>  1.85 </td><td>  1.40 </td><td>  1.26 </td></tr><tr><td>  DetectionHaarDetect32fi (1) </td><td>  2.06 </td><td>  1.55 </td><td>  1.38 </td></tr><tr><td>  DetectionHaarDetect32fp (0) </td><td>  2.07 </td><td>  1.45 </td><td>  1.36 </td></tr><tr><td>  DetectionHaarDetect32fp (1) </td><td>  2.19 </td><td>  1.56 </td><td>  1.50 </td></tr></tbody></table>  The table clearly shows the decreasing utility from each subsequent doubling of the vector. <br><br><h2>  Software implementation </h2><br>  In conclusion, I would like to say a few words about the software implementation of the above algorithms.  In the frame of the <a href="https://github.com/ermig1979/Simd">Simd</a> project, the C ++ class <a href="">Simd :: Detection</a> was implemented.  It hides under the hood a low-level work with the Simd bilingual API.  One of the important advantages is the compatibility of the used cascades (HAAR and LBP) with the cascades of <a href="https://opencv.org/">OpenCV</a> , as well as ease of use.  Below is an example of face detection using this framework: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;string&gt; #include "opencv2/opencv.hpp" #define SIMD_OPENCV_ENABLE #include "Simd/SimdDetection.hpp" #include "Simd/SimdDrawing.hpp" int main(int argc, char * argv[]) { if (argc &lt; 2) { std::cout &lt;&lt; "You have to set video source! It can be 0 for camera or video file name." &lt;&lt; std::endl; return 1; } std::string source = argv[1]; cv::VideoCapture capture; if (source == "0") capture.open(0); else capture.open(source); if (!capture.isOpened()) { std::cout &lt;&lt; "Can't capture '" &lt;&lt; source &lt;&lt; "' !" &lt;&lt; std::endl; return 1; } typedef Simd::Detection&lt;Simd::Allocator&gt; Detection; Detection detection; detection.Load("../../data/cascade/haar_face_0.xml"); bool inited = false; const char * WINDOW_NAME = "FaceDetection"; cv::namedWindow(WINDOW_NAME, 1); for (;;) { cv::Mat frame; capture &gt;&gt; frame; Detection::View image = frame; if (!inited) { detection.Init(image.Size(), 1.2, image.Size() / 20); inited = true; } Detection::Objects objects; detection.Detect(image, objects); for (size_t i = 0; i &lt; objects.size(); ++i) Simd::DrawRectangle(image, objects[i].rect, Simd::Pixel::Bgr24(0, 255, 255)); cv::imshow(WINDOW_NAME, frame); if (cvWaitKey(1) == 27)// "press 'Esc' to break video"; break; } return 0; }</span></span></span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/336338/">https://habr.com/ru/post/336338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336328/index.html">Creating a quiz on Vue.js</a></li>
<li><a href="../336330/index.html">Game of God, or how I wrote "Wolf Island"</a></li>
<li><a href="../336332/index.html">Fish, fish: how to use the "data lake" in the bank. VTB experience</a></li>
<li><a href="../336334/index.html">Paraquire, or Stop Trusting Libraries</a></li>
<li><a href="../336336/index.html">OCaml and RESTful JSON API using Eliom</a></li>
<li><a href="../336342/index.html">Agents, principals and online ticket booths in between</a></li>
<li><a href="../336346/index.html">How I did realtime roulette on NodeJS & VueJS</a></li>
<li><a href="../336348/index.html">Using the terminal when developing for Android</a></li>
<li><a href="../336350/index.html">Calculation of the weight spectrum of a linear subspace in Wolfram Mathematica</a></li>
<li><a href="../336352/index.html">Convenient use of Redux in vue components</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>