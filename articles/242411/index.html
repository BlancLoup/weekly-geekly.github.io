<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Btree node deletion algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 

 The history of this text is as follows. The child was asked to program btree. I sometimes help him. Decided that this is trivial. But att...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Btree node deletion algorithm</h1><div class="post__text post__text-html js-mediator-article">  Good day! <br><br>  The history of this text is as follows.  The child was asked to program btree.  I sometimes help him.  Decided that this is trivial.  But attempts to solve the problem by success were not crowned.  Searches for any reasonable description and / or code were also futile.  Passed son passed long ago, but my paranoid nature made me solve the problem.  Maybe someone will come in handy. <br><a name="habracut"></a><br>  <b>Btree balanced search tree (b tree)</b> <br><br>  Definition not cite.  Find it is not difficult.  Search, insert key are trivial. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Removing a key from btree </h5><br>  A node will be called empty if it contains t-1 keys, i.e.  no keys can be removed from it.  The root is by definition never empty.  Also, a subtree will be called empty if all its nodes are empty.  Empty tree is arranged uniquely.  Accordingly, a full node will be called a node with the number of keys 2t-1.  The number of keys in an empty tree is obvious <br>  (t-1) * (1 + t + t ^ 2 + ... + t ^ h) = t ^ (h + 1) -1, where h is the height of the tree (root height = 0). <br>  If inserting a key into btree is unambiguous, then deletion is ambiguous. <br>  If the node containing the found key is leaf, then if the node is not empty, the keys are shifted, replacing the one being deleted: <br><br><img src="https://habrastorage.org/files/bd6/d7a/d92/bd6d7ad92efd4a329038412435fd37c1.png" alt="image"><br><br>  If the node is empty, you need to convert the tree so that it becomes non-empty. <br><br>  For a given key, we call the <b>leaf on the left</b> leaf node into which we rest, moving first to the left descendant of this key, and then to the leaf node along the last descendants.  The <b>left sheet on the right is</b> defined in the same way.  First to the right stream, then zero descendants. <br><br><img src="https://habrastorage.org/files/c14/a67/fe5/c14a67fe55514b59a72449a0263ea454.png" alt="image"><br><br>  If the node is not leaf, this key has a right and left descendant and a parent (if not root), in which our node is in position i.  By the definition of btree, all keys of the left child are smaller, and all keys of the right child are larger than the given key.  Without violating the definition of btree, which key can replace the deleted one? <br><br><img src="https://habrastorage.org/files/fb5/b2b/f59/fb5b2bf592fe45c0805d3b3490c5f3bf.png" alt="image"><br><br>  In the figure, the keys marked in blue are smaller than this, yellow is greater than this.  The deleted key can be replaced only with the largest of the smaller ones or the smallest of the largest ones.  In the figure they are circled in red and blue, respectively.  The first is the last key of the right sheet on the left, the second is the first key of the left sheet on the right.  If one of them is not empty, simply change the deleted key to one of them and remove the replacement key from the source sheet, if not, return to the task how to make the leaf node non-empty. <br><br>  To solve the problem of making this leaf node non-empty, consider two btree transformations: merge and outweigh.  If this node is not empty, and both descendants of this key are empty, you can do a merge transformation.  This key is removed from its node, one node is made from it and its descendants.  Since the root is never empty, if all nodes are empty, and at the root of one key, merging is done, and the old root is deleted. <br><br><img src="https://habrastorage.org/files/bcc/a1f/e85/bcca1fe8594c44978c36b09b46abca18.png" alt="image"><br><br>  The second Btree transform is overweight.  If the given key has the right leaf on the left is not empty, the left leaf on the right is not full, you can make a right advantage.  If the left sheet on the right is full, perform the separation.  This key is inserted into the zero position of the left sheet on the right, increasing by one the number of keys in it.  Replace this key with the last key of the right sheet on the left, and delete it. <br><br><img src="https://habrastorage.org/files/809/a61/6f7/809a616f704f4e6d812eba53111db8d0.png" alt="image"><br><br>  Similarly, the advantage is to the right.  The height of the odds from one to the height of the tree. <br><br>  Now, actually, the algorithm is how to make this sheet non-empty.  The process is called crimping wood.  Consider crimping to the right. <br><br>  The left brother is a node at the same level to the left of the current one.  The brothers have a common ancestor and the key of a common ancestor.  Through the key of the common ancestor, the keys are re-weighted. <br><br>  If the left brother is not empty, outweigh the key.  Problem solved.  If the left sibling is empty, but the parent is not empty, perform the merge.  Problem solved.  If both the parent is empty and the left brother, we recursively ask for a spin from the parent, then from the left (any) brother. <br><br>  Similarly, crimping is done to the left.  The ambiguity of the removal is whether you can first crimp either right or left.  You can also first request the odds, and then merge, and vice versa. <br><br>  Proving reluctance, but intuition shows that crimped always. <br><br>  It must be remembered that when rebuilding a tree, the key found for deletion may be the result of merges in other nodes of the tree.  But to lose touch with the replacement keys can not. <br><br>  As one of the conclusions it can be argued that to speed up the removal of keys, it is desirable to keep the leaf nodes non-empty.  Those.  in his spare time, do the pressing down of the tree by merging.  It does not make sense to outweigh. <br><br>  You can also offer some optimization. <br><br>  Btree is a low but wide tree.  Walking on the branches can be expensive.  For optimization, we can suggest the parameter ‚Äúbranch weight‚Äù - the number of keys in it.  Since the weight of an empty tree is a constant for one height, you can check the weight by walking along the branches.  If it is equal to the weight of an empty tree, there is nothing to do there, if not, we‚Äôll stop on it, just press one key from it.  Weight management is simple.  When inserting a key, the weight of all nodes along the insertion path is incremented; if you remove the current node and all parents to the root, it is decremented. <br><br>  Terminology own. <br><br>  I say goodbye to this, I hope I am not tired.  Listing with ++ is attached (without optimization and not too combed). <br><br>  PS Ripened and proof. <br><br>  If there is at least one non-empty sheet, you can always move it to the one you need.  If there is not even one sheet above the sheets, we merge.  Further, by induction.  Given that the root is never empty. <br><br>  An optimization option has also surfaced.  If the node in which you want to remove the key is not empty, and all the left and right descendants are empty, the key is simply removed, and the descendants are glued together.  Those.  if the node is not empty, it is not necessary to go further than the nearest descendants to the left and right. <br><br><img src="https://habrastorage.org/files/92b/c9f/fdf/92bc9ffdf5aa4c69970da492884e6544.png" alt="image"><br><br>  <a href="https://yadi.sk/d/2tcxmB3IcRkM3">Sources with ++</a> . </div><p>Source: <a href="https://habr.com/ru/post/242411/">https://habr.com/ru/post/242411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242395/index.html">Meet IntelliJ IDEA 14 here.</a></li>
<li><a href="../242397/index.html">Call center with ACD, skill groups and WebRTC client for handling incoming calls</a></li>
<li><a href="../242403/index.html">Microsoft Azure ‚ù§ Big Data</a></li>
<li><a href="../242407/index.html">Yahoo Mail Evolution</a></li>
<li><a href="../242409/index.html">LED control over the Internet using RaspberryPi</a></li>
<li><a href="../242413/index.html">Tinkoff Bank at a performance conference in C #</a></li>
<li><a href="../242415/index.html">New WebStorm 9: just better. Support for Meteor, React and JSX, integration with Gulp, PhoneGap and more</a></li>
<li><a href="../242417/index.html">Otkrytie Mobile Bank: development from reverse</a></li>
<li><a href="../242425/index.html">Jump Start in PowerShell (Part I)</a></li>
<li><a href="../242427/index.html">We use AngularJS in Windows Phone 8.1 applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>