<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How the memory is arranged NetApp FAS: NVRAM, Kesh and Tetris</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to look at the internal structure of the NetApp FAS storage system and how it can collect Tetris. 



 System memory 
 The stor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How the memory is arranged NetApp FAS: NVRAM, Kesh and Tetris</h1><div class="post__text post__text-html js-mediator-article">  In this article I want to look at the internal structure of the NetApp FAS storage system and how it can collect Tetris. <br><br><img src="https://habrastorage.org/files/e7b/bae/930/e7bbae9305fc4e5db5b05a5cd5aaf13e.jpg"><br><a name="habracut"></a><br><h2>  System memory </h2><br>  The storage memory of any NetApp FAS controller consists of RAM modules that are used for reading and writing caching, and are powered by a battery, hence the ‚ÄúNV‚Äù prefix - Non Volatile MEMory / RAM / LOG.  RAM is divided into the following functional parts: NVRAM, MBUF buffer (or system cache), which are more detailed. <br><br><img src="https://habrastorage.org/files/6ec/5d4/38a/6ec5d438a6ca472388c199391354b620.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      * Data is reset to disk <a href="https://habr.com/ru/post/280616/">from MBUF, according to the NVRAM full event</a> , and not from <a href="https://habr.com/ru/post/280616/">NVRAM</a> itself. <br><br><h2>  NVRAM &amp; NVLOG </h2><br>  NVRAM consistently, like LOG entries in the database, gathers NVLOG entries, in their original form, as they were sent by the hosts.  As soon as the data from the host enters NVRAM, the host receives a confirmation of the record.  After the CP event occurs, which generates a data reset <u>from the MBUF</u> to the disks, followed by confirmation, the NVRAM is cleared.  Thus, in a normally running storage system, the contents of NVRAM are never read, but only written, and when space ends there, a CP occurs and the NVRAM is cleared.  Reading NVRAM occurs only after a crash. <br><br><h2>  NVRAM to HA </h2><br>  In the High Availability (HA) pair, of two NetApp FAS controllers, NVRAM is always mirrored, each controller has a copy of its neighbor.  This allows in case of failure of one controller to switch and continue to service all hosts to the remaining controller.  After the CP event occurs (data is flushed to the confirmation disk), the NVRAM is cleared. <br><br>  To be more precise, each of these two parts is further divided into two parts, for a total of 4 for the HA pair (i.e., 2 local).  This was done to ensure that after filling in half of the local NVRAM, the data reset did not slow down the new incoming commands.  That is, while data is being reset from one part of the local NVRAM, new ones are already arriving in the second half of the local NVRAM. <br><br><img src="https://habrastorage.org/files/4b8/e15/9e3/4b8e159e34fe468aa19d9af6d7a0370f.png"><br><br><h2>  NVRAM to MCC </h2><br>  In order to protect data from Split-Brain in the <a href="https://habrahabr.ru/post/279989/">MCC</a> , the data that is received on the recording will be confirmed to the host only after they get into the NVRAM of one local controller, its neighbor and one remote neighbor (if the MCC consists of 4 nodes ).  Synchronization between local controllers is performed via HA Interconnect (this is an external connection for two-controller systems in two different chassis), and synchronization to a remote node is performed via FC-IV adapters (this is also an external connection).  This scheme allows you to perform switching within the site if the second HA controller of the pair is intact, or switch to the second site if all local storage nodes have failed.  Switching to the second site occurs in seconds. <br><br><img src="https://habrastorage.org/files/488/35c/803/48835c803f2342b8aa9b1243e5178b10.png"><br><br><h2>  NVRAM &amp; Pass-Through </h2><br>  It is important to note that NVRAM, on the one hand, is a technology that is not only in service with NetApp, but on the other hand, is used by NetApp to store logs (hardware implementation of a journaling file system), while most other storage vendors use NVRAM at the ‚Äúblock level‚Äù (Disk Driver level or Disk Cache) for caching data in NVRAM - this is a big difference. <br><br>  The presence of NVLOG allows NetApp FAS not to transfer in the HA pair, the surviving single controller to the Pass-Through mode (write, without cache, directly to the disks) if one of them died.  Let's dwell on this a bit and start with why we need a write cache at all?  The cache is needed to deceive the hosts and speed up the recording, it confirms the recording of the data before, how the data actually gets on the disks.  Why bother to switch the controller to Pass-Through mode, if the cache has a battery, while all A-brands of the storage system also have a cache mirroring in the HA pair?  The answer is not quite easy to see at a glance, first, the HA mechanism ensures that the data is not damaged and dumped onto the disks when one of the two controllers in the HA pair fails, and the clients transparently switch to the partner, secondly, the most important, in this case, that the data were not damaged at the level of the data structure of the storage itself, it is worthwhile to dwell on this in more detail.  Recalculation of check-sums for RAID, in memory, is not new for a long time, as it speeds up the disk subsystem, many if not all A-brands have mastered this trick, but it is the reset of data from the cache <u>in the already processed RAID-level</u> leaves the likelihood of data corruption which cannot be traced and restored after the restart of the <i>two controllers</i> .  So, if the first controller fails, and then the second controller fails, it may turn out that it is impossible to track the integrity of the initially received data as a result of processing, that is, the data may be damaged, in other situations it is possible to track and repair the damage, but for this it is necessary to start checking the data storage structure.  Since the write cache becomes a cornerstone and a potential big problem, when a single controller fails in an AT pair, most storage systems need to go into PassThrough mode with direct writing to discs by turning off the write cache to eliminate the likelihood of damage to their file structure. <br><br>  On the other hand, most of these storage systems allow the administrator to manually transfer the surviving controller manually to the record caching mode, but this is not safe, because if the second controller fails, the data at the file storage structure level may be damaged and will have to be restored. sometimes it can lead to tragic consequences.  Due to the fact that FAS systems store data in the form of logs, <i>and not in the processed form after WAFL or RAID</i> , and the already processed data is reset as rolling a system snapshot of CP, in a single transaction, this allows you to completely circumvent the probability of data corruption.  Thus, in many <u>modern</u> competing storage systems, when one controller dies in an HA pair, it is not only that the load from the dead controller drops to the second, it also disables its cache to optimize entries, which greatly impairs the speed in such situations.  This is done to ensure that the recorded data is accurately recorded in a non-corrupted form on the disks, and most importantly, the file structure of the storage system remains uncorrupted.  Some do not bother with this question at all and just honestly write about this ‚Äúnuance‚Äù in their documentation.  And some try to circumvent this problem with the help of a ‚Äúcrutch‚Äù, offering to buy not 4-node, but 4-node system at once.  So, for example, the HP 3PAR system is arranged, where in the event of a single controller failure, in the 4 node system, the remaining 3 controllers will work in normal recording mode, but in the event of a failure of 50% of the node, the system will go into Pass-through.  Sometimes there are funny situations when it is better that the entire storage system has already died, rather than that it works with such terrible brakes.  This contrasts with FAS systems, which even in single-channel configurations never turn off the cache, as they are architecturally protected from such problems. <br><br><h2>  <a href="https://habr.com/ru/post/280616/">Memory Buffer: Write</a> </h2><a name="MBUF"></a><br>  Writing, in fact, always happens in the MBUF (Write Memory Buffer).  And from it using the Direct Memory Access (DMA) request, NVRAM performs a copy of this data to itself, which saves CPU resources.  After that, the WAFL module allocates block ranges to which data from the MBUF will be written, this process is called Write Allocation.  The WAFL module does not just allocate mindlessly blocks, but first collects Tetris (oh yeah, <a href="https://cloud.mail.ru/public/DCR2/R6LmAunRx">Tetris! Did you not hear about it?,</a> Then look at the 28th minute), and allocate empty blocks, so as to be able to burn all Tetris on disks with one inseparable a piece. <br><img src="https://habrastorage.org/files/8c2/c56/d4a/8c2c56d4a0bd427f9b2bfbfff0323d4b.png"><br><br>  WAFL also performs other write optimizations for data.  After the record confirmation from NVRAM comes to the WAFL module, the data from the MBUF, according to the selected blocks, is processed by the RAID module, where the checksum for the pair of disks is calculated and the checksum is calculated, which is stored with each block (Block / Zone checksums).  It is also important to note that the data from MBUF being transferred to the RAID module is ‚Äúunpacked‚Äù, for example, some commands may request recording of a repeating pattern of information blocks or a request for moving blocks, such commands themselves do not take up much space in NVRAM, but when ‚Äúunpacking‚Äù generate a large amount of new data. <br><br><h2>  Write allocation </h2><br>  This is part of WAFL, which has undergone significant changes from its original device architecture, especially in terms of working with new information carriers and parallelization (the new architecture began to be delivered in 2011) and prepared a springboard for using new storage technologies that may appear in the near future.  Thanks to the intelligence of your device, Write Allocation allows you to granularly write data in different ways and to different places of the disk subsystem.  Each separate stream of recorded information is processed separately and can be processed, depending on how the data is written, read, the block size and the nature of the record (and others).  Based on the nature of the recorded WAFL data, it can decide on what type of media it is worth writing it in which way.  An example of this is Flash drives, where it makes sense to write with granularity and along block boundaries, which erase block size takes place.  In addition, meta information, which usually takes up a lot less space than the data itself, can be placed separately from large blocks with useful data, in some cases it has a great advantage, which was established experimentally.  In fact, the description of the internal device Write Allocation is a separate, very large topic. <br><br><h2>  <a href="https://habr.com/ru/post/280616/">RAID</a> </h2><a name="RAID"></a><br>  From the WAFL module, the data is transferred to the RAID module, which processes and <a href="http://www.netapp.com/us/media/tr-3001.pdf">writes them in one transaction, stripes</a> to disks, including parity disks.  And since the data is always written in stripes and always in a new place, the data for parity disks do not need to be recalculated, they were already prepared for recording by the RAID module.  Due to this, <i>in FAS systems in practice, parity disks are always much less loaded</i> than other disks, which contrasts with the usual implementation of RAID 4/6.  It is also worth noting that the check-sum calculation is performed immediately for the entire stripe of the recorded data, never overwriting the data (recording occurs to a new place), only the meta-information changes (links to new blocks with data).  This leads to the fact that in the case of overwriting one of the disks it is not necessary to read the information from the other disks into the memory each time and recalculate the check-sum, thanks to which the system memory is used more efficiently.  <a href="https://www.netapp.com/us/media/tr-3298.pdf">Read more about the device RAID-DP</a> . <br><br> <a href="http://www.netapp.com/us/media/tr-3001.pdf"><img src="https://habrastorage.org/files/de6/f0f/a23/de6f0fa23b6a4ddcada803d73a66b118.png"></a> <br><br><h2>  Tetris performs IO-reduction </h2><br>  Tetris is a write and read optimization mechanism that collects data, between CPs (CP Time Frame), into chains of blocks of sequences from one host, turning small blocks into larger sequential records (IO-reduction).  On the other hand, this allows, without complex logic, to include a preemptive reading of data.  So, for example, there is no difference - read 5KB, or 8KB, 13KB or 16KB, etc.  This logic is used to read ahead.  Read-ahead is a form of caching data that can potentially be requested in the future, followed by the data that has just been requested.  And when the question becomes, which ‚Äúextra‚Äù blocks should be read ahead of time for transferring to the cache, with Tetris, you automatically get an answer to this question: those that were recorded along with the requested data. <br><br><img src="https://habrastorage.org/files/525/3fc/577/5253fc57758c4d239e54dad8b017b02f.png"><br><br><h2>  Read cache </h2><br>  The system cache (MBUF) is used for both write and read operations.  All read operations without exception get into the cache, as well as the newly recorded data is read from it.  When the CPU of the storage system cannot find the data in the system cache, it accesses the disks, and the first thing it does is put it into the cache for reading, and then give it to the host.  Further, these data can be either simply deleted (the same read cache, everything is on disks) or moved to a level below (cache level II), if there is one: FlashPool (SSD drives, read-write cache) or FlashCache ( PCIe Flash card, read only cache).  First, the system cache, both the first and the second level, is pushed out very granularly: i.e.  4 KB block of information can be pushed out.  Secondly, the system and level II cache, it is deduplication-aware, i.e.  if such a block is duplicated or cloned, it will not be copied again and will take up space in the memory.  This significantly <a href="https://habrahabr.ru/post/280105/">improves performance by increasing cache hit.</a>  <a href="https://habrahabr.ru/post/280105/">This happens when the dataset on the storage system can be well prodduplitsirovany or cloned many times</a> , for example, in the VDI environment. <br><br><h2>  Consistency point </h2><br>  Like many modern file systems, WAFL is a journaling file system.  Like any journaling file system, a log with log entries is used to ensure consistency and its inherentness at the storage level.  While all other implementations of journaling file systems are designed in such a way that if they are damaged, they can roll back to a consistent state (it is necessary to check and restore) and try to recover, WAFL is designed so as to prevent damage in the event of a sudden failure of the controllers.  This is achieved, first of all, due to the atomicity of the Consistency Point recording, and secondly due to the use of system snapshots during write operations. <br><br>  NetApp technology has been so successful that ONTAP is literally everywhere, as a basis, for many other features and functions.  Let me remind you that CP contains data already <a href="https://habrahabr.ru/post/244923/">processed by WAFL</a> and RAID.  The CP is also a snapshot, which, before the contents are dumped from the system memory (after being processed by the WAFL and RAID modules), the data storage system removes the system snapshot from the unit, and adds new data to the disks, then the data storage system marks the data successfully. after which it clears NVLOG entries in NVRAM.  Before a new data is reset to disk (always to a new place), a system snapshot is taken, after which the data is either recorded as a whole in one transaction or (in case of an accident) the previously created snapshot is used (at the aggregate level) as the last working version of the file system in case of a sudden restart of the storage system in the middle of a transaction.  If a failure has occurred and both controllers have rebooted or have lost power, the data from NVRAM will restore all the information and reset the data to the disks as soon as the controllers are turned on again.  If only one controller turns off or reboots, the second controller from the copy of NVLOG to NVRAM will immediately restore the data and write it down, it will even happen transparently for the applications.  When data is successfully dumped onto disks, the last CP block, based on the old root inode (snepshot), creates a new one, including references to old and new, newly recorded data. <br><br><h3>  CP Generating Events </h3><br>  A CP is an event that is automatically generated under one of several conditions: <br><br><ul><li>  10 seconds passed </li><li>  Half NVRAM filled </li><li>  local MBUF filled (High Water Mark).  It is caused by the fact that one or several commands from the host generated a large amount of data for the CP, for example, recording a certain amount of information by repeating patterns. </li><li>  Controller stop command started (Halt) </li><li>  Other. </li></ul><br>  By the way, the CP reset status, very often, may indirectly indicate what problems exist in the storage system, for example, <a href="http://blog.aboutnetapp.ru/archives/199">when you do not have enough spindles or they are damaged</a> .  Learn more about working in an article on the <a href="https://kb.netapp.com/support/s/article/faq-consistency-point%3Flanguage%3Den_US">Knowledge Base FAQ: Consistency Point</a> . <br><br><h2>  Why is NVRAM size not always important? </h2><br>  As mentioned earlier, NVRAM is used in FAS systems as a storage of log records, rather than a write cache, so its size, in HDD and hybrid FAS systems, is not as large as its competitors.  Just to increase NVRAM is not necessary.  Each system is designed so that it has enough resources to service the maximum supported number of spindles. <br><br><h2>  Battery and Flash Disk </h2><br>  As already mentioned, the battery powers the system memory.  But it also powers the system flash disk installed in the controller.  In the event of a power failure, after that, the contents of the memory will be merged onto the system Flash-drive, so the storage system can live for a very long time in the off state.  Restore content to memory automatically when you start storage.  The battery can withstand up to 72 hours, and therefore, if the power is restored during this time, the contents will remain in the cache and recovery from the system Flash-drive will not occur. <br><br><h2>  <a href="https://habr.com/ru/post/280616/">SSD and WAFL</a> </h2><a name="SSD_and_WAFL"></a><br>  As mentioned earlier, WAFL always writes to a new place, this is done architecturally for a variety of reasons, and one of them is the job of resetting the MBUF contents as a snapshot.  After all, otherwise, in the case of physical rewriting of blocks - new ones, on top of old ones, with an incomplete cache reset transaction, this could lead to data corruption.  It turned out that the ‚Äúwrite to a new place‚Äù approach is very successful not only for rotating disks, and the snepshot mechanism, but also for Flash technologies, due to the need to evenly dispose of all the cells of SSD disks. <br><br><h2>  findings </h2><br>  NetApp FAS RAM not only accelerates read and write operations, but is also architecturally designed to provide high reliability, speed and optimization for such operations.  Rich functionality, multiple protection and system cache speed are qualitatively distinguished by A-class systems, for high productive loads and critical tasks. <br><br>  English translation <br>  How memory works in ONTAP: <br><ul><li>  <a href="https://wp.me/p9LTcx-2H">NVRAM / NVMEM (Part 1)</a> </li><li>  <a href="https://wp.me/p9LTcx-2E">NVRAM / NVMEM &amp; Write-Through (Part 2)</a> </li><li>  <a href="https://wp.me/p9LTcx-2S">Write Allocation, Tetris, MBUF &amp; CP (Part 3)</a> </li></ul><br><br>  <b>This may contain links to Habra articles that will be published later</b> . <br>  <b>I ask to send messages on errors in the text to the <abbr title="Private message">LAN</abbr></b> . <br>  <b>Comments, additions and questions on the article on the contrary, please in the comments</b> . </div><p>Source: <a href="https://habr.com/ru/post/280616/">https://habr.com/ru/post/280616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280604/index.html">Legend of international avos</a></li>
<li><a href="../280606/index.html">Collection and analysis of the logs of demons in Badoo</a></li>
<li><a href="../280608/index.html">Tuples in programming languages. Part 2</a></li>
<li><a href="../280610/index.html">The tale of Tsar Saltan about the potential of the Laplacian</a></li>
<li><a href="../280614/index.html">Cisco Routermate</a></li>
<li><a href="../280618/index.html">Exploratory testing: when to use it and how to do it</a></li>
<li><a href="../280622/index.html">Build 2016 conference text translation - second day</a></li>
<li><a href="../280624/index.html">Stand EAST 4 SCADA: how to arrange an accident on the railway</a></li>
<li><a href="../280626/index.html">Apple Developer Center certification in simple and clear language</a></li>
<li><a href="../280628/index.html">C ++ Russia 2016 at ++ 5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>