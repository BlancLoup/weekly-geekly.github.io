<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pro Rendering Optimization - With Optimism</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have a dream, and it is utopian: I want my web applications to work perfectly. JQuery, AngularJs, React, Vue.js - all promise performance. But the p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pro Rendering Optimization - With Optimism</h1><div class="post__text post__text-html js-mediator-article">  I have a dream, and it is utopian: I want my web applications to work perfectly.  JQuery, AngularJs, React, Vue.js - all promise performance.  But the problem is not in frameworks and not in JavaScript.  The problem is how the browser renders the page.  And he does it very badly. <br><br>  If the browser did a great job with rendering, then a tool like React Native would not have appeared.  Under the hood, React Native is still the same JavaScript, and View is native, and the difference in performance between the native application and the application on React Native will not be noticeable for the average user.  In other words, the problem is not in javascript. <br><br>  If something to optimize, then just rendering.  The tools that JavaScript and the browser API give us are not enough.  For two years I have been trying to make the work of my products smooth and fast, but in vain.  I am almost resigned to the fact that the web will remain so forever.  In this article, I collected everything that I managed to learn about rendering optimization and apply it on projects I worked on and talk about my hopes for the near future.  This is the future in which I want to rely on a solid foundation of standards and browser APIs, rather than CSS hacks and third-party repositories for optimizing performance. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/8a3/c28/182/8a3c2818258149c69b991eac5c6f8f10.jpg"><br><a name="habracut"></a><br><h2>  Hybrid Applications and Performance </h2><br>  I wrote applications with rather trivial functionality: news feeds with comments, categories and tags.  They can watch videos, do a search for news, etc.  Well, more push notifications.  Nothing complicated.  Because of the NDA, I can‚Äôt show you these projects, but in our company's blog <a href="http://livetyping.com/ru/blog/cross-platform-vs-native-apps-comparing-and-selecting-approaches">we talk about the principles for choosing an approach to mobile development</a> . <br><br>  The development of hybrid applications is good.  JavaScript completely suited me, completely suited me and interface elements that were generously provided by Framework7 and Ionic.  Even plug-ins that allow the use of native functions, enough.  Write one application and get ten at once - for all the platforms that you just invented.  Dream and only.  But now there will be a ‚Äúbut‚Äù, fat and putting an end to everything. <br><br>  <b>As soon as the application becomes more complicated than ‚ÄúHello, world!‚Äù, Performance problems begin.</b>  <b>The application works better than the mobile version of the site, but not nearly as good as a similar native application.</b> <b><br></b> <br><br><img src="https://habrastorage.org/files/5e8/05f/4a0/5e805f4a061f485ab10b53bf5fff7ed2.gif"><br><br>  If someone is ready to put up with it, then for me it was a challenge.  I needed to write a hybrid application so that it could not be distinguished from the native one.  Then I rummaged a bit and came to one simple conclusion: everything is fine with js, the problem is rendering.  I tried all the css hacks from ‚Äútransform: translate3d (0,0,0)‚Äù (which soon stopped working) and before replacing png gradients with alpha channel.  This, of course, did not solve the problem, but only slightly masked it.  The links are several such hacks: <br><br>  ¬ª <a href="https://davidwalsh.name/translate3d">Force Hardware Acceleration in WebKit with translate3d</a> <br>  ¬ª <a href="https://www.thecssninja.com/javascript/pointer-events-60fps">60fps scrolling using pointer-events: none</a> <br>  ¬ª <a href="http://nerds.airbnb.com/box-shadows-are-expensive-to-paint/">CSS box-shadow Can Slow Down Scrolling</a> <br><br>  After that I worked on other projects not related to mobile browsers and devices.  And everything is not bad, there are no performance problems, because where do they come from in a car with a good iron.  But if performance problems are not visible, this does not mean that everything is optimized. <br><br><h2>  Medium, you have problems </h2><br>  On websites and in applications, we see endless tapes: Instagram, Facebook, Twitter, Medium - from these examples, perhaps, you can make your tape with the upload.  And there is nothing wrong with that.  Scroll allows you to move within one post and move between posts.  You can scroll quickly, you can slowly.  You add new items to the list as much as you like.  I did it myself. <br><br><img src="https://habrastorage.org/files/244/c3f/284/244c3f28470b4086b8c6c31b3ee9542e.gif"><br><br>  Let's do an experiment.  Do you have a noisy cooler?  Open Medium.com and go down.  How soon will your cooler reach its maximum speed?  My result is about 45 seconds.  And this is not Chrome to blame.  And not even that my laptop for many years.  The problem is that no one is optimizing what we see in the viewport. <br><br>  What happens when we shake a ribbon?  Once at the bottom of the page, we get some more posts from the server, and they are added to the end of the list.  The list grows endlessly.  What does the browser do?  Nothing.  Posts at the beginning of the feed still exist and the browser still renders them.  And ‚Äúvisibility: hidden‚Äù will not help here, even if we hang this property on every post that is outside of the viewport.  By the way, such a useless optimization was noticed by me in Ionic.  Seriously.  But then they fixed it.  If anyone is interested, here is the <a href="https://forum.ionicframework.com/t/does-collection-repeat-really-help/31826">topic on the Ionic forum</a> , which I created to discuss the problem. <br><br><h2>  Mysterious world of optimization </h2><br><br><img src="https://habrastorage.org/files/520/360/f0d/520360f0d7b74feab0937ec6fee3aa2e.png"><br><br>  What prevents to write good, optimized code?  It‚Äôs disturbing that we don‚Äôt know so much about this process.  Most of the knowledge came to us through trial and error, and articles with a title like "How the browser renders the page" tell us how HTML is combined with CSS and how the page is divided into layers.  I don‚Äôt understand what happens when I add a new element to the DOM or add a new class to the element.  What elements will be recalculated and rendered? <br><br>  Here we will add a new item to the list.  What's next? <br><br><ol><li>  A new item needs to be rendered and put in place; </li><li>  need to re-move the other elements of the list; </li><li>  need to re-render other list items; </li><li>  need to update the height of the "parent"; </li><li>  the ‚Äúparent‚Äù has been updated, and now it is not clear whether the neighboring elements have changed. </li></ol><br>  And so on to the root of the DOM.  As a result, we render the entire page. <br><br>  Rendering in the browser works differently.  <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">Here is</a> one of the many articles on this topic, where the author talks about the process of combining the DOM tree and the CSS tree and how the browser subsequently draws the resulting structure.  Everything is very cool, but it‚Äôs not entirely clear what the developer can do to help the browser.  There is an unofficial <a href="https://csstriggers.com/">CSS Triggers</a> resource that presents a table that allows you to determine which CSS properties call Layout / Paint / Composite processes in the browser, but since pages usually contain a large number of styles and elements, the only sensible solution is to try to eliminate everything. which can hit on performance. <br><br>  In general, optimization consists of several points: <br><br><ul><li>  <a href="https://css-tricks.com/efficiently-rendering-css/">make it easier to CSS</a> , make the styles readable for the browser; </li><li>  get rid of heavy rendering styles (shadows and transparency should be avoided altogether); </li><li>  reduce the number of DOM elements and make as few changes as possible in it; </li><li>  Work properly with the GPU. </li></ul><br>  All this helps to speed up the rendering a bit, but what to do if you want more? <br><br><h2>  Cutting off the excess </h2><br><br><img src="https://habrastorage.org/files/59e/dd7/656/59edd7656c4c4b6385f75c6574dabd70.jpg"><br><br>  It seems to me that the only way that really works is to ensure that the page contains only those elements that the user really needs.  Implementing this behavior is problematic. <br><br>  Many people know about Virtual list / Virtual scroll / Grid View / Table View.  The names are different, but the essence is the same: it is a component for efficiently displaying very long lists on a page.  Mostly similar interface components are used in mobile development. <br><br>  GitHub is full of js repositories a la virtual list, virtual grid, etc.  Optimization is quite working, it is a fact.  In the list of 10 thousand elements, you can create a container with a length of 10,000 px multiplied by the height of one element, then follow the scroll and render only the elements visible to the user plus a little more.  The elements themselves are positioned using ‚Äútranslate: transformY (&lt;element index&gt; * &lt;element height&gt; px)‚Äù.  I recently studied Vue.js 2.0 and wrote such a component in a couple of hours. <br><br>  There are several options for implementation, and the difference between them is only in how we position the elements and divide them into groups, but this is not so important.  The problem is that the scroll event under ideal conditions is triggered exactly as many times as the pixels were scrolled.  That is a lot.  Add to this the need to make calculations every time an event triggers.  On mobile devices, the scroll event and the scroll mechanics itself work in different ways.  The conclusion of this is quite simple: the scroll event is not well suited for such tasks. <br><br>  Here it is worth mentioning another problem.  All the components that I saw require that the size of the list items be the same or, at best, be known in advance for each item.  This complicates implementation. <br><br><h2>  IntersectionObserver </h2><br><br><img src="https://habrastorage.org/files/8c0/37d/c90/8c037dc9056540b689dfbb5897d91560.png"><br><br>  Now IntersectionObserver, the first ray of hope, which fell on the future that I described in the introduction, comes onto the scene.  The feature is new, so here is information about browser support on <a href="http://caniuse.com/">caniuse.com</a> .  And here are some materials on it: <br><br><ul><li>  <a href="https://wicg.github.io/IntersectionObserver/">draft specification</a> </li><li>  <a href="https://github.com/WICG/IntersectionObserver">repository with draft specification, explanation with examples and polyfill</a> </li><li>  <a href="https://developers.google.com/web/updates/2016/04/intersectionobserver">featured article on google blog</a> </li></ul><br>  IntersectionObeserver reports when the element of interest appears in the viewport and when it leaves.  Now you do not need to keep track of the scroll and count the height of the elements in order to understand which of them need to be rendered and which are not. <br><br>  Now a little practice.  I wanted to make a virtual scrolling with loading elements using IntersectionObserver.  Something like this: <br><br><ul><li>  endless tape with posts that have a title, picture and text; </li><li>  the content of posts and their height are not known in advance; </li><li>  no stops for content uploading; </li><li>  60 fps. </li></ul><br>  But what I understood while writing this component: <br><br><ul><li>  need to reuse elements, producing a minimum of operations with DOM; </li><li>  You do not need to create IntersectionObserver for each item in the list, two is enough. </li></ul><br><br><h3>  Principle of operation </h3><br>  Content is divided into parts of 12 posts each.  When the component is initialized, there is only one such part in the DOM.  The first and last parts have a hidden element at the top and bottom, respectively.  We monitor the visibility of these elements.  When one of these elements falls on the screen, we add a new part and delete the already unnecessary.  Thus, we have in DOM two parts of 12 posts at a time. <br><br>  How is it easier to track the scroll?  If the height of the posts is unknown, you have to look for an element in the DOM and recognize it.  This is not very convenient and not very productive. <br><br>  At the output, we get a component that can quickly render endless content of an unknown height in advance.  You can use something like this not only for news feeds, but also for any content consisting of blocks. <br><br>  Less words more action: here is a <a href="https://dmitryskripkin.github.io/vue-virtual-scroll-demo/">demo</a> .  And I ask you to pay attention to the fact that the goal here is to see the work of IntersectionObserver on a real example. <br><br>  Here you can look at the FPS, if you scroll with the speed of a quick view of the tape (the image is clickable): <br><br> <a href=""><img src="https://habrastorage.org/files/7aa/cc0/e69/7aacc0e692f143719e164f363fe3c70d.png" alt="image"></a> <br><br>  And as quickly as possible (the image is clickable): <br><br> <a href=""><img src="https://habrastorage.org/files/2bb/fe6/2cd/2bbfe62cd54046679c9baf1a5add3ea2.png"></a> <br><br>  FPS very rarely falls below 60, but only a couple of frames and no less than 45. A good result, given that the browser does not know the size of the pictures and text in advance. <br><br><h2>  Conclusion </h2><br>  This is not the most impressive and useful example of using IntersectionObserver.  It is much more interesting to try to use it in conjunction with React / Vue / Polimer components.  Then, when the component is initialized, IntersectionObserver can be hung onto it and continue initialization only when it appears in the viewport.  This opens up opportunities.  It remains only to cross your fingers and believe that IntersectionObserver will receive its further development. </div><p>Source: <a href="https://habr.com/ru/post/316136/">https://habr.com/ru/post/316136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316124/index.html">Better in RainTime than never: Extend the JIRA API on the fly</a></li>
<li><a href="../316126/index.html">Interweaving the narrative into the procedural worlds</a></li>
<li><a href="../316128/index.html">TCP puzzles</a></li>
<li><a href="../316132/index.html">Google Chrome Developer Console: Ten Unobvious Utilities</a></li>
<li><a href="../316134/index.html">How to make the presentation interactive</a></li>
<li><a href="../316138/index.html">Call Transfer Using Script in Asterisk</a></li>
<li><a href="../316140/index.html">How to test a legacy without pain and fear</a></li>
<li><a href="../316142/index.html">How we built a cloud backend for a mobile shooter</a></li>
<li><a href="../316144/index.html">Ambient Occlusion Volumes for burnt samovars</a></li>
<li><a href="../316146/index.html">FlyElephant celebrates its first year of public access and announces cooperation with HPC-HUB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>