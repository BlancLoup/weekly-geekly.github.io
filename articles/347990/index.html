<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In a section: the news aggregator on Android with backend. Distributed Message Processing Systems (Spark, Storm)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction (with links to all articles) 



 The main component of the system that processes raw data from ‚Äúspiders‚Äù performs data enrichment, their...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In a section: the news aggregator on Android with backend. Distributed Message Processing Systems (Spark, Storm)</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/334510/">Introduction (with links to all articles)</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c02/efb/062/c02efb06223c905f64f9be990f9246cc.png" alt="image"><br><br>  The main component of the system that processes raw data from ‚Äúspiders‚Äù performs data enrichment, their indexing and subsequent search is the message processing system, since  Only such systems can adequately respond to peak loads of input data, the shortage of certain types of resources and can be easily horizontally scalable. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When analyzing the future use of the system processing requests or incoming data, the following requirements were highlighted: <br><br><ul><li>  Low latency (processing) of the message; </li><li>  The ability to obtain data from different sources (DB, message middleware); </li><li>  Ability to process data on multiple nodes; </li><li>  Fault tolerance to node failure situations; </li><li>  Support for the level of guaranteed processing of the message "at-least-once"; </li><li>  The presence of an interface to monitor the status of the cluster and to manage it (at least partially). </li></ul><br>  As a final solution, the Apache Storm framework was chosen.  For Apache Spark fans: given the prevalence of this framework (using Spark Streaming or now Spark Structured Streaming), all further narration will be built in comparison with the Apache Spark functionality. <br><a name="habracut"></a><br>  Taking into account the fact that both systems have highly intersecting sets of functions, the choice was not easy, however, since  More control over the processing of each message remains for Apache Storm - the choice was made in its favor.  Then I will try to explain what is the difference, what is the similarity of frameworks and what means "greater control over the processing of each message." <br><br><h3>  Basic concepts </h3><br>  Next, I will try to briefly tell you about the basic steps of placing and executing your code in a cluster. <br><br>  The ready code for each system is loaded into the cluster using special utilities (specific for each framework), while the ready code in both cases is uberjar / shadowJar (ie, the jar file containing all the necessary dependencies, except for the framework itself, of course).  In both cases, the entry point classes and the code operation parameters are specified (as one of the possible utility keys). <br>  Next, your code is converted to topology for Apache Storm and an application for Apache Spark. <br><br><h4>  Apache Storm Topology </h4><br>  You declare the topology at your entry point in a similar way: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HeatmapTopologyBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StormTopology </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TopologyBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TopologyBuilder(); builder.setSpout(<span class="hljs-string"><span class="hljs-string">"checkins"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Checkins()); builder.setBolt(<span class="hljs-string"><span class="hljs-string">"geocode-lookup"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GeocodeLookup()).shuffleGrouping(<span class="hljs-string"><span class="hljs-string">"checkins"</span></span>); builder.setBolt(<span class="hljs-string"><span class="hljs-string">"heatmap-builder"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HeatMapBuilder()).globalGrouping(<span class="hljs-string"><span class="hljs-string">"geocode-lookup"</span></span>); builder.setBolt(<span class="hljs-string"><span class="hljs-string">"persistor"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Persistor()).shuffleGrouping(<span class="hljs-string"><span class="hljs-string">"heatmap-builder"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builder.createTopology(); } }</code> </pre> <br>  everything is converted to something similar (Apache Spark topology): <br><br><img src="https://habrastorage.org/webt/mx/_j/fd/mx_jfdnsndamka15j30ppsgw7ya.png" alt="image"><br><br>  As a result, we have a graph (possibly containing cycles), on whose branches Tuples run (data packets or messages are indicated on the graph), where each node is either a Tuple source - Spout, or their Bolt handler. <br><br>  When creating a topology, you determine which Spout / Bolt will participate in its work, how they are interconnected, how messages are grouped within a cluster based on keys (or not grouped at all).  As a result, you can merge, split, transform your messages (executing external interactions or not), swallow, cycle through, run into named threads (links between cluster members have a ‚Äúdefault‚Äù thread, but you can create your own named , for example, for packages requiring long processing). <br><br>  In this case, all this movement is reflected and taken into account in the statistics and metrics of "Storm UI" - a web application for tracking the status of the cluster.  Next, a few screenshots: <br><br><img src="https://habrastorage.org/webt/3k/71/ds/3k71ds3k6z2vna9ipud7as2nfxc.png"><br><br><img src="https://habrastorage.org/webt/bm/e3/qo/bme3qoklrd3t9w3zdwei3qsudvk.png"><br><br><img src="https://habrastorage.org/webt/dd/yo/sv/ddyosvpuwv7yx9bg661ebzb3uw4.png"><br><br><h4>  Apache Spark application </h4><br>  You declare the application at your entry point in a similar way (here we will only talk about Spark Streaming): <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// Create a StreamingContext with a 1-second batch size from a SparkConf val ssc = new StreamingContext(conf, Seconds(1)) // Create a DStream using data received after connecting to port 7777 on the // local machine val lines = ssc.socketTextStream("localhost", 7777) // Filter our DStream for lines with "error" val errorLines = lines.filter(_.contains("error")) // Print out the lines with errors errorLines.print()</span></span></code> </pre><br>  This all translates into something like ‚ÄúRecipient (Receiver) + Apache Spark Code + Output Operators‚Äù: <br><br><img src="https://habrastorage.org/webt/dr/gf/cl/drgfclu7po6mim_jdfywzpqcb9y.png"><br><br>  As a result, we have: <br><br><ul><li>  Your control code (driver), which coordinates the execution of the Apache Spark application; </li><li>  Receiver (in the case of Spark Streaming), which reads data from the source and forms the RDD series; </li><li>  Acyclic graphs (generated by driver code) running on cluster nodes, representing the processing and generation of new RDDs. </li></ul><br>  In this case, all this is reflected and taken into account in the statistics and metrics of "Spark UI" - a web application for tracking the status of the cluster.  Next, a few screenshots: <br><br><img src="https://habrastorage.org/webt/jp/us/v-/jpusv-gsojuuzfx2uwjtmy8kt0w.png"><br><br><img src="https://habrastorage.org/webt/z2/wf/co/z2wfcommcsx03xqfwg7c7tfj5uq.png"><br><br><img src="https://habrastorage.org/webt/ql/da/vc/qldavc2wvlxcsqjnt3-km_byl-u.png"><br><br>  As can be seen, despite the common goal, the ways of forming the processing paths and the final structures are completely different in ideology, which ultimately leads to even greater differences in the implementation. <br><br><h3>  Running an Apache Storm topology and an Apache Spark application in a cluster </h3><br><h4>  Apache Storm Cluster </h4><br>  After uploading your code to the Apache Storm cluster control machines (nimbus, analogous to Cluster Manager) from the Java entry point code using the APache Storm API, the topology and information about its execution are generated: <br><br><ul><li>  how many tasks; </li><li>  what level of concurrency; </li><li>  what connections between message handlers should be made; </li><li>  what parameters of the cluster should be specific to this particular topology; </li><li>  how many Workers should be created, etc. </li></ul><br>  All this information and your code (jar files) are sent to other nodes, where the necessary elements of your topology are created (instances of classes that implement message generators (Spout) and processors (Bolt)) and additional configuration of nodes is performed.  After this, the topology is considered to be expanded and work begins in accordance with the specified cluster configuration and topology. <br><br>  Screenshot of working topology from Storm UI: <br><br><img src="https://habrastorage.org/webt/zw/2x/n8/zw2xn8q1pjjshlzu1tl_qha846s.png"><br><br>  From the cluster / topology configuration levers, you have parameters that affect: <br><br><ul><li>  how many instances of Spout / Bolt within the terms of the Apache Storm topology (worker / executor / task) will be launched in the cluster; </li><li>  how they can be distributed between nodes (not directly of course, but through their abstractions); </li><li>  what are the sizes of buffers in the elements; </li><li>  What is the number of unprocessed messages and how long can it ‚Äúwalk‚Äù in a cluster? </li><li>  cluster braking on options when abruptly filled with ‚Äúbackpressure‚Äù messages; </li><li>  adjusting the debug level; </li><li>  the frequency of statistics collection (for an incoming stream of 100,000 messages per second, take into account each ‚Äî an extra load), etc. </li></ul><br><h4>  Apache Spark Cluster </h4><br>  After loading your code into the cluster, an application is created that is executed by the driver (driver), which forms a large number of processing graphs RDD (directed acyclic graph, DAG) -&gt; DAG is divided into job (action) in the form of "collect", "saveAsText", etc) -&gt; stages are formed from the job (stage) (transformations for the most part) -&gt; stage is divided into task (minimum units of work on the partition (partition)). <br><br><img src="https://habrastorage.org/webt/cf/p_/bj/cfp_bjivycjucikl4oycjbiqjqo.png"><br><br>  Next comes the scheduler, which distributes tasks and data across the cluster nodes.  Your application code is present in the driver and code snippets sent to nodes for performing transformations / actions. <br><br>  From the cluster / topology configuration levers you have: <br><br><ul><li>  limits on memory usage; </li><li>  the number of cores; </li><li>  timeouts for data availability (data locality); </li><li>  scheduler operation algorithms (FIFO / FAIR), etc. </li></ul><br>  Of course, the possibilities for working with resources may differ from the resource manager depending on the type of cluster. <br><br>  In the end, it turns out that Apache Spark is focused on processing data streams, taking into account their consideration as a set, with analysis and processing them in the context of other messages for a certain period of time or in general all received during processing.  While Apache Storm treats each message as a separate entity and processes it the same way.  In the case of Trident-topologies, where the formation of micro packets (micro batching) takes place, this statement does not change much because  batching is a means of minimizing service traffic and unnecessary connections to each message.  From here we get different cluster architectures, different message processing entities and how they work in Apache Storm and Apache Spark. <br><br>  As a result, it turns out that approaches to resource management in a cluster reflect the level of abstraction over the processing process (‚Äúhigher abstraction means less influence‚Äù). <br><br><h3>  Current project topologies </h3><br><img src="https://habrastorage.org/webt/g1/wk/be/g1wkbeytvbwaqtbdj1mvadvo8be.png"><br><br>  As you can see, the current topologies are also linear (the algorithm is quite simple) and broken down according to the principle ‚Äúseparate source - separate topology‚Äù in order to simplify management and update topologies on a cluster. <br><br><h3>  Additional features of Apache Storm </h3><br><h4>  DPRC (Distributed RPC) </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/c59/4c2/f9e/c594c2f9e2f36305866e0b6f8650b0fb.png" alt="image"><br>  An interesting feature of Apache Storm is DPRC (Distributed RPC): the ability to make calls to methods that are actually handled by the cluster.  The specified functionality is used when implementing a REST client, whose responses are later cached by Nginx. <br><br>  The operation scheme is simple: a daemon receiving requests and buffering them -&gt; special Spout, sending requests to the topology -&gt; invisible collectors, sending data and removing requests from the input buffer.  As a result, we get a simple, but powerful tool, thanks to which the processing of the request can be performed on the cluster, while for the caller it is just an RPC call. <br><br>  Despite the lack of such a solution in Apache Spark (I know), I think that the implementation is not too complicated. <br><br><h4>  Trident </h4><br>  Trident is a high-level abstraction for performing real-time computation using Apache Storm primitives.  This makes it easy to combine high bandwidth (millions of messages per second), processing streams with state tracking with low latency distributed queries.  If you are familiar with high-level batch processing tools such as Pig or Cascading, Trident concepts will be very familiar ‚Äî Trident has connections, aggregates, grouping, functions, and filters (essentially the same abstractions as Apache Spark RDD).  In addition to this, Trident adds primitives to perform incremental processing with state tracking on top of any database or storage.  Trident has a consistent, ‚Äúexactly-once‚Äù semantics, therefore, it is quite easy to understand the work of the topology implemented on it. <br><br>  The disadvantages of Trident can only be called a more complex relationship between the code of your topology and what Spout / Bolt will be created. <br><br>  Trident allows you to write about this code: <br><br><pre> <code class="java hljs">TridentState urlToTweeters = topology.newStaticState(getUrlToTweetersState()); TridentState tweetersToFollowers = topology.newStaticState(getTweeterToFollowersState()); topology.newDRPCStream(<span class="hljs-string"><span class="hljs-string">"reach"</span></span>) .stateQuery(urlToTweeters, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"args"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MapGet(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"tweeters"</span></span>)) .each(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"tweeters"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExpandList(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"tweeter"</span></span>)) .shuffle() .stateQuery(tweetersToFollowers, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"tweeter"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MapGet(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"followers"</span></span>)) .parallelismHint(<span class="hljs-number"><span class="hljs-number">200</span></span>) .each(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"followers"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExpandList(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"follower"</span></span>)) .groupBy(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"follower"</span></span>)) .aggregate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> One(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"one"</span></span>)) .parallelismHint(<span class="hljs-number"><span class="hljs-number">20</span></span>) .aggregate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Count(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Fields(<span class="hljs-string"><span class="hljs-string">"reach"</span></span>));</code> </pre><br>  and get something like this topology: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a9/462/1ad/5a94621ad6edb9922ab7c10293d3a88e.png" alt="image"><br><br><h3>  Advantages of Apache Storm: </h3><br><ul><li>  Integration with a large number of data sources (databases, message brokers - Kafka, HBase, HDFS, Hive, Solr, Cassandra, JDBC, JMS, Dredis, Elasticsearch, Kinesis, Kestrel, MongoDB ....); </li><li>  The presence of a special language with high-level functions for working with messages (Trident); </li><li>  Availability of load control tools (Resource Aware Scheduler); </li><li>  Detailed control over the level of parallelism (which, on the other hand, entails an understanding of the operation of the elements of topology and the system's response to a sharp increase in the amount of incoming data); </li><li>  SQL query support for processed data (experimental function similar to Apache Spark SQL); </li><li>  Support for other non-JVM languages; </li><li>  Cluster deployment support (YARN, Mesos, Docker, Kubernetes). </li></ul><br><h3>  Disadvantages of Apache Storm: </h3><br><ul><li>  Implementation on Clojure (this I think is a plus and a minus of this aspect).  However, plans for the further development of Apache Storm talk about plans for the transition in version 2.0 to the implementation of Java.  First of all, to increase the commitments base (the more, the better each version and the faster the product development takes place); </li><li>  Lack of information about the framework - information (articles, books, videos) is frankly significantly less than Apache Spark; </li><li>  More complicated from my point of view, the architecture - as a result, the steeper curve of the training of developers: a higher probability to make a mistake, someone may not have enough knowledge / perseverance to overcome the framework. </li></ul><br><h3>  Comparison results of Apache Spark and Apache Storm </h3><br>  As Apache Spark (Spark Streaming) and Apache Storm have already become clear, things are different and it‚Äôs wrong to compare them head-on, due to differences in the mass of aspects, first of all in the way of forming input data for processing: Apache Spark (micro-batch) and Apache Storm Core (per-message) (a comparison of Apache Spark and Apache Storm's Trident is more appropriate here). <br><br><ul><li>  <b>Reaction speed (latency, not throughput):</b> there are no official performance comparisons recognized by both parties, but most talk about seconds for Apache Spark and fractions of seconds for Apache Storm; </li><li>  <b>Processing principles:</b> Apache Storm - a stream processing framework that also performs micro-batching (Apache Storm's Trident), Apache Spark - a batch processing framework that also performs micro-batching (Spark Streaming); </li><li>  <b>Languages:</b> Apache Storm is more diverse in the number of languages ‚Äã‚Äãfor implementing handlers, not only JVM-based, Python and R - as is the case with Apache Spark; </li><li>  <b>Message processing guarantees:</b> Of the three semantics of ‚Äúat-most-once‚Äù, ‚Äúat-least-once‚Äù and ‚Äúexactly-once‚Äù, Apache Spark supports ‚Äúout of the box‚Äù only ‚Äúexactly-once‚Äù; </li><li>  <b>Fault tolerance:</b> none of the frameworks gives a 100% guarantee of missing messages for all sources (for this, sources must meet a series of conditions, must be reliable and durable, such as Kafka. Also it is necessary to take into account that checkpoints on HDFS make their own delay - reduce latency, which may lead to a decision to disable them for some scenarios). </li></ul><br>  In the bottom line, we have 2 frameworks with their own features, the specifics of which must be taken into account in order to make the right decision. <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/347990/">https://habr.com/ru/post/347990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347980/index.html">Is it possible to use C ++ instead of C for small projects in microcontrollers?</a></li>
<li><a href="../347982/index.html">Event digest for HR specialists in IT-field for February 2018</a></li>
<li><a href="../347984/index.html">From prototype to production on Kickstarter: $ 100,000 is not enough</a></li>
<li><a href="../347986/index.html">Mobile App Auto-Test Tools Guide</a></li>
<li><a href="../347988/index.html">Open lesson on the topic "Areas of knowledge of marketing and TV + Search"</a></li>
<li><a href="../347992/index.html">False alarms. New technique of catching two birds with one stone</a></li>
<li><a href="../347994/index.html">UX research and evidence strength</a></li>
<li><a href="../347996/index.html">Parsing sites or long-term construction of the Moscow region</a></li>
<li><a href="../347998/index.html">We integrate TeamCity with JIRA - without plug-ins and administrators</a></li>
<li><a href="../348000/index.html">Convolutional neural network, part 1: structure, topology, activation functions and training set</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>