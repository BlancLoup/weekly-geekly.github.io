<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to work with Postgres in Go: practices, features, nuances</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The unexpected behavior of the application in relation to working with the database leads to a war between the DBA and the developers: DBA shout: "You...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to work with Postgres in Go: practices, features, nuances</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/yg/8e/hm/yg8ehmpmicsm7ye6fwju6kwog14.png"></p><br><p>  The unexpected behavior of the application in relation to working with the database leads to a war between the DBA and the developers: DBA shout: "Your application drops the database", the developers - "But everything worked before!"  Worst of all, DBA and developers cannot help each other: some do not know about the nuances of the application and driver, others do not know about the features related to the infrastructure.  It would be nice to avoid such a situation. </p><br><p>  You have to understand, it is often not enough to look through <a href="http://go-database-sql.org/">go-database-sql.org</a> .  It is better to arm yourself with other people's experience.  Even better if it is an experience gained by blood and lost money. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Uojy57I-xP0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  My name is <a href="https://www.facebook.com/furdarius">Ryabinkov Artemy</a> and this article is a free interpretation of my report from the <a href="https://www.highload.ru/">Saints HighLoad 2019</a> conference. </p><br><h1 id="instrumenty">  Instruments </h1><br><p>  You can find the minimum necessary information on how to work with any SQL-like database in Go at <a href="http://go-database-sql.org/">go-database-sql.org</a> .  If you have not read it, read it. </p><br><h2 id="sqlx">  sqlx </h2><br><p>  In my opinion, the power of Go is simplicity.  And this is expressed, for example, in that it is customary for Go to write queries in bare SQL (ORM is not in honor).  This is both an advantage and a source of additional difficulties. </p><br><p> Therefore, taking the standard <code>database/sql</code> language package, you will want to expand its interfaces.  Once that happens, take a look at <a href="https://github.com/jmoiron/sqlx">github.com/jmoiron/sqlx</a> .  Let me show you a few examples of how this extension can simplify your life. </p><br><p>  Using <a href="https://godoc.org/github.com/jmoiron/sqlx">StructScan</a> eliminates the need to manually shift data from columns into structure properties. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Place <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Country <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> City sql.NullString TelephoneCode <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`db:"telcode"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place err = rows.StructScan(&amp;p)</code> </pre> <br><p>  Using <a href="https://godoc.org/github.com/jmoiron/sqlx">NamedQuery</a> allows you to use structure properties as placeholders in a query. </p><br><pre> <code class="go hljs">p := Place{Country: <span class="hljs-string"><span class="hljs-string">"South Africa"</span></span>} sql := <span class="hljs-string"><span class="hljs-string">`.. WHERE country=:country`</span></span> rows, err := db.NamedQuery(sql, p)</code> </pre> <br><p>  Using <a href="https://godoc.org/github.com/jmoiron/sqlx">Get</a> and <a href="https://godoc.org/github.com/jmoiron/sqlx">Select</a> allows you to get rid of the need to manually write loops that get rows from the database. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p Place <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pp []Place <span class="hljs-comment"><span class="hljs-comment">// Get   p     err = db.Get(&amp;p, ".. LIMIT 1") // Select   pp   . err = db.Select(&amp;pp, ".. WHERE telcode &gt; ?", 50)</span></span></code> </pre> <br><h1 id="drayvery">  Drivers </h1><br><p>  <code>database/sql</code> is a set of interfaces for working with the database, and <code>sqlx</code> is their extension.  For these interfaces to work, they need an implementation.  Drivers are responsible for implementation. </p><br><p>  Most popular drivers: </p><br><ul><li>  <a href="https://github.com/lib/pq">github.com/lib/pq</a> - <code>pure Go Postgres driver for database/sql.</code>  This driver has long remained the default standard.  But today it has lost its relevance and is not being developed by the author. </li><li>  <a href="https://github.com/jackc/pgx">github.com/jackc/pgx</a> - <code>PostgreSQL driver and toolkit for Go.</code>  Today it is better to choose this tool. </li></ul><br><p>  <strong>github.com/jackc/pgx</strong> - this is the driver you want to use.  Why? </p><br><ul><li>  Actively <strong>supported and developed</strong> . </li><li>  It can be more <strong>productive</strong> if used without <code>database/sql</code> interfaces. </li><li>  Support for over <strong>60 types of PostgreSQL</strong> that <code>PostgreSQL</code> implements outside the <code>SQL</code> standard. </li><li>  The ability to conveniently implement <strong>logging</strong> of what is happening inside the driver. </li><li>  <code>pgx</code> <strong>human-readable errors</strong> , while just <code>lib/pq</code> throws panic attacks.  If you do not catch a panic, the program will crash.  ( <em>Do not use panic in Go; it's not the same as exceptions.</em> ) </li><li>  With <code>pgx</code> , we have the ability to independently <strong>configure each connection</strong> . </li><li>  There is support <strong>for the</strong> <code>PostgreSQL</code> <strong>logical replication protocol</strong> . </li></ul><br><h2 id="4kb">  4KB </h2><br><p>  Typically, we write this loop to get data from the database: </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, sql) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rows.Next() { err = rows.Scan(...) }</code> </pre> <br><p>  Inside the driver, we get data by storing it in <strong>a 4KB buffer</strong> .  <code>rows.Next()</code> spawns a network trip and fills the buffer.  If the buffer is not enough, then we go to the network for the remaining data.  More network visits - less processing speed.  On the other hand, since the buffer limit is 4KB, let's not forget the entire process memory. </p><br><p>  But, of course, I want to unscrew the buffer volume to the maximum in order to reduce the number of requests to the network and reduce the latency of our service.  <a href="https://github.com/jackc/pgconn/pull/10">We add</a> this opportunity and try to find out the expected acceleration on <a href="">synthetic tests</a> : </p><br><pre> <code class="bash hljs">$ go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -v -run=XXX -bench=. -benchmem goos: linux goarch: amd64 pkg: github.com/furdarius/pgxexperiments/bufsize BenchmarkBufferSize/4KB 5 315763978 ns/op 53112832 B/op 12967 allocs/op BenchmarkBufferSize/8KB 5 300140961 ns/op 53082521 B/op 6479 allocs/op BenchmarkBufferSize/16KB 5 298477972 ns/op 52910489 B/op 3229 allocs/op BenchmarkBufferSize/1MB 5 299602670 ns/op 52848230 B/op 50 allocs/op PASS ok github.com/furdarius/pgxexperiments/bufsize 10.964s</code> </pre> <br><p>  It can be seen that there is no big difference in processing speed.  Why is that? </p><br><p>  It turns out that we are limited by the size of the buffer for sending data inside Postgres itself.  This buffer has a <a href="">fixed</a> size of <strong>8KB</strong> .  Using <code>strace</code> <a href="https://pastebin.com/LU10BdBJ">you can see</a> that the OS returns <code>8192</code> bytes in the <a href="https://linux.die.net/man/2/read">read</a> system call.  And <code>tcpdump</code> <a href="https://pastebin.com/FD8abbiA">confirms</a> this <a href="https://pastebin.com/FD8abbiA">with the</a> size of the packets. </p><br><p>  <a href="https://en.wikipedia.org/wiki/Tom_Lane_(computer_scientist)">Tom Lane</a> ( <em>one of the core developers of the Postgres kernel</em> ) <a href="">comments</a> this like this: </p><br><blockquote>  Traditionally, at least, that was the size of pipe buffers in Unix machines, so in principle this is the most optimal chunk size for sending data across a Unix socket. </blockquote><p>  <a href="https://twitter.com/andresfreundtec">Andres Freund</a> ( <em>Postgres developer from EnterpriseDB</em> ) <a href="">believes</a> that an 8KB buffer is not the best implementation option to date, and you need to test the behavior on different sizes and with a different socket configuration. </p><br><p>  We must also remember that PgBouncer also has a buffer and its size can be configured with the <code>pkt_buf</code> parameter. </p><br><h2 id="oids">  OIDs </h2><br><p>  Another feature of the pgx ( <em>v3</em> ) driver: for each connection setup, it makes a request to the database to obtain information about the <strong>Object ID</strong> ( <em>OID</em> ). </p><br><p>  These identifiers were added to Postgres to <a href="https://momjian.us/main/blogs/pgblog/2012.html">uniquely identify</a> internal objects: rows, tables, functions, etc. </p><br><p>  The driver uses knowledge of <code>OIDs</code> to understand which database column into which language primitive to add data.  To do this, <code>pgx</code> supports such a table (the <em>key is the type name, the value is Object ID</em> ) </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]Value{ <span class="hljs-string"><span class="hljs-string">"_aclitem"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"_bool"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"_int4"</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">"_int8"</span></span>: <span class="hljs-number"><span class="hljs-number">55</span></span>, ... }</code> </pre> <br><p>  This implementation leads to the fact that the driver for each established connection with the database makes about three requests to form a table with an <code>Object ID</code> .  In the normal mode of operation of the database and application, the connection pool in Go allows you not to generate new connections to the database.  But at the slightest degradation of the database, the pool of connections on the application side is exhausted and the number of generated connections per unit of time increases significantly.  Requests for <code>OIDs</code> quite heavy, as a result, the driver can bring the database to a critical state. </p><br><p>  Here is the moment when such requests were poured onto one of our databases: </p><br><p><img src="https://habrastorage.org/webt/lm/ra/vb/lmravbubtqb2ah8dvbvvpklbz8m.png"></p><br><p>  <strong>15 transactions per minute</strong> in normal mode, a jump of up to <strong>6500 transactions</strong> during degradation. </p><br><p>  <strong>What to do?</strong> </p><br><p>  First and foremost, limit the size of your pool from above. </p><br><p>  For <code>database/sql</code> this can be done with the <a href="https://golang.org/pkg/database/sql/">DB.SetMaxOpenConns</a> function.  If you abandon the <code>database/sql</code> interfaces and use <code>pgx.ConnPool</code> (the <em>connection pool implemented by the driver itself</em> ), you can specify <code>MaxConnections</code> ( <em>default is 5</em> ). </p><br><p>  By the way, when using <code>pgx.ConnPool</code> driver <a href="https://github.com/jackc/pgx/pull/561">will reuse</a> information about received <code>OIDs</code> and will not make queries to the database for every new connection. </p><br><p>  If you do not want to refuse <code>database/sql</code> , you can cache information about <code>OIDs</code> yourself. </p><br><pre> <code class="go hljs">github.com/jackc/pgx/stdlib.OpenDB(pgx.ConnConfig{ CustomConnInfo: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pgtype.ConnInfo, error)</span></span></span></span> { cachedOids = <span class="hljs-comment"><span class="hljs-comment">//  OIDs   . info := pgtype.NewConnInfo() info.InitializeDataTypes(cachedOids) return info, nil } })</span></span></code> </pre> <br><p>  This is a working method, but using it can be dangerous under two conditions: </p><br><ul><li>  you use enum or domain types in Postgres; </li><li>  if the wizard fails, you switch the application to the replica, which is poured by logical replication. </li></ul><br><p>  Fulfillment of these conditions leads to the fact that cached <code>OIDs</code> become invalid.  But we won‚Äôt be able to clean them, because we don‚Äôt know the moment of switching to a new base. </p><br><p>  In the <code>Postgres</code> world, physical replication is used to organize high availability, which copies the instances of the database bit by bit, so problems with <code>OIDs</code> caching <code>OIDs</code> rarely seen in the wild.  ( <em>But it‚Äôs better to check with your DBAs how standby works for you</em> ). </p><br><p>  In the next major version of the <code>pgx</code> driver - <code>v4</code> , <a href="https://github.com/jackc/pgx/issues/546">there will be no</a> campaigns for <code>OIDs</code> .  Now the driver will rely only on the list of <code>OIDs</code> that are <code>OIDs</code> in the code.  For custom types, you will need to take control of deserialization on your application side: the driver will simply give up a piece of memory as an array of bytes. </p><br><h1 id="logirovanie-i-monitoring">  Logging and monitoring </h1><br><p>  Monitoring and logging will help to notice problems before the base crashes. </p><br><p>  <code>database/sql</code> provides the <a href="https://golang.org/pkg/database/sql/">DB.Stats ()</a> method.  The returned status snapshot will give you an idea of ‚Äã‚Äãwhat is going on inside the driver. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DBStats <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxOpenConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-comment"><span class="hljs-comment">// Pool Status OpenConnections int InUse int Idle int // Counters WaitCount int64 WaitDuration time.Duration MaxIdleClosed int64 MaxLifetimeClosed int64 }</span></span></code> </pre> <br><p>  If you use the pool in <code>pgx</code> directly, the <a href="https://godoc.org/github.com/jackc/pgx">ConnPool.Stat ()</a> method will give you similar information: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ConnPoolStat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { MaxConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CurrentConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> AvailableConnections <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>  Logging is equally important, and <code>pgx</code> allows you to do this.  The driver accepts the <code>Logger</code> interface, implementing it, you get all the events occurring inside the driver. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Log a message at the given level with data key/value pairs. // data may be nil. Log(level LogLevel, msg string, data map[string]interface{}) }</span></span></code> </pre> <br><p>  Most likely, you do not even have to implement this interface yourself.  In <code>pgx</code> out of the box there is a <a href="https://github.com/jackc/pgx/tree/master/log">set of adapters</a> for the most popular loggers, for example, <a href="https://github.com/uber-go/zap">uber-go / zap</a> , <a href="https://github.com/sirupsen/logrus">sirupsen / logrus</a> , <a href="https://github.com/rs/zerolog">rs / zerolog</a> . </p><br><h1 id="infrastruktura">  Infrastructure </h1><br><p>  Almost always when working with <code>Postgres</code> you will use <strong>connection pooler</strong> , and it will be <a href="https://pgbouncer.github.io/">PgBouncer</a> ( <em>or <a href="https://github.com/yandex/odyssey">odyssey</a> - if you are Yandex</em> ). </p><br><p>  Why so, you can read in the excellent article <a href="https://brandur.org/postgres-connections">brandur.org/postgres-connections</a> .  In short, when the number of clients <strong>exceeds 100, the</strong> speed of processing requests begins to degrade.  This happens due to the features of the implementation of Postgres itself: the launch of a separate process for each connection, the mechanism for removing snapshots and the use of shared memory for interaction - all this affects. </p><br><p>  Here is the <a href="https://github.com/postgrespro/postgresql.builtin_pool/wiki/Benchmarking-connection-poolers">benchmark of</a> various connection pooler implementations: <br><img src="https://habrastorage.org/webt/im/p1/-n/imp1-nuasdxn1wmve7l89rrvmbw.png"></p><br><p>  And <a href="https://www.percona.com/blog/2018/06/27/scaling-postgresql-with-pgbouncer-you-may-need-a-connection-pooler-sooner-than-you-expect/">benchmark</a> bandwidth with and without PgBouncer. </p><br><p><img src="https://habrastorage.org/webt/jc/cp/21/jccp2150oefyeiixeu005lpsl_0.png"></p><br><p>  As a result, your infrastructure will look like this: </p><br><p><img src="https://habrastorage.org/webt/bf/ee/ok/bfeeokt_cdojbuddo7_rhzddjis.png"></p><br><p>  Where <code>Server</code> is the process that processes user requests.  This process spins in <code>kubernetes</code> in 3 copies ( <em>at least</em> ).  Separately, on an iron server, there is <code>Postgres</code> , covered by <code>PgBouncer'</code> .  <code>PgBouncer</code> itself <code>PgBouncer</code> single-threaded, so we launch several bouncers, the traffic for which we balance using <code>HAProxy</code> .  As a result, we get this chain of query execution to the database: <code>   ‚Üí HAProxy ‚Üí PgBouncer ‚Üí Postgres</code> . </p><br><p>  <code>PgBouncer</code> can work in three modes: </p><br><ul><li>  <strong>Session pooling</strong> - for each session, one connection is issued and assigned to it for the entire life time. </li><li>  <strong>Transaction pooling</strong> - the connection lives while the transaction is running.  As soon as the transaction is completed, <code>PgBouncer</code> takes this connection and gives it back to another transaction.  This mode allows very good disposal of compounds. </li><li>  <strong>Statement pooling</strong> - <strong>deprecated</strong> mode.  It was created only to support <a href="https://wiki.postgresql.org/wiki/PL/Proxy">PL / Proxy</a> . </li></ul><br><p>  You can see the <a href="https://wiki.postgresql.org/wiki/PgBouncer">matrix</a> of what properties are available in each mode.  We choose <strong>Transaction Pooling</strong> , but it has limitations on working with <code>Prepared Statements</code> . </p><br><h2 id="transaction-pooling--prepared-statements">  Transaction Pooling + Prepared Statements </h2><br><p>  Let's imagine that we want to prepare a request and then execute it.  At some point, we start a transaction in which we send a request to Prepare, and we get the identifier of the prepared request from the database. </p><br><p><img src="https://habrastorage.org/webt/pb/tu/bq/pbtubqa7cvmly0ntnhs0dwc9etc.png"></p><br><p>  After, at any other moment in time, we generate another transaction.  In it, we turn to the database and want to fulfill the request using the identifier with the specified parameters. </p><br><p><img src="https://habrastorage.org/webt/uy/ci/h4/uycih4iuh8aasw43aqodbsxolac.png"></p><br><p>  In <strong>Transaction Pooling</strong> mode, two transactions can be executed in different connections, but the <strong>Statement ID is</strong> valid only within one connection.  We get a <code>prepared statement does not exist</code> error when trying to execute a request. </p><br><p>  The most unpleasant: since during development and testing the load is small, <code>PgBouncer</code> often issues the same connection and everything works correctly.  But as soon as we roll out to prod, requests begin to fall with an error. </p><br><p>  Now find <code>Prepared Statements</code> in this code: </p><br><pre> <code class="go hljs">sql := <span class="hljs-string"><span class="hljs-string">`select * from places where city = ?`</span></span> rows, err := s.db.Query(sql, city)</code> </pre> <br><p>  You will not see him!  Query preparation will implicitly occur inside <code>Query()</code> .  At the same time, the preparation and execution of the request will occur in different transactions and we will fully receive all that I described above. </p><br><p>  <strong>What to do?</strong> </p><br><p>  The first, easiest option is to <strong>switch <code>PgBouncer</code> to <code>Session pooling</code></strong> .  One connection is allocated to the session, all transactions begin to go in this connection and prepared requests work correctly.  But in this mode, the efficiency of utilization of compounds leaves much to be desired.  Therefore, this option is not considered. </p><br><p>  The second option is <strong>to prepare a request on the client side</strong> .  I do not want to do this for two reasons: </p><br><ul><li>  Potential SQL vulnerabilities.  The developer may forget or incorrectly do the escaping. </li><li>  Escaping the query parameters each time has to be written by hand. </li></ul><br><p>  Another option is to <strong>explicitly wrap each request in a transaction</strong> .  After all, as long as the transaction lives, <code>PgBouncer</code> does not take the connection.  This works, but, in addition to verbosity in our code, we also get more network calls: Begin, Prepare, Execute, Commit.  Total 4 network calls per request.  Latency is growing. </p><br><p>  But I want it both safely and conveniently and efficiently.  And there is such an option!  You can explicitly tell the driver that you want to <strong>use <a href="https://www.postgresql.org/docs/11/protocol-flow.html">Simple Query</a> mode</strong> .  In this mode, there will be no preparation and the entire request will pass in one network call.  In this case, the driver will do the shielding of each of the parameters itself ( <em><code>standard_conforming_strings</code> should be activated at the base level or when establishing a connection</em> ). </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... RuntimeParams: <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"standard_conforming_strings"</span></span>: <span class="hljs-string"><span class="hljs-string">"on"</span></span>, }, PreferSimpleProtocol: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }</code> </pre> <br><h1 id="otmena-zaprosov">  Cancel requests </h1><br><p>  The following issues are related to canceling requests on the application side. </p><br><p>  Take a look at this code.  Where are the pitfalls? </p><br><pre> <code class="go hljs">rows, err := s.db.QueryContext(ctx, ...)</code> </pre> <br><p>  Go has a method for controlling the flow of program execution - <a href="https://golang.org/pkg/context/">context.Context</a> .  In this code, we pass the <code>ctx</code> driver so that when the context is closed, the driver cancels the request at the database level. </p><br><p>  At the same time, it is expected that we will save resources by canceling requests for which no one is waiting.  But when canceling a request, <code>PgBouncer</code> version <em>1.7</em> sends information to the connection that this connection is ready for use, and after that it returns it to the pool.  This behavior of <code>PgBouncer'</code> is misleading the driver, which, when sending the next request, instantly receives <code>ReadyForQuery</code> in response.  In the end, we catch <a href="https://github.com/pgbouncer/pgbouncer/issues/223">unexpected ReadyForQuery errors</a> . </p><br><p>  Starting with <code>PgBouncer</code> version <em>1.8,</em> this behavior has <a href="https://github.com/pgbouncer/pgbouncer/commit/9bff5cae90c5c081c0a3044392362a49052782f2">been fixed</a> .  Use the current version of <code>PgBouncer</code> . </p><br><h3 id="otlozhennaya-otmena">  Delayed cancellation </h3><br><p>  But the most interesting is how query cancellation works.  To cancel the request, we need to create a new connection to the database and request a cancellation.  <code>Postgres</code> creates a separate process for each connection.  We send a command to cancel the <strong>current</strong> request in a specific process.  To do this, create a new connection and in it pass the process ID (PID) of interest to us.  But while the cancellation command flies to the base, the canceled request may end on its own. </p><br><p><img src="https://habrastorage.org/webt/us/xf/v_/usxfv_i0ze_axpmjtlir183reiu.png"></p><br><p>  <code>Postgres</code> will execute the command and cancel the <strong>current</strong> request in the given process.  But the current request will not be the one we wanted to cancel initially.  Because of <a href="https://github.com/pgbouncer/pgbouncer/issues/245">this behavior</a> when working with <code>Postgres</code> with <code>PgBouncer</code> , it would be safer not to cancel the request at the driver level.  To do this, you can set the <code>CustomCancel</code> , which will not cancel the request, even if <code>context.Context</code> used. </p><br><pre> <code class="go hljs">cfg := pgx.ConnConfig{ ... CustomCancel: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ *pgx.Conn)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }, }</code> </pre> <br><h1 id="cheklist-po-rabote-s-postgres">  Postgres Checklist </h1><br><p>  Instead of conclusions, I decided to make a checklist for working with Postgres.  This should help the article fit into my head. </p><br><ul><li>  Use <a href="https://github.com/jackc/pgx">github.com/jackc/pgx</a> as a driver for working with Postgres. </li><li>  Limit the size of the connection pool from above. </li><li>  Cache <code>OIDs</code> or use <a href="https://godoc.org/github.com/jackc/pgx">pgx.ConnPool</a> if you are working with <code>pgx</code> version 3. </li><li>  Collect metrics on the connection pool using <a href="https://golang.org/pkg/database/sql/">DB.Stats ()</a> or <a href="https://godoc.org/github.com/jackc/pgx">ConnPool.Stat ()</a> . </li><li>  Log what is happening in the driver. </li><li>  Use <a href="https://www.postgresql.org/docs/11/protocol-flow.html">Simple Query</a> mode to avoid problems with query preparation in <code>PgBouncer</code> transactional mode. </li><li>  Update <code>PgBouncer</code> to the latest version. </li><li>  Be careful with canceling requests from the application. </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/461935/">https://habr.com/ru/post/461935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461921/index.html">HDMI-LVDS. Development on TSUMV59 from MStar</a></li>
<li><a href="../461923/index.html">JetBrains Open Day in St. Petersburg: video</a></li>
<li><a href="../461927/index.html">Active Ranking Learning</a></li>
<li><a href="../461929/index.html">Monitoring and checking SSD status on Linux</a></li>
<li><a href="../46193/index.html">Keith Chambers' Wood Watch</a></li>
<li><a href="../461937/index.html">Parkinson's law and how to break it</a></li>
<li><a href="../461939/index.html">Year of adventure with graphene-python</a></li>
<li><a href="../461941/index.html">Massage it</a></li>
<li><a href="../461945/index.html">The digest of events for HR professionals in the field of IT for August 2019</a></li>
<li><a href="../461949/index.html">AppCode 2019.2: Swift 5.1, analysis of code coverage by tests, display of disassembled code and more</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>