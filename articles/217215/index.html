<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"What is proof?": A look from theoretical informatics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Theoretical computer science is one of the areas of study at the Department of Mathematical and Information Technologies of the Academic University. W...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"What is proof?": A look from theoretical informatics</h1><div class="post__text post__text-html js-mediator-article">  Theoretical computer science is one of the areas of study at the Department of <a href="http://mit.spbau.ru/">Mathematical and Information Technologies of the</a> Academic University.  We are often asked what theoretical informatics does.  Theoretical computer science is an actively developing scientific field that includes both fundamental areas: algorithms, computational complexity, cryptography, information theory, coding theory, algorithmic game theory, and more applied ones: artificial intelligence, machine learning, programming language semantics, verification, automatic proof of theorems and much more.  We will devote this article to a review of only a small plot, namely, we will tell about unusual approaches to the concept of proof, which theoretical informatics considers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b78/a13/408/b78a13408761bf61de251c3988a4bcf8.png" width="400"></div><br><br>  To explain what kind of evidence will be discussed, consider an example: there is a computer program whose authors claim that the program does something definite (specific examples will be a little later).  The program can be run and get an answer.  And how can you make sure that the program does what it should do?  It would be nice if, in addition to the answer, the program would give proof that this answer is correct. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider a more specific example: we want to have a program that, in a bichromatic graph, finds a matching maximum size together with proof of its maximum. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/377/044/e0f37704470e2b0d3aeb0e3a57f5b3c8.png" width="400"></div><br><br>  Recall that a graph is called bichromatic if its vertices can be colored in two colors so that the edges of the graph connect the vertices of different colors.  A matching in a graph is such a set of edges that no two of them have a common end.  A set of vertices of a graph is called covering if each edge of the graph has at least one end in this set.  Koenig's theorem states that in a bichrophic column the size of the maximum matching matches the size of the minimal covering set.  Thus, in order to prove that the matching is maximal, one can present a covering set whose size coincides with the size of the given matching.  Indeed, this covering set will be minimal, since each covering set must cover at least one end of each edge of this matching.  For example, in the graph in the figure, the matching (M1, G3), (M2, G2), (M4, G1) will be maximal, since there is a covering set of size 3, which consists of G2, G3 and M4.  Note that it is much easier to verify such a proof than to calculate the maximum matching: it suffices to verify that the matching size coincides with the size of the covering set and verify that all edges are covered. <br><br>  Consider another example, suppose we need a program that checks a system of non-strict linear inequalities with rational coefficients for consistency (recall that a system of inequalities is called joint if you can pick up such values ‚Äã‚Äãof variables that all inequalities are satisfied). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04e/8ac/44a/04e8ac44a976165daf12607f95037f54.jpg" width="150"></div><br><br>  How can you prove the correctness of the result?  If the system is consistent, then the solution of this system can be a proof of consistency (it is easy to prove that if such a system has a solution, then there is a rational solution, that is, it can be written down).  And how to prove that the system is incompatible?  It turns out that this can be done with the help of the Farkas Lemma, which states that if the system of non-strict linear inequalities is incompatible, then these inequalities can be added with non-negative coefficients and a contradictory inequality 0‚â•1 can be obtained.  For example, the system in the figure is incompatible, and if you add the first equation with a factor of 1, the second with a factor of 2, and the third with a factor of 1, you get 0‚â•1.  The proof of incompatibility is just a set of non-negative coefficients. <br><br>  In this article we will talk about whether evidence is needed, or verifying evidence is not always easier than solving a problem on your own.  (In the example of maximum matching, we did not prove that there is no algorithm that solves the problem for the same time as proof checking takes.) If we do not limit the size of the proof, then it turns out that evidence is needed, and if we demand that the proof be short, the question of the need for proof is equivalent to the most important open question of the equality of the classes P and NP.  Then we will talk about interactive evidence (evidence in dialogue).  We will discuss cryptographic evidence that does not disclose unnecessary information, except for the correctness of the proved statement.  And we end with a discussion of probabilistically verifiable proofs and the famous PCP theorem, which is used to prove the difficulty of approximating optimization problems. <br><br>  In this article we will not touch on the automatic proof of theorems and the proof of the correctness of programs, although these topics are also quite interesting. <br><br><a name="habracut"></a><br><h4>  Do you need proof? </h4><br>  A language is a set of strings over some finite alphabet.  In theoretical computer science, evidence is usually considered for statements of the form x‚ààL, where L is a language and x is a certain string.  Statements of this kind generalize mathematical theorems, since any mathematical theorem states that a statement written in a formal language belongs to the set of true statements. <br><br>  The proof system for the language L is the algorithm A (x, w), which receives two lines as input: x and w and verifies that the string w is a proof of the membership of x‚ààL.  From the system of evidence require two properties: correctness and completeness.  Correctness states that if for some rows x and w the algorithm A (x, w) returns 1, then x‚ààL.  Completeness asserts that for each x‚ààL there exists a string w such that the algorithm A (x, w) yields 1. <br><br>  Languages ‚Äã‚Äãfor which evidence systems exist are called enumerable languages.  If you come across a different definition of an enumerable language, then as an exercise, prove their equivalence. <br><br>  A language L is called solvable if there exists an algorithm B such that when x‚ààL, the algorithm B (x) returns 1, and when x‚àâL it returns 0. Any soluble language has a proof system in which the proof is empty.  The natural question is whether it is necessary that for any language for which there is a system of evidence, there exists a resolving algorithm.  The answer to this question is known, there are languages ‚Äã‚Äãfor which there are systems of evidence, but for which there is no resolving algorithm.  To invent an example of such a language is not difficult, it is more difficult to invent a natural example.  Consider a language that consists of polynomials with integer coefficients in many variables that vanish at least for some integer value of the variables.  The proof system for such a language is constructed simply: the proof is the integer value of the variables in which the polynomial vanishes.  The DPRM theorem (named for the authors: Davis, Putnam, Robinson, and Matiyaesevich) states that this language is not solvable, that is,  there is no algorithm that checks whether the polynomial vanishes at integer points.  The last step in the proof of this theorem belongs to Academician Yu. V. Matiyasevich, and this theorem gives a negative answer to the 10th Hilbert problem. <br><br><h4>  Short evidence </h4><br>  So far we have not imposed any restrictions on the algorithm that verifies the proof and on the size of the proof.  Would it be useful to prove the correctness of the result of a program if the time it takes to check the proof is more than the time it takes to execute the program?  It seems that such proofs are meaningless, therefore, we will require that the algorithm A (x, w) in the definition of the proof system works polynomially on the length of the string x and on the length of the proof w time, such proof systems will be called effective. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d13/c1b/8b9/d13c1b8b987b4d9194a87d7ae7edaa5c.png" align="right" width="200"><br>  We say that the language L belongs to the class NP if there is an effective system of proofs for it and the polynomial p, that for any x‚ààL there is a proof that x‚ààL is of length not greater than p (| x |).  The language L belongs to the class P if there exists an algorithm polynomial in time that checks whether the input string belongs to the language L. The class P is contained in the class NP, because for each language L of P, the algorithm checking the belonging of L itself will be a proof system if that he ignores evidence.  At the moment, it is not known whether there exist languages ‚Äã‚Äãfrom the class NP, which do not belong to the class P. The question of the equality of the classes P and NP is on the list of seven millennium problems compiled by the Clay Institute;  for the solution of this problem a prize of one million dollars has been announced.  Many have heard about the list of tasks of the millennium in connection with the proof of the Poincare hypothesis by G. Ya. Perelman.  Most experts believe that the classes P and NP do not match. <br><br>  Consider examples of languages ‚Äã‚Äãfrom the NP class: <br><ul><li>  The language of composite numbers lies in the class NP.  To prove that the number n is composite, it suffices to present two integers a and b that are greater than one and n = ab.  The language of prime numbers also lies in the class NP, but it is more difficult to prove it.  However, in 2002, Kayal and Saxena proved that the language of simple (and, therefore, composite) numbers lies in the class P. <br></li><li>  Consider the language GI, which consists of pairs of isomorphic graphs.  We assume that the vertices of the graphs are numbered from 1 to n, each <br>  edge connects exactly one pair of vertices.  Two graphs G <sub>1</sub> (V <sub>1</sub> , E <sub>1</sub> ) and G <sub>2</sub> (V <sub>2</sub> , E <sub>2</sub> ) are called isomorphic if the vertices of the first graph can be renumbered so that the first graph begins to coincide with the second graph.  This means that after renumbering, the set of edges of the first graph coincides with the set of edges of the second graph.  The language GI lies in the class NP, the proof of the isomorphism of the graphs is the permutation of the vertices of the first graph, which defines an isomorphism.  Whether the GI language is in the P class is an open question.  Consider also the language GNI, which consists of pairs of non-isomorphic graphs on the same number of vertices.  It is not known about the GNI language whether it lies in NP, since it is unclear how briefly to prove that two graphs are non-isomorphic. <br></li><li>  Consider the HamPath language, which consists of graphs in which there is a Hamiltonian path, i.e.  such a path that exactly once passes through each vertex.  This language lies in the NP class, since the path itself can be used as evidence of the presence of a path.  About this language it is not known whether it is in the class P, but it is known that it is NP-complete.  The latter in particular means that HamPath does not lie in P if P ‚â† NP.  The addition of the HamPath language coincides with the set of graphs in which there is no Hamiltonian path.  Whether the HamPath supplement lies in the NP class is unknown. <br></li></ul><br><br><h4>  Interactive evidence </h4><br>  Until now, the evidence that we considered was very similar to our usual ones, namely, evidence is some text that, although it is not clear how to invent, but it is easy to verify, there is an algorithm that verifies the correctness of the evidence.  That is, to come up with a proof, you need to have some special abilities, and everyone can check the proof.  In fact, not all the evidence of modern mathematics has this property.  Firstly, the evidence is not written in a formal language convenient for automatic verification, and secondly, in order to understand the evidence in some areas, you need to spend several years studying this area. <br><br>  Mathematics classes for schoolchildren often practice this format of classes: children are given a set of tasks, when the child believes that he has solved the problem, he verbally tells the solution to the teacher.  And there is a dialogue between the teacher and the student, who either convinces the teacher that the problem is solved or does not convince. <br><br>  Consider an example of interactive proof: there is a program that solves the problem of isomorphism of graphs.  In the case when the graphs are isomorphic, the program can prove the correctness of its answer by issuing a permutation defining isomorphism.  We show how it is possible in the dialogue to prove that graphs are non-isomorphic.  Let the user ask the program if the graphs G <sub>0</sub> and G <sub>1</sub> are isomorphic and get the answer that they are non-isomorphic.  After that, the user throws a coin (selects a random element i from the set {0,1}) and selects a random permutation of the n-element set (all the permutations are considered to be equally probable) œÉ.  He asks the program whether the graphs are isomorphic to G <sub>0</sub> , œÉ (G <sub>i</sub> ).  If i = 0, then the program is expected to answer that the graphs are isomorphic, and if i = 1, then the program is expected to graph non-isomorphic.  If the graphs G <sub>0</sub> and G <sub>1</sub> were indeed non-isomorphic, then the program will easily give the correct answer to this question.  And if G <sub>0</sub> and G <sub>1</sub> were isomorphic, then the graph œÉ (G <sub>i</sub> ) with equal probability can be either a permutation of G <sub>0</sub> or a permutation of G <sub>1</sub> , therefore the program will produce the expected response with a probability not greater than 1/2.  The error probability can be reduced by repeating the algorithm n times and deciding that the algorithm works correctly if in each of the n launches the correct answer was given;  the probability of error in this case does not exceed 1/2 <sup>n</sup> . <br><br>  In the example just considered, the proof is a dialogue between the proving (the program) and the verifier (the user), while the proving can be very complicated, and the verifier can only do simple things (produce polynomial time calculations).  If x‚ààL, then the prover must convince the verifier with probability 1, and if x‚àâL, then the verifier must accept such proof with a probability of no more than 1/10.  Shamir's theorem states that such interactive proof systems with short dialogues exist for all L languages ‚Äã‚Äãfor which there are recognition algorithms using polynomial memory.  In particular, it is possible to prove in polynomial time that there is no Hamiltonian path in the graph. <br><br><h4>  Evidence with zero disclosure </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f9/177/c05/0f9177c05c9c43d49d1c92b24b0d9174.png" width="600"></div><br><br>  The concept of proof is found not only in mathematics and computer science, but also in jurisprudence.  For example, a person is accused of a crime, he can prove that he was not at the crime scene, but does not want to tell where he was in fact (for example, he could have a mistress or wants to hide his whereabouts from competitors).  Alibi is not a crime, but its announcement is very undesirable.  It turns out that it is theoretically possible to prove in such a way as not to communicate unnecessary information, except for the statement being proved. <br><br>  Consider an example: some firms write programs that quickly solve the problem of graph isomorphism, but the free version of this program simply says whether graphs are isomorphic or not, without giving a permutation in the case that graphs are isomorphic.  To get a permutation, you need to buy a paid version of the program.  But meanwhile, the developers want the user to make sure that the graphs are indeed isomorphic, but that this information does not help the user to find this isomorphism on his own.  This can be done as follows: if the graphs G <sub>0</sub> and G <sub>1 are</sub> isomorphic, then you can choose a random permutation œÄ and produce the graph G <sub>2</sub> = œÄ (G <sub>1</sub> ) and ask the user to decide which graph isomorphism he wants to get G <sub>0</sub> and G <sub>2</sub> or G <sub>1</sub> and G <sub>2</sub> .  The program will respond to exactly one of these requests.  If the program knows isomorphism, then it will easily respond to the user's request, but if there is no isomorphism, then at least one of the user's request options for issuing an answer will fail.  And if the user selects the query randomly, then the probability that there is an isomorphism between the options selected by the user does not exceed 1/2.  The error can be reduced by repeating this process: choosing a new permutation and prompting the user to choose a new option. <br><br>  It turns out that for each language from the NP class, with a certain cryptographic assumption, it is possible to construct such an interactive proof of ownership that will not give any information about the classic proof of membership (which exists for any language from the NP class).  The cryptographic assumption mentioned is the existence of one-way functions, i.e.  functions that are easy to calculate but hard to reverse.  For example, many believe that a function that gives out their product by two n-bit numbers is one-sided. <br><br><h4>  Probability testable evidence </h4><br>  Let a math teacher give his students homework, they hand him notebooks with a solution.  Any math teacher wants to check the solution without reading it completely.  The option to check the decision only by the answers is bad, since the answer can be written off or guessed and also this does not help in the tasks on the proof, in which there are no answers as such.  It turns out that this dream of teachers is achievable and any proof can be rewritten in such a way that to check it it would be enough to look at the constant number of bits of proof. <br><br>  We give an example for the language of pairs of non-isomorphic GNI graphs.  In our example, the proof will be exponential length, namely, for graphs on n vertices, the proof will be 2 <sup>n (n-1) / 2</sup> , here n (n-1) / 2 is the maximum number of edges that a graph can have on n tops.  The proof of the non-isomorphism of a pair of graphs G <sub>0</sub> and G <sub>1</sub> is a bit string w of length 2 <sup>n (n-1) / 2</sup> , which is indexed by all different graphs on n vertices.  The bit of the string w corresponding to the graph H is zero if H is isomorphic to G <sub>0</sub> , unity if the graph is isomorphic to G <sub>1</sub> , and equal to anything if the graph H is not isomorphic to neither G <sub>0</sub> nor G <sub>1</sub> .  The figure shows an example of such a string w for two non-isomorphic graphs on three vertices: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfb/d29/e8b/dfbd29e8ba244a2e6addcbcea9e974e4.png" width="600"></div><br><br>  The verification of such a proof is similar to an interactive proof: you must throw a coin (take random i from {0,1}), random permutation œÉ and look at the bit of proof corresponding to the column œÉ (G <sub>i</sub> ), if it coincides with i, then accept such proof , if it does not coincide with i, then reject.  In the case when the graphs G <sub>0</sub> and G <sub>1 are</sub> non-isomorphic, then such a proof will be accepted.  If the graphs G <sub>0</sub> and G <sub>1 are</sub> isomorphic, then the graph œÉ (G <sub>i</sub> ) with equal probability can be a permutation of G <sub>0</sub> and G <sub>1</sub> , therefore, the proof will be accepted with a probability not greater than 1/2.  By repeating such a check 10 times for independent random choices i and œÉ, it is possible to lower the error probability to 1/1024. <br><br>  The disadvantage of the above proof is that it has an exponential size.  However, the famous PCP theorem (PCP is short for probabalistically checkable proofs) states that for each language from class NP there is evidence of belonging to a language of polynomial size, and to verify this proof, it is enough to read the constant number of bits of this proof.  Moreover, the usual proof (which exists by definition of the class NP) can be transformed in polynomial time into a proof that can be checked probabilistically. <br><br>  PCP-theorem is not only a fun fact, but also a powerful tool for proving the difficulty of approximate solutions for optimization problems.  Recall that an independent set in a graph is a set of vertices of the graph, between which there are no edges of the graph.  It is known that the task of finding the maximum independent set in a graph is NP-hard, which, in particular, means that if there is an algorithm that is polynomial in the number of vertices of the graph that finds the maximum independent set in the graph, then P = NP.  Using the PCP theorem, it can be proved that the NP-hard problem is to find not only the maximal independent set, but also the approximately maximal set (with a constant approximation).  In particular, if there exists an algorithm which, during polynomial time in the graph, finds an independent set that is not more than 1000 times smaller than the maximum, then it follows that P = NP. <br><br><h4>  Links </h4><br>  Literature in which you can find rigorous wording and evidence of all the statements mentioned in the article: <br><ul><li>  S. Arora, B. Barak, <a href="http://www.cs.princeton.edu/theory/complexity/">Computational Complexity: A modern Approach</a> </li><li>  O. Goldreich, <a href="http://www.wisdom.weizmann.ac.il/~oded/foc-book.html">The Foundations of Cryptogtaphy</a> </li><li>  Yu. V. Matiyasevich, Hilbert's Tenth Problem.  - M .: Science, 1993. - ISBN 502014326X </li><li>  N.K.  Vereshchagin, <a href="http://lpcs.math.msu.su/~ver/teaching/cryptography/index.html">Theoretical complexity problems of cryptography</a> , lecture notes </li><li>  D.M.  Itsykson, <a href="http://logic.pdmi.ras.ru/csclub/courses/csintro">Overview course on theoretical computer science</a> , lecture notes </li></ul><br><br>  Those interested in theoretical computer science are advised to pay attention to the <a href="http://mit.spbau.ru/csmaster">magistracy of the</a> Academic University. </div><p>Source: <a href="https://habr.com/ru/post/217215/">https://habr.com/ru/post/217215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../217205/index.html">The logic of thinking. Subtotal</a></li>
<li><a href="../217207/index.html">Invitation to Frontend Developer Conf by Artem Zakharchenko</a></li>
<li><a href="../217209/index.html">Google Cloud Platform Live: a mix of IaaS and PaaS. Moore's Law for the Clouds</a></li>
<li><a href="../217211/index.html">Spectrophotometer PHOTON RT or spectral characteristics of glasses Gunnar and Polaroid</a></li>
<li><a href="../217213/index.html">TYPO3 CMS cluster in Jelastic cloud</a></li>
<li><a href="../217225/index.html">MakeHuman: release after 12 years of development</a></li>
<li><a href="../217235/index.html">Australian shark warns of its approach to shore via Twitter</a></li>
<li><a href="../217237/index.html">Internet Archive began digitizing 40,000 VHS and Betamax video tapes</a></li>
<li><a href="../217239/index.html">A set of bike Yii developer</a></li>
<li><a href="../217241/index.html">(Archive) Matreshka.js v0.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>