<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C #: one use case for any tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! We continue to talk about asynchronous programming in C #. Today we will talk about a single use case or user scenario suitable for any task...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C #: one use case for any tasks</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  We continue to talk about asynchronous programming in C #.  Today we will talk about a single use case or user scenario suitable for any tasks within asynchronous programming.  Let's talk about synchronization, deadlocks, operator settings, exception handling and much more.  Join now! <br><br><img src="https://habrastorage.org/webt/fn/3y/w8/fn3yw8b2lmo8cbbziqaiogmvsxy.jpeg"><a name="habracut"></a><br><br><blockquote>  <b>Previous related articles</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habr.com/company/microsoft/blog/420627/">Asynchronous C # programming: how are you doing with performance?</a> </li><li>  <a href="https://habr.com/company/microsoft/blog/418515/">Override Equals and GetHashCode.</a>  <a href="https://habr.com/company/microsoft/blog/418515/">Do you need it?</a> </li><li>  <a href="https://habr.com/company/microsoft/blog/418519/">What can be found in someone else's code?</a>  <a href="https://habr.com/company/microsoft/blog/418519/">Selection of useful materials on .NET</a> </li></ul></blockquote><br>  Virtually any non-standard behavior of asynchronous methods in C # can be explained on the basis of a single user scenario: the conversion of existing synchronous code to asynchronous should be as simple as possible.  You must be able to add the async keyword before the returned method type, add the Async suffix to the name of this method, and add the await keyword here and in the text area of ‚Äã‚Äãthe method to get a fully functional asynchronous method. <br><br><img width="550" src="https://habrastorage.org/webt/di/uw/i8/diuwi85jehdfov_iozovmreg59s.png"><br><br>  The ‚Äúsimple‚Äù scenario drastically changes many aspects of the behavior of asynchronous methods: from planning the duration of the task to the exception handling.  The script looks convincing and meaningful, but in its context the simplicity of asynchronous methods becomes very deceptive. <br><br><h2>  Synchronization context </h2><br>  User Interface Development (UI) is one of the areas where the scenario described above is particularly important.  Due to the lengthy operations in the user interface flow, the response time of applications increases, and in this case asynchronous programming has always been considered a very effective tool. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_ClickAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 -- UI Thread var result = await _stockPrices.GetStockPricesForAsync("MSFT"); // 2 -- Usually non-UI Thread textBox.Text = "Result is: " + result; //3 -- Should be UI Thread }</span></span></code> </pre> <br>  The code looks very simple, but one problem arises.  For most user interfaces, there are limitations: UI elements can be modified only by special threads.  That is, in line 3, an error occurs if the duration of the task is scheduled in the thread from the thread pool.  Fortunately, this issue has been known for a long time, and the concept of <a href="https://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext(v%3Dvs.80).aspx">synchronization context has</a> appeared in the .NET Framework 2.0 version. <br><br>  Each UI provides special utilities for marshaling tasks into one or more specialized user interface threads.  Windows Forms uses the <code>Control.Invoke</code> method, WPF - Dispatcher.Invoke, other systems can access other methods.  The schemes used in all these cases are similar in many respects, but differ in details.  The synchronization context allows you to abstract away the differences by providing an API for running code in a ‚Äúspecial‚Äù context that provides handling of minor details with such derived types as <code>WindowsFormsSynchronizationContext</code> , <code>DispatcherSynchronizationContext</code> , etc. <br><br>  To solve the problem related to the similarity of threads, C # programmers decided to enter the current synchronization context at the initial stage of the implementation of asynchronous methods and to plan all subsequent operations in such a context.  Now each of the blocks between await statements is executed in the user interface thread, which makes it possible to implement the main script.  However, this decision gave rise to a number of new problems. <br><br><h2>  Deadlock </h2><br>  Let's look at a small, relatively simple piece of code.  Are there any problems here? <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UI code private void buttonOk_Click(object sender, EventArgs args) { textBox.Text = "Running.."; var result = _stockPrices.GetStockPricesForAsync("MSFT").Result; textBox.Text = "Result is: " + result; } // StockPrices.dll public Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { await Task.Yield(); return 42; }</span></span></code> </pre> <br>  This code causes a <b>deadlock</b> .  The user interface thread starts an asynchronous operation and waits synchronously for the result.  However, the execution of the asynchronous method cannot be completed, since the second line <code>GetStockPricesForAsync</code> must be executed in the user interface thread that causes the deadlock. <br><br>  You argue that this problem is fairly easy to solve.  Yes indeed.  It is necessary to prohibit all calls to the <code>Task.Result</code> or <code>Task.Wait</code> from the user interface code, however, the problem can still occur if the component used by such code synchronously waits for the result of the user operation: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UI code private void buttonOk_Click(object sender, EventArgs args) { textBox.Text = "Running.."; var result = _stockPrices.GetStockPricesForAsync("MSFT").Result; textBox.Text = "Result is: " + result; } // StockPrices.dll public Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { // We know that the initialization step is very fast, // and completes synchronously in most cases, // let's wait for the result synchronously for "performance reasons". InitializeIfNeededAsync().Wait(); return Task.FromResult((decimal)42); } // StockPrices.dll private async Task InitializeIfNeededAsync() =&gt; await Task.Delay(1);</span></span></code> </pre> <br>  This code again causes deadlock.  How to solve it: <br><br><ul><li>  Do not block asynchronous code using <code>Task.Wait()</code> or <code>Task.Result</code> and </li><li>  use <code>ConfigureAwait(false)</code> in library code. </li></ul><br>  The meaning of the first recommendation is clear, and the second we will explain below. <br><br><h2>  Configuring await statements </h2><br>  There are two reasons why a deadlock occurs in the last example: <code>Task.Wait()</code> in <code>GetStockPricesForAsync</code> and indirectly using the synchronization context at subsequent stages in InitializeIfNeededAsync.  Although C # programmers do not recommend blocking calls to asynchronous methods, it is clear that in most cases this blocking is still used.  C # programmers offer the following solution to a deadlock problem: <code>Task.ConfigureAwait(continueOnCapturedContext:false)</code> . <br><br>  Despite the strange appearance (if the method is called without a named argument, it does not mean anything at all), this function fulfills its function: it ensures that the execution will continue without the synchronization context. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPricesForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol</span></span></span><span class="hljs-function">)</span></span> { InitializeIfNeededAsync().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  In this case, the continuation of the <code>Task.Delay(1</code> ) task (here, an empty statement) is scheduled in the stream from the thread pool, and not in the user interface thread, which eliminates the deadlock. <br><br><h2>  Disable sync context </h2><br>  I know that <code>ConfigureAwait</code> actually solves this problem, but it itself generates much more.  Here is a small example: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPricesForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol</span></span></span><span class="hljs-function">)</span></span> { InitializeIfNeededAsync().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Initialize the cache field first await _cache.InitializeAsync().ConfigureAwait(false); // Do some work await Task.Delay(1); }</span></span></code> </pre> <br>  Do you see the problem?  We used <code>ConfigureAwait(false)</code> , so everything should be fine.  But not a fact. <br><br>  <code>ConfigureAwait(false)</code> returns a custom awaiter <code>ConfiguredTaskAwaitable</code> object, and we know that it is used only if the task does not complete synchronously.  That is, if <code>_cache.InitializeAsync()</code> completes synchronously, a deadlock is still possible. <br><br>  To eliminate a deadlock, all tasks awaiting completion must be decorated with a call to the <code>ConfigureAwait(false)</code> method <code>ConfigureAwait(false)</code> .  All this is annoying and causes mistakes. <br><br>  Alternatively, you can use a custom awaiter object in all public methods to disable the synchronization context in the asynchronous method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = _stockPrices.GetStockPricesForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).Result; textBox.Text = <span class="hljs-string"><span class="hljs-string">"Result is: "</span></span> + result; } <span class="hljs-comment"><span class="hljs-comment">// StockPrices.dll public async Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { // The rest of the method is guarantee won't have a current sync context. await Awaiters.DetachCurrentSyncContext(); // We can wait synchronously here and we won't have a deadlock. InitializeIfNeededAsync().Wait(); return 42; }</span></span></code> </pre> <br>  <code>Awaiters.DetachCurrentSyncContext</code> returns the following custom awaiter object: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DetachSynchronizationContextAwaiter : ICriticalNotifyCompletion { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Returns true if a current synchronization context is null. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> It means that the continuation is called only when a current context </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> is presented. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public bool IsCompleted =&gt; SynchronizationContext.Current == null; public void OnCompleted(Action continuation) { ThreadPool.QueueUserWorkItem(state =&gt; continuation()); } public void UnsafeOnCompleted(Action continuation) { ThreadPool.UnsafeQueueUserWorkItem(state =&gt; continuation(), null); } public void GetResult() { } public DetachSynchronizationContextAwaiter GetAwaiter() =&gt; this; } public static class Awaiters { public static DetachSynchronizationContextAwaiter DetachCurrentSyncContext() { return new DetachSynchronizationContextAwaiter(); } }</span></span></code> </pre> <br>  <code>DetachSynchronizationContextAwaiter</code> does the following: the async method works with a non-zero synchronization context.  But if the async method works without a synchronization context, the <code>IsCompleted</code> property returns true, and the method continues to run synchronously. <br><br>  This means the presence of service data close to zero, when the asynchronous method is executed from a thread in the thread pool, and the payment is made once for transferring the execution from the user interface thread to the thread from the thread pool. <br><br>  The following are other benefits of this approach. <br><br><ul><li>  <b>Reduced probability of error.</b>  <code>ConfigureAwait(false)</code> works only if it applies to all tasks waiting to be completed.  It is worth forgetting at least one thing - and a deadlock may occur.  In the case of a custom awaiter object, remember that all public library methods must begin with <code>Awaiters.DetachCurrentSyncContext()</code> .  Errors are possible here, but their probability is much lower. </li><li>  <b>The resulting code is more declarative and clear.</b>  The method with several calls of <code>ConfigureAwait</code> seems to me less convenient for reading (due to unnecessary elements) and not informative enough for beginners. </li></ul><br><h2>  Exception Handling </h2><br>  What is the difference between these two options: <br><br>  Task mayFail = Task.FromException (new ArgumentNullException ()); <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Case 1 try { await mayFail; } catch (ArgumentException e) { // Handle the error } // Case 2 try { mayFail.Wait(); } catch (ArgumentException e) { // Handle the error }</span></span></code> </pre> <br>  In the first case, everything meets expectations - error handling is being performed, but in the second case this does not happen.  The TPL parallel task library is created for asynchronous and parallel programming, and Task / Task can represent the result of several operations.  That is why <code>Task.Result</code> and <code>Task.Wait()</code> always throw an <code>AggregateException</code> exception, which may contain several errors. <br><br>  However, our main script changes everything: the user should be able to add an async / await operator, without touching the logic of error handling.  That is, the await operator must be different from <code>Task.Result</code> / <code>Task.Wait()</code> : it must remove the wrapper from one exception in an <code>AggregateException</code> instance.  Today we will choose the first exception. <br><br>  Everything is fine if all Task-based methods are asynchronous and parallel computations are not used to perform tasks.  But in some cases, everything is different: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task1 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException()); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task2 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException()); <span class="hljs-comment"><span class="hljs-comment">// await will rethrow the first exception await Task.WhenAll(task1, task2); } catch (Exception e) { // ArgumentNullException. The second error is lost! Console.WriteLine(e.GetType()); }</span></span></code> </pre> <br>  <code>Task.WhenAll</code> returns a task with two errors, but the await operator retrieves and fills only the first one. <br><br>  There are two ways to solve this problem: <br><br><ol><li>  manually view tasks if they are accessible, or </li><li>  Configure the TPL library to force the exception to be thrown to another <code>AggregateException</code> exception. </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task1 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException()); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task2 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException()); <span class="hljs-comment"><span class="hljs-comment">// t.Result forces TPL to wrap the exception into AggregateException await Task.WhenAll(task1, task2).ContinueWith(t =&gt; t.Result); } catch(Exception e) { // AggregateException Console.WriteLine(e.GetType()); }</span></span></code> </pre> <br><h2>  Async void method </h2><br>  The Task based method returns a token that can be used to process results in the future.  If the task is lost, the token becomes inaccessible for reading by the user code.  An asynchronous operation that returns a void method produces an error that cannot be processed in user code.  In this sense, tokens are useless and even dangerous - we will see it now.  However, our main scenario assumes their mandatory use: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_ClickAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _stockPrices.GetStockPricesForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); textBox.Text = <span class="hljs-string"><span class="hljs-string">"Result is: "</span></span> + result; }</code> </pre> <br>  But what if <code>GetStockPricesForAsync</code> gives an error?  An unhandled async void method exception is marshaled to the current synchronization context, triggering the same behavior as for synchronous code (for more information, see the <a href="http://referencesource.microsoft.com/">ThrowAsync Method</a> on the <a href="http://referencesource.microsoft.com/">AsyncMethodBuilder.cs</a> web page).  In Windows Forms, an unhandled exception in the event handler triggers the <code>Application.ThreadException</code> event, for the WPF, the <code>Application.DispatcherUnhandledException</code> event is fired, and so on. <br><br>  And if the async void method does not get a sync context?  In this case, an unhandled exception causes a fatal application crash.  It will not trigger the [ <code>TaskScheduler.UnobservedTaskException</code> ] event being restored, but will trigger the unrecoverable <code>AppDomain.UnhandledException</code> event and then close the application.  This is intentional, and this is the result we need. <br><br>  Now let's consider another well-known way: using asynchronous void methods only for UI event handlers. <br><br>  Unfortunately, the asynch void method is easy to call by accident. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Task&lt;T&gt; ActionWithRetry&lt;T&gt;(Func&lt;Task&lt;T&gt;&gt; provider, Action&lt;Exception&gt; onError) { <span class="hljs-comment"><span class="hljs-comment">// Calls 'provider' N times and calls 'onError' in case of an error. } public async Task&lt;string&gt; AccidentalAsyncVoid(string fileName) { return await ActionWithRetry( provider: () =&gt; { return File.ReadAllTextAsync(fileName); }, // Can you spot the issue? onError: async e =&gt; { await File.WriteAllTextAsync(errorLogFile, e.ToString()); }); }</span></span></code> </pre> <br>  At first glance, it is difficult to say if a function is a Task-based method or an async void method, and therefore an error may creep into your code base, despite the most thorough check. <br><br><h2>  Conclusion </h2><br>  Many aspects of asynchronous programming in C # have been influenced by one user script ‚Äî the simple conversion of the synchronous code of an existing user interface application to asynchronous: <br><br><ul><li>  Subsequent execution of asynchronous methods is scheduled in the resulting synchronization context, which can cause deadlocks. </li><li>  To prevent them, you need to place <code>ConfigureAwait(false)</code> calls <code>ConfigureAwait(false)</code> everywhere in the asynchronous library code. </li><li>  await task;  throws the first error, and this complicates the creation of a processing exception for parallel programming. </li><li>  Async void methods are introduced to handle user interface events, but they are easy to execute completely by accident, which will cause the application to crash if there is an unhandled exception. </li></ul><br>  Free cheese is only in a mousetrap.  Ease of use can sometimes result in great difficulty in other areas.  If you are familiar with the history of asynchronous programming in C #, the strangest behavior no longer seems so strange, and the likelihood of errors in asynchronous code is significantly reduced. </div><p>Source: <a href="https://habr.com/ru/post/421245/">https://habr.com/ru/post/421245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421227/index.html">Overview of cross-platform mobile development frameworks</a></li>
<li><a href="../421229/index.html">Story of my headache</a></li>
<li><a href="../421235/index.html">Magic Leap One glasses - points for $ 2295 with maintainability 3 of 10</a></li>
<li><a href="../421241/index.html">The Central Bank asks for authority to block pre-trial malicious sites</a></li>
<li><a href="../421243/index.html">LLTR Part 2: Algorithm for determining the network topology from the collected statistics</a></li>
<li><a href="../421247/index.html">How to turn graphics into sound, and why?</a></li>
<li><a href="../421249/index.html">Why are Wall Street financiers working too hard and is it possible to fix it?</a></li>
<li><a href="../421253/index.html">Why do we need "tailed" cars?</a></li>
<li><a href="../421255/index.html">Ilon Mask abandoned plans to turn Tesla into a private company</a></li>
<li><a href="../421257/index.html">How an international hacker network earned $ 100 million by stealing press releases</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>