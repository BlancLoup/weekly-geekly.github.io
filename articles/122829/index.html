<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data binding in JavaScript applications: auto-authoring events</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! In this article I will consider one of the options for building a client-server web application architecture from the point of view of data b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data binding in JavaScript applications: auto-authoring events</h1><div class="post__text post__text-html js-mediator-article">  Hi Habr!  In this article I will consider one of the options for building a client-server web application architecture from the point of view of data binding.  This option does not claim to originality, but personally allowed me to significantly reduce development time, as well as optimize load time. <br><a name="habracut"></a><br><br><h4>  Problem </h4><br>  Suppose we have a large web interface that should display and allow the user to interact with several hundred elements of different types at the same time. <br>  For each type of object we have our own class, and we naturally want to associate user actions in the interface with the methods of these classes. <br>  In this case, we consider a simple example - the object has a name (the name property), and the object management interface is a text field where this name is entered.  When the field changes, we want the object to change the property, and a new value is sent to the server (the SetName method). <br><br>  Typically, a typical application initialization sequence looks like this: <br><ol><li>  Initialize all objects </li><li>  Build DOM Interface Tree </li><li>  Get links to key interface elements (object container, object editing form, etc.) </li><li>  Initialize the interface with the current object property values </li><li>  Assign object methods as event handlers on interface elements </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Head-on </h4><br>  The simplest implementation for a single object is as follows: <br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitDomForObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// DOM,  ,    object.container = $("&lt;div&gt;", {className : "container"}); object.inputs.name = $("&lt;input&gt;", {value : object.data.name}).appendTo(object.container); ... //  object.inputs.name.change($.proxy(object, "SetName")); ... }</span></span></code> </pre> <br><br><h5>  Obvious disadvantages of this implementation: </h5><br><ol><li>  Hard coupling of layout and JS code </li><li>  A huge amount of DOM build code and event handler assignments (for complex interfaces) </li><li>  With this approach, building a DOM will take too long for the browser, because we will call createElement, setAttribute and appendChild several times for each object, and these are rather ‚Äúheavy‚Äù operations. </li></ol><br><br><h4>  Templates </h4><br>  Faced with such difficulties, we immediately come to mind using templates and not generating DOM manually, because we are well aware that if we build the interface as a string with HTML code, it will be processed by the browser almost instantly. <br><br>  We built HTML (for example, on the server side), and brought it to the browser, but we were faced with the fact that we would have to look for elements in a large DOM tree. <br>  Due to the fact that we need to assign handlers to the elements - we cannot use lazy initialization, we still have to find absolutely all interface elements when loading the application. <br>  Suppose all our objects of different types are numbered, and are collected in an array of Objects. <br>  Now we have two ways: <br><br><h5>  Option A </h5><br>  Search for items by class by writing the object ID in the rel attribute. <br>  An HTML representation of a single object will look like this: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"12345"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"objectName"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"12345"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  Then for each type of interface elements we assign approximately the following handler: <br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">".objectName"</span></span>).change(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = $(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).attr(<span class="hljs-string"><span class="hljs-string">"rel"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//,     Objects[id].SetName(); //  });</span></span></code> </pre><br><br>  And if for some reason we also want to keep the links to each element of the interface, we generally have to write a creepy loop over the entire array of objects: this is long and inconvenient. <br><br><h5>  Option B </h5><br>  Of course, we know that searching for items by id is much faster! <br>  Since our id must be unique, we can use for example the following format "name_12345" ("role_id"): <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container_12345"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name_12345"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"objectName"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  The assignment of handlers will look almost the same: <br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">".objectName"</span></span>).change(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id.split(<span class="hljs-string"><span class="hljs-string">"_"</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>];<span class="hljs-comment"><span class="hljs-comment">//,     Objects[id].SetName(); //  });</span></span></code> </pre><br><br>  Since now all the elements can be found by ID, and the handlers are already assigned - we may well not collect all the links at once, but do it out of necessity (‚Äúlazily‚Äù) by implementing the GetElement method somewhere in the basic prototype of all our objects: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element_name</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element_cache[element_name]) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element_cache[element_name] = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(element_name + <span class="hljs-string"><span class="hljs-string">'_'</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element_cache[element_name]; }</code> </pre><br><br>  Search by ID is very fast, but the cache has never interfered with anyone.  However, if you are going to remove items from the tree, please note that as long as there are links to them, the garbage collector will not get to them. <br><br>  We will have only one problem: a large number of event handlers destination code, because for each type of interface element we will have to assign a separate handler for each event!  The total number of appointments will be = <nobr><u>number of objects</u> <b>X</b> <u>number of elements</u> <b>X</b> <u>number of events</u></nobr> . <br><br><h4>  Final decision </h4><br>  Recall the remarkable property of events in the DOM: <a href="http://javascript.info/tutorial/bubbling-and-capturing">capturing and bubbling</a> ( <a href="http://javascript.info/tutorial/bubbling-and-capturing">capturing and bubbling</a> ): <br>  because we can assign event handlers on the root element, because all the same, all events pass through it! <br><br>  We could use the jQuery.live method for this purpose, and would come up with what is written above: <i>Option B</i> , namely, a large number of handler assignment code. <br><br>  Instead, we will write a small "router" for our events.  We agree to start all the id elements with a special symbol to exclude elements for which no event handlers are needed.  The router will try to forward the event to the object to which this element belongs, and call the appropriate method. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Router={ <span class="hljs-attr"><span class="hljs-attr">EventTypes</span></span> : [<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-string"><span class="hljs-string">'change'</span></span>, <span class="hljs-string"><span class="hljs-string">'dblclick'</span></span>, <span class="hljs-string"><span class="hljs-string">'mouseover'</span></span>, <span class="hljs-string"><span class="hljs-string">'mouseout'</span></span>, <span class="hljs-string"><span class="hljs-string">'dragover'</span></span>, <span class="hljs-string"><span class="hljs-string">'keypress'</span></span>, <span class="hljs-string"><span class="hljs-string">'keyup'</span></span>, <span class="hljs-string"><span class="hljs-string">'focusout'</span></span>, <span class="hljs-string"><span class="hljs-string">'focusin'</span></span>], <span class="hljs-comment"><span class="hljs-comment">//   Init : function(){ $(document.body).bind(Router.EventTypes.join(" "), Router.EventHandler); //  }, EventHandler : function(event){ //  if(event.target.id.charAt(0) != '-') return; var route = event.target.id.substr(1).split('_'); var elementRole = route[0]; var objectId = route[1]; var object = App.Objects[objectId]; //  if(object == null) return; var method = object[elementRole + '_' + event.type]; if (typeof method == 'function') //    { event.stopPropagation(); //      return method.call(object, event); //     ,         } } }</span></span></code> </pre><br><br>  Example of use: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"-Name_12345"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><pre> <code class="javascript hljs">SomeObject.prototype = { ‚Ä¶ Name_blur : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   blur this.data.name = e.target.value; this.GetElement("container").title=this.data.name;// title  ,    id  this.SaveToServer("name"); } }</span></span></code> </pre><br><br><h6>  Advantages of the solution: </h6><br><ul><li>  No need to assign many individual handlers, minimum code </li><li>  Each event is automatically sent to the desired object method, and the method is called in the desired context. </li><li>  You can add / remove interface elements from the layout at any time; you only need to implement the appropriate methods on your objects. </li><li>  The number of handler assignments is equal to the number of event types (and not the <u>number of objects</u> <b>X, the</b> <u>number of elements</u> <b>X, the</b> <u>number of events</u> ) </li></ul><br><h6>  Minuses: </h6><br><ul><li>  It is necessary in a special way and in large quantities to assign ID elements.  (This only requires changing the patterns) </li><li>  At each event in each element, our EventHandler is called (it almost does not reduce performance, since we immediately discard unnecessary elements and also call stopPropagation) </li><li>  Object numbering should be end-to-end (you can divide the Objects array into several - one for each of the object types, or you can enter separate internal ordinal indexes, instead of using the same ID as on the server) </li></ul><br><h4>  Other options </h4><br><br><h5>  Fast decision </h5><br>  If our interface were standard and simple (i.e., used only standard controls), we would use the usual data binding method, for example, jQuery DataLink: <br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">"#container"</span></span>).link(object, { <span class="hljs-attr"><span class="hljs-attr">name</span></span> : <span class="hljs-string"><span class="hljs-string">"objectName"</span></span> } );</code> </pre><br>  When the object property changes, the value of the text field changes and vice versa. <br>  However, in reality, we often use non-standard interface elements and more complex dependencies than ‚ÄúOne interface element to one property of an object‚Äù.  Changing one field can affect several properties at once, and for different objects. <br><br>  For example, if we have a user ( <b>UserA</b> ) with some rights, which belongs to a group, as well as an element in which you can select a group ( <b>GroupA</b> or <b>GroupB</b> ). <br>  Then changing the selection in this list will entail many other changes: <br>  In the data: <br><ul><li>  The property <b>UserA.group will change.</b> </li><li>  <b>UserA</b> object will be removed from <b>GroupA.users</b> array </li><li>  The <b>UserB</b> object will be removed from the <b>GroupB.users</b> array <b>.</b> </li><li>  <b>Change</b> array <b>UserA.permissions</b> </li></ul><br>  In the interface: <br><ul><li>  The view of the list of user rights will change </li><li>  The counters showing the number of users in a group will change. </li></ul><br>  Etc. <br>  Such complex dependencies cannot be easily resolved.  Just in this case, the method described above is suitable. <br><br><h5>  Similar solution </h5><br>  A similar approach is applied to vKontakte: each event element is assigned through the appropriate attributes (onclick, onmouseover, etc.).  Only the template is built on the client side, not the server. <br>  However, event handling is not delegated to any object: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dialogs_row"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"im_dialog78974230"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onclick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"IM.selectDialog(78974230); return false;"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Instead, methods of global objects are called, which is not very good if, for example, the OOP approach is used in an application. <br><br>  We could change this principle, still directing events to the right methods, but it would not look very nice: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"dialogs_row"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"im_dialog78974230"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onclick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Dialog.prototype.select.call(Objects[78974230], event); return false;"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  Instead, we can adapt our function router to this approach: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Name_12345"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onblur</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"return Route(event);"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Router</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> route = event.target.id.split(<span class="hljs-string"><span class="hljs-string">'_'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elementRole = route[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objectId = route[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> object = App.Objects[objectId]; <span class="hljs-comment"><span class="hljs-comment">//  if(object == null) return; var method = object[elementRole + '_' + event.type]; if (typeof method == 'function') //    { event.stopPropagation(); //      return method.call(object, event); //     ,         } }</span></span></code> </pre><br>  This will save us from handling a large number of events for each "sneeze" of the user, but it will force us to describe the events in the template of each element and, moreover, the inline code. <br><br>  Which of these evils is the least, and accordingly which of the methods to choose depends on the context and the specific task. </div><p>Source: <a href="https://habr.com/ru/post/122829/">https://habr.com/ru/post/122829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../122823/index.html">File transfer by signals</a></li>
<li><a href="../122824/index.html">Reading an XML file using App Inventor</a></li>
<li><a href="../122826/index.html">Qt applications in the Mac App Store</a></li>
<li><a href="../122827/index.html">Functional programming in 1C: Enterprise 8 environment</a></li>
<li><a href="../122828/index.html">comScore: The network is "shrinking" because of Facebook</a></li>
<li><a href="../122830/index.html">Checkout right</a></li>
<li><a href="../122831/index.html">Qt. Creating a console widget for a graphics application</a></li>
<li><a href="../122832/index.html">Conference site DevCon'11 published conference materials</a></li>
<li><a href="../122834/index.html">OAuth VKontakte: mercenary use</a></li>
<li><a href="../122835/index.html">Transparent proxying in I2P and Tor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>