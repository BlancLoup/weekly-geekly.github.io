<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fourier processing of digital images</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 A digital photograph or other raster image is an array of numbers recorded by the brightness levels sensors in a two-dimensional plane. Kno...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fourier processing of digital images</h1><div class="post__text post__text-html js-mediator-article"><h2>  Foreword </h2><br>  A digital photograph or other raster image is an array of numbers recorded by the brightness levels sensors in a two-dimensional plane.  Knowing that from a mathematical point of view, a thin lens performs the Fourier transform of images placed in focal planes, it is possible to create image processing algorithms that are analogous to image processing by a classical optical system. <br><br>  The formula of such algorithms will be as follows: <br><ol><li>  Z = FFT (X) is the direct two-dimensional Fourier transform </li><li>  Z ‚Ä≤ = T (Z) - application of the function or transparency to the Fourier transform of the image </li><li>  Y = BFT (Z) is the inverse two-dimensional Fourier transform </li></ol><br>  To calculate the Fourier transforms, the Fast Discrete Fourier Transform algorithms are used.  Although the optical system of lenses performs the Fourier transform on the continuous range of the argument for the continuous spectrum, but when switching to digital data processing, the Fourier transform formulas can be replaced with the discrete Fourier transform formulas. <br><br><h2>  Implementation examples </h2><br><ul><li>  Image Blur Algorithm </li><li>  Image Sharpening Algorithm </li><li>  Image scaling algorithm </li></ul><br>  The implemented algorithms are part of the open source FFTTools library.  Internet address: <a href="https://github.com/dprotopopov/FFTTools">github.com/dprotopopov/FFTTools</a> <br><a name="habracut"></a><br><h2>  Image Blur Algorithm </h2><br>  In optical systems, the aperture located in the focal plane is a simple hole in the screen.  As a result of the passage of the light flux through the diaphragm, the high-frequency waves (with shorter wavelengths) pass through an obstacle, and the low-frequency waves (with longer wavelengths) are cut off by the screen.  This increases the sharpness of the resulting image.  If you replace the hole in the screen with an obstacle in the screen, the result will be a blurred image, since it will be formed from the frequencies of waves of great lengths. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Algorithm: <br><ol><li>  Let X (N1, N2) be the array of brightness of the image pixels. </li><li>  Calculate Px = the mean (root mean square) brightness of the pixels in the array X </li><li>  Calculate the array Z = FT (X) - direct two-dimensional discrete Fourier transform </li><li>  Calculate the array Z ‚Ä≤ = T (Z), where T is the zeroing of rows and columns located in the specified internal regions of the matrix argument corresponding to the high frequencies 5. (i.e., the zeroing of the Fourier expansion coefficients corresponding to high frequencies) </li><li>  Calculate the array Y = RFT (Z ‚Ä≤) - the inverse two-dimensional discrete Fourier transform </li><li>  Calculate Py = Mean (RMS) Brightness of Pixels in Array Y </li><li>  Normalize the array Y (N1, N2) on the average level of brightness Px / Py </li></ol><br><h2>  Image Sharpening Algorithm </h2><br>  In optical systems, the aperture located in the focal plane is a simple hole in the screen.  As a result of the passage of the light flux through the diaphragm, the high-frequency waves (with shorter wavelengths) pass through an obstacle, and the low-frequency waves (with longer wavelengths) are cut off by the screen.  This increases the sharpness of the resulting image. <br><br>  Algorithm: <br><ol><li>  Let X (N1, N2) be the array of brightness of the image pixels. </li><li>  Calculate Px = the mean (root mean square) brightness of the pixels in the array X </li><li>  Calculate the array Z = FT (X) - direct two-dimensional discrete Fourier transform </li><li>  Save value L = Z (0,0) - corresponding to the average brightness of the pixels of the original image </li><li>  Calculate the array Z ‚Ä≤ = T (Z), where T is the zeroing of rows and columns located in the specified external regions of the matrix argument corresponding to the low 6. frequencies (i.e. zeroing of the Fourier expansion coefficients corresponding to low frequencies) </li><li>  Restore Z 'value (0,0) = L - corresponding to the average brightness of the pixels of the original image </li><li>  Calculate the array Y = RFT (Z ‚Ä≤) - the inverse two-dimensional discrete Fourier transform </li><li>  Calculate Py = Mean (RMS) Brightness of Pixels in Array Y </li><li>  Normalize the array Y (N1, N2) on the average level of brightness Px / Py </li></ol><br><h2>  Image scaling algorithm </h2><br>  In optical systems, the light flux in the focal plane of the system is the Fourier transform of the original image.  The size of the image obtained at the output of the optical system is determined by the ratio of the focal distances of the lens and the eyepiece. <br><br>  Algorithm: <br><ol><li>  Let X (N1, N2) be the array of brightness of the image pixels. </li><li>  Calculate Px = the mean (root mean square) brightness of the pixels in the array X </li><li>  Calculate the array Z = FT (X) - direct two-dimensional discrete Fourier transform </li><li>  Calculate the array Z ‚Ä≤ = T (Z), where T is either adding zero rows and matrix columns corresponding to high frequencies, or removing matrix rows and columns corresponding to high frequencies to obtain the required size of the final image </li><li>  Calculate the array Y = RFT (Z ‚Ä≤) - the inverse two-dimensional discrete Fourier transform </li><li>  Calculate Py = Mean (RMS) Brightness of Pixels in Array Y </li><li>  Normalize the array Y (M1, M2) at the average level of brightness Px / Py </li></ol><br>  <b>Used software</b> <br><ul><li>  Microsoft Visual Studio 2013 C # - environment and programming language </li><li>  EmguCV / OpenCV - C ++ library of structures and algorithms for image processing </li><li>  FFTWSharp / FFTW - C ++ library that implements fast discrete Fourier transform algorithms </li></ul><br><h2>  Image Blur Algorithm </h2><br><div class="spoiler">  <b class="spoiler_title">Algorithm Code</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Clear internal region of array </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="data"&gt;</span></span></span><span class="hljs-comment">Array of values</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="size"&gt;</span></span></span><span class="hljs-comment">Internal blind region size</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private static void Blind(Complex[,,] data, Size size) { int n0 = data.GetLength(0); int n1 = data.GetLength(1); int n2 = data.GetLength(2); int s0 = Math.Max(0, (n0 - size.Height)/2); int s1 = Math.Max(0, (n1 - size.Width)/2); int e0 = Math.Min((n0 + size.Height)/2, n0); int e1 = Math.Min((n1 + size.Width)/2, n1); for (int i = s0; i </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; e0; i++) { Array.Clear(data, i*n1*n2, n1*n2); } for (int i = 0; i &lt; s0; i++) { Array.Clear(data, i*n1*n2 + s1*n2, (e1 - s1)*n2); } for (int i = e0; i &lt; n0; i++) { Array.Clear(data, i*n1*n2 + s1*n2, (e1 - s1)*n2); } } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Blur bitmap with the Fastest Fourier Transform </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">Blured bitmap</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public Bitmap Blur(Bitmap bitmap) { using (var image = new Image</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Bgr, double&gt;</span></span></span><span class="hljs-comment">(bitmap)) { int length = image.Data.Length; int n0 = image.Data.GetLength(0); int n1 = image.Data.GetLength(1); int n2 = image.Data.GetLength(2); var doubles = new double[length]; Buffer.BlockCopy(image.Data, 0, doubles, 0, length*sizeof (double)); double power = Math.Sqrt(doubles.Average(x =&gt; x*x)); var input = new fftw_complexarray(doubles.Select(x =&gt; new Complex(x, 0)).ToArray()); var output = new fftw_complexarray(length); fftw_plan.dft_3d(n0, n1, n2, input, output, fftw_direction.Forward, fftw_flags.Estimate).Execute(); Complex[] complex = output.GetData_Complex(); var data = new Complex[n0, n1, n2]; var buffer = new double[length*2]; GCHandle complexHandle = GCHandle.Alloc(complex, GCHandleType.Pinned); GCHandle dataHandle = GCHandle.Alloc(data, GCHandleType.Pinned); IntPtr complexPtr = complexHandle.AddrOfPinnedObject(); IntPtr dataPtr = dataHandle.AddrOfPinnedObject(); Marshal.Copy(complexPtr, buffer, 0, buffer.Length); Marshal.Copy(buffer, 0, dataPtr, buffer.Length); Blind(data, _blinderSize); Marshal.Copy(dataPtr, buffer, 0, buffer.Length); Marshal.Copy(buffer, 0, complexPtr, buffer.Length); complexHandle.Free(); dataHandle.Free(); input.SetData(complex); fftw_plan.dft_3d(n0, n1, n2, input, output, fftw_direction.Backward, fftw_flags.Estimate).Execute(); double[] array2 = output.GetData_Complex().Select(x =&gt; x.Magnitude).ToArray(); double power2 = Math.Sqrt(array2.Average(x =&gt; x*x)); doubles = array2.Select(x =&gt; x*power/power2).ToArray(); Buffer.BlockCopy(doubles, 0, image.Data, 0, length*sizeof (double)); return image.Bitmap; } }</span></span></code> </pre> <br></div></div><br><h2>  Image Sharpening Algorithm </h2><br><div class="spoiler">  <b class="spoiler_title">Algorithm Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Clear external region of array </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="data"&gt;</span></span></span><span class="hljs-comment">Array of values</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="size"&gt;</span></span></span><span class="hljs-comment">External blind region size</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private static void Blind(Complex[,,] data, Size size) { int n0 = data.GetLength(0); int n1 = data.GetLength(1); int n2 = data.GetLength(2); int s0 = Math.Max(0, (n0 - size.Height)/2); int s1 = Math.Max(0, (n1 - size.Width)/2); int e0 = Math.Min((n0 + size.Height)/2, n0); int e1 = Math.Min((n1 + size.Width)/2, n1); for (int i = 0; i </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; s0; i++) { Array.Clear(data, i*n1*n2, s1*n2); Array.Clear(data, i*n1*n2 + e1*n2, (n1 - e1)*n2); } for (int i = e0; i &lt; n0; i++) { Array.Clear(data, i*n1*n2, s1*n2); Array.Clear(data, i*n1*n2 + e1*n2, (n1 - e1)*n2); } } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Sharp bitmap with the Fastest Fourier Transform </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">Sharped bitmap</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public Bitmap Sharp(Bitmap bitmap) { using (var image = new Image</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Bgr, double&gt;</span></span></span><span class="hljs-comment">(bitmap)) { int length = image.Data.Length; int n0 = image.Data.GetLength(0); int n1 = image.Data.GetLength(1); int n2 = image.Data.GetLength(2); var doubles = new double[length]; Buffer.BlockCopy(image.Data, 0, doubles, 0, length*sizeof (double)); double power = Math.Sqrt(doubles.Average(x =&gt; x*x)); var input = new fftw_complexarray(doubles.Select(x =&gt; new Complex(x, 0)).ToArray()); var output = new fftw_complexarray(length); fftw_plan.dft_3d(n0, n1, n2, input, output, fftw_direction.Forward, fftw_flags.Estimate).Execute(); Complex[] complex = output.GetData_Complex(); Complex level = complex[0]; var data = new Complex[n0, n1, n2]; var buffer = new double[length*2]; GCHandle complexHandle = GCHandle.Alloc(complex, GCHandleType.Pinned); GCHandle dataHandle = GCHandle.Alloc(data, GCHandleType.Pinned); IntPtr complexPtr = complexHandle.AddrOfPinnedObject(); IntPtr dataPtr = dataHandle.AddrOfPinnedObject(); Marshal.Copy(complexPtr, buffer, 0, buffer.Length); Marshal.Copy(buffer, 0, dataPtr, buffer.Length); Blind(data, _blinderSize); Marshal.Copy(dataPtr, buffer, 0, buffer.Length); Marshal.Copy(buffer, 0, complexPtr, buffer.Length); complexHandle.Free(); dataHandle.Free(); complex[0] = level; input.SetData(complex); fftw_plan.dft_3d(n0, n1, n2, input, output, fftw_direction.Backward, fftw_flags.Estimate).Execute(); double[] array2 = output.GetData_Complex().Select(x =&gt; x.Magnitude).ToArray(); double power2 = Math.Sqrt(array2.Average(x =&gt; x*x)); doubles = array2.Select(x =&gt; x*power/power2).ToArray(); Buffer.BlockCopy(doubles, 0, image.Data, 0, length*sizeof (double)); return image.Bitmap; } }</span></span></code> </pre><br></div></div><br><h2>  Image scaling algorithm </h2><br><div class="spoiler">  <b class="spoiler_title">Algorithm Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Copy arrays </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="input"&gt;</span></span></span><span class="hljs-comment">Input array</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="output"&gt;</span></span></span><span class="hljs-comment">Output array</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private static void Copy(Complex[,,] input, Complex[,,] output) { int n0 = input.GetLength(0); int n1 = input.GetLength(1); int n2 = input.GetLength(2); int m0 = output.GetLength(0); int m1 = output.GetLength(1); int m2 = output.GetLength(2); int ex0 = Math.Min(n0, m0)/2; int ex1 = Math.Min(n1, m1)/2; int ex2 = Math.Min(n2, m2); Debug.Assert(n2 == m2); for (int k = 0; k </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; ex2; k++) { for (int i = 0; i &lt;= ex0; i++) { for (int j = 0; j &lt;= ex1; j++) { int ni = n0 - i - 1; int nj = n1 - j - 1; int mi = m0 - i - 1; int mj = m1 - j - 1; output[i, j, k] = input[i, j, k]; output[mi, j, k] = input[ni, j, k]; output[i, mj, k] = input[i, nj, k]; output[mi, mj, k] = input[ni, nj, k]; } } } } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Resize bitmap with the Fastest Fourier Transform </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">Resized bitmap</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public Bitmap Stretch(Bitmap bitmap) { using (var image = new Image</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Bgr, double&gt;</span></span></span><span class="hljs-comment">(bitmap)) { int length = image.Data.Length; int n0 = image.Data.GetLength(0); int n1 = image.Data.GetLength(1); int n2 = image.Data.GetLength(2); var doubles = new double[length]; Buffer.BlockCopy(image.Data, 0, doubles, 0, length*sizeof (double)); double power = Math.Sqrt(doubles.Average(x =&gt; x*x)); var input = new fftw_complexarray(doubles.Select(x =&gt; new Complex(x, 0)).ToArray()); var output = new fftw_complexarray(length); fftw_plan.dft_3d(n0, n1, n2, input, output, fftw_direction.Forward, fftw_flags.Estimate).Execute(); Complex[] complex = output.GetData_Complex(); using (var image2 = new Image</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Bgr, double&gt;</span></span></span><span class="hljs-comment">(_newSize)) { int length2 = image2.Data.Length; int m0 = image2.Data.GetLength(0); int m1 = image2.Data.GetLength(1); int m2 = image2.Data.GetLength(2); var complex2 = new Complex[length2]; var data = new Complex[n0, n1, n2]; var data2 = new Complex[m0, m1, m2]; var buffer = new double[length*2]; GCHandle complexHandle = GCHandle.Alloc(complex, GCHandleType.Pinned); GCHandle dataHandle = GCHandle.Alloc(data, GCHandleType.Pinned); IntPtr complexPtr = complexHandle.AddrOfPinnedObject(); IntPtr dataPtr = dataHandle.AddrOfPinnedObject(); Marshal.Copy(complexPtr, buffer, 0, buffer.Length); Marshal.Copy(buffer, 0, dataPtr, buffer.Length); complexHandle.Free(); dataHandle.Free(); Copy(data, data2); buffer = new double[length2*2]; complexHandle = GCHandle.Alloc(complex2, GCHandleType.Pinned); dataHandle = GCHandle.Alloc(data2, GCHandleType.Pinned); complexPtr = complexHandle.AddrOfPinnedObject(); dataPtr = dataHandle.AddrOfPinnedObject(); Marshal.Copy(dataPtr, buffer, 0, buffer.Length); Marshal.Copy(buffer, 0, complexPtr, buffer.Length); complexHandle.Free(); dataHandle.Free(); var input2 = new fftw_complexarray(complex2); var output2 = new fftw_complexarray(length2); fftw_plan.dft_3d(m0, m1, m2, input2, output2, fftw_direction.Backward, fftw_flags.Estimate).Execute(); double[] array2 = output2.GetData_Complex().Select(x =&gt; x.Magnitude).ToArray(); double power2 = Math.Sqrt(array2.Average(x =&gt; x*x)); double[] doubles2 = array2.Select(x =&gt; x*power/power2).ToArray(); Buffer.BlockCopy(doubles2, 0, image2.Data, 0, length2*sizeof (double)); return image2.Bitmap; } } }</span></span></code> </pre><br></div></div><br><br><h2>  Screenshots of programs </h2><br><div class="spoiler">  <b class="spoiler_title">Blur image</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/098/bef/10c/098bef10cbb825ae371924c1f3b85be5.jpg" alt="image"><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Image scaling</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/608/53c/6e4/60853c6e4c667f02dea6fd2fa854d87f.jpg" alt="image"><br></div></div><br><br><h2>  Literature </h2><br><ol><li>  A.L.  Dmitriev.  Optical methods of information processing.  Tutorial.  SPb.  SPUGUITMO 2005. 46 p. </li><li>  A.A. Akaev, S..Mayorov ‚ÄúOptical methods of information processing‚Äù M.: 1988 </li><li>  J. Goodman "Introduction to Fourier Optics" M .: Mir 1970 </li></ol></div><p>Source: <a href="https://habr.com/ru/post/265781/">https://habr.com/ru/post/265781/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265771/index.html">Summary of Udi Dahan‚Äôs ‚ÄúIntegrated Service Approach‚Äù presentation from ¬µCon 2014: The Microservices Conference</a></li>
<li><a href="../265773/index.html">SpiderTest: use the power of CI</a></li>
<li><a href="../265775/index.html">We write the real noise of Perlin</a></li>
<li><a href="../265777/index.html">Windows 10 through 10. Issue # 2. Interaction with users through live tiles and notifications</a></li>
<li><a href="../265779/index.html">‚ÄúThank you for using our products and services.‚Äù What we allow services</a></li>
<li><a href="../265783/index.html">Housing cost as a function of coordinates</a></li>
<li><a href="../265785/index.html">Data Access Layer as a storage management tool</a></li>
<li><a href="../265787/index.html">Books according to which we taught programming in childhood and we will teach children</a></li>
<li><a href="../265791/index.html">Using Intel HAXM when developing applications for Android Wear and TV</a></li>
<li><a href="../265793/index.html">Experience developing games for Android. From idea to implementation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>