<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What we lack in java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will look at some of the missing features in Java. But it must be immediately emphasized that certain things will be deliberately ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What we lack in java</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/41e/353/f13/41e353f135c44f6abf5f31dd7eab624d.jpg"><br><br>  In this article, we will look at some of the missing features in Java.  But it must be immediately emphasized that certain things will be deliberately omitted, which are either already actively discussed or require too much work at the virtual machine level.  For example: <br><br>  <b>There are no materialized generics (reified generics)</b> .  Only the lazy one didn‚Äôt write about it, and most of the comments indicate a lack of understanding of the essence of type mashing.  If a Java developer says, ‚ÄúI don‚Äôt like typewriting,‚Äù then in most cases this means, ‚ÄúI need a <code>List int</code> .‚Äù  The question of the primitive specialization of generics is only indirectly related to mashing, and the benefits of generics seen during the execution are greatly exaggerated by the rumors. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Unsigned calculations (unsigned arithmetic) at the virtual machine level.</b>  The lack of support for unsigned arithmetic types in Java has caused discontent among developers for many years.  But this is a deliberate decision of the creators of the language.  The presence of only sign calculations greatly simplifies the language.  If today we begin to implement unsigned types, then this will entail a very serious processing of Java, which is fraught with a mass of large and small bugs that will be difficult to catch.  At the same time greatly increases the risk of destabilization of the entire platform. <br><br>  <b>Long pointers for arrays</b> .  Again, the introduction of this functionality will require too deep processing of the JVM with possible unpleasant consequences, and not only in terms of the behavior and semantics of garbage collectors.  Although it should be noted that Oracle is looking for ways to implement such functionality using the VarHandles project. <br><br>  Here we will not go into details of the possible Java syntax for the discussed functionality.  Unfortunately, such discussions in general often fall into disputes about the syntax, although semantics is more important. <br><a name="habracut"></a><br><h3>  More expressive import syntax </h3><br>  The syntax for importing into Java provides us with not so many possibilities, only two options are available: import of one class or the whole package.  And if you need to import only part of the package, then you have to pile up a bunch of lines.  Also, the poverty of the syntax makes it necessary to use IDE features such as import convolution for the largest Java files. <br><br>  It would make life easier if we could import several classes from one package in one line: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.{List, Map};</code> </pre><br>  The readability of the code would increase due to the possibility of local type renaming (or creating an alias).  At the same time there would be less confusion with types that have the same short class name: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.{Date : UDate}; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.sql.{Date : SDate}; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Future; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.{Future : SFuture};</code> </pre><br>  Benefit and implement extended wildcard characters: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.{*Map};</code> </pre><br>  This is a small but useful change that can be fully implemented using javac. <br><br><h3>  Literals Collections </h3><br>  In Java, there is a syntax (albeit limited) for declaring array literals.  For example: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] i = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre><br>  This syntax has several disadvantages.  For example, literals should only be used in initializers. <br><br>  Arrays in Java are not collections.  The ‚Äúbridge methods‚Äù presented in the auxiliary class <code>Arrays</code> also have flaws.  Say, the <code>Arrays.asList()</code> method returns an <code>ArrayList</code> , which on closer inspection turns out to be <code>Arrays.ArrayList</code> .  This inner class does not contain alternative methods for the <code>List</code> , and similar methods throw an <code>OperationNotSupportedException</code> exception.  As a result, an ugly seam occurs in the API, making it difficult to navigate between arrays and collections. <br><br>  There are no reasons for refusing the syntax of declaring an array literal; in one form or another it is present in many languages.  For example, in Perl you can write this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $primes = [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $capitals = {<span class="hljs-string"><span class="hljs-string">'UK'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'London'</span></span>, <span class="hljs-string"><span class="hljs-string">'France'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Paris'</span></span>};  Scala ‚Äî : val primes = Array(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>); val <span class="hljs-keyword"><span class="hljs-keyword">m</span></span> = Map(<span class="hljs-string"><span class="hljs-string">'UK'</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'London'</span></span>, <span class="hljs-string"><span class="hljs-string">'France'</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'Paris'</span></span>);</code> </pre><br>  Unfortunately, Java has no useful collection literals.  This question has been raised repeatedly, but this functionality has not appeared in either Java 7 or Java 8.  Object literals are also interesting, but in Java they are much more difficult to implement. <br><br><h3>  Structural typing </h3><br>  Naming plays a very important role in the type system in Java.  All variables must refer to named types, and it is impossible to express a type only through the definition of its structure.  In other languages, for example, in Scala, you can express a type without declaring it when implementing an interface (or Scala trait), but simply by confirming that it contains a specific method: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whoLetTheDucksOut</span></span></span></span>(d: {<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">quack</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">String</span></span>}) { println(d.quack()); }</code> </pre><br>  In this case, any type that contains the <code>quack()</code> method will be accepted, regardless of whether there is inheritance or types using a common interface. <br><br>  It is no coincidence that <code>quack()</code> was chosen as an example - structural typing has much in common with duck typing in the same Python.  However, in Scala, typing is done at compilation, which indicates the flexibility of the language in terms of expressing types that would be difficult or impossible to express in Java.  Unfortunately, here the type system has very little structural typing capabilities.  You can specify a local anonymous type with additional methods, and if one of them is immediately called, Java will allow you to compile the code. <br><br>  This is where the possibilities end: we can create only one ‚Äústructural‚Äù method.  From it it is impossible to return the type that contains the additional information we need.  All structural methods are valid, expressed in bytecode and support reflexive access.  They simply cannot be expressed using the Java type system.  Perhaps this should not surprise anyone, since structural methods are actually implemented using an additional class file that corresponds to an anonymous local type. <br><br><h3>  Algebraic data types </h3><br>  Thanks to generics, Java is a language with parameterized types (parameterized types), which are reference types with type parameters.  When they are substituted into some types, others are formed.  That is, the resulting types consist of ‚Äúcontainers‚Äù (generic types) and ‚Äúpayload‚Äù (values ‚Äã‚Äãof type parameters). <br><br>  In some languages, the supported composite types are very different from Java generics.  As an example, tuples are immediately suggested, although sum type (sum type), sometimes also called ‚Äúdisjoint union of types‚Äù or ‚Äúhosted unions‚Äù (tagged union), are of much more interest. <br><br>  Type-sum is an unambiguous type, that is, at each moment of time variables can have only one value.  But at the same time it can be any valid value belonging to a specified range of different types.  This is true even if the non-connected types that are values ‚Äã‚Äãare in no way related to each other in terms of inheritance.  For example, in the F # language, you can specify the type Shape, instances of which can be rectangles or circles: <br><br> <code>type Shape =</code> <br> <code>| Circle of int</code> <br> <code>| Rectangle of int * int</code> <br> <br>  F # is very different from Java, but in Scala these types are implemented with restrictions: sealed types are used with case classes.  A sealed class cannot be extended beyond the current compilation unit.  This is practically an analogue of the terminal class in Java, but in Scala, the base unit of compilation is a file, and numerous high-level open classes (public classes) can be declared in a single file. <br><br>  This leads us to a pattern in which a sealed abstract base class is declared along with several subclasses that correspond to possible incoherent types from a type-sum.  The Scala standard library contains many examples of using this pattern, including <code>Option[A]</code> , which is similar to the <code>Optional T</code> type from Java 8. <br><br>  In Scala, the disjoint unions of the two possibilities include <code>Option</code> and <code>Some</code> , as well as the <code>None</code> and <code>Option type</code> . <br><br>  If we implemented the same mechanism in Java, we would face a restriction when the compilation unit is essentially a class.  It turns out not as convenient as in Scala, but you can still come up with solutions.  For example, you could use javac to handle the new syntax for the classes we want to seal: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> example.algebraic;</code> </pre><br>  Such a syntax would mean that the compiler should allow for class extension taking into account the final packaging within the current folder, rejecting all other expansion attempts.  This change could also be implemented using javac, but without checks during execution it cannot be completely protected against a cyclic code (reflective code).  In addition, a Java implementation would be less useful than in Scala, since Java lacks developed match expressions. <br><br><h3>  Dynamic call sites </h3><br>  Starting from version 7 in Java, a surprisingly useful tool has appeared: <code>invokedynamic</code> bytecode, designed to perform the role of the main calling mechanism.  This allows you to run dynamic languages ‚Äã‚Äãon top of the JVM, as well as extend the type system in Java by adding built-in methods and changing the interface, while previously it was not possible.  Pay for this account for a slightly increased complexity.  But with skillful handling, <code>invokedynamic</code> is a powerful tool. <br><br>  True, he has one strange limitation.  Despite the declared support in Java 7, for some reason, direct access to methods of dynamic invocation is still not provided.  Although the whole point of dynamic dispatch is to allow developers to decide for themselves which method to call from a particular call point, and the decision can be postponed until the moment the code is executed. <br><br>  Note: Do not confuse this dynamic binding method with the C # <code>dynamic</code> keyword.  In our case, an object is entered that dynamically defines its bindings during execution;  this does not work if the object does not support the requested method calls.  Instances of such dynamic objects in the course of execution are indistinguishable from "ordinary" objects, and the mechanism itself turns out to be unsafe. <br><br>  While <code>invokedynamic</code> used to implement lambda expressions and embedded methods in Java, developers do not have direct access and cannot perform dispatching at runtime.  In other words, in Java there is no keyword or other construct for creating general purpose <code>invokedynamic</code> call points.  The javac compiler simply does not translate <code>invokedynamic</code> instructions outside of the language infrastructure. <br><br>  You can simply add this functionality to Java.  For example, using some keyword or annotating.  You will also need an additional library and support at the assembly stage. <br><br><h3>  Glimmers of hope? </h3><br>  The development of language architecture and its implementation is the art of achieving the possible.  There are many examples when important changes make their way very long.  For example, in C ++, lambda expressions appeared only in version 14. <br><br>  Many people do not like the leisurely development of Java.  But <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE%25D1%2581%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B3,_%25D0%2594%25D0%25B6%25D0%25B5%25D0%25B9%25D0%25BC%25D1%2581">James Gosling</a> takes the position that functionality cannot be implemented until it is fully understood and understood.  Although the conservatism of the Java architecture is one of the reasons for the success of this language, at the same time, many impatient young developers who are eager for rapid change do not like it.  Are any of the above possibilities being implemented?  You can carefully assume this. <br><br>  Some of the ideas described can be implemented using the same <code>invokedynamic</code> .  As you remember, it should fulfill the role of the main mechanism of the call, postponed until the moment of execution.  According to the proposal to improve the <a href="http://openjdk.java.net/jeps/276">JEP276</a> language, you can standardize the Dynalink library, which was originally created by Attila Szegedi for the implementation of the ‚Äúmeta-object protocol‚Äù in the JVM.  Later, the library author moved to work at Oracle, which used Dynalink in Nashorn, a JavaScript implementation on the JVM.  The library description is on Github, but it has been removed from there. <br><br>  Essentially, Dynalink allows you to talk about object-oriented operations - ‚Äúget the value of a property‚Äù, ‚Äúassign a property a value‚Äù, ‚Äúcreate a new object‚Äù, ‚Äúcall a method‚Äù - without having to implement their semantics with the help of the corresponding statically typed, low-level JVM operations. <br><br>  This binding technology can be used to implement dynamic linkers, whose behavior will be different from the standard.  In addition, it can act as a kind of draft for the implementation of new properties of the type system in Java. <br><br>  Some key Scala developers considered this mechanism as a possible replacement for the implementation of structural types in this language.  Although in the current version the bet is made on reflection, but the appearance of Dynalink on the scene can change everything. </div><p>Source: <a href="https://habr.com/ru/post/281513/">https://habr.com/ru/post/281513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281501/index.html">Project Tofino - the new Mozilla browser</a></li>
<li><a href="../281503/index.html">Interfaces: How not to do the option of unsubscribing from the email-list</a></li>
<li><a href="../281505/index.html">How we implemented DevOps: infrastructure-as-code using Microsoft Azure and Azure Resource Manager</a></li>
<li><a href="../281509/index.html">5G core networks: flexibility opens up new business opportunities</a></li>
<li><a href="../281511/index.html">// BUILD / 2016: how it was</a></li>
<li><a href="../281515/index.html">How to determine the best time for a transaction in the stock market: Trend following algorithms</a></li>
<li><a href="../281517/index.html">How to write a bloom filter in C ++</a></li>
<li><a href="../281519/index.html">More than 80 Linux system monitoring tools</a></li>
<li><a href="../281521/index.html">What's new in Vim 8</a></li>
<li><a href="../281523/index.html">Develop HTML5 games in Intel XDK. Part 3. Meet the Snake</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>