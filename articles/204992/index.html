<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write your DSL on Clojure to work with the database</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's write a Clojure library for working with relational databases. At the same time we will practice writing macros, try using protocols and multi m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write your DSL on Clojure to work with the database</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/fea/6af/72b/fea6af72b09f9ded1aa29426d1c429e8.png" align="left"><br>  Let's write a Clojure library for working with relational databases.  At the same time we will practice writing macros, try using protocols and multi methods.  After all, there is no better way to learn a language than to write something on it.  Well ... or read, as someone else wrote. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">What for?</b> <div class="spoiler_text">  At one time I needed such a library for personal needs.  At that time there were two common solutions - ClojureQL and Korma.  For one reason or another, I did not like them (yes, a fatal flaw), it was decided to make my own bike.  The bike is quite working, I am satisfied.  Of the external differences - higher extensibility, the emphasis was on the ease of adding new operators and functions, it was important to support subqueries and inserts from bare SQL. <br><br>  The article describes the general structure of this bike, albeit in a somewhat simplified form.  There are no some features, the code was usually developed in a different sequence, many intermediate API options were left behind.  But, in general, the main architectural ideas are described accurately.  I hope someone article will be useful. <br></div></div><br><h4>  So what are we writing? </h4><br>  We create DSL ( <b>not</b> ORM).  Unlike ORM: <br>  - no "smart objects" - only functions and embedded data structures (including records); <br>  - no "lazy" connections, magical loading of records and other "nastiness"; <br>  - we want to clearly control the time of occurrence of side effects - they should occur only in strictly expected places. <br><br>  Add a few more requirements: <br>  - similar to SQL; <br>  - transparency, the less ‚Äúmagic‚Äù - the better; <br>  - no validation of queries, schemas and the like - leave the database on the conscience; <br>  - automatic quoting of identifiers and arguments; <br>  - ensuring independence from a specific base (but without fanaticism); <br>  - sometimes we need to write DB-dependent code (stored, triggers, etc.). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is meant by "little magic"?  Roughly speaking, such a library <b>should not be</b> engaged in query optimization, and any such activity.  Theoretically, this, perhaps, will allow some (well, a little bit) to unload the database, in practice, things usually get worse.  After all, only the database and the programmer (occasionally) have sufficient knowledge to properly perform the necessary optimization.  The bad option: the developer writes the request, then very carefully examines the application logs in order to find out which SQL is actually sent to the database.  It is necessary to re-check the logs regularly, because after the new release the library may suddenly become ‚Äúsmarter‚Äù! <br><br>  So, our DSL will be rather <s>silly</s> transparent by possibilities - we work semantically with bare SQL, but use Clojure's syntax.  Something like writing SQL through S-expressions, taking into account the specifics of our language.  Everything will look like this: <br><br><pre><code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">select</span></span> (<span class="hljs-name"><span class="hljs-name">fields</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:role_name</span></span>]) (<span class="hljs-name"><span class="hljs-name">from</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>) (<span class="hljs-name"><span class="hljs-name">join-inner</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Roles</span></span> (<span class="hljs-name"><span class="hljs-name">==</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>.role_id <span class="hljs-symbol"><span class="hljs-symbol">:Roles</span></span>.id)) (<span class="hljs-name"><span class="hljs-name">where</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Roles</span></span>.name <span class="hljs-string"><span class="hljs-string">"admin"</span></span>)) (<span class="hljs-name"><span class="hljs-name">order</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>.name) (<span class="hljs-name"><span class="hljs-name">limit</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>))</code> </pre> <br><br>  For this code you will need to generate a query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">`name`</span></span>, <span class="hljs-string"><span class="hljs-string">`role_name`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">`Users`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-string"><span class="hljs-string">`Roles`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-string"><span class="hljs-string">`Users`</span></span>.<span class="hljs-string"><span class="hljs-string">`role_id`</span></span> = <span class="hljs-string"><span class="hljs-string">`Roles`</span></span>.<span class="hljs-string"><span class="hljs-string">`id`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-string"><span class="hljs-string">`Roles`</span></span>.<span class="hljs-string"><span class="hljs-string">`name`</span></span> = ? <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-string"><span class="hljs-string">`Users`</span></span>.<span class="hljs-string"><span class="hljs-string">`name`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> ?</code> </pre><br><br>  We screen all names with backquotes.  In an amicable way, you should use double quotes (and even better to take into account the type of database), but for readability purposes, we will use MySQL-style in the examples.  Constants are replaced by <code>?</code>  - The jdbc-driver of a specific database will itself deal with the transmission and shielding of parameters. <br><br>  Directly performing SELECT queries, we will deal with separate functions: <code>fetch-all</code> , <code>fetch-one</code> , <code>with-fetch</code> .  All of them accept as input the connection to the database and the request that we want to perform: <br><br><pre> <code class="hljs pgsql">(def db {:classname "com.mysql.jdbc.Driver" :subprotocol "mysql" :<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> "test" :<span class="hljs-keyword"><span class="hljs-keyword">password</span></span> "test" :subname "//localhost/test"}) ;   <span class="hljs-number"><span class="hljs-number">1</span></span>    Users (<span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>-one db (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :Users) (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (== :id <span class="hljs-number"><span class="hljs-number">123</span></span>)))) ;        (<span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> db (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :Users))) (<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span> db [<span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :Users))] ;     **  `<span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>` (doseq [r <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>] (print "&gt;" r)))</code> </pre><br><br><h4>  We generate SQL </h4><br>  To begin with we will be defined how we will store requests in our library. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> raw-select ['SELECT <span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:role_name</span></span> ['FROM <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span> ['JOIN <span class="hljs-symbol"><span class="hljs-symbol">:Roles</span></span> ['ON <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>.role_id <span class="hljs-symbol"><span class="hljs-symbol">:Roles_id</span></span>]]] ['WHERE ['LIKE <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>.name <span class="hljs-string"><span class="hljs-string">"And%"</span></span>] ['LIMIT <span class="hljs-number"><span class="hljs-number">100</span></span>]]])</code> </pre><br><br>  In this example, we have a tree of vectors, symbols, and keys.  Using symbols, we denote SQL keywords, with keys ‚Äî table and field names, values ‚Äã‚Äã(strings, numbers, dates, etc.) are left as is.  We represent the compiled query as a pair: SQL code (string) and vector of arguments.  We get a separate type: <br><br><pre> <code class="hljs sql">(defrecord Sql [sql args]) ;;      : (Sql. "<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">`Users`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-string"><span class="hljs-string">`id`</span></span> = ?<span class="hljs-string"><span class="hljs-string">" [123])</span></span></code> </pre><br><br>  This is the bottom view in our library.  We implement the conversion from one view to another.  To do this, you need a <i>universal</i> way to convert <i>any</i> entity into a <code>Sql</code> record.  Protocols are perfect: <br><br><pre> <code class="hljs pgsql">(defprotocol SqlLike (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this])) ;   (defn <span class="hljs-keyword"><span class="hljs-keyword">quote</span></span>-<span class="hljs-type"><span class="hljs-type">name</span></span> [s] (let [x (<span class="hljs-type"><span class="hljs-type">name</span></span> s)] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (= "*" x) x (str \` x \`)))) (extend-protocol SqlLike ;   `x` (= (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> x)) (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> x)) <span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] this) ;         <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] (<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>. "?" [this])) ;      clojure.lang.Keyword (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] (<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>. (<span class="hljs-keyword"><span class="hljs-keyword">quote</span></span>-<span class="hljs-type"><span class="hljs-type">name</span></span> this) nil)) ;     <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span> clojure.lang.Symbol (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] (<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>. (<span class="hljs-type"><span class="hljs-type">name</span></span> this) nil)) ;  nil    nil (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] (<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>. "NULL" nil)))</code> </pre><br><br>  Instead of protocols, one could use a set of <code>if</code> , or even pattern matching.  But protocols have an indisputable plus: library users can <i>themselves</i> implement a specific conversion for <i>any</i> type.  For example, someone might want to automagically extract values ‚Äã‚Äãfrom links: <br><br><pre> <code class="hljs pgsql">(extend-protocol SqlLike clojure.lang.ARef (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> @this))) ;      ;  (<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>, agent, var, atom) (def a (atom <span class="hljs-number"><span class="hljs-number">123</span></span>)) (<span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (= (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> a) (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> @a) (<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>. "?" [<span class="hljs-number"><span class="hljs-number">123</span></span>])))</code> </pre><br><br>  We implement our protocol for vectors and lists: <br><br><pre> <code class="hljs pgsql">;  ,  <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>-   (defn- <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>-sqls ([] (<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>. "" nil)) ([^<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span> s1 ^<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span> s2] (<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>. (str (.<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> s1) " " (.<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> s2)) (concat (.args s1) (.args s2))))) (extend-protocol SqlLike clojure.lang.Sequential (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] (reduce <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>-sqls (map <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> this))))</code> </pre><br><br>  With the efficiency of the algorithm here is not very good, you can write the code and quickly.  But now: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [<span class="hljs-string"><span class="hljs-string">'SELECT '</span></span>* [<span class="hljs-string"><span class="hljs-string">'FROM :Users] ['</span></span><span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> :id <span class="hljs-string"><span class="hljs-string">'= 1 '</span></span><span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> :<span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-string"><span class="hljs-string">'IS '</span></span><span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> nil]]) ; =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>{:<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> "SELECT * FROM `Users` WHERE `id` = ? AND `name` IS NOT NULL" :args (<span class="hljs-number"><span class="hljs-number">1</span></span>)}</code> </pre><br><br>  Fine!  Let's define a couple more functions ... <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">require</span></span> '[clojure.java.jdbc <span class="hljs-symbol"><span class="hljs-symbol">:as</span></span> jdbc]) (<span class="hljs-name"><span class="hljs-name">defn-</span></span> to-sql-params [relation] (<span class="hljs-name"><span class="hljs-name">let</span></span> [{s <span class="hljs-symbol"><span class="hljs-symbol">:sql</span></span> p <span class="hljs-symbol"><span class="hljs-symbol">:args</span></span>} (<span class="hljs-name"><span class="hljs-name">as-sql</span></span> relation)] (<span class="hljs-name"><span class="hljs-name">vec</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> sp)))) (<span class="hljs-name"><span class="hljs-name">defn</span></span> fetch-all [db relation] (<span class="hljs-name"><span class="hljs-name">jdbc/query</span></span> db (<span class="hljs-name"><span class="hljs-name">to-sql-params</span></span> relation) <span class="hljs-symbol"><span class="hljs-symbol">:result-set-fn</span></span> vec)) <span class="hljs-comment"><span class="hljs-comment">;   `fetch-one`</span></span></code> </pre><br><br>  Working directly with JDBC is tedious, so tricky - all the dirty work for us is done by <code>clojure.java.jdbc</code> .  Finally, we already have quite acceptable results, you can even use the library: <br><br><pre> <code class="hljs pgsql">;     (def db {:classname "com.mysql.jdbc.Driver" :subprotocol "mysql" :<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> "test" :<span class="hljs-keyword"><span class="hljs-keyword">password</span></span> "test" :subname "//localhost/test"}) ;     (<span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> db (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-string"><span class="hljs-string">'[SELECT * FROM :users ORDER BY :name]))</span></span></code> </pre><br><br>  Oh yeah, we forgot about <code>with-fetch</code> .  We realize: <br><br><pre> <code class="hljs pgsql">(defmacro <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span> [db [v rel :<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> vr] &amp; body] `(let [params# (<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>-params ~rel) rsf# (fn [~v] ~@body)] (jdbc/query ~db params# :result-<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>-fn rsf# ;  RS    rsf# :<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>-fn <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>))) ;    </code> </pre><br><br><h4>  Increasing queries iteratively </h4><br>  The selected view has serious drawbacks - it is difficult to increase queries <i>iteratively</i> .  Suppose we have a tree for the <code>SELECT FROM `Users` LIMIT 10</code> query, and we want to add a <code>WHERE</code> section to it.  In general, for this, you will have to parse the SQL syntax (analyze the AST-tree), which, in truth, would like to avoid. <br><br>  Why do we need to "iteratively increase" requests?  Well, firstly, this is a useful option in itself.  When writing a program, we often do not know in advance what requests we will carry out.  Example: dynamically build arbitrary conditions for the <code>WHERE</code> and ORDER BY sections in the admin panel. <br><br>  But more importantly, this is a good practice when writing Clojure programs.  We break work into many small pieces that do their work iteratively.  Each such brick (pure function) accepts data to the input and returns a ‚Äúcorrected‚Äù result.  Bricks are easy to test and develop.  And in the end such pieces easily come together. <br><br>  Requests are presented in the form of a hash table.  Example: <br><br><pre> <code class="hljs ruby">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-function"> { ;</span></span>  <span class="hljs-string"><span class="hljs-string">"  -  "</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:tables</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:r</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Roles</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:u</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>}, ;  [ ,  ,    ON] ;   -- [ , <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>] ;  , ..    join<span class="hljs-string"><span class="hljs-string">' :joins [[:u nil nil] [:r :inner ['</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>.role_id <span class="hljs-symbol"><span class="hljs-symbol">:Roles</span></span>.id]]] ; ast-  <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:u</span></span>.name <span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>], ;  <span class="hljs-string"><span class="hljs-string">"  -  "</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:fields</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:name</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:role_name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:role_name</span></span>}, ;   <span class="hljs-symbol"><span class="hljs-symbol">:offset</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:limit</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>, ; order, group, having, etc... })</code> </pre><br><br>  For sections <code>WHERE</code> , <code>ORDER BY</code> , etc.  we store the AST expression tree - it's easier.  For the list of tables and fields, we store dictionaries, keys - the names of aliases, values ‚Äã‚Äã- expressions or table names.  Within the framework of such a structure, we implement the necessary functions: <br><br><pre> <code class="hljs pgsql">;  `<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>` &amp; `<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span>`  (defn <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> [relation v] (assoc relation :<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> v)) ; **     (defn fields [query fd] (assoc query :fields fd)) (defn <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [query wh] (assoc query :<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> wh)) ; helper- (defn <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>* [{:keys [<span class="hljs-keyword"><span class="hljs-keyword">tables</span></span> joins] :<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> q} <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>] (let [a (<span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>)] (assoc q :<span class="hljs-keyword"><span class="hljs-keyword">tables</span></span> (assoc <span class="hljs-keyword"><span class="hljs-keyword">tables</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>) :joins (conj (<span class="hljs-keyword"><span class="hljs-keyword">or</span></span> joins []) [a <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>])))) (defn <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ([q <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>] (<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>* q nil <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> nil)) ([q <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>] (<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>* q nil <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> nil))) (defn <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> ([q <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>] (<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>* q :<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> nil)) ([q <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>] (<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>* q :<span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> nil))) ;;   <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>- (left, right, <span class="hljs-keyword"><span class="hljs-keyword">full</span></span>)   -  </code> </pre><br><br>  So, we have many functions ( <code>where</code> , <code>fields</code> , <code>from</code> , <code>join</code> , <code>limit</code> and others) that can "tweak" queries.  The starting point is an empty request. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> empty-select {})</code> </pre><br><br>  Now we can write: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-&gt;</span></span> empty-select (<span class="hljs-name"><span class="hljs-name">fields</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:role_name</span></span>]) (<span class="hljs-name"><span class="hljs-name">from</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>) (<span class="hljs-name"><span class="hljs-name">limit</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>))</code> </pre><br><br>  This code uses the macro <a href="http://clojuredocs.org/clojure_core/clojure.core/-%253E">-&gt;</a> , which unfolds into something like: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">limit</span></span> (<span class="hljs-name"><span class="hljs-name">from</span></span> (<span class="hljs-name"><span class="hljs-name">fields</span></span> empty-select [<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:role_name</span></span>]) <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>) <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre><br><br>  For beauty, we define our <code>select</code> macro, which behaves like <code>-&gt;</code> : <br><br><pre> <code class="hljs vhdl">(defmacro <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> [&amp; <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>] `(-&gt; empty-<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ~@<span class="hljs-keyword"><span class="hljs-keyword">body</span></span>))</code> </pre><br><br>  It remains to teach our library to convert one representation into another. <br><br><pre> <code class="hljs pgsql">;  <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>,  nil   "NULL" (def <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>. "" nil)) ;     (defn render-<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> [s] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>-let [l (:<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> s)] [<span class="hljs-string"><span class="hljs-string">'LIMIT l] NONE)) (defn render-fields [s] '</span></span>*) ;      ;      (defn render-<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [s] <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span>) (defn render-<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> [s] <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span>) (defn render-expression [s] <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span>) ;       (defn render-<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> [s] <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span>) (defn render-<span class="hljs-keyword"><span class="hljs-keyword">having</span></span> [s] <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span>) (defn render-<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> [s] <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span>) ;   (defn render-<span class="hljs-keyword"><span class="hljs-keyword">table</span></span> [[<span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>]] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (= <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>) ;     ,    <span class="hljs-string"><span class="hljs-string">'AS'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'AS alias])) (defn render-join-type [jt] (get {nil (symbol ",") :cross '</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">CROSS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span>], :left <span class="hljs-string"><span class="hljs-string">'[LEFT OUTER JOIN], :right '</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">RIGHT OUTER JOIN</span></span>], :<span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-string"><span class="hljs-string">'[INNER JOIN], :full '</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">FULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span>], } jt jt)) ;     (defn render-<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [{:keys [<span class="hljs-keyword"><span class="hljs-keyword">tables</span></span> joins]}] ;  <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span>    ! (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (empty? joins)) [<span class="hljs-string"><span class="hljs-string">'FROM ;   (let [[a jn] (first joins) t (tables a)] ;       `(from ..)` (assert (nil? jn)) (render-table [at])) ;    (for [[a jn c] (rest joins) :let [t (tables a)]] [(render-join-type jn) ;  JOIN XX   (render-table [at]) ;     (if c ['</span></span><span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (render-expression c)] <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span>) ;  <span class="hljs-string"><span class="hljs-string">'ON'</span></span> ])] <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span>)) (defn render-<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>] [<span class="hljs-string"><span class="hljs-string">'SELECT (mapv #(% select) [render-fields render-from render-where render-group render-having render-order render-limit render-offset])])</span></span></code> </pre><br><br>  Library users may not know about the <code>SqlLike</code> protocol and the <code>as-sql</code> function at all.  Good practice.  For comparison, in Java, interfaces often define a module / library API.  In Clojure, protocols are usually created for the lowest-level operations, some kind of basis, on which a set of helper functions are already working.  And now these helper-s provide a public library API.  We try to generate a simple query: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">fetch-all</span></span> db (<span class="hljs-name"><span class="hljs-name">render-select</span></span> (<span class="hljs-name"><span class="hljs-name">select</span></span> (<span class="hljs-name"><span class="hljs-name">from</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>) (<span class="hljs-name"><span class="hljs-name">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>)))</code> </pre><br><br>  Done!  It's true that manually calling a <code>render-select</code> tedious.  We fix: <br><br><pre> <code class="hljs sql">(<span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> render-<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>) ;      ; record   ,      (defrecord <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">fields</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> joins <span class="hljs-keyword"><span class="hljs-keyword">tables</span></span> offet <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>] SqlLike (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> (render-<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> this)))) (<span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> {}))</code> </pre><br><br>  Now, when running <code>(as-sql (select ...))</code> , the <code>render-select</code> will be automatically called: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> db (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :Users) (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>))) ;      <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>    (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">Table</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>))) ;    (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">Table</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>))</code> </pre><br><br><h4>  Expression support </h4><br>  Let's start writing the <code>where</code> function.  We want to be able to use it like this: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">select</span></span> (<span class="hljs-name"><span class="hljs-name">from</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Table</span></span>) (<span class="hljs-name"><span class="hljs-name">where</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:x</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">==</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:y</span></span> <span class="hljs-string"><span class="hljs-string">"z"</span></span>))))</code> </pre><br><br>  Obviously, it is impossible to calculate <code>(&gt; :x 1)</code> at the time of the <code>where</code> call - a macro is needed.  The constructed expression will be stored in the form of an AST-tree: nodes - operators, leaves - constants and fields.  First, we write a helper function <code>where*</code> : <br><br><pre> <code class="hljs ruby">;  <span class="hljs-number"><span class="hljs-number">2</span></span>     AND (defn- conj-expression [e1 e2] (cond (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (seq e1)) e2 (= <span class="hljs-string"><span class="hljs-string">'and (first e1)) (conj (vec e1) e2) :else (vector '</span></span><span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e1 e2))) (conj-expression <span class="hljs-string"><span class="hljs-string">'[&gt; 1 2] '</span></span>[&lt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> <span class="hljs-string"><span class="hljs-string">"b"</span></span>]) ; =&gt; <span class="hljs-string"><span class="hljs-string">'[and [&gt; 1 2] [&lt; "a" "b"]]) (conj-expression '</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">and</span></span> [&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> [+ <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>]] [= <span class="hljs-symbol"><span class="hljs-symbol">:x</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:y</span></span>]] <span class="hljs-string"><span class="hljs-string">'[&lt;&gt; "a" "b"]) ; =&gt; '</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">and</span></span> [&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> [+ <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>]] [= <span class="hljs-symbol"><span class="hljs-symbol">:x</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:y</span></span>] [&lt;&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> <span class="hljs-string"><span class="hljs-string">"b"</span></span>]] (defn where* [query expr] (assoc query <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> (conj-expression (<span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> query) expr)))</code> </pre><br><br>  Now it's time for a <code>render-where</code> : <br><br><pre> <code class="hljs mel">;   (declare <span class="hljs-keyword"><span class="hljs-keyword">render</span></span>-operator) (declare <span class="hljs-keyword"><span class="hljs-keyword">render</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">expression</span></span>) ;   ? (defn- function-symbol? [s] (re-matches #<span class="hljs-string"><span class="hljs-string">"\w+"</span></span> (name s))) ;      (defn <span class="hljs-keyword"><span class="hljs-keyword">render</span></span>-operator [op &amp; args] (let [ra (map <span class="hljs-keyword"><span class="hljs-keyword">render</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> args) lb (symbol <span class="hljs-string"><span class="hljs-string">"("</span></span>) rb (symbol <span class="hljs-string"><span class="hljs-string">")"</span></span>)] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (function-symbol? op) ;  (count, <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>, ...) [op lb (interpose (symbol <span class="hljs-string"><span class="hljs-string">","</span></span>) ra) rb] ;  (+, *, ...) [lb (interpose op (map <span class="hljs-keyword"><span class="hljs-keyword">render</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> args)) rb]))) (defn <span class="hljs-keyword"><span class="hljs-keyword">render</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">expression</span></span> [etree] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (and (sequential? etree) (symbol? (first etree))) (apply <span class="hljs-keyword"><span class="hljs-keyword">render</span></span>-operator etree) etree)) (defn <span class="hljs-keyword"><span class="hljs-keyword">render</span></span>-where [{:keys [where]}] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> where [<span class="hljs-string"><span class="hljs-string">'WHERE (render-expression where)] NONE))</span></span></code> </pre><br><br>  Great, now we can write the simplest expressions: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">select</span></span> (<span class="hljs-name"><span class="hljs-name">from</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:Users</span></span>) (<span class="hljs-name"><span class="hljs-name">where*</span></span> ['= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>]) (<span class="hljs-name"><span class="hljs-name">as-sql</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; =&gt; (Sql. "SELECT * FROM `Users` WHERE ( `id` = ? )" [1])</span></span></code> </pre><br><br>  It turned out ugly, fix it with a simple macro: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> prepare-expression [e] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">seq</span></span>? e) `(vector (quote ~(first e)) ~@(map prepare-expression (rest e))) e)) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> where [q body] `(where* ~q ~(prepare-expression body)))</code> </pre><br><br>  Replace all sequences (lists) with vectors.  The remaining values ‚Äã‚Äãare left as is.  We missed an important point - some operators in Clojure and SQL are called differently, for example <code>&lt;&gt;</code> and <code>not=</code> .  A philosophical question, which option is better to use.  On the one hand, we decided to leave the library as ‚Äústupid‚Äù as possible, on the other, it is much more pleasant to see the functions ‚Äúnative‚Äù for Clojure.  Let's allow both options: <br><br><pre> <code class="hljs swift">(defn- canonize-<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-symbol [op] (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> '{not= &lt;&gt;, == =} op op)) ;   (defn prepare-expression [e] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (seq? e) `(vector (quote ~(canonize-<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-symbol (first e))) ~@(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> prepare-expression (rest e))) e))</code> </pre><br><br>  Well, when using the <code>where</code> macro, you can write both options, but inside our query view there will be only one.  What you need.  We have a small favor - joins do not work. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defmacro</span></span> join-left ([q table cond] `(let [t# ~table] (join-left ~qt# <span class="hljs-literal"><span class="hljs-literal">t</span></span># ~cond))) ([q table alias cond] (<span class="hljs-name"><span class="hljs-name">join*</span></span> ~q <span class="hljs-symbol"><span class="hljs-symbol">:cross</span></span> ~table ~alias ~(<span class="hljs-name"><span class="hljs-name">prepare-expression</span></span> cond)))) <span class="hljs-comment"><span class="hljs-comment">;    ,   ...</span></span></code> </pre><br><br>  To write several identical macros is an ignoble thing: <br><br><pre> <code class="hljs swift">;     `<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>-template` (use 'clojure.template) ;     <span class="hljs-number"><span class="hljs-number">5</span></span>   (<span class="hljs-keyword"><span class="hljs-keyword">do</span></span>-template [<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>-name <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>-key] ;    ;   (defmacro <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>-name ([relation alias table cond] `(<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>* ~relation ~<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>-key ~alias ~table ~(prepare-expression cond))) ([relation table cond] `(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [table# ~table] (<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>* ~relation ~<span class="hljs-built_in"><span class="hljs-built_in">join</span></span>-key <span class="hljs-literal"><span class="hljs-literal">nil</span></span> table# ~(prepare-expression cond))))) ;    <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>-inner :inner, <span class="hljs-built_in"><span class="hljs-built_in">join</span></span> :inner, <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">right</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">right</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">left</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">join</span></span>-full :full)</code> </pre><br><br><h4>  More possibilities </h4><br>  While we are able to carry out only the elementary requests.  Let's support expressions in the enumeration of columns. <br><br><pre> <code class="hljs swift">;  `f`   `m` ( ) (defn- <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-vals [fm] (into (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>? m) (empty m) {}) (<span class="hljs-keyword"><span class="hljs-keyword">for</span></span> [[kv] m] [k (fv)]))) ;      (def surrogate-alias-counter (atom <span class="hljs-number"><span class="hljs-number">0</span></span>)) ;    :<span class="hljs-number"><span class="hljs-number">__00001234</span></span> (defn generate-surrogate-alias [] (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [k (<span class="hljs-built_in"><span class="hljs-built_in">swap</span></span>! surrogate-alias-counter #(-&gt; % inc (mod <span class="hljs-number"><span class="hljs-number">1000000</span></span>)))] (keyword (format <span class="hljs-string"><span class="hljs-string">"__%08d"</span></span> k)))) ;     <span class="hljs-string"><span class="hljs-string">""</span></span> (defn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-alias [n] (cond (keyword? n) n ;  /    (string? n) (keyword n) ;    :<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (generate-surrogate-alias))) ;      ;     --  <span class="hljs-string"><span class="hljs-string">" - "</span></span>    (defn- prepare-fields [fs] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>? fs) (<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>-vals prepare-expression fs) (into {} (<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> (juxt <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-alias prepare-expression) fs)))) (defn fields* [query fd] (assoc query :fields fd)) (defmacro fields [query fd] `(fields* ~query ~(prepare-fields fd))) (defn render-field [[alias nm]] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (= alias nm) nm ;    [(render-expression nm) '<span class="hljs-type"><span class="hljs-type">AS</span></span> alias])) (defn render-fields [{:keys [fields]}] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (or (<span class="hljs-literal"><span class="hljs-literal">nil</span></span>? fields) (= fields :*)) '* (interpose (symbol <span class="hljs-string"><span class="hljs-string">","</span></span>) (<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> render-field fields))))</code> </pre><br><br>  Not bad.  Now you can write like this: <br><br><pre> <code class="hljs sql">(<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">fields</span></span> {:n :<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>, :a :age}) ;    (from :users)) ;   (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">fields</span></span> {:cnt (<span class="hljs-keyword"><span class="hljs-keyword">count</span></span> :*), :<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>-age (<span class="hljs-keyword"><span class="hljs-keyword">max</span></span> :age)}) (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>)) ;    (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">fields</span></span> [(<span class="hljs-keyword"><span class="hljs-keyword">count</span></span> :*)]) (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :<span class="hljs-keyword"><span class="hljs-keyword">users</span></span>))</code> </pre><br><br>  We add sorting.  Already the usual order of actions: create the function <code>order*</code> and the macro <code>order</code> , implement the <code>render-order</code> : <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> order* ([relation column] (<span class="hljs-name"><span class="hljs-name">order*</span></span> relation column <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) ([{order <span class="hljs-symbol"><span class="hljs-symbol">:order</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:as</span></span> relation} column dir] (<span class="hljs-name"><span class="hljs-name">assoc</span></span> relation <span class="hljs-symbol"><span class="hljs-symbol">:order</span></span> (<span class="hljs-name"><span class="hljs-name">cons</span></span> [column dir] order)))) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> order ([relation column] `(order* ~relation ~(prepare-expression column))) ([relation column dir] `(order* ~relation ~(prepare-expression column) ~dir))) (<span class="hljs-name"><span class="hljs-name">defn</span></span> render-order [{order <span class="hljs-symbol"><span class="hljs-symbol">:order</span></span>}] (<span class="hljs-name"><span class="hljs-name">let</span></span> [f (<span class="hljs-name"><span class="hljs-name">fn</span></span> [[cd]] [(<span class="hljs-name"><span class="hljs-name">render-expression</span></span> c) (<span class="hljs-name"><span class="hljs-name">get</span></span> {<span class="hljs-literal"><span class="hljs-literal">nil</span></span> [] <span class="hljs-symbol"><span class="hljs-symbol">:asc</span></span> 'ASC <span class="hljs-symbol"><span class="hljs-symbol">:desc</span></span> 'DESC} dd)])] (<span class="hljs-name"><span class="hljs-name">if</span></span> order ['[ORDER BY] (<span class="hljs-name"><span class="hljs-name">interpose</span></span> (<span class="hljs-name"><span class="hljs-name">symbol</span></span> <span class="hljs-string"><span class="hljs-string">","</span></span>) (<span class="hljs-name"><span class="hljs-name">map</span></span> f order))] [])))</code> </pre><br><br>  Now it is possible to sort the sample in our queries, including by an arbitrary expression: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">select</span></span> (<span class="hljs-name"><span class="hljs-name">from</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:User</span></span>) (<span class="hljs-name"><span class="hljs-name">order</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:message_cnt</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:post_cnt</span></span>)))</code> </pre><br><br>  In a similar way, we can add support for groupings, subqueries, and the like ... So, for example, the implementation for <code>UNION ALL</code> might look like <br><br><pre> <code class="hljs rust">;  - (defn render-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">all</span></span></span></span> [{ss :selects}] (interpose [<span class="hljs-symbol"><span class="hljs-symbol">'UNION</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'ALL</span></span>] (map render-select ss))) ;  ,      (defrecord UnionAll [selects] SqlLike (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-sql [this] (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-sql (render-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">all</span></span></span></span> this)))) ;   **   - (defn <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">all</span></span></span></span> [&amp; ss] (-&gt;UnionAll ss)) ;;  ... (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-sql (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">all</span></span></span></span> (select (from :Users) (fields [:email])) (select (from :Accounts) (fields [:email]))))</code> </pre><br><br><h4>  Multiple DB Support - Dialects </h4><br>  Add support for multiple databases.  The idea is simple: a number of functions in our library can change their behavior depending on which base we use.  Organize a tree hierarchy of dialects: <br><br><pre> <code class="hljs scala">;    (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">^</span></span></span></span>:const <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>-dialect ::sql92) ;           (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">^</span></span></span></span>:dynamic *dialect* nil) ;     (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dialects-hierarchy</span></span></span><span class="hljs-function"> </span></span>(make-hierarchy)) ; ,      (defn register-dialect ([dialect parent] (alter-<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>-root #<span class="hljs-symbol"><span class="hljs-symbol">'dialects</span></span>-hierarchy derive dialect parent)) ;      ::sql92 ([dialect] (register-dialect dialect <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>-dialect))) ;  (register-dialect ::pgsql) (register-dialect ::pgsql92 ::pgsql) ; postgresql     ;   ad-hoc     (register-dialect ::my-custom-db-<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-extra-functions ::pgsql92)</code> </pre><br><br>  Now we define a small <code>defndialect</code> macro: <br><br><pre> <code class="hljs pgsql">;     ;    (defn <span class="hljs-keyword"><span class="hljs-keyword">current</span></span>-dialect [&amp; _] (<span class="hljs-keyword"><span class="hljs-keyword">or</span></span> *dialect* <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>-dialect)) ;    ""  (defmacro defndialect [<span class="hljs-type"><span class="hljs-type">name</span></span> &amp; args-<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>-body] `(<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ;   (defmulti ~<span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span>-dialect :hierarchy #<span class="hljs-string"><span class="hljs-string">'dialects-hierarchy) ;    `sql92` (defmethod ~name default-dialect ~@args-and-body)))</span></span></code> </pre><br><br>  Now you need to remember to add the dialect value to the <code>*dialect*</code> variable: <br><br><pre> <code class="hljs css">(<span class="hljs-selector-tag"><span class="hljs-selector-tag">defmacro</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">with-db-dialect</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[db &amp; body]</span></span> ;         `(<span class="hljs-selector-tag"><span class="hljs-selector-tag">binding</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[*dialect* (:dialect ~db)]</span></span> ~@<span class="hljs-keyword"><span class="hljs-keyword">body</span></span>))</code> </pre><br><br>  Fine.  The last step remains: we rewrite all definitions of functions for rendering, replacing <code>defn</code> with <code>defndialect</code> .  The body of the functions do not need to be changed.  And now we have the opportunity to generate different SQL depending on the database: <br><br><pre> <code class="hljs pgsql">(defndialect <span class="hljs-keyword"><span class="hljs-keyword">quote</span></span>-<span class="hljs-type"><span class="hljs-type">name</span></span> [s] (let [x (<span class="hljs-type"><span class="hljs-type">name</span></span> s)] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (= "*" x) x (str "\"" x "\"")))) ; MySQL    (defmethod <span class="hljs-keyword"><span class="hljs-keyword">quote</span></span>-<span class="hljs-type"><span class="hljs-type">name</span></span> ::mysql [s] (let [x (<span class="hljs-type"><span class="hljs-type">name</span></span> s)] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (= "*" x) x (str "`" x "`"))))</code> </pre><br><br>  Finally, we note that there is no need to call the <code>with-db-dialect</code> manually, you can rewrite our functions <code>fetch-*</code> : <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> fetch-all [db relation] (<span class="hljs-name"><span class="hljs-name">jdbc/query</span></span> db (<span class="hljs-name"><span class="hljs-name">with-db-dialect</span></span> db (<span class="hljs-name"><span class="hljs-name">to-sql-params</span></span> relation)) <span class="hljs-symbol"><span class="hljs-symbol">:result-set-fn</span></span> vec)) <span class="hljs-comment"><span class="hljs-comment">;     fetch-*</span></span></code> </pre><br><br><h4>  RAW requests </h4><br>  Sometimes you need to use too specific queries - they are easier to write as a string, bypassing the DSL.  No problem: <br><br><pre> <code class="hljs swift">(require '[clojure.string :<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> s]) (defn format-sql [raw-sql args] (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [;     :x al (<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> (comp keyword second) (re-seq #<span class="hljs-string"><span class="hljs-string">":([\w.-]+)"</span></span> raw-sql)) ;     <span class="hljs-string"><span class="hljs-string">"?"</span></span> pq (s/replace raw-sql #<span class="hljs-string"><span class="hljs-string">":[\w.-]+"</span></span> <span class="hljs-string"><span class="hljs-string">"?"</span></span>)] (-&gt;<span class="hljs-type"><span class="hljs-type">Sql</span></span> pq (<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> args al)))) ; ... (fetch-all db (format-sql <span class="hljs-string"><span class="hljs-string">"SELECT * FROM Users WHERE role = :rl AND age &lt; :age"</span></span> {:rl <span class="hljs-string"><span class="hljs-string">"admin"</span></span> :age <span class="hljs-number"><span class="hljs-number">18</span></span>}))</code> </pre><br><br>  By the way, queries generated in this way can be used in <code>UNION ALL</code> , which we implemented a little higher.  Unfortunately, to incrementally change them does not work - for this would have to parse the string with the SQL-code.  The workaround is subqueries: <br><br><pre> <code class="hljs pgsql">(defn users-<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">role</span></span> [r] (<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> "SELECT * FROM Users WHERE role = :r" {:rr})) ;    (-&gt; (users-<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">role</span></span> "ADMIN") (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> :<span class="hljs-type"><span class="hljs-type">name</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>)) ;    ..? (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :x (users-<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">role</span></span> "ADMIN")) (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> :<span class="hljs-type"><span class="hljs-type">name</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>)) ; =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>{:<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> "SELECT * FROM SELECT * FROM Users WHERE role = ? AS `x` ORDER BY `name`", :args ("ADMIN")}</code> </pre><br><br>  Oops, the generated SQL is missing round brackets.  We eliminate the mistake, here is the revised version of the <code>render-table</code> : <br><br><pre> <code class="hljs pgsql">(defn render-<span class="hljs-keyword"><span class="hljs-keyword">table</span></span> [[<span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>]] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (= <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>) ;     ,    <span class="hljs-string"><span class="hljs-string">'AS'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ;   -  <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> -   (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (instance? <span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>) (instance? <span class="hljs-keyword"><span class="hljs-keyword">Select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>)) [(symbol "(") <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (symbol ")") <span class="hljs-string"><span class="hljs-string">'AS alias] [table '</span></span><span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>]))) ;      (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :x (users-<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">role</span></span> "ADMIN")) (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> :<span class="hljs-type"><span class="hljs-type">name</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>))</code> </pre><br><br><h4>  Permanent connection to the database </h4><br>  Of course, opening a new connection every time inside the <code>fetch-*</code> functions is not an option.  Again the macro: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> with-connection* [db body-fn] (<span class="hljs-name"><span class="hljs-name">assert</span></span> (<span class="hljs-name"><span class="hljs-name">nil</span></span>? (<span class="hljs-name"><span class="hljs-name">jdbc/db-find-connection</span></span> db))) (<span class="hljs-name"><span class="hljs-name">with-open</span></span> [conn (<span class="hljs-name"><span class="hljs-name">jdbc/get-connection</span></span> db)] (<span class="hljs-name"><span class="hljs-name">body-fn</span></span> (<span class="hljs-name"><span class="hljs-name">jdbc/add-connection</span></span> db conn)))) (<span class="hljs-name"><span class="hljs-name">defmacro</span></span> with-connection [binding &amp; body] `(with-connection* ~(second binding) (fn [~(first binding)] ~@body)))</code> </pre><br><br>  Here we check that there is still no open connection, open a new one and ‚Äúattach‚Äù it to the dictionary with the database parameters.  You need to use this: <br><br><pre> <code class="hljs ruby">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">db</span></span></span><span class="hljs-function"> {...}) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(with-connection [c db] ;  e </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`c`</span></span></span></span><span class="hljs-function"><span class="hljs-params">    </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`db`</span></span></span></span><span class="hljs-function"><span class="hljs-params"> +   (fetch-all c (select (from </span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">:B</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>)) ; ... (fetch-all c (select (from <span class="hljs-symbol"><span class="hljs-symbol">:A</span></span>))))</code> </pre><br><br>  In a similar way, you can add transaction support. <br><br><div class="spoiler">  <b class="spoiler_title">A small bonus - more speed with elements of abnormal programming</b> <div class="spoiler_text">  Obviously, the library introduces additional costs: you need to create the original query in the highest level view, convert it with the help of <code>render-select</code> , skip the result through <code>as-sql</code> .  In addition to this, many of our functions are implemented through <code>defndialect</code> , which also adversely affects performance.  It is especially annoying to repeat such operations for the simplest queries like ‚Äúpull record by id‚Äù.  In truth, the overhead is quite insignificant compared with the time of the database ... But with a strong desire, you can add even more speed.  So, our goal: <br><br><pre> <code class="hljs pgsql">;  ,   <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>    (defselect <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>-id [x] (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> :Users) (<span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (= :id x)))) ;  ,    legacy  (defselect <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>-id [x] "SELECT * FROM `Users` WHERE `id` = :x") ;  (<span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>-one db (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">by</span></span>-id <span class="hljs-number"><span class="hljs-number">123</span></span>))</code> </pre><br><br>  There is a problem - dialects.  We cannot calculate the query at the compilation of the program (in the body of the macro), because we do not know which dialect will be active during execution.  You can precompute the query for all available dialects, but they can be added dynamically (in runtime) - most likely we will miss the right one, badly. <br><br>  An alternative solution is to cache computed queries.  Those.  each such <code>defselect</code> stores in itself a cache - dictionary ‚Äúdialect - SqlLike object‚Äù.  Thus, for each dialect we compile (potentially expensive for complex queries) once for each dialect.  After extracting the <code>Sql</code> record, we simply substitute the necessary arguments into the field <code>:args</code> , without changing anything <code>:sql</code> . <br><br><pre> <code class="hljs pgsql">;   -      <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>  (defrecord LazySelect [content-fn] SqlLike (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] (content-fn))) ;       (defrecord RenderedSelect [content] SqlLike (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> content))) ;   (defrecord SurrogatedArg [symbol] SqlLike (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> [this] (<span class="hljs-keyword"><span class="hljs-keyword">Sql</span></span>. symbol "?"))) (defn emit-precompiled-<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> [<span class="hljs-type"><span class="hljs-type">name</span></span> args body] (let [;  args -    sargs (map -&gt;SurrogatedArg args) ;      sargs-args (<span class="hljs-keyword"><span class="hljs-keyword">into</span></span> {} (map vector sargs args))] `(let [sqls# (atom {}) ;     ; ""  original# (fn ~<span class="hljs-type"><span class="hljs-type">name</span></span> ~args (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ~@body))) ;   , ;     compile# (fn [] (apply original# (list ~@sargs)))] (defn ~<span class="hljs-type"><span class="hljs-type">name</span></span> ~args (-&gt;LazySelect (fn [] (let [;  ,    ;   dialect# (<span class="hljs-keyword"><span class="hljs-keyword">current</span></span>-dialect) cached-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span># (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> @sqls# dialect#) ;   -   <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span># (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cached-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span># cached-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span># ;   ;     , ;      -  (let [<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span># (compile#)] (swap! sqls# assoc dialect# <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>#) <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>#)) ;      args# (:args <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>#)] ;      (assoc <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span># :args (replace ~sargs-args args#))))))))) ;      (defn emit-raw-<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> [<span class="hljs-type"><span class="hljs-type">name</span></span> args <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>] ;    (let [args-map (<span class="hljs-keyword"><span class="hljs-keyword">into</span></span> {} (map (juxt keyword <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>) args))] ;  ,  RenderedSelect `(defn ~<span class="hljs-type"><span class="hljs-type">name</span></span> ~args (-&gt;RenderedSelect (<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> ~<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> ~args-map))))) (defmacro defselect [<span class="hljs-type"><span class="hljs-type">name</span></span> args &amp; body] (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (== <span class="hljs-number"><span class="hljs-number">1</span></span> (count body)) (string? (first body))) (emit-raw-<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> args (first body)) (emit-precompiled-<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> args body)))</code> </pre><br></div></div><br><br><h4>  In conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article does not affect the implementation of functions for modifying the database: insert, delete, update records. </font><font style="vertical-align: inherit;">There are no tools for working with DDL, transactions, and much more. </font><font style="vertical-align: inherit;">But the new functionality is quite easy to add, often even without modifying the existing code. </font><font style="vertical-align: inherit;">The proposed method is one of many, not without shortages, but with the right to live. </font><font style="vertical-align: inherit;">Finally, I leave a link to the </font></font><a href="https://github.com/anjensan/azql"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code of the full version</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , based on which this article was written.</font></font></div><p>Source: <a href="https://habr.com/ru/post/204992/">https://habr.com/ru/post/204992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204978/index.html">Wireless VoIP with Escene WS320-N IP Phone</a></li>
<li><a href="../204980/index.html">EMC Product Update: Webinar Records</a></li>
<li><a href="../204982/index.html">Multiprocess Firefox</a></li>
<li><a href="../204984/index.html">Signing a Java applet and some java security details</a></li>
<li><a href="../204986/index.html">Calculation of the position of celestial bodies and ephemeris theories</a></li>
<li><a href="../204994/index.html">Export Gmail and Google Calendar archives</a></li>
<li><a href="../204998/index.html">NSA tracks the location of mobile phones around the world</a></li>
<li><a href="../205000/index.html">Overview of paid providers independent of the Internet provider IPTV (OTT TV)</a></li>
<li><a href="../205002/index.html">From idea to App Store in 24 hours: Pomodoro</a></li>
<li><a href="../205004/index.html">Telepathwords - determining the level of password security online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>