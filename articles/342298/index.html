<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Andrei Karpov believes that the code for the Manticore project is better than the code for the Sphinx project</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My readers asked to compare Manticore and Sphinx projects in terms of code quality. I can do this in only one way I have mastered - check projects wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Andrei Karpov believes that the code for the Manticore project is better than the code for the Sphinx project</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/5b6/959/340/5b6959340a03d3c576e7d97ad0677b82.png" alt="Sphinx vs Manticore" align="left">  My readers asked to compare Manticore and Sphinx projects in terms of code quality.  I can do this in only one way I have mastered - check projects with the help of the PVS-Studio static analyzer and calculate the error density in the code.  So, I checked the C and C ++ code in these projects and, in my opinion, the quality of the Manticore code is higher than the quality of the Sphinx code.  Naturally, this is a very narrow view, and I do not pretend to the authenticity of my research.  However, I was asked, and I made the comparison as I can. <br><a name="habracut"></a><br><h2>  Sphinx and Manticore </h2><br>  First, let's take a look at the Sphinx and Manticore projects. <br><br>  <b>Sphinx</b> is a full-text search system developed by Andrei Aksenov and distributed under the GNU GPL license.  A distinctive feature is the high speed of indexing and searching, as well as integration with existing DBMS and API for common web programming languages. <br><br>  I took the source code <a href="https://github.com/sphinxsearch/sphinx">from here</a> .  The size of the project, if you take the code in C and C ++ and do not include third-party libraries - 156 KLOC.  Comments make up 10.2%.  This means that the ‚Äúclean code‚Äù is 144 KLOC. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Manticore is</b> Sphinx fork.  Starting as key members of the original Sphinx team, the Manticore team has set itself the following goal - to deliver fast, stable and powerful free software for full-text search. <br><br>  I took the source code <a href="https://github.com/manticoresoftware/manticore">from here</a> .  The size of the project, if you take the code in C and C ++ and do not include third-party libraries - 170 KLOC.  Comments make up 10.1%.  This means that the ‚Äúclean code‚Äù is 152 KLOC. <br><br>  The number of lines of code in the Manticore project is slightly larger, and I will take this into account when assessing the density of errors found. <br><br><h2>  Comparative analysis </h2><br>  The code of these projects is very similar, and very often the same error is present in one or another project.  I‚Äôll say right away that this time I carried out the analysis superficially and studied only general warnings of the High level, issued by the PVS-Studio analyzer. <br><br>  Why am I too lazy to compare projects more carefully?  As I have already said, the projects are very similar, and already when I viewed High-level warnings, I became bored.  In general, the picture is clear.  The analyzer issued very similar lists of warnings, but only slightly more in the Sphinx project.  I think the situation with the warnings of other levels will be exactly the same. <br><br>  In the article I will consider only some fragments of code with errors that for some reason seemed interesting to me.  More detailed analysis of projects can be performed by their developers.  I am ready to provide them with temporary license keys. <br><br>  I suggest that readers also download the demo version of <a href="https://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> and check the code of their projects.  I am sure you will find a lot of interesting things in them. <br><br><h2>  Common mistakes </h2><br>  I will start with the errors that were found in both the Sphinx project and Manticore. <br><br><h3>  CWE-476: NULL Pointer Dereference </h3><br><pre><code class="cpp hljs">Expr_StrIn_c ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSphAttrLocator &amp; tLoc, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iLocator, ConstList_c * pConsts, UservarIntSet_c * pUservar, ESphCollation eCollation ) : Expr_ArgVsConstSet_c&lt;<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>&gt; ( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, pConsts ) , ExprLocatorTraits_t ( tLoc, iLocator ) , m_pStrings ( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) , m_pUservar ( pUservar ) { assert ( tLoc.m_iBitOffset&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; tLoc.m_iBitCount&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> ); assert ( !pConsts || !pUservar ); m_fnStrCmp = GetCollationFn ( eCollation ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * sExpr = pConsts-&gt;m_sExpr.cstr(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  I brought a fairly large code snippet, but do not worry, everything is simple.  Note the formal argument of <i>pConsts</i> .  This pointer is used in the constructor to initialize the <i>sExpr</i> variable.  At the same time, there is nowhere in the constructor a check in the event that <i>NULL</i> is passed as an argument, i.e.  There is no protection against a null pointer.  The variable <i>pConsts is</i> just bravely <i>derelated</i> . <br><br>  Note.  There is a check in the form of <i>assert</i> , but it does not help in the release-version, so such a check can not be considered sufficient. <br><br>  Now let's take a look at the <i>CreateInNode</i> function code, where an instance of the <i>Expr_StrIn_c</i> class is <i>created</i> : <br><br><pre> <code class="cpp hljs">ISphExpr * ExprParser_t::CreateInNode ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iNode ) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TOK_ATTR_STRING: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Expr_StrIn_c ( tLeft.m_tLocator, tLeft.m_iLocator, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">// &lt;= pUservar, m_eCollation ); .... }</span></span></code> </pre> <br>  The third actual argument is <i>NULL</i> .  Accordingly, if this code fragment is executed, then the null pointer dereference will occur. <br><br>  The analyzer signals this error by issuing a warning: V522 Dereferencing of the null pointer 'pConsts' might take place.  The null pointer is passed into the Expr_StrIn_c function.  Inspect the third argument.  Check lines: 5407, 5946. sphinxexpr.cpp 5407 <br><br>  This error is interesting because PVS-Studio performs data-flow analysis, examining the bodies of two different functions.  However, it can also perform a much more complicated embedded analysis.  Consider this case. <br><br>  First, we consider the <i>SendBytes</i> function, in which, in fact, the null pointer will be dereferenced. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISphOutputBuffer::SendBytes ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * pBuf, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iLen ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iOff = m_dBuf.GetLength(); m_dBuf.Resize ( iOff + iLen ); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span> ( m_dBuf.Begin() + iOff, pBuf, iLen ); }</code> </pre> <br>  Notice the <i>pBuf</i> pointer.  It is not checked anywhere and is immediately passed as an actual argument to the <i>memcpy</i> function.  Accordingly, if the <i>pBuf</i> pointer is zero, then when the <i>memcpy</i> function is called, it will read at the null pointer. <br><br>  Why does PVS-Studio decide that there will be an error here?  To answer this question, let's go up the call chain above and look at the <i>SendMysqlOkPacket</i> function. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMysqlOkPacket</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ISphOutputBuffer &amp; tOut, BYTE uPacketID, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iAffectedRows=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iWarns=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * sMessage=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bMoreResults=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ DWORD iInsert_id = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> sVarLen[<span class="hljs-number"><span class="hljs-number">20</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * pBuf = sVarLen; pBuf = MysqlPack ( pBuf, iAffectedRows ); pBuf = MysqlPack ( pBuf, iInsert_id ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iLen = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) pBuf - sVarLen; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iMsgLen = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sMessage ) iMsgLen = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(sMessage) + <span class="hljs-number"><span class="hljs-number">1</span></span>; tOut.SendLSBDword ( (uPacketID&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>) + iLen + iMsgLen + <span class="hljs-number"><span class="hljs-number">5</span></span>); tOut.SendByte ( <span class="hljs-number"><span class="hljs-number">0</span></span> ); tOut.SendBytes ( sVarLen, iLen ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( iWarns&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> ) iWarns = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( iWarns&gt;<span class="hljs-number"><span class="hljs-number">65535</span></span> ) iWarns = <span class="hljs-number"><span class="hljs-number">65535</span></span>; DWORD uWarnStatus = iWarns&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( bMoreResults ) uWarnStatus |= ( SPH_MYSQL_FLAG_MORE_RESULTS ); tOut.SendLSBDword ( uWarnStatus ); tOut.SendBytes ( sMessage, iMsgLen ); }</code> </pre> <br>  I apologize that I had to bring the whole body of the function.  I wanted to show that there is no protection in the function from the fact that the argument <i>sMessage</i> will be equal to <i>NULL</i> .  The <i>sMessage</i> pointer <i>is</i> simply passed to the <i>SendBytes</i> function. <br><br>  I also want to note that the default value of the formal argument <i>sMessage</i> is <i>NULL</i> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * sMessage=<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,</code> </pre> <br>  This is dangerous in itself.  However, the fact that the default argument is <i>NULL</i> does not mean anything.  Perhaps the correct arguments are always passed to the function.  Therefore, let's go further: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ok</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iAffectedRows=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iWarns=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * sMessage=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bMoreResults=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ SendMysqlOkPacket ( m_tOut, m_uPacketID, iAffectedRows, iWarns, sMessage, bMoreResults ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( bMoreResults ) m_uPacketID++; }</code> </pre> <br>  In the <i>Ok</i> function <i>,</i> the <i>sMessage</i> argument <i>is</i> simply passed to the <i>SendMysqlOkPacket</i> function.  We continue. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleMysqlMultiStmt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... dRows.Ok ( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, bMoreResultsFollow ); .... }</code> </pre> <br>  Here we finish our journey.  Only 4 actual arguments are passed to the function.  The remaining arguments are defaulted.  This means that the fifth parameter, <i>sMessage</i> , will be <i>NULL</i> , and the null pointer dereference will occur. <br><br>  A warning from the PVS-Studio analyzer that indicates this error: V522 Dereferencing of the null pointer 'pBuf' might take place.  The null pointer is passed into the 'Ok' function.  Inspect the third argument.  Check lines: 2567, 12267, 12424, 14979. searchd.cpp 2567 <br><br><h3>  CWE-570: Expression is Always False </h3><br>  To begin, consider the <i>ESphBinRead</i> enumeration. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ESphBinRead { BIN_READ_OK, <span class="hljs-comment"><span class="hljs-comment">///&lt; bin read ok BIN_READ_EOF, ///&lt; bin end BIN_READ_ERROR, ///&lt; bin read error BIN_PRECACHE_OK, ///&lt; precache ok BIN_PRECACHE_ERROR ///&lt; precache failed };</span></span></code> </pre> <br>  As you can see, there are no named constants with negative values. <br><br>  Just in case, take a look at the <i>ReadBytes</i> function and make sure that it honestly returns values ‚Äã‚Äãwithout any tricks. <br><br><pre> <code class="cpp hljs">ESphBinRead CSphBin::ReadBytes ( <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * pDest, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iBytes ) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BIN_READ_EOF; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BIN_READ_ERROR; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BIN_READ_OK; }</code> </pre> <br>  As you can see, all the values ‚Äã‚Äãreturned by the function are greater than or equal to 0. Now it‚Äôs the turn of the code with the error: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DictReadEntry</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pBin-&gt;ReadBytes ( pKeyword, iKeywordLen )&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> ) { assert ( pBin-&gt;IsError() ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } .... }</code> </pre> <br>  PVS-Studio warning: V547 Expression is always false.  sphinx.cpp 22416 <br><br>  Such a check does not make sense.  The condition is always false, and as a result, incorrect situations when reading data are not processed.  Most likely, it should have been written here: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pBin-&gt;ReadBytes ( pKeyword, iKeywordLen ) != BIN_READ_OK)</code> </pre> <br>  This code demonstrates that the author of the code only thinks that the program will handle incorrect situations.  In fact, I often encounter defects in code that is responsible for handling incorrect / non-standard situations.  Therefore, programs often fall when something goes wrong.  Error handlers are simply incorrectly written in them. <br><br>  No mystery why this happens, of course not.  Testing such parts of the program is difficult and uninteresting.  This is one of those cases where a static analyzer can be a good helper, since it checks the code no matter how often it gets control. <br><br><h3>  CWE-14: Compiler Clear Buffers Code </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFileStats</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... struct_stat tStat; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> ( &amp;tStat, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ( tStat ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( stat ( szFilename, &amp;tStat ) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pError ) *pError = strerror ( errno ); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span> ( &amp;tStat, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ( tStat ) ); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } .... }</span></span></code> </pre> <br>  PVS-Studio warning: V597 The compiler could delete the memset function call, which is used to flush the tStat object.  The memset_s () function should be used to erase the private data.  sphinx.cpp 19987 <br><br>  The compiler has the right to remove a call to the <i>memset</i> function, which, in case of an error in the program, should clear the private data in <i>tStat</i> . <br><br>  Why does the compiler do this, I have written many times, so I will not repeat.  For those who have not yet encountered such situations, I suggest reading the description of the <a href="https://www.viva64.com/ru/w/v597/">V597</a> diagnostic or see the description of the <a href="https://cwe.mitre.org/data/definitions/14.html">CWE-14</a> . <br><br><h3>  CWE-762: Mismatched Memory Management Routines </h3><br>  First we need to look at the implementation of two macros: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SafeDelete(_x) \ { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_x) { delete (_x); (_x) = nullptr; } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SafeDeleteArray(_x) \ { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_x) { delete [] (_x); (_x) = nullptr; } }</span></span></code> </pre> <br>  Now, I think it‚Äôs easy for you to find the error in this code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CSphIndex_VLN::DebugCheck ( FILE * fp ) { .... CSphRowitem * pInlineStorage = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( pQword-&gt;m_iInlineAttrs ) pInlineStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSphRowitem [ pQword-&gt;m_iInlineAttrs ]; .... <span class="hljs-comment"><span class="hljs-comment">// cleanup SafeDelete ( pInlineStorage ); .... }</span></span></code> </pre> <br>  PVS-Studio warning: V611, it was allocated using the 'delete' operator.  Consider inspecting this code.  It's probably better to use 'delete [] pInlineStorage;'.  sphinx.cpp 19178 <br><br>  As you can see, the memory is allocated for the array, and is released, as if only one element was created.  Instead of the <i>SafeDelete</i> macro, the <i>SafeDeleteArray</i> macro should be used <i>here</i> . <br><br><h2>  Unique bugs </h2><br>  Above, I looked at a few errors that reveal themselves in both Sphinx and Manticore code.  In this case, of course, there are errors inherent in only one project.  Consider for example one such case. <br><br>  In both projects there is a function <i>RotateIndexMT</i> .  But it is implemented in different ways.  In the implementation of the Sphinx project, this function contains a defect CWE-690 (Unchecked Return Value to NULL Pointer Dereference). <br><br>  First, let's look at the declaration of the <i>CheckServedEntry</i> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckServedEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ServedIndex_c * pEntry, </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">// &lt;= const char * sIndex, CSphString &amp; sError );</span></span></span></span></span></span></code> </pre> <br>  The first argument is a pointer to a constant object.  Therefore, the function cannot change this object and the pointer itself. <br><br>  Now the function containing the error: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateIndexMT</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( .... )</span></span></span><span class="hljs-function"> </span></span>{ .... ServedIndex_c * pServed = g_pLocalIndexes-&gt;GetWlockedEntry ( sIndex ); pServed-&gt;m_sNewPath = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= if ( !CheckServedEntry ( pServed, sIndex.cstr(), sError ) ) { if ( pServed ) // &lt;= pServed-&gt;Unlock(); return false; } .... }</span></span></code> </pre> <br>  PVS-Studio warning: V595 The 'pServed' pointer was used before it was verified against nullptr.  Check lines: 17334, 17337. searchd.cpp 17334 <br><br>  First, the <i>pServed</i> pointer <i>is</i> dereferenced.  Next, the <i>CheckServedEntry</i> function is <i>called</i> , which, as we have already learned, cannot change the <i>pServed</i> pointer passed as the first actual argument. <br><br>  Next, the <i>pServed</i> pointer <i>is</i> checked for <i>NULL</i> equality.  Aha  So the pointer could be null.  Therefore, above, before the first pointer dereferencing, you need to add a check. <br><br>  Another option: <i>if (pServed) is an</i> extra check <i>if the</i> pointer is never <i>NULL</i> .  In any case, the code must be corrected. <br><br><h2>  Let's sum up </h2><br>  The Sphinx project is smaller in size to the Manticore project.  At the same time, in the Sphinx project, I noticed more errors and a ‚Äúwrap code‚Äù than in the Manticore project. <br><br>  Given the size of the projects and the number of defects seen, I got the following result.  Take the error density in Manticore for 1. Then, in my Sphinx project, the error density in my estimation is 1.5. <br><br>  <b>My findings.</b>  The density of errors in the Sphinx project is one and a half times higher than in the Manticore project.  Consequently, the quality of the Manticore code is better than that of the Sphinx project.  Fork turned out better than the original. <br><br>  I repeat once again that this is my subjective opinion, based on a very small amount of information.  The density of errors in the code of some components does not yet speak about the quality and reliability of the project as a whole. <br><br>  Download and try the PVS-Studio analyzer.  It's simple.  In the end, even if you write the perfect code, you can always <a href="https://www.viva64.com/ru/b/0525/">look for</a> errors in the code of your colleagues :). <br><br>  Thanks for attention.  Subscribe to <a href="https://twitter.com/Code_Analysis">Twitter</a> or <a href="http://feeds.feedburner.com/viva64-blog-ru">RSS</a> to keep abreast of our new publications. <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0538/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation <a href="http://www.viva64.com/en/b/0538/">of the Sphinx project</a> <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. </div></div></div><p>Source: <a href="https://habr.com/ru/post/342298/">https://habr.com/ru/post/342298/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342284/index.html">New release Oh, My Code - Cloud, Perl and good programmers</a></li>
<li><a href="../342286/index.html">Bible movements doom. Part 2</a></li>
<li><a href="../342288/index.html">SparrowHub Plugin Overview</a></li>
<li><a href="../342290/index.html">November 29, Kharkiv: Report "Analytics in a Gaming Company: Big Data Architecture and Tools"</a></li>
<li><a href="../342292/index.html">Introduction to Seneca.JS</a></li>
<li><a href="../342300/index.html">How not to put thousands of servers using centralized configuration management using the example of CFEngine</a></li>
<li><a href="../342302/index.html">Design Template ‚ÄúMini Scenario with Contradiction Check‚Äù</a></li>
<li><a href="../342304/index.html">Interesting logical puzzles for interviews</a></li>
<li><a href="../342306/index.html">How we played with neural networks</a></li>
<li><a href="../342308/index.html">Future of wikipedia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>