<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lightcycle demo using WebGL (part 0)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 I like to learn new technologies, doing things I never did before. I also like TRON . Both films, by the way. I remember, even before I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lightcycle demo using WebGL (part 0)</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  I like to learn new technologies, doing things I never did before.  I also like <a href="http://en.wikipedia.org/wiki/Tron_(film)">TRON</a> .  Both films, by the way.  I remember, even before I looked at them, in student dark times, I played <a href="http://www.armagetronad.net/">Armagetron</a> and fanatel from racing on the light cycles.  After watching TRON: Legacy, I suddenly wanted to make my Tron with grid and isomorphs.  Without thinking twice, I launched my beloved Visual Studio Express and thought about it - and how would my creation differ from the dump site of the Tron clones?  The studio closed smoothly, and my enthusiasm abated somewhat.  Exactly until the moment I came across some article about WebGL.  The eyes lit up again, and the hands themselves reached for the editor.  The thought somehow didn‚Äôt come to my head that the last time I had done a handler for pressing a button for a test on a certain subject in JavaScript. <br><br>  So, today in the program: <br><ul><li>  Low-level WebGL programming. </li><li>  Rendering a simple three-dimensional object. </li><li>  Detailed comments on the development process. </li><li>  Lots of letters and javascript code. </li><li>  Free booze and nice music. </li></ul><br><img src="https://habrastorage.org/storage/2dcfaeab/b1404d9c/a7ebacbe/67ba97c5.png"><br>  The article is intended for those who simply have nothing to do and want to read about how others spend their time at the computer instead of walking under the warm summer sun. <br><a name="habracut"></a><br><br><h4>  Read more about what we want to get. </h4><br>  As a result, you should get an HTML page, when loaded, the user will get control of the light cycle located on an infinite plane somewhere in the grid.  The light cycle must be able to accelerate, brake, turn smoothly and leave behind a wall of light.  I'm not a masochist, so the demo will consist of more than one file.  Markup, scripts, shaders, models - everything will be pushed into directories.  Even for one small CSS selector, the whole file will be highlighted.  I don‚Äôt have my own dedicated server, so the demo will be distributed in the archive via file sharing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Architecture </h4><br>  In this article I will not use ready-made libraries for rendering, for nefig.  But seriously, to effectively use the same <a href="https://github.com/greggman/tdl">tdl.js</a> , as well as any other library in any language for any purpose, you must first understand how it works at a lower level.  However, the article will clearly show that the development of even such a simple demo, which I ultimately want to do, by the forces of one person without the use of third-party libraries threatens to become clouded. <br><br>  The logic will be in one file.  In it, I will put the engine initialization code, including the loading of resources, the compilation of shaders and the main loop, as well as the scene rendering function.  From the main loop, which is actually not a loop, but a callback using <a href="http://habrahabr.ru/blogs/javascript/114358/">requestAnimateFrame</a> , calculation and rendering will be called up (well, or rendering and calculation, almost no difference. Almost;). <br><br>  Rendering involves several steps: <br><ul><li>  Rendering the environment, that is, the floor on which we drive and, optionally, the sky that hangs over us. </li><li>  Rendering of the light cycle, which in turn includes several substeps for rendering parts with different materials. </li><li>  Rendering of a strip of light extending beyond the light cycle. </li></ul><br>  Why not draw everything in one go, you ask?  Due to the peculiarities of the OpenGL pipeline.  More details below. <br><br>  From this we will make a start.  It makes no sense to describe in more detail, and it is time to write something about the implementation. <br><br><h4>  What is WebGL and how to use it? </h4><br>  A lot of useful information for a beginner can be found on <a href="http://learningwebgl.com/blog/">this site</a> .  But <a href="http://www.nihilogic.dk/labs/webgl_cheat_sheet/WebGL_Cheat_Sheet.htm">this link</a> leads to a page with a hint on the functions of WebGL. <br><br>  In a nutshell, WebGL is a set of <a href="http://ru.wikipedia.org/wiki/OpenGL_ES">OpenGL ES</a> 2.0 bindings for JavaScript.  This technology is still being actively developed, therefore, there is still no meaningful and complete documentation on it.  But enthusiasts with might and main <a href="http://code.google.com/p/webglsamples/">use it</a> . <br><br>  It is very easy to use.  You just need to throw the <code>&lt;canvas /&gt;</code> tag into the body of the HTML document, execute the method of the <code>canvas.getContext("experimental-webgl")</code> element <code>canvas.getContext("experimental-webgl")</code> and thereby get the object that is used to render WebGL.  Let's start writing code. <br><br><h4>  Engine Initialization </h4><br>  It all starts with the loading page.  Set a callback to this event using jQuery, for this is the easiest way.  In the callback, let's call the resource loading functions, get the GL context and start the engine. <br><pre> <code class="javascript hljs">$(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ loadResources(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gl = $(<span class="hljs-string"><span class="hljs-string">"#viewport"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].getContext(<span class="hljs-string"><span class="hljs-string">"experimental-webgl"</span></span>); engineStartup(gl); });</code> </pre><br>  Then we need to compile and build the shader programs that will be used in the demo.  This includes the following functions: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildShaders</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gl, count</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shaders = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { shaders[i] = composeProgram(gl, localStorage.getItem(<span class="hljs-string"><span class="hljs-string">"step "</span></span> + i + <span class="hljs-string"><span class="hljs-string">" vertex shader"</span></span>), localStorage.getItem(<span class="hljs-string"><span class="hljs-string">"step "</span></span> + i + <span class="hljs-string"><span class="hljs-string">" fragment shader"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shaders; } <span class="hljs-comment"><span class="hljs-comment">//   http://www.guciek.net/webgl_shortest/en function composeProgram(gl, vertex_shader, fragment_shader) { var program = gl.createProgram(); var addShader = function(type, source) { var shader = gl.createShader(type); gl.shaderSource(shader, source); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { throw "Could not compile " + (type == gl.VERTEX_SHADER ? "vertex" : "fragment") + " shader:\n\n" + gl.getShaderInfoLog(shader); } gl.attachShader(program, shader); }; addShader(gl.VERTEX_SHADER, vertex_shader); addShader(gl.FRAGMENT_SHADER, fragment_shader); gl.linkProgram(program); if (!gl.getProgramParameter(program, gl.LINK_STATUS)) { throw "Could not link the shader program."; } return program; }</span></span></code> </pre><br>  Yes, yes, I use the browser's local storage to download files from the local machine.  Here I am such a pervert.  By the way, in order for my favorite Chrome to let me do this, you have to run it like this: <br>  <code>"chrome --allow-file-access-from-files"</code> . <br><br>  But it's better to talk about the code and what it means.  The first function, I think, will not arouse any interest in it - it compiles an array of shader programs.  But the creation of a shader program that occurs in the second function is much more interesting.  First you need to understand what a <a href="http://www.iquilezles.org/apps/shadertoy/">shader in WebGL</a> . <br><br><h4>  A shader is such a thing ... </h4><br>  A shader is a program that runs on the graphics processor during frame processing.  In OpenGL ES 2.0, there are two types of shaders - vertex and pixel (vertex &amp; fragment, respectively).  The order of operations in the OpenGL pipeline is described in detail <a href="http://learningwebgl.com/blog/%3Fp%3D134">here</a> , we only need to know that the vertex shader runs before the pixel shader and operates with all the vertices in the pipeline.  The pixel shader runs almost before the frame is displayed on the screen for each pixel in the pipeline and can use the data transmitted by the vertex shader.  The combination of these two shaders is called a shader program.  At the same time, the graphics processor can run only one shader program, but this does not mean that we are limited to two shaders for everything.  Shader programs can be switched during rendering, changing the processing logic of all subsequent primitives.  In order to do this quickly, you need to pre-compile all the shaders used and build them into shader programs.  For storing programs, I did not find anything better than an array.  The array index corresponds to the rendering step in which the shader program is used.  We'll postpone the writing of the actual shaders, but for now let's consider the function of creating a shader program from the source code in more detail. <br><br>  First of all, the <code>createProgram()</code> function is <code>createProgram()</code> , indicating GL that we want to create a shader program.  Then we add vertex and pixel shaders to this program.  Adding occurs in four steps.  First, an object for the shader is created using <code>gl.createShader()</code> , then the <code>shaderSource()</code> function <code>shaderSource()</code> its source code, after which <code>compileShader()</code> compiled and the compiled shader is added to the program with <code>attachShader()</code> .  Two function calls and a shader program contains two ready-to-use shaders.  Now the program needs to be linked using <code>linkProgram()</code> - and it can be used. <br><br>  I will not show the resource loading functions here and some auxiliary husk - it is absolutely boring.  Better go ahead. <br><br><h4>  Shader Writing </h4><br>  You already have basic theoretical information about shaders, so here I will describe the writing of the shaders themselves. <br><br>  Shaders are written in a C-like language.  More precisely, two very similar languages ‚Äã‚Äã- one for vertex and one for pixel shaders.  You can read the GLSL spec <a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">from here</a> .  The main program can transfer parameters to shaders using uniform variables.  The main feature of these variables is that they cannot change their value during primitive processing, which makes them the main way of communication between the main program and the shader program.  The vertex shader can accept attribute variables that are set for each vertex in the main program.  For the connection between the vertex and pixel shaders, varying variables are used, which are initialized by the vertex shader, then interpolated over the area of ‚Äã‚Äãthe whole primitive being processed, and the interpolated values ‚Äã‚Äãcan be used by the pixel shader. <br><br>  For example, I will give a simple shader program that uses all three types of variables. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Vertex shader attribute vec3 aVertexPosition; attribute vec4 aVertexColor; uniform mat4 uMVMatrix; uniform mat4 uPMatrix; varying vec4 vColor; void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vColor = aVertexColor; } // Fragment shader #ifdef GL_ES precision highp float; #endif varying vec4 vColor; void main() { gl_FragColor = vColor; }</span></span></code> </pre><br><img src="http://habrastorage.org/storage/d1fc23d2/3c6c6859/7e9adb0e/4da74e00.png" align="left"><br>  The result is predictable - primitive with gradient.  Delve into the process of processing. <br><br><h5>  Data Types and Variables in Shaders </h5><br>  At first glance, you can see strange data types for variables.  There are many basic types in shader languages ‚Äã‚Äã- boolean, integer, floating point, vector and matrix of several dimensions, handler for texture (for internal use only), structure and array.  For now, only vectors and matrices are of interest to us, handlers are not particularly useful to us. <br><br>  Vectors can be two-, three- or four-component, each component is a floating-point number.  The first and second types are familiar to us from the school course of mathematics, but the latter makes us wonder - is it defined in the four-dimensional space?  In general, if you drive the processing logic of four-dimensional coordinates into a shader, it can.  When applied to three-dimensional space, the fourth component of the vector sets the depth value for the vertex.  About what the depth in the scene - later.  In general, vectors in shaders are used not only to determine coordinates in space.  They can be used to store color values, normals, texture coordinates, dates of your birth ... what your heart desires.  Moreover, it is worth noting the importance of the vector for transferring values ‚Äã‚Äãto shaders - memory in buffers for transferring these values ‚Äã‚Äãis a multiple of a four-component vector.  So, if you need to transfer 2-3-4 floating-point numbers that are not related to each other in the shader, it will be most economical and right to shove them into one vector.  We will come back to this. <br><br>  <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D0%25B0_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">Matrices</a> are a much more interesting data type.  Probably you have heard more than once that matrix computations are performed by a graphics processor an order of magnitude faster than universal ones?  This is it.  Matrix we will use very intensively.  In more detail about operations with matrixes and their effects when rendering slightly below.  Now you only need to know that in the given vertex shader two matrices are used - perspectives and displacements.  The perspective matrix determines the position of the camera and the angle of view.  The move matrix indicates where to move the vertex.  Since the shader is executed for the primitive, as a result, the entire primitive is moved, optionally turning at any angle. <br><br>  You <code>gl_Position</code> noticed the variables <code>gl_Position</code> and <code>gl_FragColor</code> .  In these variables, the shader inserts the result of its execution.  <code>gl_Position</code> determines the position of the vertex in three-dimensional space.  <code>gl_FragColor</code> sets the color of the pixel that we see on the screen.  Remember that uniform variables are interpolated throughout the primitive, before getting into the pixel shader?  That is why there is a gradient on the primitive.  I hope everything is more or less clear, because the shaders that will be used in the demo are not an example more complicated than the ones given. <br><br><h4>  Rendering, matrices and all-all-all </h4><br>  You may have already realized that the graphics processor does not know anything about the camera and even about the position of the vertices before the vertex shader executes.  Therefore, it is very important to be able to teach him this.  The camera, as mentioned earlier, is set by the matrix.  The other matrix determines the movement of a point in space.  To understand the principle of operation of these two matrices, plunge into mathematics with the head. <br><br><h5>  Theory </h5><br>  First you need to understand how the projection of the scene.  Details in English are <a href="http://en.wikipedia.org/wiki/Perspective_transform">here</a> .  The main idea is that a point in space is projected using matrix operations to a point on the display plane (this part of the conveyor is hidden from us and the glory of Gd;).  Those of you who have carefully read the article on the link, will be indignant - they say, but why about the camera did not say anything?  The fact is that the camera in OpenGL is always at one point ‚Äî the origin of coordinates ‚Äî and is aligned with the negative part of the Z axis. Now that everyone else is stretching their fingers to tear the author into small polygons in the comments, I hasten to explain ‚Äúwhy then Quake can you turn your head? ".  The fact is that it is easier to work with the graphics processor - the formulas for the projection of a three-dimensional point are greatly simplified, and as a result, the number of required calculations decreases.  Well, or so the manufacturers of graphics accelerators simplify the lives of programmers, giving them complete freedom in the implementation of their camera.  That is, when you jerk your mouse in a quake - this is actually not a camera spinning, but the whole scene rotates around the origin.  Inquisitors would have liked that.  So there is no difference between the perspective matrix and the displacement matrix - they both move a point in space.  But the displacement matrix does this only to move the object in space, and the perspective matrix changes the resulting space so that only the desired part of the scene is in the frame.  Knowing that to display a primitive in space, you need to specify two matrices, you can ask the question - does this mean that more complex models, for example, a teapot, can be saved once and then to move the whole object, simply recalculate the matrices?  The answer is yes.  Moreover, OpenGL gives us the opportunity to save a set of object vertices directly in the video card's memory using vertex buffers, saving bandwidth of the video card bus. <br><br><h5>  Practice </h5><br>  And here we smoothly approached the description of the scene rendering process.  For example, let's take a triangle and a square with a gradient, but we will do this not just by outputting a static picture on the screen, but let the user move the camera. <br><br><h4>  We take something simple and complicate </h4><br>  Before rendering, you need to prepare - build the necessary shader programs, initialize the vertex buffers, adjust the projection plane, specify the initial settings of the camera and the position of the objects.  So far, I have shown only the first item from the list.  Correct. <br><br><h5>  Buffers, buffers ... </h5><br>  Let's start with working with buffers.  The concept itself is very simple - there are attributes of the vertex shader and there are arrays with the values ‚Äã‚Äãof these attributes.  The number of elements in the arrays for one primitive must match.  Using the <code>createBuffer()</code> function, <code>createBuffer()</code> declare the GL subsystem that we want to allocate space for an array of values.  Then, using <code>bindBuffer()</code> select the newly created buffer.  This is very important, because only one buffer can be selected at a time, so if you need to process several buffers, you need to consistently select them and take the necessary actions, just like that.  But something must be stored in the buffer, so call <code>bufferData()</code> and specify the values ‚Äã‚Äãof the array and its size.  In code, it looks like this (a piece of the buffer creation function): <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffers = []; buffers[<span class="hljs-number"><span class="hljs-number">0</span></span>] = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffers[<span class="hljs-number"><span class="hljs-number">0</span></span>]); gl.bufferData(gl.ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Float32Array</span></span>([ <span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>]), gl.STATIC_DRAW); buffers[<span class="hljs-number"><span class="hljs-number">0</span></span>].itemSize = <span class="hljs-number"><span class="hljs-number">3</span></span>; buffers[<span class="hljs-number"><span class="hljs-number">0</span></span>].itemCount = <span class="hljs-number"><span class="hljs-number">3</span></span>; buffers[<span class="hljs-number"><span class="hljs-number">0</span></span>].attributeLocation = gl.getAttribLocation(shaders[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">"aVertexPosition"</span></span>); gl.enableVertexAttribArray(buffers[<span class="hljs-number"><span class="hljs-number">0</span></span>].attributeLocation);</code> </pre><br>  The variables <code>itemSize</code> , <code>itemCount</code> and <code>attributeLocation</code> are used during rendering.  We will not focus on them yet.  Using the <code>getAttribLocation()</code> function, the positions of two attributes of the vertex shader are saved for later use in rendering.  The function <code>enableVertexAttribArray()</code> does exactly what you expect from it. <br><br><h5>  Maybe draw something already? </h5><br>  Actually, at the moment we need one shader program and two buffers - one contains the position of the primitive vertices, and the other their colors in the RGBA format float32 (I was not mistaken, a 32-bit number with a floating point per channel).  You can score on all these matrices and viewports and just draw a triangle.  The result, of course, will not be so hot. <br><img src="http://habrastorage.org/storage/f3297f1f/b296a87f/40faa468/69ed56ba.png"><br>  An inquisitive eye will immediately notice the monstrous aliasing on the left sides of the triangle.  Moreover, when the browser window is resized, the triangle will also change its proportions, which is completely unacceptable.  We will cope with all these problems, however, the code of the example can be taken <a href="http://rghost.ru/10023831">here</a> if someone is interested.  We proceed to the addition of transformations and setting sane display. <br><br><h5>  Matrices again </h5><br>  For matrix operations, I use the <a href="">glMatrix.js</a> library, because I don‚Äôt want to debug errors in matrix calculations. <br><br>  First you need to understand what is the movement of a point in space.  For example, take point A (1; 1; 1) and try to move it to +1 along the Z axis. After long and painful attempts to count something in my mind, I used a calculator and got point A (1; 1; 2).  This is a very simple operation, since when you move a point along one or more axes, you only need to add a number to the corresponding component of the point.  And now let's try to rotate point A (1; 1; 0) by 45 degrees in the XY plane relative to the positive direction of the X axis. Crushing our brains painfully, we can recall something <a href="http://www.gamedev.ru/code/articles/%3Fid%3D4215">similar</a> from higher mathematics.  According to the provided link, quaternions and their application are described in sufficient detail, I recommend reading.  English readers can go to <a href="http://en.wikipedia.org/wiki/Quaternion">Wikipedia</a> to learn more theory.  But for work we only need to know that the 4x4 matrix can contain information about the rotation of a point relative to each of the three axes and the movement of a point in space.  We don‚Äôt need any more. With a combination of these four transformations, you can move any point as we like.  And not only a point, but a whole primitive and even an object. <br><br>  Let's turn the ill-fated point A (1; 1; 0), but do it in the code.  First you need to create a transformation matrix.  This process consists of several stages.  First, create an <a href="http://en.wikipedia.org/wiki/Identity_matrix">identity matrix</a> , which means that no transformations will be applied to the point.  This matrix contains units in the main diagonal and zeros in the remaining positions.  Then, the required transformations ‚Äî the movement (the <code>translate()</code> function), the rotation (the <code>rotate()</code> function, respectively) and the scaling (the <code>scale()</code> function <code>scale()</code> must be applied successively to the identity matrix.  As a result, we obtain a matrix combining all the transformations applied to it.  In code, it looks like this: <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> matrix = mat4.create(); mat4.identity(matrix); matrix.rotate(matrix, <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">4</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre><br>  As a result, we obtain a matrix whose multiplication by a vector, which is the initial point in space, will result in the desired point.  This action is performed in the vertex shader, and it is as easy as multiplying two numbers.  Seriously, the multiplication of a matrix by a vector (and the matrix by a matrix, and a vector by a vector too) in GLSL is represented by a simple operator "*": <br><pre> <code class="cpp hljs">attribute vec3 aVertexPosition; attribute vec4 aVertexColor; uniform mat4 matrix; varying vec4 vColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_Position = matrix * vec4(aVertexPosition, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); vColor = aVertexColor; }</code> </pre><br>  Do not forget that the transformation matrix is ‚Äã‚Äãtransferred to the vertex shader as a uniform variable. <br><br>  In principle, it is possible to use one matrix to transfer the primitive transformation parameters to the vertex shader both for the camera and for directly moving an object in space.  But these are logically completely different things.  The camera may not change its characteristics, and objects on the scene can move, and vice versa, but when calculating each frame, we will have to re-combine both types of transformations each time.  Plus, there may be more than one object on the scene, which will automatically increase the number of calculations.  So we will have to keep one matrix for the camera and one for each object, and the graphics processor will multiply them - it is in order for the computer to be installed. <br><br><h5>  More about the camera </h5><br>  If the movement of primitives is not so surprising, then working with the camera threatens to finish off your brain completely.  But the devil is not so bad as he is painted.  In fact, these are all the same native transformations, but from a different point of view (forgive the pun).  As mentioned above, the camera in OpenGL is at the origin.  In order for a certain object to appear on the screen, you need to move it in space to the negative part of the Z axis. To rotate the camera 90 degrees up (X, I mean), you need to rotate the scene 90 degrees down relative to the origin along the same X axis. Imitation of movement from an object is made by simply moving it from the origin of coordinates along the Z axis. We will not need scaling yet.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most important property of the camera is that the camera matrix is ‚Äã‚Äãapplied to all objects in the scene. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glMatrix.js helps us in creating the matrix for the camera. </font><font style="vertical-align: inherit;">There are already many as three functions for different projections: </font></font><code>perspective()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ortho()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>frustrum()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We will use it for now </font></font><code>perspective()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But no one forbids creating your own matrix with </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neo and Trinity with</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arbitrary parameters.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And yet he spins! </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following code will make our triangle rotate. </font><font style="vertical-align: inherit;">At the same time, you will notice that it has become somewhat smaller - this is the effect of perspective.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,       , //        . //       . function drawFrame(gl, shaders, buffers, matrices) { gl.viewport(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight); gl.clearColor(0.0, 0.0, 0.0, 1); gl.clear(gl.COLOR_BUFFER_BIT); gl.useProgram(shaders[0]); mat4.perspective(75, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.1, 100.0, matrices[0]); mat4.rotate(matrices[1], Math.PI / 100, [1, 1, 1]); gl.bindBuffer(gl.ARRAY_BUFFER, buffers[0]); gl.vertexAttribPointer(buffers[0].attributeLocation, buffers[0].itemSize, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, buffers[1]); gl.vertexAttribPointer(buffers[1].attributeLocation, buffers[1].itemSize, gl.FLOAT, false, 0, 0); gl.uniformMatrix4fv(matrices[0].uniformLocation, false, matrices[0]); gl.uniformMatrix4fv(matrices[1].uniformLocation, false, matrices[1]); gl.drawArrays(gl.TRIANGLES, 0, buffers[0].itemCount); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Preparatory actions have already been described, except for one - using </font></font><code>getUniformLocation()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">our shader to obtain the location of the uniform-variables, but since its use is simple, we will not slow down. The source, by the way, can be found </font></font><a href="http://rghost.ru/10037371"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's sort the code. The first function call </font></font><code>viewport()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sets the size of the image display area on our canvas. Functions </font></font><code>clearColor()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>clear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clears the output area in the specified color. Matrix operations are described earlier; I will not describe the parameters of the functions - they can be found on the library page. Using the familiar function, we </font></font><code>bindBuffer()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">select arrays with coordinates and vertex colors, which are then set with the help of the </font></font><code>vertexAttribPointer()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source for the vertex shader attribute variables. Then two calls follow.</font></font><code>uniformMatrix4fv()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that define two uniform-matrices for shaders: the first is the camera matrix, the second is the primitive transformations. </font><font style="vertical-align: inherit;">Well, in the end, </font></font><code>drawArrays()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">displays our triangle.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Final chord </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article has accidentally grown much more than I expected, so it will have to be divided into at least two parts. </font><font style="vertical-align: inherit;">However, so that the reader does not waste his time reading about the next rotating triangle on OpenGL, at the end a small model of the light cycle will be displayed on the screen.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Model View in OpenGL </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, OpenGL doesn't know what a model is. It operates only with primitives and their arrays. The task of the programmer is to present a model of any format as a set of primitives that can be fed to the GL pipeline and get the expected result in the form of a projection of this model on the screen. You will not believe it, but to display a complex </font></font><a href="http://en.wikipedia.org/wiki/Polygon_mesh"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mesh,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we almost do not need to change the rendering code. In fact, you only need to add some actions to display the model as a frame. But first, take a closer look at the function</font></font><code>drawArrays()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It takes three arguments ‚Äî the first determines how to interpret the selected vertex buffer, the second indicates the index of the element from which to start processing, and the third specifies the number of processed vertices. Simply put, filling the vertex buffer with the coordinates of the vertices of all the triangles of the model, we just need to increase the number of processed vertices - and everything will be a bundle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An experienced developer will immediately point out a lack of approach - excessive memory usage for storing duplicate vertices. The fact is that in OpenGL there are two ways to reduce memory usage and speed up the output of primitives. The first is another function for outputting primitives -</font></font><code>drawElements()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Its main difference is that it operates not just with the coordinates of the vertices, but with an array of indexes of the vertices and an array of the actual vertices. Thus, in order to output two triangles with two common vertices, you will need to first save in the memory of the video card an array of vertices, and then transfer the </font></font><code>drawElements()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">array of vertex indices that we want to use to display the primitive. Given that the size of the index can be as much as two bytes, memory consumption will fall. This method is good, but only for a very large number of duplicate vertices in different models. In our case, it would be best to use the parameter </font></font><code>TRIANGLE_STRIP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instead of </font></font><code>TRIANGLES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the call.</font></font><code>drawArrays()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The strip of triangles is a regular array with vertices, but it is interpreted differently. </font><font style="vertical-align: inherit;">The first triangle will consist of vertices with indices [0,1,2], as in the case of and </font></font><code>TRIANGLES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">However, the vertices of the second triangle will be [1,2,3], whereas in the case of the </font></font><code>TRIANGLES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second triangle it is given by the vertices with indices [3,4,5]. </font><font style="vertical-align: inherit;">Also a good memory saving. </font><font style="vertical-align: inherit;">The model that I use (taken, by the way, </font></font><a href="http://forums3.armagetronad.net/viewtopic.php%3Ff%3D42%26t%3D1679"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) consists of an array of vertices and an array of triangles, with the vertices of the triangles being addressed by indices in the first array. </font><font style="vertical-align: inherit;">Therefore, the most appropriate option would be to use </font></font><code>drawElements()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the parameter </font></font><code>TRIANGLES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For the sake of simplifying the task, I will not sort the triangles so that they make up a strip, but in the future this is necessary.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendering model </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The model in JSON format consists of an array of vertices, an array of indices, the number of vertices and the number of triangles. </font><font style="vertical-align: inherit;">Parsing is done using jQuery. </font><font style="vertical-align: inherit;">The rendering code has not changed much, the only difference is at the very end - when the object is displayed. </font><font style="vertical-align: inherit;">Shaders haven't changed that at all.</font></font><br><pre> <code class="javascript hljs"> gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers[<span class="hljs-number"><span class="hljs-number">2</span></span>]); gl.drawElements(gl.TRIANGLES, buffers[<span class="hljs-number"><span class="hljs-number">2</span></span>].itemCount, gl.UNSIGNED_SHORT, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third buffer contains an array of indices. </font><font style="vertical-align: inherit;">It must be selected in GL before calling </font></font><code>drawElements()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It should be noted that at least the vertex buffer and the vertex color buffer are filled with parsed JSON, but this has almost no effect on the code. </font><font style="vertical-align: inherit;">The colors of the vertices are considered randomly, it is fun to color the model if all components are set to random values. </font><font style="vertical-align: inherit;">The source can be obtained </font></font><a href="http://rghost.ru/10064051"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">But what can he show:</font></font><br><img src="http://habrastorage.org/storage/286e97a6/03bed5a8/65591d95/0dc6cb26.png"><br><br><h4>  Misadventure </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I began to write this article as a way to streamline my thoughts during development. </font><font style="vertical-align: inherit;">You should not consider it as a tutorial or theoretical calculations - both can be found by reference in the article. </font><font style="vertical-align: inherit;">However, if someone described will seem interesting or even prove useful - I will be glad.</font></font> Fair. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the topic is interesting, I will write a sequel. </font><font style="vertical-align: inherit;">It is possible that not soon - now I do not have a lot of free time for a hobby - but I will write.</font></font> In the next series: <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depth buffer and stencil buffer. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reflections and textures. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Control. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Explore a higher-level WebGL library. </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If JavaScript gurus say in comments, I‚Äôll be happy to hear tips on improving code and further development. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There will be no references to the materials used, because they are in the body of the article, but to pull out laziness.</font></font></div><p>Source: <a href="https://habr.com/ru/post/120878/">https://habr.com/ru/post/120878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120871/index.html">Philips monitors will do in Minsk</a></li>
<li><a href="../120872/index.html">Base GeoIP - countries and cities, June 2011 (+ update script)</a></li>
<li><a href="../120874/index.html">IPv6 day</a></li>
<li><a href="../120876/index.html">Passing a password over an open channel (part 2)</a></li>
<li><a href="../120877/index.html">Hyperkin Releases SupaBoy Portable SNES Console</a></li>
<li><a href="../120881/index.html">Creating a programming language using LLVM. Part 5: Language Expansion: Control Flow</a></li>
<li><a href="../120882/index.html">Yandex finances "Zenmoney"</a></li>
<li><a href="../120883/index.html">Overview of Twitter clients for iPhone</a></li>
<li><a href="../120884/index.html">Cactus Obfuscator obfuscator javascript / css</a></li>
<li><a href="../120885/index.html">Sony PSN: Welcome Back</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>