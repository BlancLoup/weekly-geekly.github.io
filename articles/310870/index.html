<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The dark side of TypeScript - @ decorators on examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Decorators are incredibly awesome. They allow you to describe meta information directly in the class declaration, grouping everything in one place and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The dark side of TypeScript - @ decorators on examples</h1><div class="post__text post__text-html js-mediator-article"><p>  Decorators are incredibly awesome.  They allow you to describe meta information directly in the class declaration, grouping everything in one place and avoiding duplication.  Terribly convenient.  Once having tried, you will never agree to write in the old way. </p><br><p>  However, despite all the usefulness, the decorators in TypeScript (also <a href="https://github.com/tc39/proposal-decorators">declared</a> on the standard) are not as simple as we would like.  Working with them requires Jedi skills, since it is necessary to understand the <a href="https://habrahabr.ru/company/enterra/blog/153365/">object model of JavaScript</a> (well, you understand what I mean), the API is somewhat confusing and, moreover, not yet stable.  In this article I will talk a little about the device decorators and show a few specific techniques, how to put this dark force for the benefit of front-end development. </p><br><p>  Besides TypeScript, decorators <a href="https://habrahabr.ru/post/277021/">are available in Babel</a> .  This article only covers implementation in TypeScript. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e86/fb8/fbc/e86fb8fbcba9404c9262c30e6f96e5a6.jpg"></div><a name="habracut"></a><br><br><h2><img width="64" height="64" src="https://habrastorage.org/files/efd/9ed/36a/efd9ed36aaf84c0abdd461d6bdf5ae5b.png">  The basics </h2><br><p>  You can decorate in TypeScript classes, methods, method parameters, accessor properties (accessors) and fields. </p><br><div class="spoiler">  <b class="spoiler_title">Why do I use the term "field" rather than "property" as in the official documentation</b> <div class="spoiler_text"><p>  In TypeScript, the term "field" is not commonly used, and the fields <a href="http://www.typescriptlang.org/docs/handbook/decorators.html">are also called properties</a> .  This creates a lot of confusion because  there is a difference.  If we declare a property with get / set access methods, then a Object.defineProperty call <a href="http://www.typescriptlang.org/play/index.html">appears</a> in the class declaration and a descriptor is available in the decorator, and if we declare just a field (in C # and Java terms), then <a href="http://www.typescriptlang.org/play/index.html">nothing appears</a> , and, accordingly, transferred to the decorator.  This defines the decorators signature, so I use the term "field" to distinguish them from properties with access methods. </p></div></div><br><p>  In general, a decorator is an <strong>expression</strong> , preceded by the "@" symbol, which returns a function of a certain type ( <a href="https://habr.com/ru/company/docsvision/blog/310870/">different in each case</a> ).  Actually, you can simply declare such a function and use <strong><em>its name</em></strong> as a decorator expression: </p><br><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDecorator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target, propertyKey, descriptor)</span></span></span><span class="hljs-function"> { // ... } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function"> { @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDecorator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { } }</span></span></code> </pre> <br><p>  However, you can use any other expression that returns such a function.  For example, you can declare another function that will accept additional information as parameters and return the corresponding lambda.  Then, as the decorator, we will use the expression " <strong>function call MyAdvancedDecorator</strong> ". </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyAdvancedDecorator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info?: string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, propertyKey, descriptor</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// .. }; } class MyClass { @MyAdvancedDecorator("advanced info") myMethod() { } }</span></span></code> </pre> <br><p>  Here, the most common function call, so even if we do not pass parameters, you still need to write the brackets "@MyAdvancedDecorator ()".  Actually, these are the two main ways to advertise decorators. </p><br><p>  During the compilation process, the decorator declaration results in a call to our function in the class definition.  That is, where <code>Object.defineProperty</code> is <code>Object.defineProperty</code> , the class prototype is filled in and all that.  How exactly this happens is important to know, because  This explains when the decorator is called, what the parameters of our function are, why they are just like that, and what and how you can do in the decorator.  Below is the simplified code that compiles our class with the decorator: </p><br><pre> <code class="hljs matlab">var __decorateMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(decorators, target, key)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">descriptor</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Object</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOwnPropertyDescriptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target, key)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var i = decorators.length - 1; i &gt;= 0; i--)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decorator</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decorators</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[i]</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">descriptor</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decorator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target, key, descriptor)</span></span></span><span class="hljs-function"> || </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">descriptor</span></span></span><span class="hljs-function">; //    } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Object</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defineProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target, key, descriptor)</span></span></span><span class="hljs-function">; }; //   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(function ()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> {} //  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prototype</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myMethod</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { }; //  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myMethod</span></span></span><span class="hljs-function"> //   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__decorateMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([ MyAdvancedDecorator("advanced info")</span></span></span><span class="hljs-function"> //   ,    ], </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prototype</span></span></span><span class="hljs-function">, "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myMethod</span></span></span><span class="hljs-function">"); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function">; }</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">);</span></span></code> </pre> <br><a name="decorator-types"></a><br><p>  The table below provides a description of the function for each type of decorators, as well as links to examples in the <a href="http://www.typescriptlang.org/play/">TypeScript Playground</a> , where you can see what exactly the decorators are compiled in and try them in action. </p><br><table><tbody><tr><th>  View decorator </th><th>  Function signature </th></tr><tr><td>  <a href="http://www.typescriptlang.org/docs/handbook/decorators.html"><b>Class decorator</b></a> <br>  <a href="http://www.typescriptlang.org/play/index.html"><em>Playground example</em></a> <br><br><pre> @MyDecorator 
 class MyClass {}
</pre><br></td><td>  <b>function</b> MyDecorator &lt;TFunction extends Function&gt; (target: TFunction): TFunction { <br>  return target; <br>  } <br><ul><li>  <b>target</b> - class constructor </li><li>  <b>returns</b> - class constructor or null.  If you return the constructor, it will replace the original one.  In this case, you must also configure the prototype in the new designer. </li></ul><br></td></tr><tr><td>  <a href="http://www.typescriptlang.org/docs/handbook/decorators.html"><b>Method decorator</b></a> <br>  <a href="http://www.typescriptlang.org/play/index.html"><em>Playground example</em></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> class MyClass {
   @MyDecorator
   myMethod () {}
 }
</pre><br></td><td>  <b>function</b> MyDecorator (target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor &lt;any&gt;): TypedPropertyDescriptor &lt;any&gt; { <br>  return descriptor; <br>  } <br><ul><li>  <b>target</b> - class prototype </li><li>  <b>propertyKey</b> - method name (saved during minification);  in the current implementation, the type is string </li><li>  <b>descriptor</b> - method <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">handle</a> <a href="https://habr.com/ru/company/docsvision/blog/310870/">*</a> </li><li>  <b>returns</b> - method handle <a href="https://habr.com/ru/company/docsvision/blog/310870/">*</a> or null </li></ul><br></td></tr><tr><td>  <a href="http://www.typescriptlang.org/docs/handbook/decorators.html"><b>Static method decorator</b></a> <br>  <a href="http://www.typescriptlang.org/play/index.html"><em>Playground example</em></a> <br><br><pre> class MyClass {
   @MyDecorator
   static myMethod () {}
 }
</pre><br></td><td>  <b>function</b> MyDecorator (target: Function, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor &lt;any&gt;): TypedPropertyDescriptor &lt;any&gt; { <br>  return descriptor; <br>  } <br><ul><li>  <b>target</b> - class constructor </li><li>  <b>propertyKey</b> - method name (saved during minification);  in the current implementation, the type is string </li><li>  <b>descriptor</b> - method <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">handle</a> <a href="https://habr.com/ru/company/docsvision/blog/310870/">*</a> </li><li>  <b>returns</b> - method handle <a href="https://habr.com/ru/company/docsvision/blog/310870/">*</a> or null </li></ul><br></td></tr><tr><td>  <a href="http://www.typescriptlang.org/docs/handbook/decorators.html"><b>Accessor decorator</b></a> <br>  <a href="http://www.typescriptlang.org/play/index.html"><em>Playground example</em></a> <br><br><pre> class MyClass {
   @MyDecorator
   get myProperty () {}
 }
</pre><br></td><td>  Similar to the method.  The decorator should be applied to the first access method (get or set), in the order of declaration in the class. <br></td></tr><tr><td>  <a href="http://www.typescriptlang.org/docs/handbook/decorators.html"><b>Parameter decorator</b></a> <br>  <a href="http://www.typescriptlang.org/play/index.html"><em>Playground example</em></a> <br><br><pre> class MyClass {
   myMethod (
     @MyDecorator val) {
     }
 }
</pre><br></td><td>  <b>function</b> MyDecorator (target: Object, propertyKey: string | symbol, index: number): void {} <br><ul><li>  <b>target</b> - class prototype </li><li>  <b>propertyKey</b> - method name (saved during minification);  in the current implementation, the type is string </li><li>  <b>index</b> - the parameter index in the parameter list </li><li>  <b>returns</b> - void </li></ul><br></td></tr><tr><td><a name="field-decorator"></a><br>  <a href="http://www.typescriptlang.org/docs/handbook/decorators.html"><b>Field decorator (properties)</b></a> <br>  <a href="http://www.typescriptlang.org/play/index.html"><em>Playground example</em></a> <br><br><pre> class MyClass {
   @MyDecorator
   myField: number;
 }
</pre><br></td><td>  <b>function</b> MyDecorator (target: Object, propertyKey: string | symbol): TypedPropertyDescriptor &lt;any&gt; { <br>  return null; <br>  } <br><ul><li>  <b>target</b> - class prototype </li><li>  <b>propertyKey</b> - field name (saved when minifying);  in the current implementation, the type is string </li><li>  <b>returns</b> is a null or property <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">descriptor</a> ;  if you return a handle, it will be used to call Object.defineProperty;  however, when the reflect-metadata library is connected, this does not happen (this is a <a href="https://github.com/rbuckton/ReflectDecorators/issues/48">bug in reflect-metadata</a> ) </li></ul><br></td></tr><tr><td>  <a href="http://www.typescriptlang.org/docs/handbook/decorators.html"><b>Static field decorator (properties)</b></a> <br>  <a href="http://www.typescriptlang.org/play/index.html"><em>Playground example</em></a> <br><br><pre> class MyClass {
   @MyDecorator
   static myField;
 }
</pre><br></td><td>  <b>function</b> MyDecorator (target: Function, propertyKey: string | symbol): TypedPropertyDescriptor &lt;any&gt; { <br>  return null; <br>  } <br><ul><li>  <b>target</b> - class constructor </li><li>  <b>propertyKey</b> - field name (saved when minifying);  in the current implementation, the type is string </li><li>  <b>returns</b> is a null or property <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">descriptor</a> ;  if you return a handle, it will be used to call Object.defineProperty;  however, when the reflect-metadata library is connected, this does not happen (this is a <a href="https://github.com/rbuckton/ReflectDecorators/issues/48">bug in reflect-metadata</a> ) </li></ul><br></td></tr><tr><td>  Interfaces </td><td>  Interface decorators and their members are not supported. <br></td></tr><tr><td>  Type declarations </td><td>  Decorators are not supported in ambient declarations. <br></td></tr><tr><td>  Functions and variables outside the class <br></td><td>  Decorators outside the class are not supported. <br></td></tr></tbody></table><br><p>  The TypedPropertyDescriptor &lt;T&gt; interface appearing in the signature of method and property decorators is declared as follows: </p><br><pre> <code class="javascript hljs">interface TypedPropertyDescriptor&lt;T&gt; { enumerable?: boolean; configurable?: boolean; writable?: boolean; value?: T; get?: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> T; set?: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value: T</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; }</code> </pre> <br><p>  If you specify a specific type T for a TypedPropertyDescriptor in the decorator‚Äôs declaration, you can limit the type of properties to which the decorator is applicable.  What the members of this interface mean is <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">here</a> .  In short, for the value method it contains the method itself, for the field - the value, for the property - get and set contain the corresponding access methods. </p><br><h3 id="img-width30-height30-srchttpshabrastorageorgfiles6df9cc1946df9cc19467c40f682e6926085e4230apng-nastroyka-sredy"><img width="30" height="30" src="https://habrastorage.org/files/6df/9cc/194/6df9cc19467c40f682e6926085e4230a.png">  Environment setup </h3><br><p>  Decorator support is experimental and may change in future releases (in <a href="http://www.typescriptlang.org/docs/release-notes/typescript-2.0.html">TypeScript 2.0</a> it has not changed).  Therefore, you must add experimentalDecorators: true to tsconfig.json.  In addition, decorators are only available if target: es5 or higher. </p><br><div class="spoiler">  <b class="spoiler_title">tsconfig.json</b> <div class="spoiler_text"><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"compilerOptions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"ES5"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"experimentalDecorators"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> </div></div><br><a name="target-es3-bug"></a><br><blockquote><h4><img width="20" height="20" src="https://habrastorage.org/files/64c/0a5/99d/64c0a599d2f3406987c186dce2b0aa4d.png">  <b>Important!!!</b>  - <em>About target: ES3 and JSFiddle</em> </h4><br>  It is important not to forget to specify the target - ES5 option when working with decorators.  If this is not done, the code will compile without errors, but it will work differently ( <a href="https://github.com/Microsoft/TypeScript/issues/11658">this is a bug in the TypeScript compiler</a> ).  In particular, the third parameter will not be passed to the decorators of methods and properties, and their return value will be ignored. <br><br>  These phenomena can be observed in JSFiddle (this is already a <a href="https://github.com/jsfiddle/jsfiddle-issues/issues/906">bug in JSFiddle</a> ), so in this article I don‚Äôt place examples in JSFiddle. <br><br>  However, there is a workaround for these bugs.  You just need to get the descriptor yourself, and update it yourself.  For example, here is the <a href="https://jsfiddle.net/PFight/msac244r/">implementation of the @safe decorator</a> , which works with both target ES3 and ES5. <br></blockquote><p>  To use type information, you must also add emitDecoratorMetadata: true. </p><br><div class="spoiler">  <b class="spoiler_title">tsconfig.json</b> <div class="spoiler_text"><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"compilerOptions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"ES5"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"experimentalDecorators"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"emitDecoratorMetadata"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> </pre> </div></div><br><p>  To use the <a href="https://www.npmjs.com/package/reflect-metadata">Reflect</a> class, you need to install the additional package <a href="https://github.com/rbuckton/ReflectDecorators">reflect-metadata</a> : </p><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> reflect-metadata <span class="hljs-comment"><span class="hljs-comment">--save</span></span></code> </pre> <br><p>  And in the code: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "reflect-metadata";</code> </pre> <br><p>  However, if you use Angular 2, then your build system may already contain the Reflect implementation, and after installing the reflect-metadata package, you can get the runtime error <code>Unexpected value 'YourComponent' exported by the module 'YourModule'</code> .  In this case, it is better to install only <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/reflect-metadata">typings</a> . </p><br><pre> <code class="hljs sql">typings <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> dt~reflect-metadata <span class="hljs-comment"><span class="hljs-comment">--global --save</span></span></code> </pre> <br><p>  So, let's move on to practice.  Consider a few examples that demonstrate the capabilities of decorators. </p><br><h2 id="safe---avtomaticheskaya-obrabotka-oshibok-vnutri-funkcii">  <strong><a href="https://habrahabr.ru/users/safe/" class="user_link">safe</a></strong> - <em>automatic error handling inside a function</em> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/files/727/0cb/2ab/7270cb2abbfc41c9af6f18213ea39947.jpg"></div><br><p>  Suppose we often have minor functions, the errors within which we would like to ignore.  Every time try / catch is cumbersome, the decorator comes to the rescue: </p><br><div class="spoiler">  <b class="spoiler_title">The implementation of the decorator</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;any&gt;</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TypedPropertyDescriptor</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    var originalMethod = descriptor.value; //      descriptor.value = function SafeWrapper () { try { //    originalMethod.apply(this, arguments); } catch(ex) { //    ,     console.error(ex); } }; //   return descriptor; }</span></span></code> </pre> </div></div><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ @safe public foo(str: string): boolean { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  str == null,   } } var test = new MyClass(); console.info("Starting..."); test.foo(null); console.info("Continue execution");</span></span></code> </pre> <br><p>  Result of performance: </p><br><blockquote><img src="https://habrastorage.org/files/c7d/e25/f8e/c7de25f8e6094ad39c7c8c44e14cd45a.png"><br></blockquote><p>  <a href="https://embed.plnkr.co/hJIvnIYCdmnvJlUZZUCw/">Try it in action in Plunker</a> <br>  <a href="http://www.typescriptlang.org/play/index.html">View in Playground</a> </p><br><h2 id="onchange---zadanie-obrabotchika-izmeneniya-znacheniya-polya">  <strong>@OnChange</strong> - <em>setting the field value change handler</em> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c64/6e2/064/c646e20646434ac69686baa03c7cec1f.jpg"></div><br><p>  For example, if you change the value of a field, you need to perform some kind of logic.  You can, of course, define a property with get / set methods, and put the necessary code in the set.  And you can reduce the amount of code by declaring the decorator: </p><br><div class="spoiler">  <b class="spoiler_title">The implementation of the decorator</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnChange</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassT</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback: (ClassT, T</span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-function"><span class="hljs-params">, propertyKey: string | symbol</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,   . //        . var descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || {configurable: true, enumerable: true}; //    get  set var value: T; var originalGet = descriptor.get || (() =&gt; value); var originalSet = descriptor.set || (val =&gt; value = val); descriptor.get = originalGet; descriptor.set = function(newVal: T) { // ,   set  function, //  this -   , //   ,  this - Window!!! var currentVal = originalGet.call(this); if (newVal != currentVal) { //    callback    callback.call(target.constructor, this, newVal); } originalSet.call(this, newVal); }; //   ,    Object.defineProperty(target, propertyKey, descriptor); return descriptor; } }</span></span></code> </pre> <br><p>  Notice that we call defineProperty and return the handle from the decorator.  This is due to a <a href="https://github.com/rbuckton/ReflectDecorators/issues/48">bug in reflect-metadata</a> , due to which the return value is ignored for the field decorator. </p></div></div><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ @OnChange(MyClass.onFieldChange) public mMyField: number = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> onFieldChange(self: MyClass, <span class="hljs-attr"><span class="hljs-attr">newVal</span></span>: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.info(<span class="hljs-string"><span class="hljs-string">"Changing from "</span></span> + self.mMyField + <span class="hljs-string"><span class="hljs-string">" to "</span></span> + newVal); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> test = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass(); test.mMyField = <span class="hljs-number"><span class="hljs-number">43</span></span>; test.mMyField = <span class="hljs-number"><span class="hljs-number">44</span></span>;</code> </pre> <br><p>  Result of performance: </p><br><blockquote><img src="https://habrastorage.org/files/fab/195/ae9/fab195ae9eb2473e942e1ab77bb5a970.png"><br></blockquote><p>  ¬ª <a href="https://embed.plnkr.co/7k6FZqoB9gYHm0yYqiXC/">Try it in action in Plunker</a> <br>  ¬ª <a href="http://www.typescriptlang.org/play/index.html">View in the Playground</a> <br>  We had to declare the handler as static, because  it is difficult to sue on the instance method.  Here is <a href="https://jsfiddle.net/PFight/p7ubjx6c">an alternative option with a string parameter</a> , and another <a href="https://jsfiddle.net/PFight/525kjkgp/1/">using lambda</a> . </p><br><h2 id="inject---vnedrenie-zavisimostey">  <strong><a href="https://habrahabr.ru/users/inject/" class="user_link">Inject</a></strong> - <em>dependency injection</em> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/files/77b/1fc/621/77b1fc6219444fe589d85c1e83efaf31.png"></div><br><p>  One of the interesting features of decorators is the ability to receive information about the type of the property or parameter being decorated (say ‚Äúthanks‚Äù Angular, because it was done specifically for it).  For this to work, you need to include the reflect-metadata library, and enable the emitDecoratorMetadata option (see above).  After that, for properties that have at least one decorator, you can call Reflect.getMetadata with the key "design: type", and get a constructor of the corresponding type.  Below is a simple implementation of the <code>@Inject</code> decorator, which uses this technique to <code>@Inject</code> dependencies: </p><br><div class="spoiler">  <b class="spoiler_title">The implementation of the decorator</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   function Inject(target: Object, propKey: string): any { //     // (       ILogService) var propType = Reflect.getMetadata("design:type", target, propKey); //    var descriptor = { get: function () { // this -    var serviceLocator = this.serviceLocator || globalSericeLocator; return serviceLocator.getService(propType); } }; Object.defineProperty(target, propKey, descriptor); return descriptor; }</span></span></code> </pre> <br><p>  Notice that we call defineProperty and return the handle from the decorator.  This is due to a <a href="https://github.com/rbuckton/ReflectDecorators/issues/48">bug in reflect-metadata</a> , due to which the return value is ignored for the field decorator. </p></div></div><br><pre> <code class="hljs pgsql">//  ,  ,   abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ILogService { abstract log(msg: string): <span class="hljs-type"><span class="hljs-type">void</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Console1LogService extends ILogService { log(msg: string) { console.<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>(msg); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Console2LogService extends ILogService { log(msg: string) { console.warn(msg); } } var globalSericeLocator = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ServiceLocator(); globalSericeLocator.registerService(ILogService, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ConsoleLogService1()); <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyClass { @Inject private logService: ILogService; sayHello() { this.logService.log("Hello there"); } } var my = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MyClass(); my.sayHello(); my.serviceLocator = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ServiceLocator(); my.serviceLocator.registerService(ILogService, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ConsoleLogService2()); my.sayHello();</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Implementing the ServiceLocator class</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceLocator</span></span></span><span class="hljs-class"> </span></span>{ services: [{<span class="hljs-attr"><span class="hljs-attr">interfaceType</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>, <span class="hljs-attr"><span class="hljs-attr">instance</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> }] = [] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any; registerService(interfaceType: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>, <span class="hljs-attr"><span class="hljs-attr">instance</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> record = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.services.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.interfaceType == interfaceType); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!record) { record = { <span class="hljs-attr"><span class="hljs-attr">interfaceType</span></span>: interfaceType, <span class="hljs-attr"><span class="hljs-attr">instance</span></span>: instance}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.services.push(record); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { record.instance = instance; } } getService(interfaceType: <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.services.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x.interfaceType == interfaceType).instance; } }</code> </pre> </div></div><br><p>  As you can see, we simply declare the logService field, and the decorator already determines its type, and sets the access method that the corresponding service instance receives.  Beautiful and comfortable.  Result of performance: </p><br><blockquote><img src="https://habrastorage.org/files/76e/d1d/9b3/76ed1d9b301a4fa6a0d8ee9e1d0cc8ed.png"><br></blockquote><p>  ¬ª <a href="https://embed.plnkr.co/fcjDyqdK6kG9yPWlTsNB/">Try it in Plunker</a> <br>  ¬ª <a href="http://www.typescriptlang.org/play/index.html">View in the Playground</a> </p><br><h2 id="jsonname---serializaciya-modeley-c-preobrazovaniem">  <strong>@JsonName</strong> - <em>serialization of models with conversion</em> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/files/82b/0c3/53c/82b0c353cda14a359ac0c4c702276366.jpeg"></div><br><br><p>  Suppose for some reason you need to rename some object fields when serialized to JSON.  With the help of a decorator, we will be able to declare a JSON-name of the field, and then, when serialized, read it.  Technically, this decorator illustrates the work of the reflect-metadata library, and, in particular, the functions Reflect.defineMetadata and Reflect.getMetadata. </p><br><div class="spoiler">  <b class="spoiler_title">The implementation of the decorator</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      const JsonNameMetadataKey = "Habrahabr_PFight77_JsonName"; //  function JsonName(name: string) { return (target: Object, propertyKey: string) =&gt; { //     name Reflect.defineMetadata(JsonNameMetadataKey, name, target, propertyKey); } } // ,      function serialize(model: Object): string { var result = {}; var target = Object.getPrototypeOf(model); for(var prop in model) { //     var jsonName = Reflect.getMetadata(JsonNameMetadataKey, target, prop) || prop; result[jsonName] = model[prop]; } return JSON.stringify(result); }</span></span></code> </pre> </div></div><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> </span></span>{ @JsonName(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) public title: string; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Model(); model.title = <span class="hljs-string"><span class="hljs-string">"Hello there"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = serialize(model); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.info(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(moel)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.info(json);</code> </pre> <br><p>  Result of performance: </p><br><blockquote><img src="https://habrastorage.org/files/6e5/af8/fa9/6e5af8fa957d4175878058cff5add7ef.png"><br></blockquote><p>  ¬ª <a href="https://embed.plnkr.co/q0PJWcLMnMUepaDbRNjb/">Try it in Plunker</a> <br>  ¬ª <a href="https://www.typescriptlang.org/play/index.html">View in the Playground</a> </p><br><p>  This decorator has the disadvantage that if the model contains objects of other classes as fields, the fields of these classes are not processed by the serialize method (that is, the decorator @JsonName cannot be applied to them).  In addition, the inverse transformation is not implemented here - from JSON to the client model.  Both of these drawbacks are fixed in a somewhat more complex implementation of the server model converter, in the spoiler below. </p><br><div class="spoiler">  <b class="spoiler_title">@ServerModelField - server models converter on decorators</b> <div class="spoiler_text"><p>  <strong>@ServerModelField</strong> - server models converter on decorators </p><br><p>  The statement of the problem is as follows.  From the server, some JSON data of approximately the same type arrive to us (similar JSON sends one BaaS service): </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"username"</span></span>:<span class="hljs-string"><span class="hljs-string">"PFight77"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"email"</span></span>:<span class="hljs-string"><span class="hljs-string">"test@gmail.com"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"doc"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"info"</span></span>:<span class="hljs-string"><span class="hljs-string">"The author of the article"</span></span> } }</code> </pre> <br><p>  We want to convert this data into a typed object, renaming some fields.  In the end, it will look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserAdditionalInfo</span></span></span><span class="hljs-class"> </span></span>{ @ServerModelField(<span class="hljs-string"><span class="hljs-string">"info"</span></span>) public mRole: string; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserInfo</span></span></span><span class="hljs-class"> </span></span>{ @ServerModelField(<span class="hljs-string"><span class="hljs-string">"username"</span></span>) private mUserName: string; @ServerModelField(<span class="hljs-string"><span class="hljs-string">"email"</span></span>) private mEmail: string; @ServerModelField(<span class="hljs-string"><span class="hljs-string">"doc"</span></span>) private mAdditionalInfo: UserAdditionalInfo; public get DisplayName() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mUserName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + mAdditionalInfo.mRole; } public get ID() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mEmail; } public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> parse(jsonData: string): UserInfo { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> convertFromServer(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(jsonData), UserInfo); } public serialize(): string { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverData = convertToServer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(serverData); } }</code> </pre> <br><p>  Let us see how this is implemented. </p><br><p>  First, we need to define a decoder for the ServerModelField <a href="https://habr.com/ru/company/docsvision/blog/310870/">field</a> , which will take a string parameter and store it in metadata.  In addition, to parse JSON, we still need to know what fields with our decorator are in the class at all.  To do this, we will declare another instance of metadata, common to all fields of the class, in which we will save the names of all decorated members.  Here we will not only save metadata via Relect.defineMetadata, but also receive via Reflect.getMetadata. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,       const ServerNameMetadataKey = "Habrahabr_PFight77_ServerName"; const AvailableFieldsMetadataKey = "Habrahabr_PFight77_AvailableFields"; //   export function ServerModelField(name?: string) { return (target: Object, propertyKey: string) =&gt; { //     name,    ,     Reflect.defineMetadata(ServerNameMetadataKey, name || propertyKey, target, propertyKey); // ,     availableFields    var availableFields = Reflect.getMetadata(AvailableFieldsMetadataKey, target); if (!availableFields) { // Ok,  ,     availableFields = []; //   4- (propertyKey)  defineMetadata, // ..      Reflect.defineMetadata(AvailableFieldsMetadataKey, availableFields, target); } //      availableFields.push(propertyKey); } }</span></span></code> </pre> <br><p>  Well, it remains to write the function convertFromServer.  It is almost nothing special, it just calls Reflect.getMetadata and uses the resulting metadata to parse JSON.  One feature is that this function should create an instance of UserInfo via new, so we are passing to it, in addition to JSON data, a class: <code>convertFromServer(JSON.parse(data), UserInfo)</code> .  To understand how this works, look at the spoiler below. </p><br><div class="spoiler">  <b class="spoiler_title">Passing class by parameter</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">//    "   " var myType: { new(): any; }; //     myType = MyClass; //  new MyClass() var obj = new myType();</span></span></code> </pre> </div></div><br><p>  The second feature is the use of field type data generated by setting up "emitDecoratorMetadata": true in tsconfig.json.  The <code>Reflect.getMetadata</code> is to call <code>Reflect.getMetadata</code> with the key "design: type", which is returned by the constructor of the corresponding type.  For example, a call to <code>Reflect.getMetadata("design:type", target, "mAdditionalInfo")</code> will return the <code>UserAdditionalInfo</code> constructor.  We will use this information to properly process custom type fields.  For example, the UserAdditionalInfo class also uses the @ServerModelField decorator, so we must also use this metadata for JSON parsing. </p><br><p>  The third feature is to obtain the corresponding target, from where we will take the metadata.  We use <a href="https://habr.com/ru/company/docsvision/blog/310870/">field decorators</a> , so metadata needs to be taken from the class prototype.  For static member decorators, use the class constructor.  You can get a prototype by calling <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf">Object.getPrototypeOf</a> or by calling the constructor's prototype property. </p><br><p>  All other comments in the code: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertFromServer</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">serverObj: Object, type: { new(</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> ;} ): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,   ,    type var clientObj: T = new type(); //     var target = Object.getPrototypeOf(clientObj); //   ,       var availableNames = Reflect.getMetadata(AvailableFieldsMetadataKey, target) as [string]; if (availableNames) { //    availableNames.forEach(propName =&gt; { //       JSON var serverName = Reflect.getMetadata(ServerNameMetadataKey, target, propName); if (serverName) { //  ,   var serverVal = serverObj[serverName]; if (serverVal) { var clientVal = null; // ,       @ServerModelField //    var propType = Reflect.getMetadata("design:type", target, propName); // ,         var propTypeServerFields = Reflect.getMetadata(AvailableFieldsMetadataKey, propType.prototype) as [string]; if (propTypeServerFields) { // ,    ,    clientVal = convertFromServer(serverVal, propType); } else { // ,    clientVal = serverVal; } //      clientObj[propName] = clientVal; } } }); } else { errorNoPropertiesFound(getTypeName(type)); } return clientObj; } function errorNoPropertiesFound&lt;T&gt;(typeName: string) { throw new Error("There is no @ServerModelField directives in type '" + typeName + "'. Nothing to convert."); } function getTypeName&lt;T&gt;(type: { new(): T ;}) { return parseTypeName(type.toString()); } function parseTypeName(ctorStr: string) { var matches = ctorStr.match(/\w+/g); if (matches.length &gt; 1) { return matches[1]; } else { return "&lt;can not determine type name&gt;"; } }</span></span></code> </pre> <br><p>  The inverse function has a similar form - convertToServer. </p><br><div class="spoiler">  <b class="spoiler_title">ConvertToServer function</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertToServer</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">clientObj: T</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Object</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverObj = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getPrototypeOf(clientObj); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> availableNames = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.getMetadata(AvailableFieldsMetadataKey, target) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [string]; availableNames.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">propName</span></span></span><span class="hljs-function">=&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverName = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.getMetadata(ServerNameMetadataKey, target, propName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serverName) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clientVal = clientObj[propName]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clientVal) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverVal = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propType = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.getMetadata(<span class="hljs-string"><span class="hljs-string">"design:type"</span></span>, target, propName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propTypeServerFields = <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.getMetadata(AvailableFieldsMetadataKey, propType.prototype) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [string]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clientVal &amp;&amp; propTypeServerFields) { serverVal = convertToServer(clientVal); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { serverVal = clientVal; } serverObj[serverName] = serverVal; } } }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!availableNames) { errorNoPropertiesFound(parseTypeName(clientObj.constructor.toString())); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> serverObj; }</code> </pre> </div></div></div></div><br><p>   @ServerModelField    <a href="http://embed.plnkr.co/MJLm7v">  plunker</a> . </p><br><h2 id="controller-action---servisy-dlya-vzaimodeystviya-s-serverom"> <strong><a href="https://habrahabr.ru/users/controller/" class="user_link">Controller</a> , <a href="https://habrahabr.ru/users/action/" class="user_link">Action</a></strong> ‚Äî <em>    </em> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/files/814/eb4/5e8/814eb45e81b94a80a7f110d2cb659075.jpg"></div><br><p>  ASP.NET ,  ,   ,   . , url   ,  /ControllerName/ActionName.         ,         ,      .    ,        .. </p><br><p>        TypeScript,      .        ,       ,  url       . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ControllerNameMetadataKey = <span class="hljs-string"><span class="hljs-string">"Habr_PFight77_ControllerName"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  . //  ,     //   (  ), //      . function Controller(name: string) { return (target: Function) { Reflect.defineMetadata(ControllerNameMetadataKey, name, target.prototype); }; } //  ,    function Action(target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;any&gt;): TypedPropertyDescriptor&lt;any&gt; { //    var originalMethod = descriptor.value; //      descriptor.value = function ActionWrapper () { //  url,   Controller var controllerName = Reflect.getMetadata(ControllerNameMetadataKey, target); //  url  /ControllerName/ActionName var url = "/" + controllerName + "/" + propertyKey; //  url   [].push.call(arguments, url); //       originalMethod.apply(this, arguments); }; //   return descriptor; } // ,    function post(data: any, args: IArguments): any { //  url,   @Action var url = args[args.length - 1]; return $.ajax({ url: url, data: data, method: "POST" }); }</span></span></code> </pre> </div></div><br><pre> <code class="javascript hljs">@Controller(<span class="hljs-string"><span class="hljs-string">"Account"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AccountController</span></span></span><span class="hljs-class"> </span></span>{ @Action public Login(data: any): any { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> post(data, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AccountController(); Account.Login({ <span class="hljs-attr"><span class="hljs-attr">username</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">password</span></span>: <span class="hljs-string"><span class="hljs-string">"111"</span></span>});</code> </pre> <br><p>  Result of performance: </p><blockquote><img src="https://habrastorage.org/files/4d2/87c/655/4d287c65592b4f6e94582bcecd62774c.png"><br><br></blockquote><br><p> ¬ª <a href="https://embed.plnkr.co/vLwbHJOG2kWwEjbHDrLl/">  Plunker</a> <br> ¬ª <a href="https://www.typescriptlang.org/play/index.html">  Playground</a> <br><br>      ,     TypeScript     .                   JSON.  ,        ,        ( ,    <a href="https://habrahabr.ru/users/controller/" class="user_link">Controller</a> ). </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>   TypeScript    ,       .      -    ++,          . </p><br><p>     ,      : </p><br><ol><li><p>     .  ,    ,    ,      ..  ,        . </p><br></li><li><p>        Reflect.       ,       ,   . </p><br></li><li>        Reflect.getMetada   "design:type". </li></ol><br><p>       ,     . ,    8          .        (   ),        .  ,          API  ReactJS ,    <a href="http://stackoverflow.com/questions/29732015/value-of-this-in-react-event-handler">    this</a> . </p><br><p>  That's all for now.    ,     . </p><br><p>  UPD.   <a href="https://habrahabr.ru/users/whiletrue/" class="user_link">whileTrue</a> ,  ES7   .  ,     ES8 . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b9d/e2e/493/b9de2e4933d8459794024fca361cac2a.jpg"></div></div><p>Source: <a href="https://habr.com/ru/post/310870/">https://habr.com/ru/post/310870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310860/index.html">MMO in the real world, or instructions for creating live games, or How to make children in the camp interesting</a></li>
<li><a href="../310862/index.html">Toyota: 81,514 code violations</a></li>
<li><a href="../310864/index.html">We return to AMD drivers support for DirectX12 old processors</a></li>
<li><a href="../310866/index.html">Y Combinator: What to do before the explosive growth</a></li>
<li><a href="../310868/index.html">Fast rendering with DOM template engines</a></li>
<li><a href="../310872/index.html">ROAD audio codec analysis</a></li>
<li><a href="../310886/index.html">Replacing the boot-animation of an Android device with flickering Linux kernel logs</a></li>
<li><a href="../310892/index.html">Configuring D-link DSR routers to work with 3CX</a></li>
<li><a href="../310922/index.html">40% of organizations store admin passwords in spreadsheets and text files</a></li>
<li><a href="../310924/index.html">Forcing Asynchrony in Java Services for Baratine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>