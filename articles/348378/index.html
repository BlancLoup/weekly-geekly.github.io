<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>VDOM do it yourself</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. 


 Many frontend developers believe that the VDOM technology, which, in particular, is used in React.js, works like a black box. Also in the npm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>VDOM do it yourself</h1><div class="post__text post__text-html js-mediator-article"><p>  Hey. </p><br><p>  Many frontend developers believe that the VDOM technology, which, in particular, is used in React.js, works like a black box.  Also in the npm spaces there are a lot of libraries implementing this technology, however, as for me, it will break the leg in them.  The very topic of the VDOM I was interested in some time ago and I started experimenting by touch myself.  In the end, it was all over with the fact that I made my own VDOM implementation and embedded it in my datagram framework (I'll write about it somehow).  It turned out to be not easy, but very simple and in this article I will explain in detail what is what, why and why.  And how it works, too, will tell.  Dive under the cat and we indulge in an interesting experience. </p><a name="habracut"></a><br><h1 id="disclamer">  Disclamer </h1><br><p>  I'm not a frontend developer.  Do not hit me with slippers. <br>  Also, do not write "take the finished framework, cudgel".  I know that there are ready-made frameworks, but I need my own implementation for a number of purely technical reasons. </p><br><h1 id="zachem-ono-nado">  Why is it necessary </h1><br><p>  <em>TL; DR</em> : <a href="https://jsfiddle.net/9no687oa/">Example from this article on jsfiddle</a> <a href="https://github.com/reinforced/Reinforced.VdomSample">sources</a> </p><br><p>  On Habr√© <a href="https://habrahabr.ru/post/256965/">somewhere already there was an article about VDOM</a> , but I don‚Äôt like the explanation of the essence of the matter.  So let me scatter on my fingers.  So let's say you have a webpage, huh?  It draws a certain HTML element (probably quite large).  To add some context, I‚Äôll say that this element is drawn by stretching the template onto the view model.  Well, everyone used frameworks that do this, right?  Handlebars there, lodash-templates, AngularJS to some extent ... And in short, imagine that the model on which the template is being pulled is changed.  And you need to draw these changes inside the HTML element.  The question arises - how to do it and not be a fool?  Here, as usual, there are several options. </p><br><h3 id="innerhtml">  innerHTML </h3><br><p> You can run the data model through the template engine, get the HTML and just make <code>element.innerHTML = ourHtmlString;</code>  .  Cheap and angry, but for some tasks it rolls well.  What is terrible here, you ask? </p><br><p>  And I will answer you: this option is bad first of all because all the child elements located inside the <code>element</code> will be mercilessly killed by the browser and replaced with new ones.  Consequently?  Yes, therefore you will lose all the event subscriptions (within your element, of course) that you had.  You will have to re-sign the newly created elements again.  Here I honestly do not know how garbage collection works in different js engines, but I admit that if you previously saved some of the child elements in your code, for example, in variables, then these elements will be removed from the tree, but not destroyed.  Hi, memory leak, we missed you.  Well, this is assuming that the browser uses reference counting for DOM elements, for example.  Who knows the details - please write in the comments. </p><br><p>  Besides this, this variant is very slow, especially when there are many children.  That is, the browser honestly erases everything that was drawn inside the element, recalculate and redraw it anew.  Just imagine - you have a Grisha user's card in which there are 100 different fields.  And in your data only the date of birth has changed.  And now - "All garbage, Grisha, let's be new" for one unfortunate piece of text?  Kill Grisha entirely, calculate and draw again?  Do you know that redrawing the interface in the browser is actually a long time?  And if Grisha consists of 150 elements, then all the same.  But if out of a thousand (the autopsy shows Grisha an abundance of fine details), then on some machines the redrawing can take several seconds, which greatly reduces the responsiveness of the interface. </p><br><p>  Well and the saddest thing: not all elements are drawn through innerHTML.  As an example, in IE8 <a href="https://stackoverflow.com/questions/4729644/cant-set-innerhtml-on-tbody-in-ie">it is not possible to set innerHTML</a> on the <code>tbody</code> element.  In Google Chrome, the table headings ( <code>th</code> ) are poorly rendered via innerHTML.  Everything that you put in there through innerHTML will be truncated to plain text for an unknown reason.  Pruflinka will not be - information from my own experience.  Probably now it was repaired, but the sediment remained. </p><br><p>  Thus innerHTML is like a fast and dirty hack.  Unreliable in general, has a bunch of side effects, and in general - we are not here in grade 9 school to write like that.  Of the benefits - is implemented on the knee. </p><br><h3 id="parser-html">  HTML parser </h3><br><p>  Frankly, this option solves only the latest and most sad innerHTML problem - the finest fastidiousness in the created elements.  But it is definitely worth mentioning it, largely because we need it to implement VDOM. </p><br><p>  How does it work?  Yes, it just works.  Parsing HTML and calling <code>document.createElement</code> for each node, followed by setting attributes.  Then do <code>element.innerHTML = ''</code> and go through the received elements by calling <code>appendChild</code> / <code>insertBefore</code> . </p><br><p>  Well ... First, we have not solved the problem with the killing of elements.  Secondly, with HTML parsing, everything is not so smooth in this world. </p><br><p>  Parsing HTML is about how to parse an XML document and is most often used for client side in parsers <del>  in food </del>  thread parser.  Dada, it's about like <a href="https://en.wikipedia.org/wiki/StAX">StAX in Java</a> .  It is proved that the use of XML stream parser is good for health.  Why?  Yes, because it is fast and easy to write.  You should not use the classic tree parser for this task as for XML.  It is simply not necessary here. </p><br><p>  Everything in the world of HTML parsers is good, except for one thing: I don‚Äôt have them, poor things built into browsers.  In MDN <a href="https://developer.mozilla.org/ru/docs/Web/API/DOMParser">, the DOMParser is mentioned</a> , but it is still experimental and, apparently, will give you a tree at the output.  Well, that's just to bypass the trees and call <code>document.createElement</code> on the client side, and we didn‚Äôt have enough, yeah.  In a word, he is strange.  Let's not touch it.  There is <a href="https://www.npmjs.com/package/htmlparser2">htmlparser2 - there lies in npm</a> .  Event stream parser, but I did not use it myself, because as the ideology of my framework it does not allow me to use third-party dependencies.  And there is <a href="https://johnresig.com/blog/pure-javascript-html-parser/">an article and an example of John Rezig's code</a> (please take it apart from jQuery), where he explains everything on his fingers and gives the code of a simple parser.  I don't like it because it works on regular expressions.  I see this very hard.  However, quite workable.  For a long time, I (I repent) used just the code from this article, revised for TypeScript.  However, then I replaced it with a stream parser on a simple state machine (which I will share with you today) in order to minimize string comparisons and support for creating virtual elements (which, for example, John was somewhat uncomfortable). </p><br><h3 id="vdom-sobstvennoy-personoy">  VDOM in person </h3><br><p>  And here we finally come to the most cunning approach, which solves problems with both performance and the fastidiousness of innerHTML to elements.  Namely - using the HTML parser, we can, suddenly, parse our HTML, but call for each element not <code>document.createElement</code> , but simply create some object that will store the tag name and attributes.  This very object will be called a <em>virtual DOM node</em> , and their combination - a <em>virtual DOM tree</em> , or VDOM.  Here it is worth noting that create a thousand objects in JS through <code>var a = {};</code>  - it's fast.  Very fast.  But to create a thousand real DOM nodes is slow.  From this circumstance, sobsno, and results in productivity gains. </p><br><p>  OK, created.  And what will we do with this good? <del>  Take off your pants and run </del>  You can not take off your pants, but you will have to run: we will <strong>compare the</strong> structure of our VDOM tree with what has already been drawn, make some sort of diff patch from this (what needs to be added, what to remove, where to drop attributes, where to change the content) and roll it onto an existing DOM tree.  This is exactly the same as it happens in your favorite git during the merge.  Fortunately, the task of building a diff in programming is quite well known - it is googling, suddenly, according to the words, <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D0%25B8%25D0%25B1%25D0%25BE%25D0%25BB%25D1%258C%25D1%2588%25D0%25B0%25D1%258F_%25D0%25BE%25D0%25B1%25D1%2589%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BF%25D0%25BE%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">finding the largest common subsequence</a> .  It is solved by dynamic programming.  The algorithm has a quadratic complexity.  In good universities, the solution of this problem is studied in the first courses, but here I will describe it thesis and tell you how to adapt it to the trees. </p><br><p>  <strong>UPD:</strong> <em>in the comments I was already showered with tomatoes for the fact that LCS is not optimal for this task - it is necessary to use LIS, but I cannot rewrite the article and the code so quickly.</em>  <em>So just keep in mind that the part that is involved in calculating the diff can be optimized much "denser".</em> </p><br><p>  As a result, the VDOM approach does not kill those elements of the tree that have not changed and does not create unnecessary elements, which significantly saves memory and keeps event subscriptions (if the elements are not destroyed), at the same time forcing your CPU to do more comparisons than creating HTML elements .  And this gives a notable increase in productivity, when only one of the 1000 elements on the screen has changed. </p><br><h1 id="pristupim">  Let's get started </h1><br><p>  We will write a small application that will consist of a <code>textarea</code> on the left, in which you will drive in and / or modify your HTML, and in the window on the right you will see the result of the work.  No additional libraries - only TypeScript and browser.  Let us, as they say, create magic from the air. </p><br><p>  You know, at first I wanted to add a lot of code to this article with line-by-line parsing of it, but, remembering my previous articles, I did not dare to do that.  Directly, the code reduces readability and bores.  So, with your permission, I‚Äôll just give links to Github and explain how and what works.  Our VDOM will consist of three main components - the HTML parser, the comparator itself and the batch calculator, as well as <code>app.ts</code> , which will put all this <code>app.ts</code> together and make it work. </p><br><h2 id="parser">  Parser </h2><br><p>  Here it is necessary to make a reservation.  As I understand it, React.js works without an HTML parser since its templates (jsx / tsx) are already being assembled into the corresponding calls for creating nodes.  This is a good move that improves speed, but you know ... it was not my plan to create my own template making language and writing a compiler for it when I was writing this article.  So we will parse the bare HTML hands.  This implementation guarantees us the opportunity to embed our craft anywhere, well, and will allow you to avoid purely pedagogical curiosities, if you know what I mean :) So, let's go. </p><br><h3 id="stek">  Stack </h3><br><p>  JavaScript does not contain effective tools for working with stacks, but we need it.  Therefore, we make a <a href="">simple stack</a> .  No comments. </p><br><h3 id="konstruktor-nod">  Constructor node </h3><br><p>  As you know, in terms of JavaScript, an HTML document consists of nodes.  Some of which are quite HTML elements, such as HTMLInputElement ( <code>input</code> tag), HTMLDivElement ( <code>div</code> tag).  And some - no (text, comment).  All available node types are listed <a href="https://developer.mozilla.org/ru/docs/Web/API/Node/nodeType">here in MDN</a> .  We begin with a simple one - we will declare a so-called interface.  "constructor node".  In order not to enter into our HTML parser, I call <code>document.createElement</code> and use the same parser for the DOM and for the VDOM.  In my implementation, it looks <a href="">like this</a> .  As you can see, we are limited to three types of nodes - HTML element, text (content) and comment.  The interface is extremely simple and provides for the possibility of creating all three types of nodes, and for an HTML element also the installation of attributes.  In order not to depart from the cash register, we immediately implement it for real HTML nodes.  <a href="">It is very simple.</a>  <a href="">Even a child can handle it</a> . </p><br><p>  Here we will think over how we will store VDOM nodes.  What is important for us to know about a node, besides its type?  In the case of an HTML element, a tag and attributes.  In the case of a comment and text - the content.  In addition to everything else, the list of child nodes is just as important to us.  Fine.  We describe the interface and <code>enum</code> for types, after which we implement the constructor itself: <a href="">like this</a> . </p><br><h3 id="parser-html-1">  HTML parser </h3><br><p>  Parser - we will have such a thing, which has a limited number of <strong>states</strong> .  She is <del>  leisurely </del>  It goes according to the HTML transmitted to it, symbol by symbol and changes its state depending on the current symbol.  When moving from state to state, the parser will pull the constructor's node methods, performing the appropriate actions. </p><br><p>  For example: reads the parser characters, does not touch anyone.  Op - met <code>&lt;</code> , remembers where he saw him, changes his state to "listen carefully, now there will be an HTML tag".  Reads on.  Op - meets the whitespace character, and like this: aha!  here is the name of the tag.  He remembers where he met <code>&lt;</code> , gnaws the text from there to the current position - this is the name of the tag.  So, it is necessary to pull the constructor node and call create on it, passing the name of the tag.  Then the parser skips all whitespace characters and if it sees <code>&gt;</code> , it goes to its original state.  And if he sees the letter of the alphabet, he also catches the name of the attribute, <code>=</code> , the attribute value in quotes, pulls the constructor node ... And so on, until it reaches the end. </p><br><p>  The created tags will be stored on the stack.  Every time we reach the opening tag, we put it on the stack.  When creating an element through the constructor, we indicate the current top of the stack as the parent element.  Trivially.  I am sure that at least once everyone did something similar when they wrote a calculator on the first courses of the university. </p><br><p>  All states, as well as actions during transitions, we put in a <em>state machine</em> , which technically is a huge <del>  Dictionary fucking c # in head </del>  a hash object of the form "state" -&gt; "description of actions".  The description of actions in our case consists of three parts: </p><br><ul><li>  the function that will be executed on entering the state; </li><li>  a function that will be executed at the exit from the state; </li><li>  the function that will be called for each next character read; </li></ul><br><p>  I combined these three functions into a piece that I called <a href="">IStateInfo</a> .  In the same place I described all possible states of the parser.  I made <a href="">the parser itself</a> , providing it with several useful tester functions (this is when we look at what the current symbol is, what was n characters back, whether the next m characters follow such a word, and so on).  The <code>fix()</code> function stands out in <code>fix()</code> : when we change the state of the parser, it remembers the position of the current character with the thought that by moving a few characters further, we can gnaw a piece of text between the stored position and the current position.  Gnawing out a piece of text from the memorized position to the current position is performed by the <code>cut()</code> function.  Usually, after calling <code>cut()</code> , a state machine sends a <strong>signal to the</strong> parser - like "oh, look, the opening tag is caught, here is its name."  Why so hard?  Well ... I am an economical person.  Made a parser that does not create unnecessary lines unnecessarily. </p><br><p>  Well and, actually, further I simply listed all possible states of the parser and all possible actions - as they say, I <a href="">programmed the state machine</a> .  There are many nuances associated with quotes around attributes, self-closing tags, symbols <code>-</code> and <code>:</code> in attribute names.  Allow me to omit here the detailed chewing of each of these cases - everything is in the code, if you wish, you will see it. </p><br><p>  Another feature: the <code>style</code> and <code>script</code> parser cuts and folds separately, so that the user of the parser himself decides <del>  execute or pardon them </del>  what to do next with them.  You can, for example, make <code>eval</code> for scripts.  But what to do with styles - the question is not clear even for me.  The only thing that is not taken into account in my implementation is the tricky possible structure of these tags.  Say, if in a <code>script</code> you have text in the spirit of <code>return '&lt;/script&gt;';</code>  , the parser mistakenly recognizes it as closing the <code>script</code> tag, which is unpleasant, but it is easy to repair. <del>  I'm just too lazy </del>  . </p><br><h2 id="vyschityvaem-raznicu">  Calculate the difference </h2><br><p>  So, at the current stage, we have a valid HTML parser, to which you can transfer a piece of HTML-me and parse it into real DOM elements, or into VDOM elements.  This is just great. <br>  Now imagine that we have already drawn some kind of HTML on the screen, we want to change it slightly.  We take it, make adjustments, feed the parser with the VDOM constructor.  Get the list of VDOM nodes.  Now we need to calculate the difference between the HTML that is drawn on the screen and what our parser has done to us.  In fact, we need to take a parent-node, inside which our HTML is rendered, take an array of all its children and compare it with a similar array of virtual children, which we created the HTML-parser.  And when I say "compare" - I mean not only answer the question "match or not," but also generate a so-called.  "update batch" - a list of which items to add and which ones to remove from where to get a new one from an old piece of wood.  After that, the resulting packet of changes simply rolls onto the already rendered HTML, without destroying the already rendered and unchanged, but cleverly changing only the affected nodes.  This operation is called <strong>VDOM update</strong> .  Something like that.  But first things first. </p><br><h3 id="kesh-sravneniy">  Comparison cache </h3><br><p>  First you need to learn how to compare HTML nodes and VDOM nodes.  This is done relatively simply: </p><br><ol><li>  Compare types.  If it does not match, the nodes are different. </li><li>  If both nodes are textual or comments - compare the content.  Coincides?  The same.  Does not match?  Various. </li><li>  Compare the number of attributes.  Does not match?  Various. </li><li>  Meaningfully we compare the presence of attributes and their values.  Something did not match?  Well, you understand. </li><li>  We perform steps 1-4 for each child node. </li><li>  If you are reading this, then the nodes still match. </li></ol><br><p>  As you can see, comparing nodes from scratch each time is labor-intensive.  Largely due to recursion in step 5.  Therefore, I made a cache comparator that lives within one update and stores the results of comparisons of nodes with each other.  Thus, if the fact that two nodes are different has already been installed, it is not installed again, but is taken from the cache.  <a href="">A lot of the same type of code</a> . </p><br><h3 id="lcs">  LCS </h3><br><p>  This is short for "Longest Common Subsequence".  <a href="">This class</a> is essentially a matrix for solving a LCS problem using dynamic programming.  We give it two arrays to the input - one of the real nodes, the other - from the virtual ones, we also feed the comparison cache, which I described above.  Next, call <code>produceModifyBatch</code> and get an array of <a href="">batch entries (described at the bottom)</a> , which essentially says what needs to be done with such and such an account node - update, delete, or insert another (and which) node BEFORE it. </p><br><p>  First, after calling <code>produceModifyBatch</code> , LCS cuts the same elements from the beginning and from the end of the arrays (the <code>doSkips</code> function).  Next, on the remaining data is the matrix of dynamic programming - <a href="https://www.youtube.com/watch%3Fv%3DP-mMvhfJhu8">exactly as explained in this video</a> .  Then bypass this, determining which nodes should be <strong>removed</strong> and which ones should be <strong>added</strong> (also described in the video).  Please note that at this stage we do not get a list of nodes that need to be <strong>updated</strong> .  The result contains only delete-add, but!  But deleting-adding a node to the same place (or adding-deleting) is the <strong>update</strong> .  The <code>normalizeBatch</code> operation does just that, which collapses the nearby add-delete in one operation ‚Äî the <strong>update</strong> , reformatting the primary batch entry array.  The result, finally, you can return a happy user. </p><br><p>  LCS is the most difficult thing in VDOM, which makes it seem like a terrible magic to many.  As you can see, the algorithm itself, as they say, is tricky, but quite understandable to itself.  Its complexity, by the way, is quadratic, but there is nothing to be afraid of.  If the changes are relatively small and they are somewhere in the middle of a pack of elements, most of them are cut off at the <code>doSkips</code> stage and as a result, the dynamic programming matrix rarely exceeds 3x3 in size.  Of course, if your users do not redraw 10 thousand buttons, standing under each other.  In practice, such cases rarely occur.  So it makes sense not to build the LCS-matrix, if you have 2 or 1 element, but to process the result with your hands.  Much more often in real life there is a large nesting of elements, for that matter. , ,       JS (     ).    .  ,    React.js        ‚Äî     .   ‚Äî .           . </p><br><h3 id="materializator-i-dom-differ">   DOM Differ </h3><br><p> ,   update,      parent-,  LCS-,    HTML-   .  , ,  <a href=""> </a> ‚Äî ,      .  No comments. </p><br><p>     ! <del>  ! </del></p><br><p>  update:   parent-,   VDOM-.  LCS,  update batch.    ,  ,      , ,    ‚Äî  . ,    ‚Äî       <code>updateAttributes</code> ,         update,        (,     VDOM--).  : ,    ‚Äî   ,  <code>parent.insertBefore</code> . ,    ‚Äî  <code>parent.removeChild</code> .  . <a href="">  </a> . </p><br><p>       <code>diff</code> ,      update batch-. ,        . </p><br><h3 id="vse-vmeste">   </h3><br><p>  <a href="https://github.com/reinforced/Reinforced.VdomSample/blob/master/Reinforced.VdomSample/index.html"> HTML-   </a> ,  <a href="">app.ts</a> ,         . </p><br><h1 id="itogi">  Results </h1><br><p>     ,   VDOM. ,   ,            ,               JS-. -, ,   HTML- ‚Äî ,   . </p><br><p>    ,  . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348378/">https://habr.com/ru/post/348378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348364/index.html">BitPaymer (FriedEx) coder created by Dridex banker trojan authors</a></li>
<li><a href="../348366/index.html">Personal experience with Firebase Cloud Firestore</a></li>
<li><a href="../348368/index.html">Dynamic font size change throughout an Android application using Configuration.fontScale</a></li>
<li><a href="../348374/index.html">Translation of the book "Social Architecture": Chapter 5. Design, development, innovation</a></li>
<li><a href="../348376/index.html">pdbe is an assistant to the built-in python debugger and debugging process</a></li>
<li><a href="../348380/index.html">8-bit computer with BASIC and VGA-out on the Arduino</a></li>
<li><a href="../348382/index.html">Is it true that PM does something useful and what it takes to become</a></li>
<li><a href="../348384/index.html">Pygest # 22. Releases, articles, interesting projects, packages and libraries from the world of Python [January 18, 2018 - February 4, 2018]</a></li>
<li><a href="../348386/index.html">What really happened to vista</a></li>
<li><a href="../348390/index.html">Web typography: create tables for reading, not for beauty</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>