<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Continuous Delivery & Sitecore: our implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to introduce you to our concept of Continuous Delivery (hereinafter, CD) in relation to the main CMS in which our company is developing - Sitec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Continuous Delivery & Sitecore: our implementation</h1><div class="post__text post__text-html js-mediator-article">  I want to introduce you to our concept of Continuous Delivery (hereinafter, CD) in relation to the main CMS in which our company is developing - Sitecore.  Our CD concept is based on three pillars: <br><ul><li>  Version control system - Git (in principle, it can be applied to others, but Git is most convenient because its branches are very simple, fast and cheap) </li><li>  CI server - TeamCity </li><li>  Code that actually performs all delivery, installation and processing (scripts and additional executable files) </li></ul><br>  In this article, I will try to describe all the aspects involved. <br><a name="habracut"></a><br><h4>  Git </h4><br>  The choice of this version control system is due to our CD concept, in which we have three main branches in each repository: dev, acceptance and master.  In accordance with the names, each branch reflects the status of the code on one of the three servers: <br><ul><li>  Dev = QA, internal server, available only on our network.  It is the main testing </li><li>  Acceptance = acceptance is a server that is accessible from both our network and customers, but is not available to other Internet users. </li><li>  Master = production server accessible to all. </li></ul><br>  All development begins and is maintained in a separate branch, the root of which is master.  Upon completion of development, a merg in dev occurs, and the task is given for testing. <br>  If any bugs were found - fix in the branch, merge and retesting. <br>  After the tester considers the task completed - it is merg in acceptance, the delivery and the task is given to the testers and the customer for verification.  If any problems were found, the above process is repeated again. <br>  If the task is completed in the customer's opinion, a merge of the branch takes place, in which development was carried out in master and delivery to production. <br>  Thus, Git is a very important part of our development and delivery process due to simple and fast branches and ease of management. <br><br><h4>  TeamCity and delivery process with involved scripts / applications </h4><br>  Easy to set up, free for small projects (no more than 20 build configurations), understands most common version control systems (including our favorite Git), has built-in runners for MSBuild, nANT, Visual Studio, and also provides access to its restAPI for receiving data and managing configs.  In my opinion, one of the most convenient in its class build servers (as well as other products of JetBrains).  Also, one very handy feature of TeamCity is the ability to configure parameters at the project level or at the build level right through the web interface.  It is possible to configure the parameters at the server level, as well as access to the system parameters of the host (for example, PATH). <br>  A typical project build that automatically delivers and verifies that a web application is live after delivery (page returns 200) consists of the following configuration aspects: <br>  <b>General settings</b> : based on the results of each build, we collect artifacts - an archive with a web application, a pekedzhi archive (Sitecore uses xml files created and archived for pending files between environments, which we call pekedzhi) and an archive with SQL scripts, if The solution uses additional databases.  As well as an auto-increment build counter, which is used in the patcher built into TeamCity AssemblyInfo, incrementing the build version. <br>  <b>Version control system settings</b> : in TeamCity are simple to disgrace and easily configured.  The only interesting point here is the ability to tag the results of the build, which, theoretically, allows you to return exactly to the code in which there was / appeared any problem.  If possible, an incremental checkout is used here in order to speed up the build and reduce traffic. <br>  <b>Actually, the build itself</b> : <br><ol><li>  Build and Publish solution using Visual Studio tools (VS of the required version should be installed on the server).  Specify the path to the sln file, specify the variable which build configuration for this sln file to call (each project has several build configurations for each environment involved).  Publish is performed in a local folder on the server, because it was not possible to organize the delivery using the MS Publish Tool directly to the server you need.  The first and last problem I stumbled on was that we were in different domains.  If an error occurs MSBuild - the build stops, and an informational message is sent to the following persons: people whose commits participated in the build, build engineer, and testers. </li><li>  Preparation of files and the target application to install pekedzhey (script).  Due to the fact that Sitecore does not allow the creation of nodes in the database containing special characters of languages ‚Äã‚Äãand reserved characters by default, and sometimes it is impossible to do without them during development - in this step a special patch is delivered to the target application, which allows the use of these symbols .  In the same step, after delivery of the patch config, which causes the application to restart, wget is used to get the main page of the site.  This ensures that the application is operational and ready for the next step. </li><li>  Delivery of nodes to Sitecore databases.  WCF service is deployed to a web application, which accepts pekedzhi and installs them (let me remind you that site uses xml files created and archived for delivery between environments in a special way, which we call pekedzhi), which allows you to automate this procedure as follows: necessary for delivery to the target application pekedzhi in a designated folder, which is also stored in surs-control.  TeamCity independently collects data about the changes involved in this build and provides access to them via restAPI.  The application responsible for delivery reads xml from restAPI, selects pekedges participating in the build and sends them to the WCF service, after which the WCF service installs them.  All the necessary data for the collector application is transmitted through parameters that are configured at the project level, since they are the same for the entire repository.  Unfortunately, there is one problem related to the WCF service and settings of the target application: if the size of the pekedzha is too large, or its installation takes more than 20 minutes - the service breaks the connection.  If an error occurs - the service returns an error, the build stops, notifications are sent to the same person as in the first step.  WCF service will be called only if there is something to deliver to Sitecore, which also contributes to the acceleration of the build. </li><li>  Publish nodes in content database.  Since Sitecore works with two databases (master ‚Äî in which content is created and web ‚Äî from which content is delivered to the end user), another application was created to implement Sitecore‚Äôs built-in process of transferring data from a master to a web database. which is called Publish.  This application works on the same principle as the application from step 3. The developer commits a file that describes the nodes that need to be zapped out line by line, the application retrieves these files via restAPI (files are selected from the commit from a specific folder in the repository, the limitation is that the files must have a certain extension), reads the contents of the files and sends it to the WCF service, which, in turn, will publish the nodes with their children.  Unlike the previous step, when an error occurs in this step, the build does not stop.  WCF service will be called only if there is something to publish in Sitecore, which also contributes to the acceleration. </li><li>  Code preparation and delivery to the target server.  In this step, the usual cmd script packages the pre-existing solution and, via SSH, delivers the resulting archive to the target server in a temporary directory, unpacking the archive there as well.  After that, App_Offline.htm is placed in the web application folder, which stops the web application and allows users to display a message indicating that the application is currently being updated. </li><li>  Update third-party databases (Optional step).  If the application uses not only the standard Sitecore data, but also additional ones - in this step, these databases are updated using scripts stored in the resource control in a special folder, by analogy with the files from steps 3 and 4. At this point, the choice of the necessary script and its application is carried out using a special file name format (version. name).  If the version files are higher than the database version (stored in the Extended properties field) - the database is updated by the script from the file.  In a short time, files for updating the database will be received by the application-collector, similar to steps 3 and 4. Also, soon it is planned to switch this step from execution on the host server build to execution on the WCF service (however, in this case you will have to refuse from App_Oflline.htm), which should increase security. </li><li>  Delivery code in the application.  The script clears the folder with configs and binaries in the application, then from the folder unpacked in step 5, delivers the code and accompanying files to the web application folder.  The last step of the script removes App_offline.htm. </li><li>  With the help of wget we get the page (as a rule, the main one) of the site to make sure that the application is alive (code 200).  If the code is different from 200 - the build is considered to have failed. </li></ol><br>  This is how the automatic delivery of web applications based on Sitecore CMS works. <br><br><h4>  Pros / cons / unrealized buns of this approach </h4><br>  Strictly speaking, there are a lot of advantages, but the main thing that I would like to single out is that we have removed the person from the process of delivery, with his usual forgetfulness and laziness.  Also, due to automation, delivery has accelerated significantly.  Of course, the source is still the person (the developer).  If he didn‚Äôt commit something, it will not be delivered, zakkomtitil wrongly - it will be delivered incorrectly.  But such purely human errors, as a rule, are caught on internal testing. <br>  Cons, as well as unrealized buns, however, is also missing.  I would like to highlight a few: <br><ol><li>  During the entire build period it is necessary that the Internet is connected.  If there is a problem with the Internet connection, the build will fail.  This will not be a problem in the steps to the fifth.  However, if at the 5th step the Internet falls off, the application will remain unused, and it will only be possible to fix it by hand. </li><li> I do not see an opportunity to implement automatic rollback to the previous version in case of a failure in the steps above the second: database backup is done automatically, but recovering it is a rather long process, and versioning of all sites without third-party (and rather expensive applications) is impossible.  As with the database, I don‚Äôt yet imagine the possibility of automatic code rollback. </li><li>  There is no 100% criterion that the delivery was successful: there are situations when the test page returns a code of 200, while others may fall with errors. </li><li>  Delivery via SSH is very good for its stability and speed, but, unlike MS Publish Tool, it leaves files on the target web application that were excluded from the solution.  Not that it was a major problem, however, just plain ugly. </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/154327/">https://habr.com/ru/post/154327/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../154317/index.html">Meet the free and free Scada headset</a></li>
<li><a href="../154319/index.html">Popular about pseudo-elements: Before and: After</a></li>
<li><a href="../154321/index.html">GWT + Hibernate + Dispatch</a></li>
<li><a href="../154323/index.html">Granular restoration of virtualized application objects</a></li>
<li><a href="../154325/index.html">Time capsule</a></li>
<li><a href="../154331/index.html">About a dozen useful opensource libraries for iOS developers</a></li>
<li><a href="../154333/index.html">The best way to learn English for single men</a></li>
<li><a href="../154335/index.html">Suggest.io: Towards the Perfect Search</a></li>
<li><a href="../154339/index.html">Infiniband: data matrix</a></li>
<li><a href="../154341/index.html">Noosphere automation system (social detonator) based on Boolean algebra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>