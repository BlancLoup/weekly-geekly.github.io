<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RESTful API for the server - doing it right (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In 2007, Steve Jobs introduced the iPhone, which revolutionized the high-tech industry and changed our approach to work and business. Now 2012 and mor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RESTful API for the server - doing it right (Part 1)</h1><div class="post__text post__text-html js-mediator-article">  In 2007, Steve Jobs introduced the iPhone, which revolutionized the high-tech industry and changed our approach to work and business.  Now 2012 and more and more sites offer native iOS and Android clients for their services.  Meanwhile, not all startups have the finances to develop applications in addition to the main product.  To increase the popularity of their product, these companies offer open APIs that can be used by third-party developers.  Perhaps Twitter was the first in this area and now the number of companies following this strategy is growing rapidly.  This is a really great way to create an attractive ecosystem around your product. <br><br><a name="habracut"></a><br>  The life of a startup is full of changes, turning points in which the fate of the project depends on the decisions made.  If your codebase is not able to provide the embodiment of a variety of your solutions - you have lost.  The server code, which is flexible enough to adjust to the needs of the business in a short time, decides whether to be a project or not.  Successful startups are not the ones that just offered a great idea, but those that were able to put it into practice.  The success of a startup depends on the success of its product, be it an iOS application, service, or API.  For the past three years, I have been working on different iOS applications (mainly for startups) using web services, and in this blog I tried to gather my accumulated knowledge and show you the best techniques you need to follow when developing the RESTful API.  A good RESTful API is one that can be changed easily and simply. <br><br><h4>  The target audience </h4><br>  This post is intended for those who have knowledge in the development of a RESTful API level from intermediate to advanced.  As well as some basic knowledge of object-oriented (or functional) programming in server languages ‚Äã‚Äãsuch as Java / Ruby / Scala.  (I intentionally ignored PHP or Programmable Hyperlinked Pasta). <br>  <i>Note</i>  <i>Per.</i>  <i>Here the author provided a link to a <a href="http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html">humorous article</a> about the history of programming languages ‚Äã‚Äãwhere PHP was decoded as Programmable Hyperlinked Pasta (Programmable Hyperlinked Noodles).</i>  <i>What characterizes the attitude of the author to PHP.</i> <i><br></i> <br><h4>  The structure and organization of the article </h4><br>  The article is quite detailed and consists of two parts.  The first describes the basics of REST, while the second describes the documentation and support for different versions of your API.  The first part for beginners, the second for the pros.  I have no doubt that you are a pro, and therefore here is a <a href="https://habr.com/ru/post/144011/">link</a> for you to jump directly to the chapter ‚ÄúAPI Documentation‚Äù.  Perhaps you should start from there, if it seems to you that this post is from the category ‚ÄúMany bukaf, niasilil ...‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  RESTful principles </h4><br>  A server can be considered RESTful if it complies with <a href="http://ru.wikipedia.org/wiki/REST">REST</a> principles.  When you develop an API that will be primarily used by mobile devices, understanding and following the three most important principles can be very useful.  And not only in the development of the API, but also with its support and development in the future.  So let's get started. <br><br><h5>  Statelessness </h5><br>  The first principle is independence from state.  Simply put, the RESTful server should not monitor, store, or even use the current contextual information about the client.  On the other hand, the client must take on this task.  In other words, do not make the server remember the state of the mobile device using the API. <br><br>  Let's imagine that you have a startup called ‚ÄúNew Facebook‚Äù.  A good example where a developer could make a mistake is providing an API call that allows a mobile device to set the last read item in a stream (let's call it the Facebook feed).  An API call, usually returning a feed (let's call it / feed), will now return items that are newer than the one set.  Sounds smart, doesn't it?  Have you ‚Äúoptimized‚Äù the data exchange between the client and the server?  And no. <br><br>  What can go wrong in the above case is that if your user uses the service from two or three devices, then in the case when one of them installs the last element read, the rest will not be able to load the tape elements read on other devices. earlier. <br><br>  <i>State independence means that the data returned by a particular API call should not be affected by calls made earlier.</i> <br><br>  The correct way to optimize this call is to pass the creation time of the last read tape entry as an API call parameter returning the feed (/ feed? LastFeed = 20120228).  There is another, more ‚Äúcorrect" method - the use of the HTTP header If-Modified-Since.  But we will not go into this direction for now.  We will discuss this in the second part. <br><br>  The client, on the other hand, may (must) remember the parameters generated on the server when accessing it and use them for subsequent API calls, if required. <br><br><h5>  Cached and layered architecture </h5><br>  The second principle is to provide the client with information that the server's response can be cached for a certain period of time and reused without new requests to the server.  This client can be either a mobile device itself or an intermediate proxy server.  I will tell you more about caching in the second part. <br><br><h5>  Client - server split and single interface </h5><br>  A RESTful server must hide as many details of its implementation as possible from the client.  The client should not be aware of which DBMS is being used on the server or how many servers are currently processing requests and other such things.  Organizing the proper separation of functions is important for scaling if your project starts to gain popularity quickly. <br><br>  These are probably the three most important principles to be followed during the development of a RESTful server.  Next will be described three less important principles, but they all have a direct bearing on what we are talking about here. <br><br><h4>  REST requests and four HTTP methods </h4><br>  Get <br>  POST <br>  PUT <br>  DELETE <br><br><h5>  The principle of ‚Äúcacheability‚Äù and GET requests </h5><br>  The main thing to remember is that a call made via GET should not change the state of the server.  This in turn means that your requests can be cached by any intermediate proxy (load reduction).  Thus, as a server developer, you should not publish GET methods that change data in your database.  This violates the RESTful philosophy, especially the second paragraph described above.  Your GET calls should not even leave entries in access.log or update ‚ÄúLast logged in‚Äù data.  If you are changing data in the database, these must be POST / PUT methods. <br><br><h5>  That discussion of POST vs PUT </h5><br>  The HTTP 1.1 specification states that PUT is <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B4%25D0%25B5%25D0%25BC%25D0%25BF%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">idempotent</a> .  This means that a client can perform multiple PUT requests on a single URI and this will not create duplicate entries.  Assignment operations are a good example of an idempotent operation. <br><br><pre><code class="java hljs">String userId = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.request[<span class="hljs-string"><span class="hljs-string">"USER_ID"</span></span>];</code> </pre> <br>  Even if this operation is performed twice or three times, there will be no harm (except for extra processor cycles).  POST, on the other hand, is not idempotent.  This is something like an increment.  You should use POST or PUT, taking into account whether the action being taken is idempotent or not.  In the language of programmers, if the client knows the URL of the object to be created, use PUT.  If the client knows the URL of the method / class that creates the desired object, use POST. <br><br><pre> <code class="bash hljs">PUT www.example.com/post/1234</code> </pre><br>  Use PUT if the client knows the URI, which itself could be the result of the request.  Even if the client calls this PUT method many times, no harm or duplicate entries will be created. <br><br><pre> <code class="bash hljs">POST www.example.com/createpost</code> </pre><br><br>  Use POST if the server itself creates a unique identifier and returns it to the client.  Duplicate records will be created if this request is repeated later with the same parameters. <br>  More information in <a href="http://stackoverflow.com/a/2691891/90165">this discussion</a> . <br><br><h5>  DELETE method </h5><br>  DELETE is absolutely unique.  It is idempotent as PUT, and should be used to delete a record if it exists. <br><br><h4>  REST answers </h4><br>  Answers from your RESTful server can be used as XML or JSON.  Personally, I prefer JSON, because it is more concise and a smaller amount of data is transmitted over the network than when transmitting the same response in XML format.  The difference may be of the order of several hundred kilobytes, but, taking into account the speeds of 3G and the instability of the exchange with mobile devices, these several hundred kilobytes can be important. <br><br><h4>  Authentication </h4><br>  Authentication must be done via https and the client must send the password in encrypted form.  The process of getting sha1 hash NSString in Objective-C is quite clear and simple, and the code below clearly shows this. <br><br><pre> <code class="cpp hljs">- (NSString *) sha1 { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cstr = [self cStringUsingEncoding:NSUTF8StringEncoding]; NSData *data = [NSData dataWithBytes:cstr length:self.length]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> digest[CC_SHA1_DIGEST_LENGTH]; CC_SHA1(data.bytes, data.length, digest); NSMutableString* output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH * <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;; CC_SHA1_DIGEST_LENGTH; i++) [output appendFormat:@<span class="hljs-string"><span class="hljs-string">"%02x"</span></span>, digest[i]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre><br>  The server should compare the received password hash with the hash stored in its database.  In any case, under no circumstances should passwords be transmitted from the client to the server in open form.  There are no exceptions to this rule!  The day when your users find out that you store their passwords in clear text may be the last day of your startup.  Trust, once lost, can not be returned. <br><br>  RFC 2617 describes two methods of authentication on an HTTP server.  The first is Basic Access, the second is Digest.  For mobile clients, either of these two methods is suitable and most server (and client too) languages ‚Äã‚Äãhave built-in mechanisms for implementing such authentication schemes. <br><br>  If you plan to make your API public, you should also look towards oAuth or better oAuth 2.0.  oAuth will allow your users to publish content created in your application on other resources without exchanging keys (logins / passwords).  oAuth also allows users to control what exactly is in access and what permissions are given to third-party resources. <br><br>  The Facebook Graph API is the most advanced and common implementation of oAuth at the moment.  Using oAuth, Facebook users can give access to their photos to third-party applications without publishing other private and identification information (login / password).  The user can also restrict access to unwanted applications without having to change their password. <br><br>  Until now, I have been talking about the basics of REST.  Now we come to the essence of the article.  In subsequent chapters, I will talk about practical techniques that should be used when documenting, creating new ones and completing support for old versions of my API ... <br><a name="API_documentation"></a><br><h4>  API Documentation </h4><br>  The worst documentation a server developer can write is a long, consistent list of API calls describing parameters and return data.  The main problem with this approach is that making changes to the server and the format of the returned data as the project develops becomes a nightmare.  I will make some suggestions on this subject so that the client software developer understands you better.  Over time, this will also help you develop as a developer of server software. <br><br><h5>  Documentation </h5><br>  The first step I would recommend is to think about the basic, high-level data structures (models) that your application operates on.  Then think about the actions that can be performed on these components.  The foursquare API documentation is a good example to study before you start writing your own.  They have a set of high-level objects, such as places, users, and the like.  They also have a set of actions that can be performed on these objects.  Since you know the high-level objects and actions on them in your product, creating an API call structure becomes easier and more understandable.  For example, to add a new place, it would be logical to call a method like / venues / add <br><br>  Document all high-level objects.  Then document the requests and responses to them using these high-level objects instead of simple data types.  Instead of writing ‚ÄúThis call returns three string fields, the first contains id, the second name, and the third description‚Äù write ‚ÄúThis call returns a structure (model) describing the place‚Äù. <br><br><h5>  Documenting request parameters </h5><br>  Let's imagine that you have an API that allows the user to log in using the Facebok token.  Call this method as / login. <br><br><pre> <code class="xml hljs">Request /login Headers Authorization: Token XXXXX User-Agent: MyGreatApp/1.0 Accept: application/json Accept-Encoding: compress, gzip Parameters Encoding type ‚Äì application/x-www-form-urlencoded token ‚Äì ‚ÄúFacebook Auth Token‚Äù (mandatory) profileInfo = ‚Äújson string containing public profile information from Facebook‚Äù (optional)</code> </pre><br>  Where profileinfo is a high-level object.  Since you have already documented the internal structure of this object, such a simple mention is enough.  If your server uses the same Accept, Accept-Encoding and the Encoding type parameter, you can always document them separately, instead of repeating them in all sections. <br><br><h5>  Documenting Response Parameters </h5><br>  Responses to API calls should also be documented based on a high-level object model.  Quoting the same example of foursquare, calling the method / venue / # venueid # returns a data structure (model) describing the location of the event. <br><br>  Sharing ideas, documenting or informing other developers that you will return in response to a request will become easier if you document your API using the structure of objects (models).  The most important result of this chapter is the need to perceive documentation as a contract that you conclude, as a server-side developer and client application developers (iOS / Android / Windows Phone / to be completely). <br><br><h4>  Reasons for creating new and stopping support for old versions of your API </h4><br>  Before the advent of mobile applications, in the era of Web 2.0, creating different versions of the API was not a problem.  Both the client (JavaScript / AJAX front-end) and the server were deployed simultaneously.  Consumers (your customers) have always used the latest version of client software to access the system.  Since you are the only company developing both the client and server parts, you fully control how your API is used and changes in it are always immediately applied to the client side.  Unfortunately, this is not possible with client applications written for different platforms.  You can deploy API version 2, assuming that everything will be fine, but this will lead to inoperability of iOS applications using the old version.  Because there may still be users using such applications despite the fact that you posted an updated version in the App Store.  Some companies have resorted to using push notifications to remind you to update.  The only thing that will lead to this is the loss of such a client.  I saw a lot of iPhones, which had more than 100 applications awaiting updates.  The chances that your will become one of them are very high.  You should always be ready to separate your API into versions and to stop supporting some of them as soon as it is required.  However, maintain each version of your API for at least three months. <br><br><h5>  Split into versions </h5><br>  Deploying your server code to different folders and using different URLs for calls does not mean that you have successfully divided your API into versions. <br>  So <a href="http://example.com/api/v1">example.com/api/v1</a> will be used by version 1.0 of the application, and your freshest and coolest version 2.0 will use <a href="http://example.com/api/v2">example.com/api/v2</a> <br><br>  When you make updates, you almost always make changes to the internal data structures and models.  This includes changes to the database (adding or deleting columns).  For better understanding, let's imagine that your ‚Äúnew Facebook‚Äù has an API call called / feed which returns the Ribbon object.  Today, in version 1, your Ribbon object includes the user's avatar URL (avatarURL), user name (personName), post text (feedEntryText) and creation time (timeStamp) of the post.  Later, in version 2, you introduce a new feature that allows advertisers to place descriptions of their products in the feed.  Now the ‚ÄúRibbon‚Äù object contains, let's say, the new ‚ÄúsourceName‚Äù field, which overlaps the user's name when the ribbon is displayed.  Thus, the application should display ‚ÄúsourceName‚Äù instead of ‚ÄúpersonName‚Äù.  Since the application no longer needs to display ‚ÄúpersonName‚Äù if ‚ÄúsourceName‚Äù is set, you decide not to send ‚ÄúpersonName‚Äù if there is a ‚ÄúsourceName‚Äù.  It all looks good until the old version of your application, version 1, contacts the updated server.  It will display your advertisements from the tape without a title because there is no ‚ÄúpersonName‚Äù.  The ‚Äúliterate‚Äù way to solve this problem is to send both ‚ÄúpersonName‚Äù and ‚ÄúsourceName‚Äù.  But friends, life is not always that simple.  As a developer, you will not be able to track all single changes that have ever been made with each data model in your object.  This is not a very effective way to make changes since in half a year you will almost forget why and how something was added to your code. <br><br>  Returning to web 2.0, this was not a problem at all.  The JavaScript client was immediately modified to support API changes.  However, the installed iOS applications are no longer dependent on you.  Now their update is the user's prerogative. <br><br>  I have an elegant solution for tricky situations of this kind. <br><br><h5>  Paradigm versioning via URL </h5><br>  The first solution is sharing using a URL. <br>  <a href="http://api.example.com/v1/feeds">api.example.com/v1/feeds</a> will be used by version 1 of the iOS application whereas <br>  <a href="http://api.example.com/v2/feeds">api.example.com/v2/feeds</a> will be used by version 2. <br>  Despite the fact that it sounds all good, you cannot continue to create copies of your server code for each change in the format of the returned data.  I recommend using this approach only in case of global changes in the API. <br><br><h5>  Paradigm of versioning through model </h5><br>  Above, I showed how to document your data structures (models).  Treat this documentation as a contract between the developers of the server and client parts.  You should not make changes to the model without changing the version.  This means that in the previous case there should be two models, Feed1 and Feed2. <br><br>  Feed2 has a sourceName field and it returns sourceName instead of personName if sourceName is set.  The behavior of Feed1 remains the same as it was specified in the documentation.  The algorithm of the controller will be something like this: <br><img src="http://habrastorage.org/storage2/8ab/b7f/375/8abb7f375eefb2efdceb9300f1b7e474.jpg"><br>  You should move the class creation logic to a separate class according to the Factory method pattern.  The corresponding controller code should look something like this: <br><br><pre> <code class="cpp hljs">Feed myFeedObject = Feed.createFeedObject(<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>); myFeedObject.populateWithDBObject(FeedDao* feedDaoObject);</code> </pre><br>  Where the decision on the version of the API used will be made by the controller in accordance with the UserAgent field of the request text. <br><br>  <b>Addition:</b> <br>  Instead of using the version number from the UserAgent string, it would be better to use the version number in the Accept header.  Thus, instead of sending <br><br><pre> <code class="xml hljs">Accept: application/json</code> </pre><br>  should be sent <br><br><pre> <code class="xml hljs">Accept: application/myservice.1.0+json</code> </pre><br>  Thus, you have the opportunity to specify the API version for each request to the REST server.  Thanks to the hacker news readers for this tip. <br><br>  The controller uses the Feed factory method to create a valid feed object (tape) based on information from a client request (all requests include a UserAgent field that looks like AppName / 1.0) for the version concerned.  When you develop a server in this way, any change will be easy.  Changes will not violate existing agreements.  Just create new data structures (models), make changes to the factory method to create an instance of a new model for the new version and that's it! <br><br>  With this approach, your version 1 and 2 applications can continue to work with a single server.  Your controller can create version 1 objects for old client applications and version 2 objects for new ones. <br><br><h5>  Termination of support </h5><br>  With the paradigm of separating an API into versions proposed through the model, stopping support for your API becomes much easier.  This is very important in the latter stages when you publish your API.  When you do a global API update, audit all of the factory methods in your models to reflect the changes in your business logic. <br><br>  If, during the release of version 3 of your API, you decide to stop supporting version 1, then all you have to do is to remove the corresponding models and delete the lines that create their instances in your factory method.  Creation of new versions and the termination of support for old will necessarily accompany your project, showing how flexible it is to support key decisions dictated by the business.  A business incapable of sudden changes and turns is doomed.  Typically, the inability to make key changes is due to technical imperfections of the project.  This technique can solve this problem. <br><br><h4>  Caching </h4><br>  Another important thing about performance that needs attention is caching.  If you think that this is a client application task, think carefully.  In part 2 of this article, I will explain how to organize caching using http 1.1 tools. <br><br><h4>  Error handling and internationalizing your API </h4><br>  Bringing to the client the reason for the error in case of its occurrence is no less important than sending the correct data.  I will talk about error handling and internationalization in part 3 of this article.  I will not promise anything, in any case it will take time to write. <br><br>  <b>From the translator:</b> <br>  I myself am not a developer for iOS and I did not develop web services; my level in this area can be described as ‚ÄúI am going to be a beginner‚Äù.  But the topic is interesting to me and I liked the article, so much so that I decided to translate. <br><br>  <a href="http://habrahabr.ru/post/144259/">The second part of</a> </div><p>Source: <a href="https://habr.com/ru/post/144011/">https://habr.com/ru/post/144011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144002/index.html">Skype introduced new subscriptions - unlimited calls to Russia</a></li>
<li><a href="../144003/index.html">The simplest techniques of adaptive layout</a></li>
<li><a href="../144005/index.html">New "gift" in the legislation on PD</a></li>
<li><a href="../144006/index.html">As I pulled the map back into the table</a></li>
<li><a href="../144008/index.html">jParser: analyzing binary files just works</a></li>
<li><a href="../144012/index.html">9facts: debriefing</a></li>
<li><a href="../144013/index.html">Three small useful utilities</a></li>
<li><a href="../144014/index.html">Writing Linux security module</a></li>
<li><a href="../144015/index.html">HP Pavilion dv7-7006er laptop video review</a></li>
<li><a href="../144016/index.html">Unity3D 3.x Terrain Bump Specular Shader</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>