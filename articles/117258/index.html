<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[Translation] Now Twitter search is 3 times faster</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have always been interested in Ruby-on-Rails (RoR) and Twitter as a bright representative of the platform on this framework. On April 6 of this year...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[Translation] Now Twitter search is 3 times faster</h1><div class="post__text post__text-html js-mediator-article">  I have always been interested in Ruby-on-Rails (RoR) and Twitter as a bright representative of the platform on this framework.  On April 6 of this year, a blog entry on the Twitter team blog appeared on a complete change of the search platform from RoR to Java.  Under the cut translation of how it was. <br><br><a name="habracut"></a><br><br>  ‚ÄúIn the spring of 2010, the Twitter search team started rewriting our search engine in order to serve the ever-growing traffic, reduce latency for the end user and increase the availability of our service, to gain the ability to quickly develop new search capabilities.  As part of the work, we launched a new <a href="http://engineering.twitter.com/2010/10/twitters-new-search-architecture.html">real-time search engine</a> , changing our back-end from MySQL to the <a href="http://lucene.apache.org/java/docs/index.html">Lucene</a> version.  Last week, we launched a replacement for our Ruby-on-Rails front-end: Java server, which we call Blender.  We are pleased to announce that this change has reduced the search time by 3 times and will give us the opportunity to consistently increase the search functionality in the following months. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Performance boost </h4><br>  Twitter search is one of the world's busiest search engines, serving more than one billion search queries per day.  This week, before we deployed Blender, <a href="http://twitter.com/">#tsunami</a> in Japan contributed to a significant increase in search queries and associated search delays.  After launching Blender, our 95% latency has decreased 3 times, from 800ms to 250ms and the CPU load on our front-end servers has been halved.  Now we have the potential to serve 10 times more requests per machine.  This means that we can maintain the same number of requests with a smaller number of servers, reducing the cost of our front-end service by an order of magnitude. <br><img src="https://habrastorage.org/getpro/habr/post_images/1df/2d1/5fd/1df2d15fd54c6a394f70ef12dce85fbc.jpg" alt="image"><br>  <i>95% delay in the search API before and after starting Blender.</i> <br><br><h4>  Improved Twitter Search Architecture </h4><br>  To better understand performance gains, you must first understand the flaws of our former Ruby-on-Rails front-end servers.  They ran a fixed number of single-threaded workflows, each of which did the following: <br><ul><li>  Parsed the search query; </li><li>  Synchronously requested search servers; </li><li>  Aggregated and shaped the results. </li></ul><br>  We have long known that the synchronous request processing model uses our CPUs inefficiently.  For a long time, we also accumulated significant technical debt in our main Ruby code, making it difficult to add functionality and improve the reliability of our search engine.  Blender addresses these issues by: <br><ol><li>  Creating a fully asynchronous aggregation service.  No threads waiting for network I / O to complete; </li><li>  Aggregating results from back-end services, such as real-time service, top tweet service (tweet) and geographic indices service; </li><li>  Accurately resolving dependencies between services.  Workflows automatically handle transitive dependencies between back-end services. </li></ol><br>  The following diagram shows the architecture of the Twitter search engine.  Requests from a website, API, or external clients on Twitter are sent to Blender via a hardware load balancer.  Blender parses the search query and sends it to the back-end services using workflows to handle dependencies between services.  Finally, the results from the services are combined and formed in the appropriate language of the client. <br><img src="https://habrastorage.org/getpro/habr/post_images/17f/943/ae2/17f943ae228fd0a761f5f203da506fb6.jpg" alt="image"><br>  <i>Twitter Search Architecture with Blender.</i> <br><br><h4>  Blender Review </h4><br>  Blender is a Thrift and HTTP service built on <a href="http://www.jboss.org/netty">Netty</a> , a widely scalable NIO client-server library written in Java, which allows you to develop for various servers and clients quickly and easily.  We chose Netty from several of its competitors, such as Mina and Jetty, because it has a more transparent API, better documentation and, most importantly, because several other Twitter projects use this framework.  In order for Netty to work with Thrift, we wrote a simple Thrift codec that decodes Thrift incoming requests from the Netty channel buffer when it is read from a socket and encodes Thrift outgoing responses when it is written to a socket.  Netty introduces a key abstraction, called a Channel, to encapsulate a connection to a network socket, which provides an interface for performing a variety of I / O operations, such as read, write, connect, and bind.  All channel I / O operations are asynchronous in nature.  This means that any I / O call is returned immediately with a ChannelFuture instance that reports when the requested I / O operation is successful, unsuccessful, or canceled.  When the Netty server accepts a new connection, it creates a new channel pipeline to handle the connection.  A channel pipeline is a sequence of channel handlers that implement the business logic necessary to process a request.  In the next section, we show how Blender transports these pipelines for the request processing workflows. <br><br><h4>  Workflow library </h4><br><br>  In Blender, a workflow is a set of back-end services with dependencies between them that must be processed to service an incoming request.  Blender automatically determines the dependencies between them, for example, if service A depends on service B, A is requested first and its results are transferred to B. This is convenient for representing workflows in the form of <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graphs</a> (see figure below). <br><img src="https://habrastorage.org/getpro/habr/post_images/11e/132/fc5/11e132fc57b4074e4457771129e96c77.jpg" alt="image"><br>  <i>Sample Blender workflow with 6 back-end services.</i> <br><br>  In the example of the workflow, we have 6 services {s1, s2, s3, s4, s5, s6} with dependencies between them.  The straight line from s3 to s1 means that s3 must be called before the call to s1, because s1 needs s3 results.  For such a working project, the Blender library performs <a href="http://en.wikipedia.org/wiki/Topological_sorting">topological sorting</a> on the <a href="http%253A%252F%252Fen.wikipedia.org%252Fwiki%252FDirected_acyclic_graph%26ei%3DzACjTd_YN47rObCruTU%26usg%3DAFQjCNGqVeqL6Rk4g1yzkda9N-5Wx20w0w%26sig2%3DveB6-Hfj0j22EvsxWESwPQ">DAG</a> to determine the final order of the services, which is also the order in which they are called.  The execution order for the workflow above will be {(s3, s4), (s1, s5, s6), (s2)}.  This means that s3 and s4 can be called in parallel in the first step;  when they return the results, s1, s5, and s6 are also called in parallel in the next step;  before the final call s2.  After Blender has determined the order of execution, it is displayed on the Netty pipeline.  This pipeline is a sequence of handlers that need to send a request for processing. <br><br><h4>  Multiplexing incoming requests </h4><br>  Since the workflows are mapped to the Netty pipelines in Blender, we needed to send incoming client requests to the appropriate pipeline.  For this, we built a proxy layer, which multiplexes and sends client requests according to the following rules: <br><ul><li>  When a remote Thrift client opens a permanent connection to Blender, the proxy layer creates a map for local clients, one for each of the local servers serving the workflows.  Notice that all of these servers are started in the Blender process of the JVM environment and are created when the Blender process starts; </li><li>  When a request arrives on a socket, the proxy layer reads it, determines which workflow has been requested and forwards it to the appropriate workflow server; </li><li>  Similarly, when a response comes from a local server serving the workflow, the proxy reads it and writes the answer to the remote client. </li></ul><br>  We used the event-driven Netty model to perform all the listed tasks asynchronously, so there are no more threads waiting for I / O. <br><br><h4>  Dispatch back-end requests </h4><br>  As soon as a search request arrives at the workflow pipeline, it passes through a sequence of service handlers in the sequence defined by the workflow.  Each service handler creates a corresponding back-end request for this search request and sends it to a remote server.  For example, a real-time service handler creates a real-time request and sends it asynchronously to one or more real-time indices.  We use the <a href="https://github.com/twitter/commons">twitter commons</a> library (recently become open source!) To provide connection pool management, load balancing, and dead host definitions.  The I / O stream that processes the search request is released when all back-end responses are processed.  The timer thread checks every few milliseconds to see if any of the back-end responses are returned from remote servers and sets a flag indicating if the request is successful, timed out, or unsuccessful.  We maintain one object throughout the search query life cycle to manage this data type.  Successful responses are aggregated and sent to the next step for processing by service handlers in the workflow pipeline.  When all responses from the first step arrive, the second step of the asynchronous requests is made.  This process is repeated until we complete the workflow or the waiting time does not exceed the allowable one.  As you can see, during the execution of the workflow, no thread is idle waiting for I / O.  This allows us to efficiently use the CPU on our machines with Blender and handle a large number of concurrent requests.  We also save on delays, since we execute most requests for back-end services in parallel. <br><br><h4>  Deploying Blender and Future Work </h4><br>  In order to ensure the high quality of the service while we integrate Blender into our system, we use the old Ruby-on-Rails front-end server as a proxy to redirect thrift requests for our Blender cluster.  Using old front-end servers as a proxy allows us to ensure the integrity of user perception, making significant changes in the underlying technology.  In the next phase of our deployment, we will completely remove Ruby-on-Rails from our search stack, connecting users directly to Blender and potentially reducing delays even more. ‚Äù </div><p>Source: <a href="https://habr.com/ru/post/117258/">https://habr.com/ru/post/117258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../117250/index.html">Why do subscribers leave provider?</a></li>
<li><a href="../117252/index.html">Copini Integration with Twitter and Facebook</a></li>
<li><a href="../117255/index.html">Go!</a></li>
<li><a href="../117256/index.html">New components for Proliant</a></li>
<li><a href="../117257/index.html">ICQ protocol opened for alternative clients</a></li>
<li><a href="../117259/index.html">505 million rubles for the redesign of the site about spending to overcome the crisis</a></li>
<li><a href="../117260/index.html">Testing Cloud Provider Drives</a></li>
<li><a href="../117261/index.html">LED Continuous Integration Server Status Monitor</a></li>
<li><a href="../117262/index.html">The story of how to get from the Mac to the RMM server module, but not without Windows</a></li>
<li><a href="../117264/index.html">Creating a multilingual installer for Windows using WiX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>