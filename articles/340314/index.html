<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Universal adapter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 


 This article is the author's translation from English of its own article called God Adapter . You can also watch video presentations from...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Universal adapter</h1><div class="post__text post__text-html js-mediator-article"><h2 id="predislovie">  Foreword </h2><br><p>  This article is the author's translation from English of its own article called <a href="http://gridem.blogspot.com/2015/11/replicated-object-part-2-god-adapter.html">God Adapter</a> .  You can also watch <a href="https://www.youtube.com/watch%3Fv%3DmnH_-qFU5E0">video presentations from the C ++ Russia conference</a> . </p><br><h2 id="1-annotaciya">  1 Abstract </h2><br><p>  The article presents a special adapter that allows you to wrap any object into another with the addition of the necessary functionality.  Adapted objects have the same interface, so they are completely transparent in terms of use.  A common concept will be introduced consistently using simple, but powerful and interesting examples. </p><br><h2 id="2-vvedenie">  2 Introduction </h2><br><p>  <strong>WARNING</strong> .  Almost all the methods mentioned in the article contain dirty hacks and abnormal use of the C ++ language.  So, if you are not tolerant of such perversions, please do not read this article. </p><br><p>  The term <em>universal adapter</em> comes from being able to universally add the necessary behavior for any object. </p><br><a name="habracut"></a><br><h2 id="3-postanovka-zadachi">  3 Task setting </h2><br><p> A long time ago, I introduced the <a href="https://habrahabr.ru/post/184436/">concept of a smart mutex</a> to simplify access to shared data.  The idea was simple: bind the mutex to the data and automatically call <code>lock</code> and <code>unlock</code> every time you access the data.  The code looks like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ val_ = v; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val_ = <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-comment"><span class="hljs-comment">//     SmartMutex&lt;Data&gt; d; //  ,      d-&gt;set(4); //   std::cout &lt;&lt; d-&gt;get() &lt;&lt; std::endl;</span></span></code> </pre> <br><p>  But there are several problems with this approach. </p><br><h3 id="31-vremya-blokirovki">  3.1 Blocking time </h3><br><p>  The lock is held for the duration of the current expression.  Consider the following line: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; d-&gt;get() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Unlocking is called after the completion of the entire expression, including output to <code>std::cout</code> .  This is an unnecessary waste of time, which significantly increases the waiting time when locking is taken. </p><br><h3 id="32-vozmozhnost-vzaimnoy-blokirovki">  3.2 Possibility of interlocking </h3><br><p>  As a consequence of the first problem, there is the possibility of interlocking due to the implicit locking mechanism and the long blocking time when the current expression is executed.  Consider the following code snippet: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SmartMutex&lt;Data&gt;&amp; x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SmartMutex&lt;Data&gt;&amp; y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x-&gt;get() + y-&gt;get(); }</code> </pre> <br><p>  It is not at all obvious that the function potentially contains a deadlock.  This is due to the fact that the method <code>-&gt;get()</code> can be called in any order for different pairs of instances <code>x</code> and <code>y</code> . </p><br><p>  Thus, it would be better to avoid an increase in the time taken to take the lock and to prevent the interlocks mentioned above. </p><br><h2 id="4-reshenie">  4 Solution </h2><br><p>  The idea is quite simple: we need to implement the functionality of the proxy object inside the call itself.  And in order to simplify interaction with our object, let's replace <code>-&gt;</code> with <code>.</code>  . </p><br><p>  Simply put, we need to convert the <code>Data</code> object to another object: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Lock = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataLocked</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Lock _{mutex_}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_.get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ Lock _{mutex_}; data_.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(v); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex mutex_; Data data_; };</code> </pre> <br><p>  In this case, we control the operations of getting and releasing the mutex inside the methods themselves.  This prevents the problems mentioned earlier. </p><br><p>  But such a record is inconvenient for implementation, because the basic idea of ‚Äã‚Äãa smart mutex is to avoid additional code.  The preferred way is to take advantage of both approaches: less code and fewer problems at the same time.  Therefore, it is necessary to generalize this solution and distribute it for wider usage scenarios. </p><br><h3 id="41-obobschennyy-adapter">  4.1 Generalized adapter </h3><br><p>  We need to somehow adapt our old <code>Data</code> implementation without <code>mutex</code> to an implementation containing <code>mutex</code> , which should look similar to the <code>DataLocked</code> class.  To do this, wrap the method call for further transformation of behavior: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataAdapter</span></span></span><span class="hljs-class"> :</span></span> T_base { <span class="hljs-comment"><span class="hljs-comment">//      set void set(int v) { T_base::call([v](Data&amp; data) { data.set(v); }); } };</span></span></code> </pre> <br><p>  Here we postpone the call to <code>data.set(v)</code> and pass it to <code>T_base::call(lambda)</code> .  A possible implementation of <code>T_base</code> could be: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutexBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F f)</span></span></span><span class="hljs-function"> </span></span>{ Lock _{mutex_}; f(data_); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Data data_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex mutex_; };</code> </pre> <br><p>  As you can see, we have divided the monolithic implementation of the <code>DataLocked</code> class into two classes: <code>DataAdapter&lt;T_base&gt;</code> and <code>MutexBase</code> as one of the possible base classes for the created adapter.  But the actual implementation is very close: we hold the mutex during the call to <code>Data::set(v)</code> . </p><br><h3 id="42-bolshe-obobscheniya">  4.2 More generalization </h3><br><p>  Let's summarize our implementation.  Our <code>MutexBase</code> implementation only works for <code>Data</code> .  Improve this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_locker&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseLocker</span></span></span><span class="hljs-class"> :</span></span> T_base { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Lock = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;T_locker&gt;; Lock _{lock_}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T_base&amp;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: T_locker lock_; };</code> </pre> <br><p>  Here are a few generalizations: </p><br><ol><li>  I do not use a specific implementation of the mutex.  You can use either <code>std::mutex</code> or any object that implements <a href="http://en.cppreference.com/w/cpp/concept/BasicLockable"><code> BasicLockable</code></a> . </li><li>  <code>T_base</code> is an instance of an object with the same interface.  This could be <code>Data</code> or even an already adapted <code>Data</code> object, such as, for example, <code>DataLocked</code> . </li></ol><br><p>  Thus, we can define: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DataLocked = DataAdapter&lt;BaseLocker&lt;Data, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt;&gt;;</code> </pre> <br><h3 id="43-nuzhno-bolshe-obobscheniya">  4.3 Need more generalization </h3><br><p>  When using generalizations it is impossible to stop.  Sometimes I would like to convert input parameters.  For this, I will change the adapter: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataAdapter</span></span></span><span class="hljs-class"> :</span></span> T_base { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ T_base::call([](Data&amp; data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v) { data.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(v); }, v); } };</code> </pre> <br><p>  And the <code>BaseLocker</code> implementation <code>BaseLocker</code> converted to: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_locker&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseLocker</span></span></span><span class="hljs-class"> :</span></span> T_base { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... V&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F f, V&amp;&amp;... v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Lock = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;T_locker&gt;; Lock _{lock_}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T_base&amp;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;V&gt;(v)...); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: T_locker lock_; };</code> </pre> <br><h2 id="44-universalnyy-adapter">  4.4 Universal Adapter </h2><br><p>  Finally, let's reduce the size of the template code associated with the adapter.  Templates end and advanced macros come into play with iterators: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DECL_FN_ADAPTER(D_name) \ template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename... V&gt; \ auto D_name(V&amp;&amp;... v) \ { \ return T_base::call([](auto&amp; t, auto&amp;&amp;... x) { \ return t.D_name(std::forward&lt;decltype(x)&gt;(x)...); \ }, std::forward&lt;V&gt;(v)...); \ }</span></span></span></span></code> </pre> <br><p>  <code>DECL_FN_ADAPTER</code> allows <code>DECL_FN_ADAPTER</code> to wrap any method with the name <code>D_name</code> .  Now it only remains to go through all the methods of the object and wrap them: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DECL_FN_ADAPTER_ITERATION(D_r, D_data, D_elem) \ DECL_FN_ADAPTER(D_elem) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DECL_ADAPTER(D_type, ...) \ template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;typename T_base&gt; \ struct Adapter&lt;D_type, T_base&gt; : T_base \ { \ BOOST_PP_LIST_FOR_EACH(DECL_FN_ADAPTER_ITERATION, , \ BOOST_PP_TUPLE_TO_LIST((__VA_ARGS__))) \ };</span></span></span></span></code> </pre> <br><p>  Now we can adapt our <code>Data</code> using only one line: </p><br><pre> <code class="cpp hljs">DECL_ADAPTER(Data, get, <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      template&lt;typename T, typename T_locker = std::mutex, typename T_base = T&gt; using AdaptedLocked = Adapter&lt;T, BaseLocker&lt;T_base, T_locker&gt;&gt;; using DataLocked = AdaptedLocked&lt;Data&gt;;</span></span></code> </pre> <br><p>  And that's it! </p><br><h2 id="5-primery">  5 Examples </h2><br><p>  We looked at a mutex-based adapter.  Consider other interesting adapters. </p><br><h3 id="51-adapter-dlya-podscheta-ssylok">  5.1 Adapter for reference counting </h3><br><p>  Sometimes for some reason we need to use <code>shared_ptr</code> for our objects.  And it would be better to hide this behavior from the user: instead of using <code>operator-&gt;</code> I would just like to use <code>operator.</code>  .  Well, or at least simple <code>.</code>  .  The implementation is very simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseShared</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... V&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F f, V&amp;&amp;... v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(*shared_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;V&gt;(v)...); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt; shared_; }; <span class="hljs-comment"><span class="hljs-comment">//     BaseShared  template&lt;typename T, typename T_base = T&gt; using AdaptedShared = Adapter&lt;T, BaseShared&lt;T_base&gt;&gt;;</span></span></code> </pre> <br><p>  Application: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DataRefCounted = AdaptedShared&lt;Data&gt;; DataRefCounted data; data.<span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><h3 id="52-kombinaciya-adapterov">  5.2.  Adapter combination. </h3><br><p>  Sometimes there is a great idea to fumble data between threads.  The general scheme is to combine <code>shared_ptr</code> with <code>mutex</code> .  <code>shared_ptr</code> solves problems with the lifetime of an object, and <code>mutex</code> used to prevent a race condition. </p><br><p>  Since each adapted object has the same interface as the original one, we can simply combine several adapters: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_locker = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base = T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AdaptedSharedLocked = AdaptedShared&lt;T, AdaptedLocked&lt;T, T_locker, T_base&gt;&gt;;</code> </pre> <br><p>  With such use: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> DataRefCountedWithMutex = AdaptedSharedLocked&lt;Data&gt;; DataRefCountedWithMutex data; <span class="hljs-comment"><span class="hljs-comment">//           //    int v = data.get();</span></span></code> </pre> <br><h3 id="53-asinhronnyy-primer-ot-obratnyh-vyzovov-callback-k-buduschemu-future">  5.3 Asynchronous example: from callbacks to the future </h3><br><p>  Let's step into the future.  For example, we have the following interface: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncCb</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)&gt; cb)</span></span></span></span>; };</code> </pre> <br><p>  But we would like to use the asynchronous interface of the future: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncFuture</span></span></span><span class="hljs-class"> {</span></span> Future&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; async(); };</code> </pre> <br><p>  Where <code>Future</code> has the following interface: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Future</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Promise</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-function">Future </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">future</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; v)</span></span></span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">then</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp;)&gt;)</span></span></span></span>; };</code> </pre> <br><p>  Matching adapter: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_future&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseCallback2Future</span></span></span><span class="hljs-class"> :</span></span> T_base { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... V&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F f, V&amp;&amp;... v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_future::Promise promise; f(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T_base&amp;&gt;(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;V&gt;(v)..., [promise](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; val) <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { promise.put(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(val)); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise.future(); } };</code> </pre> <br><p>  Application: </p><br><pre> <code class="cpp hljs">DECL_ADAPTER(AsyncCb, async) <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AsyncFuture = AdaptedCallback&lt;AsyncCb, Future&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;; AsyncFuture af; af.async().then([](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v) { <span class="hljs-comment"><span class="hljs-comment">//    });</span></span></code> </pre> <br><h3 id="54-asinhronnyy-primer-iz-buduschego-k-obratnomu-vyzovu">  5.4 Asynchronous example: from the future to the callback </h3><br><p>  Since  this leads us into the past, then let it be a domestic task. </p><br><h3 id="55-lenivyy-adapter">  5.5 Lazy adapter </h3><br><p>  The developers are lazy.  Let's adapt any object for compatibility with developers. </p><br><p>  In this context, laziness means creating an object on demand.  Consider the following example: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Obj</span></span></span><span class="hljs-class"> {</span></span> Obj(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }; Obj obj; <span class="hljs-comment"><span class="hljs-comment">// : Obj::Obj obj.action(); // : Obj::action obj.action(); // : Obj::action AdaptedLazy&lt;Obj&gt; obj; //   ! obj.action(); // : Obj::Obj  Obj::action obj.action(); // : Obj::action</span></span></code> </pre> <br><p>  Those.  the idea is to delay the creation of an object to the last.  If the user decides to use an object, we must create it and call the appropriate method.  The base class implementation can be like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseLazy</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... V&gt; BaseLazy(V&amp;&amp;... v) { <span class="hljs-comment"><span class="hljs-comment">//    state_ = [v...]() mutable { return T{std::move(v)...}; }; } protected: using Creator = std::function&lt;T()&gt;; template&lt;typename F, typename... V&gt; auto call(F f, V&amp;&amp;... v) { auto* t = boost::get&lt;T&gt;(&amp;state_); if (t == nullptr) { //       state_ = std::get&lt;Creator&gt;(state_)(); t = std::get&lt;T&gt;(&amp;state_); } return f(*t, std::forward&lt;V&gt;(v)...); } private: // variant     //    :     std::variant&lt;Creator, T&gt; state_; }; template&lt;typename T, typename T_base = T&gt; using AdaptedLazy = Adapter&lt;T, BaseLazy&lt;T_base&gt;&gt;;</span></span></code> </pre> <br><p>  And now we can create a heavy lazy object and initialize it only when necessary.  At the same time, it is completely transparent to the user. </p><br><h2 id="6-nakladnye-rashody">  6 Overhead </h2><br><p>  Let's look at the performance of the adapter.  The fact is that we use lambdas and transfer them to other objects.  Thus, it would be extremely interesting to know the overhead of such adapters. </p><br><p>  To do this, consider a simple example: we wrap the object call using the object itself, i.e.  create an identical adapter and try to measure the overhead for such a case.  Instead of making direct measurements of performance, let's just look at the generated assembler code for different compilers. </p><br><p>  First, let's create a simple version of our adapter to work only with the <code>on</code> methods: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;utility&gt; template&lt;typename T, typename T_base&gt; struct Adapter : T_base { template&lt;typename... V&gt; auto on(V&amp;&amp;... v) { return T_base::call([](auto&amp; t, auto&amp;&amp;... x) { return t.on(std::forward&lt;decltype(x)&gt;(x)...); }, std::forward&lt;V&gt;(v)...); } };</span></span></span></span></code> </pre> <br><p>  <code>BaseValue</code> is our identical base class for calling methods directly from the same type <code>T</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseValue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... V&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(F f, V&amp;&amp;... v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(t, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;V&gt;(v)...); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: T t; };</code> </pre> <br><p>  And here is our test class: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v + <span class="hljs-number"><span class="hljs-number">1</span></span>; } }; <span class="hljs-comment"><span class="hljs-comment">//      int f1(int v) { X x; return x.on(v); } //       int f2(int v) { Adapter&lt;X, BaseValue&lt;X&gt;&gt; x; return x.on(v); }</span></span></code> </pre> <br><p>  Below you can find the results obtained in the <a href="https://gcc.godbolt.org/">online compiler</a> : </p><br><p>  <strong>GCC 4.9.2</strong> </p><br><pre> <code class="hljs perl">f1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>): leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax ret f2(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>): leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax ret</code> </pre> <br><p>  <strong>Clang 3.5.1</strong> </p><br><pre> <code class="hljs mel">f1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>): # @f1(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax retq f2(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>): # @f2(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax retq</code> </pre> <br><p>  As you can see, there is no difference between <code>f1</code> and <code>f2</code> , which means that compilers can optimize and completely eliminate the overhead associated with creating and transmitting a lambda object. </p><br><h2 id="7-zaklyuchenie">  7 Conclusion </h2><br><p>  The article presents an adapter that allows you to convert an object to another object with additional functionality that leaves the interface unchanged without the overhead of conversion and call.  Classes of the base adapter are universal transformers that can be applied to any object.  They are used to improve and further extend the functionality of the adapter.  Different combinations of base classes make it easy to create very complex objects without additional effort. </p><br><p>  This powerful and entertaining technique will be used and expanded in subsequent articles. </p><br><h2 id="poleznye-ssylki">  useful links </h2><br><p>  [1] <a href="https://github.com/gridem/GodAdapter">github.com/gridem/GodAdapter</a> <br>  [2] <a href="https://bitbucket.org/gridem/godadapter">bitbucket.org/gridem/godadapter</a> <br>  [3] <a href="http://gridem.blogspot.com/2015/11/replicated-object-part-2-god-adapter.html">Blog: God Adapter</a> <br>  [4] <a href="http://www.cpp-russia.ru/talks/grigoriy-demchenko">C ++ Russia Report: Universal Adapter</a> <br>  [5] <a href="https://www.youtube.com/watch%3Fv%3DmnH_-qFU5E0">Video C ++ Russia: Universal Adapter</a> <br>  [6] <a href="https://habrahabr.ru/post/184436/">Habrahabr: Useful multithreading idioms C ++</a> <br>  [7] <a href="https://gcc.godbolt.org/">godbolt online compiler</a> <br></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/340314/">https://habr.com/ru/post/340314/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340298/index.html">Company growth: from five to three hundred</a></li>
<li><a href="../340302/index.html">Parsing sites: from the point of view of the law, one of the most useful IT tools in the world (and in Russia) looks like?</a></li>
<li><a href="../340304/index.html">Why robots have to format the code for us</a></li>
<li><a href="../340306/index.html">Windows 10 Fall Creators Update and the Windows subsystem for Linux</a></li>
<li><a href="../340312/index.html">Use PowerShell for IT security. Part V: Security Platform Optimization Using Scripts</a></li>
<li><a href="../340316/index.html">Are you already using R in business?</a></li>
<li><a href="../340318/index.html">Behind the scene of TOP-1 supercomputer</a></li>
<li><a href="../340320/index.html">Free YouTube broadcast DevOps conference DevOops 2017</a></li>
<li><a href="../340322/index.html">How I passed the practice in the university and set up Nextcloud</a></li>
<li><a href="../340324/index.html">Invitation to Meetup on computer vision in Avito, October 28</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>