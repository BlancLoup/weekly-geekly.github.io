<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to save resources in the browser and not break the web. Yandex report</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despite the increase in device performance, the web is becoming increasingly demanding on memory and processor. Proper rendering and clever tab alloca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to save resources in the browser and not break the web. Yandex report</h1><div class="post__text post__text-html js-mediator-article">  Despite the increase in device performance, the web is becoming increasingly demanding on memory and processor.  Proper rendering and clever tab allocation is an important part of solving this problem.  Konstantin Kramlich <a href="https://habr.com/ru/users/purplepowder/" class="user_link">PurplePowder</a> devoted his speech at the <a href="https://events.yandex.ru/events/meetings/yalovefrontend/">conference</a> ‚ÄúI Frontend‚Äù to algorithms that improve performance and save resources in both the Chromium project and Yandex <a href="https://habr.com/ru/users/purplepowder/" class="user_link">Browser</a> . <br><br>  Some of them - for example, Hibernate technology - we have already analyzed in a <a href="https://habr.com/ru/company/yandex/blog/423507/">separate post</a> .  The Bones report covers the task more broadly: not only in terms of tab switching, but also taking into account content rendering methods, tiles and page layers. <br><br>  Toward the end, web interface developers can learn how to identify and solve problems with the performance of sites. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/6OLVN_gprow" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - My name is Kostya, I am the head of the internal components development team in the Yandex.Browser team.  In the Browser, I was a little more than five years old, doing different things: from all decoding in a browser, all HTML5 videos, to rendering, rendering, and other similar processes. <br><br><a name="habracut"></a>  For the last one and a half or two years I have been involved in projects related to saving resources in the browser: CPU, memory, and battery. <br><br>  You will say - Kostya, in the courtyard of 2019, whence problems with resources?  You can buy any device you want with any resources.  But if we turn to the open statistics of Mozilla, we see that half of the users have 4 GB of memory or less.  And many users who have one or two physical cores, they make up a considerable share of your audience.  In this world we live. <br><br><img src="https://habrastorage.org/webt/vr/cx/q0/vrcxq0duik8iaocs9q0v7xbkcqs.jpeg"><br><br>  How many of you often see this tab?  This is exactly what happens with ordinary users who have little RAM and old computers. <br><br><img src="https://habrastorage.org/webt/kd/kq/db/kdkqdbilt2lzsmz5q5p5xgizgci.jpeg"><br><br>  What to do?  The problem is not a secret for anyone; they started to actively struggle with it three years ago.  Since then, the nuts are gradually tightened in different ways.  I'll show you an example that went around the Stack Overflow around 2016.  There is a fairly simple snippet.  This piece simply updates the title and sets the time that has passed since the last launch of this function.  What should be the ideal?  Every 100 ms in the title should be written + -100.  If we get lucky. <br><br><img src="https://habrastorage.org/webt/eh/fs/3h/ehfs3hfvws_8dd1t_fxe29qgdui.jpeg"><br><br>  But what if we open and do like this?  Did someone rush on this?  The question went to Stack Overflow: what the hell do Cookie Clicker stop working in my background tabs?  It was one of the first Chromium initiatives to reduce CPU consumption in the browser.  The idea was that if the user does not use the tab now, it means that he doesn‚Äôt need it now - let's suppress JS on it. <br><br>  The browser tries to maintain the CPU load on this tab at about 1% - it starts to pause all timers, perform JS, etc. This is one of the first steps into a brighter future. <br><br><img src="https://habrastorage.org/webt/qf/vu/_c/qfvu_cyufv3gab9rsell45yv-6g.jpeg"><br><br>  After some time in the browser, you get the situation that the background tabs stop working altogether.  This is the very bright future of which I speak.  According to the plans of Chromium, which they voiced on the last BlinkOn, in 2020 they plan to do this: give the tab to load and if it is in the background, it will not do anything.  You should always be ready for this. <br><br><img src="https://habrastorage.org/webt/u2/_i/gx/u2_igx67m7vxehtknn_-juntdjs.jpeg"><br><br>  In Yandex. Browser, we also attended to such a problem, but decided it was less categorical and did not break the entire web.  We created a power saving mode, which turns off decoding on the processor and leaves only decoding on the video card, and also lowers the FPS and disables some animations that are not needed right now and instead of which the user should save the battery.  It gave us about an hour of extra battery life.  Check can any, ixbt, for example, <a href="https://www.ixbt.com/portopc/battery-life-browsers-test-part-1.html">checked</a> . <br><br><img src="https://habrastorage.org/webt/vi/jx/kb/vijxkbmraau6ziqjhlswbz_u-t4.jpeg"><br><br>  I think some will say: Kostya, you ‚Äúbroke‚Äù the web, helped some users, but did not invent anything smarter.  Add hardcore!  How do browsers paint pages? <br><br><img src="https://habrastorage.org/webt/u4/2j/hy/u42jhyxml4ljdmmd6iu69azgl4g.jpeg"><br><br>  The concept of layers, in a nutshell, is when the browser tries to split the page into layers and draw them separately.  This is done so that some animations are executed and do not force something that is static to be redrawn.  The browser does this on different heuristics.  For example, it tries to select a video element in a separate layer, which, obviously, is quickly and often redrawn.  And if it is shown somewhere, then you do not need to redraw everything under it. <br><br>  In addition, each layer is divided into such tiles - rectangles 256 by 256. In the inspector you can see something like this.  There is a frame that breaks into a bunch of tiles. <br><br><img src="https://habrastorage.org/webt/li/g7/ft/lig7ftmhfrgn3r_rlppouwefs8w.jpeg"><br><br><img src="https://habrastorage.org/webt/ip/1e/ud/ip1eudzb0uatttxq7-ydfb-aqe0.jpeg"><br><br>  What is it and why is it needed?  First of all - to prioritize rendering.  If we have a huge sausage on which we all draw, then why do we need all this to draw, if now the user sees only what he has in ViewPort now? <br><br><img src="https://habrastorage.org/webt/4q/nf/5o/4qnf5oxbb4j3ta9jfxca9urof3c.jpeg"><br><br>  With this approach, we first draw only what the user sees right now in the ViewPort, then one tile around, then in the direction of the scroll.  If the user scrolls down - draw down, if up - up.  Everything else will be drawn only if we have a quota for these tiles and we can draw them, after which the user will someday see them.  And maybe never. <br><br><img src="https://habrastorage.org/webt/vt/vd/uw/vtvduwiv5swz_ogt7vkpwr8_rjc.jpeg"><br><br>  It also helps a lot with disabilities.  Suppose the user opens the page, selects a piece, and we do not need to redraw everything.  We can leave most of the previous rendering.  Six tiles will be redrawn here, and everything will be fine. <br><br><img src="https://habrastorage.org/webt/5z/4p/uw/5z4puwbbmkpqcdqbip5yh1lstew.jpeg"><br><br>  Just at this level several very successful optimizations were made.  For example, Chromium made such optimization around 2017. <br><br><img src="https://habrastorage.org/webt/vc/lk/gy/vclkgyedfjzyc5wreb-q4t52pv0.jpeg"><br><br>  If we only have a small rendering, we only do it.  Here the cursor blinks, and we redraw only the cursor area, but not the entire area of ‚Äã‚Äãthis tile.  We very much save the CPU, so as not to redraw everything. <br><br><img src="https://habrastorage.org/webt/ax/-a/cv/ax-acv5ypcljlc7jkheipeut6ek.jpeg"><br><br>  It also helps save memory.  What is the problem here?  Whole white rectangles.  Imagine that this would be a 256 by 256 texture, four bytes per pixel.  Although it would seem, this area can be encoded with only five numbers: coordinates, width, height and color. <br><br><img src="https://habrastorage.org/webt/ho/kx/kt/hokxktfgpxja01guodvgtxdhv6q.jpeg"><br><br>  Monochrome areas optimization was done in Chromium.  If the browser understands that there are no drawings in this rectangle, that it is completely monochromatic, not transparent and still meets some conditions, then we simply say to the video card - draw a white rectangle, do not select the whole texture. <br><br>  What else can you optimize?  If you look at the remaining tiles, they contain a bit of content and a huge white area.  We, in Yandex. Browser, thought about it and made a mechanism that was called adaptive tiling. <br><br><img src="https://habrastorage.org/webt/xr/vc/9j/xrvc9j8bqm5fpslcp1jbkvjzqpy.jpeg"><br><br>  There is one small rectangle, tile.  There is some content in the middle of the tile.  We select it and - only for it - texture.  Everything else is also divided into several areas, about which we speak to the video card: just draw with white color of this size. <br><br><img src="https://habrastorage.org/webt/jh/ow/c7/jhowc7oh1nxm6-ofebqgzznnaya.jpeg"><br><br>  The page also starts saving everything that is highlighted in red.  On more complex pages it looks something like this. <br><br><img src="https://habrastorage.org/webt/of/pu/lz/ofpulzw2yanibpfx7vrweogcsr8.jpeg"><br><br>  It is important to understand that there are still a bunch of layers and each layer is drawn in this way.  On each layer, you can save some amount of memory.  This approach allowed us to save about 40% of video memory on average for all users. <br><br>  More hardcore!  Here, a little memory saved, then "broke" the web - why not "break" the web next? <br><br>  In Chromium there is something like a policy: if the user does not use background tabs, if he leaves them, it means that he does not need them.  If we are now without memory and the browser is going to fall now, then let's take the oldest tab that the user hasn't used for a long time, and kill it.  It will remain in the interface, but the process will not be there, the whole JS will die.  Is it ok or not ok?  It is strange to ask such a question on the front-end party and expect any answer, except for ‚ÄúWhat are you talking about?‚Äù. <br><br><img src="https://habrastorage.org/webt/ui/5j/nq/ui5jnqtbegu672hy2tzbfiglhrk.jpeg"><br><br>  Then it is not much gone.  Here are the real comments from the Chromium blog: you broke all my applications to me, there was some kind of game - and hop, it has no state.  It is important to understand that there and unload handler did not work, as if we just put out this insert.  The user then returns to it, and we re-download it from the network, as if nothing had happened. <br><br>  Then this approach was temporarily abandoned and came with a more thoughtful serious idea.  They called it discard. <br><br><img src="https://habrastorage.org/webt/x2/7w/zq/x27wzq5kw55gtlcsduajusa3yoi.jpeg"><br><br>  What's the point?  This is all the same kill tabs, only controlled.  It is called the <a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api">Page Lifecycle API</a> buzzword.  If you have a tab, and the user has not seen it for a long time, it can go to the frozen state.  The browser speaks through the event: now I will freeze you.  After processing the event, nothing at all will be executed.  Do what you need, get ready. <br><br>  Then, from the frozen state, it can either exit through the resume event, as if nothing happened.  Or, if the browser really needs to free up memory right now, it just takes it and kills it.  But if the user goes back to this tab, we will reload it, and set the field was discarded on the document. <br><br><img src="https://habrastorage.org/webt/8c/-i/wu/8c-iwuqbmjxvsrdksgcjwvenew4.jpeg"><br><br>  Right now you can already subscribe to these events and catch them, somehow handle.  If the tab is really killed, you can check the field was discarded.  This means that you have recovered after the discard.  You can restore the previous state. <br><br><img src="https://habrastorage.org/webt/as/ny/b1/asnyb16w13ubi3k1dfi_04nicik.jpeg"><br><br>  We in Yandex. Browser thought a few years ago: why not apply a complex cardinal approach.  They called it Hibernate. <br><br><img src="https://habrastorage.org/webt/ce/7-/gn/ce7-gngt24kb9ikzc4nzdxbjspu.jpeg"><br><br>  What's the point?  There are several tabs, running some kind of JS, some kind of state.  A separate process is created for each tab: a video can be played here, then you leave something on the form.  Hibernate comes - and there are no processes.  We have them all "abandoned."  But if we now switch back to these tabs, the process will return, and the entire state will be in place, the video will continue to play from the right moment, all the text in the fields will remain in place. <br><br><img src="https://habrastorage.org/webt/oy/ks/ug/oyksug04glkeh-amu4dyqfrryyc.jpeg"><br><br>  What have we done?  Three most important things live inside each renderer: V8, in which all JS is spinning, Blink, in which all DOM is stored, and some kind of browser binding, which helps to tie everything together, with tabs and everything else. <br><br><img src="https://habrastorage.org/webt/pz/hj/h4/pzhjh4pmyn-yz5afmas6omozx6g.jpeg"><br><br>  Consider for example a sample.  Here we wait for onload to happen, and add a new div element to the DOM tree.  For the browser, it looks something like this. <br><br><img src="https://habrastorage.org/webt/ic/cu/vy/iccuvyjbkmkyjhbgfb5de8uqxpc.jpeg"><br><br>  Naturally, there is a DOM tree, it has some fields, associated objects, and there is such an entity. <br><br><img src="https://habrastorage.org/webt/ng/tj/ki/ngtjkiwdv6raldvffqgnoils7ge.jpeg"><br><br>  In V8, the state of each node is stored, and these nodes are associated with Blink objects through a layer of bindings.  What have we done?  We took the serializer from V8, serialized the entire V8 state, found all the related objects in Blink, wrote positive serializers that save the entire DOM tree, serialize it, then write to disk, compressed and encrypted.  And we taught the browser to recover from such a snapshot back.  That is, when the user goes to such a tab, we uncompress it, decrypt it and show it to the user, restore it completely.  ( <a href="https://habr.com/ru/company/yandex/blog/423507/">Separate post about Hibernate</a> - approx. Ed.) <br><br>  Right now, Hibernate is published for everyone in stable and allows each user to save on average one or two tabs.  That is, on average, one tab is always saved, or maybe two.  This allows you to save memory for users who have more than 10 tabs - like we have with you, but we are not representative. <br><br>  I told you how the browser is trying to help, but now each of you can do something to speed up the site and improve its performance.  Today you can come and do it. <br><br>  First you need to understand whether there are problems with memory. <br><br><img src="https://habrastorage.org/webt/xu/l4/nv/xul4nvtip2nc_mr93zrevltkmye.jpeg"><br><br>  There are certain symptoms: either the site starts to degrade, or fading appears.  This usually means that the garbage collector is triggered, the whole world is frozen and nothing is drawn.  Or that the site just continuously slows down - these also happen. <br><br>  Need to understand if there is a problem.  See what happens with JS memory. <br><br><img src="https://habrastorage.org/webt/ui/g4/kz/uig4kzofjrymuq0egjmk-cdt36o.jpeg"><br><br>  If it jumps sharply back and forth or grows continuously, this is not a good symptom.  Or continuously growing. <br><br><img src="https://habrastorage.org/webt/dt/to/ek/dttoekpmiceh7_6693-n6vrtsjk.jpeg"><br><br>  In this case, you can always take a snapshot through DevTools.  Someone even bother with leaks in JS?  If someone does not know, in JS it is quite possible to make a leak. <br><br><img src="https://habrastorage.org/webt/da/n_/yh/dan_yhjbdvvilgwgovgzzf6tpgu.jpeg"><br><br>  For example, you have a global variable where you add nodes that are not inserted into the tree.  You forget about them, and then it turns out that they are eating hundreds of kilobytes, or even megabytes. <br><br><img src="https://habrastorage.org/webt/vq/au/ia/vqauia5ylxx_u0xu8arw5ycuvta.jpeg"><br><br>  Strictly speaking, it is not clear what to do with such detached-nodes.  You can pull them out of the tree, and then insert them back.  Because usually the state of the picture or something else remains with them.  This way you can find and treat the problem. <br><br><img src="https://habrastorage.org/webt/w7/a6/cy/w7a6cyfk_5iroc0ybpdk21gym5k.jpeg"><br><br>  You can also look at the memory allocation in the timeline.  If you go to a systematic selection and never clears anything - this is also a bad sign, I think everyone understands that. <br><br><img src="https://habrastorage.org/webt/0m/ol/4w/0mol4w_xotmiebkvvheldcrnokq.jpeg"><br><br>  And you can play around with the layers on your tab.  The browser generally works on heuristics in this regard ‚Äî it tries to select into separate layers those objects that it considers often changing.  But sometimes it does this not very well, and it turns out that you have so many layers that consume a lot of memory.  You can always see if you have such a situation, eliminate some layers and find out how much memory this layer occupies. <br><br><img src="https://habrastorage.org/webt/rc/w6/il/rcw6ilo68vshxkgqzq82esab_1y.jpeg"><br><br>  Another layer of problems - with performance.  setTimeout is a bad idea for animation.  It does not work the way the browser wants to render the page.  It may not work in phase: the browser has requested the frame, but the animation has not yet, because setTimeout has not worked.  Or it can work, even when you do not need to draw anything.  The user has left, some background work remains, but we will work with him through setTimeout. <br><br>  Here is the correct approach that your callback will call only when the browser needs to draw this page. <br><br><img src="https://habrastorage.org/webt/st/nr/dv/stnrdvev7a9sricvyvwivcufg4k.jpeg"><br><br>  I also want to remind you that if the browser wants to draw 60 frames per second, it means that for each frame it needs about 16 ms. <br><br><img src="https://habrastorage.org/webt/zo/fy/es/zofyesewo-ck8wl-z_jlsb6u7ak.jpeg"><br><br>  And if you occupy the main stream for longer than 16 ms, then you have a guaranteed frame drop, which is quite unpleasant for the user: the site starts to crash.  Therefore, all the hard work correctly put in the background threads that you just return the result. <br><br><img src="https://habrastorage.org/webt/mp/rk/ry/mprkryexbai19rd-vhbj_tlbeb4.jpeg"><br><br>  Or another approach is to use microtasking.  Create a queue of tasks, process it after some time, until the quota is over, and let the browser quietly draw a page. <br><br><img src="https://habrastorage.org/webt/-0/jr/bn/-0jrbntves41mkelcd56bmgu6uc.jpeg"><br><br>  Naturally, you can add new layers.  The browser works on heuristics and tries to select the layer where it sees fit.  But if you know that right now this element will be animated, it is better to explicitly tell the browser that you need to select this element in a separate layer.  Then it will be rendered more efficiently. <br><br><img src="https://habrastorage.org/webt/t9/pf/mr/t9pfmrqa0mhyszxphlkmvxafsag.jpeg"><br><br>  The latest interesting approach is to complain.  If you have problems, it is always helpful to come and talk.  Maybe this problem is easy to treat, and we will help each other. <br><br>  A little background.  This feature is now in the process of working out.  The search results page development team has come to us.  They have such a metric as the time to draw the first snippet.  If the user previously sees the first link that you need to click on, and which most likely gives him the correct answer, then it is much better to draw it as soon as possible.  They came and asked if it was possible to somehow speed up this time, because they had already squeezed everything out. <br><br>  We searched, performed perf-testing, made a prototype, and it turned out that we can do this if the site tells us that we need to draw first.  We conducted tests and see that this improves our performance.  Now we are testing this in production for a small audience.  See what happens.  Stay tuned. <br><br>  The world does not stand still.  The user starts to want more and more, browsers change, the web changes.  This is normal.  We try not only to make product features, but also to help the user in every way to get the best experience in terms of content consumption.  And you always have to be ready for changes in any popular browser.  Naturally, if there are problems, come, we are ready to discuss and help each other. <br><br>  Here I collected various useful links: <br><br><ul><li>  <a href="https://clck.ru/Eek2s">Hibernate in Yandex Browser</a> </li><li>  <a href="https://clck.ru/EAiQR">Tab discarding in Chrome</a> </li><li>  <a href="https://clck.ru/EcL2L">Page Lifecycle API</a> </li><li>  <a href="https://clck.ru/EcL5i">Measure Performance with the RAIL Model</a> </li><li>  <a href="https://clck.ru/EcLFE">Energy saving in Yandex Browser</a> </li><li>  <a href="https://clck.ru/EcL8J">Steam hardware statistics</a> </li><li>  <a href="https://clck.ru/EcLCZ">The Firefox Public Data Report</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/442456/">https://habr.com/ru/post/442456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442446/index.html">Digital transformation on the example of the Call Center of any business</a></li>
<li><a href="../442448/index.html">Concurrency and error patterns hidden in code: Deadlock</a></li>
<li><a href="../442450/index.html">Blockchain and medical data: how it works</a></li>
<li><a href="../442452/index.html">How to log in NodeJS to the boys in the yard respected</a></li>
<li><a href="../442454/index.html">Magic Leap plans to add digital layers to the real world</a></li>
<li><a href="../442458/index.html">Handmade chasm or the path from the RPA pilot to company-wide implementation</a></li>
<li><a href="../442460/index.html">We help Queryable Provider to deal with interpolated strings</a></li>
<li><a href="../442464/index.html">How to grow manned "Dragon"</a></li>
<li><a href="../442466/index.html">How to promote incremental game? Free, fast and efficient *</a></li>
<li><a href="../442468/index.html">In a unique experiment, mice received infrared vision</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>