<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Duke Nukem 3D Source Code Analysis: Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After leaving work at Amazon, I spent a lot of time reading excellent source code. 

 Having dealt with the incredibly wonderful idSoftware code , I s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Duke Nukem 3D Source Code Analysis: Part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="http://fd.fabiensanglard.net/duke3d/palette_fix.png" alt="image"><br><br>  After leaving work at Amazon, I spent a lot of time reading excellent source code. <br><br>  <a href="http://fabiensanglard.net/doomIphone/doomClassicRenderer.php">Having dealt</a> <a href="http://fabiensanglard.net/quakeSource/index.php">with the</a> <a href="http://fabiensanglard.net/wolf3d/index.php">incredibly</a> <a href="http://fabiensanglard.net/quake3/index.php">wonderful</a> <a href="http://fabiensanglard.net/doom3/index.php">idSoftware</a> <a href="http://fabiensanglard.net/quake2/index.php">code</a> , I started on one of the <a href="http://en.wikipedia.org/wiki/List_of_best-selling_PC_video_games">best games of all time</a> : Duke Nukem 3D and its engine called " <i>Build</i> ". 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It turned out to be a difficult experience: the engine itself is of great importance and highly valued for its speed, stability and memory consumption, but my enthusiasm has come across source code that is contradictory in terms of orderliness, compliance with recommendations and comments / documentation.  While reading the code, I learned a lot about the inherited code and what allows the software to live for a long time. <br><br>  As usual, I reworked <a href="http://fabiensanglard.net/duke3d/notes.txt">my notes</a> into an article.  I hope she inspires you to read the source code and improve your skills. <br><a name="habracut"></a><br>  I want to thank <b>Ken Silverman</b> for reading this article: his patience and honest answers to my letters were important to me. <br><br><h2>  Origin </h2><br>  Duke Nukem 3D is not one, but <b>two</b> code bases: <br><br><ul><li>  <i>Build</i> Engine: Provides rendering, networking, file system, and caching services. </li><li>  Game module: uses the <i>Build</i> service to create a game. </li></ul><br>  Why was this separation necessary?  Because in 1993, when development began, only a few people had the skills and zeal necessary to create a good 3D engine.  When 3D Realms decided to write a game that would become a competitor to <i>Doom</i> , she needed to find powerful technology.  And at this moment Ken Silverman appears on the scene. <br><br>  According to his <a href="http://advsys.net/ken/build.htm">well-documented website</a> and <a href="http://www.3drealms.com/news/2006/02/the_apogee_legacy_8.html">interviews</a> , Ken (he was 18 at the time) wrote a 3D engine at home and sent a demo to 3D Realms for evaluation.  They considered his skills promising, and concluded an agreement: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cb/26f/fe9/2cb26ffe9a3af4aae5b60412bc746693.png"><br><br>  Silverman will write a new engine for 3D Realms, but will retain the source code. <br><br>  It will provide only the <u>binary static library</u> ( <code>Engine.OBJ</code> ) with the header file <code>Engine.h</code> .  For its part, the 3D Realms team will take over the work on the game module ( <code>Game.OBJ</code> ) and release the final executable <code>DUKE3D.EXE</code> . <br><br>  Unfortunately, the source code of both parts of the game was not open at the same time: <br><br><ul><li>  The source code for the engine was released by Ken Silverman on June 20, 2000. </li><li>  The source code of the game module was released by 3D Realms on April 1, 2003. </li></ul><br>  As a result, the full source code became available only 7 years after the release of the game. <br><br>  <u><b>Interesting fact: the</b></u> name of the engine " <i>Build</i> " was chosen by Ken Silverman when creating the catalog for the new engine.  He used the <a href="http://advsys.net/ken/build.htm">thesaurus to find synonyms for the word "Construction"</a> . <br><br><h2>  First contact </h2><br><img align="left" src="https://habrastorage.org/getpro/habr/post_images/5dc/9d5/2b7/5dc9d52b7375cdf5ef63afa599fb8ee9.png">  Since the source code was released a long time ago (it was intended for the Watcom C / C ++ compiler and DOS systems), I tried to find something similar to <a href="http://www.chocolate-doom.org/wiki/index.php/Chocolate_Doom">Chocolate doom</a> : a port that faithfully reproduces Duke Nukem 3D gameplay, as it was in 90 , and seamlessly compiled on modern systems. <br><br>  It turned out that the Duke Nukem source code community is no longer too active: many ports are outdated again, some are created for MacOS 9 PowerPC.  So far, only one ( <a href="http://eduke32.com/">EDuke32</a> ) is supported, but it has evolved too much compared to the original code. <br><br>  As a result, I started working with <a href="http://vision.gel.ulaval.ca/~klein/duke3d/">xDuke</a> , although it did not compile on Linux and Mac OS X (which excluded the use of Xcode: an excellent IDE for reading code and profiling). <br><br>  Visual Studio's xDuke faithfully reproduces the original code.  It contains two projects: Engine and Game.  The Engine project is compiled into a static library ( <code>Engine.lib</code> ), and the Game project (containing the <code>main</code> method) is associated with it to generate <code>duke3D.exe</code> . <br><br>  When opening VS, the engine source files look rather unfriendly due to the complex file names ( <code>ac</code> , <code>cache1d.c</code> ).  These files contain something hostile to the eye and brain.  Here is one of many examples in the <a href="">Engine.c</a> file <a href="">(line 693)</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((globalorientation&amp;<span class="hljs-number"><span class="hljs-number">0x10</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) globalx1 = -globalx1, globaly1 = -globaly1, globalxpanning = -globalxpanning; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((globalorientation&amp;<span class="hljs-number"><span class="hljs-number">0x20</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) globalx2 = -globalx2, globaly2 = -globaly2, globalypanning = -globalypanning; globalx1 &lt;&lt;= globalxshift; globaly1 &lt;&lt;= globalxshift; globalx2 &lt;&lt;= globalyshift; globaly2 &lt;&lt;= globalyshift; globalxpanning &lt;&lt;= globalxshift; globalypanning &lt;&lt;= globalyshift; globalxpanning += (((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)sec-&gt;ceilingxpanning)&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>); globalypanning += (((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)sec-&gt;ceilingypanning)&lt;&lt;<span class="hljs-number"><span class="hljs-number">24</span></span>); globaly1 = (-globalx1-globaly1)*halfxdimen; globalx2 = (globalx2-globaly2)*halfxdimen;</code> </pre> <br>  <u><b>Note:</b></u> if the file / variable name contains a number, then this is quite possibly not a very good name! <br>  <u><b>Interesting fact: the</b></u> last part of the <code>game.c</code> code contains a <a href="">draft of the Duke V script</a> ! <br>  <b><u>Note:</u></b> xDuke port uses SDL, but the advantage of the cross-platform API is lost due to WIN32 timers ( <code>QueryPerformanceFrequency</code> ).  It seems that the SDL Timer used is too inaccurate to emulate a 120 Hz frequency in DOS. <br><br><h2>  Assembly </h2><br>  Having dealt with the SDL and the location of the DirectX header / libraries, you can assemble the code in one click.  It is very nice.  The last thing left is to get the resource file <code>DUKE3D.GRP</code> , and the game will start ... well, or something like that.  It looks like SDL has some problems with the palette in Vista / Windows 7: <br><br><img src="http://fd.fabiensanglard.net/duke3d/palette_bug.png"><br><br>  Running in windowed mode (or better on Windows 8) seems to solve the problem: <br><br><img src="http://fd.fabiensanglard.net/duke3d/palette_fix.png"><br><br><h2>  Immersion process </h2><br>  Now the game is working.  For a few seconds, <i>Build</i> appears in all its splendor, showing: <br><br><ul><li>  Sloping ceilings </li><li>  Realistic surroundings </li><li>  Free fall </li><li>  A sense of true 3D. </li></ul><br>  The last point was probably the most influential on players in 1996.  The dive level was unsurpassed.  Even when the technology reached its limit because of two-dimensional maps, Todd Replogle and Allen Blum implemented ‚Äúsector effectors‚Äù that allowed to teleport a player and heighten the sense of immersion in a three-dimensional world.  This feature is used in the legendary LA Meltdown map: <br><br>  When a player jumps into the ventilation shaft: <br><br><img src="http://fd.fabiensanglard.net/duke3d/duke_top_roof.png"><br><br><img src="http://fd.fabiensanglard.net/duke3d/level1_map.png"><br><br>  The effectors of the sectors work and before the ‚Äúlanding‚Äù they teleport the player to a completely different place on the map: <br><br><img src="http://fd.fabiensanglard.net/duke3d/duke_post_jump.png"><br><br><img src="http://fd.fabiensanglard.net/duke3d/duke_map_post_jump.png"><br><br>  Good games are slowly aging, and Duke Nukem is no exception: twenty years later, it is still incredibly fun to play.  And now we can also study its source code! <br><br><h2>  Engine Library Overview </h2><br><img src="http://fd.fabiensanglard.net/duke3d/engine_archi.png"><br><br>  The engine code is in one file of 8503 lines and with 10 main functions ( <code>Engine.c</code> ) and in two additional files: <br><br><ul><li>  <code>cache1.c</code> : contains a virtual file system (sic!) and caching system procedures. </li><li>  <code>ac</code> : C implementation of the re-created by developing code that was a highly optimized x86 assembler.  The code works, but reading it is a huge meal! <br></li></ul><br>  Three translation modules and several functions make up a high-level architecture that is difficult to understand.  Unfortunately, these are not the only difficulties that the reader will have to face. <br><br>  To the interiors of the <i>Build</i> engine I have dedicated a whole section (see below). <br><br><h3>  Game Module Overview </h3><br><img src="http://fd.fabiensanglard.net/duke3d/game_archi.png"><br><br>  The game module is entirely built on top of the engine module, the system calls of the operating system are used by the process.  Everything in the game is done through <i>Build</i> (drawing, resource loading, file system, caching system, etc.).  The only exception is the sounds and music, they are completely related to the <i>Game</i> . <br><br>  Since I was more interested in the engine, I didn‚Äôt really understand it here.  But in this module you can see more experience and organization: 15 files divide the source code into clear modules.  It even has <code>types.h</code> (initiator <code>stdint.h</code> ) to improve portability. <br><br>  A couple of interesting points: <br><br><ul><li>  <code>game.c</code> is a monster of <code>game.c</code> lines of code. </li><li>  The <code>menu.c</code> has 3000 lines with ‚Äúswitch case‚Äù. </li><li>  Most methods have ‚Äúvoid‚Äù parameters and return ‚Äúvoid‚Äù.  Everything is done through global variables. </li><li>  Method names do not use camelCase or the NAMESPACE prefix. </li><li>  The module has a good parser / lexical analyzer, although the <b>values ‚Äã‚Äãof the tokens</b> <a href="">are transmitted via decimal</a> values ‚Äã‚Äãinstead of <a href=""><code>#define</code></a> . </li></ul><br>  In general, this part of the code is easy to read and understand. <br><br><h3>  Inherited Source Code </h3><br>  Looking at the endless number of ports generated by Doom / Quake, I always wondered why there are so few Duke Nukem 3D ports.  The same question arose when the engine was ported to OpenGL only after Ken Silverman decided to do this on his own. <br><br>  Now that I looked at the code, I‚Äôd venture to explain this in the second part of this article. <br><br><h3>  Chocolate Duke Nukem 3D </h3><br>  I love this engine and love the game, so I couldn‚Äôt leave everything as it is: I created <a href="https://github.com/fabiensanglard/chocolate_duke3D">Chocolate Duke Nukem 3D</a> , the port of ‚Äúvanilla‚Äù source code, trying to achieve two goals in this way: <br><br><ul><li>  Training: ease of reading / understanding and ease of porting. </li><li>  Reliability: the gameplay should be similar to the one we saw in 1996 on our 486s. </li></ul><br>  I hope this initiative helps to inherit the code.  The most important modifications will be described in the second part of the article. <br><br><h1>  Build engine insides </h1><br>  <a href="http://en.wikipedia.org/wiki/Build_engine"><i>Build was</i></a> used in Duke Nukem 3D and many other successful games such as <a href="http://en.wikipedia.org/wiki/Shadow_Warrior">Shadow Warrior</a> and <a href="http://en.wikipedia.org/wiki/Blood_(video_game)">Blood</a> .  At the time of release on January 29, 1996, he destroyed the <i>Doom</i> engine with innovative features: <br><br><ul><li>  Destructible surroundings </li><li>  Sloped floors and ceilings </li><li>  Mirrors </li><li>  Opportunity to look up and down </li><li>  The ability to fly, crawl and swim under water </li><li>  <a href="">Voxel objects</a> (appeared later in ‚ÄúBlood‚Äù) </li><li>  Real immersion in 3D (thanks to teleports). </li></ul><br>  The crown was taken away from him in June 1996 by Quake, launched on powerful Pentiums ... but for several years <i>Build</i> provided high quality, designer freedom and, most importantly, good speed on most computers of that time. <br><br><h2>  The most important concept: the portal system </h2><br>  Most of the 3D engines divided game maps using binary space partitioning (Binary Space Partition) or Octree (Octree).  Doom, for example, pre-processed each card using a time-consuming method (up to 30 minutes), which resulted in a BSP-tree, which allowed: <br><br><ul><li>  Sort walls </li><li>  Determine the position </li><li>  Detect collisions. </li></ul><br>  But to please speed, one had to make concessions: the walls <b>could not move</b> .  <i>Build</i> removed this restriction, it did not pre-process maps, but instead used <b>a portal system</b> : <br><br><img src="http://fd.fabiensanglard.net/duke3d/duke_map.png"><br><br><img src="http://fd.fabiensanglard.net/duke3d/duke_map_portal.png"><br><br>  On this map, the game designer drew 5 sectors (above) and connected them together, marking the walls as portals (below). <br><br>  As a result, the <i>Build</i> world database has become ridiculously simple: one array for the sectors and one array for the walls. <br><br><pre>  Sectors (5 records): Walls (29 records):
   ============================ ===================== ====================
   0 |  startWall: 0 numWalls: 6 0 |  Point = [x, y], nextsector = -1 // Wall in sector 0
   1 |  startWall: 6 numWalls: 8 .. |  // Wall in sector 0
   2 |  startWall: 14 numWalls: 4 .. |  // Wall in sector 0
   3 |  startWall: 18 numWalls: 3 3 |  Point = [x, y], nextsector = 1 // Portal from sector 0 to sector 1
   4 |  startWall: 21 numWalls: 8 .. |  // Wall for sector 0
   ============================ .. |  // Wall for sector 0
                                                .. |
                   First wall of sector 1 &gt;&gt; 6 |  Point = [x, y], nextsector = -1
                                                 7 |  Point = [x, y], nextsector = -1
                                                 8 |  Point = [x, y], nextsector = -1   
                                                 9 |  Point = [x, y], nextsector = 2 // Portal from sector 1 to sector 2
                                                10 |  Point = [x, y], nextsector = -1   
                                                11 |  Point = [x, y], nextsector = 0 // Portal from sector 1 to sector 0
                                                12 |  Point = [x, y], nextsector = -1
                 Last wall of sector 1 &gt;&gt; 13 |  Point = [x, y], nextsector = -1
                                                .. |
                                                28 |  Point = [x, y], nextsector = -1
                                                =========================================== </pre><br>  Another misconception about <i>Build</i> is that it does not emit rays: the vertices are first projected into the player‚Äôs space, and then a column / distance is generated from the viewpoint. <br><br><h2>  Duty Cycle Overview </h2><br>  High-level description of the frame rendering process: <br><br><ol><li>  <i>The game module</i> transfers to the <i>engine module the</i> sector from which the rendering should start (usually it is the player‚Äôs sector, but it can also be a sector with a mirror). </li><li>  <i>The engine module</i> bypasses the portal system and visits <i>the</i> sectors of <i>interest</i> .  In each visited sector: <br><ul><li>  The walls are grouped into sets, called groups ("bunch").  They are saved to the stack. </li><li>  Sprites that are visible in this sector are defined and saved to the stack. </li></ul></li><li>  Groups are processed in order from near to far: continuous walls and portals are rendered. </li><li>  Rendering stops: waiting while the <i>game module</i> updates visible sprites. </li><li>  Render all sprites and transparent walls in order from distant to neighbors. </li><li>  Switching buffers. </li></ol><br>  Here are each of the steps in the code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// 1.          . updatesector(int x, int y, int* lastKnownSectorID) displayrooms() { //   ,   .     (    ). drawrooms(int startingSectorID) { //   "gotsector",   "visited sectors". clearbufbyte(&amp;gotsector[0],(long)((numsectors+7)&gt;&gt;3),0L); //   umost  dmost (  ). // 2.    :    ("bunch"). scansector(startingSectorID) { //        BUNCH. //          tsprite, spritesortcnt++ } //     numbunches   bunches. //   .   (O)n*n,        . while ((numbunches &gt; 0) &amp;&amp; (numhits &gt; 0)) { //    (o) n*n for(i=1;i&gt;numbunches;i++) { //   bunchfront test } //  ,   bunchID (closest) drawalls(closest); } } // 3.      ,       . animatesprites() // 4.    ,     ,    (, ). drawmasks() { while ((spritesortcnt &gt; 0) &amp;&amp; (maskwallcnt &gt; 0)) { drawsprite or drawmaskwall } } } //   .  2D- (,   ) displayrest(); // 5.   nextpage()</span></span></code> </pre> <br>  <u><b>An interesting fact:</b></u> if you study the code, that is, a <a href="http://fabiensanglard.net/duke3d/duke3d_code_review_unrolled.txt">fully expanded cycle</a> , which I used as a map. <br><br>  <u><b>Interesting fact:</b></u> why is the buffer switching method called <code>nextpage()</code> ?  In the 90s, the joy of programming for VGA / VESA included the implementation of double buffering: two parts of the video memory were allocated and used in turn.  Each part is called a ‚Äúpage‚Äù.  One part was used by the VGA CRT module, and the second was updated by the engine.  Switching buffers involved using the next page CRT (‚Äúnext page‚Äù) by replacing the base address.  You can read more about this in <a href="http://downloads.gamedev.net/pdf/gpbb/gpbb23.pdf">Chapter 23 of the book ‚ÄúBlack Book of Graphic Programming: Bones and sinew‚Äù by Michael Abrash</a> . <br><br>  Today, SDL simplifies this work with the simple flag of the <code>SDL_DOUBLEBUF</code> video mode, but the method name remains as an artifact of the past. <br><br><h3>  1. How to start rendering? </h3><br>  The absence of BSP means that it is impossible to take the point <code>p(x,y)</code> and go through the nodes of the tree until we reach the leaf sector.  In <i>Build,</i> the player‚Äôs current sector must be <u>tracked</u> after each position update using the <code>updatesector(int newX, int newY, int* lastKnownSectorID)</code> .  <i>The game module</i> calls this <i>engine module</i> method very often. <br><br>  A naive implementation of the <code>updatesector</code> would scan linearly each sector and each time check whether <code>p(x,y)</code> <i>inside</i> sector S. But the <code>updatesector</code> optimized by a behavioral pattern: <br><br><ol><li>  Writing <code>lastKnownSectorID</code> , the algorithm assumes that the player has not moved very far and starts checking with the <code>lastKnownSectorID</code> sector. </li><li>  If point 1 failed, the algorithm checks adjacent <code>lastKnownSectorID</code> sectors using portals. </li><li>  Finally, in the worst case scenario, it scans all sectors with a linear search. </li></ol><br><img align="left" src="http://fd.fabiensanglard.net/duke3d/duke_map.png" alt="image">  On the map on the left, the last known sector of the player‚Äôs position was the sector with identifier <code>1</code> : depending on the distance the player moved, the <code>updatesector</code> checks in the following order: <br><br><ol><li>  <code>inside(x,y,1)</code> (the player has moved not so far to leave the sector). </li><li>  <code>inside(x,y,0)</code> (the player has moved slightly to the adjacent sector). <br> <code>inside(x,y,2)</code> <br> </li><li>  <code>inside(x,y,0)</code> (the player has moved a lot: potentially checking all sectors of the game is potentially necessary). <br> <code>inside(x,y,1)</code> <br> <code>inside(x,y,2)</code> <br> <code>inside(x,y,3)</code> <br> <code>inside(x,y,4)</code> </li> </ol><br>  The worst case scenario can be quite expensive.  But most of the time the player / projectiles do not move very far, and the speed of the game remains high. <br><br><h2>  Details about inside </h2><br>  Inside is a remarkable method for two reasons: <br><br><ul><li>  It can only use integers. </li><li>  It must be performed for sectors that may be concave. </li></ul><br>  I take a closer look at this method, because it perfectly demonstrates how <i>Build</i> works: with the help of good old vector products and XOR. <br><br><h2>  The era of fixed-point computation and the ubiquitous vector products </h2><br>  Since most computers in the 90s did not have a floating-point (FPU) coprocessor (386SX, 386DX and 486SX), only integers were used in <i>Build</i> . <br><br><img src="http://fd.fabiensanglard.net/duke3d/problem.png"><br><br>  The example shows a wall with end points A and B: the task is to determine whether the point is to the left or to the right. <br><br><img src="http://fd.fabiensanglard.net/duke3d/problem_fp.png"><br><br>  In <a href="http://twimgs.com/ddj/abrashblackbook/gpbb61.pdf">Chapter 61 of the book ‚ÄúBlack Book of Programming: Frame of Reference‚Äù by Michael Abrash,</a> this problem is solved by simple scalar product and comparison. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inFrontOfWall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> plan[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> point[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dot = dotProduct(plan,point); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot &lt; plan[<span class="hljs-number"><span class="hljs-number">3</span></span>]; }</code> </pre> <br><img src="http://fd.fabiensanglard.net/duke3d/problem_fixedp.png" alt="image"><br><br>  But in the world without floating point operations, the problem is solved by a vector product. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inFrontOfWall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wall[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> point[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pointVector[<span class="hljs-number"><span class="hljs-number">2</span></span>], wallVector[<span class="hljs-number"><span class="hljs-number">2</span></span>] ; pointVector[<span class="hljs-number"><span class="hljs-number">0</span></span>] = point[<span class="hljs-number"><span class="hljs-number">0</span></span>] - wall[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  pointVector[1] = point[1] - wall[0][1]; wallVector[0] = wall[1][0] - wall[0][0]; //  wallVector[1] = wall[1][1] - wall[0][1]; //   crossProduct    Z:     Z. return 0 &lt; crossProduct(wallVector,wallVector); }</span></span></code> </pre> <br>  <u><b>An interesting fact:</b></u> if you set the search string ‚Äúfloat‚Äù in the source code of <i>Build</i> , then there is not a single match. <br>  <u><b>An interesting fact: the</b></u> use of the <code>float</code> type was popularized by Quake, because it was intended for Pentium processors and their co-processors for floating point numbers. <br><br><h2>  Inside the concave polygon </h2><br>  Having learned how a vector product can be used to determine the position of a point relative to a wall, we can take a closer look at <a href=""><code>inside</code></a> . <br><br><img src="http://fd.fabiensanglard.net/duke3d/inside_both.png"><br><br>  An example with a concave polygon and two points: Point 1 and Point 2. <br><br><ul><li>  Point 1 is considered to be outside. </li><li>  Point 2 is considered to be located inside. </li></ul><br>  The "modern" algorithm for determining the point in the polygon (point-in-polygon, PIP) is to emit a ray to the left and determine the number of crossed sides.  For an odd number, the point is inside, and for even, it is outside. <br><br><img src="http://fd.fabiensanglard.net/duke3d/inside_p1.png"><br><br><img src="http://fd.fabiensanglard.net/duke3d/inside_p2.png"><br><br>  <i>Build</i> uses a variation of this algorithm: it counts the number of edges on each side and combines the results using XOR: <br><br><img src="http://fd.fabiensanglard.net/duke3d/inside_fixed_p1.png"><br><br><img src="http://fd.fabiensanglard.net/duke3d/inside_fixed_p2.png"><br><br>  <u><b>Interesting fact:</b></u> the Doom engine had to perform about the same tricks in <a href="">R_PointOnSide</a> .  Quake used planes and floating point operations in <a href="">Mod_PointInLeaf</a> . <br><br>  <u><b>An interesting fact:</b></u> if <code>inside</code> seems difficult to you to read, I advise you to study <a href="">the Chocolate Duke Nukem version</a> , it has comments. <br><br><h2>  2. Portal and opaque walls </h2><br>  The initial sector is transferred to the <i>Build</i> engine by the <i>game module</i> .  Rendering begins with opaque walls in <code>drawrooms</code> : two stages connected by a stack. <br><br><img src="http://fd.fabiensanglard.net/duke3d/two_step_solidworlds_rendition.png"><br><br><ul><li>  The preprocessing stage floods the portal system (starting with <code>startingSectorID</code> ) and saves the walls on the stack: <code>scansector()</code> . </li><li>  The stack consists of ‚Äúbunch‚Äù elements. </li><li>  The stack elements are passed to the renderer method: <code>drawwalls()</code> . </li></ul><br><img src="http://fd.fabiensanglard.net/duke3d/bunch.png"><br><br>  What is a ‚Äúbunch‚Äù? <br><br>  A group is a set of walls that are considered ‚Äúpotentially visible.‚Äù  These walls belong to the same sector and are constantly (connected by a dot) directed towards the player. <br><br>  Most of the walls in the stack will be dropped, as a result only some of them are rendered on the screen. <br><br>  <b><u>Note:</u></b> "wall proxy" is an integer that refers to a wall in the list of "potentially visible" walls.  The pvWalls array contains a link to a wall in the world‚Äôs database, as well as its coordinates rotated / moved into player space and screen space. <br><br>  <b><u>Note:</u></b> the data structure is actually more complex: only the first wall of the group is saved on the stack.  The rest are in an array used as a list with references to identifiers: this is done in such a way that groups can be quickly moved up and down the stack. <br><br> <b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An interesting fact:</font></font></u></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to mark visited "sectors", the filling process uses an array. This array must be cleared before each frame. To determine whether a sector has been visited in the current frame, it does not use the</font></font><a href="http://fabiensanglard.net/quakeSource/quakeSourceRendition.php"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> framenumber trick</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br> <b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An interesting fact:</font></font></u></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the Doom engine, quantification was used to convert angles to screen columns. In</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Build, the </font></font></i><font style="vertical-align: inherit;"></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cos / sin matrix was used</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to convert the vertices of world space into player space</font><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When pouring portals, the following heuristics are used: all portals that are directed towards the player and are within the range of 90 degrees will be filled. This part is</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hard to understand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but it is interesting because it shows how developers were striving to save cycles everywhere: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  -&gt;  Z tempint = x1*y2-x2*y1; //     ,     ,  . //  :        . if (((uint32_t)tempint+262144) &lt; 524288) { //(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) is the squared length of the wall if (mulscale5(tempint,tempint) &lt;= (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)) sectorsToVisit[numSectorsToVisit++] = nextsectnum; }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Group generation </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The walls inside the sector are grouped into "groups" ("bunches"). </font><font style="vertical-align: inherit;">Here is a picture to explain the idea: </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/bunch_generation.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The figure above shows that three sectors generated four groups:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sector 1 generated one group containing one wall. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sector 2 generated one group containing three walls. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sector 3 generated two groups, each of which contains two walls. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why group walls at all? </font><font style="vertical-align: inherit;">Because </font><font style="vertical-align: inherit;">there is no data structure </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that allows for quick sorting. </font><font style="vertical-align: inherit;">He retrieves the closest group using the process (O¬≤), which would be very costly if performed for each wall. </font><font style="vertical-align: inherit;">Resource costs are much lower than when performing for a variety of all walls.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using groups </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After filling the stack of groups, the engine starts to draw them, starting from close to far. </font><font style="vertical-align: inherit;">The engine selects the first group that is not covered by another group (there is always at least one group that satisfies this condition):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  ,    :( */</span></span> closest = <span class="hljs-number"><span class="hljs-number">0</span></span>; tempbuf[closest] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; numbunches; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((j = bunchfront(i,closest)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; tempbuf[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>){ tempbuf[closest] = <span class="hljs-number"><span class="hljs-number">1</span></span>; closest = i; } }</code> </pre> <br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> despite the name of the variable, the group selected is not necessarily the closest. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explanation of the principle of choice given by Ken Silverman:</font></font></u> <br><blockquote>   2 .   ,       x-.   ,            .          ,     x-.     .    :  ,          . (:    ,   ,    ¬´¬ª !)     ( )        .       ,     ,      ,     ‚Äî  </blockquote><br> <code>bunchfront</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- fast, complex and imperfect, so </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build </font></font></i> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performs a double check</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> before sending the result to the renderer. </font><font style="vertical-align: inherit;">This disfigures the code, but as a result we get O (n) instead of O (n¬≤). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each selected group is sent to the </font></font><code>drawalls(closest)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renderer: this part of the code renders as many walls / floors / ceilings as possible.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualization of walls / floors / ceilings </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To understand this part, it is important to understand that everything is rendered vertically: the walls, the floor and the ceilings. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two clipping arrays in the renderer core. </font><font style="vertical-align: inherit;">Together they track the top and bottom clipping of each column of pixels on the screen:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    - 1600x1200 #define MAXXDIM 1600 //FCS: (     x,    ) short umost[MAXXDIM+1]; //FCS: (     x,    ) short dmost[MAXXDIM+1];</span></span></code> </pre> <br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notes: the</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> engine usually uses arrays of primitive types instead of an array of struct. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The engine records the vertical range of pixels, starting from the top to the bottom border. </font><font style="vertical-align: inherit;">Border values ‚Äã‚Äãmove towards each other. </font><font style="vertical-align: inherit;">When they determine that the pixel column is completely overlapped, the counter value decreases:</font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/occlusion/duke_occ_principle.png"><br><br> <b><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Note:</font></font></u></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> most of the time, the clipping array is only partially updated: the portals leave ‚Äúholes‚Äù in it. </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/occlusion/occ_pixels.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each wall in the group is projected into screen space, and then:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If it is a solid wall: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Render ceiling if it is visible. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Render the floor if it is visible. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Renders the wall if it is visible. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The whole column is marked as overlapped in the clipping array. </font></font></li></ul><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If this is a portal: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Render ceiling if it is visible. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Render the floor if it is visible. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The engine ‚Äúlooks in‚Äù the following sector: </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The clipping array is updated to reflect what was drawn. </font></font></li></ul></li></ul><br><img src="http://fd.fabiensanglard.net/duke3d/occlusion/occ_example.png"><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stop condition:</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this cycle will continue until all groups are processed or until all columns of pixels are marked as completed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is much easier to understand with an example that breaks a scene, for example, a familiar hall: </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/movies/inside-poster.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the map, portals are shown in red and solid walls in white: </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/maps/inside_map.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Three walls of the first group are projected into the screen space: only the lower parts fall on the screen. </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/first_bunch.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the engine can render the floor vertically: </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/first_bunch_render1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then the engine ‚Äúlooks in‚Äù the sectors adjacent to each of the three walls: since their meaning is not </font></font><code>-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, these walls are portals. </font><font style="vertical-align: inherit;">Seeing the difference between the heights of the floors, the engine understands that it is necessary to draw a step up ("UP") for each of them:</font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/first_bunch_render2.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is all that is rendered with the first group. Now the second group is projected into the screen space. </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/second_bunch.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And again only the lower part falls. This means that the engine can render the floor: </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/second_bunch_floor.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looking into the next sector and seeing the longest portal, the engine can draw a ledge up (‚ÄúSTEP UP‚Äù). However, the second portal in the group leads to a lower sector: the ledge is NOT drawn. </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/second_bunch_walls.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The process is repeated. Here is a video showing the full scene: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inside the theater:</font></font></b> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PFWKfG0dX0k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result of rendering the portal door, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> painted the ledge up and the ledge down with two different textures. How is this possible with only one </font></font><code>picnum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is possible because the structure has " </font></font><code>picnum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", it is " </font></font><code>overpicnum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" for one-sided or masked walls, and a flag that allows to "steal" the index of the bottom texture from the wall of the opposite sector. It was a hack that allowed keeping the small size of the sector structure. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I compiled two other scenes in the video: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Street:</font></font></b> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/eyWqDqgzb9w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From 0:00 to 0:08: the</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> portal of the lower line of the pavement is used to draw the vertical part of the floor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At 0:08 the engine is looking for the level of the floor sector after the sidewalk. As it rises, the portal wall is drawn: the rendering of the pavement is complete. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From 0:18 to 0:30: a</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> group of two pavements on the left is used to render a huge piece of floor. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outside the theater:</font></font></b> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Q6aa90Zf798" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an interesting scene in which a window appears. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last video shows a window. Here are the details on how it is created: </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Map:</font></font></u> <br><br><img src="http://fd.fabiensanglard.net/duke3d/maps/theatre_map.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The first group contains four walls that, when projected into the screen space, allow the ceiling and floor to be drawn: The </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/theatre/ceiling_floor.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">left wall of the group is the portal. After studying it turns out that the floor of the next sector is at the same height, and the ceiling is higher: there is no need to render any walls of the ledges. The second wall is opaque (marked white on the map). As a result, a full column of pixels is drawn: </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/theatre/opaquewall1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third wall is the portal. Looking at the height of the next sector, it is clear that it is lower, therefore it is necessary to render the wall of the ledge down:</font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/theatre/portal_stepdown.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same process of ‚Äúpeeking‚Äù is also performed for the floor. </font><font style="vertical-align: inherit;">Since it is higher, the ledge wall is drawn up: </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/theatre/portal_stepup.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, finally, the last wall is processed. </font><font style="vertical-align: inherit;">It is not a portal, so full columns of pixels are drawn. </font></font><br><br><img src="http://fd.fabiensanglard.net/duke3d/breakdown/theatre/opaquewall2.png"><br><br> <u><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An interesting fact:</font></font></b></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> since the walls are drawn vertically, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stores textures in RAM rotated 90 degrees. </font><font style="vertical-align: inherit;">This greatly optimizes the use of the cache.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. pause </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this point, all the visible solid walls are recorded in the voice-over buffer. </font><font style="vertical-align: inherit;">The engine stops its work and waits for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">game module</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to </font><font style="vertical-align: inherit;">execute </font><font style="vertical-align: inherit;">so that it can animate all visible sprites. </font><font style="vertical-align: inherit;">These sprites are written to the following array:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXSPRITESONSCREEN 1024 extern long spritesortcnt; extern spritetype tsprite[MAXSPRITESONSCREEN];</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Rendering of sprites </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">game module has</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> finished animating all the visible sprites, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> starts drawing: from the far to the near in </font></font><code>drawmasks()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Calculates the distance from the viewpoint to each sprite. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array of sprites sorted by Shell algorithm </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The engine alternately takes data from two lists (one for sprites and one for transparent walls). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After exhausting one list, the engine tries to minimize branching and switches to a cycle that renders only one type: sprites or walls. </font></font></li></ol><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Profiling </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Running </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duke Nukem 3D</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> through the Instruments debugger prompted me to think about what processor cycles are being spent on: </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Main method:</font></font></u> <br><br><img src="http://fd.fabiensanglard.net/duke3d/profiling/profiling_01_main.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Not surprising: most of the time is spent rendering non-transparent walls and waiting for the buffer to switch (vsync is enabled). </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Displayrooms method:</font></font></u> <br><br><img src="http://fd.fabiensanglard.net/duke3d/profiling/profiling_02_walls.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 93% of the time is spent drawing solid walls. </font><font style="vertical-align: inherit;">6% allotted visualization of sprites / transparent walls. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drawrooms method:</font></font></u> <br><br><img src="http://fd.fabiensanglard.net/duke3d/profiling/profiling_021.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despite its complexity, the definition of visible surfaces (Visible Surface Determination) takes up only 0.1% of the solid wall visualization step. </font></font><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The drawalls method:</font></font></u> <br><br><img src="http://fd.fabiensanglard.net/duke3d/profiling/profiling_022.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * scan functions are the interface between the engine and assembler procedures:</font></font><br><br><ul><li> <code>wallscan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : walls </font></font></li><li> <code>ceilscan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ceilings without tilt </font></font></li><li> <code>florscan()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : floor without tilt </font></font></li><li> <code>parascan()</code> :   (  <code>wallscan()</code> ) </li><li> <code>grouscan()</code> :     ‚Äî   </li></ul><br> <u>  :</u> <br><blockquote> ceilscan()  florscan() ,           .        while.   ,               .     ,  , ,  .     while     Doom. </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ken sent me an </font></font><a href="http://advsys.net/ken/evaltut/evaldraw_tut.htm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evaldraw</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> script </font><font style="vertical-align: inherit;">, </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">span_v2h.kc</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , showing how ceilscan () and florscan () convert a list of vertical ranges into a list of horizontal ranges: </font></font><br><br><img src="http://fabiensanglard.net/duke3d/evalDraw.png"><br><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The displayrest method:</font></font></u> <br><br><img src="http://fd.fabiensanglard.net/duke3d/profiling/profiling_05_rest.png"><br><br> <code>displayrest</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> taken from the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">game module</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The main costs here again fall on drawing (weapons). </font><font style="vertical-align: inherit;">The status bar is not drawn every frame; it is inserted only when the ammunition counter is changed.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interesting facts about VGA and VESA </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to X-Mode VGA, most players started </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in 320x240 resolution. </font><font style="vertical-align: inherit;">But thanks to the VESA standard, the engine also supports Super-VGA resolution. </font><font style="vertical-align: inherit;">Vanilla sources are equipped with a VESA code that provides portable definition resolution and rendering. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nostalgic can read about programming for VESA </font></font><a href="http://www.monstersoft.com/tutorial1/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in this good guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Today in the code leaving only the names of methods, for example </font></font><code>getvalidvesamodes()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sound engine </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the time, Duke3D had an impressive sound system engine. </font><font style="vertical-align: inherit;">He could even mix sound effects to simulate reverb. </font><font style="vertical-align: inherit;">Read more about this in </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reverb.c</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Inherited code </h2><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Build</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code is </font><font style="vertical-align: inherit;">very difficult to read. </font><font style="vertical-align: inherit;">I listed all the reasons for these difficulties on the </font></font><a href="http://fabiensanglard.net/duke3d/code_legacy.php"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Duke Nukem 3D</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> page </font><a href="http://fabiensanglard.net/duke3d/code_legacy.php"><font style="vertical-align: inherit;">and Build engine: Source code issues and legacy</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recommended reading </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No </font><font style="vertical-align: inherit;">Do better climbing - it's awesome! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if you insist, then you can read </font></font><a href="http://fabiensanglard.net/duke3d/id%2520as%2520Super-Ego-%2520The%2520Creation%2520of%2520Duke%2520Nukem%25203D.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">id as Super-Ego: The Creation of Nukem 3D</font></font></a> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to read about another game based on portals, then I recommend the </font></font><a href="https://habrahabr.ru/post/321986/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excellent post-mortem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sean Barrett about Thief: The Dark Project.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Many interviews with Ken Silverman: </font></font><br><ul><li> <a href="http://www.classicdosgames.com/interviews/kensilverman.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">November 21, 2005</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , classicdosgames.com ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mirror</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li><li> <a href="http://www.strifestreams.com/KenSilvermanInterview"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2005</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , strifestreams.com ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mirror</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></li><li> <a href="http://www.3drealms.com/news/2006/02/the_apogee_legacy_8.html">27  2006 </a> , 3drealms.com ( <a href=""></a> ). </li><li> <a href="http://misterdai.yougeezer.co.uk/2010/03/25/retro-game-interview-ken-silverman-duke-nukem-3d/">25  2010 </a> misterdai.yougeezer.co.uk ( <a href=""></a> ). </li><li> <a href="http://videogamepotpourri.blogspot.ca/2012/05/interview-with-ken-silverman.html">1  2012 </a> videogamepotpourri.blogspot.ca ( <a href=""></a> ). </li></ul><br></li></ul><br> <i>[     <a href="https://habrahabr.ru/post/323684/"></a> .]</i> </div><p>Source: <a href="https://habr.com/ru/post/323426/">https://habr.com/ru/post/323426/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323414/index.html">The history of the engineer-radiophysics, who decided to watch</a></li>
<li><a href="../323416/index.html">Yii2, quick start. The easiest site on Yii2 with static pages without using a database</a></li>
<li><a href="../323420/index.html">My Material Design Framework</a></li>
<li><a href="../323422/index.html">Search without internet. New beta application Yandex</a></li>
<li><a href="../323424/index.html">Search space strategies. AI driver</a></li>
<li><a href="../323430/index.html">GitHub Pages for the site on March 8</a></li>
<li><a href="../323434/index.html">Weekday programmers: how we finalized the cash software after the new law</a></li>
<li><a href="../323436/index.html">How we analyze vulnerabilities using neural networks and fuzzy logic</a></li>
<li><a href="../323438/index.html">HPE SecureMail - The Best Secure Email Software for 2017</a></li>
<li><a href="../323442/index.html">Theoretical foundations of spline interpolation or why IQ tests have no solution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>