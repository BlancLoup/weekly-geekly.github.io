<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DotHill 4824 storage overview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The hero of this review will be the modest DotHill 4824 storage system. Surely many of you have heard that DotHill as an OEM partner is producing entr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DotHill 4824 storage overview</h1><div class="post__text post__text-html js-mediator-article">  The hero of this review will be the modest DotHill 4824 storage system. Surely many of you have heard that DotHill as an OEM partner is producing entry-level storage for Hewlett-Packard ‚Äî the most popular HP MSA (Modular Storage Array) already existing in the fourth generation.  The DotHill 4004 line corresponds to the HP MSA2040 with a few differences, which will be described in detail below. <br><br>  DotHill is a classic entry level storage system.  Form factor, 2U, two options for different drives and with a large variety of host interfaces.  Mirrored cache, two controllers, asymmetric active-active with ALUA.  Last year, a new functionality was added: disk pools with three-level tiering (tier data storage) and SSD cache. <br><br><br><img src="https://habrastorage.org/files/3ca/408/baf/3ca408baff8e4a518a422418ea34649c.jpg"><a name="habracut"></a><br><h4>  Specifications </h4><br><ul><li>  Form factor: 2U 24x 2.5 "or 12x 3.5" </li><li>  Interfaces (per controller): 4524C / 4534C - 4x SAS3 SFF-8644, 4824C / 4834C - 4x FC 8 Gbit / s / 4x FC 16 Gbit / s / 4x iSCSI 10 Gbit / s SFP + (depending on the used transceivers) </li><li>  Scaling: 192 2.5 "disks or 96 3.5" disks, supports up to 7 additional disk shelves </li><li>  RAID support: 0, 1, 3, 5, 6, 10, 50 </li><li>  Cache (per controller): 4GB with flash protection </li><li>  Functionality: snapshots, volume cloning, asynchronous replication (except SAS), thin provisioning, SSD cache, 3-level tiering (SSD, 10 / 15k HDD, 7.2k HDD) </li><li>  Configuration limits: 32 arrays (vDisk), up to 256 volumes per array, 1024 volumes per system </li><li>  Management: CLI, Web-interface, SMI-S support </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Disk pools in DotHill </h4><br>  For those who are not familiar with the theory, it is worthwhile to talk about the principles of operation of disk pools and longline storage.  More precisely, about specific implementation in DotHill. <br><br>  Before the advent of pools, we had two limitations: <br><ul><li>  The maximum size of the disk group.  RAID 10, 5 and 6 can have a maximum of 16 drives.  RAID-50 - up to 32 drives.  If you need a volume with a large number of spindles (for the sake of performance and / or volume), then you had to combine LUNs on the host side. <br></li><li>  Non-optimal use of fast drives.  You can create a large number of disk groups for several load profiles, but with a large number of hosts and services on them, constantly monitor performance, volume and periodically make changes becomes difficult. <br></li></ul><br><br>  A disk pool in a DotHill storage system is a collection of several disk groups with load distribution between them.  From the point of view of performance, the pool can be considered as a RAID-0 of several subarrays, i.e.  we are already solving the problem of short disk groups.  In total, only two disk pools are supported on the storage system, A and B, one for the controller), each pool can have up to 16 disk groups.  The main architectural difference is the maximum use of free placement of stripe on disks.  Several features and features are based on this feature: <br><ul><li>  <b>Thin Provisioning</b> (thin allocation of resources).  The technology is not new, even those who have not seen a single storage system have seen it, for example, in desktop hypervisors.  On top of the pool or a regular linear disk group, volumes are created, which are then presented to the hosts.  Disk space under the ‚Äúthin‚Äù volume is not reserved immediately, but only as it is filled with data.  This allows you to pre-allocate the necessary disk space, taking into account growth forecasts and allocate more space than it actually is.  In the future, either expanding the system will not be necessary at all (not all volumes will actually use the allocated volume), or we will be able to add the required number of disks without resorting to complex manipulations (data transfer, an increase in LUNs and file systems on them, etc. ).  If you are afraid of a possible situation with a lack of capacity, you can disable over-provisioning in the pool settings, and allocate more disk space than is available, it will not work. <br><br>  When using <i>Thin Provisioning,</i> it is important to ensure a reverse process ‚Äî returning unused disk space back to the pool (space reclamation).  When deleting a storage file, it will not be able to learn about the release of the corresponding blocks, unless additional steps are taken.  Once, storage systems with <i>space reclamation</i> support could only rely on periodic zeros from the host (for example, using SDelete), but now almost all (and, of course, DotHill) support the SCSI UNMAP command (similar to the well-known TRIM in the ATA command set ). <br><br></li><li>  <b>The ability to transparently add and remove pool elements</b> .  In traditional RAID arrays, it is often possible to expand the array by adding disks, but most disk pool implementations, including those from DotHill, allow you to add or remove a disk group without losing data.  Blocks from this group will be redistributed to the remaining groups in the pool.  Naturally, provided there are enough free blocks. <br></li><li>  <b>Tiering (tiered data storage).</b>  Instead of distributing volumes with different performance requirements across different disk groups, you can combine volumes on disks with different capacities into a common pool and rely on automatic block migration between three <i>tiers</i> with different capacities.  The criterion for migration is the load intensity with random access.  More often requested blocks ‚Äúfloat up‚Äù, rarely used ‚Äúsettle‚Äù on slow disks. <br><br>  There are three fixed tiers in the DotHill storage system: Archive (archived, 7200 rpm disks), Standard (standard, ‚Äúreal‚Äù SAS disks 10/15 thousand rpm) and Performance (productive, SSD).  In this regard, there is a chance to get an incorrectly working configuration, consisting, for example, of a dozen 7200 disks and a pair of 15k disks.  DotHill will consider a mirror from a pair of 15k-disks as more productive and transfer ‚Äúhot‚Äù data to it. <br><br>  When planning a configuration with tiering, you should take into account that you will always get a performance boost with some delay - the system needs time to move the blocks to the desired tier.  The second point is the primitiveness of organizing tiering in DotHill 4004, i.e.  the inability to assign volumes to priorities.  There are no complicated structures with profiles and <i>tier affinity</i> , as in DataCore or some midrange class storage systems, there is no entry level storage system.  Want guaranteed performance immediately and always?  Use regular disk groups.  Another alternative to tiering in DotHill is SSD cache, the details of which will be implemented below. <br><br>  DotHill 4004 has a simple and visual tool for analyzing pool utilization efficiency: <br><br><img src="https://habrastorage.org/files/6c1/64d/b0a/6c164db0aa114fc694ca58c3faffe7bc.png"><br><br>  This is a screenshot from the <i>Pools</i> tab of the new Storage Management Console (SMC) v3 web interface (this is called SMU for HP).  You can see a pool consisting of two tiers: Standard (2 disk groups) and Performance.  You can immediately understand how the data is distributed in the pool, and how much space is allocated on each tier: one volume has just been created and it is not filled with real data, so only 8 with a small MB are actually allocated. <br><br>  The second screenshot, performance: <br><br><img src="https://habrastorage.org/files/474/209/6ba/4742096baa7248338422d199a66ca8fc.png"><br><br>  Currently running load test after pre-filling the volume.  We can see how much each layer in the pool gives in IOPS and throughput.  The space for new units initially stands out on the Standard tier, and here the migration process on the Performance tier is already visible under the influence of the load. <br><br></li></ul><br><h4>  Differences from HP MSA2040 </h4><br><ol><li>  <b>MSA 2040 is an HP product</b> , with all the consequences and benefits.  First of all - an extensive network of service centers and the ability to purchase various packages of extended support.  Only the distributors and their partners are engaged in the Russian-language support and maintenance of DotHill.  All that remains is the optional 8x5 support with the next business day response and the delivery of spare parts the next business day. <br><br>  Documentation is completely identical to HP's, with the exception of names and logos, i.e.  equally high quality and detailed.  Of course, HP has many additional FAQs, best practices, descriptions of reference architectures involving MSA2040.  The HP web interface (HP SMU) differs only in a company font and icons. <br><br>  <b>Price</b>  Of course, nothing is given in vain.  The price for MSA2040 in common configurations (two controllers, 24 450-600GB 10k disks, 8Gbit FC transceivers) is about 30% higher than the DotHill 4004. Of course, without CarePacks.  Also excluding HP's separately expanding number of snapshots (from 64 to 512) and asynchronous replication (Remote Snap), which add several thousand USD to the cost of the solution.  Our statistics show that additional CarePacks for MSA in the territory of the Russian Federation are extremely rarely bought, after all, this is a budget segment.  The implementation in most cases is carried out on its own, sometimes it is carried out by the supplier within the framework of a common project, extremely rarely by HP engineers. <br><br></li><li>  <b>Discs</b> .  DotHill and HP have ‚Äútheir own‚Äù, that is, HDD and SSD with non-standard firmware are used, the slide comes with disks.  DotHill offers only nearline SAS from 3.5 "disks, i.e., with a spindle speed of 7200 rpm, i.e. <s>all fast disks - only 2.5"</s> *.  HP offers 300, 450 and 600GB 15,000 rpm disks in a 3.5 "version. <br>  * <b>Update 03/25/2015:</b> 10k and 15k disks in the 3.5 "version of DotHill are still available on request. <br></li><li>  <b>Related products</b> .  HP MSA 1040 is a budget version of MSA 2040 with certain limitations: <br><ul><li>  No SSD support.  Optional auto-tiering is still there, it's just 2-level. </li><li>  Smaller host ports - 2 per controller instead of 4.  There is no support for 16Gbps FC and SAS. </li><li>  Fewer disks - only 3 additional disk shelves instead of 7. </li></ul><br><br><img src="https://habrastorage.org/files/3ca/408/baf/3ca408baff8e4a518a422418ea34649c.jpg"><br><br>  So if you do not need all the features of MSA 2040, then you can save about 20% and get very close to the cost of the "original" (but full-featured). <br><br>  DotHill has another variation - the <a href="http://www.dothill.com/storage-arrays/high-density-san-storage/">AssuredSAN Ultra</a> series.  These are storage systems with exactly the same controllers, functionality and control interface as the 4004 series, but with a high disk density: <i>Ultra48</i> - 48x 2.5 "in 2U and <i>Ultra56</i> - 56x 3.5" in 4U. <br><img src="https://habrastorage.org/files/6a9/d56/55f/6a9d5655f30644998724af2f10a83abe.jpg"><br><img src="https://habrastorage.org/files/932/89a/e52/93289ae5293b470489d002bed71e4257.jpg"><br><br></li></ol><br><br><h4>  Performance </h4><br><br><h5>  Storage configuration </h5><br><ul><li>  DotHill 4824 (2U, 24x2.5 ") </li><li>  Firmware Version: GL200R007 (last at the time of testing) </li><li>  RealTier 2.0 Activated License </li><li>  Two controllers with CNC ports (FC / 10GbE), 4 8Gbit FC transceivers (installed in the first controller) </li><li>  20x 146GB 15 thousand rpm SAS HDD (Seagate ST9146852SS) </li><li>  4x 400GB SSD (HGST HUSML4040ASS600) </li></ul><br><h3>  Host configuration </h3><br><ul><li>  Platform Supermicro 1027R-WC1R </li><li>  2x Intel Xeon E5-2620v2 </li><li>  8x 8GB DDR3 1600MHz ECC RDIMM </li><li>  480GB SSD Kingston E50 </li><li>  2x Qlogic QLE2562 (2-port 8Gbps FC HBA) </li><li>  CentOS 7, fio 2.1.14 </li></ul><br>  Connection was made through one controller, direct, through 4 8Gbps FC ports.  Naturally, the mapping of volumes to the host was through 4 ports, and multipath was configured on the host. <br><h3>  Pool with tier-1 and SSD cache </h3><br>  This test is a three-hour (180 cycles of 60 seconds) load with random access by 8KiB blocks (8 threads with a queue depth of 16 each) with a different read / write ratio.  The entire load is focused on the 0-20GB area, which is guaranteed to be less than the amount of performance tier or cache on an SSD (800GB) - this is done to quickly fill the cache or tier in a reasonable time. <br><br>  Before each test run, the volume was created anew (to clear the SSD-tier or SSD cache), was filled with random data (sequential write in 1MiB blocks), the volume was not read ahead.  The values ‚Äã‚Äãof IOPS, average and maximum delay were determined within each 60-second cycle. <br><br>  Tests with 100% reading and 65/35 reading + writing were performed both with SSD-tier (a disk group of 4x400GB SSD in RAID-10 was added to the pool) and with SSD cache (2x400GB of SSD in RAID-0, storage does not allow adding more than two SSDs to the cache for each pool).  The volume was created on a pool of two RAID-6 disk groups of 10 46-GB disks of 15 thousand SPS rpm (that is, in fact, this is RAID-60 according to the 2x10 scheme).  Why not 10 or 50?  To intentionally complicate random storage for storage systems. <br><br><h4>  Iops </h4><br>  The results were quite predictable.  As the vendor claims, the advantage of SSD cache over SSD tier is in filling the cache faster, i.e.  DSS reacts faster to the appearance of ‚Äúhot‚Äù areas with an intense load on random access: 100% reading IOPS grow together with a drop in delay faster than using tier'ing. <br><br>  This advantage ends as soon as a significant write load is added.  RAID-60, to put it mildly, is not very suitable for random recording in small blocks, but this configuration was chosen specifically to show the essence of the problem: DSS cannot cope with the recording, because  it bypasses the cache for a slow RAID-60, the queue is quickly clogged, there is little time to service read requests, even taking into account caching.  Some blocks get there all the same, but quickly become invalid, because there is a record.  This vicious circle leads to the fact that with such a load profile, the cache that works only on reading becomes ineffective.  Exactly the same situation could be observed with the early versions of the SSD cache (before the appearance of Write-Back) in PCI-E RAID controllers LSI and Adaptec.  The solution is to use an initially more productive volume, i.e.  RAID-10 instead of 5/6/50/60 and / or SSD-tier instead of cache. <br><br><img src="https://habrastorage.org/files/865/26b/c37/86526bc3713c4d4e8ea9817f50c8c480.png"><br><h4>  Average delay </h4><br><img src="https://habrastorage.org/files/193/208/1e8/1932081e8b474d78ade79fc7bba02aa9.png"><br><h4>  Maximum delay </h4><br>  This graph uses a logarithmic scale.  In case of 100% SSD cache usage, you can see a more stable delay value - after filling the cache, the peak values ‚Äã‚Äãdo not exceed 20ms. <br><img src="https://habrastorage.org/files/11d/5c9/6cc/11d5c96cc73f455ebfbe5d1ee239d3b9.png"><br>  What can be summed up in the dilemma of "caching versus long-term storage (tiering)"? <br>  What to choose? <br><ul><li>  Filling cache is faster.  If your load consists of primary random reading and at the same time the area of ‚Äã‚Äã"hot" periodically changes, then you should choose a cache. </li><li>  Saving "fast" volume.  If the ‚Äúhot‚Äù data fits entirely in the cache, but not in the SSD-tier, then the cache may be more efficient.  The SSD cache in DotHill 4004 is read-only, so a RAID-0 disk group is created for it.  For example, with 4 SSDs of 400GB, you can get 800GB of cache for each of the two pools (1600GB total) or 2 times less with tiering (800GB for one pool or 400GB for two).  Of course, there is another option 1200GB in RAID-5 for one pool, if the second does not need SSD. <br><br>  On the other hand, the total net pool size when using tiering will be greater due to the storage of only one copy of the blocks. <br><br></li><li>  The cache does not affect the performance of sequential access.  When caching does not move blocks, only copying.  With a suitable load profile (random reading in small blocks with repeated access to the same LBA), the DSS issues data from the SSD cache, if they are there, or from the HDD and copies them to the cache.  When a load with sequential access appears, the data will be read from the HDD.  Example: a pool of 20 10 or 15k HDD can give about 2000MB / s for sequential reading, but if the required data is on a disk group from a pair of SSDs, we will get about 800MB / s.  Whether it is critical or not depends on the actual storage usage scenario. </li></ul><br><h3>  4x SSD 400GB HGST HUSML4040ASS600 RAID-10 </h3><br>  The volume was tested on a linear disk group - RAID-10 out of four 400GB SSDs.  In this delivery of DotHill, HGST HUSML4040ASS600 turned out to be abstract ‚Äú400GB SFF SAS SSD‚Äù.  This is an <a href="http://www.hgst.com/solid-state-storage/enterprise-ssd/sas-ssd/ultrastar-ssd400m">Ultrastar SSD400M SSD</a> with a fairly high declared performance (56000/24000 IOPS 4KiB read / write), and most importantly - a resource of 10 overwrites per day for 5 years.  Of course, now in the arsenal of HGST there are more productive SSD800MM and SSD1600MM, but for DotHill 4004 there is quite enough of these. <br><br>  We used tests designed for single SSDs - ‚ÄúIOPS Test‚Äù and ‚ÄúLatency Test‚Äù from the SNIA Solid State Storage Performance Test Specification Enterprise v1.1: <br><ul><li>  <b>IOPS Test</b> .  The number of IOPS (I / O operations per second) is measured for blocks of various sizes (1024KiB, 128KiB, 64KiB, 32KiB, 16KiB, 8KiB, 4KiB) and random access with different read / write ratio (100/0, 95/5, 65/35, 50/50, 35/65, 5/95, 0/100).  8 threads were used with a queue depth of 16. <br></li><li>  <b>Latency Test</b> .  The average and maximum delay values ‚Äã‚Äãare measured for different block sizes (8KiB, 4KiB) and read / write ratios (100/0, 65/35, 0/100) at the minimum queue depth (1 flow with QD = 1). <br></li></ul><br>  The test consists of a series of measurements - 25 rounds of 60 seconds.  Preload - sequential recording in blocks of 128KiB until reaching 2x capacity.  The steady state window (4 rounds) is checked by plotting.  Criteria of steady state: linear approximation within the window should not exceed the limits of 90% / 110% of the average value. <br><br><br><h4>  SNIA PTS: IOPS test </h4><br><img src="https://habrastorage.org/files/122/883/8eb/1228838eb7c04ac78a6ab05e46cde4c8.png"><br>  As expected, the stated limit of the performance of a single small block IOPS controller was achieved.  For some reason, DotHill indicates 100000 IOPS for reading, and HP for MSA2040 - more realistic 80000 IOPS (40 thousand per controller), which we see on the graph. <br><br>  For the test, a single HGST HGST HUSML4040ASS600 SSD was tested with a SAS HBA.  On the 4KiB block, about 50 thousand IOPS were received for reading and writing, with saturation (SNIA PTS Write Saturation Test) the record was dropped to 25-26 thousand IOPS, which corresponds to the characteristics stated by HGST. <br><br><h4>  SNIA PTS: Latency Test </h4><br>  Average delay (ms): <br><img src="https://habrastorage.org/files/1f2/29e/f07/1f229ef07cf74c55bb94bb744d42a80c.png"><br>  Maximum delay (ms): <br><img src="https://habrastorage.org/files/cae/e3c/bc8/caee3cbc864842db866f95cf04e5b3af.png"><br>  The average and peak delay values ‚Äã‚Äãare only 20-30% higher than those for a single SSD when connected to the SAS HBA. <br><br><h4>  Conclusion </h4><br>  Of course, the article turned out to be somewhat chaotic and does not answer the several important questions: <br><ul><li>  Comparison in a similar configuration with products of other vendors: IBM v3700, Dell PV MD3 (and other descendants of LSI CTS2600), Infrotrend ESDS 3000, etc. The storage systems come to us in different configurations and, as a rule, not for long - you need to load and / or to introduce. <br></li><li>  The storage bandwidth limit has not been tested.  We managed to see about 2100MB / s (RAID-50 from 20 disks), but I didn‚Äôt test the sequential load due to insufficient number of disks.  I am sure that the claimed 3200/2650 MB / s for reading / writing would be possible to get. <br></li><li>  There is no useful, in many cases, IOPS vs latency graphics, where by varying the queue depth you can see how much IOPS can be obtained with an acceptable delay value.  Alas, not enough time. <br></li><li>  Best Practices.  I did not want to reinvent the wheel, as there is a <a href="http://h50146.www5.hp.com/products/storage/whitepaper/pdfs/4AA4-6892ENW.pdf">good document for HP MSA 2040</a> .  To it you can add only recommendations for the proper use of disk pools (see above). <br></li></ul><br><br><h4>  Links </h4><br><ul><li>  <a href="http://www.dothill.com/storage-arrays/assuredsan-4000-san-storage/">DotHill AssuredSAN 4004: product page</a> </li><li>  <a href="http://www.dothill.com/storage-arrays/high-density-san-storage/">DotHill AssuredSAN Ultra: product page</a> </li><li>  <a href="http://h50146.www5.hp.com/products/storage/whitepaper/pdfs/4AA4-6892ENW.pdf">HP MSA 1040/2040 Best practices</a> </li><li>  <a href="http://h40195.www2.hp.com/v2/getpdf.aspx/4AA4-7060ENW.pdf%3Fver%3D1.0">HP MSA 2040 Storage Configuration and Best Practices for VMware vSphere</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/253907/">https://habr.com/ru/post/253907/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253895/index.html">Who is this toy for or how to identify the target audience</a></li>
<li><a href="../253899/index.html">Portable hiking weather station MiniBTH</a></li>
<li><a href="../253901/index.html">Self-assembly 3d-printer or purchase ready-made equipment for the design. BY. Part 2</a></li>
<li><a href="../253903/index.html">CLRium, the last announcement before Moscow</a></li>
<li><a href="../253905/index.html">REG.ru has divided part of domains</a></li>
<li><a href="../253909/index.html">(Archive) The first version of the Matreshka.js framework has been released</a></li>
<li><a href="../253913/index.html">JavaScript internationalization API: implementation in Firefox</a></li>
<li><a href="../253917/index.html">Perl 6 and Markov sequences</a></li>
<li><a href="../253919/index.html">Gaming headphones. Sound for gamers. Sound illusions</a></li>
<li><a href="../253921/index.html">Conference ProfsoUX 2015: Review of applications for speeches</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>