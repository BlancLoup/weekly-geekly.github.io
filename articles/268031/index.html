<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Apiway - a new way of client-server data transport</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúYou want to live - not so raskoryachishsya‚Äù ¬© Features of national hunting 

 How often do you have to ‚Äúco-ordinate‚Äù the work of the client and serve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Apiway - a new way of client-server data transport</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ea1/743/824/ea174382456d41deb44e6bb62d5c97f9.jpg" alt="image"><br>  <i>‚ÄúYou want to live - not so raskoryachishsya‚Äù ¬© Features of national hunting</i> <br><br>  How often do you have to ‚Äúco-ordinate‚Äù the work of the client and server parts of the application, organize the exchange of messages, its timeliness, provide access to data and their constant relevance on the client? <br><br>  Often?  Then maybe you will be interested in the idea and implementation described in this article. <br>  It's about Javascript, Ruby and Websockets. <br><a name="habracut"></a><br><h2>  Prelude </h2><br>  At the beginning of this year I published <a href="http://habrahabr.ru/post/248601/">an article</a> about one of my inventions, into the code of which I poured all my thoughts and vision (at that time) on the development of both the frontend and backend.  I did not call anyone to use it, which, in fact, did not happen, I just asked one question - is this another bike? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      After some time, I joined Luciding as a frontend-developer (a young startup promoting the idea of ‚Äã‚Äãlucid dreams).  Since then, and to this day, my work is closely connected with React, and thanks to him, my views on the development have changed dramatically.  Now I can answer myself - my past invention is just another bicycle.  Now I see no point in implementing the client part of the application in accordance with the MVC pattern, the client part is a mirror reflecting the reality occurring on the server, the reality that the user is allowed to see, and all that is needed is data and a tool for visualizing them. <br><br>  React handles the visualization task perfectly, but the task of delivering data to the client and keeping it up to date is implemented by each programmer in its own way and quite often the following approach is used: <br><br>  <strong>Data access</strong> <br>  1. Sending a request to the server to receive actual data. <br>  2. Creating event handlers for their changes, which bring the data (after the next manipulation) to the current state. <br><br>  <strong>Data manipulation</strong> <br>  1. Send a request to the server to change / delete data. <br>  2. Sending notifications (events) about the manipulations to the client. <br><br><h2>  Conception </h2><br>  And everything seems to be good, but if the first points are taken for granted, then the second is a routine that would be nice to automate.  That is what gave rise to the idea of ‚Äã‚Äãa new bicycle in my head - to create a tool that allows you to completely refuse to participate in the delivery / synchronization of data between the client and the server.  The developer should only clearly define what and to whom, and not think about how and when. <br><br><h2>  Childbirth </h2><br>  After the amount of time I wrote ruby ‚Äã‚Äãgem for the implementation of the server part and javascript npm package for the client.  I called my brainchild <strong>Apiway</strong> . <br><br><h4>  Server part </h4><br>  Built on top of the well-known <strong>Sinatra</strong> framework in the ruby ‚Äã‚Äãcommunity, it has generators for quickly creating the structure of a new application and its components. <br><br>  <strong>Components:</strong> <br><ul><li> <strong>Client</strong> - <code>Apiway::Client</code> instance, personal for each connection; </li><li>  <strong>The model</strong> is the usual ActiveRecord model; </li><li>  <strong>The controller</strong> is designed to determine the actions that manipulate the data; </li><li>  <strong>Resource</strong> - responsible for accessing data and providing it to the client. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Details on the components</b> <div class="spoiler_text"><h5>  Customer </h5><br>  Performs parsing of incoming messages, controls the launch of controllers and synchronization of resources.  The current client, always available in the controller and resource code, can be obtained by the <code>client</code> method.  An array of all connected clients can be obtained by calling <code>Apiway::Client.all</code> (in addition, this method accepts a block of code applied to each client). <br>  Each client has its own personal repository, the data in which is stored throughout the entire connection. <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     client[:user_id] = 1 #     client[:user_id] # &gt; 1</span></span></code> </pre> <br>  <strong>Custom client event handlers</strong> <br>  When generating a new application, the file <code>app/base/client.rb</code> , which allows you to configure client connection / disconnection event handling, as well as receive a new message.  Each handler is called in the context of the client whose event is being processed. <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apiway</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Client</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on_connected</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">do</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#       #      end on_message do |message| #       end on_disconnected do #       #       end end end</span></span></span></span></code> </pre> <br><h5>  Model </h5><br>  By default, the new model is inherited from <code>ActiveRecord::Base</code> when it is generated, but this is not necessary, the main thing is that it be extended by the <code>Apiway::Model</code> module.  This module adds to it the only <code>sync</code> method, the call of which starts the process of synchronization of resources depending on this model (automatically called on <code>ActiveRecord</code> models after saving / deleting the model). <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> &lt; ActiveRecord::Base </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apiway::Model</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><h5>  Controller </h5><br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersController</span></span></span><span class="hljs-class"> &lt; ApplicationController </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">include</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Apiway::Controller</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#     Rails # Before- before_action :method_name before_action :method_name, only: :action_name before_action :method_name, only: [ :action_name, :action_name ] before_action :method_name, except: :action_name before_action :method_name, except: [ :action_name, :action_name ] # After- after_action :method_name after_action :method_name, only: :action_name after_action :method_name, only: [ :action_name, :action_name ] after_action :method_name, except: :action_name after_action :method_name, except: [ :action_name, :action_name ] #   action :auth do #        # Api.query("Users.auth", {name: "Bob", pass: "querty"}) # .then(function( id ){ console.log("User id: ", id) }) # .catch(function( e ){ console.log("Error: ", e) }) begin #  params      user = User.find_by! name: params[ :name ], pass: params[ :pass ] rescue Exception =&gt; e #         ,   error #         #  ,    "Error: auth_error" error :auth_error #  error     , , ,  #    before-,      #       else #     client     #  ( Apiway::Client),      # id  client[:user_id] = user.id #          #     ,      id #    "User id: 1" end end end</span></span></span></span></code> </pre> <br><h5>  Resource </h5><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#         # var userMessages = new Resource("UserMessages", {limit: 30}); # userMessages.onChange(function( data ){ console.log("New data", data) }); # userMessages.onError(function( e ){ console.log("Error", e) }); class UserMessagesResource &lt; ApplicationResource include Apiway::Resource #   depend_on Message, User #   ,       Message  User, #      ,    #    #     access do #           #  client ,       , #        :user_id error :auth_error unless client[:user_id] #   error       #  "error"   "auth_error",    #  "Error: auth_error"  ,   "", #  "" ,    ,   #      "change"    #     "New data: [{mgs},{mgs},{mgs}...]" end #    #      ,      #    data do #  params      Message.find_by(user_id: client[:user_id]).limit(params[:limit]).map do |msg| { text: msg.text, user: msg.user.name } end end end</span></span></code> </pre><br></div></div><br><h4>  Client part </h4><br>  Provides the components necessary to interact with the server.  Each component is inherited from the EventEmitter class, I carried it into a separate <a href="https://www.npmjs.com/package/js.event_emitter">package</a> . <br><br>  <strong>Components:</strong> <br><ul><li>  <strong>Api</strong> - an object that provides methods for connecting to the server and sending requests to its controllers; </li><li>  <strong>Resource</strong> - a class whose instances open server resources and always contain relevant data; </li><li>  <strong>Store</strong> is an empty object, designed to transfer ‚Äúcommon‚Äù data between different parts of the client part of the application. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Details on the components</b> <div class="spoiler_text"><h5>  Developments </h5><br>  Each client-side object has the following methods: <br><pre> <code class="javascript hljs">.on(event, callback[, context]) <span class="hljs-comment"><span class="hljs-comment">//   callback   event; .one(event, callback[, context]) //   .on(),      ; .off() //     ; .off(event) //     event; .off(event, callback) //   callback  event; .off(event, callback, context) //   callback  event, //    context;</span></span></code> </pre><br><h5>  Api </h5><br>  <strong>Generated events</strong> <br><ul><li>  <strong>ready</strong> - generated after setting up the connection and successfully fulfilling the promise <i>beforeReadyPromise</i> ; </li><li>  <strong>unready</strong> ‚Äî generated after the connection is established and the ‚Äúfailure‚Äù to fulfill the promise <i>beforeReadyPromise</i> ; </li><li>  <strong>error</strong> - generated in case of errors in connection with the server; </li><li>  <strong>disconnect</strong> - generated when disconnecting from the server. </li></ul><br>  <strong>Methods</strong> <br><pre> <code class="javascript hljs">Api.connect(address[, options ]) <span class="hljs-comment"><span class="hljs-comment">//      //  : // aliveDelay -  ( )   "ping" , , //   ,       Api.query( "Messages.new", params ) //     new  MessagesController'a //   params    Api.disconnect() //     Api.beforeReadyPromise( callback ) //  ,   (Promise) //         //        // "ready" -     "unready" -   //    , ,   //     Api.onReady(callback, context) //  Api.on("ready", callback, context) Api.oneReady(callback, context) //  Api.one("ready", callback, context) Api.offReady(callback, context) //  Api.off("ready", callback, context) Api.onUnready(callback, context) //  Api.on("unready", callback, context) Api.oneUnready(callback, context) //  Api.one("unready", callback, context) Api.offUnready(callback, context) //  Api.off("unready", callback, context)</span></span></code> </pre> <br><h5>  Resource </h5><br>  <strong>Generated events</strong> <br><ul><li>  <strong>change</strong> - generated when updating resource data; </li><li>  <strong>error</strong> - generated when an error occurs (call the <code>error</code> method on the server). </li></ul><br>  <strong>Methods</strong> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Resource(<span class="hljs-string"><span class="hljs-string">"Messages"</span></span>, {<span class="hljs-attr"><span class="hljs-attr">limit</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>}) <span class="hljs-comment"><span class="hljs-comment">//   MessagesResource   {limit: 10} resource.name //     resource.data //     resource.get("limit") //    limit,   : 10 resource.set({limit: 20, order: "ask"}) //    limit     order //      resource.unset("order") //   order //      resource.onChange(callback, context) //  resource.on("change", callback, context) resource.oneChange(callback, context) //  resource.one("change", callback, context) resource.offChange(callback, context) //  resource.off("change", callback, context) resource.onError(callback, context) //  resource.on("error", callback, context) resource.oneError(callback, context) //  resource.one("error", callback, context) resource.offError(callback, context) //  resource.off("error", callback, context)</span></span></code> </pre><br></div></div><br><h2>  Taming </h2><br>  Consider creating a simplest console chat using <strong>Apiway</strong> . <br><br><h4>  Server part </h4><br>  First, install <strong>Apiway</strong> and generate an application framework: <br><pre> <code class="bash hljs">$ gem install apiway <span class="hljs-comment"><span class="hljs-comment">#  gem'a $ apiway new Chat #    $ cd Chat #    </span></span></code> </pre><br>  Through migrations, we will create the <strong>Messages</strong> table in the database: <br><pre> <code class="bash hljs">$ bundle <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> rake db:create_migration NAME=create_messages</code> </pre><br>  Add the code that forms the table: <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># db/mirgations/20140409121731_create_messages.rb class CreateMessages &lt; ActiveRecord::Migration def change create_table :messages do |t| t.text :text t.timestamps null: true end end end</span></span></code> </pre> <br>  And run the migrations: <br><pre> <code class="bash hljs">$ bundle <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> rake db:migrate</code> </pre><br>  <strong>Now create a model:</strong> <br><pre> <code class="bash hljs">$ apiway generate model Message</code> </pre><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># app/models/message.rb class Message &lt; ActiveRecord::Base include Apiway::Model #         #    ,        validates :text, presence: { message: "blank" }, length: { in: 1..300, message: "length" } end</span></span></code> </pre> <br>  <strong>Then the resource:</strong> <br><pre> <code class="bash hljs">$ apiway generate resource Messages</code> </pre><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># app/resources/messages.rb class MessagesResource &lt; ApplicationResource include Apiway::Resource # ,       Message depend_on Message #  ,         data do Message.limit( params[ :limit ] ).order( created_at: :desc ).reverse.map do |message| { id: message.id, text: message.text } end # params - ,    ,     #    params = {limit: 10}      10   # [{id: 10, text: "Hello 10"}, {id: 9, text: "Hello 9"}, {id: 8, text: "Hello 8"}, ...] end end</span></span></code> </pre><br>  <strong>And finally - the controller:</strong> <br><pre> <code class="bash hljs">$ apiway generate controller Messages</code> </pre><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># app/controllers/messages.rb class MessagesController &lt; ApplicationController include Apiway::Controller #  ,    action :new do begin # params -     current_user.messages.create! text: params[ :text ] rescue ActiveRecord::RecordInvalid =&gt; e #       error e.record.errors.full_messages else true #   ,    end end end</span></span></code> </pre> <br>  On this, the server part is completed, we will start the server with the command: <br><pre> <code class="bash hljs">$ apiway server</code> </pre><br><h4>  Client part </h4><br>  I think that the overwhelming majority know what npm, gulp, grunt, browserify, etc. is, so I will not write about the intricacies of the build, but I‚Äôll just describe the main points. <br><br>  Install apiway: <br><pre> <code class="bash hljs">npm install apiway --save</code> </pre><br>  Actually, the client part itself (as simple as 3 kopecks and fits in a few lines): <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// source/app.js import { Api, Resource } from "apiway"; //    var Chat = { run: function(){ //      Messages   { limit: 10 } var messagesResource = new Resource( "Messages", { limit: 10 } ); //          render messagesResource.onChange( this.render ); //   send   window window.send = this.send; }, render: function( messages ){ //      console.clear(); //      messages.forEach( function( item ){ console.log( item.text ) }); }, send: function( text ){ //        new  Messages Api.query( "Messages.new", { text: text } ) //        console.warn .catch( function( errors ){ console.warn( errors.join( ", " ) ) }); } }; Api //          .connect( "ws://localhost:3000", { aliveDelay: 5000 } ) //      ,    .oneReady( function( e ){ Chat.run() }); // ""       // ,     onReady(),    //         </span></span></code> </pre> <br>  That's all.  Now, to see the result, open the browser, then the console and see the last ten chat messages, write <code>send("Hello world")</code> and again see the last ten messages, or rather our new and nine previous ones.  We try to send an empty message - we see errors. <br><div class="spoiler">  <b class="spoiler_title">Client side using React</b> <div class="spoiler_text">  First we create the <strong>Message</strong> component, it will be responsible for displaying the message: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ./components/Message.jsx import React from "react"; class Message extends React.Component { render(){ return ( &lt;div&gt; &lt;b&gt;{ this.props.data.user }&lt;/b&gt; &lt;p&gt;{ this.props.data.text }&lt;/p&gt; &lt;/div&gt; ); } } export default Message;</span></span></code> </pre> <br>  Now the <strong>Chat</strong> component itself: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ./components/Chat.jsx import React from "react"; import Message from "./Message.jsx"; import { Api, Resource } from "apiway"; //  ,     //        let errorsMsg = { "Text blank": "    ", "Text length": "     1  300 " }; class Chat extends React.Component { constructor( props ){ //     super( props ); this.state = { messages: [], errors: [] }; } componentDidMount(){ //     ,  //  Messages   { limit: 30 } this.MessagesResource = new Resource( "Messages", { limit: 30 } ); //       this.MessagesResource.onChange(( messages )=&gt;{ this.setState({ messages }) }); //  callback        } componentWillUnmount(){ //      this.MessagesResource.destroy(); } onKeyUp( e ){ //     Enter'    ,   if( e.keyCode !== 13) return; //     new  Messages,   {text: " "} Api.query( "Messages.new", { text: e.target.value } ) //   (Promise) .then( ()=&gt;{ this.setState({ errors: [] }) }, ( errors )=&gt;{ this.setState({ errors }) }); //    -  ,    -   } render(){ return ( &lt;div&gt; //   &lt;div&gt; { this.state.messages.map( ( message )=&gt;{ return &lt;Message data={ message } key={ message.id } /&gt;; } ) } &lt;/div&gt; //   &lt;input type="text" onKeyUp={ ( e )=&gt; this.onKeyUp( e ) } /&gt; //   &lt;div&gt; { this.state.errors.map( function( key ){ return errorsMsg[ key ]; }).join( ", " ) } &lt;/div&gt; &lt;/div&gt; ); } } export default Chat;</span></span></code> </pre> <br>  And finally, we will edit the <strong>app.js</strong> file <strong>.</strong> <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Chat <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./components/Chat.jsx"</span></span>; Api <span class="hljs-comment"><span class="hljs-comment">//    .connect( `ws://localhost:3000`, { aliveDelay: 5000 } ) .oneReady( function( e ){ // ,      ,    React.render( &lt;Chat /&gt;, document.getElementById( "app" ) ); });</span></span></code> </pre> <br></div></div><br><br><h2>  But what is going on then? </h2><br>  As you can see, we have never directly resorted to synchronizing data with the client - <strong>Apiway</strong> did this work for us.  How did and in what magic - consider more: <br><br><ul><li>  When sending a request to an action of the server controller, <strong>Apiway</strong> remembers all the models that have undergone changes during the execution of the action; in our case, a new <strong>Message</strong> model was created; </li><li>  after the action is completed, synchronization of all resources dependent on the modified models is started, in our case these are all instances of the <strong>MessagesResource</strong> resource; </li><li>  the resource makes a new sample of models, generates the actual data and converts it into a JSON string (it also remembers the JSON string that is currently on the client), then the two strings are compared and the patch is calculated (the minimum instruction for converting old data into new - this allows you to significantly save traffic); </li><li>  then the weighting of the complete data and the patch occurs, after which what is less in volume is sent to the client; </li><li>  the client resource, having received a new instruction, applies it to its data and generates a " <strong>change</strong> " event. </li></ul><br><br><h2>  Subtleties of character </h2><br>  <strong>What happens if the connection to the server disappears?</strong> <br>  Everything will be fine!  The client will automatically reconnect and, as soon as the connection is established, all resources synchronize their data to the current state, and during the absence of a ‚Äúconnection‚Äù, the data loaded earlier will be available. <br><br>  <strong>What format should be the data generated by the resource?</strong> <br>  Anyone!  Anything that can be converted to JSON, be it a hash, an array, a string, a number, or any other object that has the <code>as_json</code> method <code>as_json</code> . <br><br>  <strong>Can I change the parameters of an open resource?</strong> <br>  Can!  A typical example: load message history when scrolling.  It is implemented by an elementary change of the resource parameter <code>messageResource.set({limit: 50})</code> - the resource will load the last 50 messages and generate the " <strong>change</strong> " event. <br><br><h2>  Heels of achilles </h2><br>  <strong>Many database queries</strong> <br>  Yes this is true!  Skillful use of caching of frequent requests can help in this case. <br><br>  <strong>The patch calculation procedure is relatively slow.</strong> <br>  Yes, the larger the amount of data, the more time is needed for the calculation.  You can of course cut out this functionality altogether, but then the amount of ‚Äúchased‚Äù traffic will increase significantly.  Here it is necessary to think about a compromise. <br><br>  I consider the data and drawbacks to be significant, but at the moment <strong>Apiway</strong> is an example of implementation and is only suitable for projects with a low load. <br><br><h2>  Give it a touch! </h2><br>  <a href="http://apiway.herokuapp.com/">Chat</a> is a slightly more complex example with simple authentication. <br>  <a href="https://github.com/4urbanoff/apiway_example">Chat source on Github</a> <br>  <a href="https://github.com/4urbanoff/rb.apiway">Apiway server-side sources on Github</a> <br>  <a href="https://github.com/4urbanoff/js.apiway">Apiway client-side sources on Github</a> <br>  I apologize in advance for the ‚Äúclumsiness‚Äù of English (at the level of intuition) in the readme repositories. <br><br><h2>  Thank! </h2><br>  I thank all the readers who have found time to read this article.  I will be glad to your criticism, any help and just support. <br>  Sincerely, Denis. </div><p>Source: <a href="https://habr.com/ru/post/268031/">https://habr.com/ru/post/268031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268019/index.html">Network for the smallest. Micro issue ‚Ññ5. Networking FAQ</a></li>
<li><a href="../268021/index.html">Microsoft scared users of Windows 7</a></li>
<li><a href="../268023/index.html">The story of a "hack" or How Yahoo gave me a login and password from someone else's mail</a></li>
<li><a href="../268025/index.html">How-to: The process of creating the layout of html-letters</a></li>
<li><a href="../268029/index.html">Security vulnerability detected in WinRAR software</a></li>
<li><a href="../268033/index.html">We balance the mechanics in games</a></li>
<li><a href="../268035/index.html">Bad "Spring" or as the reasons for the delays were looking for</a></li>
<li><a href="../268037/index.html">Preparing ASP.NET5, issue number 4 - details about routing</a></li>
<li><a href="../268039/index.html">Predicting Titanic Passenger Survival with Azure Machine Learning</a></li>
<li><a href="../268047/index.html">Asterisk. This time, as a background music broadcasting system with the possibility of emergency notification</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>