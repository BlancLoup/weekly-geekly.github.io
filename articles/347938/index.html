<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Chromium: using unreliable data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We bring to your attention a series of articles devoted to recommendations for writing high-quality code using the example of errors found in the Chro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Chromium: using unreliable data</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/58c/b89/aaf/58cb89aafeb3e2044966c86c66ef7090.png" alt="PVS-Studio, Common Weakness Enumeration" align="left">  We bring to your attention a series of articles devoted to recommendations for writing high-quality code using the example of errors found in the Chromium project.  This is the fifth part, which will be devoted to errors in the use of unverified or incorrectly verified data.  A very large number of vulnerabilities exist due to the use of unverified data, which makes this topic interesting and relevant. <br><br>  In fact, the cause of the vulnerability can be almost any type of error, even a common typo.  Actually, if the error found is classified according to the <a href="https://cwe.mitre.org/">Common Weakness Enumeration</a> , then it is a potential vulnerability. <br><br>  Starting from version 6.21, the PVS-Studio analyzer has learned to classify the found errors according to the Common Weakness Enumeration and assign them the corresponding CWE ID. <br><a name="habracut"></a><br>  Perhaps readers have already noticed that in previous articles, in addition to the warning number Vxxx, I also quoted a CWE ID.  This means that the errors discussed earlier could theoretically cause vulnerabilities.  The probability of this is small, but it is.  Interestingly, we managed to match this or that CWE ID with almost every warning issued by PVS-Studio.  This means that without planning it, we created an analyzer that can detect a large number of weaknesses :). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Conclusion.</b>  The PVS-Studio analyzer helps to prevent many types of vulnerabilities in advance.  Publication on this topic: " <a href="https://www.viva64.com/ru/b/0514/">How can PVS-Studio help in searching for vulnerabilities?</a> ". <br><br>  In this article, I have compiled errors that could potentially lead to security problems.  I warn you that the choice of errors is very conditional and subjective.  It may well turn out that some kind of vulnerability is disguised as an error, which I called a commonplace typo in one of the previous articles. <br><br>  So, let's consider what security defects I noticed during the analysis of the report issued by PVS-Studio for the Chromium project.  As I wrote in the <a href="https://habrahabr.ru/company/pvs-studio/blog/347536/">introductory article</a> , I looked at the report rather briefly, so there may be other errors that I did not notice.  The task of the article in general terms is to show how some errors can lead to the fact that the program begins to process incorrect or unverified data.  I have not yet decided how best to call such data, and for the time being I will use the term ‚Äúunreliable data‚Äù. <br><br><h2>  Error examples </h2><br>  Chromium project. <br><br><pre><code class="cpp hljs">InstallUtil::ConditionalDeleteResult InstallUtil::DeleteRegistryValueIf(....) { .... ConditionalDeleteResult delete_result = NOT_FOUND; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { LONG result = key.DeleteValue(value_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != ERROR_SUCCESS) { .... delete_result = DELETE_FAILED; } delete_result = DELETED; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delete_result; }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v519/">warning</a> : <a href="https://www.viva64.com/ru/w/v519/">V519</a> CWE-563 The 'delete_result' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 381, 383. install_util.cc 383 <br><br>  The function returns an incorrect status.  As a result, other parts of the program will assume that the function has successfully deleted some value.  The error is that the <i>DELETE_FAILED</i> status is always replaced with the <i>DELETED</i> status. <br><br>  You can fix the error by adding the <i>else</i> keyword: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != ERROR_SUCCESS) { .... delete_result = DELETE_FAILED; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { delete_result = DELETED; }</code> </pre> <br>  Perhaps, the considered error does not reflect the essence of inaccurate data very well.  In this function, the creation of false data, and not their verification or use.  Therefore, let's consider another, more appropriate error. <br><br>  PDFium library (used in Chromium). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">CPVT_WordRange </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPVT_WordRange&amp; that)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (that.EndPos &lt; BeginPos || that.BeginPos &gt; EndPos || EndPos &lt; that.BeginPos || BeginPos &gt; that.EndPos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CPVT_WordRange(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CPVT_WordRange(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(BeginPos, that.BeginPos), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(EndPos, that.EndPos)); }</code> </pre> <br>  PVS-Studio warnings: <br><br><ul><li>  <a href="https://www.viva64.com/ru/w/v501/">V501</a> CWE-570 There are identical sub-expressions 'that.BeginPos&gt; EndPos'  operator.  cpvt_wordrange.h 46 </li><li>  V501 CWE-570 There are identical sub-expressions' that. EndPos &lt;|  operator.  cpvt_wordrange.h 46 </li></ul><br>  The condition is written incorrectly.  To make it easier to notice the error, we reduce the condition: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (E2 &lt; B1 || B2 &gt; E1 || E1 &lt; B2 || B1 &gt; E2)</code> </pre> <br>  Notice that <i>(E2 &lt;B1)</i> and <i>(B1&gt; E2)</i> are one and the same.  Similar to <i>(B2&gt; E1),</i> this is the same as <i>(E1 &lt;B2)</i> . <br><br>  It turns out that not all the necessary checks are performed, and then an incorrect range can be generated, which, in turn, will affect the operation of the program. <br><br>  Now let's look at a large and complex piece of code from the RE2 regular expression library (used in Chromium).  To be honest, I don‚Äôt even understand what is happening here, but in the code there is definitely an anomalous check. <br><br>  First you need to show how some types are declared.  If this is not done, the code will not be very clear. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Rune; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { UTFmax = <span class="hljs-number"><span class="hljs-number">4</span></span>, Runesync = <span class="hljs-number"><span class="hljs-number">0x80</span></span>, Runeself = <span class="hljs-number"><span class="hljs-number">0x80</span></span>, Runeerror = <span class="hljs-number"><span class="hljs-number">0xFFFD</span></span>, Runemax = <span class="hljs-number"><span class="hljs-number">0x10FFFF</span></span>, };</code> </pre> <br>  And now the function with anomaly. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">utfrune</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *s, Rune c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> c1; Rune r; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(c &lt; Runesync) <span class="hljs-comment"><span class="hljs-comment">/* not part of utf sequence */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)s, c); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { c1 = *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)s; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(c1 &lt; Runeself) { <span class="hljs-comment"><span class="hljs-comment">/* one byte rune */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(c1 == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(c1 == c) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return (char*)s; s++; continue; } n = chartorune(&amp;r, s); if(r == c) return (char*)s; s += n; } return 0; }</span></span></code> </pre> <br>  The PVS-Studio analyzer issues a warning on the line, which I noted with the comment "// &lt;=".  Message: <a href="https://www.viva64.com/ru/w/v547/">V547</a> CWE-570 Expression 'c1 == c' is always false.  rune.cc 247 <br><br>  Let's try to figure out why a condition is always false.  First, notice these lines: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(c &lt; Runesync) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strchr</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)s, c);</code> </pre> <br>  If the variable <i>c &lt;0x80</i> , the function will stop its operation.  If the function does not complete its work, but continues it, then we can say for sure that the variable <i>c&gt; = 0x80</i> . <br><br>  Now we look at the condition: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(c1 &lt; Runeself)</code> </pre> <br>  The condition <i>(c1 == c)</i> , marked with the comment "// &lt;=", is satisfied only if <i>c1 &lt;0x80</i> . <br><br>  So, this is what we know about the values ‚Äã‚Äãof variables: <br><br><ul><li>  c&gt; = 0x80 </li><li>  c1 &lt;0x80 </li></ul><br>  It follows that the condition <i>c1 == c is</i> always false.  But it is very suspicious.  It turns out that the <i>utfrune</i> function in the regular expression library does not work as planned.  The consequences of such an error are unpredictable. <br><br>  LibVPX video codec (used in Chromium). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VP9_LEVELS 14 extern const Vp9LevelSpec vp9_level_defs[VP9_LEVELS]; typedef enum { .... LEVEL_MAX = 255 } VP9_LEVEL; static INLINE int log_tile_cols_from_picsize_level( uint32_t width, uint32_t height) { int i; const uint32_t pic_size = width * height; const uint32_t pic_breadth = VPXMAX(width, height); for (i = LEVEL_1; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; LEVEL_MAX; ++i) { if (vp9_level_defs[i].max_luma_picture_size &gt;= pic_size &amp;&amp; vp9_level_defs[i].max_luma_picture_breadth &gt;= pic_breadth) { return get_msb(vp9_level_defs[i].max_col_tiles); } } return INT_MAX; }</span></span></span></span></code> </pre> <br>  PVS-Studio warnings: <br><br><ul><li>  <a href="http://v557/">V557</a> CWE-119 Array overrun is possible.  The value of 'i' index could reach 254. vp9_encoder.h 931 </li><li>  V557 CWE-119 Array overrun is possible.  The value of 'i' index could reach 254. vp9_encoder.h 932 </li><li>  V557 CWE-119 Array overrun is possible.  The value of 'i' index could reach 254. vp9_encoder.h 933 </li></ul><br>  The <i>vp9_level_defs</i> array consists of 14 elements.  In the loop, the variable <i>i</i> , used as the index of the array, varies from 0 to 254. The result: going beyond the array boundary. <br><br>  Well, if this code leads to <a href="https://www.viva64.com/ru/t/0063/">Access Violation</a> .  But in practice, most likely, some random data located after the <i>vp9_level_defs</i> array will be <i>processed</i> . <br><br>  Another similar error of using data outside the array was met in the SQLite library (used in Chromium). <br><br>  First, notice that the <i>yy_shift_ofst</i> array contains 455 elements. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> yy_shift_ofst[] = { <span class="hljs-comment"><span class="hljs-comment">/* 0 */</span></span> <span class="hljs-number"><span class="hljs-number">355</span></span>, <span class="hljs-number"><span class="hljs-number">888</span></span>, <span class="hljs-number"><span class="hljs-number">1021</span></span>, <span class="hljs-number"><span class="hljs-number">909</span></span>, <span class="hljs-number"><span class="hljs-number">1063</span></span>, <span class="hljs-number"><span class="hljs-number">1063</span></span>, <span class="hljs-number"><span class="hljs-number">1063</span></span>, <span class="hljs-number"><span class="hljs-number">1063</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">-19</span></span>, .... <span class="hljs-comment"><span class="hljs-comment">/* 450 */</span></span> <span class="hljs-number"><span class="hljs-number">1440</span></span>, <span class="hljs-number"><span class="hljs-number">1443</span></span>, <span class="hljs-number"><span class="hljs-number">1538</span></span>, <span class="hljs-number"><span class="hljs-number">1542</span></span>, <span class="hljs-number"><span class="hljs-number">1562</span></span>, }</code> </pre> <br>  Also of interest to us are two macros: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> YY_SHIFT_COUNT (454) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> YY_MIN_REDUCE 993</span></span></code> </pre> <br>  The macro <i>YY_SHIFT_COUNT</i> defines the maximum index that can be used to access the elements of the <i>yy_shift_ofst</i> array.  It is not 455, but 454, since the numbering of elements comes with 0. <br><br>  The macro <i>YY_MIN_REDUCE</i> , equal to 993, has nothing to do with the size of the array <i>yy_shift_ofst</i> . <br><br>  Function containing weak validation: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yy_find_shift_action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stateno = pParser-&gt;yytos-&gt;stateno; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( stateno&gt;=YY_MIN_REDUCE ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stateno; <span class="hljs-comment"><span class="hljs-comment">// &lt;= assert( stateno &lt;= YY_SHIFT_COUNT ); do { i = yy_shift_ofst[stateno]; // &lt;= .... }</span></span></code> </pre> <br>  PVS-Studio warning: V557 CWE-125 Array overrun is possible.  The value of 'stateno' index could reach 992. sqlite3.c 138802 <br><br>  The function provides protection that the index when accessing an array should not be greater than a certain value.  Because of a typo, or for some other reason, the wrong constant is used.  It was necessary to use a constant equal to 454, and instead the value of the index is compared with 993. <br><br>  As a result, it is possible to access the array beyond the boundary and read arbitrary invalid data. <br><br>  Note.  Below is the correct <i>assert</i> , but it will not help in the release version. <br><br>  Most likely, the check should be rewritten as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stateno &gt; YY_SHIFT_COUNT) { assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stateno; }</code> </pre> <br>  ICU project (used in Chromium). <br><pre> <code class="cpp hljs">UVector* ZoneMeta::createMetazoneMappings(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnicodeString &amp;tzid) { UVector *mzMappings = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (U_SUCCESS(status)) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (U_SUCCESS(status)) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ures_hasNext(rb)) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mzMappings == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { mzMappings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UVector( deleteOlsonToMetaMappingEntry, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, status); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (U_FAILURE(status)) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mzMappings; uprv_free(entry); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... } .... } } ures_close(rb); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mzMappings; }</code> </pre> <br>  PVS-Studio <a href="https://www.viva64.com/ru/w/v774/">warning</a> : <a href="https://www.viva64.com/ru/w/v774/">V774</a> CWE-416 The mzMappings' pointer was used after the memory was released.  zonemeta.cpp 713 <br><br>  The code is complex, I find it difficult to say for sure if there is a real error here or not.  However, as I understand it, a situation is possible when the function returns a pointer to an already freed memory block.  The correct handler for an incorrect status should reset the pointer: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (U_FAILURE(status)) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mzMappings; mzMappings = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; uprv_free(entry); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>  Now it turns out that the function returned a pointer to the freed memory.  Anything in this memory can be anything and using this invalid pointer will lead to undefined program behavior. <br><br>  The following Chromium project function incorrectly implements protection against negative values. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AXPlatformNodeWin::HandleSpecialTextOffset(LONG* offset) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*offset == IA2_TEXT_OFFSET_LENGTH) { *offset = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;LONG&gt;(GetText().length()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*offset == IA2_TEXT_OFFSET_CARET) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selection_start, selection_end; GetSelectionOffsets(&amp;selection_start, &amp;selection_end); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selection_end &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) *offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; *offset = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;LONG&gt;(selection_end); } }</code> </pre> <br>  PVS-Studio warning: V519 CWE-563 The '* offset' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 3543, 3544. ax_platform_node_win.cc 3544 <br><br>  If the value of the variable <i>selection_end is</i> negative, then the function should return <i>0</i> .  However, because of a typo, <i>0 is</i> written in the wrong place.  The correct code should be: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selection_end &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) selection_end = <span class="hljs-number"><span class="hljs-number">0</span></span>; *offset = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;LONG&gt;(selection_end);</code> </pre> <br>  Because of this error, the function may return a negative number, although it should not.  This is a negative number that can ‚Äúleak‚Äù through the check, and there is inaccurate data. <br><br><h2>  Other errors </h2><br>  To be honest, I do not really like the examples that I cited in the previous section of the article.  There are few of them, and they do not reflect very well the essence of the errors of using invalid data.  I think, over time, I will make a separate article where I will show more vivid examples of mistakes, having collected them from various open source projects. <br><br>  By the way, it was possible to include more examples of errors in the article, but I already ‚Äúspent‚Äù them when writing previous articles, but I don‚Äôt want to repeat myself.  For example, in the article ‚ÄúChromium: typos,‚Äù there was such a fragment: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!posX-&gt;hasDirtyContents() || !posY-&gt;hasDirtyContents() || !posZ-&gt;hasDirtyContents() || !negX-&gt;hasDirtyContents() || !negY-&gt;hasDirtyContents() || <span class="hljs-comment"><span class="hljs-comment">// &lt;= !negY-&gt;hasDirtyContents()) // &lt;=</span></span></code> </pre> <br>  Because of this typo, the object referenced by the <i>negZ</i> pointer is not <i>checked</i> .  As a result, the program will work with unreliable data. <br><br>  Also in this article I did not begin to consider situations where invalid (corrupted) data arise due to the lack of verification of the pointer returned by the <i>malloc</i> function.  If the <i>malloc</i> function <i>returns</i> <i>NULL,</i> this does not mean that only a null pointer dereference is possible.  There are more insidious situations.  Schematically, they look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *ptr = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); ptr[<span class="hljs-number"><span class="hljs-number">1234567</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br>  There will be no null pointer dereference here.  Here the data will be recorded incomprehensibly where and the destruction of some data. <br><br>  This is an interesting story and I will dedicate the following separate article to it. <br><br><h2>  Recommendations </h2><br>  To the emergence and use of unreliable (unverified, corrupted) data lead a variety of errors.  There can be no universal council here.  You can, of course, write: do not make mistakes in the code!  But there is no use for such advice :). <br><br>  So why then did I even write this article and single out this type of error? <br><br>  So that you know about them.  The knowledge of the existence of a problem in itself helps to prevent it.  If someone does not know about a problem, it does not mean that it does not exist.  This picture will be a good illustration: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a12/7ee/841/a127ee8415699e4961f4f07701a6f603.png" alt="Figure 2"></p><br><br>  What can you still advise: <br><br><ol><li>  Update libraries used in your project.  The new versions can be fixed various bugs that represent vulnerabilities.  However, we must admit that the vulnerability may appear just in the new version, and absent in the old one.  But still, a better solution would be to upgrade the libraries.  More people know about old vulnerabilities than about new ones. </li><li>  Carefully check all input data, especially coming from outside.  For example, all data coming from somewhere over the network should be very carefully checked. </li><li>  Use various code verification tools.  For example, the Chromium project clearly lacks the use of the PVS-Studio static analyzer :). </li><li>  Explain to colleagues that "a <a href="https://www.viva64.com/ru/b/0499/">simple error in coding does not mean a non-direst error</a> ."  If your team develops responsible applications, then you should focus as much as possible on the quality of the code and destroy everything, even if they are innocuous for the type of error. </li></ol><br><h2>  Note about PVS-Studio </h2><br>  As I have already said, the PVS-Studio analyzer already helps prevent the appearance of a vulnerability by detecting errors at the stage of writing code.  But we want more and soon we will significantly improve PVS-Studio by introducing the concept of ‚Äúusing unverified data‚Äù into Data Flow analysis. <br><br>  We have even reserved a special number for this important diagnostic: V1010.  Diagnostics will detect errors when data has been received from an unreliable source (for example, sent over the network) and used without proper verification.  The absence of all necessary input data checks is often the cause of detection of vulnerabilities in applications.  We recently wrote about this in more detail in the article " <a href="https://www.viva64.com/ru/b/0547/">PVS-Studio 2018: CWE, Java, RPG, macOS, Keil, IAR, MISRA</a> " (see the section "Potential Vulnerabilities, CWE"). <br><br>  New diagnostics will significantly enhance the analyzer in identifying potential vulnerabilities.  Most likely, the V1010 diagnostics will match the <a href="https://cwe.mitre.org/data/definitions/20.html">CWE-20</a> identifier (Improper Input Validation). <br><br><h2>  Conclusion </h2><br>  I suggest you and your colleagues read the article " <a href="https://www.viva64.com/ru/b/0391/">42 recommendations</a> " on our website.  After it, the programmer will not turn into a security expert, but he will learn a lot of new and useful things.  Especially these articles will be useful to developers who have only recently mastered the language of C or C ++ and who are not aware of how deep the rabbit hole they fall into. <br><br>  I plan to update 42 tips and turn them into 50 tips.  Therefore, I invite you to subscribe to my twitter <a href="https://twitter.com/Code_Analysis">@Code_Analysis</a> and our <a href="http://feeds.feedburner.com/viva64-blog-ru">RSS</a> feed, so as not to miss this and other interesting articles in our blog. <br><br><p> <a href="https://www.viva64.com/en/b/0557/"><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov.  <a href="https://www.viva64.com/en/b/0557/">Chromium: Use of Untrusted Data</a> . </div><p>Source: <a href="https://habr.com/ru/post/347938/">https://habr.com/ru/post/347938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347928/index.html">FPGA for programmer, state machines (verilog)</a></li>
<li><a href="../347930/index.html">Writing a blockchain in less than 200 lines of Go code</a></li>
<li><a href="../347932/index.html">Useful to the designer and developer. Needed at hand news from the community, designed to improve your workflow. Issue number 7</a></li>
<li><a href="../347934/index.html">Security of third-party dependencies - check with snyk</a></li>
<li><a href="../347936/index.html">Olympiad "ITMO VKontakte": weekend in St. Petersburg and +10 points to the exam</a></li>
<li><a href="../347940/index.html">Red Hat absorbs CoreOS</a></li>
<li><a href="../347942/index.html">HR analytics with R</a></li>
<li><a href="../347946/index.html">Vivaldi 1.14 - longitudinally transverse version</a></li>
<li><a href="../347948/index.html">Game Designer. Who is it?</a></li>
<li><a href="../347952/index.html">How to create a truly random and provably secure password</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>