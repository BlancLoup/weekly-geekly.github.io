<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The difference between nginx and apache with examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="During interviews for the linux / unix admin role, many IT companies ask what load average is, how nginx differs from apache httpd, and what fork is. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The difference between nginx and apache with examples</h1><div class="post__text post__text-html js-mediator-article"><p>  During interviews for the linux / unix admin role, many IT companies ask what load average is, how nginx differs from apache httpd, and what fork is.  In this article I will try to explain what they expect to hear in response to these questions, and why. </p><br><p>  It is important to understand the basics of administration very well.  In an ideal situation, when setting a task, the system administrator sets a number of requirements.  If the situation is not ideal, then, in fact, the requirement for the administrator is one: "I want everything to work."  In other words, the service should be available 24/7 and, if some solution does not meet these requirements (scaling and fault tolerance refer to accessibility), then we can say that the administrator has done a poor job.  But if the different solutions of the two administrators work 24/7, how to understand which one is better? </p><br><p>  A good system administrator, when choosing a solution with given requirements, is guided by two conditions: minimum resource consumption and their balanced distribution. </p><br><p>  The variant, when one specialist needs 10 servers to complete the task, and the second is only 2, we will not consider what‚Äôs better here ‚Äî obviously.  Further, under the resources I will understand the CPU (cpu), RAM (ram) and disk (hdd). </p><br><p>  Let's consider the situation: one administrator created a solution that requires 10% cpu, 5% ram and 10% hdd from all your equipment, and the second used 1% cpu, 40% ram and 20% hdd for this.  Which of these solutions is better?  Here everything is no longer so obvious.  Therefore, a good administrator should always be able to correctly select a solution based on the available resources. </p><br><a name="habracut"></a><br><p>  Imagine that we are entry-level programmers, and we are asked to write an elementary program for working with the network.  The requirements are simple: you need to process two connections simultaneously using the tcp protocol and write what we have accepted into a file. </p><br><p>  Before developing an application, you need to remember what tools the Linux operating system provides for us (further in the article all examples are based only on this OS).  In Linux, we have a set of system calls (that is, functions in the OS kernel that we can call directly from our program, thereby forcibly giving the processor time to the kernel): </p><br><p>  1) socket - allocates space in the OS kernel buffer for our socket.  The address of the allocated space is returned from the function to the program; <br>  2) bind - allows you to change the information in the structure of the socket, which was allocated to us by the linux OS on the command socket; <br>  3) listen - just like bind, it changes the data in our structure, allowing the OS to indicate that we want to accept connections on this socket; <br>  4) connect - tells our OS that it should connect to another remote socket; <br>  5) accept - tells our OS that we want to accept a new connection from another socket; <br>  6) read - we ask the OS to give us from its buffer a certain number of bytes, which it received from a remote socket; <br>  7) write - we ask the OS to send a certain number of bytes to the remote socket. </p><br><p>  In order to establish a connection, we need to create a socket in the linux memory, set the necessary data in it and connect to the remote side. </p><br><p>  socket ‚Üí bind ‚Üí connect ‚Üí read / write </p><br><p>  But if you trust the OS to make the selection of the outgoing port for you (as well as the ip address), then bind is optional: </p><br><p>  socket ‚Üí connect ‚Üí read / write </p><br><p>  In order to receive incoming messages, we need to run: </p><br><p>  socket ‚Üí bind ‚Üí listen ‚Üí accept ‚Üí read / write </p><br><p>  Now we know enough to write a program.  We proceed directly to writing using si.  Why si?  Because in this language, commands are called the same as system calls (with rare exceptions, such as fork). </p><br><div class="spoiler">  <b class="spoiler_title">Differ1.c program</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//,    #define PORT_NO 2222 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;netinet/in.h&gt; int main(int argc, char *argv[]) { //,        long buffersize=50; int sockfd, newsockfd; socklen_t clilen; // ,        char *buffer; struct sockaddr_in serv_addr, cli_addr; FILE * resultfile; //   buffer = malloc (buffersize+1); //      resultfile = fopen("/tmp/nginx_vs_apache.log","a"); bzero((char *) &amp;serv_addr, sizeof(serv_addr)); bzero(buffer,buffersize+1); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = INADDR_ANY; serv_addr.sin_port = htons(PORT_NO); //  (),  SOCK_STREAM  tcp/ip . sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd &lt; 0) error("ERROR opening socket"); //   ,    2222   ip  if (bind(sockfd, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) error("ERROR on binding"); //   ,        ,  50 listen(sockfd,50); while (1) { //          newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen); if (newsockfd &lt; 0) error("ERROR on accept"); read(newsockfd,buffer,buffersize); fprintf(resultfile, buffer); fflush (resultfile); } close(sockfd); return 0; }</span></span></code> </pre> </div></div><br><p>  Compile and run our daemon: </p><br><pre> <code class="bash hljs">[tolik@ localhost]$ [tolik@localhost]$ ./differ</code> </pre> <br><p>  Look what happened: </p><br><pre> <code class="bash hljs">[root@ localhost]<span class="hljs-comment"><span class="hljs-comment"># ps axuf | grep [d]iffer tolik 45409 0.0 0.0 4060 460 pts/12 S+ 01:14 0:00 | \_ ./differ [root@localhost ]# netstat -tlnp | grep 2222 tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN 45409/./differ [root@localhost ]# ls -lh /proc/45409/fd  0 lrwx------ 1 tolik tolik 64  19 01:16 0 -&gt; /dev/pts/12 lrwx------ 1 tolik tolik 64  19 01:16 1 -&gt; /dev/pts/12 lrwx------ 1 tolik tolik 64  19 01:16 2 -&gt; /dev/pts/12 l-wx------ 1 tolik tolik 64  19 01:16 3 -&gt; /tmp/nginx_vs_apache.log lrwx------ 1 tolik tolik 64  19 01:16 4 -&gt; socket:[42663416] [root@localhost ]# netstat -apeen | grep 42663416 tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN 500 42663416 45409/./differ [root@localhost ]# strace -p 45409 Process 45409 attached - interrupt to quit accept(4, ^C &lt;unfinished ...&gt; Process 45409 detached [root@localhost ]#</span></span></code> </pre> <br><p>  The process is in the sleep state (S + in the ps command). </p><br><p>  This program will continue to run (will get processor time) only when a new connection appears on port 2222. In all other cases, the program will never receive processor time: it will not even require it from the OS and, therefore, will not affect load avarage (hereafter LA ), consuming only memory. </p><br><p>  From the other console, launch the first client: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ telnet localhost 2222 Connected to localhost. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> client 1</code> </pre> <br><p>  See the file: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># cat /tmp/nginx_vs_apache.log test client 1</span></span></code> </pre> <br><p>  Open the second connection: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ telnet localhost 2222 Connected to localhost. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> client 2</code> </pre> <br><p>  See the result: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># cat /tmp/nginx_vs_apache.log test client 1</span></span></code> </pre> <br><p>  From the contents of the file you can see that only the first message from the first client arrived.  But at the same time, we have already sent the second message, and it is somewhere.  All network connections are made by the OS, which means that the test client 2 message is now in the operating system's buffer, in a memory that is not available to us.  The only way to get this data is to process the new connection with the accept command, then call read. </p><br><p>  Let's try to write something in the first client: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ telnet localhost 2222 Connected to localhost. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> client 1 blablabla</code> </pre> <br><p>  Check the log: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># cat /tmp/nginx_vs_apache.log test client 1</span></span></code> </pre> <br><p>  A new message was not logged.  This is due to the fact that we call the read command only once, therefore, only the first message gets into the log. </p><br><p>  Let's try to close our first connection: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ telnet localhost 2222 Connected to localhost. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> client 1 bla bla bla ^] telnet&gt; quit Connection closed.</code> </pre> <br><p>  At this moment, our program starts the following accept and read loop, therefore, accepts the message from the second connection: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># cat /tmp/nginx_vs_apache.log test client 1 test client 2</span></span></code> </pre> <br><p>  Our message bla bla bla did not appear anywhere, we already closed the socket, and the OS cleared the buffer, thereby deleting our data.  It is necessary to modernize the program - read from the socket until information comes from there. </p><br><div class="spoiler">  <b class="spoiler_title">A program with infinite reading from the socket2.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_NO 2222 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;netinet/in.h&gt; int main(int argc, char *argv[]) { int sockfd, newsockfd; socklen_t clilen; char buffer; char * pointbuffer = &amp;buffer; struct sockaddr_in serv_addr, cli_addr; FILE * resultfile; resultfile = fopen("/tmp/nginx_vs_apache.log","a"); bzero((char *) &amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = INADDR_ANY; serv_addr.sin_port = htons(PORT_NO); sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd &lt; 0) error("ERROR opening socket"); if (bind(sockfd, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) error("ERROR on binding"); listen(sockfd,50); while (1) { newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen); if (newsockfd &lt; 0) error("ERROR on accept"); while (read(newsockfd, pointbuffer,1)) { fprintf(resultfile, pointbuffer); fflush (resultfile); } } close(sockfd); return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  The program is not much different from the previous one.  We added another loop before the read command in order to take data from the socket as long as it goes there.  We are checking. </p><br><p>  Clear the file: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># &gt; /tmp/nginx_vs_apache.log</span></span></code> </pre> <br><p>  Compile and run: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ gcc -o differ differ2.c [tolik@localhost ]$ ./differ</code> </pre> <br><p>  First client: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ telnet localhost 2222 Connected to localhost. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. client <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> 1 yoyoyo</code> </pre> <br><p>  Second client: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ telnet localhost 2222 Connected to localhost. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. client <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> 2 yooyoy</code> </pre> <br><p>  Checking what happened: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># cat /tmp/nginx_vs_apache.log client test 1 yoyoyo</span></span></code> </pre> <br><p>  This time everything is fine, we took all the data, but the problem remained: two connections are processed sequentially, in turn, and this does not fit our requirements.  If we close the first connection (ctrl +]), then the data from the second connection will go directly to the log: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># cat /tmp/nginx_vs_apache.log client test 1 yoyoyo client test 2 yooyoy</span></span></code> </pre> <br><p>  Data came from.  But how to handle two connections in parallel?  This is where the fork command comes to the rescue.  What does the fork system call on linux do?  The correct answer to this question at any interview is nothing.  Fork is an obsolete call, and in linux it is present only for backward compatibility.  In fact, by calling the fork command, you call the clone system call.  The clone function creates a copy of the process and queues both processes on the processor.  The difference between them is that fork copies data (variables, buffers, etc.) directly to the memory area of ‚Äã‚Äãthe child process, and clone copies the data to the child process only when trying to change it (see memory access restrictions in the MMU).  That is, if you call fork 10 times and use data only for reading, you will receive 10 identical copies of data in memory.  And this is clearly not what you need, especially in multi-threading applications.  Clone runs a copy of your application, but does not copy data right away.  If you run clone 10 times, then you will have 10 executable processes with one memory block, and the memory will be copied only when you try to change it by a child process.  Agree, the second algorithm is much more efficient. </p><br><div class="spoiler">  <b class="spoiler_title">C program fork differ3.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_NO 2222 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;netinet/in.h&gt; int main(int argc, char *argv[]) { int sockfd, newsockfd; socklen_t clilen; char buffer; char * pointbuffer = &amp;buffer; struct sockaddr_in serv_addr, cli_addr; FILE * resultfile; int pid=1; resultfile = fopen("/tmp/nginx_vs_apache.log","a"); bzero((char *) &amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = INADDR_ANY; serv_addr.sin_port = htons(PORT_NO); sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd &lt; 0) error("ERROR opening socket"); if (bind(sockfd, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) error("ERROR on binding"); listen(sockfd,50); while (pid!=0) { newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen); if (newsockfd &lt; 0) error("ERROR on accept"); pid=fork(); if (pid!=0) { close(newsockfd); fprintf(resultfile,"New process was started with pid=%d\n",pid); fflush (resultfile); } } while (read(newsockfd, pointbuffer,1)) { fprintf(resultfile, pointbuffer); fflush (resultfile); } close(sockfd); return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  In this program, everything is the same - we accept, accept a new connection.  Next, we run fork.  And if this is a master process (fork returned the pid of the created process), then we close the current connection in the parent process (it is available both in the parent and in the child process).  If this is a child process (fork returns 0), then we begin to read from the open socket, which we opened with the accept command in the parent process.  In fact, it turns out that the parent process only accepts connections, and we do read / write in the child processes. </p><br><p>  Compile and run: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ gcc -o differ differ3.c [tolik@localhost ]$ ./differ</code> </pre> <br><p>  Clearing our log file: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># &gt; /tmp/nginx_vs_apache.log</span></span></code> </pre> <br><p>  We look at the processes: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># ps axuf | grep [d]iffer tolik 45643 0.0 0.0 4060 460 pts/12 S+ 01:40 0:00 | \_ ./differ</span></span></code> </pre> <br><p>  Client1: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ telnet localhost 2222 Connected to localhost. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. client 1 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> megatest</code> </pre> <br><p>  Client2: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ telnet localhost 2222 Connected to localhost. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. client2 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> yoyoyoy</code> </pre> <br><p>  We look at the processes: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># ps axuf | grep [d]iffer tolik 45643 0.0 0.0 4060 504 pts/12 S+ 01:40 0:00 | \_ ./differ tolik 45663 0.0 0.0 4060 156 pts/12 S+ 01:41 0:00 | \_ ./differ tolik 45665 0.0 0.0 4060 160 pts/12 S+ 01:41 0:00 | \_ ./differ</span></span></code> </pre> <br><p>  We do not close both connections and we can add something else there, see our log: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># cat /tmp/nginx_vs_apache.log New process was started with pid=44163 New process was started with pid=44165 client 1 test megatest client2 test yoyoyoy</span></span></code> </pre> <br><p>  Two connections are processed simultaneously - we get the desired result. </p><br><p>  The program works, but not fast enough.  It first accepts the connection, and only then runs the fork command, and the connection processes only one process.  The question arises: can multiple processes in the Linux OS work with the same tcp port?  We try. </p><br><div class="spoiler">  <b class="spoiler_title">Program c pre fork differ_prefork.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_NO 2222 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;netinet/in.h&gt; int main(int argc, char *argv[]) { int sockfd, newsockfd, startservers, count ; socklen_t clilen; char buffer; char * pointbuffer = &amp;buffer; struct sockaddr_in serv_addr, cli_addr; FILE * resultfile; int pid=1; resultfile = fopen("/tmp/nginx_vs_apache.log","a"); bzero((char *) &amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = INADDR_ANY; serv_addr.sin_port = htons(PORT_NO); sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd &lt; 0) error("ERROR opening socket"); if (bind(sockfd, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0) error("ERROR on binding"); listen(sockfd,50); startservers=2; count = 0; while (pid!=0) { if (count &lt; startservers) { pid=fork(); if (pid!=0) { close(newsockfd); fprintf(resultfile,"New process was started with pid=%d\n",pid); fflush (resultfile); } count = count + 1; } //sleep (1); } newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen); if (newsockfd &lt; 0) error("ERROR on accept"); while (read(newsockfd, pointbuffer,1)) { fprintf(resultfile, pointbuffer); fflush (resultfile); } close(sockfd); return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  As you can see, the program still hasn't changed much, we just run fork in a loop.  In this case, we create two child processes, and only then in each of them we accept to accept a new connection.  We are checking. </p><br><p>  Compile and run: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ gcc -o differ differ_prefork.c [tolik@localhost ]$ ./differ</code> </pre> <br><p>  We look, that at us in processes: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># ps axuf | grep [d]iffer tolik 44194 98.0 0.0 4060 504 pts/12 R+ 23:35 0:07 | \_ ./differ tolik 44195 0.0 0.0 4060 152 pts/12 S+ 23:35 0:00 | \_ ./differ tolik 44196 0.0 0.0 4060 156 pts/12 S+ 23:35 0:00 | \_ ./differ</span></span></code> </pre> <br><p>  We have not connected to any client yet, and the program has already made fork for two times.  What is happening with the system now?  To begin, the master process: it is in a closed loop and checks whether it is necessary to fork more processes.  If we do this without stopping, then, in fact, we will constantly require CPU time from the OS, since our cycle must always be executed.  This means that we consume 100% of one core - in the ps command, the value is 98.0%.  The same can be seen in the top command: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># top -n 1 | head top - 23:39:22 up 141 days, 21 min, 8 users, load average: 1.03, 0.59, 0.23 Tasks: 195 total, 2 running, 193 sleeping, 0 stopped, 0 zombie Cpu(s): 0.3%us, 0.2%sy, 0.0%ni, 99.3%id, 0.2%wa, 0.0%hi, 0.0%si, 0.0%st Mem: 1896936k total, 1876280k used, 20656k free, 151208k buffers Swap: 4194296k total, 107600k used, 4086696k free, 1003568k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 44194 tolik 20 0 4060 504 420 R 98.9 0.0 4:10.54 differ 44255 root 20 0 15028 1256 884 R 3.8 0.1 0:00.03 top 1 root 20 0 19232 548 380 S 0.0 0.0 2:17.17 init</span></span></code> </pre> <br><p>  If we connect with the strace command to the parent, we will not see anything, since our process does not invoke any kernel functions: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># strace -p 44194 Process 44194 attached - interrupt to quit ^CProcess 44194 detached [root@localhost ]#</span></span></code> </pre> <br><p>  What do child processes do?  This is where the fun begins.  Judging by the code, all of them after the fork should hang in the accept state and wait for new connections from the same port, in our case 2222. We check: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># strace -p 44195 Process 44195 attached - interrupt to quit accept(4, ^C &lt;unfinished ...&gt; Process 44195 detached [root@localhost ]# strace -p 44196 Process 44196 attached - interrupt to quit accept(4, ^C &lt;unfinished ...&gt; Process 44196 detached</span></span></code> </pre> <br><p>  At the moment, they do not require processor time from the OS and consume only memory.  But the question is: which one of them will accept my connection if I make telnet?  Checking: </p><br><pre> <code class="bash hljs">[tolik@localhost ]$ telnet localhost 2222 Connected to localhost. Escape character is <span class="hljs-string"><span class="hljs-string">'^]'</span></span>. client 1 <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> hhh</code> </pre> <br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># strace -p 44459 Process 44459 attached - interrupt to quit read(5, ^C &lt;unfinished ...&gt; Process 44459 detached [root@localhost ]# strace -p 44460 Process 44460 attached - interrupt to quit accept(4, ^C &lt;unfinished ...&gt; Process 44460 detached</span></span></code> </pre> <br><p>  We see that the process that was created earlier (with a smaller pid) processed the connection first, and is now in the read state.  If we run the second telnet, then our connection will process the next process.  After we have finished working with the socket, we can close it and go back to the accept state (I did not do this, so as not to complicate the program). </p><br><p>  The last question remains: what do we do with the parent process so that it does not consume so much cpu and continue to work?  We need to give time to other processes on a voluntary basis, that is, to ‚Äútell‚Äù our OS that we do not need cpu for some time.  For this task, the sleep 1 command is appropriate: if you uncomment it, you will see in strace a picture that repeats once every second: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># strace -p 44601 ‚Ä¶.. rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0 rt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 nanosleep({1, 0}, 0x7fff60a15aa0) = 0 ‚Ä¶. rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0 rt_sigaction(SIGCHLD, NULL, {SIG_DFL, [], 0}, 8) = 0 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0 nanosleep({1, 0}, 0x7fff60a15aa0) = 0 ‚Ä¶</span></span></code> </pre> <br><p>  etc. </p><br><p>  Our process will receive the processor about once a second, or at least require it from the OS. </p><br><p>  If you still do not understand what this long article is for, then look at the apache httpd operating in prefork mode: </p><br><pre> <code class="bash hljs">[root@www /]<span class="hljs-comment"><span class="hljs-comment"># ps axuf | grep [h]ttpd root 12730 0.0 0.5 271560 11916 ? Ss Feb25 3:14 /usr/sbin/httpd apache 19832 0.0 0.3 271692 7200 ? S Apr17 0:00 \_ /usr/sbin/httpd apache 19833 0.0 0.3 271692 7212 ? S Apr17 0:00 \_ /usr/sbin/httpd apache 19834 0.0 0.3 271692 7204 ? S Apr17 0:00 \_ /usr/sbin/httpd apache 19835 0.0 0.3 271692 7200 ? S Apr17 0:00 \_ /usr/sbin/httpd</span></span></code> </pre> <br><p>  Child processes in accept: </p><br><pre> <code class="bash hljs">[root@www /]<span class="hljs-comment"><span class="hljs-comment"># strace -p 19832 Process 19832 attached accept4(3, ^CProcess 19832 detached &lt;detached ...&gt; [root@www /]# strace -p 19833 Process 19833 attached accept4(3, ^CProcess 19833 detached &lt;detached ...&gt;</span></span></code> </pre> <br><p>  Master process with a second pause: </p><br><pre> <code class="bash hljs">[root@www /]<span class="hljs-comment"><span class="hljs-comment"># strace -p 12730 Process 12730 attached select(0, NULL, NULL, NULL, {0, 629715}) = 0 (Timeout) wait4(-1, 0x7fff4c9e3fbc, WNOHANG|WSTOPPED, NULL) = 0 select(0, NULL, NULL, NULL, {1, 0}) = 0 (Timeout) wait4(-1, 0x7fff4c9e3fbc, WNOHANG|WSTOPPED, NULL) = 0 select(0, NULL, NULL, NULL, {1, 0}) = 0 (Timeout) wait4(-1, 0x7fff4c9e3fbc, WNOHANG|WSTOPPED, NULL) = 0 ‚Ä¶</span></span></code> </pre> <br><p>  When starting the httpd master process spawns its child processes, it is easy to see if you run strace on the master process at the time of launch: <br>  Let's start a web server with the following settings: </p><br><pre> <code class="bash hljs">StartServers 1 MinSpareServers 9 MaxSpareServers 10 ServerLimit 10 MaxClients 10 MaxRequestsPerChild 1</code> </pre> <br><p>  These settings indicate that each child process will process only one request, then the process will be killed.  The minimum number of processes in accept is 9 and the maximum is 10. </p><br><p>  If you run strace on the master process at the time of start, we will see how the master calls clone until it reaches MinSpareServers. </p><br><div class="spoiler">  <b class="spoiler_title">Tracing</b> <div class="spoiler_text"><p>  rt_sigaction (SIGSEGV, {0x7f9991933c20, [], SA_RESTORER | SA_RESETHAND, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGBUS, {0x7f9991933c20, [], SA_RESTORER | SA_RESETHAND, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGABRT, {0x7f9991933c20, [], SA_RESTORER | SA_RESETHAND, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGILL, {0x7f9991933c20, [], SA_RESTORER | SA_RESETHAND, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGFPE, {0x7f9991933c20, [], SA_RESTORER | SA_RESETHAND, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGTERM, {0x7f999193de50, [], SA_RESTORER, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGWINCH, {0x7f999193de50, [], SA_RESTORER, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGINT, {0x7f999193de50, [], SA_RESTORER, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGXCPU, {SIG_DFL, [], SA_RESTORER, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGXFSZ, {SIG_IGN, [], SA_RESTORER, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGPIPE, {SIG_IGN, [], SA_RESTORER, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGHUP, {0x7f999193de80, [HUP USR1], SA_RESTORER, 0x7f99901dd500}, NULL, 8) = 0 <br>  rt_sigaction (SIGUSR1, {0x7f999193de80, [HUP USR1], SA_RESTORER, 0x7f99901dd500}, NULL, 8) = 0 <br>  clone (child_stack = 0, flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0x7f99918eeab0) = 13098 <br>  write (2, "[Wed Jan 25 13:24:39 2017] [noti" ..., 114) = 114 <br>  wait4 (-1, 0x7fffae295fdc, WNOHANG | WSTOPPED, NULL) = 0 <br>  select (0, NULL, NULL, NULL, {1, 0}) = 0 (Timeout) <br>  clone (child_stack = 0, flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0x7f99918eeab0) = 13099 <br>  wait4 (-1, 0x7fffae295fdc, WNOHANG | WSTOPPED, NULL) = 0 <br>  select (0, NULL, NULL, NULL, {1, 0}) = 0 (Timeout) <br>  clone (child_stack = 0, flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0x7f99918eeab0) = 13100 <br>  clone (child_stack = 0, flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0x7f99918eeab0) = 13101 <br>  wait4 (-1, 0x7fffae295fdc, WNOHANG | WSTOPPED, NULL) = 0 <br>  select (0, NULL, NULL, NULL, {1, 0}) = 0 (Timeout) <br>  clone (child_stack = 0, flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0x7f99918eeab0) = 13102 <br>  clone (child_stack = 0, flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0x7f99918eeab0) = 13103 <br>  clone (child_stack = 0, flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0x7f99918eeab0) = 13104 <br>  clone (child_stack = 0, flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0x7f99918eeab0) = 13105 <br>  wait4 (-1, 0x7fffae295fdc, WNOHANG | WSTOPPED, NULL) = 0 <br>  select (0, NULL, NULL, NULL, {1, 0}) = 0 (Timeout) <br>  clone (child_stack = 0, flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0x7f99918eeab0) = 13106 <br>  clone (child_stack = 0, flags = CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, child_tidptr = 0x7f99918eeab0) = 13107 <br>  wait4 (-1, 0x7fffae295fdc, WNOHANG | WSTOPPED, NULL) = 0 <br>  select (0, NULL, NULL, NULL, {1, 0}) = 0 (Timeout) </p></div></div><br><p>  We look at how Apache starts - for this you can simply watch ps axuf |  grep [h] ttp every second, immediately after the start. </p><br><div class="spoiler">  <b class="spoiler_title">Apache start</b> <div class="spoiler_text"><p>  [root @ www /] # date;  ps axuf |  grep [h] ttp <br>  Wed Jan 25 14:12:10 EST 2017 <br>  root 13342 2.5 0.4 271084 9384?  Ss 14:12 0:00 / usr / sbin / httpd <br>  apache 13344 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd </p><br><p>  [root @ www /] # date;  ps axuf |  grep [h] ttp <br>  Wed Jan 25 14:12:11 EST 2017 <br>  root 13342 1.6 0.4 271084 9384?  Ss 14:12 0:00 / usr / sbin / httpd <br>  apache 13344 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13348 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd </p><br><p>  [root @ www /] # date;  ps axuf |  grep [h] ttp <br>  Wed Jan 25 14:12:11 EST 2017 <br>  root 13342 2.0 0.4 271084 9384?  Ss 14:12 0:00 / usr / sbin / httpd <br>  apache 13344 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13348 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13352 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13353 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd </p><br><p>  [root @ www /] # date;  ps axuf |  grep [h] ttp <br>  Wed Jan 25 14:12:12 EST 2017 <br>  root 13342 1.7 0.4 271084 9384?  Ss 14:12 0:00 / usr / sbin / httpd <br>  apache 13344 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13348 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13352 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13353 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13357 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13358 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13359 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13360 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd </p><br><p>  [root @ www /] # date;  ps axuf |  grep [h] ttp <br>  Wed Jan 25 14:12:13 EST 2017 <br>  root 13342 1.4 0.4 271084 9384?  Ss 14:12 0:00 / usr / sbin / httpd <br>  apache 13344 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13348 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13352 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13353 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13357 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13358 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13359 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13360 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13364 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  apache 13365 0.0 0.2 271084 5232?  S 14:12 0:00 _ / usr / sbin / httpd <br>  [root @ www /] # </p></div></div><br><p>  So, we have several child processes that are ready to accept our http request.  Let's try to send a request: </p><br><pre> <code class="bash hljs">[root@www /]<span class="hljs-comment"><span class="hljs-comment"># wget -O /dev/null http://localhost --2017-01-25 14:04:00-- http://localhost/ Resolving localhost... ::1, 127.0.0.1 Connecting to localhost|::1|:80... failed: Connection refused. Connecting to localhost|127.0.0.1|:80... connected. HTTP request sent, awaiting response... 403 Forbidden 2017-01-25 14:04:00 ERROR 403: Forbidden.</span></span></code> </pre> <br><p>  Apache answered 403, we look at the processes: </p><br><pre> <code class="bash hljs">root 13342 0.0 0.4 271084 9384 ? Ss 14:12 0:00 /usr/sbin/httpd apache 13348 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13352 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13353 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13357 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13358 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13359 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13360 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13364 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13365 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd</code> </pre> <br><p>  As you can see, the process with the minimum pid processed the request and completed its work: </p><br><pre> <code class="bash hljs">apache 13344 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd</code> </pre> <br><p>  We have 9 child processes left, which fits into our MinSpareServers limit. </p><br><p>  We try to send the request again: </p><br><pre> <code class="bash hljs">[root@www /]<span class="hljs-comment"><span class="hljs-comment"># wget -O /dev/null http://localhost --2017-01-25 14:15:47-- http://localhost/ Resolving localhost... ::1, 127.0.0.1 Connecting to localhost|::1|:80... failed: Connection refused. Connecting to localhost|127.0.0.1|:80... connected. HTTP request sent, awaiting response... 403 Forbidden 2017-01-25 14:15:47 ERROR 403: Forbidden. [root@www /]# ps axuf | grep [h]ttp root 13342 0.0 0.4 271084 9384 ? Ss 14:12 0:00 /usr/sbin/httpd apache 13352 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13353 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13357 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13358 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13359 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13360 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13364 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13365 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13373 0.0 0.2 271084 5232 ? S 14:15 0:00 \_ /usr/sbin/httpd</span></span></code> </pre> <br><p>  This time our request processed the process. </p><br><pre> <code class="bash hljs">apache 13348 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd</code> </pre> <br><p>  since it now has a minimum pid. </p><br><p>  But we have 8 free child processes left in accept, one is missing before MinSpareServers, so the master process has created a new process for us: </p><br><pre> <code class="bash hljs">apache 13373 0.0 0.2 271084 5232 ? S 14:15 0:00 \_ /usr/sbin/httpd</code> </pre> <br><p>  Let's tell our OS that it does not give the processor time to the master Apache process: </p><br><pre> <code class="bash hljs">[root@www /]<span class="hljs-comment"><span class="hljs-comment"># kill -SIGSTOP 13342</span></span></code> </pre> <br><p>  We look: </p><br><pre> <code class="bash hljs">[root@www /]<span class="hljs-comment"><span class="hljs-comment"># ps axuf | grep [h]ttp | grep ^root root 13342 0.0 0.4 271084 9384 ? Ts 14:12 0:00 /usr/sbin/httpd</span></span></code> </pre> <br><p>  The status of the process has changed, now it does not work. </p><br><p>  Check if our web server works: </p><br><pre> <code class="bash hljs">[root@www /]<span class="hljs-comment"><span class="hljs-comment"># wget -O /dev/null http://localhost --2017-01-25 14:20:12-- http://localhost/ Resolving localhost... ::1, 127.0.0.1 Connecting to localhost|::1|:80... failed: Connection refused. Connecting to localhost|127.0.0.1|:80... connected. HTTP request sent, awaiting response... 403 Forbidden 2017-01-25 14:20:12 ERROR 403: Forbidden.</span></span></code> </pre> <br><p>  Oh yes, it still works, the web server is still responding. </p><br><p>  We look at what we have with the processes: </p><br><pre> <code class="bash hljs">root 13342 0.0 0.4 271084 9384 ? Ts 14:12 0:00 /usr/sbin/httpd apache 13352 0.0 0.0 0 0 ? Z 14:12 0:00 \_ [httpd] &lt;defunct&gt; apache 13353 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13357 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13358 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13359 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13360 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13364 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13365 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13373 0.0 0.2 271084 5232 ? S 14:15 0:00 \_ /usr/sbin/httpd</code> </pre> <br><p>  Our next request was processed by another child process, which worked and left.  But he left the exit code, which must be processed by the master process.  Since the master process is stopped at us, the exit code is still in the kernel in the process table, and even though we don‚Äôt already have the process, it is in the table marked as zombies. </p><br><pre> <code class="bash hljs">apache 13352 0.0 0.0 0 0 ? Z 14:12 0:00 \_ [httpd] &lt;defunct&gt;</code> </pre> <br><p>       8,    9  ,  . </p><br><p>       http : </p><br><pre> <code class="bash hljs">[root@www /]<span class="hljs-comment"><span class="hljs-comment"># wget -O /dev/null http://localhost --2017-01-25 14:25:03-- http://localhost/ Resolving localhost... ::1, 127.0.0.1 Connecting to localhost|::1|:80... failed: Connection refused. Connecting to localhost|127.0.0.1|:80... connected. HTTP request sent, awaiting response... 403 Forbidden 2017-01-25 14:25:03 ERROR 403: Forbidden. [root@www /]# ps axuf | grep [h]ttp root 13342 0.0 0.4 271084 9384 ? Ts 14:12 0:00 /usr/sbin/httpd apache 13352 0.0 0.0 0 0 ? Z 14:12 0:00 \_ [httpd] &lt;defunct&gt; apache 13353 0.0 0.0 0 0 ? Z 14:12 0:00 \_ [httpd] &lt;defunct&gt; apache 13357 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13358 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13359 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13360 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13364 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13365 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13373 0.0 0.2 271084 5232 ? S 14:15 0:00 \_ /usr/sbin/httpd</span></span></code> </pre> <br><p> ,   . </p><br><p>    ,       : </p><br><pre> <code class="bash hljs">[root@www /]<span class="hljs-comment"><span class="hljs-comment"># kill -SIGCONT 13342 [root@www /]# ps axuf | grep [h]ttp root 13342 0.0 0.4 271084 9384 ? Ss 14:12 0:00 /usr/sbin/httpd apache 13357 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13358 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13359 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13360 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13364 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13365 0.0 0.2 271084 5232 ? S 14:12 0:00 \_ /usr/sbin/httpd apache 13373 0.0 0.2 271084 5232 ? S 14:15 0:00 \_ /usr/sbin/httpd apache 13388 0.0 0.2 271084 5232 ? S 14:26 0:00 \_ /usr/sbin/httpd apache 13389 0.0 0.2 271084 5232 ? S 14:26 0:00 \_ /usr/sbin/httpd apache 13390 0.0 0.2 271084 5232 ? S 14:26 0:00 \_ /usr/sbin/httpd</span></span></code> </pre> <br><p>      exit code  ,        ,         ‚Äî    10    accept,        . </p><br><p>   nginx?    ,   accept       ,     . ,               .  Or? </p><br><p>   : </p><br><div class="spoiler"> <b class="spoiler_title">  select</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT 2222 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netinet/in.h&gt; #include &lt;sys/time.h&gt; int main(int argc , char *argv[]) { int opt = 1; int master_socket , addrlen , new_socket , client_socket[30] , max_clients = 30 , activity, i , valread , sd; int max_sd; FILE * resultfile; struct sockaddr_in address; char buffer[50]; fd_set readfds; resultfile = fopen("/tmp/nginx_vs_apache.log","a"); //     for (i = 0; i &lt; max_clients; i++) client_socket[i] = 0; if( (master_socket = socket(AF_INET , SOCK_STREAM , 0)) == 0) error("socket failed"); address.sin_family = AF_INET; address.sin_addr.s_addr = INADDR_ANY; address.sin_port = htons( PORT ); if (bind(master_socket, (struct sockaddr *)&amp;address, sizeof(address))&lt;0) error("bind failed"); if (listen(master_socket, 3) &lt; 0) error("listen"); addrlen = sizeof(address); while(1) //     { FD_ZERO(&amp;readfds); FD_SET(master_socket, &amp;readfds); max_sd = master_socket; for ( i = 0 ; i &lt; max_clients ; i++) { sd = client_socket[i]; if(sd &gt; 0) FD_SET( sd , &amp;readfds); if(sd &gt; max_sd) max_sd = sd; } //        activity = select( max_sd + 1 , &amp;readfds , NULL , NULL , NULL); if ((activity &lt; 0) &amp;&amp; (errno!=EINTR)) printf("select error"); //   if (FD_ISSET(master_socket, &amp;readfds)) { if ((new_socket = accept(master_socket, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen))&lt;0) error("accept"); for (i = 0; i &lt; max_clients; i++) if( client_socket[i] == 0 ) { client_socket[i] = new_socket; break; } } //    ,           CPU for (i = 0; i &lt; max_clients; i++) { sd = client_socket[i]; if (FD_ISSET( sd , &amp;readfds)) { if ((valread = read( sd , buffer, 1024)) == 0) { close( sd ); client_socket[i] = 0; } else { buffer[valread] = '\0'; fprintf(resultfile, buffer); fflush (resultfile); } } } } return 0; }</span></span></span></span></code> </pre> </div></div><br><p>     ,  ,     . ,      30 .     .       ,   ,       .       ,       .           accept?  linux      3 : select, poll  epoll.   freebsd      epoll   kqueue (kernel queue).    ? select ‚Äì   ,       ,      ,       (   accept).   ,     cpu,        .         ,    select   .       ,   select      :     2222  ,    .   , : </p><br><pre> <code class="bash hljs">[tolik@101host nginx_vs_apache]$ ./differ &amp; [1] 44832 [tolik@101host nginx_vs_apache]$ ps axuf | grep [.]/differ tolik 44832 0.0 0.0 4060 448 pts/0 S 22:47 0:00 \_ ./differ [root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># strace -p 44832 Process 44832 attached - interrupt to quit select(5, [4], NULL, NULL, NULL) = 1 (in [4])</span></span></code> </pre> <br><p>         telnet   2222       : </p><br><pre> <code class="bash hljs">accept(4, {sa_family=AF_INET, sin_port=htons(41130), sin_addr=inet_addr(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>)}, [16]) = 5 select(6, [4 5], NULL, NULL, NULL^C &lt;unfinished ...&gt; Process 44832 detached [root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># ls -lh /proc/44832/fd  0 lrwx------ 1 tolik tolik 64  19 00:26 0 -&gt; /dev/pts/12 lrwx------ 1 tolik tolik 64  19 00:26 1 -&gt; /dev/pts/12 lrwx------ 1 tolik tolik 64  19 00:21 2 -&gt; /dev/pts/12 l-wx------ 1 tolik tolik 64  19 00:26 3 -&gt; /tmp/nginx_vs_apache.log lrwx------ 1 tolik tolik 64  19 00:26 4 -&gt; socket:[42651147] lrwx------ 1 tolik tolik 64  19 00:26 5 -&gt; socket:[42651320] [root@localhost ]# netstat -apeen | grep 42651147 tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN 500 42651147 44832/./differ [root@localhost ]# netstat -apeen | grep 42651320 tcp 0 0 127.0.0.1:2222 127.0.0.1:41130 ESTABLISHED 500 42651320 44832/./differ</span></span></code> </pre> <br><p>   select    4 (   ).  /proc  ,  4 - ‚Äî     42651147.  netstat  ,      ‚Äî      listen  2222.       ,   tcp handshake   telnet     ,      select.            . ,    ,    accept, ,       ,     .        accept,    . </p><br><p>  ,    ,      linux,   ,          ‚Äî   4  5,       strace ([4 5]).    nginx:        .        read/write,     accept. Select ‚Äî    ,   : ,     ( ).          poll,      .   epoll  kqueue ( freebsd).         . </p><br><p>      nginx? Nginx      . </p><br><p> <a href="http://nginx.org/ru/docs/events.html">  </a> .       ,     , ..     . </p><br><p> Nginx  fork  ,         .       nginx      ,     select,       ( linux    epoll).  We look: </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># ps axuf| grep [n]ginx root 232753 0.0 0.0 96592 556 ? Ss Feb25 0:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf nginx 232754 0.0 0.0 97428 1400 ? S Feb25 5:20 \_ nginx: worker process nginx 232755 0.0 0.0 97460 1364 ? S Feb25 5:02 \_ nginx: worker process [root@localhost ]# strace -p 232754 Process 232754 attached - interrupt to quit epoll_wait(12, ^C &lt;unfinished ...&gt; Process 232754 detached [root@localhost ]# strace -p 232755 Process 232755 attached - interrupt to quit epoll_wait(14, {}, 512, 500) = 0 epoll_wait(14, ^C &lt;unfinished ...&gt; Process 232755 detached</span></span></code> </pre> <br><p>      nginx? </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># strace -p 232753 Process 232753 attached - interrupt to quit rt_sigsuspend([]^C &lt;unfinished ...&gt; Process 232753 detached</span></span></code> </pre> <br><p>     ,       .   nginx   , ,   ,     ,     . </p><br><p>     nginx   unix : </p><br><pre> <code class="bash hljs">[root@localhost ]<span class="hljs-comment"><span class="hljs-comment"># ls -lh /proc/232754/fd  0 lrwx------ 1 nginx nginx 64  8 13:20 0 -&gt; /dev/null lrwx------ 1 nginx nginx 64  8 13:20 1 -&gt; /dev/null lrwx------ 1 nginx nginx 64  8 13:20 10 -&gt; socket:[25069547] lrwx------ 1 nginx nginx 64  8 13:20 11 -&gt; socket:[25069551] lrwx------ 1 nginx nginx 64  8 13:20 12 -&gt; anon_inode:[eventpoll] lrwx------ 1 nginx nginx 64  8 13:20 13 -&gt; anon_inode:[eventfd] l-wx------ 1 nginx nginx 64  8 13:20 2 -&gt; /var/log/nginx/error.log lrwx------ 1 nginx nginx 64  8 13:20 3 -&gt; socket:[25069552] l-wx------ 1 nginx nginx 64  8 13:20 5 -&gt; /var/log/nginx/error.log l-wx------ 1 nginx nginx 64  8 13:20 6 -&gt; /var/log/nginx/access.log lrwx------ 1 nginx nginx 64  8 13:20 9 -&gt; socket:[25069546] [root@localhost ]# netstat -apeen | grep 25069547 tcp 0 0 172.16.0.1:80 0.0.0.0:* LISTEN 0 25069547 232753/nginx [root@localhost ]# netstat -apeen | grep 25069551 unix 3 [ ] STREAM CONNECTED 25069551 232753/nginx</span></span></code> </pre> <br><h2 id="itog">  Total </h2><br><p>          ,    .        apache httpd  nginx ‚Äì  .       ,          ( ),      nginx   nginx. </p><br><h2 id="ps">  PS </h2><br><p>        , ,       2222.         ,     -         .    ,  ,      . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/320710/">https://habr.com/ru/post/320710/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320700/index.html">DNS provider substitution</a></li>
<li><a href="../320702/index.html">Virtual cinematography for VR trailers</a></li>
<li><a href="../320704/index.html">Subversion vs. Git: Debunking Myths About Debunking Myths</a></li>
<li><a href="../320706/index.html">Another JNCIE-SP exam history</a></li>
<li><a href="../320708/index.html">Thinking about a one-way mirror</a></li>
<li><a href="../320712/index.html">Aesthetic Beauty: Switch vs If</a></li>
<li><a href="../320714/index.html">3CX Client for Android and iOS updates, and the 3CX SBC release for Debian Linux</a></li>
<li><a href="../320716/index.html">Passive methods to detect illegal traffic termination</a></li>
<li><a href="../320718/index.html">PHP SQL query</a></li>
<li><a href="../320720/index.html">Own search algorithm for similar images. Theory</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>