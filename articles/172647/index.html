<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About the intricacies of foreach in PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In a recent digest of interesting links about PHP, I found a link to Nikita Popov's comment on StackOverflow, where he talks in detail about the ‚Äúunde...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About the intricacies of foreach in PHP</h1><div class="post__text post__text-html js-mediator-article">  <i>In a recent <a href="http://habrahabr.ru/company/zfort/blog/172297/">digest of</a> interesting links about PHP, I found a link to Nikita Popov's <a href="http://stackoverflow.com/questions/10057671/how-foreach-actually-works/14854568">comment</a> on StackOverflow, where he talks in detail about the ‚Äúunder the hood‚Äù mechanism of the foreach control construct.</i> <i><br></i>  <i>Since foreach does indeed sometimes work in more than strange ways, I found it useful to translate this answer.</i> <br><br>  Attention: this text implies a <a href="http://www.php.net/manual/ru/features.gc.refcounting-basics.php">basic knowledge</a> of the functionality of zval's in PHP, in particular, you should know what refcount and is_ref are. <br>  foreach works with entities of different types: with arrays, with simple objects (which lists the available properties) and with <a href="http://php.net/manual/ru/class.traversable.php">Traversable</a> objects (or rather, objects that have an internal get_iterator handler).  Here we mostly talk about arrays, but I‚Äôll also talk about the rest at the very end. <br><br>  Before you begin, a couple of words about arrays and their traversal are important for understanding the context. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  How arrays work </h4><br><br>  Arrays in PHP are ordered hash tables (the elements of the hash are combined into a doubly linked list) and foreach bypasses the array, following the specified order. <br><br>  PHP includes two ways to traverse an array: <br><ul><li>  The first method is an internal array pointer.  This pointer is part of the HashTable structure and is simply a pointer to the current hash table entry.  The internal array pointer can be changed with impunity, that is, if the current element is deleted, the internal array pointer will be moved to the next one. </li><li>  The second iteration mechanism is an external array pointer called HashPosition.  This is practically the same as the internal array pointer, but it is not part of the HashTable.  This external way of iteration is not safe to change.  If you delete the element pointed to by the HashPosition, you will be left with a dangling pointer, which will lead to a segmentation error. </li></ul><br><br>  Thus, external array pointers can only be used when you are completely confident that no custom code will be executed when traversing.  And such code may be in the most unexpected place, such as an error handler or destructor.  That is why in most cases PHP has to use an internal pointer instead of an external one.  If it were otherwise, PHP might have dropped due to the segmentation fault as soon as the user starts doing something unusual. <br><br>  The problem with the internal pointer is that it is part of the HashTable.  So when you change it, the HashTable changes with it.  And since accessing arrays in PHP is done by value (and not by reference), you have to copy the array in order to bypass its elements in a loop. <br><br>  A simple example showing the importance of copying (by the way, not such a rarity) is an embedded iteration: <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $a) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $b) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br><br>  Here you want both cycles to be independent, rather than slyly thrown by one pointer. <br><br>  So, we have reached foreach. <br><br><h4>  Foreach array traversal </h4><br><br>  Now you know why foreach has to create a copy of the array before bypassing it.  But this is clearly not the whole story.  Whether PHP makes a copy or not depends on several factors: <br><br><ul><li>  If the array to be iterated is a link, no copying will occur; instead, addref will be executed: <br><br><pre> <code class="php hljs">$ref =&amp; $array; <span class="hljs-comment"><span class="hljs-comment">// $array has is_ref=1 now foreach ($array as $val) { // ... }</span></span></code> </pre><br>  Why?  Because any change to the array should be distributed by reference, including the internal pointer.  If foreach had made a copy in this case, it would have destroyed the semantics of the link. </li><li>  If the array has refcount = 1, the copying will not be performed again.  refcount = 1 means that the array is not used elsewhere and foreach can use it directly.  If there is more than one refcount, then the array is shared with other variables and in order to avoid the change, foreach must copy it (regardless of the reference case described above). </li><li>  If an array is managed by reference (foreach ($ array as &amp; $ ref)), then ‚Äî regardless of the copy or non-copy function ‚Äî the array will become a link. </li></ul><br><br>  So this is the first part of the mystery: the copy function.  The second part is how the current iteration is performed, and it is also rather strange.  An ‚Äúordinary‚Äù iteration pattern that you already know (and which is often used in PHP ‚Äî separate from foreach) looks like this (pseudo-code): <br><br><pre> <code class="php hljs">reset(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (get_current_data(&amp;data) == SUCCESS) { code(); move_forward(); }</code> </pre><br>  foreach iteration looks a little different: <br><br><pre> <code class="php hljs">reset(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (get_current_data(&amp;data) == SUCCESS) { move_forward(); code(); }</code> </pre><br><br>  The difference is that move_forward () is executed at the beginning and not at the end of the loop.  Thus, when the user code uses the element $ i, the internal array pointer already points to the element $ i + 1. <br><br>  This foreach mode of operation is also the reason why the internal pointer of the array goes to the next element if the current one is deleted, and not to the previous one (as you might expect).  Everything is done so as to work perfectly with foreach (but, obviously, everything else will not work so well, missing items). <br><br><h4>  Implications for code </h4><br><br>  The first consequence of the above behavior is that foreach copies the array being iterated in many cases (slowly).  But cast off the fear: I tried to remove the copying requirement and could not see the acceleration of work anywhere, except for artificial benchmarks (in which the iteration occurred twice as fast).  It seems that people just do not iterate quite a lot. <br><br>  The second consequence is that there usually should be no other effects.  The behavior of foreach is, in general, quite understandable to the user and simply works as it should.  You should not be worried about how copying takes place (and whether it happens at all), and at what particular point in time the pointer moves. <br><br>  And the third consequence - and here we are just approaching your problems - is that sometimes we see very strange behavior that is difficult to understand.  <b>This happens specifically when you try to modify the array itself, which you bypass in the loop.</b> <br><br>  A large collection of behaviors in borderline cases that appear when you modify an array during an iteration can be found in PHP tests.  You can start with <a href="">this test</a> , then change 012 to 013 in the address, and so on.  You will see how the foreach behavior will manifest itself in different situations (all sorts of link combinations, etc.). <br><br>  Now back to your examples: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $item) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"$item\n"</span></span>; $array[] = $item; } print_r($array); <span class="hljs-comment"><span class="hljs-comment">/* Output in loop: 1 2 3 4 5 $array after loop: 1 2 3 4 5 1 2 3 4 5 */</span></span></code> </pre><br><br>  Here, $ array has refcount = 1 before the loop, so it will not be copied, but will get addref.  Once you assign the value of $ array [], the zval will be split, so the array to which you add elements and the array to be iterated will be two different arrays. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $item) { $array[$key + <span class="hljs-number"><span class="hljs-number">1</span></span>] = $item + <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"$item\n"</span></span>; } print_r($array); <span class="hljs-comment"><span class="hljs-comment">/* Output in loop: 1 2 3 4 5 $array after loop: 1 3 4 5 6 7 */</span></span></code> </pre><br><br>  The same situation as in the first test. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,  ,      foreach var_dump(each($array)); foreach ($array as $item) { echo "$item\n"; } var_dump(each($array)); /* Output array(4) { [1]=&gt; int(1) ["value"]=&gt; int(1) [0]=&gt; int(0) ["key"]=&gt; int(0) } 1 2 3 4 5 bool(false) */</span></span></code> </pre><br><br>  Again the same story.  During the foreach loop, you have refcount = 1 and you only get addref, the internal pointer $ array will be changed.  At the end of the loop, the pointer becomes NULL (this means that the iteration is completed).  each demonstrates this by returning false. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $item) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"$item\n"</span></span>; each($array); } <span class="hljs-comment"><span class="hljs-comment">/* Output: 1 2 3 4 5 */</span></span></code> </pre><br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $item) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"$item\n"</span></span>; reset($array); } <span class="hljs-comment"><span class="hljs-comment">/* Output: 1 2 3 4 5 */</span></span></code> </pre><br><br>  The functions each and reset are both referenced.  $ array has refcount = 2 when it comes to them, as a result of which it should be divided.  Again, foreach will work on a separate array. <br><br>  But these examples are not convincing enough.  Behavior starts to be truly unpredictable when you use current in a loop: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $val) { var_dump(current($array)); } <span class="hljs-comment"><span class="hljs-comment">/* Output: 2 2 2 2 2 */</span></span></code> </pre><br><br>  Here you should keep in mind that current is also referred to by reference, despite the fact that it does not modify the array.  This is necessary in order to work consistently with all other functions, like next, which are accessed by reference (current, in fact, preferably the ref function; it can get a value, but use the reference if it can).  The link means that the array must be separated, therefore $ array and the copy of $ array that foreach uses will be independent.  Why you get 2, not 1, is also mentioned above: foreach increments the array pointer <b>before the beginning of the user code</b> , and not after.  So, even if the code still works with the first element, foreach has already moved the pointer to the second. <br><br>  Now try to make a small change: <br><br><pre> <code class="php hljs">$ref = &amp;$array; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $val) { var_dump(current($array)); } <span class="hljs-comment"><span class="hljs-comment">/* Output: 2 3 4 5 false */</span></span></code> </pre><br><br>  Here we have is_ref = 1, so the array is not copied (as above).  But now when there is an is_ref, the array no longer needs to be split, passing by reference to current.  Now current and foreach work with one array.  You see an array of just one because of the way foreach handles the pointer. <br><br>  You will see the same thing when you do a link traversal: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &amp;$val) { var_dump(current($array)); } <span class="hljs-comment"><span class="hljs-comment">/* Output: 2 3 4 5 false */</span></span></code> </pre><br><br>  The most important thing here is that foreach will assign our $ array is_ref = 1 when it will loop around it by reference, so it‚Äôs the same as above. <br><br>  Another small variation, here we assign our array to another variable: <br><br><pre> <code class="php hljs">$foo = $array; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $val) { var_dump(current($array)); } <span class="hljs-comment"><span class="hljs-comment">/* Output: 1 1 1 1 1 */</span></span></code> </pre><br><br>  Here, the refcount of the $ array array takes the value 2 when the loop has started, so you need to make a copy before starting.  Thus, $ array and the array used by foreach will be different from the very beginning.  That is why you get the position of the internal array pointer that was relevant before the cycle began (in this case, it was in the first position). <br><br><h4>  Object Iteration </h4><br><br>  When iterating objects, it makes sense to consider two cases: <br><br><h5>  The object is not Traversable (or rather, the internal get_iterator handler is not defined) </h5><br><br>  In this case, the iteration is almost the same as for arrays.  Same copy semantics.  The only difference is: foreach will run some additional code to skip properties that are not available in the current scope.  A couple more interesting facts: <br><br><ul><li>  For declared properties, PHP reoptimizes the properties hash table.  If you are still iterating an object, it must reconstruct this hash table (which increases memory usage).  Not that you should worry about this, just keep in mind. </li><li>  At each iteration, the property hash table will be retrieved again, that is, PHP will call get_properties again, and again, and again.  For ‚Äúnormal‚Äù properties, this is not so important, but if properties are created dynamically (this is often done by the built-in classes), then the property table will be recalculated each time. </li></ul><br><br><h5>  Traversable object </h5><br><br>  In this case, everything that is said above will not be applied in any way.  Also, PHP will not copy and will not apply any tricks like increasing the pointer until the loop passes.  I think that the mode of passage on a traversable object is much more predictable and does not require further description. <br><br><h4>  Replacing an object to be iterated during a cycle </h4><br><br>  Another unusual case that I did not mention is that PHP allows for the possibility of replacing an object to be iterated during a cycle.  You can start with one array and continue, replacing it halfway with another.  Or start with an array, then replace it with an object: <br><br><pre> <code class="php hljs">$arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; $obj = (object) [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]; $ref =&amp; $arr; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($ref <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $val) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"$val\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($val == <span class="hljs-number"><span class="hljs-number">3</span></span>) { $ref = $obj; } } <span class="hljs-comment"><span class="hljs-comment">/* Output: 1 2 3 6 7 8 9 10 */</span></span></code> </pre><br><br>  As you can see, PHP just started to bypass another entity as soon as the replacement occurred. <br><br><h4>  Changing the internal array pointer during iteration </h4><br><br>  The last detail of foreach behavior that I didn‚Äôt mention (because it can be used to get <b>truly weird behavior</b> ): what can happen if you try to change the internal array pointer during the loop pass. <br><br>  Here you can get not what you expected: if you call next or prev in the body of the loop (in the case of a link), you will see that the internal pointer has moved, but this did not affect the behavior of the iterator.  The reason is that foreach makes a backup of the current position and hash of the current element in the HashPointer after each pass of the loop.  On the next pass, foreach will check if the position of the internal pointer has changed and will try to restore it using this hash. <br><br>  Let's see what it means to "try."  The first example shows how changing the internal pointer does not change the foreach mode: <br><br><pre> <code class="php hljs">$array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; $ref =&amp; $array; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $value) { var_dump($value); reset($array); } <span class="hljs-comment"><span class="hljs-comment">// output: 1, 2, 3, 4, 5</span></span></code> </pre><br><br>  Now let's try to unset the element that the foreach will address on the first pass (key 1): <br><br><pre> <code class="php hljs">$array = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; $ref =&amp; $array; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $value) { var_dump($value); <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($array[<span class="hljs-number"><span class="hljs-number">1</span></span>]); reset($array); } <span class="hljs-comment"><span class="hljs-comment">// output: 1, 1, 3, 4, 5</span></span></code> </pre><br><br>  Here you will see that the counter is reset, because it was not possible to find an element with a suitable hash. <br><br>  Keep in mind that a hash is just a hash.  There are collisions.  Now let's try this: <br><br><pre> <code class="php hljs">$array = [<span class="hljs-string"><span class="hljs-string">'EzEz'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'EzFY'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'FYEz'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>]; $ref =&amp; $array; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $value) { <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($array[<span class="hljs-string"><span class="hljs-string">'EzFY'</span></span>]); $array[<span class="hljs-string"><span class="hljs-string">'FYFZ'</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; reset($array); var_dump($value); } <span class="hljs-comment"><span class="hljs-comment">// output: 1 1 3 4</span></span></code> </pre><br><br>  Works as we expected.  We deleted the EzFY key (the one where the foreach was), so a reset was made.  We also added an additional key, so at the end we see 4. <br><br>  And here comes the unknown.  What happens if you replace the FYFY key with FYFZ?  Let's try: <br><br><pre> <code class="php hljs">$array = [<span class="hljs-string"><span class="hljs-string">'EzEz'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'EzFY'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'FYEz'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>]; $ref =&amp; $array; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $value) { <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($array[<span class="hljs-string"><span class="hljs-string">'EzFY'</span></span>]); $array[<span class="hljs-string"><span class="hljs-string">'FYFY'</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; reset($array); var_dump($value); } <span class="hljs-comment"><span class="hljs-comment">// output: 1 4</span></span></code> </pre><br><br>  Now the cycle has moved directly to the new element, skipping everything else.  This is because the FYFY key has a collision with EzFY (in fact, all the keys from this array too).  More than this, the FYFY element is located at the same address in memory as the EzFY element that has just been deleted.  So for PHP it will be the same position with the same hash.  The position is ‚Äúrestored‚Äù and the transition to the end of the array occurs. </div><p>Source: <a href="https://habr.com/ru/post/172647/">https://habr.com/ru/post/172647/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../172631/index.html">How, in your opinion, should antiviruses be perceived by Guard@Mail.Ru and other similar software?</a></li>
<li><a href="../172633/index.html">First look at the HTC One</a></li>
<li><a href="../172637/index.html">Android and Chrome OS on the road to unification: Sundar Pichai becomes the new head of Android</a></li>
<li><a href="../172641/index.html">Why modern interfaces are bad</a></li>
<li><a href="../172643/index.html">School business is not a hindrance. 10 entrepreneurs from 7 to 15 years</a></li>
<li><a href="../172651/index.html">Building a system for optical recognition of structural information on the example of Imago OCR</a></li>
<li><a href="../172653/index.html">On the responsibility of advertisers placing advertisements on torrents and file hosting</a></li>
<li><a href="../172655/index.html">Device and setting of EPU at cellular base station</a></li>
<li><a href="../172661/index.html">Text output in iOS: CoreText, NSAttributedString</a></li>
<li><a href="../172663/index.html">The realities of the Chinese Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>