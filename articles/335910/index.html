<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Own bike for JSON API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! At the recent Superjob IT Meetup, I talked about how we at Superjob are developing our API for a project with a million people and a bunch of d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Own bike for JSON API</h1><div class="post__text post__text-html js-mediator-article">  Hello!  At the recent Superjob IT Meetup, I <a href="https://youtu.be/EfL8lsUTlFo%3Ft%3D7m32s">talked</a> about how we at Superjob are developing our API for a project with a million people and a bunch of different platforms. <br><br>  In this article I would like to talk about why we could not dwell on any of the dozens of ready-made solutions, how painful it was to write our own and what awaits you if you decide to repeat our path.  All interested in asking under the cat. <br><br><img src="https://habrastorage.org/web/c05/b9e/116/c05b9e116ef94b519a650cc5ce44bdd3.jpg"><a name="habracut"></a><br><h3>  Instead of intro </h3><br>  The API history in Superjob began with a harsh XML API.  From it we moved to a concise JSON, and later, tired of arguing about what is more correct - {success: true} or {result: true}, implemented the <a href="http://jsonapi.org/">JSON API</a> .  Over time, we abandoned some of its features, agreed on data formats, and wrote our version of the spec, which retained backward compatibility with the original.  Exactly on this spec, the latest, third version of our API works, to which we gradually transfer all our services. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For our purposes, when most endpoints in the API accept or give away certain objects, the JSON API has proven to be an almost perfect solution.  At the heart of this spec are the entities and their connections.  Entities are typed, have a fixed set of attributes and relationships, and are inherently very similar to the models with which we are accustomed to working in code.  Work with entities is carried out in accordance with the principles of REST - a protocol over HTTP, as, for example, in SOAP or JSON-RPC, no.  The format of the request almost completely repeats the format of the response, which greatly facilitates the life of both the server and the client.  For example, a typical JSON API response is: <br><br><pre><code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"resume"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">"attributes"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"position"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"relationships"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"owner"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span> } } } }, <span class="hljs-attr"><span class="hljs-attr">"included"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-attr"><span class="hljs-attr">"attributes"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } } ] }</code> </pre> <br>  Here we see an entity of type resume, with an owner association on an entity of type user.  If the client wanted us to send such an entity, he would put the exact same json in the request body. <br><br><h3>  The first steps </h3><br>  Initially, the implementation of our API was very naive: the answers of endpoints were formed directly in the actions, the data from the client were obtained using a small add-on over Yii1, on which our server application works, and the documentation lived in a separate file that was filled in by hand. <br><br>  With the transition to the JSON API, we turned the add-in into a full-fledged framework that controlled the transformation (mapping) of the models in essence, and also managed the transport layer (parsing requests and generating responses). <br><br>  To mapping the model into essence, it was necessary to describe two additional classes: the DTO for the entity and the hydrator that would fill the DTO with data from the model.  This approach made the mapping process quite flexible, but in reality this flexibility turned out to be evil: our hydrators eventually became clouded with copy-paste, and the need for each model to start another 2 classes led to the swelling of our code base. <br><br>  The transport layer was also far from ideal.  The developer was forced to constantly think about the internal structure of the JSON API: as was the case with model mapping, full control over the process led to the need to drag almost identical code from the action to the action. <br><br>  We began to think about switching to a third-party solution that works with the JSON API.  On the JSON API site there is a rather impressive list of implementations of specs in various languages ‚Äã‚Äãfor both the server and the client.  There were 18 projects implementing the server part in PHP at the time of writing this article, of which none approached us: <br><br><ul><li>  First, third-party solutions had all the same problems as our own ‚Äî too much extra code, not enough automation.  In some cases, certain requirements were imposed on the models (for example, interface implementation), and with our amount of code this could result in serious refactoring.  For requests and responses to work, in any case, we would have to write an adapter linking the chosen solution to Yii. <br><br></li><li>  Secondly, the overwhelming number of third-party solutions supported one-to-one mapping: you have one model, you can turn it into one entity.  This is a normal case, when the data in the models is stored in the form in which you would like to give them to the client, but in reality this is not always the case.  For example, the resume model has attributes with contacts, but the client can receive these contacts only under certain conditions.  It would be great to bring contacts into a separate entity related to the essence of the resume itself, thus turning one model into several entities, but in third-party decisions this can be done only through crutches. <br><br></li><li>  Thirdly, we wanted to simplify the development of typical endpoints as much as possible, so that the programmer who is faced with the task of writing an endpoint that selects models from the base and sends them to the client does not have to write the same type of code each time.  However, third-party solutions did not offer any integration with DBAL. <br><br></li><li>  Finally, fourthly, we wanted to simplify the writing of documentation and tests, but third-party solutions for the most part did not provide any information about what attributes and relationships a particular entity has. </li></ul><br>  The need to start writing your own decision again became obvious :) <br><br><h2>  Framework Development </h2><br>  After analyzing the shortcomings of our past development and third-party solutions, we formed our own vision of what our new framework should be, which received the very original name Mapper: <br><br><ul><li>  First of all, instead of writing DTO and hydrators, we decided to describe the entire mapping in the config. </li><li>  This config, unnoticed by the developer, should have been compiled into PHP code, which, in turn, would be used to hydrate entities. </li><li>  All work with the JSON API was to be carried out behind the scenes: for typical endpoints, all work would be reduced to describing business logic and obtaining models. </li><li>  Finally, as mentioned above, we wanted to integrate our solution with DBAL, documentation, and tests. </li></ul><br><h3>  Core </h3><br>  The framework is based on compiled hydrators, that is, objects that fill models and build entities.  What knowledge should a hydrator have to cope with the task?  First of all, he must know from which models and which entity he will build.  He must understand what properties and connections the entity has and how they relate to the properties and connections of the original models. <br><br>  Let's try to describe the config for such a hydrator.  The config format is YAML, which is easy to write, easy to read, and easy to parse (we used <a href="http://symfony.com/doc/current/components/yaml.html">symfony / yaml</a> ). <br><br><pre> <code class="hljs pgsql">entities: TestEntity: classes: - TestModel attributes: id: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-type"><span class="hljs-type">integer</span></span> accessor: <span class="hljs-string"><span class="hljs-string">'@getId'</span></span> mutator: <span class="hljs-string"><span class="hljs-string">'@setId'</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: string accessor: <span class="hljs-type"><span class="hljs-type">name</span></span> mutator: <span class="hljs-type"><span class="hljs-type">name</span></span> relations: relatedModel: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: TestEntity2 accessor: relatedModel relatedModels: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: TestEntity3[] accessor: <span class="hljs-string"><span class="hljs-string">'@getRelatedModels'</span></span></code> </pre> <br>  Here, the TestEntity entity is collected from the TestModel model.  An entity has two attributes: id, which is obtained from the getId getter, and name ‚Äî from the name property.  Also, an entity has two connections: a single relatedModel, which consists of an entity of type TestEntity2, and multiple relatedModels, which consists of entities of TestEntity3. <br><br>  Compiled from this configuration hydrator is as follows: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestEntityHydrator</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hydrator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'TestEntity'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getClasses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [Method::DEFAULT_ALIAS =&gt; TestModel::class]; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompiledAttribute(<span class="hljs-string"><span class="hljs-string">'id'</span></span>, Type::INTEGER)) -&gt;setAccessor( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodCallable( Method::DEFAULT_ALIAS, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $modelArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $modelArray[Method::DEFAULT_ALIAS]-&gt;getId(); } ) ) -&gt;setMutator( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodCallable( Method::DEFAULT_ALIAS, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $modelArray, $value)</span></span></span><span class="hljs-function"> </span></span>{ $modelArray[Method::DEFAULT_ALIAS]-&gt;setId($value); } ) ), <span class="hljs-string"><span class="hljs-string">'name'</span></span> =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompiledAttribute(<span class="hljs-string"><span class="hljs-string">'name'</span></span>, Type::STRING)) -&gt;setAccessor( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodCallable( Method::DEFAULT_ALIAS, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $modelArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $modelArray[Method::DEFAULT_ALIAS]-&gt;name; } ) ) -&gt;setMutator( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodCallable( Method::DEFAULT_ALIAS, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $modelArray, $value)</span></span></span><span class="hljs-function"> </span></span>{ $modelArray[Method::DEFAULT_ALIAS]-&gt;name = $value; } ) ) -&gt;setRequired(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>), ]; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildRelations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'relatedModel'</span></span> =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompiledRelation(<span class="hljs-string"><span class="hljs-string">'relatedModel'</span></span>, TestEntity2Hydrator::getName()))-&gt;setAccessor( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodCallable( Method::DEFAULT_ALIAS, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $modelArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $modelArray[Method::DEFAULT_ALIAS]-&gt;relatedModel; } ) ), <span class="hljs-string"><span class="hljs-string">'relatedModels'</span></span> =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompiledRelation(<span class="hljs-string"><span class="hljs-string">'relatedModels'</span></span>, TestEntity3Hydrator::getName()))-&gt;setAccessor( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodCallable( Method::DEFAULT_ALIAS, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $modelArray)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $modelArray[Method::DEFAULT_ALIAS]-&gt;getRelatedModels(); } ) )-&gt;setMultiple(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>), ]; } }</code> </pre><br>  All this monstrous code, in fact, only describes the data that is in essence.  Agree, to write this by hand, and even for each entity that is in the project, it would not be great at all. <br><br>  In order for everything described above to work, we needed to implement three services: a config parser, a validator and a compiler. <br><br>  The parser was engaged in following the changes to the <a href="https://symfony.com/doc/current/components/config/caching.html">config (symfony / config</a> helped us with this) and, if such changes were found, reread all the <a href="https://symfony.com/doc/current/components/config/caching.html">config</a> files, merged them and passed them to the validator. <br><br>  The validator checked the correctness of the config: first, the compliance with the json schema was checked, which we described for our config (here we used <a href="https://github.com/justinrainbow/json-schema">justinrainbow / json-schema</a> ), and then all the mentioned classes, their properties and methods were checked for existence. <br><br>  Finally, the compiler took the validated config and collected PHP code from it. <br><br><h3>  DBAL Integration </h3><br>  For historical reasons, there are two DBALs in our project together: the standard for Yii1 ActiveRecord and Doctrine, and we wanted to make friends our framework with both.  By integration, it was understood that Mapper would be able to independently both receive data from the database and save it. <br><br>  To achieve this, we first needed to make small changes to the config.  Since in the general case the name of the connection in the model may differ from the name of the getter or the property that returns this connection (this is especially true for Doctrine), we needed to be able to tell the Mapper what name this or that DBAL connection is known by.  To do this, we added the internalName parameter to the link description.  Later, the same internalName appeared in the attributes, so that Mapper could independently perform selections by fields. <br><br>  In addition to internalName, we added to the config knowledge about which DBAL the entity belongs to: the adapter parameter specified the name of the service that implemented the interface that allows Mapper to interact with DBAL. <br><br>  The interface had the following form: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDbAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Statement  . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $className * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> mixed $context * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $relationNames * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> IDbStatement */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statementByContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $className, $context, array $relationNames)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IDbStatement</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Statement   . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $className * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $attributes * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $relationNames * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> IDbStatement */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statementByAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $className, array $attributes, array $relationNames)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IDbStatement</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** *    . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $className * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> mixed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $className)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** *  . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> mixed $model */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($model)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** *      . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> mixed $parent * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> mixed $child * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $relationName */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">link</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parent, $child, string $relationName)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** *     . * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> mixed $parent * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> mixed $child * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $relationName */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($parent, $child, string $relationName)</span></span></span></span>; }</code> </pre><br><br>  In order to simplify interaction with DBAL, we introduced the concept of context.  The context is a certain object, having received which, DBAL should understand, it should fulfill what request.  In the case of ActiveRecord, CDbCriteria is used as the context, for Doctrine - QueryBuilder. <br><br>  For each DBAL, we wrote our adapter implementing the IDbAdapter.  There were no surprises: for example, it turned out that during the entire existence of Yii1 not a single extension was written that would support the preservation of all kinds of connections ‚Äî I had to write my own wrapper. <br><br><h3>  Documentation and tests </h3><br>  We use <a href="http://behat.org/en/latest/">Behat</a> for integration tests and <a href="https://swagger.io/">Swagger</a> for documentation.  Both tools natively support JSON Schema, which allowed us to integrate Mapper support into them without any problems. <br><br>  Tests for Behat are written in the Gherkin language.  Each test is a sequence of steps, and each step is a sentence in a natural language. <br><br>  We added steps that integrated JSON API and Mapper support into Behat: <br><br><pre> <code class="hljs pgsql">#   <span class="hljs-keyword"><span class="hljs-keyword">When</span></span> I have entity "resume" <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> I have entity attributes: | <span class="hljs-type"><span class="hljs-type">name</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> | | profession |  | #   <span class="hljs-keyword"><span class="hljs-keyword">And</span></span> I have entity relationship "owner" <span class="hljs-keyword"><span class="hljs-keyword">with data</span></span>: | <span class="hljs-type"><span class="hljs-type">name</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> | | id | <span class="hljs-number"><span class="hljs-number">100</span></span> | #    ,    resume <span class="hljs-keyword"><span class="hljs-keyword">Then</span></span> I send entity via "POST" <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> "/resume/" <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> entity "resume"</code> </pre> <br><br>  In this test, we create the summary entity, fill in its attributes and relationships, send the request and validate the answer.  At the same time, the whole routine is automated: we don‚Äôt need to compose the request body, since our helpers for Behat do this, we don‚Äôt need to describe the JSON Schema of the expected response, since it will be generated by the Mapper. <br><br>  The situation is somewhat more interesting with documentation.  The JSON Schema files for Swagger were originally generated on the fly from YAML sources: as mentioned, YAML is much simpler to write than the same JSON, but Swagger only understands JSON.  We have added this mechanism so that the final JSON Schema includes not only the contents of the YAML files, but also the descriptions of the entities from the mapper.  So, for example, we taught Swagger to understand links like: <br><br> <code>$ref: '#mapper:resume'</code> <br> <br>  Or: <br><br> <code>$ref: '#mapper:resume.collection.response'</code> <br> <br>  And Swagger rendered the resume entity object or the entire server response object with the collection of resume entities, respectively.  Thanks to such links, as soon as Mapper's config was changed, the documentation was automatically updated. <br><br><h3>  findings </h3><br>  With a lot of effort, we made a tool that significantly simplified the lives of developers.  To create trivial endpoints, it is now enough to describe the entity in the config file and add a couple of lines of code.  Automating the routine of writing tests and documentation allowed us to save time on developing new endpoints, and Mapper‚Äôs flexible architecture made it possible to easily extend its functionality when we needed it. <br><br>  The time has come to answer the main question I voiced at the beginning of the article - what did it cost us to make our bike?  And do you need to make your own? <br><br>  The intensive development phase of Mapper took us about three months.  We still continue to add new features to it, but in a much less intensive mode.  In general, we are satisfied with the result: since Mapper was designed taking into account the peculiarities of our project, he copes with the tasks assigned to him much better than any third-party solution. <br><br>  Should you go our way?  If your project is still young and the code base is small, it is quite possible that writing your bike for you would be an unnecessary waste of time, and the best choice would be to integrate a third-party solution.  However, if your code has been written for many years and you are not ready to conduct serious refactoring, then you should definitely think about your own decision.  Despite the initial difficulties in the development, it can significantly save you time and energy in the future. </div><p>Source: <a href="https://habr.com/ru/post/335910/">https://habr.com/ru/post/335910/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335900/index.html">Mountebank: flexible mocking web API</a></li>
<li><a href="../335902/index.html">Virtualization operation: comparison of virtual server and shared-hosting</a></li>
<li><a href="../335904/index.html">A bit of the history of cryptography CCPP: M-105, codenamed Agat</a></li>
<li><a href="../335906/index.html">Available on cryptography on elliptic curves</a></li>
<li><a href="../335908/index.html">Using MVP + TDD in the development of iOS applications</a></li>
<li><a href="../335916/index.html">Improvised barcode reader for 1C via Telegram on Go</a></li>
<li><a href="../335920/index.html">Description of sorting algorithms and comparison of their performance</a></li>
<li><a href="../335922/index.html">Join the game: the MAZE DevOps game from ITSumma</a></li>
<li><a href="../335924/index.html">On the quality of requirements in IT projects, to be honest (from the standpoint of the development team). Part 2</a></li>
<li><a href="../335926/index.html">Implementation and alternative of basic jQuery functions in pure javascript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>