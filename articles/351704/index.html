<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>History of ES6 Modules</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vladislav Vlasov, a software engineer at Developer Soft and a teacher at the Netology course, wrote a series of articles on EcmaScript6 especially for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>History of ES6 Modules</h1><div class="post__text post__text-html js-mediator-article">  <i>Vladislav Vlasov, a software engineer at <a href="http://www.developersoft.ru/">Developer Soft</a> and a teacher at the <a href="https://netology.ru/%3Futm_source%3Dblog%26utm_medium%3D747%26utm_campaign%3Dhabr">Netology</a> course, wrote a series of articles on EcmaScript6 especially for the blog.</i>  <i>In the <a href="https://habrahabr.ru/company/netologyru/blog/347516/">first part</a> , examples of the considered dynamic analysis of code in EcmaScript using Iroh.js, in the <a href="https://habrahabr.ru/company/netologyru/blog/348632/">second</a> focused on the implementation of canceled Promises.</i>  <i>This article will talk about the history of ES6 modules.</i> <br><br> <a href="https://habrahabr.ru/company/netologyru/blog/351704/"><img src="https://habrastorage.org/webt/t6/nw/0q/t6nw0qfsu2febrc2_yswaq6gsga.jpeg"></a> <br><br>  The history of the EcmaScript language extends from a simple scripting language in the browser down to the modern general-purpose language that works in various host environments.  Along with the complication of the language, the need to organize a modular structure and reuse the code with its placement in libraries also appeared.  The first libraries were imported by loading the corresponding JS file from the supplier‚Äôs host or CDN, and the interaction was carried out, as a rule, by exporting functions and classes with known names to the global space - the window object. <br><a name="habracut"></a><br>  This scheme was used for a long time, and in simple cases it works quite successfully. <br><blockquote>  Difficulties begin when libraries and the relationships between them become too much. </blockquote> First, the global host object is clogged, and all link libraries must import non-conflicting unique names.  Secondly, there is no explicit way to ensure inter-library communication and reuse. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The issue of nested dependencies can be solved using <code>dynamic &lt;script&gt; injection</code> in the DOM model, and reuse can be achieved by exporting with a known name in the global host object, but this is not a universal solution and it is based solely on an implicit agreement between the authors of the libraries and using their client scripts.  Partial name negotiation is solved by passing parameters to the <code>query string</code> in the <code>query string</code> specifying the namespaces for the JS library being loaded, but this is also not universal. <br><br>  There remain some fundamental problems associated with asynchronous loading and interaction with the DOM model.  Some libraries must be loaded earlier than others if the latter are dependent on the former.  In the case of dynamic imports, this requires the correct installation of an async flag or manipulation of the <code>readystatechanged</code> event, depending on the vendor and browser version. <br><br>  Of course, for this general case there is a solution <a href="https://www.html5rocks.com/en/tutorials/speed/script-loading/">described in the article</a> .  However, firstly, it requires careful monitoring of dependencies in all loaded libraries, and secondly, if some libraries are <code>polyfills</code> that need to monitor DOM state and events.  In case of <code>defer fallfack</code> this will not work. <br><br>  For a universal solution of the problems described above, several standards for the organization of library modules for JS were developed, the most famous of which are <a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a> (Asyncronous module definition), <a href="https://github.com/umdjs/umd">UMD</a> (Universal module definition) and <a href="http://www.commonjs.org/">CommonJS</a> .  Due to the fact that the authors followed the modules of the general declaration format and the presence of a common file uploader, most of the problems were solved. <br><br>  In the meantime, the Node.JS platform was actively developing, where the dependencies of the modules were solved in a completely different way - by means of a synchronous require-call, and the modules had the corresponding specific format.  Then the technical committee TC-39 began developing a universal means of importing modules, which was supposed to solve all the above mentioned tasks and at the same time work equally on the server and the client and provide the synchronous and asynchronous semantics of module loading.  ES6-modules have become such a tool. <br><br><h1>  Support for ES6 modules through transpile and bundle builder </h1><br>  With the advent of the Ecmascript 262 version 6 specification and subsequent revisions, many new syntactic constructs and native functions were added to the language.  As a rule, most of them could easily be run on older versions of JS engines due to preliminary transpile inga - for syntactic constructions, and adding polyfills - for missing functions. <br><br>  <a href="http://www.ecma-international.org/ecma-262/6.0/">ES6 modules</a> also provided synchronous non-blocking load semantics, binding bindings for exported / imported entities, modular visibility, and other aspects that are not easy to provide with the usual transpile ing. <br><br>  The developers wanted to create web applications in the current Ecmascript dialect of 6, 7, 8th and <a href="https://tc39.github.io/ecma262/">later versions</a> , and this required the convenience of executing transpile-ing and adding appropriate <code>polyfills</code> for applications in an automatic way so that the developed application could work in relatively old browsers no problem. <br><br>  The cumulative solution to these problems was the <code>bundle builder</code> , customizable along with the connected <code>transpilers</code> and <code>polyfills</code> .  The idea is that the application code is converted to a reference dialect, which is considered supported by all current browsers, for example, ES3 or ES5 - depending on the task.  After that, all library module files and application code are combined into one large file - the so-called bundle.  This file is sent to the client and no longer requires any synchronous or asynchronous imports, since all the necessary code is already in the <code>bundle</code> and is available by code numbers. <br><br>  Known solutions implementing the appropriate approach: <a href="http://browserify.org/">Browserify</a> and <a href="https://webpack.js.org/">Webpack</a> , the latter being currently the de facto standard.  The de facto transpiler is <a href="https://babeljs.io/">Babel</a> .  The proposed scheme has a large number of advantages. <br><br>  First, thanks to the transpiler scheme, the original project can actually be written in any language.  As a rule, this is the latest version of EcmaScript or TypeScript, but the possibilities for extending the syntax are almost endless.  One of the known extensions for ES - <a href="https://babeljs.io/docs/plugins/preset-react/">JSX</a> , used in the React library and its derivatives. <br><br>  Secondly, by controlling the conversion of the code in the transpile-ing phase, it is possible to implement support even for such functionality as <a href="https://www.npmjs.com/package/babel-plugin-proxy">ES6 proxy</a> or <a href="https://www.npmjs.com/package/babel-plugin-object-source">reflexive information in the code</a> . <br><br>  Among the interesting implications of using bundled code is the ability to write client code in <a href="http://fable.io/">F #</a> or <a href="https://github.com/ocsigen/js_of_ocamlv">Ocaml</a> and much more. <br><br>  In addition to the obvious advantages, the bundled solution also has some obvious drawbacks. <br><br>  First, the resulting <code>bundle</code> , even considering the possible compression, has quite a large amount and can be noticeable with mobile traffic.  Secondly, the <code>bundle</code> includes absolutely all dependencies of the web application that will be downloaded and interpreted in the user's browser, even if it does not use the elements of the web application in which they are needed.  Thirdly, the possibility of caching library dependencies disappears, since the <code>bundle</code> either completely relevant or requires a complete update. <br><br>  Negative effects occur in the development and debugging of the application.  Since bundling is almost always associated with <code>transpile</code> , the process of getting a new <code>bundle</code> , especially for a large project, can take a long time.  This means that during the development and debugging process, after making the next change, the <code>bundle</code> needs to be rebuilt and the new version loaded onto the client.  In addition, due to machine conversion of the source code, it becomes almost unreadable, which leads to difficulties in using the debugger in the browser. <br><br>  Of course, most of the problems identified above have their own solutions.  In order not to load the entire application code into the browser in the production mode, the codepack uses <a href="https://webpack.js.org/guides/code-splitting/">code chunk splitting</a> technology.  You can also use a dynamic version of the import that returns Promise and provides asynchronous loading of the target module. <br><br>  For debugging purposes, there are also solutions.  Viewing the original source code, and even navigating through it in a browser debugger, is achieved through the specification of <code>source maps</code> embedded in the target <code>bundle</code> in development mode.  A partial update without a full reload <code>bundle</code> is solved using the Hot Module Reload, although a truly incremental update only works correctly in simple cases. <br><br><h1>  Native support for ES6 modules </h1><br>  The scheme with bundle dependencies was relevant for its time, but currently all modern browsers have native support for ES6 modules. <br><br><img src="https://habrastorage.org/webt/so/o5/dg/soo5dgclsrfcjfqmo-2ljpvfkam.png"><br>  This requires a revision of the view on the assembly of modern web applications, since the <code>bundle</code> was a necessity due to imperfections and the lack of required functionality in browsers.  After its appearance, the use of native constructs provides a much better result. <br><br>  First, excessive <code>transpile</code> syntactic constructions and replacing it with an emulating code leads to slowing down and complication of optimizations.  This applies to async and generator functions that are replaced by the <a href="https://www.npmjs.com/package/regenerator-runtime">regenerator runtime</a> , and <code>let</code> / <code>const</code> lexical variables that are converted to suboptimal var declarations. <br><br>  Of course, this is not directly related to the ES6 modules as such, but is usually determined by the scheme of assembly and delivery to the client application.  In this sense, these are interrelated things. <br><br>  Secondly, the modules are efficient in terms of performance.  ES6 modules are loaded and executed deferred by default.  This means that it is impossible to mistakenly add blocking modules to a web application, and accordingly there is no <a href="https://www.stevesouders.com/blog/2010/06/01/frontend-spof/">SPOF</a> problem out of the box. <br><br>  To maintain performance in old browsers that do not have support for ES6 modules, you can have the <code>bundle</code> assembled and give it to old agents.  At the same time, due to the design features of importing ES6 modules, no conditional webpack configuration is required with segregation of the supplied code depending on the User-Agent of the browser string, or feature discovery. <br><br>  To distinguish, the following code is sufficient: <br><br><pre> <code class="javascript hljs">&lt;html&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">head</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"app/index.js"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"dist/bundle.js"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">defer</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">nomodule</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">head</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;!-- ‚Ä¶ --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">html</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  A browser without support for ES6 modules will simply download dist / bundle.js and will work according to the old scheme.  A modern browser will take app / index.js as an entry point and will load dependent resources automatically. <br><br>  You can read more about webpack settings for the above scheme, asynchronous and deferred module loading, dependency caching, inline modules and CORS policies in more details:  And <a href="https://jakearchibald.com/2017/es-modules-in-browsers/">ECMAScript modules in browsers</a> . <br><br><h1>  Results </h1><br>  EcmaScript has gone through a long history and continues to evolve to this day.  Many solutions were relevant for their time and allowed to solve problems, including proactive support for functionality not yet built into client agents.  Now browsers and Node.js-server releases update versions quite often, adding to them the modern functionality of EcmaScript. <br><br>  As a result, solutions that allow in the past to provide emulation of support for new features in popular versions of browsers today apply to outdated agents, which, depending on the task, it makes sense to support separately or eliminate them altogether. <br><br>  Preliminary resolution and linking of modules and their subsequent bundle, which was recently the main way to support ES6 modules in most browsers, now has a negative impact on them and interferes with optimizations and caching tools. <br><br>  Thus, while customizing the assembly of a web application, it is advisable to provide modern agents with code in modern EcmaScript, including syntax elements and import / export of modules. <br><br><h2>  From the Editor </h2><br>  Courses "Netology" on the topic: <br><br><ul><li>  Profession " <a href="https://netology.ru/programs/front-end%3Futm_source%3Dblog%26utm_medium%3D747%26utm_campaign%3Dhabr">Frontend-developer</a> "; <br></li><li>  profession " <a href="https://netology.ru/programs/web-developer%3Futm_source%3Dblog%26utm_medium%3D747%26utm_campaign%3Dhabr">Web developer</a> "; <br></li><li>  online program " <a href="https://netology.ru/programs/javascript%3Futm_source%3Dblog%26utm_medium%3D747%26utm_campaign%3Dhabr">Basic course on JavaScript</a> "; <br></li><li>  online program " <a href="https://netology.ru/programs/node%3Futm_source%3Dblog%26utm_medium%3D747%26utm_campaign%3Dhabr">Node, AngularJS and MongoDB: development of full-fledged web applications</a> "; <br></li><li>  online program " <a href="https://netology.ru/programs/html-javascript%3Futm_source%3Dblog%26utm_medium%3D747%26utm_campaign%3Dhabr">JavaScript in the browser: we create interactive web pages</a> ". <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/351704/">https://habr.com/ru/post/351704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351692/index.html">Disruption of a large-scale hacker attack on Windows users in Russia: part 2</a></li>
<li><a href="../351694/index.html">Java 10 General Availability</a></li>
<li><a href="../351696/index.html">Why pay a reputation manager</a></li>
<li><a href="../351698/index.html">The most common questions on the interview programmer graphics</a></li>
<li><a href="../351700/index.html">Trends in outsourcing. Forecast for 2020</a></li>
<li><a href="../351706/index.html">Learn OpenGL. Lesson 4.11 - Smoothing</a></li>
<li><a href="../351708/index.html">Preview RamblerFront & # 4</a></li>
<li><a href="../351710/index.html">Four levels of one-page apps that you need to know about</a></li>
<li><a href="../351712/index.html">Security Week 9: Miner eliminates competitors, snapshots for traffic lights and extremely intrusive cameras</a></li>
<li><a href="../351714/index.html">Evil by Design: interfaces from Mephistopheles (part two)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>