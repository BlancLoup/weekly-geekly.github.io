<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Guide to background work in Android. Part 4: RxJava</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Event handling is a loop. 

 In the last part, we talked about using thread pool executors for background work in Android. The problem with this appro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Guide to background work in Android. Part 4: RxJava</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/vn/yi/x9/vnyix9bhqbcrtq11czmjjgusjhg.jpeg"><br>  <sub>Event handling is a loop.</sub> <br><br>  In the last part, we <a href="https://habrahabr.ru/company/jugru/blog/351166/">talked</a> about using thread pool executors for background work in Android.  The problem with this approach turned out to be that the sending event knows how the result should be processed.  Now let's see what RxJava offers. <br><br>  <b>Disclaimer: This is not an article on how to use RxJava in Android.</b>  <b>Such texts on the Internet and so prorva.</b>  <b>This one is about the details of the library implementation.</b> <br><a name="habracut"></a><br>  Generally speaking, RxJava is not even a tool specifically for working in the background, it is a tool for handling event streams. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Background work is only one aspect of such processing.  The general idea of ‚Äã‚Äãthe approach is to use Scheduler.  Let's look directly at the code for this class: <br><br><pre><code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scheduler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Disposable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scheduleDirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Runnable run)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Disposable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scheduleDirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Runnable run, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delay, @NonNull TimeUnit unit)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Disposable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">schedulePeriodicallyDirect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Runnable run, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> initialDelay, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> period, @NonNull TimeUnit unit)</span></span></span><span class="hljs-function"> </span></span>{ ... } { <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends Scheduler &amp; Disposable&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Function&lt;Flowable&lt;Flowable&lt;Completable&gt;&gt;, Completable&gt; combine)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>  Pretty hard, right?  The good news is that you don‚Äôt have to do it yourself!  The library already includes a number of such schedulers: Schedulers.io (), Schedulers.computation (), and so on.  All that is required of you is to transfer the scheduler instance to the subscribeOn () / observeOn () method of your Rx chain: <br><br><pre> <code class="hljs pgsql">apiClient.<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>(auth) // <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> code omitted .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread())</code> </pre><br>  Then RxJava will do the rest for you: take the lambdas that you pass to the operators, and execute them on the desired scheduler. <br><br>  For example, if you want your observers to change the user interface, all you have to do is pass AndroidSchedulers.mainThread () to observeOn ().  And the trick is: no more unnecessary connectivity, no platform-specific code, one happiness.  Of course, AndroidSchedulers is not included in the original RxJava library, but is connected as part of a separate one, but this is just another line in your build.gradle. <br><br>  And what's so complicated about threads?  The trick is that you cannot simply place subscribeOn () / observeOn () anywhere in your rxChain (which would be convenient, right?) Instead, you have to consider how these operators get their schedulers.  First, let's understand that each time you call map, or flatMap, or filter, or something, you get a new object. <br><br>  For example: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attemptLoginRx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { showProgress(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) apiClient.login(auth) .flatMap { user -&gt; apiClient.getRepositories(user.repos_url, auth) } .map { list -&gt; list.map { it.full_name } } .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doFinally { showProgress(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) } .subscribe( { list -&gt; showRepositories(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, list) }, { error -&gt; Log.e(<span class="hljs-string"><span class="hljs-string">"TAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"Failed to show repos"</span></span>, error) } ) }</code> </pre><br>  So almost every line here creates a new object: <br><br><pre> <code class="hljs pgsql">// <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SingleFlatMap() val flatMap = apiClient.<span class="hljs-keyword"><span class="hljs-keyword">login</span></span>(auth) .flatMap { apiClient.getRepositories(it.repos_url, auth) } // <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SingleMap val map = flatMap .map { list -&gt; list.map { it.full_name } } // <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SingleSubscribeOn val subscribeOn = map .subscribeOn(Schedulers.io()) // <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SingleObserveOn val observeOn = subscribeOn .observeOn(AndroidSchedulers.mainThread()) // <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SingleDoFinally val doFinally = observeOn .doFinally { showProgress(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } // <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ConsumerSingleObserver val subscribe = doFinally .subscribe( { list -&gt; showRepositories(this@LoginActivity, list) }, { error -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Log</span></span>.e("TAG", "Failed to show repos", error) } ) }</code> </pre><br>  And, for example, SingleMap will get its scheduler through a call chain starting with a .subscribe () call at the end of our thread: <br><br><pre> <code class="hljs java"> <span class="hljs-meta"><span class="hljs-meta">@SchedulerSupport</span></span>(SchedulerSupport.NONE) <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SingleObserver&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; subscriber)</span></span></span><span class="hljs-function"> </span></span>{ ObjectHelper.requireNonNull(subscriber, <span class="hljs-string"><span class="hljs-string">"subscriber is null"</span></span>); subscriber = RxJavaPlugins.onSubscribe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, subscriber); ObjectHelper.requireNonNull(subscriber, <span class="hljs-string"><span class="hljs-string">"subscriber returned by the RxJavaPlugins hook is null"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { subscribeActual(subscriber); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NullPointerException ex) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ex; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable ex) { Exceptions.throwIfFatal(ex); NullPointerException npe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(<span class="hljs-string"><span class="hljs-string">"subscribeActual failed"</span></span>); npe.initCause(ex); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> npe; } }</code> </pre><br>  subsribeActual is implemented for each Single-operator as follows: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">source</span></span>.subscribe()</code> </pre> <br>  where source is an operator preceding the current one, so a chain is created with which we work and by which we reach the first created Single.  In our case, this is Single.fromCallable: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(auth: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Authorization</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Single&lt;GithubUser&gt; = Single.fromCallable { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">"https://api.github.com/user"</span></span>, auth = auth) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.statusCode != <span class="hljs-number"><span class="hljs-number">200</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Incorrect login or password"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> jsonObject = response.jsonObject with(jsonObject) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@with</span></span> GithubUser(getString(<span class="hljs-string"><span class="hljs-string">"login"</span></span>), getInt(<span class="hljs-string"><span class="hljs-string">"id"</span></span>), getString(<span class="hljs-string"><span class="hljs-string">"repos_url"</span></span>), getString(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) } }</code> </pre><br>  Inside this lambda we make our network calls. <br><br>  But where is our scheduler?  Here, inside SingleSubsribeOn: <br><br><pre> <code class="hljs php">@Override <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> void subscribeActual(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SingleObserver<span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span> super T&gt; s) { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SubscribeOnObserver&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SubscribeOnObserver&lt;T&gt;(s, source); s.onSubscribe(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>); Disposable f = scheduler.scheduleDirect(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>.task.replace(f); }</code> </pre><br>  In this case, the scheduler is the one we passed to the subsribeOn () method. <br><br>  All this code shows how the scheduler that we passed to the chain is used by the code that we passed to the operator's lambda. <br><br>  Also pay attention to the observeOn () method.  He creates an instance of the class (in our case SingleObserveOn), and its subscribeActial for us already looks trivial: <br><br><pre> <code class="hljs java"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribeActual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SingleObserver&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span><span class="hljs-function"> </span></span>{ source.subscribe(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObserveOnSingleObserver&lt;T&gt;(s, scheduler)); }</code> </pre><br>  But ObserveOnSingleObserver is much more interesting here: <br><br><pre> <code class="hljs kotlin">ObserveOnSingleObserver(SingleObserver&lt;? <span class="hljs-keyword"><span class="hljs-keyword">super</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">actual</span></span>, Scheduler scheduler) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">actual</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">actual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scheduler = scheduler; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> void onSuccess(T value) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value = value; Disposable d = scheduler.scheduleDirect(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); DisposableHelper.replace(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, d); }</code> </pre><br>  When you call observeOn in the scheduler stream, it is called by observer, which in turn opens up the possibility of switching threads directly in rxChain: you can get data from the server to Schedulers.io (), then perform resource-intensive calculations in Schedulers.computation (), update the UI , count something else, and then just go to the code in the subscribe. <br><br>  RxJava is a rather complicated ‚Äúunder the hood‚Äù, a very flexible and powerful tool for handling events (and, as a result, managing background work).  But, in my opinion, this approach has its drawbacks: <br><br><ol><li>  RxJava training takes a lot of time </li><li>  The number of operators that need to be learned is large, and the difference between them is not obvious. </li><li>  Call stack traces for RxJava are almost irrelevant to the code you write </li></ol><br>  What's next?  Of course, Kotlinov Korutiny! <br><br>  Previous articles in the series: <br><br><ul><li>  <a href="https://habrahabr.ru/company/epam_systems/blog/348894/">Part 1: AsyncTask</a> </li><li>  <a href="https://habrahabr.ru/company/jugru/blog/350094/">Part 2: Loaders</a> </li><li>  <a href="https://habrahabr.ru/company/jugru/blog/351166/">Part 3: Executors and EventBus</a> <br></li></ul><br><blockquote>  From the author: tomorrow and the day after tomorrow there will be a <b>Mobius</b> conference, where I <a href="https://mobiusconf.com/2018/spb/talks/mt2eecqokiosqguiooouu/">will talk</a> about Korutins at Kotlin.  If you are interested in a series of articles and want to continue - it is not too late to decide on its visit! </blockquote></div><p>Source: <a href="https://habr.com/ru/post/353852/">https://habr.com/ru/post/353852/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353838/index.html">Data Fest 2018: announcement and registration</a></li>
<li><a href="../353842/index.html">Three data centers without seams, or how VTB protects business systems</a></li>
<li><a href="../353844/index.html">DotNext 2018 Piter Conference Program Overview</a></li>
<li><a href="../353848/index.html">What's New in PostgreSQL 11: Embedded Web Search</a></li>
<li><a href="../353850/index.html">Pwn iNt All! We find vulnerabilities in scripting engines and open usermode-mechanisms for protecting Windows. Part 1</a></li>
<li><a href="../353854/index.html">How we broke Ceph</a></li>
<li><a href="../353856/index.html">Comparison of LAN scanning tools</a></li>
<li><a href="../353858/index.html">Open free webcast of the conference Mobius 2018 Piter</a></li>
<li><a href="../353862/index.html">Conference SMARTRHINO-2018</a></li>
<li><a href="../353864/index.html">Different facets of a digital enterprise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>