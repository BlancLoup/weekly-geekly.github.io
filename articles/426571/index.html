<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>System approach to speed: online measurements at the frontend</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Yandex speed command manually optimizes search results. Doing it blindly is difficult and often just useless. Therefore, the company has built an ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>System approach to speed: online measurements at the frontend</h1><div class="post__text post__text-html js-mediator-article">  The Yandex speed command manually optimizes search results.  Doing it blindly is difficult and often just useless.  Therefore, the company has built an infrastructure for collecting metrics, testing speed and analyzing the data. <br><br>  <b>Andrei Prokopyuk, a</b> Yandex interface developer, knows which metrics should be used and how to optimize everything. ( <a href="https://habr.com/users/andre_487/" class="user_link">Andre_487</a> ). <br><br><img src="https://habrastorage.org/webt/jh/gn/r4/jhgnr48w9fhjphnfjkjcggtsdds.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the core of the material is Andrei‚Äôs speech at the <a href="https://holyjs.ru/">HolyJS</a> conference.  Under the cut - and video, and text version of the report. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Whm2FMBIgA0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote>  In a couple of this report on online measurements there is a <a href="http://2018.holyjs-piter.ru/talks/2qmbjzjpl2iki2imckwsqc/">report by Alexey Kalmakov</a> (also from Yandex) on offline measurements, in his case there is no text version, but <a href="https://www.youtube.com/watch%3Fv%3DTzCMDlYMydA">video</a> is available. </blockquote><br><br>  Yandex search output consists of many different blocks, classes of responses to user requests.  More than 50 people work for them in the company, and so that the issuance rate does not fall, we constantly look after the development. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/044/4e1/e2a/0444e1e2a6db39e37b9c2a085c7433db.jpg"><br><br>  No one will argue that users like the fast interface more than the slow one.  But before you begin to optimize, it is important to understand how this will affect the business.  Do I need to spend time developers to accelerate the interface, if it does not affect the business metrics? <br><br>  To answer this question, I will tell two stories. <br><br><h2>  The history of the introduction of a specific web font on the issue </h2><br>  Having arranged an experiment with fonts, we found that the average content rendering time deteriorated by 3%, by 62 milliseconds.  Not so much, if you take it for a delta in a vacuum.  The noticeable delay to the naked eye begins only with 100 milliseconds - and yet the time until the first click immediately increased by one and a half percent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ef/2b5/548/4ef2b5548ae1789980552312d0b92857.jpg"><br><br>  Users began to interact with the page later.  The number of clicked pages has decreased by almost half a percentage point.  Reduced the time of presence on the service and increased the time of absence. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c15/215/b5f/c15215b5fb72633582890da9e018d4a4.jpg"><br><br>  We did not roll out the feature with fonts.  After all, these numbers seem small until you remember the scale of the service.  In reality, one and a half percent - hundreds of thousands of people. <br><br>  In addition, speed has a cumulative effect.  For one update with a share of unclipped - 0.4% will follow more and more.  In Yandex, similar features roll out dozens per day, and if you don‚Äôt fight for each share, it‚Äôs not long to go down to 10%. <br><br><h2>  LS Caching History </h2><br>  This story is connected with the fact that we inline a lot of static content on the page. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c33/3fd/7d2/c333fd7d205cc0695c8934cb0111c820.jpg"><br><br>  Due to the high variability, we cannot compile it into one bundle or deliver it with external resources.  Practice has shown that with inline delivery, JavaScript rendering and initialization occur most quickly. <br><br>  Once we decided that it would be a good idea to use the browser‚Äôs storage.  Put everything in localStorage and on subsequent logins to the page, load from there, and not transfer over the network. <br><br>  Then we focused mainly on the ‚ÄúHTML size‚Äù and ‚ÄúHTML delivery time‚Äù metrics and got good results.  As time went on, we invented new ways to measure speed, gained experience and decided to double-check, to conduct a reverse experiment, turning off optimization. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b9/37c/2c9/3b937c2c9c4f0a85c2e76a26d6fdfacf.jpg"><br><br>  The average HTML delivery time (the key metric for optimizing development) has increased by 12%, which is a lot.  But at the same time, the time was improved before the header was rendered, before content parsing began and before JavaScript was initialized.  Also reduced the time to first click.  The percentage of it is small - 0.6, but if you remember the scale ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f88/35c/0fd/f8835c0fdce5780914f129f41f445f8d.jpg"><br><br>  Turning off the optimization, we got a deterioration in the metric, noticeable only to specialists, and at the same time - an improvement noticeable to the user. <br><br>  From this we can draw the following conclusions: <br><br>  First, speed really affects business and business metrics. <br><br>  Secondly, optimization should be preceded by measurements.  If you introduce something, having badly measured, it is likely that you will not do anything useful.  The composition of the audience, the park of devices, interaction scenarios and networks are different everywhere, and you need to check what exactly will work for you. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/2c6/06b/0bf2c606bacfb7bc5769594fbc326a52.jpg"><br><br>  Once upon a time, Ash from the evil dead taught us to shoot first, then think or not think at all.  In speed so do not. <br><br>  And the third point: measurements must reflect the user experience.  For example, HTML size and delivery time are poor speed metrics, because the user does not sit with devTools and does not select the service with less delay.  But what kind of metrics are good and correct - let's tell further. <br><br><h2>  What and how to measure? </h2><br>  Dimensions should start with a few key metrics, which, unlike, for example, the size of HTML, are close to user experience. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/3c5/783/ec13c57830d7b1b3b8380273dda5bbc8.jpg"><br><br>  If TTFCP (time to first contentfull paint) and TTFMP (time to first meaningful paint) denote the time to the first rendering of the content and the time to redrawing of the significant content, then the third one - the time to initialization of the framework should be explained. <br><br>  This is the time when the framework has already passed through the page, collected all the necessary data and hung handlers.  If the user clicks somewhere at that moment, he will receive a dynamic response. <br><br>  And the last, fourth metric, the time before the first interactivity, is usually referred to as time to interactive (TTI). <br><br>  These metrics, unlike html size or delivery time, are close to user experience. <br><br><h2>  Time to firstcontentfull paint </h2><br>  To measure the time when a user saw the first content on a page, there is a Paint Timing API, which is currently available only in chromium.  Data from it can be obtained as follows. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e16/80a/c27/e1680ac270e35eaad20070c90e47066d.jpg"><br><br>  With this challenge, we get a set of events about drawing.  So far, two types of events are supported: first paint - any drawing and firstcontentfull paint - any rendering of content that is different from the white background of the empty tab and background content of the page. <br><br>  So we get an array of events, filter the firstcontentfull paint and send it with some ID. <br><br><h2>  Time to first meaningful paint </h2><br>  There is no event in the Paint Timing API that signals that significant content has been drawn on the page.  This is due to the fact that such content on each page is different.  If we are talking about video service, then the main thing is the player, in search results - the first non-advertising result.  There are a lot of services, and a universal API has not been developed yet.  But here in the course are good, proven crutches. <br><br>  In Yandex, there are two schools of crutches for measuring this metric: using RequestAnimationFrame and measuring with InterceptionObserver. <br><br>  In RequestAnimationFrame, rendering is measured using an interval. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22b/dfe/945/22bdfe945df84617220936267638cc21.jpg"><br><br>  Suppose there is some meaningful content.  Here is a div with a main-content class.  There is a script in front of it where RequestAnimationFrame is called twice. <br><br>  In the callback of the first call we write the lower limit of the interval.  In the second callback, the top one.  This is due to the frame structure that the browser renders. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/79d/783/a88/79d783a883b6a718095228cfbea29469.jpg"><br><br>  The first is the execution of JavaScript, then the analysis of styles, then the calculation of Layout, rendering and composition. <br><br>  Callback, calling RequestAnimationFrame, is activated at the same stage as JavaScript, and the content is drawn in the last segment of the frame during composition.  Therefore, in the first call we get only the lower limit, which is noticeably distant in time from the output of pixels on the screen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81c/788/f38/81c788f38c68e241cf3a34612503f9d0.jpg"><br><br>  Place two frames side by side.  It can be seen that at the end of the first one the content was rendered.  We write the lower bound of RequestAnimationFrame, called inside the first callback, and call the callback in the second frame.  Thus, we obtain the interval from JavaScript, called in the frame where the content was rendered, and to JavaScript in the second frame. <br><br><h2>  InterceptionObserver </h2><br>  Our second crutch works differently with the same content.  This time the script is placed below.  In it, we create an InterceptionObserver and subscribe to domNode. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd6/dea/87d/fd6dea87dd53e374e2ba19aa79d4a379.jpg"><br><br>  In this case, no additional parameters are passed, so we measure its intersection with the viewport.  This time and record as the exact time of rendering. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/549/5ab/d02/5495abd0268d0d59077d00ade282989a.jpg"><br><br>  This works because the intersection of the main content and viewport is considered the intersection that the user sees.  This API was designed to know exactly when a user saw an advertisement, but our research showed that this also works on non-ad units. <br><br>  Of these two methods, it is still better to use RequestAnimationFrame: its support is wider, and it is better tested by us in practice. <br><br><h2>  JS Inited </h2><br>  Imagine a framework that has a certain ‚Äúinit‚Äù event to which you can subscribe, but remember that in practice JS Inited is both a simple and complex metric. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3bf/6fe/85c/3bf6fe85c743f0ad6c255d8e4c448eae.jpg"><br><br>  Simple - because you just need to find the moment when the framework has finished work on the arrangement of events.  Difficult - because this point has to be looked for independently for each framework. <br><br><h2>  Time to Interactive </h2><br>  TTI is often confused with the previous metric, but in fact it is an indicator of the moment when the main browser thread is released.  During page loading, many tasks are performed: from drawing various elements to initializing the framework.  Only when it is unloaded does the time come before the first interactivity. <br><br>  The concept of long (long) tasks and the Long Task API helps to measure this. <br><br>  First about the long tasks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f79/67b/828/f7967b8283a7302b1d8d9b1bd076cfac.jpg"><br><br>  Between short tasks indicated by arrows, the browser can easily squeeze in the processing of a user event, for example, input, because it has a high priority.  But with the long tasks indicated by the red arrows, this will not work. <br><br>  The user will have to wait until they run out, and only after the browser has put the processing of its input for execution.  In this case, the framework can already be initialized, and the buttons will work, but slowly.  Such a deferred response is a rather unpleasant user experience.  The moment when the last Long Task is completed and the stream is empty for a long time, the illustration begins at 7 seconds and 300 milliseconds. <br><br>  How to measure this interval inside javascript? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66f/f1b/114/66ff1b114d718aa4e31cf8c2f1094525.jpg"><br><br>  The first step is conditionally designated as the opening body tag, followed by the script.  This is where PerformanceObserver is created, which is subscribed to the Long Task event.  Inside the callback PerformanceObserver, event information is collected into an array. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e3/1c4/c60/3e31c4c60298c19431ca84a93c908394.jpg"><br><br>  After collecting the data, it is time for the second step.  It is conventionally designated as a closing body tag.  We take the last element of the array, the last long task, look at the end of its execution and check whether enough time has passed. <br><br>  In the original work on this metric in the role of a constant taken 5 seconds, but the choice is not justified.  It was enough for us 3 seconds.  If it takes 3 seconds, we count the time before the first interactivity, if not, setTimeout and check for this constant again. <br><br><h2>  How to process the data? </h2><br>  Data must be obtained from customers, processed and presented in a convenient form.  Our concept of sending data is quite simple.  It is called a counter. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38f/158/cba/38f158cbaf1233223fdca1ba255f9e25.jpg"><br><br>  We transfer the data of a certain metric to a special handle on the back end and collect it in the storage. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/884/cda/04a/884cda04a3b619b084dfde376a0645cc.jpg"><br><br>  Here, data aggregation is conditionally designated as a SQL query.  Here are the main aggregations, which we usually count by speed metrics: arithmetic average and group of percentiles (50th, 75th, 95th, 99th). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/354/84a/d7c/35484ad7c51d967118abb42646a09801.jpg"><br><br>  The arithmetic average of our number range is almost 1900. It is noticeably larger than most of the elements of the set, because this aggregation is very sensitive to outliers.  This property is still useful to us. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6b/2ac/b00/d6b2acb00b844c6294fa80a50e03495c.jpg"><br><br>  To calculate percentiles for the same set, sort it and put a pointer to a percentile index.  Suppose the 50th, which is also called the median.  We fall between the elements.  In this case, you can get out of the situation in different ways, we will calculate the average between them.  We get 150. When comparing with the arithmetic average, it is clearly seen that the percentiles are insensitive to emissions. <br><br>  We consider and use these features of aggregations.  The sensitivity of the arithmetic mean to emissions is a disadvantage if you try to evaluate user experience with it.  After all, there can always be a user connecting to the network, for example, from a train, and spoil the sample. <br><br>  But the same sensitivity is an advantage when it comes to monitoring.  In order not to miss an important problem, we use the arithmetic mean.  It is easily shifted, but the risk of false positives in this case is not such a big problem.  It is better to look than to overlook. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dcb/e92/a6b/dcbe92a6baf2a4ec1e2ef01580dd948d.jpg"><br><br>  In addition, we consider the median (if we tie it to the time metrics, the median is an indicator of the time at which 50% of the requests fit) and the 75th percentile.  75% of requests fit into this time, we take it as an estimate of the overall speed.  The 95th and 99th percentiles are considered to evaluate the long, slow tail.  These are very large numbers.  95th is considered the slowest query.  The 99th percentile has anomalous indicators. <br><br>  It makes no sense to count the maximum.  This is the road to madness.  After calculating the maximum, it can happen that the user waited for the page to load, 20 years. <br><br>  Considering the aggregation, it remains only to apply these numbers, and the most obvious thing you can do with them is to represent them in the form of graphs. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8d/552/3e9/e8d5523e9eeebf2545a7f214b75b8ede.jpg"><br><br>  On the graph, our real metrics are time to first contentfull paint to search.  The blue line reflects the dynamics for desktops, the red line for mobile devices. <br><br>  The speed graphs have to be constantly monitored, and we assigned this task to the robot. <br><br><h2>  Monitoring </h2><br>  Because velocity metrics are volatile and constantly fluctuate with different periods, monitoring needs to be fine tuned.  For this we use the concept of discord. <br><br>  Disorder - the moment when a random process changes its characteristics, such as variance or expectation.  In our case, this is the average sample.  As mentioned, the average is sensitive to emissions and is well suited for monitoring. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/621/9a7/c0b/6219a7c0bc99aef5991cda07179a487a.jpg"><br><br>  Here is an example of the graph where the discord occurred and the robot recorded the incident.  How did he distinguish this moment from a number of other fluctuations?  To understand this, we impose additional data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93e/d21/ec4/93ed21ec4f2a624e3d703dc90b2c2530.jpg"><br><br>  The yellow graph is a metric indicator, and blue is a moving average with a fairly large period.  Red - average plus three standard deviations.  Green is the same, only with a minus sign. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c8/899/b90/4c8899b90f7e2696100aa4c7069a868c.jpg"><br><br>  Red and green indicators form a safe corridor.  As long as the metric and the moving average fluctuate between them - everything is normal, these are ordinary fluctuations.  But once they leave the safe zone, monitoring is triggered. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fb/d41/25e/9fbd4125ece689bd90a84e520304fd3a.jpg"><br><br><h2>  Check for speed features </h2><br>  All that was discussed was the work with the speed data of an already running project, but I want to measure the speed of individual features before sending them to a big production.  To do this, we use A / B testing - comparing metrics for the control and experimental groups. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/819/128/e94/819128e94c08fec52e22da5914d28cbe.jpg"><br><br>  We divide users into control and experimental groups.  The readings of each slot are collected separately, aggregated and tabulated. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31d/89b/1eb/31d89b1eb1915e2a0f8f29bc986f0521.jpg"><br><br>  In A / B testing, as a rule, the arithmetic mean is also used.  Here we see the delta and, to accurately determine whether it is a coincidence or a significant result, a statistical test is applied. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e78/37d/134/e7837d1340c59e00cf61a132c6ac72c9.jpg"><br><br>  It is designated as ‚ÄúMW‚Äù because the Mann-Whitney test is used in the calculation.  With its help, the so-called "percentage of correctness" is calculated.  This indicator has a threshold after which we take the delta as correct.  Here it is set at 99.9%. <br><br>  When the test reaches this value, the delta is marked in the interface with a color.  We call it prokraskoy.  Here we see a green, that is, a good color for time to first contentfull paint.  Time to first meaningful paint does not reach this value, that is, the delta is also good, but not 99.9%.  Trust her completely impossible.  Upon initialization of the framework and time to interactive, there is confidently a bad red coloring.  From this you can make the same conclusion as in the case of fonts. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25b/415/b14/25b415b14b30b25549f514aced7b52dd.jpg"><br><br><h2>  How to make at home? </h2><br>  You can implement speed measurements in yourself in two ways.  The first is to make all your own. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e30/344/cb5/e30344cb56179ed9a633ff26c187291e.jpg"><br><br>  A handle for receiving data from clients, a backend that puts it all into a database, MongoDB, PostgreSQL, MySQL, any DBMS (they have aggregations out of the box), plus one of many open source solutions - to draw graphs and arrange monitoring. <br><br>  The second solution is to use the Yandex Metrika or Google Analytics analytics systems.  On the example of "Yandex Metrics" it looks like this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/424/a97/f61/424a97f61a797dff9419d7df8828046b.jpg"><br><br>  Here are the metrics that the metric provides to the user out of the box.  Of course, this is not all mentioned, but something.  The rest can be added manually through user parameters.  Also available A / B testing and monitoring. <br><br><h2>  Conclusion </h2><br>  The concept of online speed measurement, which we described, is known as RUM - Real User Monitoring.  We love her so much that we even drew a logo with a cool rock and roll umlaut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5f/8a9/448/e5f8a94489f01743c09e5ec04453cc56.jpg"><br><br>  This approach is good because it is based on numbers from the real world, those indicators that your service audience has.  With the help of metrics, you supposedly receive feedback from each user.  So start optimizing and do not stop. <br><blockquote>  Announcement finally.  If you liked this report with <b>HolyJS 2018 Piter</b> , you will probably be interested in the upcoming <b><a href="https://holyjs-moscow.ru/">HolyJS 2018 Moscow</a></b> , which will be <b>held November 24-25</b> .  There you can not only see <a href="https://holyjs-moscow.ru/">many other</a> JS reports, but also ask after any speaker in the discussion area.  And tomorrow, from November 1, ticket prices will rise to the final, so today is the last opportunity to buy them at a discount! </blockquote></div><p>Source: <a href="https://habr.com/ru/post/426571/">https://habr.com/ru/post/426571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426559/index.html">Neural networks for image processing. Tells Alexander Savsunenko from Skylum Software</a></li>
<li><a href="../426561/index.html">The Magnificent Five: must have tools to speed development</a></li>
<li><a href="../426563/index.html">Hierarchical address book, change of primary e-mail and other innovations in Zimbra 8.8.10</a></li>
<li><a href="../426565/index.html">‚ÄúThe Java world will never be the same again‚Äù - an interview with Alexander Belokrylov and Alexey Voitylov from BellSoft</a></li>
<li><a href="../426567/index.html">The book "Mathematical chaos. From elementary mathematics to sublime abstractions "</a></li>
<li><a href="../426573/index.html">ZeroNights 2018. Reload</a></li>
<li><a href="../426575/index.html">Report of the Club of Rome 2018, Chapter 1.12: ‚ÄúFrom the empty world to the complete world‚Äù</a></li>
<li><a href="../426579/index.html">Engie and Ledger have developed a hardware blockchain solution for storing data generated by green energy sources.</a></li>
<li><a href="../426581/index.html">Open lesson "Node.js features overview"</a></li>
<li><a href="../426583/index.html">Ten people at 90 thousand sites: how not to go crazy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>