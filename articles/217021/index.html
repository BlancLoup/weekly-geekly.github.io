<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Viz - New 3D visualization module in the OpenCV library</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon, today's blog post I want to devote to the review of the new module for 3D visualization Viz in the OpenCV library , in the design and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Viz - New 3D visualization module in the OpenCV library</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/fb6/1be/c86/fb61bec8614a289f08d1adcaf373710c.png"><br><br>  Good afternoon, today's blog post I want to devote to the review of the new module for 3D visualization <a href="http://docs.opencv.org/trunk/doc/tutorials/viz/table_of_content_viz/table_of_content_viz.html">Viz</a> in the <a href="http://opencv.org/">OpenCV library</a> , in the design and implementation of which I participated.  Perhaps I should introduce myself here, my name is <a href="http://www.linkedin.com/in/anatolybaksheev">Anatoly Baksheev</a> , I have been working for <a href="http://itseez.com/">Itseez</a> , I have been using the OpenCV library for 7 years now, and I am developing and developing it together with my colleagues. <br><br>  What relation does 3D visualization have to computer vision, you ask, and why do we even need such a module?  And you will be right, if you look at computer vision as an area that works with images.  But we live in the <a href="http://ru.wikipedia.org/wiki/XXI">21st</a> century, and the field of application of computer vision has gone far beyond just image processing, highlighting object boundaries or face recognition.  Science and technology have already learned in a more or less acceptable quality to measure our three-dimensional world.  This was facilitated by the appearance of cheap <a href="http://www.xbox.com/en-US/KINECT">Kinect-</a> type sensors on the market a few years ago, which at that time allowed, with good accuracy and speed, the representation of a scene as a three-dimensional colored point cloud, and progress in the field of 3D reconstruction of the data from a series of images, and even mobile technologies, where an integrated gyroscope and accelerometer greatly simplifies the task of evaluating the movement of a mobile device camera in the 3D world, and hence the accuracy of scene reconstruction. <br><a name="habracut"></a><br>  All this prompted the development of various methods and algorithms that work with 3D data.  3D segmentation, 3D noise filtering, 3D recognition of objects by shape, 3D face recognition, 3D body posture tracking, or hand gestures recognition.  You probably know that when Kinect for XBox went on sale, Microsoft provided the developers of the SDK game to determine the position of the human body, which led to the emergence of a large number of games with an interesting interface - when, for example, the game character repeats the movements of the player facing Kinect .  The results of such 3D algorithms must somehow be visualized.  These are three-dimensional trajectories, reconstructed geometry, or, for example, the calculated position of a human hand in 3D.  Also, such algorithms must be debugged, often visualizing intermediate data in the process of convergence of the developed algorithm. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/84a/605/5c1/84a6055c13a99d6b7fa281e6285f8c0a.png"><br>  <b>Various ways to display camera paths in OpenCV Viz</b> <br><br>  Thus, once the vector of developments shifts in the 3D area, in <a href="http://opencv.org/">OpenCV there</a> will be more and more algorithms that work with 3D data.  And once there is such a trend, we hasten to create a convenient infrastructure for this.  The <a href="http://docs.opencv.org/trunk/doc/tutorials/viz/table_of_content_viz/table_of_content_viz.html">Viz</a> module is the first step in this direction.  OpenCV has always been a library containing a very convenient base, on the basis of which algorithms and computer vision applications were developed.  Convenient both because of the functionality, since it includes almost all the most frequently used operations for manipulating images and data, and because of the carefully developed and tested API for years (containers, basic types and operations with them), allowing for very compact implementation computer vision techniques, saving developer time.  We hope that Viz meets all these requirements. <br><br>  For the impatient, here is a video demonstrating the capabilities of the module. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/75Ytgy3QT9s%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhg_pUZSF_dKhM50UH3eW2AM6ilhBg" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  Viz philosophy </h4><br>  The idea of ‚Äã‚Äãcreating such a module came to me when I somehow had to debug one algorithm of visual odometry ( <a href="http://en.wikipedia.org/wiki/Simultaneous_localization_and_mapping">vslam</a> ), under conditions of limited time, when I felt in my own skin how such a module would help me and what functionality I would like to see in it .  Yes, and colleagues said that it would be healthy to have such a module.  Everything led to the beginning of its development, and then bringing it to a more or less mature state together with <a href="http://opencv.org/gsoc-2013-video.html">Ozan Tonkal</a> , our <a href="https://developers.google.com/open-source/soc/%3Fcsw%3D1">Google Summer Of Code</a> student.  Work on improving Viz'a and is now. <br><br>  The design idea is that it would be nice to have a system of three-dimensional widgets, each of which could be drawn in a 3D visualizer, simply by passing the position and orientation of this widget.  For example, a point cloud coming from Kinect is often stored in a coordinate system related to the camera position, and for visualization it is often necessary to convert all point clouds taken from different camera positions into some kind of global coordinate system.  And it would be convenient not to recalculate the data every time in the global system, but simply to set the position of this point cloud.  Thus, in OpenCV Viz, each supported widget object is formed in its own coordinate system, and then it is shifted and oriented in the process of drawing. <br><br>  But no good idea comes to mind only for one person.  As it turned out, the <a href="http://www.vtk.org/">VTK</a> library for manipulating and visualizing scientific data also implements the same approach.  Therefore, the task has been reduced to writing a competent wrapper over a <a href="http://www.vtk.org/">VTK</a> subset, with the interface and data structures in the style of OpenCV and writing some set of basic widgets with the possibility of expanding this set in the future.  In addition to the above, VTK satisfies the cross-platform requirement, so the decision to use it was chosen almost immediately.  I think a slight inconvenience due to the dependence on VTK is more than offset by convenience and extensibility in the future. <br><br><h4>  Representation of the position of objects in Viz </h4><br>  Position in the Euclidean space is given by rotation and translation.  The rotation can be represented as a rotation matrix, as a rotation vector ( <a href="http://en.wikipedia.org/wiki/Rodrigues%2527_rotation_formula">Rodrigues' vector</a> ) or a <a href="http://en.wikipedia.org/wiki/Quaternion">quaternion</a> .  Translation is simply a three-dimensional vector.  Rotation and translation can be stored in separate variables or stitched into an extended 4x4 affine transformation matrix.  Actually, this method is proposed for ease of use.  But ... ‚ÄúI, too, convenient!‚Äù, You will say, ‚Äúform such a matrix every time you draw any object!‚Äù And I agree with you, but only if you don‚Äôt provide a convenient means for creating and manipulating poses in this format.  This tool is a specially written class cv :: Affine3d, which by the way, apart from how to visualize, I recommend using it when developing odometry algorithms.  Yes, yes, lovers of quaternions can already throw stones at me.  I will say in justification that in the future they plan to support them. <br><br>  So let's define.  The pose of each object in Viz is the transformation from the Euclidean coordinate system associated with the object to a global Euclidean coordinate system.  In practice, there are various agreements that such a transformation and that where it is converted.  In our case we mean the point transfer from the coordinate system of the object to the global one.  Those: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98b/aaa/706/98baaa706579838bf4c65951cbf6a329.png" alt="image"></div><br><br>  where P <sup>G</sup> , P <sup>O</sup> are the coordinates of a point in the global coordinate system and in the coordinate system of the object, M is the transformation matrix or the pose of the object.  Let's look at how you can shape the position of the object. <br><br><pre><code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/        cv::Vec3d x_axis, y_axis, z_axis, origin; cv::Affine3d pose = cv::makeTransformToGlobal(x_axis, y_axis, z_axis, origin); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       cv::Vec3d position, view_direction, y_direction; Affine3d pose = makeCameraPose(position, view_direction, y_direction); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,       Affine3d pose1; Affine3d pose2 = Affine3d::Identity(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      cv::Matx33d R; cv::Vec3d t; Affine3d pose = Affine3d(R, t); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/             double rotation[9]; double translation[3]; Affine3d pose = Affine3d(cv::Matx33d(rotation), cv::Vec3d(translation));</span></span></code> </pre> <br>  Or maybe you have already developed visual odometry algorithms, and your program already has these transformation matrices that are stored inside cv :: Mat?  Then the pose in the new format can be easily obtained: <br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   4x4  43 cv::Mat pose_in_old_format; Affine3d pose = Affine3d(pose_in_old_format); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   33    cv::Mat R, t; Affine3d pose = Affine3d(R, translation); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      cv::Vec3d rotation_vector: Affine3d pose = Affine3d(rotation_vector, translation);</span></span></code> </pre><br>  In addition to construction, this class also allows you to manipulate the postures and apply them to three-dimensional vectors and points.  Examples: <br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   90   Oy    5  Ox. Affine3d pose = Affine3d().rotate(Vec3d(0, CV_PI/</span></span><span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>,)).translate(Vec3d(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   cv::Vec3d a_vector; cv::Point3d a_point; cv::Vec3d transformed_vector = pose * a_vector; cv::Vec3d transformed_point = pose * a_point; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Affine3d camera1_to_global, camera2_to_global; Affine3d camera1_to_camera2 = camera2_to_global.inv() * camera1_to_global</code> </pre><br>  It is necessary to read this as follows: if we multiply to the right for a point in the coordinate system of camera 1, then after the first (right) transformation we will get a point in the global system, and then we will translate it into the coordinate system of camera 2 by an inverted transformation from the global system.  we get the pose of camera 1 relative to the coordinate system of camera 2. <br><pre> <code class="hljs pgsql">//        <span class="hljs-type"><span class="hljs-type">double</span></span> distance = cv::norm((cam2_to_global.inv() * cam1_to_global).translation()); <span class="hljs-type"><span class="hljs-type">double</span></span> rotation_angle = cv::norm((cam2_to_global.inv() * cam1_to_global).rvec());</code> </pre><br>  On this, probably, we must complete our excursion into the possibilities of this class.  Who likes, I suggest using it in your algorithms, because  The code with it is compact and easy to read.  And the fact that instances of cv :: Affine3d are allocated on the stack, and all methods are inline methods, opens up possibilities for optimizing the performance of your application. <br><br><h4>  Visualization with Viz </h4><br>  The main class responsible for visualization is called cv :: viz :: Viz3d.  This class is responsible for creating the window, initializing it, displaying widgets, and managing and processing input from the user.  You can use it as follows: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">Viz3d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viz1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">‚Äúmywindow‚Äù</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     mywindow ...   ... viz1.spin(); // ;  ,     </span></span></code> </pre><br>  Like almost all the high-level functionality in OpenCV, this class is essentially a smart pointer with reference counting to its internal implementation, so it can be freely copied, or received by name from the internal database. <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Viz3d</span></span> viz2 = viz1; <span class="hljs-attribute"><span class="hljs-attribute">Viz3d</span></span> viz3 = cv::viz::getWindowByName(‚Äúmywindow‚Äù): Viz3d viz4(‚Äúmywindow‚Äù);</code> </pre><br>  If a window with the requested name already exists, the resulting Viz3d instance will point to it, otherwise a new window with that name will be created and registered.  This is done to simplify the debugging of algorithms - now you don‚Äôt need to transfer a window deep into the call stack every time something needs to be displayed somewhere.  It is enough to start a window at the beginning of the main () function, and then access it by name from anywhere in the code.  This idea is inherited from the function cv :: imshow (window_name, image), which has proven itself in OpenCV, which also allows you to display a picture in a named window anywhere in the code. <br><br><h5>  Widget system </h5><br>  As mentioned earlier, a widget system is used to draw various data.  Each widget has several constructors and sometimes methods to manage its internal data.  Each widget is formed in its own coordinate system.  For example: <br><br><pre> <code class="hljs pgsql">//     WLine line(Point3d(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), Point3d(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>), Color::apricot()); //          WCube <span class="hljs-keyword"><span class="hljs-keyword">cube</span></span>(Point3d(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0</span></span>), Point3d(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, Color::pink());</code> </pre><br><br>  As you can see, we can specify an arbitrary line, but for a cube it is possible to set only a position, but not an orientation relative to the axes of coordinates.  However, this is not a restriction, but rather even a feature that teaches thinking in the style of Viz.  As we already discussed earlier, when rendering, you can set any widget's pose in the global coordinate system.  Thus, we simply create a widget in its coordinate system with a simple constructor, for example, we set the dimensions of the cube in this way.  And then we position and orient it in the global when rendering. <br><br><pre> <code class="hljs pgsql">//      (<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)  <span class="hljs-number"><span class="hljs-number">3</span></span>  Vec3d rvec = Vec3d(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * (<span class="hljs-number"><span class="hljs-number">3.0</span></span>/cv::norm(Vec3d(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); Viz3d viz(‚Äútest1‚Äù); viz.showWidget(‚Äúcoo‚Äù, WCoordinateSystem()); viz.showWidget(‚Äú<span class="hljs-keyword"><span class="hljs-keyword">cube</span></span>‚Äù, <span class="hljs-keyword"><span class="hljs-keyword">cube</span></span>, Affine3d(rvec, Vec3d::<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>))); viz.spin();</code> </pre><br>  And here is the result: <br><img src="https://habrastorage.org/getpro/habr/post_images/f47/dbe/e0c/f47dbee0c9234253d04a4c3c6703e176.png"><br><br>  As we can see, drawing takes place through a call to the Viz3d :: showWidget () method with passing it the string name of the object, an instance of the created widget, and its position in the global coordinate system.  A string name is necessary in order to be able to add, delete and update widgets in the 3D scene by name.  If a widget with the same name is already present, it is deleted and replaced with a new one. <br><br>  In addition to the cube and line, Viz implements a sphere, cylinder, plane, 2D circle, pictures and text in 3D and 2D, various types of trajectories, camera positions, and, of course, point clouds and a widget for working with a mesh (colorwise, painted or textured).  This set of widgets is not final, and will be expanded.  Moreover, it is possible to create custom views, but about this some other time.  If you are interested in this opportunity, read <a href="http://docs.opencv.org/trunk/doc/tutorials/viz/creating_widgets/creating_widgets.html">this</a> tutorial.  And now let's consider another example of how to draw point clouds: <br><pre> <code class="hljs pgsql">//     .     CV_32FC3 cv::Mat cloud = cv::viz::readCloud(‚Äúdragon.ply‚Äù); //           cv::Mat colors(cloud.size(), CV_8UC3); theRNG().fill(colors, RNG::UNIFORM, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>); //         <span class="hljs-keyword"><span class="hljs-keyword">NAN</span></span> -     <span class="hljs-type"><span class="hljs-type">float</span></span> qnan = std::numeric_limits&lt;<span class="hljs-type"><span class="hljs-type">float</span></span>&gt;::quiet_NaN(); cv::Mat masked_cloud = cloud.clone(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cloud.total(); ++i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( i % <span class="hljs-number"><span class="hljs-number">16</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>) masked_cloud.at&lt;Vec3f&gt;(i) = Vec3f(qnan, qnan, qnan); Viz3d viz(‚Äúdragons‚Äù); viz.showWidget(‚Äúcoo‚Äù, WCoordinateSystem()); //   viz.showWidget(‚Äúred‚Äù, WCloud(cloud, Color::red()), Affine3d().translate(Vec3d(<span class="hljs-number"><span class="hljs-number">-1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>))); //     viz.showWidget(‚Äúcolored‚Äù, WCloud(cloud, colors), Affine3d().translate(Vec3d(+<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>))); //           viz.showWidget(‚Äúmasked‚Äù, WCloud(masked_cloud, colors), Affine3d::<span class="hljs-keyword"><span class="hljs-keyword">Identity</span></span>()); // A ,       viz.showWidget(‚Äúpainted‚Äù, WPaintedCloud(cloud), Affine3d().translate(Vec3d(+<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>))); viz.spin();</code> </pre><br>  The result of this code is: <br><img src="https://habrastorage.org/getpro/habr/post_images/623/740/772/6237407722085bb4b10e4755e8835577.png"><br>  For more information about the available widgets, read our <a href="http://docs.opencv.org/trunk/modules/viz/doc/viz.html">documentation</a> . <br><br><h5>  Dynamically changing scene </h5><br>  It is often not enough to simply display objects so that the user can view them, but rather need to provide some dynamics.  Objects can move, change their attributes.  If we have a video stream with Kinect, then you can play the so-called point cloud vide.  To do this, you can do the following: <br><pre> <code class="hljs ruby">cv::VideoCapture capture(CV_CAP_OPENNI) Viz3d viz(‚Äúdynamic‚Äù); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>...  ... /<span class="hljs-regexp"><span class="hljs-regexp">/      viz.setViewerPose(Affine3d().translate(1.0, 0.0, 0.0)); while(!viz.wasStopped()) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/...  ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,      Kinect /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,    capture.grab(); capture.retrieve(color, CV_CAP_OPENNI_BGR_IMAGE); capture.retrieve(depth, CV_CAP_OPENNI_DEPTH_MAP); Mat cloud = computeCloud(depth); Mat display = normalizeDepth(depth); viz.showWidget("cloud", WCloud(cloud, color)); viz.showWidget("image", WImageOverlay(display, Rect(0, 0, 240, 160))); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        30  viz.spinOnce(30 /</span></span>*ms*<span class="hljs-regexp"><span class="hljs-regexp">/, true /</span></span>*force_redraw*<span class="hljs-regexp"><span class="hljs-regexp">/)); }</span></span></code> </pre><br>  This loop will run until the user closes the window.  At the same time, at each iteration of the cycle, the widget with the old cloud will be replaced with a new one with a new cloud. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Gqdmgb2hl90%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700253&amp;usg=ALkJrhiJ4BgtQU7nWWUuvciNPRNWdYqG6Q" frameborder="0" allowfullscreen=""></iframe><br><br><h5>  Management interface </h5><br>  At the moment, the camera control is done in the so-called trackball camera style, convenient for viewing various 3D objects.  Imagine that in front of the camera there is a certain point in 3D, around which this camera rotates with the mouse.  The scroller on the mouse brings / removes to and from this point.  Using the shift / ctrl buttons and mouse, you can move this point of rotation in the 3D world.  In the future, it is planned to implement a free-fly mode for navigating large spaces.  I also recommend pressing the hotkey 'H' while Viz is running, to read the information printed on the console about other hotkeys and features, from saving screenshots to turning on anaglyph stereo. <br><br><h4>  How to build an OpenCV Viz module </h4><br>  And finally, for those who, after reading this text, had a burning desire to start using this module, this section is intended.  Viz can be used on all three dominant PC platforms - Windows, Linux, and Mac.  You will need to install VTK and compile OpenCV with VTK support.  OpenCV itself with the Viz module can only be downloaded from our repository on GitHub <a href="https://github.com/Itseez/opencv">https://github.com/Itseez/opencv</a> in the 2.4 and master branches.  So, the instruction: <br><br><h5>  1. Installing VTK </h5><br>  Under Linux, the easiest solution is to install VTK from the apt repository via the apt-get install command libvtk5-dev.  Under Windows, you need to download VTK from the developer‚Äôs site, the best is version 5.10, generate a CMake project for Visual Studio and compile it in the Release and Debug configurations.  I recommend unchecking CMake BUILD_SHARED_LIBS, which will lead to compilation of VTK static libraries.  In this case, after compilation, the size of the OpenCV Viz module without any dependencies will be only about 10 MB. <br><br>  Under Mac, for OSX 10.8 and earlier, any version of VTK will work; under 10.9, Mavericks will be able to compile VTK 6.2 from the official <a href="">github.com/Kitware/VTK.git</a> repository.  There were no 6.2 releases at the time of writing this blogpost.  Under Mac, it is also recommended to generate a project under Xcode using CMake and build static libraries in the Release and Debug configurations. <br><br><h5>  2. Compiling OpenCV with VTK </h5><br>  This step is easier and faster.  I give commands for Linux, under Windows everything is not much different <br><ol><li>  git clone <a href="">github.com/Itseez/opencv.git</a> </li><li>  [optional] git checkout -b 2.4 origin / 2.4 </li><li>  mkdir build &amp;&amp; cd build </li><li>  cmake -DWITH_VTK = ON -DVTK_DIR = &lt;path to VTK build directory&gt; ../opencv </li></ol><br><br>  If you put VTK through apt-get install, then you do not need to specify the path to it - it will be found by CMake automatically.  Next, you need to make sure in the CMake console log that he found and connected VTK.  And did not report any incompatibilities.  For example, if you compile OpenCV with Qt5 support, and VTK is compiled with Qt4, linking with VTK will cause the application to crash at the initialization stage before entering the main () function.  The solution is to choose one thing.  Or compile VTK without Qt4 by unchecking the corresponding checkbox in CMake for VTK.  Either take VTK 6.1 or higher and build it with Qt5 support.  Finally, to build OpenCV, run make -j 6 <br><br><h5>  3. Launch of texts (optional) </h5><br>  I also recommend downloading this repository: <a href="">github.com/Itseez/opencv_extra.git</a> , set the path to opencv_extra / testdata in the environment variable OPENCV_TEST_DATA_PATH.  And run the opencv_test_viz file from the build directory of the OpenCV.  On this application, you can familiarize yourself with all the current features of this module, and its source can be used to learn the API. <br><br><h4>  Conclusion </h4><br>  Well, so I got to the conclusion.  I hope it was interesting.  With this post, I wanted to show what the main trend, from my point of view, is now observed in computer vision, and that the OpenCV library is moving with the times.  And that in OpenCV there will appear algorithms for working with the 3D world.  Because we ourselves will develop them either with the help of Google Summer of Code students, or grateful users using our base, will participate in the creation and development of similar algorithms in OpenCV. <br><br>  I also wanted to interest you with this developed tool, or maybe even this area for research.  By the way, if you have a desire to conduct a similar development for OpenCV - You are welcome!  We accept pull requests via GitHub.  Instructions posted <a href="http://code.opencv.org/projects/opencv/wiki/How_to_contribute">here</a> .  We will be glad to see a new well-working approach :-) <br><br>  And although the main base is now created, I think in the future new features will be added to Viz.  For example, a model of the skeleton of the human hand and its visualization.  Or 3D world maps from algorithms like PTAM.  Or maybe a network client so that it is possible to send data for visualization from a mobile device when debugging algorithms on it :) But these are insane ideas so far :-).  If interested, in the next blog post I could talk about some algorithm, for example, ICP or Kinect Fusion, and how Viz was used to debug and visualize it. <br><br>  And for those who read to the end - a bonus.  <a href="https://github.com/Nerei/kinfu_remake">Here</a> is my optimized and lightweight remake of my own Kinect Fusion implementation in the PCL library. </div><p>Source: <a href="https://habr.com/ru/post/217021/">https://habr.com/ru/post/217021/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../217011/index.html">Unpleasant Eclipse Surprise</a></li>
<li><a href="../217013/index.html">Game Conferences</a></li>
<li><a href="../217015/index.html">Samsung Electronics History: From Dried Fish to High Tech</a></li>
<li><a href="../217017/index.html">Install Metasploit Framework Dev on Windows</a></li>
<li><a href="../217019/index.html">Pioneers: anti-social behavior detector based on video analytics</a></li>
<li><a href="../217023/index.html">Optical fiber as the basis of a real-time blood test system</a></li>
<li><a href="../217025/index.html">SMM: How hotel-casino "Aria" increased the number of reposts by 310%, telling stories</a></li>
<li><a href="../217027/index.html">Oracle Database Appliance - Review After Usage Experience</a></li>
<li><a href="../217029/index.html">How local ‚Äúsmart phone‚Äù brands rush into the middle class and inflate prices</a></li>
<li><a href="../217031/index.html">Programming the Tree of Times</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>