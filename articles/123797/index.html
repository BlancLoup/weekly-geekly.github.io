<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IIS + .NET + Json. We write the Application Server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I tried to talk about my vision of what an application server is, interacting with various clients, and how to implement it in .NET. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>IIS + .NET + Json. We write the Application Server</h1><div class="post__text post__text-html js-mediator-article">  In this article, I tried to talk about my vision of what an application server is, interacting with various clients, and how to implement it in .NET.  In order to avoid overloading the article, I tried not to go into the details of the implementation, but I think you will be interested in the basic ideas. <br><br>  And so, what is an "Application Server"? <br><a name="habracut"></a><br>  I will try to formulate in my own words. <br>  - ‚ÄúApplication Server‚Äù is one of the terms related to the architecture of distributed N-tier systems, where it occupies a central place and is located between clients making requests to process and receive data and store this data. <br>  ‚ÄúAn application server is software based on a specific architecture and technology that runs on the server side.  Specificity consists in serving a multitude of clients both in their number and in the diversity of their types. <br>  - The application server performs the necessary processing and transformation of data in certain formats, both received from clients and sent to them. <br>  - The application server provides an application-level API, whose methods can be used to implement a particular client application. <br><br>  The background of this project was as follows. <br>  Developing somehow another application based on the new-fashioned Microsoft Windows Communication Faundation (hereinafter referred to as WCF), besides a thick .NET client under Windows, there was a desire to make a web interface to this service.  ExtJs was chosen for mastering.  Having loaded some of the material on the topic ‚Äúhow to connect an Ajax client to a WCF service,‚Äù the first sketches were made.  The model has earned, but already then some complaints began to arise in ways to achieve seemingly elementary things.  At first glance, there were too many ‚Äúunnecessary‚Äù things to do for this, which in practice were simply necessary. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A little more history. <br>  There was experience and several successfully implemented projects at WCF.  In one smart book from O'Reilly there was a recommendation not to do many methods in the service interface (not more than a dozen + -).  Proceeding from this and from the real need to have a lot of different methods for the service, an evolutionary decision was made to make one main executable method plus several additional ones as needed.  Because  at that time, it was only the .NET client of the service that was used, this main method accepted the name of the method being called and the parameters serialized by BinaryFormatter, plus another AssemblyQualifiedName in case the methods were in external assemblies. <br>  But this solution was completely incompatible with Web-clients and had to go back to the ‚Äúflat‚Äù methods implemented in the service interface. <br>  There were problems when working with threads, despite the support for MTOM.  I did not manage to force WCF to pass threads through a proxy server normally. <br>  Another nuisance in WCF + Ajax is Json serialization.  Well, it seemed so much easier, so no, and a lot of its own nuances were formed here. <br>  In addition, the practice all the time showed that customers who have implemented solutions based on WCF, very often have problems installing .NET 3.5 SP1 on the server.  That the framework itself is not installed, the .svc is not registered, which is most often, then something else. <br>  Little by little, WCF ceased to please. <br><br>  And in my head, meanwhile, the thought did not give rest, how do the services of well-known social networks, web projects, various App Store work on the Internet.  After all, not pkhp one.  It is clear that this is not "Windows", but that's not the point.  The bottom line is that these services provide data to different types of clients.  One service - a lot of different customers, it's ‚Äúcool‚Äù and ‚Äúarch-important‚Äù nowadays, but how to do this on .NET? <br><br>  It was decided to try using .asmx WebServices from .NET 2.0, moreover, extensions appeared in .NET 3.5 that allow them to interact with the Ajax world.  I will say right away that something happened, something didn‚Äôt, but still there was a feeling that all these extensions for XML web services to them were ‚Äúpulled by their ears‚Äù and they are not their own. <br><br>  I do not want to say that WCF and WebService technologies are not at all suitable for the implementation of Web 2.0, but I repeat - what seemed to be done intuitively, sometimes caused such ‚Äúmisunderstandings‚Äù that I wanted to quit.  Somehow it was difficult to implement simple things, and some things could not be done at all. <br>  One could cite here a list of unpleasant moments that arose during the development process, but to be honest - now I don‚Äôt even want to remember, after everything has become elegant and simple. <br><br>  So there must be something in .NET suitable for achieving goals?  Our salvation is System.Net and System.Web. <br>  And so, choose IHttpHandler. <br><br>  Take a look at HttpContext with its HttpRequest and HttpResponse.  They are almost completely implemented low-level details of the Http protocol from Webengine and laid out to us on a platter.  We can only draw a ‚Äúblue border‚Äù. <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Enables processing of HTTP Web requests by a custom HttpHandler. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="httpContext"&gt;</span></span></span><span class="hljs-comment"> Http .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> void IHttpHandler.ProcessRequest(HttpContext httpContext)</span></span></code> </pre> <br>  We received a request from some customer. <br>  And then what should we do with it?  The answer is everything your heart desires.  Yes Yes exactly. <br>  Once again, we formulate what we want: <br>  1. One application server - many types of clients (.NET, Java, Web + Ajax, Silverlight, iPhone, Android, etc.); <br>  2. Call the required application server application method from any client; <br>  3. Support ‚ÄúGET‚Äù and ‚ÄúPOST‚Äù requests, i.e.  passing parameters via Url or request body; <br>  4. Support for compressing parameters and executing methods sent back to clients; <br>  5. Work with flows in both directions without any effort; <br>  6. Speed, ease, asynchrony, transparency and clarity of the decision. <br><br>  When implementing the 1st item, I came to the conclusion that there are data types that exist in almost all languages ‚Äã‚Äãand platforms that are compatible with each other and are suitable for transferring them across the border of the medium (I also call it - discovered America).  I emphasize the word "compatible", because  This is a fundamental point: <br>  characters, strings (including encoding), simple data types (various types of numbers, boolean values), arrays of bytes and streams.  A date usually has a specific string representation.  Here it is possible to refer arrays, lists and dictionaries, as containers of the above data types. <br>  The natural choice was Json, as the exchange format.  As an option, the Json.NET library from Newtonsoft was chosen. <br><br>  And so, the client should be able to call a specific application method (RPC) on the server and get an answer that it can understand from the server.  The called method is specified by a string with the name.  The method needs parameters.  He must recognize and process them correctly.  For greater flexibility, the methods may belong not only to the server itself, but also to any assembly that is accessible to the server, albeit with some security restrictions. <br>  REST style is popular, but not quite flexible.  This is a "template" style.  Step left and right, and universality is lost.  Remains an indispensable QueryString. <br><br>  The server receives a request from the client: <br>  /service.ashx?  <b>method</b> = GetImage (‚ÄúDSCN2099.JPG‚Äù) <br><br>  The names of the key parameters are highlighted in bold. <br>  It is clear that the method belongs to the service itself, since  there is no other indication where to look for it; it takes the name of the requested picture as a parameter.  Where the picture is located is known only to you as the developer of the service.  To choose: a directory in the file system;  resource from any assembly;  DB;  runtime drawing;  external resource, etc.  This is applied logic. <br><br>  The full format of the query string: <br><pre> /service.ashx?
 session = xxxxxxxxxxxxxxxxx &amp; - session ID
 class = Full Assembly Type Name &amp; - ‚ÄúFullTypeName, AssemblyName‚Äù
 method = Method Name (Parameters) &amp; - (case-sensitive method name)
 format = Json / DotNetBinary &amp; ‚Äì‚Äì data format (expandable)
 zip = on / off - whether method input parameters are compressed
</pre><br>  If any of the parameters is missing, then its default value is used.  The only thing that must be specified is the name of the method being called. <br><br>  What to return to the client?  Depends on the client application itself.  If the picture is a thumbnail, you can return an array of bytes.  If this is a big picture, then it is better to return the stream. <br><br>  And so, the application server receiving the request, processes it (the parsit), creates the execution context of the specified method and calls the method for execution.  The method implements the applied logic and at the end returns return result;  And where does this result go next?  Not in the air.  And the result is returned from the method back to the core of the application server as a universal object.  Next, the type of the return value is analyzed.  If it is typeof (void), then nothing else is done; if it is Stream, then it is redirected to the output stream of HttpResponse.  Otherwise, the result is given to the Json serializer for conversion to a string, and then this string is written via HttpResponse-&gt; Write (). <br><br>  Thus, having access to the Http context of the request, we were free to choose the implementation of the core infrastructure of the application server. <br><br>  SOAP .asmx WebService infrastructure is implemented in approximately the same way.  Only there is heavy but omnivorous XML, and here Json is easy and fast.  .aspx and WCF are also handlers. <br><br>  So what about our customers, for whom it all started? <br><br>  <b>Everything is simple with .NET.</b> <br>  Here you have the choice of both the native binary format and Json, and HttpWebResponse-&gt; GetResponseStream () is the stream that was returned by our application server's ‚ÄúGetImage ()‚Äù method, the only difference is in the type of this stream, here it will be a network stream - one of the inner classes of the .NET Framework.  Yes, it does not matter to us.  It is important that we can read it and make for example Image.FromStream () or simply save to a file.  If the application server returned an array of binary data (byte []), then this is essentially the same thing, since  There is no other way than GetResponseStream ().  Only we have to convert it back to this very array.  What to do with this thread is decided by the developer of the client application, based on the application API that the application server provides to it. <br><br>  The developer writes an assembly in which there can be both client and server methods, plus general data structures.  Then this assembly is simply put into the server-side project, and the client‚Äôs request indicates the name of this assembly.  Those.  it turns out that you can add additional business logic without recompiling the service itself.  Designed, assembled, put and, voila - the new functionality immediately becomes available. <br><br>  <b>Ajax</b> <br>  The presented ideology of the application server fits very well with the implementation of clients based on Ajax frameworks.  After all, Json is even more familiar to them than XML. <br><pre> <code class="javascript hljs">Ext.Ajax.request({ <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'/service.ashx?method=GetImageInfo(‚ÄúDSCN2099.JPG‚Äù)'</span></span>, <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response, options</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = Ext.decode(response.responseText); }, <span class="hljs-attr"><span class="hljs-attr">failure</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response, options</span></span></span><span class="hljs-function">) </span></span>{ ... } });</code> </pre><br>  Server Method: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ImageInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetImageInfo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Json json</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fileName = json.AsString; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> filePath = Path.Combine(IMAGES_DIR, fileName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImageInfo(filePath); }</code> </pre><br>  The ImageInfo structure returned by the ‚ÄúGetImageInfo ()‚Äù method will be converted by the serializer to Json into something like the following line: <br><pre> {
    "Name": "DSCN2099.JPG",
    "Height": 1536,
    "Width": 2048,
    "PixelFormat": 137224,
    "RawFormat": "Jpeg",
    "HorizontalResolution": 300.0,
    "VerticalResolution": 300.0,
    "ThumbImage": "/ 9j / 4AAQSkZJRgABAQ ...",
    "FileInfo": {
       "FileSize": 1849625,
       "CreationTime": "\ / Date (1246514398257 + 0400) \ /",
       "FileAttributes": 32
    }
 }
</pre><br>  And the application server will send it to the client, where it will be decoded into a javascript object. <br>  The date can be obtained by calling: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.parseDate(result.FileInfo.CreationTime, <span class="hljs-string"><span class="hljs-string">'M$'</span></span>).format(<span class="hljs-string"><span class="hljs-string">'dmY h:i'</span></span>),</code> </pre><br>  miniature: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> image = { <span class="hljs-attr"><span class="hljs-attr">xtype</span></span>: <span class="hljs-string"><span class="hljs-string">'box'</span></span>, <span class="hljs-attr"><span class="hljs-attr">autoEl</span></span>: { <span class="hljs-attr"><span class="hljs-attr">tag</span></span>: <span class="hljs-string"><span class="hljs-string">'div'</span></span>, <span class="hljs-attr"><span class="hljs-attr">children</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">tag</span></span>: <span class="hljs-string"><span class="hljs-string">'img'</span></span>, <span class="hljs-attr"><span class="hljs-attr">src</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.format(<span class="hljs-string"><span class="hljs-string">'data:image/jpg;base64,{0}'</span></span>, result.ThumbImage) }] }, <span class="hljs-attr"><span class="hljs-attr">listeners</span></span>: { <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">comp</span></span></span><span class="hljs-function">) </span></span>{ comp.getEl().on({ <span class="hljs-attr"><span class="hljs-attr">dblclick</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">'/service.ashx?method=GetImage(result.Name)'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.open(url, <span class="hljs-string"><span class="hljs-string">'imageWindow'</span></span>, <span class="hljs-string"><span class="hljs-string">'menubar=no, location=no, resizable=yes, scrollbars=yes, status=no, width=640, height=480'</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">scope</span></span>: comp }); } } };</code> </pre><br>  Our base64 ThumbImage was successfully transformed into a card of the appropriate size, and double-clicking on it will open a new browser window and display a full-fledged image. <br><br>  For example, another such trick.  A string from the style sheet.  The icons are in the resource assembly: <br><pre> <code class="javascript hljs">.loading { background-image: url(<span class="hljs-regexp"><span class="hljs-regexp">/service.ashx?method=LoadIcon%28%22loading.gif%22%29) !important; }</span></span></code> </pre><br>  Well, it seems so far so good.  We already have two clients. <br><br>  <b>Try Silverlight?</b> <br>  Differences from the ‚Äúthick‚Äù .NET client are the complete absence of synchronous methods from HttpWebRequest and HttpWebResponse.  To work with Json, there is an implementation of Json.NET for Silverlight.  The rest is almost the same as for desktop .NET applications. <br>  To simplify interaction with the application server, a special class Request has been developed, which forms the query string and executes it.  It encapsulates the work with HttpWebRequest and HttpWebResponse: <br><pre> <code class="cs hljs">RequestParams requestParams = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestParams(); requestParams.Method.Name = <span class="hljs-string"><span class="hljs-string">"GetImage(fileName)"</span></span>; requestParams.Method.Params.Add(<span class="hljs-string"><span class="hljs-string">"fileName"</span></span>, <span class="hljs-string"><span class="hljs-string">"DSCN2099"</span></span>); Request request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(<span class="hljs-string"><span class="hljs-string">"http://localhost/AppService"</span></span>); request.Execute(requestParams, Action&lt;RequestCompletedEventArgs&gt; onRequestCompleted);</code> </pre><br>  Those.  Having prepared the request parameters, we simply call the server method and process the result in the callback method.  Easier does not happen! <br><br>  <b>Next in line is Java.</b> <br>  The main class is HttpURLConnection, which has a getInputStream () method.  Called - find two differences from .NET (not counting the name).  The idea is the same - the helper classes RequestParams and Request are created.  The RequestParams class is the name of the method being called and its parameters, and Request encapsulates the logic of working with HttpURLConnection.  For Json serialization, a library from Google is used - Gson, which can also be used for development for Android.  All that comes in Json format from an application server, implemented on an antagonistic to Java platform, is ‚Äúdigested‚Äù without any problems.  The only thing that does not understand Java by default is the MS date format.  But Gson is an expandable library, and the problem is solved simply: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MSDateJsonSerializer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonSerializer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> JsonElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Date date, Type typeOfT, JsonSerializationContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonPrimitive(<span class="hljs-string"><span class="hljs-string">"/Date("</span></span> + date.getTime() + <span class="hljs-string"><span class="hljs-string">")/"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MSDateJsonDeserializer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonDeserializer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Date</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Date </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deserialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JsonElement json, Type typeOfT, JsonDeserializationContext context)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> JsonParseException </span></span>{ String jsonDateToMilliseconds = <span class="hljs-string"><span class="hljs-string">"\\/(Date\\((.*?)(\\+.*)?\\))\\/"</span></span>; Pattern pattern = Pattern.compile(jsonDateToMilliseconds); Matcher matcher = pattern.matcher(json.getAsJsonPrimitive().getAsString()); String result = matcher.replaceAll(<span class="hljs-string"><span class="hljs-string">"$2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Long(result)); } }</code> </pre><br>  Streams from .NET are also compatible with Java (they are also streams in Africa): <br><pre> <code class="java hljs">ImageIcon icon = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImageIcon(‚Äúhttp:<span class="hljs-comment"><span class="hljs-comment">//localhost/AppService/service.ashx? method=GetImage('DSCN2099.JPG')‚Äù);</span></span></code> </pre><br>  So, we already have 4 clients, and taking into account that Android applications are written in Java, then all 5. <br><br>  I think it is now becoming clear that there are practically no restrictions on the type of clients, and all platforms that can work with Http and Json will be able to interact with our application server. </div><p>Source: <a href="https://habr.com/ru/post/123797/">https://habr.com/ru/post/123797/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123787/index.html">Smart Exception</a></li>
<li><a href="../123789/index.html">Making triodes in artisanal conditions</a></li>
<li><a href="../123790/index.html">Why couple and tuple are often bad</a></li>
<li><a href="../123791/index.html">STM32F1xx - we treat arduine dependence together</a></li>
<li><a href="../123793/index.html">JavaScript libraries for working with SVG</a></li>
<li><a href="../123799/index.html">Asus Eee Pad Transformer Review</a></li>
<li><a href="../123802/index.html">Facebook is testing a new home page design.</a></li>
<li><a href="../123804/index.html">Mash of flags: how to find out more about an exotic country</a></li>
<li><a href="../123805/index.html">Search engine job dataflow</a></li>
<li><a href="../123808/index.html">Attackers have access to data from users of the Washington Post</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>