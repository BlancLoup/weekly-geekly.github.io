<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a Tower Defense game in Unity: turrets and shooting at enemies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ The first and second parts of the tutorial] 



- We place on the field of the tower. 
- We aim at enemies with the help of physics. 
- We track the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a Tower Defense game in Unity: turrets and shooting at enemies</h1><div class="post__text post__text-html js-mediator-article">  [ <a href="https://habr.com/ru/post/449798/">The first</a> and <a href="https://habr.com/ru/post/452756/">second</a> parts of the tutorial] <br><br><ul><li>  We place on the field of the tower. </li><li>  We aim at enemies with the help of physics. </li><li>  We track them while it is possible. </li><li>  We shoot at them with a laser beam. </li></ul><br>  This is the third part of the tutorial series on creating a simple tower defense game.  It considered the creation of towers, aiming and shooting at enemies. <br><br>  Tutorial was created in Unity 2018.3.0f2. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/ceb/183/470ceb1832b49ee7372fb79b8425b567.jpg" width="512" height="256"></div><br>  <i>Let's set enemies to heat.</i> <br><br><h2>  Creating a tower </h2><br>  The walls only slow down the enemies, increasing the length of the path that they need to pass.  But the goal of the game is to destroy the enemies before they reach the end point.  This task is solved by placing on the field towers that will shoot at them. <br><a name="habracut"></a><br><h3>  Tile content </h3><br>  Towers are another type of tile content, so we add an entry for them to the <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint, Tower‚Ç¨ }</code> </pre> <br>  In this tutorial, we will only support one type of towers, which can be implemented by providing <code>GameTileContentFactory</code> one link to the tower prefab, an instance of which can also be created via <code>Get</code> . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Tower‚Ç¨: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(towerPrefab); } ‚Ä¶ }</code> </pre> <br>  But the towers have to shoot, so their condition will need to be updated and they need their own code.  For this purpose, we will create the <code>Tower</code> class, which extends the <code>GameTileContent</code> class. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tower</span></span> : <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> {}</code> </pre> <br>  You can make the tower prefab have its own component by changing the factory field type to <code>Tower</code> .  Since the class is still considered <code>GameTileContent</code> , nothing else needs to be changed. <br><br><pre> <code class="cs hljs"> Tower towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><h3>  Prefab </h3><br>  Create a prefab for the tower.  You can start by duplicating the prefab wall and replacing its <code>GameTileContent</code> component with a <code>Tower</code> component, and then changing its type to <em>Tower</em> .  To make the tower fit the walls, save the cube of the wall as the base of the tower.  Then place another cube on top of it.  I gave him a scale of 0.5.  Put another cube on it, indicating the turret, this part will aim and shoot at enemies. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/e5d/633/392e5d63397672627c3b5ec018df0444.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/dec/c33/d92decc33036a1e973a7f20a3df2c00e.png" width="320" height="120"></div><br>  <i>Three cubes forming a tower.</i> <br><br>  The turret will rotate, and since it has a collider, it will be monitored by a physics engine.  But we do not need to be so accurate, because we only use tower colliders to select cells.  It is quite possible to do approximately.  Remove the turret cube collider and change the tower cube collider to cover both cubes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/11e/3b7/e0111e3b7221bbbe4e5b0d23373e4b3a.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/857/09b/a1f85709bd504d176a18930240edea5a.png" width="320" height="152"></div><br>  <i>Collider cube towers.</i> <br><br>  The turret will fire a laser beam.  It can be visualized in many ways, but we simply use a translucent cube, which we will stretch to form a beam.  Each tower should have its own beam, so add it to the tower prefab.  Place it inside the turret so that it is hidden by default and give it a smaller scale, for example 0.2.  Let's make it a child of the prefab root, not the turret cube. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/1dc/29e/19a1dc29e70adb158e07f29653db2d66.png" width="190" height="260" alt="laser beam"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/273/081/45a273081365aa9e483f1aa97cbe39c8.png" width="226" height="108" alt="hierarchy"></div><br>  <i>Hidden cube laser beam.</i> <br><br>  Create a suitable material for the laser beam.  I just used the standard translucent black material and turned off all the reflections, and also gave it a red emitted color. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/e49/860/2fbe498604cc4cc4ed6ee60a45eea63d.png" width="320" height="284" alt="color"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/b46/483/0ebb4648376a7fe68c96b7a16ce27db9.png" width="320" height="56" alt="no reflections"></div><br>  <i>The material of the laser beam.</i> <br><br>  Check that the laser beam doesn‚Äôt have a collider, and also disable the drop and receive shadows from it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f21/0ad/ecff210ad75ef4b12cb0a74102365492.png" width="320" height="162"></div><br>  <i>The laser beam does not interact with the shadows.</i> <br><br>  After completing the creation of the prefab tower, add it to the factory. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/37c/935/62637c9353cf1e20e170e82bbefcdb11.png" width="320" height="114"></div><br>  <i>Factory with a tower.</i> <br><br><h3>  Placement of towers </h3><br>  We will add and remove towers using another switching method.  You can simply duplicate the <code>GameBoard.ToggleWall</code> by changing the method name and content type. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower‚Ç¨) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower‚Ç¨); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } }</code> </pre> <br>  In <code>Game.HandleTouch</code> if you hold down the shift key, the walls will not switch, but the towers. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleTower(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleWall(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/804/2ac/9268042acc19a28d6ff1a6d74d83144f.png" width="230" height="230"></div><br>  <i>Towers on the field.</i> <br><br><h3>  Blocking the path </h3><br>  For now, only walls can block the search for a path, so the enemies move through the towers.  Let's add a helper property in <code>GameTileContent</code> indicate whether the content is blocking the path.  The path is blocked if it is a wall or a tower. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlocksPath =&gt; Type == GameTileContentType.Wall || Type == GameTileContentType.Tower‚Ç¨;</code> </pre> <br>  Use this property in <code>GameTile.GrowPathTo</code> instead of checking the content type. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">//neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null; neighbor.Content.BlocksPath ? null : neighbor; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/93f/eed/6fa93feedb4925ee12decb4233612a4c.png" width="230" height="230"></div><br>  <i>Now the path is blocked and the walls and towers.</i> <br><br><h3>  Replace the walls </h3><br>  Most likely, the player will often replace walls with towers.  It will be inconvenient for him to first clean the wall, and besides, enemies will be able to penetrate this temporary gap.  You can implement a direct replacement by forcing the <code>GameBoard.ToggleTower</code> to check if the wall is currently on the tile.  If yes, then you need to immediately replace it with a tower.  In this case, we will not have to look for other ways, because the tile still blocks them. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); } }</code> </pre> <br><h2>  Aiming at enemies </h2><br>  The tower can perform its task only when it finds an enemy.  After finding the enemy, she must decide in which part of it to aim. <br><br><h3>  Aiming point </h3><br>  To detect targets, we will use a physics engine.  As in the case with the tower collider, we do not need the enemy collider to necessarily coincide with its shape.  You can choose the simplest collider, that is, the sphere.  After detecting the enemy, we will use the position of the game object with the collider attached to it as a point for aiming. <br><br>  We cannot attach the collider to the enemy's root object, because it does not always coincide with the model's position and will force the tower to aim at the ground.  That is, you need to place the collider somewhere on the model.  The physics engine will give us a link to this object, which we can use to aim, but we also need access to the <code>Enemy</code> component of the root object.  To simplify the task, let's create a <code>TargetPoint</code> component.  We give it a property for a private task and a public receiving component <code>Enemy</code> , and another property for getting its position in the world. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TargetPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy Enemy‚Ç¨ { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position =&gt; transform.position; }</code> </pre> <br>  Give it the <code>Awake</code> method, which sets a link to its <code>Enemy</code> component.  You can go directly to the root object using <code>transform.root</code> .  If the <code>Enemy</code> component does not exist, then we made a mistake in creating the enemy, so let's add a statement for this. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy‚Ç¨ = transform.root.GetComponent&lt;Enemy&gt;(); Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  In addition, the collider must be attached to the same game object to which <code>TargetPoint</code> attached. <br><br><pre> <code class="cs hljs"> Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Debug.Assert( GetComponent&lt;SphereCollider&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without sphere collider!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> );</code> </pre> <br>  Add to the cube of the enemy prefab component and collider.  This will force the towers to aim at the center of the cube.  We use a spherical collider with a radius of 0.25.  The cube has a scale of 0.5, so the true radius of the collider will be equal to 0.125.  Due to this, the enemy will have to visually cross the range circle of the tower, and only after some time become a real target.  The size of the collider is also affected by the random scale of the enemy, so its size in the game will also vary slightly. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/5ca/5e4/85e5ca5e47b8d59fa4211c78126bd512.png" width="176" height="176"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a71/aec/7aea71aecbd64d4e045df141ecd1c711.png" width="320" height="176" alt="inspector"></div><br>  <i>The enemy with a point for aiming and a collider on the cube.</i> <br><br><h3>  Layer of enemies </h3><br>  Towers are only disturbed by enemies, and they aim at nothing else, so we will place all enemies in a separate layer.  Use layer 9. Change its name to <em>Enemy</em> in the <em>Layers &amp; Tags</em> window, which can be opened via the <em>Edit Layers</em> option in the <em>Layers</em> drop-down menu in the upper right corner of the editor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e6/9a5/762/8e69a5762e8eb1856175f9d9dc1ab388.png" width="320" height="308"></div><br>  <i>Layer 9 will be used for enemies.</i> <br><br>  This layer is needed only to recognize enemies, and not for physical interactions.  Let's point this out by turning them off in the <em>Layer Collision Matrix</em> , which is located in the <em>Physics</em> panel of the project settings. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/06e/e7d/87606ee7dfc4777760d81219517125ce.png" width="200" height="200"></div><br>  <i>Layer collision matrix.</i> <br><br>  Make sure that the game object of the aiming point is on the right layer.  The rest of the enemy prefab may be on other layers, but it will be easier to arrange everything and place the entire prefab on the <em>Enemy</em> layer.  If you change the root object layer, you will be prompted to change the layer for all its child objects. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/f75/062/6d1f75062420abadb285e9efca1e1a5e.png" width="320" height="44"></div><br>  <i>The enemy on the right layer.</i> <br><br>  Let's add the statement that <code>TargetPoint</code> really is on the right layer. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ Debug.Assert(gameObject.layer == <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point on wrong layer!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  In addition, player actions should ignore enemy colliders.  This can be done by adding the layer mask argument to <code>Physics.Raycast</code> in the <code>GameBoard.GetTile</code> .  This method has a form that takes as an additional argument the distance to the beam and the layer mask.  Give it the maximum distance and the default layer mask, that is, 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Shouldn't a layer mask be 0?</b> <div class="spoiler_text">  The layer index defaults to zero, but we pass the layer mask.  The mask changes the individual bits of an integer to 1 if the layer needs to be included.  In this case, you need to set only the first bit, that is, the youngest, which means 2 <sup>0</sup> , which equals 1. </div></div><br><h3>  Update Tile Content </h3><br>  Towers can perform their task only when their status is updated.  The same applies to the content of tiles in general, although the rest of the content does nothing.  Therefore, <code>GameTileContent</code> add a virtual <code>GameTileContent</code> method to <code>GameUpdate</code> , which by default does nothing. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br>  Let's make <code>Tower</code> redefine it, even if for now it just displays to the console what the target is looking for. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Searching for target..."</span></span>); }</code> </pre> <br>  <code>GameBoard</code> deals with tiles and their contents, so it will also keep track of which content needs to be updated.  To do this, add a list to it and a public <code>GameUpdate</code> method that updates everything in the list. <br><br><pre> <code class="cs hljs"> List&lt;GameTileContent&gt; updatingContent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTileContent&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; updatingContent.Count; i++) { updatingContent[i].GameUpdate(); } }</code> </pre> <br>  In our tutorial you only need to update the tower.  <code>ToggleTower</code> so that it adds and deletes content if necessary.  If the update is required and other content, then we need a more general approach, but for now this is enough. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { updatingContent.Remove(tile.Content); tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower); <span class="hljs-comment"><span class="hljs-comment">//if (!FindPaths()) { if (FindPaths()) { updatingContent.Add(tile.Content); } else { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } else if (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); updatingContent.Add(tile.Content); } }</span></span></code> </pre> <br>  To make it work, now we just need to update the field in <code>Game.Update</code> .  We will update the field after the enemies.  Thanks to this, the towers will be able to aim exactly where the enemies are.  If we did otherwise, the towers would aim at where the enemies in the last frame were. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); board.GameUpdate(); }</code> </pre> <br><h3>  Aiming range </h3><br>  The towers have a limited radius of aiming.  Let's make it customizable by adding a field to the <code>Tower</code> class.  The distance is measured from the center of the tower tile, so at a distance of 0.5 it will cover only its own tile.  Therefore, a reasonable minimum and standard range will be 1.5, covering most of the adjacent tiles. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1.5f, 10.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> targetingRange = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/ae4/ee8/c38ae4ee885cf5d89f24164b9c6bc5fe.png" width="320" height="74"></div><br>  <i>Targeting range 2.5.</i> <br><br>  Let's visualize the range with a gizmo.  We do not need to see it all the time, so we will create the <code>OnDrawGizmosSelected</code> method, which is called only for selected objects.  Draw the yellow frame of the sphere with a radius equal to the distance and centered relative to the tower.  Place it a little above the ground so that it can always be clearly seen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Gizmos.color = Color.yellow; Vector3 position = transform.localPosition; position.y += <span class="hljs-number"><span class="hljs-number">0.01f</span></span>; Gizmos.DrawWireSphere(position, targetingRange); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/6b7/3cd/6746b73cd2e015fd599b770bb89e1c8a.png" width="230" height="230"></div><br>  <i>Gizmo aiming range.</i> <br><br>  Now we can see which of the enemies is an accessible target for each of the towers.  But choosing towers in the scene window is inconvenient, because we have to choose one of the child cubes, and then switch to the root object of the tower.  Other types of tile content also suffer from the same problem.  We can force the selection of the <code>GameTileContent</code> content in the scene window by adding the <code>SelectionBase</code> attribute to the <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SelectionBase</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br><h3>  Capture Target </h3><br>  Add a <code>TargetPoint</code> field to the <code>Tower</code> class so that it can track its captured target.  Then we change <code>GameUpdate</code> to call the new <code>AquireTarget</code> method, which returns information about whether it found the target.  Upon detection, it will display a message in the console. <br><br><pre> <code class="cs hljs"> TargetPoint target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Acquired target!"</span></span>); } }</code> </pre> <br>  In <code>AcquireTarget</code> we get all available targets by calling <code>Physics.OverlapSphere</code> with the position of the tower and the range as arguments.  The result is a <code>Collider</code> array containing all the colliders that are in contact with the sphere.  If the array length is positive, then there is at least one aiming point, and we simply choose the first one.  Take its <code>TargetPoint</code> component, which should always exist, assign it to the target field and report success.  Otherwise, clear the target and report the failure. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targets.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targets[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targets[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  We are guaranteed to get the correct aiming points, if we consider the colliders only on the layer of enemies.  This is layer 9, so we will transfer the corresponding layer mask. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemyLayerMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">How does this bit mask work?</b> <div class="spoiler_text">  Since the enemy layer has an index of 9, the tenth bit of the bitmask should be set to 1. This corresponds to the integer 2 <sup>9</sup> , that is, 512. But such a recording of the bit mask is unintuitive.  We can also write a binary literal, for example <code>0b10_0000_0000</code> , but then we have to count to zero.  In this case, the most convenient entry would be to use the left shift <code>&lt;&lt;</code> operator, shifting the bits to the left.  which corresponds to a number in the power of two. </div></div><br>  You can visualize a captured target by drawing a line-gizmo between the positions of the tower and the target. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Gizmos.DrawLine(position, target.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e99/4be/7a5e994be6b7d848c2d4bfe7d627c708.png" width="230" height="230"></div><br>  <i>Visualization of goals.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Why not use methods like OnTriggerEnter?</b> <div class="spoiler_text">  The advantage of manual verification of cross-cutting targets is that we can only do this when necessary.  There is no reason to check for targets if the tower already has them.  In addition, thanks to getting all the potential targets at once, we don‚Äôt have to process a list of potential targets for each tower that is constantly changing. </div></div><br><h3>  Target fixation </h3><br>  The target chosen for capture depends on the order in which the physics engine represents them, that is, in fact it is arbitrary.  Therefore, it will seem that the captured target is changing for no reason.  After the tower receives the target, it is more logical for it to track it one, and not to switch to another.  Add a <code>TrackTarget</code> method that implements such tracking and returns information on whether it was successful.  At first, let's just say if the target is captured. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Call this method in <code>GameUpdate</code> and only when returning false will we call <code>AcquireTarget</code> .  If the method returns true, then we have a goal.  This can be done by placing both method calls in an <code>if</code> check with the OR operator, because if the first operand returns <code>true</code> , then the second will not be checked and the call will be skipped.  The AND operator acts in a similar way. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Locked on target!"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ec/27c/0a2/8ec27c0a2201434cba3725621b68aaa1.png" width="230" height="230"></div><br>  <i>Tracking goals.</i> <br><br>  As a result, the towers are fixed on the target until it reaches the end point and is destroyed.  If you use enemies repeatedly, you need to check the correctness of the link instead, as is done with the links to the figures processed in the <a href="https://catlikecoding.com/unity/tutorials/object-management/">Object Management</a> tutorial series. <br><br>  To track targets only when they are within range, <code>TrackTarget</code> must track the distance between the tower and the target.  If it exceeds the range value, the target needs to be reset and return false.  For this check, you can use the <code>Vector3.Distance</code> method. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  However, this code does not take into account the radius of the collider.  Therefore, as a result, the tower may lose the target, then capture it again, only to stop tracking it in the next frame, and so on.  We can avoid this by adding the radius of the collider to the range. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span>) { ‚Ä¶ }</code> </pre> <br>  This gives us the right results, but only if the scale of the enemy is not changed.  Since we give each enemy a random scale, we must take it into account when changing the range.  To do this, we must memorize the scale given by <code>Enemy</code> and open it with the getter property. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Scale { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { Scale = scale; ‚Ä¶ }</code> </pre> <br>  Now we can check in <code>Tower.TrackTarget</code> correct range. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale) { ‚Ä¶ }</code> </pre> <br><h3>  Sync physics </h3><br>  It seems that everything works well, but towers that can aim at the center of the field are capable of capturing targets that should be out of range.  They will not be able to track these goals, so they are fixed on them only for one frame. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/0a1/836/e910a1836ef729d95ebee121a67c3f2c.png" width="230" height="230"></div><br>  <i>Improper aiming.</i> <br><br>  This happens because the state of the physics engine is not perfectly synchronized with the state of the game.  Copies of all enemies are created at the origin of the world, which coincides with the center of the field.  Then we move them to the point of creation, but the physics engine does not immediately know about it. <br><br>  You can enable instant synchronization when changing object transformations by setting the <code>Physics.autoSyncTransforms</code> value to <code>true</code> .  But by default it is disabled, because it is much more efficient to synchronize everything together and, if necessary.  In our case, synchronization is required only when the state of the towers is updated.  We can perform it by calling <code>Physics.SyncTransforms</code> between updates of enemies and the field in <code>Game.Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); }</code> </pre> <br><h3>  Ignore the height </h3><br>  In fact, our gameplay takes place in 2D.  Therefore, let's change the <code>Tower</code> so that when aiming and tracking it takes into account only the X and Z coordinates. The physics engine works in 3D space, but in fact we can perform <code>AcquireTarget</code> verification in 2D: stretch the sphere upward so that it covers all colliders, regardless from their vertical position.  This can be done by using a capsule instead of a sphere, the second point of which will be in several units above the ground (say, in three). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">3f</span></span>; Collider[] targets = Physics.OverlapCapsule( a, b, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is it not possible to use a physical 2D engine?</font></font></b> <div class="spoiler_text">   ,       XZ,   2D-    XY.     ,     ,    2D-   .     3D-. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Need to also change </font></font><code>TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Of course, we can use 2D vectors and </font></font><code>Vector2.Distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but let's do the calculations ourselves and instead we will compare the squares of distances, this will be enough. </font><font style="vertical-align: inherit;">So we will get rid of the square root operation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = ax - bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = az - bz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x * x + z * z &gt; r * r) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How do these mathematical calculations work?</font></font></b> <div class="spoiler_text">     2D-   ,     .     ,       .  ,        ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Avoid memory allocation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The disadvantage of use </font></font><code>Physics.OverlapCapsule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is that for each call it allocates a new array. </font><font style="vertical-align: inherit;">This can be avoided by selecting the array once and calling the alternative method </font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the array as an additional argument. </font><font style="vertical-align: inherit;">The length of the transmitted array determines the number of results obtained. </font><font style="vertical-align: inherit;">All potential targets outside the array are discarded. </font><font style="vertical-align: inherit;">We will still use only the first element, so we have enough of an array of length 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of an array, </font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the number of collisions, up to the maximum permissible, and we will check this number instead of the array length.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">1</span></span>]; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hits = Physics.OverlapCapsuleNonAlloc( a, b, targetingRange, targetsBuffer, enemyLayerMask ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We shoot at enemies </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have a real goal, it's time to shoot it. </font><font style="vertical-align: inherit;">Shooting includes aiming, laser shot and damage.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aiming turret </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To direct the turret to the target, the class </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">needs to have a reference to the </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turret </font><font style="vertical-align: inherit;">component </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Add a configuration field for this and connect it to the tower prefab.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/3be/41b/e0f3be41b0936993268316b8f01e1f67.png" width="320" height="90"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attached turret. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is a real goal, then we must shoot it. </font><font style="vertical-align: inherit;">Put the firing code in a separate method. </font><font style="vertical-align: inherit;">Let's make him rotate the turret towards the target, calling his method </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with an aiming point as an argument.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { <span class="hljs-comment"><span class="hljs-comment">//Debug.Log("Locked on target!"); Shoot(); } } void Shoot () { Vector3 point = target.Position; turret.LookAt(point); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/5bb/e9d/00e5bbe9d98e739800bf47435ca574af.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just aiming.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We shoot laser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To position a laser beam, a class </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">also needs a reference to it.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, laserBeam = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/c9c/86e/802c9c86eac24112cb2b4f072fd0f410.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We connected a laser beam. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To turn a cube into a real laser beam, you need to take three steps. </font><font style="vertical-align: inherit;">Firstly, its orientation must correspond to the orientation of the turret. </font><font style="vertical-align: inherit;">This can be done by copying its rotation.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Second, we scale the laser beam so that its length is equal to the distance between the local point of origin of the turret and the aiming point. </font><font style="vertical-align: inherit;">We scale it along the Z axis, that is, the local axis directed toward the target. </font><font style="vertical-align: inherit;">To preserve the original XY scale, we write down the initial scale on waking up (Awake) turrets.</font></font><br><br><pre> <code class="cs hljs"> Vector3 laserBeamScale; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { laserBeamScale = laserBeam.localScale; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = Vector3.Distance(turret.position, point); laserBeamScale.z = d; laserBeam.localScale = laserBeamScale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Third, place the laser beam in the middle between the turret and the aiming point. </font></font><br><br><pre> <code class="cs hljs"> laserBeam.localScale = laserBeamScale; laserBeam.localPosition = turret.localPosition + <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * d * laserBeam.forward;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/d96/438/288d96438354bd732fd7a3bb84ead491.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shooting laser beams.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isn't it possible to make a laser beam a child of a turret?</font></font></b> <div class="spoiler_text">     ,         ,       forward.       ,     .     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This works as long as the turret is fixed on the target. </font><font style="vertical-align: inherit;">But when there is no goal, the laser remains active. </font><font style="vertical-align: inherit;">We can turn off the laser display by </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setting </font><font style="vertical-align: inherit;">its scale to </font><font style="vertical-align: inherit;">0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Shoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { laserBeam.localScale = Vector3.zero; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/8c8/c23/39b8c8c239e0936137c646f91a4197de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idle towers do not shoot.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enemy health </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far our laser beams just touch the enemies and have no effect on them anymore. </font><font style="vertical-align: inherit;">It is necessary to make the laser cause damage to enemies. </font><font style="vertical-align: inherit;">We do not want to destroy enemies instantly, so we give the </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property of health. </font><font style="vertical-align: inherit;">As health, you can choose any value, so let's take 100. But it will be more logical for large enemies to have more health, so we will introduce a factor for this.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Health = <span class="hljs-number"><span class="hljs-number">100f</span></span> * scale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To add support for damage, add a public method </font></font><code>ApplyDamage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that subtracts its parameter from health. </font><font style="vertical-align: inherit;">We will assume that the damage is non-negative, so we add a statement about it.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyDamage</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(damage &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Negative damage applied."</span></span>); Health -= damage; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will not immediately get rid of the enemy as soon as his health reaches zero. </font><font style="vertical-align: inherit;">Health exhaustion checks and destruction of the enemy will be performed at the beginning </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thanks to this, all the towers will in fact shoot at the same time, rather than in turns, which will allow them to switch to other targets if the previous tower destroyed the enemy, which they also aimed at. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Damage per second </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to determine how much damage the laser will do. </font><font style="vertical-align: inherit;">To do this, add to </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the configuration field. </font><font style="vertical-align: inherit;">Since the laser beam does continuous damage, we express it as damage per second. </font><font style="vertical-align: inherit;">We </font></font><code>Shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apply it to the </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">target </font><font style="vertical-align: inherit;">component </font><font style="vertical-align: inherit;">multiplied by the time delta.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 100f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damagePerSecond = <span class="hljs-number"><span class="hljs-number">10f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ target.Enemy.ApplyDamage(damagePerSecond * Time.deltaTime); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/18f/199/88618f199c9c08e7eaeb89b16083f545.png" width="320" height="128" alt="inspector"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/vt/sf/gkvtsfa1ya4igbsjagqhtnzu0wq.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The damage of each tower is 20 units per second.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aiming randomly </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we always choose the first available target, the aiming behavior depends on the order in which the physics engine checks intersecting colliders. This relationship is not very good, because we do not know the details, we can not manage it, besides it will look strange and inconsistent. Often this behavior leads to concentrated fire, but this is not always the case. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of relying entirely on the physics engine, let's add some randomness. This can be done by increasing the number of intersections obtained by colliders, for example, to 100. Perhaps this will not be enough to obtain all possible targets on a field densely filled with enemies, but this will be enough to improve aiming.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">100</span></span>];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now, instead of selecting the first potential target, we will select a random element from the array. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, hits)].GetComponent&lt;TargetPoint&gt;(); ‚Ä¶ } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/lt/hi/nvlthij_ixh6lsxgwujtoipjwg4.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Random aiming.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Can other criteria be used to select targets?</font></font></b> <div class="spoiler_text"> , ,        .  ,      ,     .    .             . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, in our game of the tower defense genre, towers finally appeared. </font><font style="vertical-align: inherit;">In the next part, the game will take its final shape even more.</font></font></div><p>Source: <a href="https://habr.com/ru/post/459070/">https://habr.com/ru/post/459070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459054/index.html">Heat map of clicks - how users behave on the site</a></li>
<li><a href="../459062/index.html">The digest of interesting materials for the mobile # 305 developer (July 1 - 7)</a></li>
<li><a href="../459066/index.html">Balancing write and read in the database</a></li>
<li><a href="../459068/index.html">Windows Server 2008 R2 - The King Is Dead, Long Live The King</a></li>
<li><a href="../45907/index.html">Whom ‚ÄúOdnoklassniki‚Äù scared ‚ÄúGoogle‚Äù?</a></li>
<li><a href="../459074/index.html">Small python joy # 7: three things for the price of one - console animation, algorithms and debugging</a></li>
<li><a href="../459078/index.html">CERN switches to open source software - why?</a></li>
<li><a href="../459080/index.html">Features HttpUrlConnection from java.net</a></li>
<li><a href="../459082/index.html">Who are eidetics, how do false memories work, and three popular myths about memory</a></li>
<li><a href="../459084/index.html">A little about Google Home Hub, or how I bought a photo frame for 130 Euro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>