<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Combining C ++ and Python. Subtleties Boost.Python. Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of the first part . 
 We continue to torment Boost.Python. This time it is the turn of the class, which can neither be ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Combining C ++ and Python. Subtleties Boost.Python. Part two</h1><div class="post__text post__text-html js-mediator-article">  This article is a continuation of the <a href="http://habrahabr.ru/post/168083/">first part</a> . <br>  We continue to torment Boost.Python.  This time it is the turn of the class, which can neither be created nor copied. <br>  Let's wrap an almost ordinary sishny structure with an unusual designer. <br>  And we‚Äôll work with returning a reference to a C ++ object field so that the Python garbage collector doesn‚Äôt delete it inadvertently.  Well and on the contrary, we will make an alternative option so that Python can clear up the garbage after removing what has been given to it for storage. <br>  Go‚Ä¶ <br><a name="habracut"></a><br><h4>  Table of contents </h4><br><ul><li>  <a href="http://habrahabr.ru/post/168083/">Combining C ++ and Python.</a>  <a href="http://habrahabr.ru/post/168083/">Subtleties Boost.Python.</a>  <a href="http://habrahabr.ru/post/168083/">Part one</a> </li><li>  <a href="http://habrahabr.ru/post/168233/">Combining C ++ and Python.</a>  <a href="http://habrahabr.ru/post/168233/">Subtleties Boost.Python.</a>  <a href="http://habrahabr.ru/post/168233/">Part two</a> </li><li>  <a href="http://habrahabr.ru/post/168827/">Type conversion to Boost.Python.</a>  <a href="http://habrahabr.ru/post/168827/">We do the conversion between the usual types of C + + and Python</a> </li><li>  <a href="http://habrahabr.ru/post/169639/">Exception travel between C ++ and Python, or "Back and forth"</a> </li></ul><br><h4>  Preparing a project </h4><br>  For our purposes, it would be enough for us to supplement the draft example remaining from the previous part. <br>  Let's add to it a couple more files to work with the singleton class: <br>  <b>single.h</b> <br>  <b>single.cpp</b> <br>  And we will render the declarations of auxiliary functions for wrapping in Python into a separate file: <br>  <b>wrap.h</b> <br><br>  From the previous project there should have been a file that we will actively change: <br>  <b>wrap.cpp</b> <br>  And the wonderful files with the miracle class, which helped us so much in the first part, they will remain as they are: <br>  <b>some.h</b> <br>  <b>some.cpp</b> <br><br><h4>  Wrapping a simple structure </h4><br>  Let's start with the fact that we get in single.h a small C-style structure, just with a description of the fields. <br>  Let's for interest, this will be not just a structure, but a kind of cryptic configuration description type: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> coef; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max_size; Config( <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> def_coef, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; def_path, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> def_max_size ); };</code> </pre> <br>  It is easy to make a wrapper for such a structure, you just need to specifically describe the constructor with parameters using the constructor template boost :: python :: init &lt;...&gt; (...) of the wrapper template parameter boost :: python :: class_: <br><pre> <code class="cpp hljs"> class_&lt;Config&gt;( <span class="hljs-string"><span class="hljs-string">"Config"</span></span>, init&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( args( <span class="hljs-string"><span class="hljs-string">"coef"</span></span>, <span class="hljs-string"><span class="hljs-string">"path"</span></span>, <span class="hljs-string"><span class="hljs-string">"max_size"</span></span> ) ) .add_property( <span class="hljs-string"><span class="hljs-string">"coef"</span></span>, make_getter( &amp;Config::coef ), make_setter( &amp;Config::coef ) ) .add_property( <span class="hljs-string"><span class="hljs-string">"path"</span></span>, make_getter( &amp;Config::path ), make_setter( &amp;Config::path ) ) .add_property( <span class="hljs-string"><span class="hljs-string">"max_size"</span></span>, make_getter( &amp;Config::max_size ), make_setter( &amp;Config::max_size ) ) ;</code> </pre><br>  As you can see, here you don‚Äôt even have to use return_value_policy &lt;copy_const_reference&gt; for a string field.  Just because the field here is taken essentially by value, and therefore it will automatically be converted to the standard string of the Python language. <br>  The make_setter functions still do a very useful job of checking the type of the incoming value, for example, try setting the coef field in Python to a string type or setting max_size with a value of type float, get an exception. <br>  The fields of the config structure are essentially converted into properties of the object of the full-fledged Python class Config.  Well, almost complete ... Let's, by analogy with the Some class from the last chapter, add the <b>__str__</b> and <b>__repr__</b> methods to the wrapper, and at the same time add the as_dict property to convert the structure fields to standard dict python and back. <br>  Declaring new functions, as well as old ones, will be transferred to our new wrap.h file: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/python.hpp&gt; #include "some.h" #include "single.h" using namespace boost::python; string Some_Str( Some const&amp; ); string Some_Repr( Some const&amp; ); dict Some_ToDict( Some const&amp; ); void Some_FromDict( Some&amp;, dict const&amp; ); string Config_Str( Config const&amp; ); string Config_Repr( Config const&amp; ); dict Config_ToDict( Config const&amp; ); void Config_FromDict( Config&amp;, dict const&amp; );</span></span></span></span></code> </pre><br>  In the wrap.cpp file, nothing extra will be left and the example module will immediately be declared, which will obviously add readability. <br>  At the end of wrap.cpp we will write the implementation of our new functions, by analogy with the way we wrote them in the first part: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config_Str</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Config </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; config )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> output; output &lt;&lt; <span class="hljs-string"><span class="hljs-string">"{ coef: "</span></span> &lt;&lt; config.coef &lt;&lt; <span class="hljs-string"><span class="hljs-string">", path: '"</span></span> &lt;&lt; config.path &lt;&lt; <span class="hljs-string"><span class="hljs-string">"', max_size: "</span></span> &lt;&lt; config.max_size &lt;&lt; <span class="hljs-string"><span class="hljs-string">" }"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output.str(); } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config_Repr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Config </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; config )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Config: "</span></span> + Config_Str( config ); } <span class="hljs-function"><span class="hljs-function">dict </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config_ToDict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Config </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; config )</span></span></span><span class="hljs-function"> </span></span>{ dict res; res[<span class="hljs-string"><span class="hljs-string">"coef"</span></span>] = config.coef; res[<span class="hljs-string"><span class="hljs-string">"path"</span></span>] = config.path; res[<span class="hljs-string"><span class="hljs-string">"max_size"</span></span>] = config.max_size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Config_FromDict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Config&amp; config, dict </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; src )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( src.has_key( <span class="hljs-string"><span class="hljs-string">"coef"</span></span> ) ) config.coef = extract&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;( src[<span class="hljs-string"><span class="hljs-string">"coef"</span></span>] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( src.has_key( <span class="hljs-string"><span class="hljs-string">"path"</span></span> ) ) config.path = extract&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;( src[<span class="hljs-string"><span class="hljs-string">"path"</span></span>] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( src.has_key( <span class="hljs-string"><span class="hljs-string">"max_size"</span></span> ) ) config.max_size = extract&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( src[<span class="hljs-string"><span class="hljs-string">"max_size"</span></span>] ); }</code> </pre><br>  This I, of course, am already struggling with fat, but let's call it a repetition of the past. <br>  In the structure wrapper, of course, we add new announcements: <br><pre> <code class="cpp hljs"> class_&lt;Config&gt;( <span class="hljs-string"><span class="hljs-string">"Config"</span></span>, init&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( args( <span class="hljs-string"><span class="hljs-string">"coef"</span></span>, <span class="hljs-string"><span class="hljs-string">"path"</span></span>, <span class="hljs-string"><span class="hljs-string">"max_size"</span></span> ) ) ) .add_property( <span class="hljs-string"><span class="hljs-string">"coef"</span></span>, make_getter( &amp;Config::coef ), make_setter( &amp;Config::coef ) ) .add_property( <span class="hljs-string"><span class="hljs-string">"path"</span></span>, make_getter( &amp;Config::path ), make_setter( &amp;Config::path ) ) .add_property( <span class="hljs-string"><span class="hljs-string">"max_size"</span></span>, make_getter( &amp;Config::max_size ), make_setter( &amp;Config::max_size ) ) .def( <span class="hljs-string"><span class="hljs-string">"__str__"</span></span>, Config_Str ) .def( <span class="hljs-string"><span class="hljs-string">"__repr__"</span></span>, Config_Repr ) .add_property( <span class="hljs-string"><span class="hljs-string">"as_dict"</span></span>, Config_ToDict, Config_FromDict ) ;</code> </pre><br>  With the structure of nothing complicated, it turned out to be a wonderful Python class that mirrors the properties of the Config structure in C ++ and at the same time the class is completely Pythonist.  The only problem with this class will be that you need to specify something in the constructor when creating it. <br>  To populate the configuration parameters and access them, let's set up a singleton, and at the same time provide it with a ‚Äúuseful‚Äù counter. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Wrapper class without the ability to create and copy </h4><br>  So singleton.  Let it contain the aforementioned configuration parameters of the current application and some magic counter for getting the current identifier. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Single</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CurrentID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Config&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Config </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mCurrentID; Config mAppConfig; Single(); Single( Single <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Single&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThisCurrentID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Config&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThisAppConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThisAppConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Config </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span></span>; };</code> </pre><br>  As you have probably noticed, I don‚Äôt really like to use the useless Instance () method in the <b>public</b> section and prefer working with the singleton functionality as a set of static methods.  From this singleton does not cease to be a singleton, and the user of the class will thank you for hiding the Instance () call into the implementation. <br>  This is actually the implementation in <b>single.cpp</b> : <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"single.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/thread.hpp&gt; using boost::mutex; using boost::unique_lock; const double CONFIG_DEFAULT_COEF = 2.5; const int CONFIG_DEFAULT_MAX_SIZE = 0x1000; const string CONFIG_DEFAULT_PATH = "."; int Single::CurrentID() { return Instance().ThisCurrentID(); } Config&amp; Single::AppConfig() { return Instance().ThisAppConfig(); } void Single::AppConfig( Config const&amp; config ) { Instance().ThisAppConfig( config ); } Single::Single() : mCurrentID( 0 ) { mAppConfig.coef = CONFIG_DEFAULT_COEF; mAppConfig.max_size = CONFIG_DEFAULT_MAX_SIZE; mAppConfig.path = CONFIG_DEFAULT_PATH; } Single&amp; Single::Instance() { static mutex single_mutex; unique_lock&lt;mutex&gt; single_lock( single_mutex ); static Single instance; return instance; } int Single::ThisCurrentID() { static mutex id_mutex; unique_lock&lt;mutex&gt; id_lock( id_mutex ); return ++mCurrentID; } Config&amp; Single::ThisAppConfig() { return mAppConfig; } void Single::ThisAppConfig( Config const&amp; config ) { mAppConfig = config; }</span></span></span></span></code> </pre><br>  Only three static methods, the wrapper should not be complicated, if you do not take into account one thing ... but no, not exactly one thing: <br>  1. You cannot create an instance of a class. <br>  2. You cannot copy an instance of a class. <br>  3. We haven't wrapped static methods yet. <br><pre> <code class="cpp hljs"> class_&lt;Single, noncopyable&gt;( <span class="hljs-string"><span class="hljs-string">"Single"</span></span>, no_init ) .def( <span class="hljs-string"><span class="hljs-string">"CurrentID"</span></span>, &amp;Single::CurrentID ) .staticmethod( <span class="hljs-string"><span class="hljs-string">"CurrentID"</span></span> ) .def( <span class="hljs-string"><span class="hljs-string">"AppConfig"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; Config&amp; (*)() &gt;( &amp;Single::AppConfig ), return_value_policy&lt;reference_existing_object&gt;() ) .def( <span class="hljs-string"><span class="hljs-string">"AppConfig"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*)( Config <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; ) &gt;( &amp;Single::AppConfig ) ) .staticmethod( <span class="hljs-string"><span class="hljs-string">"AppConfig"</span></span> ) ;</code> </pre><br>  As you can see, all the difficulties associated with the 1st and 2nd items are reduced to specifying the template parameter <b>boost :: noncopyable</b> and passing the parameter <b>boost :: python :: no_init to</b> the template class constructor boost :: python :: class_. <br>  If you want the class to support copying or contain a default constructor, you can erase the corresponding muffler of the property generator of the wrapper class. <br>  Generally speaking, the default constructor can be declared below in <b>.def (init &lt;&gt; ())</b> , some do so, for consistency with other constructors with parameters described separately, also passing <b>no_init</b> to the constructor of the wrapper pattern.  There is also the option of replacing the default constructor with a constructor with parameters right when declaring a wrapper class, as we have already done for the Config structure. <br>  With the third point, everything is generally simple, declaring that the static method deals with <b>.staticmethod ()</b> after declaring all the overloads of this method through <b>.def ()</b> . <br>  In general, the rest no longer raises any questions and is familiar to us from the first part, except for one funny little thing - the policy of returning the value of return_value_policy &lt;reference_existing_object&gt;, about it further. <br><br><h4>  The policy "do not hit me, I am a translator" </h4><br>  The greatest difficulty in wrapping the methods of our singleton was caused by the return of an object reference from the method <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Config&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>  Just to ensure that the Python interpreter's Garbage Collector (GC) does not remove the contents of the class field returned by reference from the method, we use <b>return_value_policy &lt;reference_existing_object&gt;</b> . <br>  The magic of Boost.Python is so severe that when executing Python code, changing the result fields of AppConfig () will lead to changes in the Singleton field as if it were happening in C ++!  By running the following code from the Python command line: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * Single.AppConfig().coef = <span class="hljs-number"><span class="hljs-number">123.45</span></span> Single.AppConfig()</code> </pre><br>  We get the output: <br><pre> <code class="python hljs">Config: { coef: <span class="hljs-number"><span class="hljs-number">123.45</span></span>, path: <span class="hljs-string"><span class="hljs-string">'.'</span></span>, max_size: <span class="hljs-number"><span class="hljs-number">4096</span></span> }</code> </pre><br><br><h4>  Add a property with a policy for the get method </h4><br>  Probably all have already noticed that I like to overload the method or the other in the example, so that the ad is as furious as possible.  For the convenience of using the Single class in Python, we now add properties for reading the counter and for getting and setting configuration parameters, since all the methods for this are already there. <br><pre> <code class="cpp hljs"> .add_static_property( <span class="hljs-string"><span class="hljs-string">"current_id"</span></span>, &amp;Single::CurrentID ) .add_static_property( <span class="hljs-string"><span class="hljs-string">"app_config"</span></span>, make_function( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; Config&amp; (*)() &gt;( &amp;Single::AppConfig ), return_value_policy&lt;reference_existing_object&gt;() ), <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*)( Config <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; ) &gt;( &amp;Single::AppConfig ) )</code> </pre><br>  The Single :: CurrentID method is wrapped in the <b>current_id</b> property one-two times, but see what a ‚Äúbeautiful‚Äù wrapper is for the two Single :: AppConfig overloads, respectively, the get and set methods of the <b>app_config</b> property.  And pay attention, for the get-method, we had to use the special function <b>make_function</b> in order to hang the return value policy <b>return_value_policy &lt;reference_existing_object&gt;</b> . <br>  Be very careful, you cannot use the function <b>make_getter</b> for methods, it is used only for C ++ class fields, methods need to be used as is.  If you need to set the return value policy for one of the property methods in one of the methods, you need to use <b>make_function</b> .  You no longer have an auxiliary additional argument for <b>return_value_policy,</b> as in <b>.def</b> , so you have to pass both the function and the return value policy with one argument. <br><br><h4>  Policy "here is a new object - delete it" </h4><br>  So, we have already figured out how not to let GC Python delete an object returned by reference.  However, it is sometimes required to transfer a new object to the python for storage.  GC will correctly remove the object as soon <s>as the</s> last variable dies <s>in torment</s> , referring to your result.  For this there is a policy <b>return_value_policy &lt;manage_new_object&gt;</b> . <br>  Let's get a method cloning configuration parameters to a new object.  Add a declaration to wrap.h: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Config* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Single_CloneAppConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br>  And in wrap.cpp we add its implementation: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Config* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Single_CloneAppConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Config( Single::AppConfig() ); }</code> </pre><br>  In the wrapper of the class Single, respectively, a new method will appear with the manage_new_object policy: <br><pre> <code class="cpp hljs"> .def( <span class="hljs-string"><span class="hljs-string">"CloneAppConfig"</span></span>, Single_CloneAppConfig, return_value_policy&lt;manage_new_object&gt;() )</code> </pre><br>  To check that Config is really deleted when necessary, we will declare the destructor in a completely not C-style Config structure.  In the destructor, we simply output the fields of the Config instance to delete in STDOUT via std :: cout: <br><pre> <code class="cpp hljs">Config::~Config() { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Config destructor of Config: { coef: "</span></span> &lt;&lt; coef &lt;&lt; <span class="hljs-string"><span class="hljs-string">", path: '"</span></span> &lt;&lt; path &lt;&lt; <span class="hljs-string"><span class="hljs-string">"', max_size: "</span></span> &lt;&lt; max_size &lt;&lt; <span class="hljs-string"><span class="hljs-string">" }"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  We try! <br>  In the test script in Python 3.x, we clone the configs, change them differently and reset all links to the object created via <b>CloneAppConfig ()</b> : <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * c = Single.CloneAppConfig() c.coef = <span class="hljs-number"><span class="hljs-number">11.11</span></span>; c.path = <span class="hljs-string"><span class="hljs-string">'cloned'</span></span>; c.max_size = <span class="hljs-number"><span class="hljs-number">111111</span></span> print( <span class="hljs-string"><span class="hljs-string">"c.coef = 12.34; c.path = 'cloned'; c.max_size = 100500"</span></span> ) print( <span class="hljs-string"><span class="hljs-string">"c:"</span></span>, c ); print( <span class="hljs-string"><span class="hljs-string">"Single.AppConfig():"</span></span>, Single.AppConfig() ) print( <span class="hljs-string"><span class="hljs-string">"c = Single.CloneAppConfig()"</span></span> ); c = Single.CloneAppConfig() c.coef = <span class="hljs-number"><span class="hljs-number">22.22</span></span>; c.path = <span class="hljs-string"><span class="hljs-string">'another'</span></span>; c.max_size = <span class="hljs-number"><span class="hljs-number">222222</span></span> print( <span class="hljs-string"><span class="hljs-string">"c.coef = 22.22; c.path = 'another'; c.max_size = 222222"</span></span> ) print( <span class="hljs-string"><span class="hljs-string">"c:"</span></span>, c ); print( <span class="hljs-string"><span class="hljs-string">"Single.app_config:"</span></span>, Single.app_config ) print( <span class="hljs-string"><span class="hljs-string">"c = None"</span></span> ); c = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> print( <span class="hljs-string"><span class="hljs-string">"Single.app_config:"</span></span>, Single.app_config )</code> </pre><br>  Destructors are called exactly when it is expected, when the last link to the object disappears. <br>  This is what should appear on the screen: <br><pre> <code class="python hljs">c.coef = <span class="hljs-number"><span class="hljs-number">12.34</span></span>; c.path = <span class="hljs-string"><span class="hljs-string">'cloned'</span></span>; c.max_size = <span class="hljs-number"><span class="hljs-number">100500</span></span> c: { coef: <span class="hljs-number"><span class="hljs-number">11.11</span></span>, path: <span class="hljs-string"><span class="hljs-string">'cloned'</span></span>, max_size: <span class="hljs-number"><span class="hljs-number">111111</span></span> } Single.AppConfig(): { coef: <span class="hljs-number"><span class="hljs-number">2.5</span></span>, path: <span class="hljs-string"><span class="hljs-string">'.'</span></span>, max_size: <span class="hljs-number"><span class="hljs-number">4096</span></span> } c = Single.CloneAppConfig() Config::~Config() destructor of object: { coef: <span class="hljs-number"><span class="hljs-number">11.11</span></span>, path: <span class="hljs-string"><span class="hljs-string">'cloned'</span></span>, max_size: <span class="hljs-number"><span class="hljs-number">111111</span></span> } c.coef = <span class="hljs-number"><span class="hljs-number">22.22</span></span>; c.path = <span class="hljs-string"><span class="hljs-string">'another'</span></span>; c.max_size = <span class="hljs-number"><span class="hljs-number">222222</span></span> c: { coef: <span class="hljs-number"><span class="hljs-number">22.22</span></span>, path: <span class="hljs-string"><span class="hljs-string">'another'</span></span>, max_size: <span class="hljs-number"><span class="hljs-number">222222</span></span> } Single.app_config: { coef: <span class="hljs-number"><span class="hljs-number">2.5</span></span>, path: <span class="hljs-string"><span class="hljs-string">'.'</span></span>, max_size: <span class="hljs-number"><span class="hljs-number">4096</span></span> } c = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> Config::~Config() destructor of object: { coef: <span class="hljs-number"><span class="hljs-number">22.22</span></span>, path: <span class="hljs-string"><span class="hljs-string">'another'</span></span>, max_size: <span class="hljs-number"><span class="hljs-number">222222</span></span> } Single.app_config: { coef: <span class="hljs-number"><span class="hljs-number">2.5</span></span>, path: <span class="hljs-string"><span class="hljs-string">'.'</span></span>, max_size: <span class="hljs-number"><span class="hljs-number">4096</span></span> } Config::~Config() destructor of object: { coef: <span class="hljs-number"><span class="hljs-number">2.5</span></span>, path: <span class="hljs-string"><span class="hljs-string">'.'</span></span>, max_size: <span class="hljs-number"><span class="hljs-number">4096</span></span> }</code> </pre><br>  As a home task, try to add the __del__ method to the Config wrapper - an analogue of the destructor in Python, you will see how the wrappers behave and the objects they refer to. <br><br><h4>  In conclusion of the second part </h4><br>  So, we got acquainted in practice with two new return value policies by reference: <b>reference_existing_object</b> and <b>manage_new_object</b> .  That is, they learned how to use the wrapper object of the return value as a link to an existing C ++ object, and also to transfer to GC Python the new objects created in C ++. <br>  Understood in brief how to act if the default class constructors in C ++ are subject to restrictions.  This is relevant not only in the case of a singleton or abstract class, but also for many specific classes, examples of which are probably before you now. <br>  In the third part, we are waiting for a simple enum wrapper, we will write our converter for the byte array from C ++ to Python and back, and also learn how to use the inheritance of C ++ classes at the level of their wrappers. <br>  Next, we are waiting for the magical world of converting exceptions from C ++ to Python and back. <br>  What will happen next while I won‚Äôt guess, the topic is unwinding like a tangle: so small and compact, until you start unwinding it ... <br>  Link to the project of the 2nd part can be found <a href="http://www.megafileupload.com/en/file/390402/example-part2-7z.html">here</a> .  The MSVS v11 project is configured to build with Python 3.3 x64. <br><br><h4>  useful links </h4><br>  <a href="http://www.boost.org/doc/libs/1_52_0/libs/python/doc/">Boost.Python Documentation</a> <br>  <a href="http://wiki.python.org/moin/boost.python/class">Constructor wrapper class boost :: python :: class_</a> <a href="http://wiki.python.org/moin/boost.python/class"><br></a>  <a href="http://wiki.python.org/moin/boost.python/CallPolicy">Policies return values ‚Äã‚Äãby reference in Boost.Python</a> <br>  <a href="http://www.boost.org/doc/libs/1_52_0/more/getting_started/windows.html">Getting Started with Boost for Windows</a> <br>  <a href="http://www.boost.org/doc/libs/1_52_0/more/getting_started/unix-variants.html">Getting started with Boost for * nix</a> <br>  <a href="http://www.boost.org/doc/libs/1_52_0/libs/python/doc/building.html">Boost.Python build subtleties</a> </div><p>Source: <a href="https://habr.com/ru/post/168233/">https://habr.com/ru/post/168233/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../168217/index.html">"Debriefing" - Episode 33 - Special: Moscow voyage of the Amazon</a></li>
<li><a href="../168219/index.html">How to start flying on your own, without risking your life</a></li>
<li><a href="../168221/index.html">LitRes.ru is trying to "squeeze" the business of the authors of the application "reader"</a></li>
<li><a href="../168223/index.html">Eclipse for Java Developers. Navigation and editing</a></li>
<li><a href="../168225/index.html">Innovations node-webkit version 0.4.1</a></li>
<li><a href="../168239/index.html">Berners-Lee: No Root? Your device serves others</a></li>
<li><a href="../168241/index.html">The helicopter weighing 16 grams entered service with the British army.</a></li>
<li><a href="../168249/index.html">Backup to "Cloud Storage"</a></li>
<li><a href="../168251/index.html">An overview of image compression tools</a></li>
<li><a href="../168253/index.html">For IBShnikov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>