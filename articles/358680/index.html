<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Troubleshooting Node.js Applications Under the Hood</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since the advent of Node.js, diagnostics has been improved in several stages, from debugging applications to in-depth performance analysis. This time ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Troubleshooting Node.js Applications Under the Hood</h1><div class="post__text post__text-html js-mediator-article">  Since the advent of Node.js, diagnostics has been improved in several stages, from debugging applications to in-depth performance analysis.  This time we will discuss strategies for using tools such as core dump debuggers, flame graphs, production errors and memory leaks. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_qzFJ2MPVWQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The material is based on the interpretation of the report by Nikolai Matvienko from Grid Dynamics from our December conference HolyJS 2017 Moscow. <br><a name="habracut"></a><br>  To understand at what stage of the evolution of diagnostic tools we are now, I propose to turn to history.  On the timeline, I depicted the most significant moments. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/587/cd0/05e/587cd005ed70ae0c85603e9ff6667288.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First, such tools as DTrace, Instruments, perf were published - these are system profilers that appeared long before Node.js, and they are still used today.  With the advent of Node.js, Node-oriented tools come to us - here we should highlight node inspector, node-heapdump, node-memwatch.  I marked this period gray and conditionally call it a troubled time.  You remember that there was a split in the community: at that time, io.js separated from Node.js, and the community did not have a common understanding of where to go and whom to choose.  But in 2015, io.js and Node.js merged, and we saw Node.js v4 Argon.  The community has a clear development vector, and Node.js in production began to use such large companies as Amazon, Netflix, Alibaba. <br><br>  And here, effective tools that are ready to work in production become popular. <br><br>  Since 2017, I conditionally single out the third stage. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02b/fdd/cef/02bfddceff066f336591c464c5edbd69.png"><br><br>  From this point on, Node.js has been developing qualitatively.  It is worth noting the full transition to Turbofan and the development of Async Hooks. <br><br>  In 2015, we launched the release on the Node.js 0.12 version and gradually updated first to the fourth version and subsequently to the sixth one.  Now we are planning to move to the eighth version. <br><br>  In the release year, we used tools from the first stage, which were low-functional for work in production.  We have a good experience with the tools of the second stage, and now we use the tools of the third stage.  But with the transition to new versions of Node.js, we are faced with the fact that we are losing the support of useful tools.  In fact, we had a choice.  Either we are switching to a new version of Node.js, which is more optimized and faster than the previous one, but we do not have the tools, and we cannot diagnose it.  Either we stay on the old version of Node.js, which is slower, but we have the tools for it, and we know its weak points.  Or there is a third option, when new tools appear, and they support, for example, Node v4 and higher, and the previous ones do not. <br><br>  Our application is a large e-commerce project where Node.js applications (these are Web UI backend and Node.js microservices) occupy a central place in the enterprise architecture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e19/a05/ba8/e19a05ba8a1dafa9bee49e36607fbb52.png"><br><br>  The problem in this place can come from any side.  In the days of high loads, such as Black Friday, when a company earns 60% of its annual profit over several days, it is especially important to maintain high throughput.  If some kind of malfunction happens, a local consultation is held, where all the heads of the systems are present, including me from Node.js.  If the problem is on the side of Node.js, you need to quickly select a strategy, pick up the tools for it and fix the problem, because the company is losing thousands of dollars a minute. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/169/7e8/3cb/1697e83cbaf412bfa57eea50c13a3e18.png"><br><br>  Below, I would like to use concrete examples to show how we in production act in cases of errors, memory leaks and a drop in performance. <br><br><h2>  Debugging Production Applications </h2><br>  There are several prompts for debugging in production. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/667/242/10c/66724210ca186bdfa071afc863590bd9.png"><br>  Consider a simple example: a service for backing up products.  The controller uses service, which sends a collection of products to the REST API, returns data, and an error is thrown to the controller. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a8e/c11/37b/a8ec1137b543fb1c58fd47a6e992e510.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/790/774/ef1/790774ef1b2366f881c68d9ca93abcaf.png"><br><br>  In the picture you see the listing of ProductController.  In the reserve method we get the profile from cookies, also take a rewards account where bonus points, id and other useful information are stored, also from cookies.  And this cookie is missing - undefined.  In the case when id is taken from rewards, the error falls.  Locally, we would set a breakpoint (red dot), get the status of all objects and find out the reason why the code falls. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ec/171/3f9/7ec1713f9966cacfc00a85f5629e712a.png"><br><br>  I'll show you how it works under the hood so that you understand what a stack track is.  If you write the% DebugTrace () command, the native V8 command, and run Node.js with the --allow-natives-syntax option, that is, enable the native syntax in V8, you will get a big message from Stack Trace. <br><br>  At the very top in the second frame we will have the reserve function before the controller method, and we will see there a link to the ProductController context - this, the request, response parameters, we will get local variables, some of which are stored on the stack, and the other in Heap (managed heap ).  We also have the source code, and it would be nice to have something similar in production when debugging to get the state of the objects. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/356/ce7/529/356ce75297234f5d9ba9fea9e115b031.png"><br><br>  This support was implemented in 2015 from version 0.12.  If we run Node with the --abort-on-uncaught-exception flag, a core dump will be created - this is the memory snapshot of the whole process, which contains the Stack Trace and Heap Dump. <br><br>  For those who have forgotten, I remind you: the memory conditionally consists of Call Stack and Heap. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/328/c66/015/328c660156fc3545875026429c2be9b7.png"><br><br>  In Call Stack, yellow bricks are frames.  They contain functions, and the function contains input parameters, local variables, and a return address.  And all objects except small integer (SMI) are stored in a managed heap, for which there are addresses. <br><br>  We figured out what the core dump consists of, now let's move on to the process of its creation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/002/71d/910/00271d9105b8a833150d66aeafbd362a.png"><br><br>  Everything is simple: the process of your application is executed, an error occurs, the process crashes, a core dump is created, then the application is restarted.  Then you connect to production remotely or pull this core dump to your local computer, debug it, make a hot-fix and publish it.  Now that we understand what this process looks like, we need to know which debuggers can be used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/928/7df/cb79287df88bf158fe8f03e8ed1727d0.png"><br><br>  They all appeared before the Node.js.  In order to read the JS Stack Trace, several plug-ins have been written to them at different times.  Most of them are already outdated and not supported by the latest version of Node.js.  I tried almost everything and in this report I want to highlight llnode.  It is cross-platform (except for Windows), it works with the latest versions of Node.js, starting with the fourth.  I will show how you can use this debugger to debug errors in production. <br><br>  Consider the example described above - product reservations. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd3/316/a8c/cd3316a8c286568c5db87c0e725a9b70.png"><br><br>  Set up the environment, set the possibility of creating a core dump, and launch our Node application with the --abort-on-uncaught-flag flag.  Next, we get the process pid, we make a request to the user who does not have cookies reward, and we receive a message that the error appeared in the ProductController in the reserve method. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d5/b13/f4c/9d5b13f4cc2c847e2ef4599c0eb88c28.png"><br><br>  Next, we get the message that the core dump was created - a memory cast.  Having received a core dump or access to it, we check its availability - it weighs 1.3 GB.  A lot. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e86/6df/5bc/e866df5bc6abef520c9f5dafbb8855e7.png"><br><br>  Run this core dump with a debugger using the llnode command, we can get the Stack Trace using the bt command. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a3/b1a/c57/2a3b1ac5750d937c9560583d7cc8cd2c.png"><br><br>  The image shows (above and below - in more detail) that there is no information in frames 4 through 20. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8db/ec5/411/8dbec5411d58ef9bd6547f0f3667380d.png"><br><br>  The fact is that this is JS Stack Trace, which C ++ debuggers cannot read.  In order to read it, just use the plugin. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a4/f6a/1a6/7a4f6a1a6dcda1937b183ecbeec3c0ad.png"><br><br>  By running the V8 bt command, we get the JS Stack Trace, where in the sixth frame we will see the reserve function.  In the frame there is a link to the context of this ProductController, parameters: IncomingMessage - Request, ServerResponse and blue is the address of the function in memory.  At this address, we can get its source code from core dump. <br><br>  Next, we write the command v8 inspect --print-source [address] and get the source code of our function from memory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e9/043/c12/3e9043c127b1ecb410f058454cd5994a.png"><br><br>  Let's go back to the Stack Trace, there were the request and response parameters, and find out what was in the request. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8d/1c8/d71/e8d1c8d71df3f78f660f18cab3a567d4.png"><br><br>  In the image we see the v8 inspect command with the address.  After it is executed, we get the status of the request object.  Here we are interested in the cookies property, url, POST method and body.  Find out what products were transferred to the server. <br><br>  Let's write the command v8 inspect [address of the body]. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c41/b78/404/c41b78404243ca116425a0ae3f0e9bca.png"><br><br>  We get an object in which the array consists of three elements in the products property.  We take its address, we inspect and we receive an array from id. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/837/d9a/598/837d9a598d51660be4b025c7ad57a269.png"><br><br>  There is no problem here.  Let's see what was in the req.cookies object. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/9b3/f1e/ab49b3f1ed649936cc16868f8d3d956f.png"><br><br>  This is an object of two properties: profile and rewards - undefined.  Find out which user has no rewards account. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7dd/37e/794/7dd37e794a597cda431d3756e478310f.png"><br><br>  Let's write the v8 inspect command [profile address] and get its id and storeid.  Thus, we managed to get the source code in production without source code and restore the user session. <br><br>  Here was a very convenient case, and if you use a framework that contains ErrorHandler Middleware, then unlike the previous example, where we had links from Stack Trace to the context of this, request, response, if ErrorHandler is not rewritten, then you in Stack Trace there will be the last calls of Express itself and it will not work with anything.  You will not have links. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c77/b09/487/c77b094870da8f3fb297add984bf82b3.png"><br><br>  I will give an example of how this happens. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25d/9b7/a17/25d9b7a1738b4e981033e14eeb3f6378.png"><br><br>  The same example with the reserve method, but the error already falls deep in the service, which operates in asynchronous mode.  In order to catch it, let's subscribe to the events of the unhadledRejection process, where we do process.abort () to create a core dump. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a0/6eb/4e9/0a06eb4e9d34d816bb9b70d050264f35.png"><br><br>  Below is what the backtrace looks like in this case. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/258/e01/9dc/258e019dc6a3aa232b9d1acd6d6f0582.png"><br><br>  There is no information about ProductController, about reserve.  There is a process.on call in this frame and nothing more useful.  Such cases happen in production when the error was not intercepted and there is no information in Stack Trace.  Next, I will show how, by working only with a managed heap without Stack Trace, to find all the objects. <br><br>  We can get all instances of an object by type IncomingMessage.  This will be a large list of all requests that have been submitted, but we need to find the one that caused the process to fail. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed2/df1/632/ed2df163236d93b02b3c5590bab70506.png"><br><br>  In this case, we will need logs and we need to get the id request in them - this is the X-Transaction-ID. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/613/cc2/cc9/613cc2cc97884d5ae990213f5189fc12.png"><br><br>  In llnode there is a possibility in memory by the value of a string to find links that refer to it.  If we write the v8 findrefs --string [string value] command, we will find an object that has the X-Transaction-ID property, and it refers to this string.  Find out what kind of object. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/44e/d9f/c3944ed9f4cdf92e5566e9a046bde366.png"><br><br>  We write the command v8 inspect [address], after which we get the headers object.  Further we learn that refers to this object, and we receive object IncommingMessage.  Thus, without having Stack Trace and addresses, we were able to restore the user session. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16e/e75/b50/16ee75b506f8cc9538ff17b8a6a3ce04.png"><br><br>  Let's dive into a more complex example when you need to get local variables - they are in services.  Suppose that the error has fallen somewhere deep and the data received are few.  In this case, the REST API is used.  Objects are taken from the database, and all of them are assigned to some local variable called someLocalValue.  And we don't have an object that refers to someLocalValue.  How, then, to get a local variable from memory?  You can find this object, for example, by the value of id, if you received it from the logs, but you can also get objects from the memory by the name of its properties, i.e.  With the v8 findrefs name command, we can find objects that have a userAccount property, preferredStore, and in this way we will get the local variables we need! <br><br>  So, we will undertake a real case - errors in production. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14e/d53/25f/14ed5325f01d52972f165258ba0cf3aa.png"><br><br>  For every error we create a core dump.  But what is wrong here?  There are a lot of errors - 3620 per minute, and the core dump weighs 1.3 GB, and the time it takes to create and merge it onto the system is about 15-20 seconds.  There is clearly not enough logic to select the creation of core dump. <br><br>  For example, your application is running and an error occurs, or you catch an error that is difficult for you to reproduce.  Then the process goes to ErrorHandler, where you have logic - is it necessary to do process.abort for this error in order to create a core dump, or we continue the execution of the program. <br><br>  If the error is unique and needs to be processed, a report is created using node-report, then process.abort is called and a core dump is created, and the process is restarted.  Your server works again, serves the traffic, and later you get access to the report, core dump and logs, then debug with the help of the debugger, make a hotfix and publish. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ccf/d56/4bf/ccfd564bf29996bbd7c6358b3b569b9d.png"><br><br>  The image below shows an example of logic that makes selection.  I call it the registry of errors.  It restricts the creation of core dump. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4da/be7/ad4/4dabe7ad4cd42a1bd47f0c21182e50e4.png"><br><br>  This is some class that uses In-Memory Databases, and when you find an error, check if it is registered in the registry or not.  If not, see if you need to register it.  If yes, then reset the process, create a core dump.  In this case, you will not create a core dump for errors that repeat.  You will select them.  This will speed up the debugging process. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ba/dff/a0b/4badffa0b2d20d8461d8399b349053d1.png"><br><br>  I believe that the debugging process in production is a kind of detective investigation, where a node-report will tell you what happened, where and under what circumstances a crime was committed against your JS Stack Trace process.  Logs will give you clues, evidence, valuable information.  The debugger will allow you to find objects that took place at the time of the crime, that is, in these functions. <br><br>  This is how we work in production and debug errors. <br><br><h2>  Memory leak detection </h2><br>  Let's look for a memory leak. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/62c/cef/6bb/62ccef6bb9416dd63ad79c37946c138b.png"><br><br>  There are many ways to detect memory leaks (some are mentioned in the image above). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/1f2/9ae/4ea1f29ae71f7ae2c00273fbcdfb16a1.png"><br><br>  For example, in the graphs of CPU and memory load, you can notice a certain correlation.  And in situations where you have a memory leak, the garbage collector is loaded, which takes up more CPU time. <br><br>  Consider an example of a leak. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b8/1b5/7ff/3b81b57ffd088c7e79f001b722fad6b2.png"><br><br>  The image above shows the work schedule of the garbage collector.  Scavenge - works in the space of young objects.  MarkSweep - in the space of old objects.  The graph shows that the number of garbage collections is growing, which means that the memory is leaking and more frequent garbage collection is needed.  To understand where and in which space it is leaking, we use the tracing of the garbage collector. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15f/3b0/4c7/15f3b04c757f4c04ee195725cd1b2be6.png"><br><br>  In the image above, a list of memory areas is visible, which displays their states at each iteration of the garbage collection.  There is old space, new space and others.  When we got the source code from the core dump, we took it from the code space. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ea/20e/884/6ea20e884fe7a2ac04ecd2ceb4d38076.png"><br><br>  From experience, I can say that if memory leaks in the space of new objects, then expensive cloning operations, merge, and so on are to blame for this.  If the memory is flowing in a large space of old objects, then these are the missing circuits, timers.  And if the memory leaks in large space, where the garbage collector does not work, then this is serialization / deserialization of large JSON. <br><br>  The image below shows an example of Scavenge tracing, which works in the field of young objects.  There is no memory leak. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06a/c0a/2e2/06ac0a2e2331f71aa4c1ceaf6e72d4bf.png"><br><br>  How can you find out?  We have two bars in bold green text.  This memory, which was allocated to your process before assembly and after assembly.  Values ‚Äã‚Äãare equal, and this suggests that the allocated memory did not increase after garbage collection.  The blue font indicates the time spent on garbage collection.  The documentation states that this requires 1 millisecond by default.  In our project it is about 3 seconds, and we consider this the norm.  In the upper image below you can see three lines, this is also a garbage collection, but already iterative, that is, you have not all memory scanned and cleared, but in pieces.  It also shows the number of iterations. <br><br>  The image below shows an example of a memory leak in the same space.  In the purple columns, it is clear that the amount of memory occupied increases, that is, after garbage collection, it increases every time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ca/ccd/605/7caccd605393388d40355a7c6320e34e.png"><br><br>  How are things in the space of old objects? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54b/269/163/54b269163db81230861d6501cd21afd4.png"><br><br>  Here we see that the process takes longer: 90ms, 110ms, etc.  This is a lot.  Moreover, it is executed still iteratively, which also takes time in the background thread. <br><br>  Under the hood, Node.js has several threads.  One for profiling, several for garbage collection, and a thread for executing the application itself. <br><br>  Consider the example below to figure out how to detect memory leaks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e2/e75/d4b/3e2e75d4b70a3cf023ca817a4d8e9db9.png"><br><br>  Notice that the Middleware, which processes the request, records the start time of the execution at the beginning, and when the request has ended, it records the time after the execution, where some function for its processing is called ‚Äî someProcessOperation.  In this function, we pass the request.  There is a closure here.  The request object is retained after it is sent.  And there may be other links to it, which draws many objects.  What to do in this case?  We do not need the entire request object.  We can transfer only its id and url.  This way we avoid memory leaks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/377/59e/693/37759e693389f0432b7b94f0fd7cc573.png"><br><br>  How can you find out? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/839/717/a30/839717a302478ee88844b34c0dfef5a6.png"><br><br>  I'll show you how we do it with the llnode debugger (in the case of Fatall Error, when after the crash of the application due to lack of memory, Node.js will create coredump).  In the previous case, we received a core dump, when we had an exception and the process ended.  This time, of course, we did not call process.abort () on a running application to get a core dump, but armed with the gcore tool, which allows you to query the process id at the infrastructure level and get a core dump on demand.  However, here we are faced with an infrastructural constraint, which is why we had to look for other options. <br><br>  A month ago, a library called gen-core was published.  This tool allows you to fork your process, kill it without harming your main process, and get a core dump. <br><br>  The image below shows an example of gen-core operation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9bd/2de/c13/9bd2dec133b2d86e376f9c9a7dcd0443.png"><br><br>  Here, the DiagnosticController by REST API can make a core dump. <br><br><h2>  How to find memory leaks using llnode </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/4ee/2b4/2f7/4ee2b42f7477d3ca54fe2d6e59c6c755.png"><br><br>  We have the findjsobjects command, with which we can scan the entire heap and group them by type, get a report on the number of instances of each type of object, their size in memory, etc.  The image above shows that there are a lot of ServerResponse and IncomingMessage instances, there are also Timeout and String objects.  The strings themselves are very large and take up a lot of memory.  Often they are in the large space where the garbage collector does not work. <br><br>  Let's find out why we have a lot of request objects.  Remember that the request object was held in Middleware. <br><br>  There is a command findjsinstances [type], and with its help we get a list of request objects. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/97f/77b/f28/97f77bf2811c70b0a19b4c62d7eff3d9.png"><br><br>  We take the address of the first object and with the help of the v8 command findrefs -v we look for an object in memory that has a link to it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18c/a45/9d3/18ca459d3d65ef95945716ca1d4bcace.png"><br><br>  These are two objects.  The first is an array of 18 elements, and the second is the request object.  We find out what this array is and why it holds our request objects. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bae/b3e/76a/baeb3e76a5be0c2204cc166b1c4df23d.png"><br><br>  Use the v8 command findrefs -v [address of this array] and find that this array is in an object of type Profiller and the property processingQueue.  In this way, we were able to find out where our request objects hold in memory.  Next we go to the source code or get it from there and see where the processingQueue is called. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e78/e03/fc1/e78e03fc13f0fd6a06491dd6cbe2f2ed.png"><br><br>  We use the command findjsinstances [type Timeout], get a list of all timeouts and then we will look for where they are used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ee/989/1ab/4ee9891abf4c08ffb2320579d982fb9e.png"><br><br>  With the help of the command v8 i we get the first timeout. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9d/c52/9f3/c9dc529f318783a20dfe7c5c6ea2156f.png"><br><br>  In the onTimeout property, we can see that the setInterval function is called and the address where the file is located.  In this way, we quickly learned where the forgotten timer is and why it is executed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea2/45f/83a/ea245f83ad76d594fe55305b603c26c2.png"><br><br><h2>  How to detect memory leak at the design stage of the application </h2><br>  If you use the% DebugTrackRetainingPath (x) command, which was added recently to V8 (Node.js does not yet have its support), download the V8 sources, compile and use the V8 debugger, and run the above in the JS image, we will get any links variable to the root object.  Do not forget to call the garbage collector.  In the example, this is a call to gc (). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/381/e74/b81/381e74b81f15cec011280687aa50c09a.png"><br><br>  We run debug8 with the --allow-natives-syntax, --track-retaining-path, --expose-gc flags and the test.js file.  In the listing, we get step by step who and what holds the object up to root. <br><br>  Thus, we disassembled the search for memory leaks in production. <br><br><h2>  Application performance profiling </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/397/c54/ff7/397c54ff720f9478c6b7978165d1a712.png"><br>  In the image above, you see a real-life example, when, after the next release, we lost five times the performance.  The upload time of the Web UI application has increased dramatically. <br><br>  For such cases there is a simple and effective algorithm of actions, which is demonstrated below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7fc/22e/14f/7fc22e14f48a7433b84929b0767f3c63.png"><br><br>  Although a profiler was added to Node.js in 2013, the tick-processor (a tool that processes V8 logs and reports) appeared only last year.  Before that, we used either the V8 profiler, which had a tick-processor in it, or we had to download the V8 itself, build it, and activate the processor there in the tools. <br><br>  The profiler gives you information at a high level, he will help determine the nature of the problem and see which functions have been performed the longest. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c0/25a/e67/6c025ae67f675c99cf66e4409843f371.png"><br><br>  There is a convenient presentation of this log data in graphical form, and it is called flame graph.  Designed it in 2013 by Brendan Gregg. <br><br>  Who remembers, in 2015 the receipt of the graph was a real headache, but now it is created by one team using 0x. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c4/41f/bfd/3c441fbfdb6e9b7bc7b3a09a339c5490.png"><br><br>  Now let's figure out how to work with him. <br><br>  To select the profile of our application, remove all unnecessary with the bottom buttons.  As a result, we see that the work of the application takes only a small part of the total execution time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86c/ee7/754/86cee77543c3aacb575c8b279e7a5268.png"><br><br>  The stack trace of the function call sequence is finite and fits on the screen.  What then takes a long time?  If we turn on the highlight of the work of npm packages, we will see that they run nine times longer than the application itself.  This is a lot. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52c/fcc/755/52cfcc755dc1416868116581c5c4799d.png"><br><br>  If we highlight the optimized functions, we will see that there are very few of them.  About 90% of calls were not optimized. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f9c/222/38b/f9c22238bf23b7c457c9b5cc917d2fa6.png"><br><br>  If we look at the tops of the calls, we will see that in our application a lot of the stack was in the handlebars, in addition we had lodash merge, which did merge objects, we had third-party utilities, which also took time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae8/0af/bb5/ae80afbb5b989a4a93617e3a837ba030.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we analyze the same graph of our application, we will see that the foundation is based on native promis, which took a long time to complete before Turbofan. </font><font style="vertical-align: inherit;">But most of all, it takes page rendering. </font><font style="vertical-align: inherit;">Our application as a percentage is one-tenth of all logic. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/398/430/ff1/398430ff181d3bfca7ac3b5c8224efe0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What have we fixed?</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reducing CPU costly operations: merge, JSON, string parse </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Removing logic from view templates </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Review npm dependencies and update packages </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Node.js update (V8 optimization killers bypass) - in progress </font></font><br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is a graph that we see after the corrections. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2c/328/1c0/c2c3281c0896dd5b2afcafad7d325500.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you should pay attention to the right side, where the handlebars helpers. Previously, the view view took up more than half of the graph, and now it is one tenth. We optimized everything fairly well, and now the work of the application itself takes about half of the total time. This does not mean that it began to work longer - all other processes began to work less in time. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a7/6e2/bfb/5a76e2bfbb87a6dd8d03d064668027d2.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The image above shows that at the stage before the release of the critical release, the graph grew, and we gradually lost in productivity. Then there was a sharp jump. In the critical period, we were 3.5 weeks and searched for shortcomings, made changes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The essence of the problem was that the error (parsing JSON lines) was laid in the application long before this release, and only fired at a certain moment. </font><font style="vertical-align: inherit;">In the end, after all the fixes and optimizations, we won in performance twice, if we take the initial level as a starting point.</font></font><br><br><h2>  Conclusion </h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Performance must be part of the requirements </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Need to make measurements when implementing third-party libraries </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Measurement should be done on staging / pre-production environments </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Need to collect archive of measurement results </font></font><br></li></ul><br><br> <i><a href="https://github.com/nickkooper/nodejs-diagnostics-resources"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resources used in the report</font></font></a></i> <br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We hope you find the experience of Nikolai useful. </font><font style="vertical-align: inherit;">By the way, this Saturday </font></font><a href="https://holyjs-piter.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HolyJS 2018 Piter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> starts </font><font style="vertical-align: inherit;">, where Nikolay will tell about the </font></font><a href="https://holyjs-piter.ru/talks/4nd6jfohg8egu4iaemweco/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decomposition of the Main Thread in Node.js to increase throughput</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">And if you like the wrong side of JS, you might also be interested in the following reports:</font></font><br><br><ul><li> <a href="https://holyjs-piter.ru/talks/11q1jiaid6uoeuieqqa4mk/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RxJS: performance and memory leaks in a large application</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Evgeny Pozdnyakov, Exadel)</font></font><br></li><li> <a href="https://holyjs-piter.ru/talks/2r1yg7w0no4ekomossmq8k/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New adventures in frontend, Season 2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Vitaly Friedman, Smashing Magazine)</font></font><br></li><li> <a href="https://holyjs-piter.ru/talks/2tmryuscgwykqms0ouqees/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meinim crypt in the browser: WebWorkers, GPU, WebAssembly and other good things</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Denis Radin, Evolution Gaming)</font></font><br></li><li> <a href="https://holyjs-piter.ru/talks/4vxicrybq84iyqiwkigyko/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debugging JS on the example of Chrome DevTools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Alexey Kozyatinsky, Google)</font></font><br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/358680/">https://habr.com/ru/post/358680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358670/index.html">Laser hair removal for a virtual server</a></li>
<li><a href="../358672/index.html">Why you should stop using grocery roadmap and try GIST</a></li>
<li><a href="../358674/index.html">Javier Mertens: ‚ÄúCryptojacking is one of the most brilliant attacks I've seen.‚Äù</a></li>
<li><a href="../358676/index.html">Mathematical modeling haboo-future</a></li>
<li><a href="../358678/index.html">FAS rendered YouTube and torrents from Russian jurisdiction</a></li>
<li><a href="../358682/index.html">ARM MBED OS. Work with arbitrary MK STM32 under PlatformIO</a></li>
<li><a href="../358686/index.html">Megafon ordered the Kupol storage complex to store traffic according to the law of Spring</a></li>
<li><a href="../358688/index.html">ESET discovered two 0-day vulnerabilities in Adobe Reader and Microsoft Windows</a></li>
<li><a href="../358690/index.html">We pack in containers, deploy, monitor - the program Root Conf</a></li>
<li><a href="../358692/index.html">Selection: 6 open frameworks for creating backtesters of trading strategies in Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>