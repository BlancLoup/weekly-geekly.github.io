<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I rewrote the search engine of air tickets with PHP on NodeJS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. My name is Andrey, I am a graduate student in one of the technical universities of Moscow and part-time  very modest  novice entrepreneur and dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I rewrote the search engine of air tickets with PHP on NodeJS</h1><div class="post__text post__text-html js-mediator-article"><p>  Hey.  My name is Andrey, I am a graduate student in one of the technical universities of Moscow and part-time <del>  very modest </del>  novice entrepreneur and developer.  In this article I decided to share my experience of transition from PHP (which I once liked because of its simplicity, but over time I became hated by me - I explain why under the cut) to NodeJS.  Very banal and seemingly elementary tasks can be cited here, which, nevertheless, I personally was curious to solve during my acquaintance with NodeJS and the features of server-side development in JavaScript.  I will try to explain and visually prove that PHP has finally gone to sunset and lost its place to NodeJS.  It may even be useful for someone to learn some features of rendering HTML pages in Node, which is not originally adapted to this from the word at all. </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduction </h2><br><p>  While writing the engine, I used the simplest techniques.  No package managers, no routing.  Only hardcore - the folders whose name corresponded to the requested route, and the <strong>index.php</strong> in each of them, configured by PHP-FPM to maintain a pool of processes.  Later it became necessary to use Composer and Laravel, which was the last straw for me.  Before turning to the story about why I even took to rewrite everything from PHP to NodeJS, I‚Äôll tell you a little about the background. </p><br><h3 id="menedzher-paketov">  Package manager </h3><br><p>  At the end of 2018, it was possible to work with one project written in Laravel.  It was necessary to fix a few bugs, make changes to the existing functionality, add a few new buttons in the interface.  The process began with the installation of the package manager and dependencies.  In PHP, Composer is used for this.  Then the customer provided a server with 1 core and 512 MB of RAM, and this was my first experience with Composer.  When installing dependencies on a virtual private server with 512 megabytes of memory, the process ended abnormally due to a lack of memory. </p><br><p><img src="https://habrastorage.org/webt/pg/jm/hh/pgjmhhg0efngekrokj1yryvdzxg.png" alt="Wut?"></p><br><p> For me, as a person familiar with Linux and having experience with Debian and Ubuntu, the solution to such a problem was obvious - installing a SWAP file (the paging file is for those who are not familiar with Linux administration).  A beginner inexperienced developer who has installed his first Laravel distribution on Digital Ocean, for example, will simply go to the control panel and raise the tariff until the dependency installation stops completing with a memory segmentation error.  And how are things going with NodeJS? <br>  And NodeJS has its own package manager, npm.  It is much easier to use, more compact, it can work even in an environment with a minimum amount of RAM.  In general, Composer doesn‚Äôt blame NPO in the background, but if there are any errors when installing the packages, Composer will crash with an error like a regular PHP application and you will never know how much of the package was installed and whether it was installed at the end ends  And in general, for the Linux administrator, the installation crashed = flashbacks in Rescue Mode and <code>dpkg --configure -a</code> .  By the time I was overtaken by such "surprises", I didn‚Äôt like PHP, but these were the last nails in the coffin of my once great love for PHP. </p><br><h2 id="long-term-support-i-problema-versionirovaniya">  Long-term support and versioning problem </h2><br><p>  Remember, what excitement and amazement caused PHP7, when the developers first presented it?  More than 2 times performance increase, and in some components up to 5 times!  Do you remember when PHP came up with the seventh version?  And how quickly WordPress earned!  It was December 2015.  Did you know that PHP 7.0 is already considered an outdated version of PHP and it is highly recommended to upgrade it ... No, not to version 7.1, but to version 7.2.  According to the developers, version 7.1 is already deprived of active support and receives only security updates.  And after 8 months it will stop.  It will stop, along with active support and version 7.2.  It turns out that by the end of this year, PHP will have only one current version - 7.3. </p><br><p><img src="https://habrastorage.org/webt/zd/0p/me/zd0pmebltmchxqafrdw5yfpdfta.png" alt="Currently used PHP versions"></p><br><p>  In fact, it would not be a niggle and I would not attribute this to the reasons for my leaving PHP, if the projects written by me in PHP 7.0. * Already did not cause a deprecation warning when opening.  Let's return to the project where the installation of dependencies took off.  This was a project written in 2015 on Laravel 4 with PHP 5.6.  It seemed that only 4 years had passed, but en-no - a bunch of deprecation-warnings, outdated modules, the inability to properly upgrade to Laravel 5 due to a heap of root engine updates. </p><br><p>  And this concerns not only Laravel itself.  Try to take any PHP application written in the days of active support for the first versions of PHP 7.0 and be prepared to spend your evening looking for solutions to problems encountered in obsolete PHP modules.  Finally, an interesting fact: support for PHP 7.0 was discontinued earlier than support for PHP 5.6.  For a moment. </p><br><p>  How are things with NodeJS?  I would not say that everything is much better here, and that the terms of support for NodeJS are radically different from PHP.  No, everything is about the same here - each LTS version is supported for 3 years.  Only NodeJS has a bit more of these most current versions. </p><br><p><img src="https://habrastorage.org/webt/ff/xf/x_/ffxfx_rhvieo0jmad4wnabdrwuy.png" alt="Current NodeJS Versions Used"></p><br><p>  If you need to deploy an application written in 2016, you can be sure that you will have absolutely no problems with it.  Incidentally, version 6. * will no longer be supported only in April of this year.  And there are still 8, 10, 11 and upcoming 12. </p><br><h2 id="o-trudnostyah-i-syurprizah-pri-perehode-na-nodejs">  On the difficulties and surprises in the transition to NodeJS </h2><br><p>  I will begin, perhaps, with the most exciting question of how to render HTML pages in NodeJS.  But let's start by remembering how this is done in PHP: </p><br><ol><li>  Embed HTML directly into PHP code.  So do all the novices who have not yet reached MVC.  And so done in WordPress, which is absolutely terrifying. </li><li>  Use MVC, which should simplify the interaction of the developer and provide some sort of breaking up the project into parts, but in reality this approach only complicates everything at times. </li><li>  Use a template engine.  The most convenient option, but not in PHP.  Just look at the syntax suggested in Twig or Blade with braces and percentages. </li></ol><br><p>  I am an ardent opponent of combining or merging several technologies together.  HTML should exist separately, styles for it - separately, JavaScript-separately (in React it generally looks monstrous - HTML and JavaScript mixed together).  That is why the ideal option for developers with preferences like mine is a template engine.  It didn‚Äôt take long to search for a web application on NodeJS and I made a choice in favor of Jade (PugJS).  Just appreciate the simplicity of its syntax: </p><br><pre> <code class="plaintext hljs"> div.row.links div.col-lg-3.col-md-3.col-sm-4 h4.footer-heading . div.copyright div.copy-text 2017 - #{current_year} . div.contact-link span : a(href='mailto:hello@flaut.ru') hello@flaut.ru</code> </pre> <br><p>  Everything is quite simple here: I wrote the template, loaded it into the application, compiled it once and then used in any convenient place at any convenient time.  I feel that PugJS‚Äôs performance is about 2 times better than rendering with the help of embedding HTML in PHP code.  If earlier in PHP a static page was generated by the server in about 200-250 milliseconds, now this time is about 90-120 milliseconds (this is not about rendering in PugJS, but about the time taken from the page request to the server response to the client with ready HTML ).  This is how the loading and compilation of templates and their components looks like at the stage of application launch: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pugs = {} fs.readdirSync(__dirname + <span class="hljs-string"><span class="hljs-string">'/templates/'</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(file.endsWith(<span class="hljs-string"><span class="hljs-string">'.pug'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filepath = __dirname + <span class="hljs-string"><span class="hljs-string">'/templates/'</span></span> + file pugs[file.split(<span class="hljs-string"><span class="hljs-string">'.pug'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]] = pug.compile(fs.readFileSync(filepath, <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>), { <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: filepath }) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(e) } } }) <span class="hljs-comment"><span class="hljs-comment">//       return pugs.tickets({ ...config })</span></span></code> </pre> <br><p>  It looks incredibly simple, but with Jade there was a little difficulty at the stage of working with already compiled HTML.  The fact is that for the introduction of scripts on the page an asynchronous function is used, which takes all the <code>.js</code> files from the directory and adds to each of them the date of their last change.  The function is as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; files.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> period = files[i].lastIndexOf(<span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// get last dot in filename let filename = files[i].substring(0, period) let extension = files[i].substring(period + 1) if(extension === 'js') { let fullFilename = filename + '.' + extension if(env === 'production') { scripts.push({ path: paths.production.web + fullFilename, mtime: await getMtime(paths.production.code + fullFilename)}) } else { if(files[i].startsWith('common') || files[i].startsWith('search')) { scripts.push({ path: paths.developer.scripts.web + fullFilename, mtime: await getMtime(paths.developer.scripts.code + fullFilename)}) } else { scripts.push({ path: paths.developer.vendor.web + fullFilename, mtime: await getMtime(paths.developer.vendor.code + fullFilename)}) } } } }</span></span></code> </pre> <br><p>  At the output we get an array of objects with two properties - the path to the file and the time it was last edited in the timestamp (for updating the client cache).  The problem is that even at the stage of collecting script files from a directory, they are all loaded into memory strictly alphabetically (as they are located in the directory itself, and the collection of files in it is done from top to bottom - from first to last).  This led to the fact that the <strong>app.js</strong> file was loaded first, and after it the <strong>core.min.js</strong> file <strong>came</strong> with the polyfills, and at the very end, <strong>vendor.min.js</strong> .  This problem was solved quite simply - a very banal sorting: </p><br><pre> <code class="javascript hljs">scripts.sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.path.includes(<span class="hljs-string"><span class="hljs-string">'core.min.js'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.path.includes(<span class="hljs-string"><span class="hljs-string">'vendor.min.js'</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> })</code> </pre> <br><p>  In PHP, this all had a monstrous appearance in the form of pre-recorded paths to the JS-files.  Simple but impractical. </p><br><h3 id="nodejs-derzhit-svoyo-prilozhenie-v-operativnoy-pamyati">  NodeJS keeps its application in RAM </h3><br><p>  This is a huge plus.  I have everything arranged so that on the server in parallel and independently from each other there are two separate sites - the developer version and the production version.  Imagine that I made some changes to the PHP files on the development site and I need to roll out these changes to production.  To do this, you need to stop the server or set the "sorry, tech. Work" stub and at this time copy the files separately from the developer folder to the production folder.  This causes some kind of simple and can lead to a loss of conversions.  The advantage of the <strong>in-memory application</strong> in NodeJS is for me that all changes to the engine files will be made only after rebooting it.  This is very convenient, since you can copy all the necessary files with changes and only then restart the server.  The process takes no more than 1-2 seconds and will not cause downtime. <br>  The same approach is used in nginx, for example.  You first edit the configuration, check it with <code>nginx -t</code> and only then make changes with <code>service nginx reload</code> </p><br><h3 id="klasterizaciya-nodejs-prilozheniya">  NodeJS application clustering </h3><br><p>  NodeJS has a very handy tool - the <strong>pm2</strong> process <strong>manager</strong> .  How do we usually run applications in Node?  We come into the console and we write <code>node index.js</code> .  As soon as we close the console, the application closes.  At least that's what happens on the server with Ubuntu.  To avoid this and keep the application running at all, just add it to <strong>pm2 with a</strong> simple command <code>pm2 start index.js --name production</code> .  But that is not all.  The tool allows monitoring ( <code>pm2 monit</code> ) and application clustering. </p><br><p>  Let's remember how processes are organized in PHP.  Suppose we have a nginx servicing http requests and we need to send a request to PHP.  You can either do this directly, and then with each request, the new PHP process will spawn, and when it is completed, it will be killed.  And you can use a fastcgi server.  I think everyone knows what it is and there is no need to go into details, but just in case, I‚Äôll clarify that PHP-FPM is most often used as fastcgi and its task is to drop many PHP processes that are ready to accept and process a new request at any time.  What is the disadvantage of this approach? </p><br><p>  The first is that you never know how much memory your application will consume.  Secondly, you will always be limited in the maximum number of processes, and accordingly, with a sharp jump in traffic, your PHP application either uses all the available memory and drops, or rests on the permissible limit of processes and starts to kill old ones.  This can be prevented by setting a not-remember-some parameter in the PHP-FPM configuration file to <strong>dynamic</strong> and then there will be as many processes as needed at this time.  But again, the elementary DDoS attack will take out all the RAM and put your server.  Or, for example, a bugged script will eat up all the RAM and the server will hang for a while (there were precedents in the development process). </p><br><p>  The fundamental difference in NodeJS is that the application can not consume more than 1.5 gigabytes of RAM.  There are no restrictions on the processes, there is only a limit on memory.  It stimulates to write the most lightweight programs.  In addition, it is very easy to calculate the number of clusters that we can afford, depending on the available CPU resource.  It is recommended to ‚Äúhang‚Äù no more than one cluster on each core (exactly as in nginx - no more than one worker per CPU core). </p><br><p><img src="https://habrastorage.org/webt/rk/z4/hp/rkz4hp9g8jkptpmq_tbc-_gpdpu.png" alt="PM2 Clustering"></p><br><p>  The advantage of this approach is that PM2 reboots all clusters in turn.  Returning to the previous paragraph, which spoke about a 1-2 second downtime at reboot.  In Cluster-Mode, when the server is restarted, your application will not experience a millisecond downtime. </p><br><h3 id="nodejs---eto-horoshiy-shveycarskiy-nozh">  NodeJS is a good Swiss knife </h3><br><p>  Now there is a situation where PHP acts as a language for writing sites, and Python acts as a tool for crawling these same sites.  NodeJS is 2 in 1, on the one hand a fork, on the other - a spoon.  You can write fast and productive applications and web crawlers on the same server within the same application.  It sounds tempting.  But how can this be realized, you ask?  Google itself rolled out the official API from Chromium - Puppeteer.  You can run Headless Chrome (a browser without a user interface - "headless" Chrome) and get the widest possible access to the API browser to crawl pages.  <a href="https://www.youtube.com/watch%3Fv%3DWPcahL2K27w">The most simple and accessible about the work of Puppeteer</a> . </p><br><p>  For example, in our VKontakte group there is a regular posting of discounts and special offers for various destinations from cities of the CIS.  We generate images for posts in automatic mode, and to make them more beautiful, we need beautiful pictures.  I don‚Äôt like to be tied to various APIs and have accounts on dozens of sites, so I wrote a simple application that simulates a regular user with Google Chrome browser, which walks around the site with stock images and randomly picks up the image found by the keyword.  I used to use Python and BeautifulSoup for this, but now this is no longer necessary.  And the most important feature and advantage of Puppeteer is that you can easily steal even SPA-sites, because you have at your disposal a full-fledged browser that understands and executes JavaScript-code on sites.  It is painfully simple: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> browser = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> puppeteer.launch({<span class="hljs-attr"><span class="hljs-attr">headless</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">args</span></span>:[<span class="hljs-string"><span class="hljs-string">'--no-sandbox'</span></span>]}) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> page = (<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> browser.pages())[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.goto(<span class="hljs-string"><span class="hljs-string">`https://pixabay.com/photos/search/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${imageKeyword}</span></span></span><span class="hljs-string">/?cat=buildings&amp;orientation=horizontal`</span></span>, { <span class="hljs-attr"><span class="hljs-attr">waitUntil</span></span>: <span class="hljs-string"><span class="hljs-string">'networkidle0'</span></span> })</code> </pre> <br><p>  So in 3 lines of code, we launched a browser and opened a page of the site with stock images.  Now we can choose a random block with an image on the page and add a class to it, by which we can later apply in the same way and go directly to the page directly with the image itself for its further loading: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imagesLength = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> page.evaluate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> photos = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.search_results &gt; .item'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(photos.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { photos[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * photos.length)].className += <span class="hljs-string"><span class="hljs-string">' --anomaly_selected'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> photos.length })</code> </pre> <br><p>  Remember how much code it would take to write something like this on PhantomJS (which, by the way, closed and entered into close cooperation with the development team Puppeteer).  Is the presence of such a wonderful tool can stop someone from moving to NodeJS? </p><br><h3 id="v-nodejs-zalozhena-asinhronnost-na-fundamentalnom-urovne">  NodeJS has asynchrony at the fundamental level </h3><br><p>  This can be considered a huge advantage of NodeJS and JavaScript, especially with the arrival of async / await in ES2017.  Unlike PHP, where any call is executed synchronously.  I will give a simple example.  Previously, in our search engine, pages were generated on the server, but something needed to be displayed on the page already in the client using JavaScript, and at that time Yandex was not yet able to use JavaScript on the sites and had to implement the snapshot mechanism (snapshots) for it using Prerender.  Snapshots were stored on our server and issued to the robot upon request.  The dilemma was that these images were generated within 3-5 seconds, which is completely unacceptable and may affect the ranking of the site in the search results.  To solve this problem, a simple algorithm was invented: when a robot requests some page, we already have a snapshot, we simply give it a snapshot that we already have, after which we perform an operation to create a new snapshot and replace them already available.  How it was done in PHP: </p><br><pre> <code class="php hljs">exec(<span class="hljs-string"><span class="hljs-string">'/usr/bin/php '</span></span> . <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">'/snapshot.php -a '</span></span> . $affiliation_type . <span class="hljs-string"><span class="hljs-string">' -l '</span></span> . urlencode($full_uri) . <span class="hljs-string"><span class="hljs-string">' &gt; /dev/null 2&gt;/dev/null &amp;'</span></span>);</code> </pre> <br><p>  Never do that. <br>  In NodeJS, this can be achieved by calling an asynchronous function: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveSnapshot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ getSnapshot().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> { db.saveSnapshot().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status.err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) }) }) } <span class="hljs-comment"><span class="hljs-comment">/** *     await * ..    resolve()   */</span></span> saveSnapshot()</code> </pre> <br><p>  In short, you are not trying to bypass synchronization, but you decide when to use synchronous code execution, and when it is asynchronous.  And it is really convenient.  Especially when you learn about <strong>Promise.all ()</strong> features <strong>.</strong> </p><br><p>  The ticket search engine itself is designed in such a way that it sends a request to the second server, which collects and aggregates data, and then refers to it for data that is already ready for issue.  To attract traffic from organic use page directions. </p><br><p>  For example, at the request "Flights Moscow St. Petersburg" a page with the address <em>/ tickets / moscow / saint-petersburg /</em> will be issued, and on it you need the data: </p><br><ol><li>  Prices of air tickets in this direction for the current month </li><li>  Airfare prices in this area for the year ahead (average price for each month for the next 12 months) </li><li>  Flight schedule for this destination </li><li>  Popular destinations from the city of dispatch - from Moscow (for re-linking) </li><li>  Popular destinations from the city of arrival - from St. Petersburg (for relink) </li></ol><br><p>  In PHP, all these requests were executed synchronously - one by one.  The average API response time for one request is 150-200 milliseconds.  Multiply 200 by 5 and get on average a second only to fulfill requests to the server with data.  NodeJS has a great function <strong>Promise.all</strong> , which executes all requests in parallel, but records the result one by one.  For example, the code to execute all five of the above queries would look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> [montlyPrices, yearlyPrices, flightsSchedule, originPopulars, destPopulars] = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ getMontlyPrices(), getYearlyPrices(), getFlightSchedule(), getOriginPopulars(), getDestPopulars() ])</code> </pre> <br><p>  And we get all the data in 200-300 milliseconds, reducing the time of data generation for a page from 1-1.5 seconds to ~ 500 milliseconds. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Switching from PHP to NodeJS helped me to get acquainted with asynchronous JavaScript better, to learn how to work with promises and async / await.  After the engine was rewritten, the page loading speed was optimized and differed dramatically from the results that the PHP engine showed.  In this article, you could still tell how easy it is to use modules for working with cache (Redis) and pg-promise (PostgreSQL) in NodeJS and compare them with Memcached and php-pgsql, but this article turned out to be quite voluminous.  And knowing my "talent" for writing, it turned out to be also poorly structured.  The purpose of writing this article is to attract the attention of developers who are still working with PHP and are not aware of the virtues of NodeJS and the development of web-based applications using the example of a real-life project that was once written in PHP, but because of preferences its owner went to another platform. </p><br><p>  I hope that I managed to convey my thoughts and more or less structured to present them in this material.  At least I tried :) </p><br><p>  Write any comments - benevolent or angry.  I will respond to any constructive. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/444400/">https://habr.com/ru/post/444400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444388/index.html">Legendary modems of the past: the best connection holders in the conditions of domestic PBX</a></li>
<li><a href="../444390/index.html">DeviceLock 8.3 DLP system: a year has passed, Billy, but you haven't changed at all</a></li>
<li><a href="../444394/index.html">A new foundation for DevOps projects from the Linux Foundation began with Jenkins and Spinnaker</a></li>
<li><a href="../444396/index.html">Epson booth at ISE 2019 - the exhibition is over, impressions remain</a></li>
<li><a href="../444398/index.html">Why non-food stores need self-service organization</a></li>
<li><a href="../444404/index.html">Why are we afraid of robots?</a></li>
<li><a href="../444406/index.html">Digital Italy. What and how it works</a></li>
<li><a href="../444408/index.html">Apple released a new iPad yesterday, and they have questions</a></li>
<li><a href="../444410/index.html">Network Maps. Overview of network mapping software</a></li>
<li><a href="../444414/index.html">Snapdragon 8cx: 7 nm PC Platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>