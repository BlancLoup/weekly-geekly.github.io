<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elixir: making code extensible with Behavior</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So, let's define the disposition ... You wrote a piece of code that you want to use with a lot of different "things" - it sounds not very scientific, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elixir: making code extensible with Behavior</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/cd0/d53/e99/cd0d53e99318443a8398494e890038b5.jpg"><br><p>  So, let's define the disposition ... You wrote a piece of code that you want to use with a lot of different "things" - it sounds not very scientific, but still.  These different things are united by some common property, through which they achieve the same result at a high level of abstraction;  only here the ways of achieving the result can be completely different. </p><br><p>  Often your code should only use one such thing at a time, but you don‚Äôt want to make your code so narrow?  This is just disgusting.  Isn't it great when other people can create new ‚Äúthings‚Äù and expand your code while you don't even touch the keyboard? </p><br><blockquote>  But can't I select a specific implementation and use it?  I don't need anything else .... </blockquote><p>  Of course you can.  But what happens if you change your mind about the ‚Äúthing‚Äù you are using.  Suddenly your sweetie without a wrapper will turn out to be not what it seems?  And suddenly even worse - your marvelous "little thing" will cease to support?  In such terrible conditions it would be cool if you could quickly change one for the other without changing everything we wrote at all.  Pralno? </p><a name="habracut"></a><br><h2 id="hvatit-toloch-vodu-v-stupe">  Stop pounding the water in a mortar ... </h2><br><p>  If you read up here, I think that you understand what I mean.  ‚ÄúThings‚Äù represent millions of variations, but let's move on to some adequate examples from the real world: </p><br><ul><li><p>  A messenger application that should send email with several different options: <strong>SMTP</strong> , <strong>Mandrill</strong> , <strong>Sendgrid</strong> , <strong>Postmark</strong> , <strong>% Your Future SaaS Product%</strong> and so on.  In this example, "things" are message delivery methods.  they all deliver mail, but in different ways. </p><br></li><li><p>  Resume Generator, which takes data from a <em>web-</em> form, and renders it in <strong>HTML</strong> , <strong>PDF</strong> , <strong>Markdown</strong> , <strong>LaTeX</strong> , <strong>% Here is New Format Your Grandma%</strong> and so on.  The ‚Äúthings‚Äù here are different document formats, they all accept the same data as input, but they all do different things to achieve results in the form of a document that your user can take. </p><br></li><li>  A data storage engine that takes data and stores it in a database: <strong>PostgreSQL</strong> , <strong>MySQL</strong> , <strong>SQLite,</strong> and so on.  In this case, the "thing" is the database, they can all accept requests, but each of them handles these requests in different ways.  Incidentally, I just described <a href="https://github.com/elixir-lang/ecto"><strong>Ecto</strong></a> . </li></ul><br><p>  All of these scenarios describe a serious problem - since we want to work with all these little things, but the differences in them constitute a formidable barrier from a heap of repetitive code.  A bunch of programming languages ‚Äã‚Äãhave solutions to this problem, and <strong>Elixir is</strong> no exception: meet <strong>Behaviour</strong> . </p><br><h2 id="behaviour-v-elixir">  Behavior in Elixir </h2><br><p>  Tip in the title.  To interact with several things as if they were one and the same: we must define their common <strong>behavior</strong> as an abstraction.  And this is exactly what <a href="http://elixir-lang.org/getting-started/typespecs-and-behaviours.html"><strong>Behaviour</strong></a> does in Elixir: the definition of such an abstraction.  Every <strong>Behavior</strong> exists as a specification or instruction, allowing other modules to follow these instructions and thus support <strong>Behaviour</strong> .  This allows the rest of the code to care only about the common interface.  Want to change services?  On health, the calling code will not notice anything. </p><br><p>  But how does all this look?  <strong>Behavior is</strong> defined as a normal module, within which you can designate a group of specifications for functions that <em>should</em> be implemented in a module that supports this <strong>Behavior</strong> .  Each such specification is defined using the <strong><a href="https://habrahabr.ru/users/callback/" class="user_link">callback</a></strong> directive and <a href="http://elixir-lang.org/getting-started/typespecs-and-behaviours.html"><strong>typespec</strong></a> signatures, which allows you to specify what exactly each function accepts and gives.  Looks like that: </p><br><pre><code class="hljs pgsql">defmodule <span class="hljs-keyword"><span class="hljs-keyword">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @callback parse(String.t) :: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span> @callback extensions() :: [String.t] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  All modules that want to support this <strong>Behaviour</strong> should: </p><br><ul><li><p>  Explicitly confirm your desire with the <code>@behaviour Parser</code> directive; </p><br></li><li><p>  Implement the <code>parse/1</code> method, which accepts a string and returns any term; </p><br></li><li>  Implement the <code>extensions/0</code> method which accepts nothing and returns a list of strings. </li></ul><br><p>  The use of <strong>Behaviour</strong> is explicit, so all modules that support <strong>Behaviour</strong> should confirm this using the <code>@behaviour SomeModule</code> attribute.  This is very convenient - you can rely on the compiler, it will check that your modules do not meet the specifications.  Therefore, if you update <strong>Behavior</strong> , then you can be sure that the compiler is on your side - it will make sure that all modules supporting it should be updated too. </p><br><h2 id="nyryaem-glubzhe">  We dive deeper </h2><br><p>  If you still do not quite understand what I mean - you can help the example of other languages.  If you are a fan of <strong>Python</strong> , then this <a href="http://charlesleifer.com/blog/django-patterns-pluggable-backends/">post</a> is a good explanation of the pattern as a whole.  If you are from <strong>Ruby</strong> - read it too - the philosophy is basically the same (inherit the basic adapter and hope for the best, hehe).  Well, for <strong>Go</strong> lovers, there is a lot in common with this <a href="http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go">interface</a> . </p><br><p>  I must say that it is much easier to explain how <strong>Behaviour</strong> can help write extensible code, on a live example, so we‚Äôll go deeper with an example about <em>email</em> .  Consider the <a href="https://github.com/swoosh/swoosh"><strong>Swoosh</strong></a> library, which uses <strong>Behavior</strong> to define a stack of methods for delivering letters, and can use one more method and use it. </p><br><h2 id="opredelenie-publichnogo-dogovora">  Definition of a public contract </h2><br><p>  We have been discussing <em>why for</em> so long, so let's immediately look at the library, namely at <a href=""><strong>Swoosh.Adapter</strong></a> </p><br><pre> <code class="hljs python">defmodule Swoosh.Adapter do @moduledoc ~S<span class="hljs-string"><span class="hljs-string">""" Specification of the email delivery adapter. """</span></span> @type t :: module @type email :: Swoosh.Email.t @typep config :: Keyword.t @doc <span class="hljs-string"><span class="hljs-string">""" Delivers an email with the given config. """</span></span> @callback deliver(email, config) :: {:ok, term} | {:error, term} end</code> </pre> <br><p>  As you can see, the example is a little longer than the documentation, because <strong>Swoosh</strong> defines all the types used for additional readability and transparency of the code ( <strong>config is</strong> used as a link to <strong>Keyword.t</strong> , simply because it is more understandable).  But we generally don't care about types, we only care about the <strong><a href="https://habrahabr.ru/users/callback/" class="user_link">callback</a></strong> directive, which defines the rules for one and only function in this abstraction: <strong>deliver the</strong> letter.  The definition of <code>deliver/2</code> tells us that: </p><br><ul><li><p>  the function takes two arguments: the structure of the <strong>Swoosh.Email</strong> type and the configuration in the form of a list of keywords; </p><br></li><li><p>  function <em>does something</em> ; </p><br></li><li>  returns values ‚Äã‚Äãin the usual <code>ok/error</code> tuple for <strong>Elixir</strong> . </li></ul><br><h3 id="podderzhivaem-behaviour">  We support <strong>Behavior</strong> </h3><br><p>  It's time to determine <em>doing something</em> .  We will look at and look at the two adapters that support <strong>behavior</strong> , and are included in the "batteries" to <strong>Swoosh</strong> .  First, let's take a look at the simple - <strong>Local</strong> client, which delivers letters straight to memory. </p><br><pre> <code class="hljs ruby">defmodule Swoosh.Adapters.Local <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @behaviour Swoosh.Adapter <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deliver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%Swoosh.Email{} = email, _config)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %Swoosh.Email{<span class="hljs-symbol"><span class="hljs-symbol">headers:</span></span> <span class="hljs-string"><span class="hljs-string">%{"Message-ID" =&gt; id}</span></span>} = Swoosh.InMemoryMailbox.push(email) {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, <span class="hljs-string"><span class="hljs-string">%{id: id}</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Here, in general, there is nothing to discuss.  For starters, the adapter clearly indicates that it supports <strong>Swoosh.Adapter Behavior</strong> .  Then, the <code>deliver/2</code> function is defined, which has exactly the signature that is defined in the contract.  This explicit definition allows the compiler to do all the dirty work for us.  If the guys who make <strong>Swoosh</strong> decide to add another function to the specification, then all supporting modules will also have to be changed, otherwise the application will simply not compile.  awesome security! </p><br><p>  Another client who sends letters via <strong>Sendgrid</strong> is too big to copy the source code here, but you can <a href="">watch it on <strong>GitHub</strong></a> .  You will notice that the module is much more complicated, and defines a large number of functions other than the one that should be required: <code>deliver/2</code> .  This is because for <strong>Behavior it</strong> does not matter how many <em>extra</em> functions there are - they should not be 1: 1.  This allows more complex modules to invoke other specific functions in the same ones defined in the contract, which improves readability and cleanliness of the code. </p><br><h2 id="dobavlyaem-v-kod-schepotku-gibkosti">  Add a pinch of flexibility to the code </h2><br><p>  We have already learned how to define the "contract" of <strong>Behavior</strong> , and even how to support it in modules, but how will this help us when we want to use them in the calling code?  There are several ways to implement this idea, everyone can vary in complexity.  Let's start with the simple. </p><br><h3 id="dependency-injection-s-pomoschyu-zagolovka-funkcii">  <em>Dependency injection</em> using function header </h3><br><p>  Let's return to our example <strong>Parser</strong> straight from the docks: </p><br><pre> <code class="hljs sql">defmodule Document <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @default_parser XMLParser defstruct <span class="hljs-keyword"><span class="hljs-keyword">body</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-keyword"><span class="hljs-keyword">parse</span></span>(%<span class="hljs-keyword"><span class="hljs-keyword">Document</span></span>{} = <span class="hljs-keyword"><span class="hljs-keyword">document</span></span>, opts // []) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {parser, opts} = Keyword.pop(opts, :parser, @default_parser) parser.parse(document.body) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Here we use the <strong>Document</strong> module which simply defines a functional wrapper for our <strong>Behaviour</strong> , so we can easily switch between different parsers.  Let's try to run ... </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Document</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.parse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">document</span></span>)</code> </pre> <br><p>  In the code above, we pass only one argument ‚Äî no <code>options</code> .  This leads to the fact that data access with the key <code>:parser</code> in the <code>Keyword.pop</code> call <code>Keyword.pop</code> not work, and returns us a simple <code>@default_parser</code> , which was defined in the module attribute.  After this, the <code>parse/1</code> function will simply call the same method on our parser, passing the <em>body</em> string there. </p><br><p>  Great, what about the <strong>XMLParser</strong> ?  Voila! </p><br><pre> <code class="hljs pgsql">Document.parse(document, <span class="hljs-keyword"><span class="hljs-keyword">parser</span></span>: JSONParser)</code> </pre> <br><p>  Since both <strong>XMLParser</strong> and <strong>JSONParser</strong> support <strong>Parser Behaviour</strong> , they both have an implementation of the <code>parse/1</code> function.  And by calling this function in a wrapper, we can very quickly and simply do <em>dependency injection of the</em> parser we need. </p><br><p>  This kind of dependency management is very powerful.  It even allows different parts of the application to use, for example, different parsers.  However, there are downsides.  When using this method, you must trust the user to know <em>how</em> and <em>where</em> <em>dependency injection</em> occurs, which will require more extensive documentation.  Moreover, what if the user wants to use different dependencies in different environments?  Your code will have to decide in runtime which module to use and when.  Isn't it better to ask it in advance and forget about it? </p><br><h3 id="dependency-injection-s-pomoschyu-mix-sonfig">  <em>Dependency injection</em> using <strong>mix config</strong> </h3><br><p>  Thanks to <strong>Mix</strong> is not even a problem.  Let's look at the <strong>Parser</strong> example again: </p><br><pre> <code class="hljs ruby">defmodule Document <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @default_parser XMLParser defstruct <span class="hljs-symbol"><span class="hljs-symbol">body:</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%Document{} = document)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> config = Application.get_env(<span class="hljs-symbol"><span class="hljs-symbol">:parser_app</span></span>, __MODULE_<span class="hljs-number"><span class="hljs-number">_</span></span>, []) parser = config[<span class="hljs-symbol"><span class="hljs-symbol">:parser</span></span>] <span class="hljs-params"><span class="hljs-params">||</span></span> @default_parser parser.parse(document.body) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In this example, <code>parse/1</code> no longer accepts any options.  But the type of the parser is calculated directly from the configuration of the <strong>OTP Application</strong> . </p><br><p>  For example, the configuration file might look like this: </p><br><pre> <code class="hljs lua"># <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.exs <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> :parser_app, Document, parser: JSONParser</code> </pre> <br><p>  our <strong>Document.parse</strong> wrapper will know to use <strong>JSONParser</strong> for parsing.  All this serves for us an excellent service, since the choice of the adapter is no longer tied to the calling code, and therefore can be changed in the <strong>Mix config</strong> , or the config that depends on the environment can be chosen by our parser in the future.  Again, this approach has its drawbacks: the configuration is strongly tied to the <strong>Document</strong> module, because it uses <strong><strong>MODULE</strong></strong> (module name) in the config.  This means that we are moving away from the possibility of using several parsers, only because everywhere in the code we use the hardcoded <strong>Document</strong> module.  Of course, in most cases, one adapter is enough for the entire project, but if you suddenly need more?  For example, one part of the code will send letters via <strong>Sendgrid</strong> , and the other part of it will require the support of an <em>outdated</em> <strong>SMTP</strong> server.  Well, back to <strong>Swoosh</strong> ... </p><br><h3 id="dostigaem-preimuschestva-oboih-podhodov">  We achieve the advantages of both approaches </h3><br><p>  Fortunately for, <strong>Swoosh</strong> repeats <strong>Ecto</strong> 's approach to this problem.  You, as a programmer, must define your own module somewhere in the code that <strong>Swoosh</strong> will then use via <code>use Swoosh.Mailer</code> .  Your calling code will then use this module as a wrapper for the imported <strong>Swoosh.Mailer</strong> .  Unfortunately, the details of how macros work are beyond the scope of the article. But for the simple reason: the <strong>use</strong> macro causes <strong>Elixir to</strong> call a macro called <strong><strong>using</strong></strong> in the imported module.  You can see how this macro <strong>Swoosh.Mailer is executed.</strong>  <strong><strong>using</strong></strong> directly <a href="">in turnips</a> . </p><br><p>  In essence, this means that the <strong>Swoosh</strong> configuration is in two places at once: </p><br><pre> <code class="hljs lua"># In your <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>/<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.exs file <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> :sample, Sample.Mailer, adapter: Swoosh.Adapters.Sendgrid, api_key: <span class="hljs-string"><span class="hljs-string">"SG.xx"</span></span> # In your application code defmodule Sample.Mailer <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Swoosh.Mailer, otp_app: :sample <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  By structuring the code in this way, we can achieve that each module has its own section of settings in <strong>Mix config</strong> .  Each individual module must <strong>use Swoosh.Mailer</strong> in order for them to be configured differently. </p><br><p>  ... and everything!  Now you know how to create <em>publicly extendable</em> code.  But before you finish, a couple more words ... </p><br><h2 id="bolshe-primerov">  More examples </h2><br><p>  Reading the existing code will help you learn the knowledge gained in the article.  You can start with: </p><br><ul><li><p>  <a href="https://github.com/elixir-lang/plug"><strong>Plug</strong></a> - The specification for extensible <strong>web</strong> applications is itself <strong>Behavior</strong> .  When someone creates a <strong>plug</strong> , in fact they support <strong>Plug Behaviour</strong> in their module, which is very simple: the module must support two functions: <code>init/1</code> and <code>call/2</code> .  This approach allows you to build a chain of plug-ins, as in <strong>Phoenix</strong> . </p><br></li><li>  <a href="https://github.com/elixir-lang/ecto"><strong>Ecto</strong></a> - uses <strong>Behavior</strong> in a billion places, ranging from repositories and their adapters, ending with database connections, extensions, migrations, and the repositories themselves. </li></ul><br><h2 id="parochka-veschey-na-posmotret">  A couple of things to see </h2><br><p>  Summing up: the advantages of this approach is that it allows you to write loosely coupled code that is subject to any public contracts.  Thanks to this, developers can extend existing functionality simply by explicitly defining extensions that appear in the course of work.  The fact that a contract is explicitly defined makes it much easier to test, without <a href="http://blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts/">"mocking as a verb" there</a> . </p><br><p>  As already mentioned, this approach does not work for all situations.  Defining a standard set of relationships between all the plugins, you kind of force the plugins to have similar functionality, but this is not always applicable: there are situations when the code is so different that you cannot put a common divider under it.  For further reading, I would advise the code for the <strong>Ecto</strong> project, especially those areas where the basis for access to various databases, such as the <a href="">DDL transaction</a> and how they <a href="">are made in <strong>Behaviour</strong></a> , is summarized. </p><br><h2 id="epilog">  Epilogue </h2><br><p>  Post suddenly turned out just huge.  In any case, thanks for getting here, and maybe even clicking on a couple of links.  In any case, feel free to email me, or subscribe to my <a href="https://twitter.com/djm_">Twitter</a> , or in any other way spread the plague of love for <strong>Elixir</strong> ! </p><br><p>  Thanks to <a href="https://twitter.com/BarisBalic">Baris</a> for reading and checking. </p><br><h3 id="ot-perevodchika">  From translator </h3><br><p>  <em>The desire to translate an article appeared after I had to do something similar in a small library of my own production.</em>  <em>The code can be viewed <a href="">here</a> for another example.</em>  <em>I hope this article will help to understand the work of the <strong>Elixir</strong> language even deeper, as well as interest those who so far do not distinguish <strong>Phoenix</strong> from <strong>Elixir</strong> .</em>  <em>If you have any questions, write to the <a href="https://telegram.me/proelixir">community</a> .</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/312442/">https://habr.com/ru/post/312442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312424/index.html">Multi-Tech Base Stations let you deploy a LoRaWAN network in a couple of clicks</a></li>
<li><a href="../312426/index.html">Software-defined modular collocation - why is it needed?</a></li>
<li><a href="../312428/index.html">Microsoft fixed vulnerabilities in their products</a></li>
<li><a href="../312430/index.html">How to write less code for MR, or why the world needs another query language? History of Yandex Query Language</a></li>
<li><a href="../312432/index.html">Internet provider fined ¬£ 400,000 after hacker attack with client data leakage</a></li>
<li><a href="../312448/index.html">Personal experience of implementing the GLPI system. Part 1</a></li>
<li><a href="../312450/index.html">Neural networks for beginners. Part 1</a></li>
<li><a href="../312456/index.html">1C in the clouds</a></li>
<li><a href="../312458/index.html">Facebook and Google have released Yarn, a new JavaScript package manager.</a></li>
<li><a href="../312460/index.html">ONLYOFFICE or Libre: about the battle of formats and co-editing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>