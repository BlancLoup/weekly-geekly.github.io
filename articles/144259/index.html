<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RESTful API for the server - doing it right (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the article, I briefly described the principles of RESTful and explained how to design the architecture of your server so that yo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RESTful API for the server - doing it right (Part 2)</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/144011/">first part of the article,</a> I briefly described the principles of RESTful and explained how to design the architecture of your server so that you can easily release new ones and stop supporting outdated versions of your API.  In this part, I will briefly talk about HATEOAS and Hypermedia, and then talk about the role they can play in developing native applications for mobile devices.  But the main topic of this article will be caching implementation (more precisely, server-side caching support).  The target audience includes server software developers and, to some extent, iOS developers or other mobile platforms. <br><br><a name="habracut"></a><br><h4>  HTTP API, REST and HATEOAS </h4><br>  Currently, the HTTP API can be divided into <br><br><ul><li>  Web services </li><li>  RPC URI Tunneling </li><li>  HTTP-based Type 1 </li><li>  HTTP-based Type 2 </li><li>  REST </li></ul><br>  Here is a <a href="http_based_apis.html">very good explanation of</a> this from Jon Algermissen.  Unfortunately, everyone who provides their API calls its RESTful service even though it is not. <br>  So what is it, a real RESTful server?  This is any hypertext / hypermedia based API.  In other words, a third-party developer or client application should be able to obtain information about ‚Äúother available resources‚Äù through the root URL API.  In fact, this is the most important condition when implementing the RESTful API.  In addition, a true RESTful server can only be considered one that adheres to the principle of HATEOAS. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  HATEOAS - Engine of Application State </h4><br>  Two basic principles to be followed when implementing HATEOAS are: <br><ol><li>  <b>Service only hypermedia resources.</b>  Hyperlinked resources are those that contain only content and hyperlinks to other hyperlinked resources.  JSON (application / json) is NOT a hyperlink resource.  (On the other hand, there are many RESTful, HATEOAS servers that support JSON) However, you can add additional fields to JSON, thus causing it to act as a hyperlink resource.  (For example: the href field for the link to the corresponding thumbnail image) </li><li>  <b>Single entry point for client application.</b>  From the API home page, subsequent GET calls should be made up as links to the corresponding URLs, and subsequent ‚ÄúPOST‚Äù, ‚ÄúPUT‚Äù or ‚ÄúDELETE‚Äù requests in the form of forms. </li></ol>  The main advantage you get by following these two principles of HATEOAS is the ease of documentation. <br><br><h4>  Does HATEOAS use in your new API? </h4><br>  <b>NOT!</b> <br>  Why?  In the past, APIs were mostly written for use in web applications.  These servers typically returned XHTML, and client applications ran in a browser.  The browser in such a scheme is similar to your mobile client, which parses hyperlink resources, knows what a form is and how to present it to the user.  In the case of a mobile application, when the response of your RESTful server contains a form from which you can send data to the server, you cannot (at least without additional efforts) convert it into native interface elements available on the platform.  None of the platform providers, either Apple / Google or Microsoft, provide support for converting XHTML forms to UIViewController (on iOS) or Intent (on Android) or Silverlight Page (on Windows Phone).  I recommend using hyperlink resources in response to GET requests and provide controller method calls (instead of forms) for all POST / PUT and DELETE requests.  (For example: / friends / add or / venues / checkin) Controller method calls can be embedded in other answers (so that the client application or the developer can learn about them).  Of course, this violates the principles of REST, but that's okay.  It is better to make a quality product than to blindly follow standards that are of little use in practice.  (This may lead to our API becoming HTTP-based Type 2). <br><br><h4>  Caching </h4><br>  Go to caching.  Caching, as many believe, is basically a client task (or an intermediate proxy task).  But you know what, at the cost of small efforts in developing the server-side, you can make your API fully meet the requirements of intermediate proxy caching?  This means that you get free load balancing on their part.  Everything you need is described in chapter 13 of <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html">the HTTP specification</a> . <br><br>  Not long ago, Art Taylor tweeted: <br><br>  <i>"I derived two new rules: 1) If your application slows down, add caching. 2) If the application is buggy, remove caching. Why is caching so difficult!"</i> <br><br>  But believe me, caching can be implemented without collisions with such problems.  Two main principles that I recommend that you follow are: <br><br><ol><li>  Do not try to do non-standard caching schemes in the client application. </li><li>  Understand the basic caching principles described in the HTTP 1.1 RFC specification.  It describes two models of caching.  Model of validity and model of validity (validity). </li></ol><br>  In any client-server application, the server is a trustworthy source of information.  When you download a resource (page or response) from the server API, the server sends to the client, among other things, some additional ‚Äúhints‚Äù about how the client can cache the received resource.  The server authoritatively indicates to the client when the cached information expires.  These hints can be sent both programmatically and through server configuration.  The expiration model is usually implemented through server configuration, while the validity model requires software implementation by the server-side developer.  It is the developer who must decide when to use validity, and when the validity period is based on the type of resource being returned.  The expiration model is usually used when the server can uniquely determine how long a particular resource will be valid.  The validity model is used for all other cases.  Later I will show you how to implement both of these models during server development.  As soon as you deal with both, I will show when to use each of them. <br><br><h5>  Expiration Model </h5><br>  Let's look at a common caching configuration.  If you use nginx, you probably have something similar in the config: <br><br><pre><code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~ \.(jpg|gif|png|ico|jpeg|css|swf)$</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">expires</span></span> <span class="hljs-number"><span class="hljs-number">7d</span></span>; }</code> </pre> <br>  nginx translates these settings into the appropriate HTTP header.  In this case, the server sends the ‚ÄúExpires‚Äù or ‚ÄúCache-Control: max-age = n‚Äù in the header for all images and expects the client to cache them for 7 days.  This means that you will not need to request the same data for the next 7 days.  Each of the common browsers (and intermediate proxies) takes this header into account and works as expected.  Unfortunately, most of the Open Source image caching frameworks for iOS, including the popular SDWebImage, use a built-in caching mechanism that simply deletes images after n days.  The problem is that such frameworks do not correspond to the model of validity and your client application using these frameworks has to resort to non-standard solutions (hacks).  I will give an example showing what could go wrong here.  Let's return to our ‚Äúnew Facebook‚Äù.  When your user uploads an avatar to the server, he thinks that the changes will be reflected in all views.  Some clever developers clear the local cache after successfully calling update-profile-image.  (This means that all controllers must download the image from the server for a new one).  Everything works great, you have reported to the project manager and in each submission the most recent profile picture is now displayed.  However, this does not completely solve the problem.  A new avatar of the user will be seen by his friends only after 7 days.  Absolutely unacceptable.  So how to solve it?  As I said, you must accept the statement that only a server can be a source of reliable data.  Do not use dishonest client tricks to update the cache by prematurely ending the expiration of the cached content. <br><br><h5>  Validity model </h5><br>  Both Facebook and Twitter solve the problem of outdated profile images (after a new image has been uploaded) using the validity model.  In the validity model, the server sends a unique resource identifier to the client and the client caches both the identifier and the response.  In terms of HTTP, this unique identifier is called ETag.  When you make a second request to the same resource, you must send it to the ETag.  The server uses this identifier to check whether the resource you requested has changed since the last time it was accessed (remember, the server is the only reliable source).  If the resource has really changed, it sends the latest copy.  Otherwise, it sends 304 Not Modified.  The cache validity model requires additional efforts from the developer in the development of both client and server parts.  I will describe both of them further. <br><br><h6>  Customer support </h6><br>  In fact, under iOS, if you use MKNetworkKit it does all the work automatically.  But for developers for Android and Windows Phone, I will describe in detail how this should be implemented. <br>  Cache validity model uses ETag and Last-Modified HTTP headers.  Client side implementation is simpler than server side.  If you receive an ETag with a resource, when you make a second request to receive it, send the ETag in the ‚ÄúIF-NONE-MATCH‚Äù header field.  Similarly, if you received a ‚ÄúLast-Modified‚Äù resource, send it to the ‚ÄúIF-MODOFIED-SINCE‚Äù field of the header in subsequent requests.  The server, on its part, decides when to use ‚ÄúETag‚Äù, and when ‚ÄúLast-Modified‚Äù. <br><br><img src="https://habrastorage.org/storage2/da1/115/0ca/da11150ca01889ab0a2131c98c8d8faf.png"><br><br>  The implementation of the lifetime model is simple.  Simply calculate the expiration date based on the header fields, ‚ÄúExpires‚Äù or ‚ÄúCache-Control: max-age-n‚Äù and clear the cache when this date arrives. <br><br><h6>  Server side implementation </h6><br>  <b>Using ETag</b> <br>  ETag is usually calculated on a server using hashing algorithms.  (Most high-level server languages ‚Äã‚Äãsuch as Java / C # / Scala have object hashing facilities.)  Before generating a response, the server must calculate the object hash and add it to the ETag header field.  Now, if the client actually sent an IF-NONE-MATCH in the request and this ETag is equal to what you calculated, send 304 Not Modified.  Otherwise, create a response and send it with a new ETag. <br><br>  <b>Use Last-Modified</b> <br>  Implementing Last-Modified is not entirely straightforward.  Let's imagine that our API has a call that returns a list of friends. <br><br><pre> <code class="html hljs xml">http://api.mynextfacebook.com/friends/</code> </pre><br>  When you use ETag, you calculate the hash of an array of friends.  When using Last-Modified, you must send the last modified date of this resource.  Since this resource is a list, this date should be the date when you last added a new friend.  This requires the organization developer to store the date of the last data change for each user in the database.  A bit harder than ETag, but gives a big advantage in terms of performance. <br>  When a client requests a resource for the first time, you send a complete list of friends.  Subsequent requests from the client will now have the ‚ÄúIF-MODIFIED-SINCE‚Äù field in the header.  Your server code should only send a list of friends added after the specified date.  The access code to the database before the modification was something like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Friends;</code> </pre><br>  after modification it became so: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Friends <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> friendedDate &gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>-MODIFIED-SINCE;</code> </pre><br>  If the request does not return records, send 304 Not Modified.  Thus, if a user has 300 friends and only two of them have been added recently, then the answer will contain only two entries.  The time it takes for the server to process the request and the resources it consumes is significantly reduced. <br>  Of course, this is a very simplified code.  A developer will have a headache when you decide to support the removal or blocking of friends.  The server must be able to send hints, using which the client will have the opportunity to tell which friends were added and which were deleted.  This technique requires additional efforts in the development of the server part. <br><br><h5>  Select a caching model </h5><br>  So.  It was a difficult topic.  Now I will try to summarize and derive the basic rules for the use of a particular caching model. <br><ol><li>  All static images must be serviced by expiration model. </li><li>  All data generated dynamically should be cached according to the validity model. </li><li>  If your dynamically configured resource is a list, you should use a validity model based on Last-Modified.  (For example / friends).  In other cases, a validation model based on ETag should be used.  (For example /friends/firstname.lastname). </li><li>  Images or any other resources that can be modified by the user (such as an avatar) should also be cached according to the validity model using the ETag.  Although these are images, they are not permanent, such as a company logo.  In addition, you simply can not accurately calculate the duration of such resources. </li></ol><br>  Another way (easier to implement, but a bit hacker) is to use the ‚ÄúURL error‚Äù.  When there is an avatar URL in the response, it is necessary to make part of it dynamic.  So instead of submitting a URL like <br><br><pre> <code class="html hljs xml">http://images.mynextfacebook.com/person/firstname.lastname/avatar</code> </pre><br>  to make <br><br><pre> <code class="html hljs xml">http://images.mynextfacebook.com/person/firstname.lastname/avatar/<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The hash should be changed when the user changes the avatar.  A call that sends a list of friends will now send modified URLs for users who have changed their avatars.  Thus, changes in profile images will be distributed almost instantly! <br>  If your server and client applications meet practically well-established caching standards, your iOS app and your product will simply ‚Äúfly‚Äù at all. <br><br>  In this article I gave a simple explanation of such standards, which the vast majority of developers do not adhere to. <br><br>  At this point I finish the second part of the article.  The next and last will describe the exchange of information about errors and their proper processing, as well as the internationalization of your application. <br><br><h4>  I recommend reading </h4><br>  <a href="http://shop.oreilly.com/product/0636920021575.do">REST API Design Rulebook</a> </div><p>Source: <a href="https://habr.com/ru/post/144259/">https://habr.com/ru/post/144259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144253/index.html">Authorization in Alpha Mobile (under iOS) 10 hours after entering the password</a></li>
<li><a href="../144255/index.html">Nmap 6</a></li>
<li><a href="../144256/index.html">Development using the iPad is becoming more attractive!</a></li>
<li><a href="../144257/index.html">How to convert PDF file to Word format online, on PC and in your own application</a></li>
<li><a href="../144258/index.html">We translate Rails ‚Äì application to Ruby 1.9</a></li>
<li><a href="../144260/index.html">Why are those who claim that the Facebook IPO failed?</a></li>
<li><a href="../144261/index.html">Registration for the conference on computational linguistics "Dialogue"</a></li>
<li><a href="../144262/index.html">Inverted apple</a></li>
<li><a href="../144263/index.html">‚ÄúHow-to me‚Äù, or how to organize professional technical support</a></li>
<li><a href="../144265/index.html">DevExpress on DevCon again!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>