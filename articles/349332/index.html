<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unit testing. Chip tuning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It doesn't matter what approach is used when writing tests: TDD, BDD, or some other. Unit tests are the primary protective barrier that helps to avoid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unit testing. Chip tuning</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/hx/3t/di/hx3tdiwbmunzkn6sxjaypwe8be4.jpeg" alt="image"></p><br><p>  It doesn't matter what approach is used when writing tests: TDD, BDD, or some other.  Unit tests are the primary protective barrier that helps to avoid bugs.  A well-described cases will help colleagues to understand what is happening in the project and not to break the wood in the code. </p><a name="habracut"></a><br><p>  Let's get to the bottom: </p><br><p>  There is a specific problem: 5k + unit tests pass in 12 minutes - this is twice the installation time of the packages and the build itself. </p><br><p>  This is a lot. </p><br><p>  If you estimate how much time with each assembly it takes on a day - it becomes sad! </p><br><p><img src="https://habrastorage.org/webt/ct/k-/5y/ctk-5yygk9tmehg-4cqo-ko53w0.jpeg" alt="image"></p><br><p>  Picking each test for problems will not change the situation much.  Tests can not be thrown out, and time must be reduced. </p><br><p>  There is a small and handy <a href="https://github.com/rschuft/karma-sharding">karma-sharding</a> plugin that allows you to run multiple browsers in parallel, the distribution of test cases in them will fall on the developer‚Äôs shoulders. </p><br><p>  The usual configuration for unit tests in an angular starter with a webpack and karma looks briefly like this: </p><br><p>  The karma <a href="">config karma.conf.js</a> installs the files that will be processed: </p><br><pre><code class="javascript hljs">files: [ { <span class="hljs-attr"><span class="hljs-attr">pattern</span></span>: <span class="hljs-string"><span class="hljs-string">'./config/spec-bundle.js'</span></span>, <span class="hljs-attr"><span class="hljs-attr">watched</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">pattern</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/assets/**/*'</span></span>, <span class="hljs-attr"><span class="hljs-attr">watched</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">included</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">served</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">nocache</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> } ]</code> </pre> <br><p>  then it connects the preprocessor for the webpack.test.js <a href="">webpack config</a> </p><br><pre> <code class="javascript hljs">preprocessors: { <span class="hljs-string"><span class="hljs-string">'./config/spec-bundle.js'</span></span>: [<span class="hljs-string"><span class="hljs-string">'coverage'</span></span>, <span class="hljs-string"><span class="hljs-string">'webpack'</span></span>, <span class="hljs-string"><span class="hljs-string">'sourcemap'</span></span>] }</code> </pre> <br><p>  Note that the <a href="">spec-bundle.js</a> file appears twice. </p><br><p>  Inside this file the following happens: </p><br><p>  The first step is to install the necessary dependencies, without which our angular code will not run in the tests: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>.stackTraceLimit = <span class="hljs-literal"><span class="hljs-literal">Infinity</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es6'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'core-js/es7/reflect'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'zone.js/dist/zone'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'zone.js/dist/long-stack-trace-zone'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'zone.js/dist/proxy'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// since zone.js 0.6.15 require('zone.js/dist/sync-test'); require('zone.js/dist/jasmine-patch'); // put here since zone.js 0.6.14 require('zone.js/dist/async-test'); require('zone.js/dist/fake-async-test'); require('rxjs/Rx'); var testing = require('@angular/core/testing'); var browser = require('@angular/platform-browser-dynamic/testing'); testing.TestBed.initTestEnvironment( browser.BrowserDynamicTestingModule, browser.platformBrowserDynamicTesting() );</span></span></code> </pre> <br><p>  The second part of the file is the context for the unit test files.  When building a webpack, it will load all split files on this schedule in this context.  These are the very same unit tests that karma launches: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Ok, this is kinda crazy. We can use the context method on * require that webpack created in order to tell webpack * what files we actually want to require or import. * Below, context will be a function/object with file names as keys. * Using that regex we are saying look in ../src then find * any file that ends with spec.ts and get its path. By passing in true * we say do this recursively */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> testContext = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.context(<span class="hljs-string"><span class="hljs-string">'../src'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, /\.spec\.ts/); <span class="hljs-comment"><span class="hljs-comment">/** * Get all the files, for each file, call the context function * that will require the file and load it up here. Context will * loop and require those spec files here */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requireAll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">requireContext</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> requireContext.keys().map(requireContext); } <span class="hljs-comment"><span class="hljs-comment">/** * Requires and returns all modules that match */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modules = requireAll(testContext);</code> </pre> <br><p>  Since in the development mode we do not need to run all the tests at once, one module is enough, then problems with the test run time are not necessary for such a module.  Everything happens fast enough. </p><br><p>  Those 12 minutes is a production / test build.  Consider this case. </p><br><p>  To solve the problem, we will parallelize all tests for N browsers.  Connecting the karma-sharding plugin does not require large manipulations: </p><br><p>  First, adding karma to frameworks </p><br><pre> <code class="javascript hljs">frameworks: [..., <span class="hljs-string"><span class="hljs-string">'sharding'</span></span>]</code> </pre> <br><p>  Secondly, this is the addition of the <a href="https://github.com/rschuft/karma-sharding">config of the plugin itself.</a> </p><br><pre> <code class="javascript hljs">sharding: { <span class="hljs-attr"><span class="hljs-attr">specMatcher</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/(spec|test)s?\.js/i</span></span>, <span class="hljs-attr"><span class="hljs-attr">base</span></span>: <span class="hljs-string"><span class="hljs-string">'/base'</span></span>, <span class="hljs-attr"><span class="hljs-attr">getSets</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">config, basePath, files</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// splitForBrowsers - some util function return splitForBrowsers(files.served) .map(oneBrowserSet =&gt; [someInitScript].concat(oneBrowserSet)); } }</span></span></code> </pre> <br><p>  By default, the config can be not defined.  But then it will work only for the basic configuration, when there are several files with tests: </p><br><pre> <code class="javascript hljs">[a1.spec.js, a2.spec.js, ‚Ä¶ aN.spec.js]</code> </pre> <br><p>  then the set for N browsers looks like this: </p><br><pre> <code class="javascript hljs">[a1.spec.js], [a2.spec.js], ‚Ä¶ [aN.spec.js]</code> </pre> <br><p>  and for N / 2, respectively: </p><br><pre> <code class="javascript hljs">[a1.spec.js, a2.spec.js], [a3.spec.js, a4.spec.js], ‚Ä¶ [aN<span class="hljs-number"><span class="hljs-number">-1.</span></span>spec.js, aN.spec.js]</code> </pre> <br><p>  and then everything is simple, but not in our case with Angular and webpack.  One test file consists of two parts: </p><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> -   <span class="hljs-comment"><span class="hljs-comment">//some setup code 2 -  - //require.context('../src', true, /\.spec\.ts/);</span></span></code> </pre> <br><p>  When testing the entire application, we need several such files with different sets of tests, however, the assembly of such files will take a lot of time, since it does not happen instantly.  For example, the resulting code converted into webpack modules of such necessary dependencies approaches 100k lines. </p><br><p>  But we will cut! </p><br><p>  That is, we will divide each such independent file into two parts: the first is all the necessary dependencies and settings ‚Äî setup.js, and the second is the test suite connected via the webpack context ‚Äî testsN.js.  Since setup.js is a common set of installations, the same for all sets of test cases, such a file will be one. </p><br><p>  As a result, we should have the following set of files: </p><br><p>  setup.js <br>  tests1.js <br>  tests2.js <br>  ... <br>  testsN.js </p><br><p>  Which we need to collect in the following sets: </p><br><pre> <code class="javascript hljs">[setup.js, tests1.js], [setup.js, tests2.js], ‚Ä¶ [setup.js, testsN.js]</code> </pre> <br><p>  <strong>Step 1</strong> </p><br><p>  First of all, go through the whole code in search of all the necessary files with unit tests and distribute them into several files - testsN.js, depending on how many browsers you plan to use - some N. One such file, for example, the same tests1.js looks like that: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'/Users/guest/test-project/src/modules/accounts/accounts.spec.ts'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'/Users/guest/test-project/src/modules/cards/cards.spec.ts'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'/Users/guest/test-project/src/modules/users/users.spec.ts'</span></span>); ...</code> </pre> <br><p>  Distribution of cases by files of course can be implemented as you please.  In our case, this is an approximately uniform distribution of the number of cases in the * .spec.ts file. </p><br><p>  We collect all necessary files in any folder convenient for us - a certain tmp directory. <br>  After that we set the following enrties to the webpack: </p><br><pre> <code class="javascript hljs">entry: { entry = fs.readdirSync(path.join(tmp)).reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">entries, fileName</span></span></span><span class="hljs-function">) =&gt;</span></span> { entries[fileName] = path.join(tmp, fileName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entries; }, {<span class="hljs-attr"><span class="hljs-attr">setup</span></span>: path.join(tmp, <span class="hljs-string"><span class="hljs-string">'setup.ts'</span></span>)}); },</code> </pre> <br><p>  It is important to <strong>setup</strong> to build as a common chunk, then we can load it before each set of tests. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommonsChunkPlugin({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'setup'</span></span>, <span class="hljs-attr"><span class="hljs-attr">minChunks</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> /setup.test/.test(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.resource) })</code> </pre> <br><p>  So after launching the webpack, we‚Äôll get compiled setup.js and N files with test cases.  This launch will be the first step of two when running tests. </p><br><p>  <strong>Step # 2</strong> </p><br><p>  This is the setting of karma and karma-sharding.  As already presented, the settings are not many.  The most interesting is the function that collects a set of test cases getSets: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {splitArray, isSpecFile} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'karma-sharding/lib/utils'</span></span>); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSets</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">config, basePath, files</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> setupScript = files.served.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function"> =&gt;</span></span> file.path.indexOf(<span class="hljs-string"><span class="hljs-string">'setup'</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> specs = files.served .map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">file</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config.base + file.path) .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filePath</span></span></span><span class="hljs-function"> =&gt;</span></span> isSpecFile(filePath, config.specMatcher) &amp;&amp; !<span class="hljs-regexp"><span class="hljs-regexp">/(setup)/</span></span>.test(filePath)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> splitArray(specs, config.browserCount).map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">set</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> set.concat([config.base + setupScript.path.replace(basePath, <span class="hljs-string"><span class="hljs-string">''</span></span>)]); }); }</code> </pre> <br><p>  The specMatcher config - here we find the compiled setup.js and all the testsN.js files in some tmp directory. </p><br><p>  And that's all - the config for karma is ready. <br>  Further only start webpack for assembly of tests and start karma! </p><br><p>  Well, and of course the numbers: </p><br><p>  <strong>5k + unit tests</strong> <br>  To: with one browser - <strong>12 minutes</strong> <br>  After: on 10 browsers - <strong>3 minutes</strong> </p><br><p>  Four times, Karl !!! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/349332/">https://habr.com/ru/post/349332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349318/index.html">FastTrack Training. "Network Basics". "Understanding the OSI Model". Part two. Eddie Martin December 2012</a></li>
<li><a href="../349320/index.html">Friday: Safety and Paradox of the Survivor</a></li>
<li><a href="../349322/index.html">Quick launch of the Github repository with Angular CLI in your browser</a></li>
<li><a href="../349326/index.html">Tanchiki in the console, article four: "The new server - the new protocol"</a></li>
<li><a href="../349330/index.html">"Hi, Habr" at a frequency of 835 kHz</a></li>
<li><a href="../349334/index.html">Learning to program gets harder</a></li>
<li><a href="../349336/index.html">Woe from Wit, or Why Excellent Writes Unintelligible Code</a></li>
<li><a href="../349338/index.html">"Make beautiful." Visualize learning with Google's Tensorboard</a></li>
<li><a href="../349340/index.html">Study history without studying books</a></li>
<li><a href="../349342/index.html">Instructor's Manual for the book ‚ÄúProgramming: Principles and Practice Using C ++‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>