<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CQRS. Facts and Fallacies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CQRS is an architecture style in which read operations are separated from write operations. The approach was formulated by Greg Young based on the CQS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CQRS. Facts and Fallacies</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4d/f93/26b/d4df9326bc3d3794857462bae9abe30e.svg"></div><br>  CQRS is an architecture style in which read operations are separated from write operations.  The approach was formulated by Greg Young based on the CQS principle proposed by Bertrand Meyer.  Most often (but not always) CQRS is implemented in <a href="https://habrahabr.ru/post/232881/">restricted contexts</a> ( <i>bounded context</i> ) of applications designed on the basis of DDD.  One of the natural reasons for the development of CQRS is the non-symmetrical distribution of the load and complexity of business logic on the read and write subsystems. Most business rules and complex checks are in the write subsystem.  At the same time, data is often read many times more often than they change. <br><br>  Despite the simplicity of the concept, the details of the implementation of the CQRS may differ significantly.  And this is exactly the case when the devil is in the details. <br><a name="habracut"></a><br>
<h2>  From <code>ICommand</code> to <code>ICommandHandler</code> </h2><br>  Many start implementing CQRS with the use of the ‚Äú <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B4%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">team</a> ‚Äù pattern, combining data and behavior in the same class. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PayOrderCommand</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OrderId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> <br>  This complicates the serialization / deserialization of commands and the introduction of dependencies. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PayOrderCommand</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OrderId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PayOrderCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IUnitOfWork unitOfWork</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// WAT? } public void Execute() { //... } }</span></span></code> </pre> <br>  Therefore, the original command is divided into ‚Äúdata‚Äù - DTO and behavior ‚Äúcommand handler‚Äù.  Thus, the ‚Äúcommand‚Äù itself no longer contains dependencies and can be used as a <a href="http://principles-wiki.net/patterns:parameter_object"><i>Parameter Object</i></a> , incl.  as an argument to the controller. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICommandHandler</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T command</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } } public class PayOrderCommand { public int OrderId { get; set; } } public class PayOrderCommandHandler: ICommandHandler&lt;PayOrderCommand&gt; { public void Handle(PayOrderCommand command) { //... } }</span></span></code> </pre><br><blockquote>  If you want to use entities, rather than their Id in commands, so as not to validate inside handlers, you can override the <a href="https://habrahabr.ru/post/346850/">Model Binding</a> , although this approach <a href="https://habrahabr.ru/post/346850/">has shortcomings</a> .  A little later, we will look at how to validate without changing the standard Model Binidng. </blockquote><h2>  Should ICommandHandler always return void? </h2><br>  Handlers do not read, for this there is a read subsystem and part of the Query, so they should always return <code>void</code> .  But what about the Id generated by the database?  For example, we sent the command ‚Äúplace an order‚Äù.  Order number corresponds to its Id from the database.  Id cannot be obtained until the <code>INSERT</code> request is completed.  What people won‚Äôt think up, what to bypass this made-up restriction: <br><br><ol><li>  Call <code>CreateOrderCommandHandler</code> and then <code>IdentityQueryHandler&lt;Order&amp;gt</code> </li><li>  Out - parameters </li><li>  Adding special properties to the command for the return value </li><li>  Developments </li><li>  Waiver of auto-increment Id in favor of Guid.  Guid come in the body of the command and recorded in the database </li></ol><br>  Well, what about validation that cannot be done without a query to the database, for example, the presence in the database of an entity with a given Id or a client‚Äôs account status?  Everything is simple here.  Most often, they simply throw an exception, despite the fact that there is nothing ‚Äúexceptional‚Äù in validation. <br><br>  Greg Young clearly states his position <a href="https://www.youtube.com/watch%3Fv%3DLDW0QWie21s">on this issue</a> (25 minutes): ‚Äú <i>Should the command handler always return</i> <code>void</code> ?  <i>No, the list of errors or an exception may be the result of the execution</i> . ‚Äù  The handler <i>can</i> return the result of the operation.  It should not be engaged in the work of <code>Query</code> - data retrieval, which does not mean that it cannot return a value.  The main limitation on this is your system requirements and the need to use the asynchronous interaction model.  If you know for sure that the command will not be executed synchronously, but instead will be placed in a queue and processed later, do not expect to receive an Id in the context of an HTTP request.  You can get a <code>Guid</code> operation and poll the status, provide a callback or get an answer on the web sockets.  In any case, <code>void</code> or non <code>void</code> in the handler is the least of your problems.  An asynchronous model will make the entire user experience change, including the interface (see how the search for tickets to Ozon or Aviasales looks like). <br><br>  You should not expect that <code>void</code> as a return value will allow the use of a single code base for synchronous and asynchronous models.  The absence of a meaningful return result can be misleading for consumers of your API.  By the way, using exceptions for the control flow, you still return the value from the handler, just do it implicitly, violating the principle of <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">structured programming</a> . <br><br>  Just in case, on one of the <a href="https://dotnext.ru/">DotNext,</a> I asked Dino Esposito's opinion on this.  He agrees with Young: the handler can return a response.  This may not be <code>void</code> , but it must be the result of the operation, not the data from the database.  CQRS is a high-level concept, giving a win in some situations (different requirements for the read and write subsystems), and not a dogma. <br><blockquote>  The distinction between <code>void</code> and <code> void</code> even less noticeable in F #.  The value <code>void</code> in F # corresponds to the type <code>Unit</code> .  <code>Unit</code> in functional programming languages ‚Äã‚Äãis a kind of singleton without values.  Thus, the difference between <code>void</code> and <code> void</code> is due to technical implementation, not abstraction.  Read more about <code>void</code> and <code>unit</code> in <a href="http://blog.ploeh.dk/2018/01/15/unit-isomorphisms/">Mark Siman‚Äôs blog.</a> </blockquote><h2>  And what about Query? </h2><br>  Query in CQRS can somehow remind <a href="http://design-pattern.ru/patterns/query-object.html">Query Object</a> .  However, in reality these are different abstractions.  Query Object - a specialized pattern for generating SQL using an object model.  In .NET, with the advent of <code>LINQ</code> and <code>Expression Trees</code> pattern has lost its relevance.  <code>Query</code> in CQRS is a request for receiving data in a convenient form for the client. <br><br>  By analogy with the <code>Command</code> <code>CommandHandler</code> it is logical to separate <code>Query</code> and <code>QueryHandler</code> .  And in this case, <code>QueryHandler</code> really cannot return <code>void</code> anymore.  If nothing was found on the request, we can return <code>null</code> or use the <a href="http://design-pattern.ru/patterns/special-case.html">Special Case</a> . <br><br>  But what is the fundamental difference between the <code>CommandHandler&lt;TIn, TOut&gt;</code> and <code>QueryHandler&lt;TIn, TOut&gt;</code> ?  Their signatures are the same.  The answer is the same.  The difference in semantics.  <code>QueryHandler</code> returns data and does not change the state of the system.  <code>CommandHandler</code> , on the contrary, changes its state and, <i>possibly</i> , returns the status of the operation. <br><br>  If one semantics is not enough for you, you can make such changes to the interface: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IQuery</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TResult</span></span>&gt; { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IQueryHandler</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TQuery</span></span>, <span class="hljs-title"><span class="hljs-title">TResult</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TQuery</span></span> : <span class="hljs-title"><span class="hljs-title">IQuery</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TResult</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">TResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TQuery query</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  The type <code>TResult</code> additionally emphasizes that the query has a return value and even binds it to it.  I spotted this implementation in the <a href="https://cuttingedge.it/blogs/steven/pivot/entry.php%3Fid%3D91">blog of the</a> developer Simple Injector and co-author of the book Dependency Injection in .NET Stephen van Deyrsen.  In our implementation, we limited ourselves to changing the name of the method from <code>Handle</code> to <code>Ask</code> , so that we can immediately see on the IDE screen that the request is being executed without having to specify the type of the object. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IQueryHandler</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TQuery</span></span>, <span class="hljs-title"><span class="hljs-title">TResult</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">TResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TQuery query</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><h2>  Do we need other interfaces? </h2><br>  At some point it may seem that all other data access interfaces can be put into junk.  We take several <code>QueryHandler'</code> , collect handler for more, more of them, and so on.  <code>QueryHandler'</code> makes sense only if you have separate use cases A and B and you need another use case, which returns A + B data without additional conversions.  By the type of the return value, it is not always obvious that it will return a <code>QueryHandler</code> .  Therefore, it is easy to get confused in interfaces with different generic parameters.  In addition, C # is verbose. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeComplexQueryHandler</span></span> { IQueryHandler&lt;FindUsersQuery, IQueryable&lt;UserInfo&gt;&gt; findUsers; IQueryHandler&lt;GetUsersByRolesQuery, IEnumerable&lt;User&gt;&gt; getUsers; IQueryHandler&lt;GetHighUsageUsersQuery, IEnumerable&lt;UserInfo&gt;&gt; getHighUsage; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeComplexQueryHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IQueryHandler&lt;FindUsersQuery, IQueryable&lt;UserInfo&gt;&gt; findUsers, IQueryHandler&lt;GetUsersByRolesQuery, IEnumerable&lt;User&gt;&gt; getUsers, IQueryHandler&lt;GetHighUsageUsersQuery, IEnumerable&lt;UserInfo&gt;&gt; getHighUsage</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.findUsers = findUsers; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers = getUsers; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getHighUsage = getHighUsage; } }</code> </pre> <br>  It is more convenient to use <code>QueryHandler</code> as an entry point for a specific use case.  And to get data inside create specialized interfaces.  So the code will be more readable. <br><blockquote>  If the idea of ‚Äã‚Äãarranging small functions into large ones does not give you peace of mind, then consider the option of changing the programming language.  In F #, this idea is <a href="https://habrahabr.ru/post/337880/">embodied</a> much better. <br></blockquote><h2>  Can the write subsystem use the read subsystem and vice versa? </h2><br>  Another dogma is that you should never mix write and read subsystems.  Strictly speaking, everything is correct here.  If you wanted to use get data from <code>QueryHandler</code> inside the command handler, it most likely means that you do not need CQRS in this subsystem.  CQRS solves a specific problem: read - the subsystem does not cope with loads. <br><br>  Until recently, one of the most popular questions in the DDD group was: ‚ÄúWe use DDD and we have an annual report here.  When we try to build it, our business logic layer pulls aggregates into RAM and the RAM ends.  How should we be?  Clear as: write an optimized SQL query manually.  The same applies to the visited web resources.  There is no need to raise all the OOP-splendor to get the data, cache and display.  CQRS - offers an excellent watershed: we use domain logic in command handlers, because there are not so many teams and because we want all business rule checks to be executed.  In the read subsystem, on the contrary, it is desirable to bypass the business logic layer, because it slows down. <br><br>  By mixing the read and write subsystems, we lose the watershed.  The meaning of semantic abstraction is lost even at the level of a single repository.  In the case when the read subsystem uses another data storage, there is generally no guarantee that the system is in a consistent state.  Once the relevance of the data is not guaranteed, the meaning of the business layer checks is lost.  Using the write subsystem in the read subsystem is generally contrary to the meaning of the operation: commands, by definition, change the state of the system, but the query does not. <br><br>  Each rule, however, has exceptions.  In <a href="https://www.youtube.com/watch%3Fv%3DLDW0QWie21s">the same video a</a> minute before, Greg gives an example: ‚Äúyou need to load millions of entities to do the calculation.  Will you load all this data into RAM or perform an optimal query? ‚Äù.  If the read subsystem already has a suitable query handler and you are using one data source, no one will put you in jail for calling query from the command handler.  Just keep in your mind the arguments against it. <br><br><h2>  To return from <code>QueryHandler</code> entities or DTO? </h2><br>  DTO.  If the customer requires the entire unit from the database, something is wrong with the customer.  Moreover, as flat data as possible is usually required.  You can start using LINQ and <a href="">Queryable Extensions</a> or <a href="https://github.com/MapsterMapper/Mapster">Mapster</a> during the prototyping phase.  And if necessary, replace the implementation of <code>QueryHandler</code> with <a href="https://github.com/StackExchange/Dapper">Dapper</a> and / or other data storage.  In Simple Injector there is a <a href="http://simpleinjector.readthedocs.io/en/latest/advanced.html">convenient mechanism</a> : you can register all objects that implement the interfaces of open generics from the assembly, and for the rest, leave a fallback with LINQ.  Writing such a configuration once will not have to edit it.  It is enough to add a new implementation to the assembly and the container automatically picks up.  For other generics, the folback will continue to work on the LINQ implementation.  <code>Mapster</code> , by the way, does not require creating profiles for mapping.  If you comply with the agreement in the names of the properties between <code>Entity</code> and <code>Dto</code> projection will be built automatically. <br><blockquote>  We have the following rule with the ‚Äúauto-mapper‚Äù: if you need to write manual mapping and the built-in agreements are not enough, it is better to do without the auto-pager.  Thus, the move to the mapstar was quite simple. </blockquote><br><a name="holistic"></a><h2>  CommandHandler and QueryHandler - <a href="http://scrapbook.qujck.com/holistic-abstractions-take-2/">holistic abstractions</a> </h2><br>  Those.  valid from the beginning to the end of the transaction.  Those.  Typical use is one handler per request.  To access data, it is better to use other mechanisms, for example, the already mentioned <code>QueryObject</code> or <code>UnitOfWork</code> .  By the way, this solves the problem using <code>Query</code> from <code>Command</code> and vice versa.  Just use <code>QueryObject</code> both there and there.  Violation of this rule complicates the management of transactions and connection to the database. <br><br><a name="decorator"></a><h2>  Cross Cutting Concerns and Decorators </h2><br>  CQRS has one big advantage over the standard service architecture: we have only 2 generic interfaces.  This allows you to multiply the usefulness of the template " <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BA%25D0%25BE%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">decorator</a> ".  There are a number of functions that any application needs but are not business logic in the direct sense: logging, error handling, transactionalism, etc.  Traditionally, two options: <br><br><ol><li>  accept and trash business logic with such dependencies and related code </li><li>  look towards AOP: using spoilers at runtime, for example <code>Castle.Dynamic Proxy</code> or rewriting IL at compile time, for example <code>PostSharp</code> </li></ol><br>  The first option is bad for its verbosity and copy-paste.  The second - problems with performance and debugging, dependence on external tools and "magic".  Option with decorators - is somewhere in the middle.  On the one hand, we can take the accompanying logic to the decorators.  On the other hand, there is no magic in it.  All code is written by man and can be debugged. <br><a name="validation"></a><br>  Remember, I promised to solve the problem by validating the input parameters without changing the ModelBinder?  Here is the answer, implement the decorator for validation.  If you are satisfied with the use of exceptions, then throw out the <code>ValidationExcepton</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ValidationQueryHandlerDecorator</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TQuery</span></span>, <span class="hljs-title"><span class="hljs-title">TResult</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IQueryHandler</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TQuery</span></span>, <span class="hljs-title"><span class="hljs-title">TResult</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TQuery</span></span> : <span class="hljs-title"><span class="hljs-title">IQuery</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TResult</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IQueryHandler&lt;TQuery, TResult&gt; decorated; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidationQueryHandlerDecorator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryHandler&lt;TQuery, TResult&gt; decorated</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.decorated = decorated; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TQuery query</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> validationContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValidationContext(query, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); Validator.ValidateObject(query, validationContext, validateAllProperties: <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.decorated.Handle(query); } }</code> </pre> <br>  If not, you can make a small wrapper and use <a href="https://habrahabr.ru/post/347284/">Result</a> as the return value. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ResultQueryHandler</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TSource</span></span>, <span class="hljs-title"><span class="hljs-title">TDestination</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IQueryHandler</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TSource</span></span>, <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TDestination</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IQueryHandler&lt;TSource, TDestination&gt; _queryHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResultQueryHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryHandler&lt;TSource, TDestination&gt; queryHandler</span></span></span><span class="hljs-function">)</span></span> { _queryHandler = queryHandler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Result&lt;TDestination&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TSource param</span></span></span><span class="hljs-function">)</span></span> =&gt; Result.Succeed(_queryHandler.Ask(param)); }</code> </pre><br>  SimpleInjector offers a convenient way to <a href="http://simpleinjector.readthedocs.io/en/latest/advanced.html">register open generics and decorators</a> .  With just one line of code, you can insert logging before executing, after executing, hang global transactionality, error handling, automatic subscription to domain events.  The main thing is not to overdo it. <br><br>  There is a certain inconvenience with two interfaces <code>IQueryHandler</code> and <code>ICommandHandler</code> .  If we want to enable logging or validation in both subsystems, we will have to write two decorators, with the same code.  Well, this is not a typical situation.  In the read subsystem, transactionism is hardly required.  Nevertheless, examples with validation and logging are quite vital.  You can solve this problem by moving from interfaces to delegates. <br><a name="delegat"></a><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ResultCommandQueryHandlerDecorator</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TSource</span></span>, <span class="hljs-title"><span class="hljs-title">TDestination</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IQueryHandler</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TSource</span></span>, <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TDestination</span></span>&gt;&gt; , <span class="hljs-title"><span class="hljs-title">ICommandHandler</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TSource</span></span>, <span class="hljs-title"><span class="hljs-title">Result</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TDestination</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Func&lt;TSource, Result&lt;TDestination&gt;&gt; _func; <span class="hljs-comment"><span class="hljs-comment">//      protected ResultCommandQueryCommandHandlerDecorator( Func&lt;TSource, Result&lt;TDestination&gt;&gt; func) { _func = func; } //  Query protected ResultCommandQueryCommandHandlerDecorator( IQueryHandler&lt;TSource, Result&lt;TDestination&gt;&gt; query) : this(query.Ask) { } //  Command protected ResultCommandQueryCommandHandlerDecorator( ICommandHandler&lt;TSource, Result&lt;TDestination&gt;&gt; query) : this(query.Handle) { } protected abstract Result&lt;TDestination&gt; Decorate( Func&lt;TSource, Result&lt;TDestination&gt;&gt; func, TSource value); public Result&lt;TDestination&gt; Ask(TSource param) =&gt; Decorate(_func, param); public Result&lt;TDestination&gt; Handle(TSource command) =&gt; Decorate(_func, command); }</span></span></code> </pre> <br>  Yes, in this case there is also a small overhead: you have to declare two classes only for casting the parameter passed to the constructor.  This can also be solved by complicating the configuration of the IOC container, but it is easier for me to declare two classes. <br><br>  An alternative is to use the <code>IRequestHandler</code> interface for <code>Command</code> and <code>Query</code> , and not to be confused to use naming convention.  This approach is implemented in the <a href="https://github.com/jbogard/MediatR/wiki">MediatR</a> library. </div><p>Source: <a href="https://habr.com/ru/post/347908/">https://habr.com/ru/post/347908/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347898/index.html">How to catch a programmer on cheating and is it worth doing?</a></li>
<li><a href="../347900/index.html">All about overriding in Java</a></li>
<li><a href="../347902/index.html">I cry and I cry: How not to overpay for licenses for a DBMS?</a></li>
<li><a href="../347904/index.html">Object movement to a point in Unity3D</a></li>
<li><a href="../347906/index.html">7 sins when working with requirements in the pre-project</a></li>
<li><a href="../347910/index.html">[BugBounty] Disclosing 5 million links to private Telegram chats and the ability to edit any article telegra.ph</a></li>
<li><a href="../347912/index.html">The most harmful advice. How to implement</a></li>
<li><a href="../347914/index.html">Technical duty and its habitat</a></li>
<li><a href="../347916/index.html">Examine pattern matching in C # 7</a></li>
<li><a href="../347918/index.html">Animations in Android on the shelves (Part 1. Basic animations)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>