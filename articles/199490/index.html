<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create an ELF file with debug information (DWARF) manually (for ARM microcontrollers)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Recently, I became interested in microcontrollers. First AVR, then ARM. There are two main options for programming microcontrollers: as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create an ELF file with debug information (DWARF) manually (for ARM microcontrollers)</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Recently, I became interested in microcontrollers.  First AVR, then ARM.  There are two main options for programming microcontrollers: assembler and C. However, I am a fan of the <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D1%2582_%2528%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F%2529">Fort</a> programming language and started porting it to these microcontrollers.  Of course, there are ready-made solutions, but none of them contained what I wanted: debugging with gdb.  And I set out to fill this gap (so far only for ARM).  I had a <a href="http://www.st.com/web/en/catalog/tools/FM116/SC959/SS1532/PF250863">stm32vldiscovery</a> board with a 32-bit ARM Cortex-M3 processor, 128kB flash and 8 kB RAM, so I started with it. <br>  I wrote Fort cross-translator of course on Forte, and the code in the article will not be, since this language is considered exotic.  I confine myself to quite detailed recommendations.  There are almost no documentation and examples in the network on the subject, some parameters were selected by me through trial and error, some by analyzing the gcc compiler output files.  In addition, I used only the necessary minimum of debugging information, without touching, for example, relocations and many other things.  The topic is very extensive and, I confess, I only dealt with it by 30 percent, which turned out to be sufficient for me. <br><a name="habracut"></a><br>  Anyone interested in this project can download the code <a href="http://oco.org.ua/m3forth/">here</a> . <br><br><h4>  ELF Overview </h4><br>  Standard development tools compile your program into an <a href="http://ru.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF (Executable and Linkable Format)</a> file with the ability to include debug information.  The format specification can be read <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf">here</a> .  In addition, each architecture has its own characteristics, for example <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044b/IHI0044B_aaelf.pdf">, ARM</a> .  Consider briefly this format. <br>  The ELF executable file consists of the following parts: <br><h5>  1. Title (ELF Header) </h5><br>  Contains general information about the file and its main characteristics. <br><h5>  2. Program Header Table </h5><br>  This is a table of correspondence of sections of a file to memory segments, indicates to the loader, in which area of ‚Äã‚Äãmemory to write each section. <br><h5>  3. Sections </h5><br>  Sections contain all the information in the file (program, data, debug information, etc.) <br>  Each section has a type, name, and other parameters.  The ".text" section usually stores code, the ".symtab" is the program symbol table (file names, procedures and variables), the ".strtab" is the string table, the sections with the ".debug_" prefix are debug information and t .d  In addition, the file must necessarily have an empty section with index 0. <br><br><h5>  4. Section Header Table </h5><br>  This is a table containing an array of section headers. <br>  The format is discussed in more detail in the Create ELF section. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  DWARF Overview </h4><br>  <a href="http://en.wikipedia.org/wiki/DWARF">DWARF</a> is a standardized debugging information format.  <a href="http://dwarfstd.org/doc/DWARF4.pdf">Standard</a> can be downloaded from the <a href="http://dwarfstd.org/">official site</a> .  There is also a wonderful short format review: <a href="http://dwarfstd.org/doc/Debugging%2520using%2520DWARF-2012.pdf">Introduction to the DWARF Debugging Format</a> (Michael J. Eager). <br>  Why do you need debug information?  It allows you to: <br><ul><li>  set breakpoints not on the physical address, but on the line number in the source code file or on the function name </li><li>  display and change values ‚Äã‚Äãof global and local variables, as well as function parameters </li><li>  show call stack (backtrace) </li><li>  execute the program step by step not by one instruction of the assembler, but by the source code lines </li></ul><br>  This information is stored in a tree structure.  Each node in the tree has a parent, may have children, and is called a DIE (Debugging Information Entry).  Each node has its own tag (type) and a list of attributes (properties) describing the node.  Attributes can contain anything, such as data or links to other nodes.  In addition, there is information stored outside the tree. <br>  Nodes are divided into two main types: nodes describing data, and nodes describing code. <br><h5>  Nodes describing the data: </h5><br><ol><li>  Data types: <br><ul><li>  Basic data types (node ‚Äã‚Äãtype DW_TAG_base_type), for example, such as the int type in C. </li><li>  Composite data types (pointers, etc.) </li><li>  Arrays </li><li>  Structures, classes, unions, interfaces </li></ul><br></li><li>  Data objects: <br><ul><li>  constants </li><li>  function parameters </li><li>  variables </li><li>  etc. </li></ul><br></li></ol><br>  Each data object has a DW_AT_location attribute that indicates how the address where the data is located is calculated.  For example, a variable may have a fixed address, be in a register or on a stack, be a member of a class or an object.  This address can be calculated in a rather complicated way, therefore the standard provides for so-called Location Expressions, which may contain a sequence of statements of a special internal stack machine. <br><br><h5>  Nodes describing the code: </h5><br><ol><li>  Procedures (functions) are nodes with the DW_TAG_subprogram tag.  Descendant nodes can contain descriptions of variables - function parameters and function local variables. </li><li>  Compilation Unit.  Contains information to the program and is the parent of all other nodes. </li></ol><br>  The information described above is in the ".debug_info" and ".debug_abbrev" sections. <br><br><h5>  Other information: </h5><br><ul><li>  Line number information (".debug_line" section) </li><li>  Macro Information (".debug_macinfo" section) </li><li>  Call Frame Information (section ".debug_frame") </li></ul><br><br><h4>  ELF creation </h4><br>  We will create files in the EFL format using the libelf library from the <a href="https://fedorahosted.org/elfutils/">elfutils</a> package.  The network has a good article on using libelf - <a href="http://people.freebsd.org/~jkoshy/download/libelf--/article.html">LibELF by Example</a> (unfortunately, the creation of files in it is described very briefly) as well as <a href="http://www.nxmnpg.com/3/elf">documentation</a> . <br>  Creating a file consists of several steps: <br><ol><li>  Libelf initialization </li><li>  Creating a file header (ELF Header) </li><li>  Creating a Program Header (Program Header Table) </li><li>  Creating sections </li><li>  Write file </li></ol><br>  Consider the stages in more detail. <br><br><h5>  Libelf initialization </h5><br>  First you need to call the function elf_version (EV_CURRENT) and check the result.  If it is equal to EV_NONE, an error has occurred and no further actions can be performed.  Then we need to create the file we need on disk, get its handle and pass it to the elf_begin function: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Elf * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fd, Elf_Cmd cmd, Elf *elf)</span></span></span></span></code> </pre> <br><ul><li>  fd - the handle of the file just opened </li><li>  cmd - mode (ELF_C_READ for reading information, ELF_C_WRITE for writing or ELF_C_RDWR for reading / writing), it should correspond to the mode of the open file (ELF_C_WRITE in our case) </li><li>  elf - only needed for working with archive files (.a), in our case you need to transfer 0 </li></ul><br>  The function returns a pointer to the created descriptor that will be used in all libelf functions, 0 is returned in case of an error. <br><br><h5>  Creating a title </h5><br>  A new file header is created by the elf32_newehdr function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Elf32_Ehdr * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf32_newehdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Elf *elf)</span></span></span></span>;</code> </pre><br><ul><li>  elf - the handle returned by the elf_begin function </li></ul><br>  Returns 0 on error or a pointer to the structure - the header of the ELF file: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EI_NIDENT 16 typedef struct { unsigned char e_ident[EI_NIDENT]; Elf32_Half e_type; Elf32_Half e_machine; Elf32_Word e_version; Elf32_Addr e_entry; Elf32_Off e_phoff; Elf32_Off e_shoff; Elf32_Word e_flags; Elf32_Half e_ehsize; Elf32_Half e_phentsize; Elf32_Half e_phnum; Elf32_Half e_shentsize; Elf32_Half e_shnum; Elf32_Half e_shstrndx; } Elf32_Ehdr;</span></span></code> </pre><br><br><br><br>  Some of its fields are filled in the standard way, some need to be filled to us: <br><ul><li>  e_ident is an identification byte array and has the following indices: <br><ul><li>  EI_MAG0, EI_MAG1, EI_MAG2, EI_MAG3 - these 4 bytes must contain the characters 0x7f, 'ELF', which the function elf32_newehdr has already done for us </li><li>  EI_DATA - indicates the type of data encoding in the file: ELFDATA2LSB or ELFDATA2MSB.  You need to set ELFDATA2LSB like this: e_ident [EI_DATA] = ELFDATA2LSB </li><li>  EI_VERSION - version of the file header, already installed for us </li><li>  EI_PAD - do not touch </li></ul></li><li>  e_type is a file type, it can be ET_NONE - without type, ET_REL is a moveable file, ET_EXEC is an executable file, ET_DYN is a shared object file, etc.  We need to set the file type to ET_EXEC </li><li>  e_machine - the architecture required for this file, for example EM_386 - for Intel architecture, for ARM we need to write EM_ARM (40) here - see <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044b/IHI0044B_aaelf.pdf">ELF for the ARM Architecture</a> </li><li>  e_version - the file version, it is necessary to install it in EV_CURRENT </li><li>  e_entry is the address of the entry point, not necessary for us </li><li>  e_phoff - the offset in the program header file, e_shoff - the offset of the section header, do not fill </li><li>  e_flags - processor-specific flags, for our architecture (Cortex-M3) must be set to 0x05000000 (ABI version 5) </li><li>  e_ehsize, e_phentsize, e_phnum, e_shentsize, e_shnum - do not touch </li><li>  e_shstrndx - contains the number of the section in which there is a table of rows with sections headers.  Since we have no sections yet, we will install this number later. </li></ul><br><br><h5>  Creating a program header </h5><br>  As already mentioned, the program header (Program Header Table) is a table for matching sections of a file to memory segments, which tells the loader where to write each section.  Zagovok created using the function elf32_newphdr: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Elf32_Phdr * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf32_newphdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Elf *elf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span></span>;</code> </pre> <br><ul><li>  elf is our descriptor </li><li>  count - the number of created table elements.  Since we will have only one section (with program code), the count will be equal to 1. </li></ul><br>  Returns 0 on error or a pointer to the program header. <br>  Each element in the header table is described by the following structure: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align; } Elf32_Phdr;</code> </pre> <br><ul><li>  p_type is a segment type (section), here we must indicate PT_LOAD is a loadable segment </li><li>  p_offset - offsets in the file, where the data section starts, which will be loaded into memory.  We have a section .text, which will be located immediately after the file header and program header, the offset we can calculate as the sum of the lengths of these headers.  The length of any type can be obtained using the elf32_fsize function: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> elf32_fsize(Elf_Type type, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> count, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version);</code> </pre>  type - here is the ELF_T_xxx constant, we will need the sizes ELF_T_EHDR and ELF_T_PHDR;  count - the number of elements of the desired type, version - must be set to EV_CURRENT </li><li>  p_vaddr, p_paddr is a virtual and physical address to which the contents of the section will be loaded.  Since we do not have virtual addresses, we set it equal to physical, in the simplest case - 0, because it is here that our program will be loaded. </li><li>  p_filesz, p_memsz - the size of the section in the file and memory.  We have them the same, but since there are no sections with program code yet, we will install them later. </li><li>  p_flags - permissions for loaded memory segment.  There can be PF_R - read, PF_W - write, PF_X - execution or their combination.  Set p_flags to PF_R + PF_X </li><li>  p_align - segment alignment, we have 4 </li></ul><br><h5>  Creating sections </h5><br>  After creating the headers, you can start creating sections.  An empty section is created using the elf_newscn function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Elf_Scn * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_newscn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Elf *elf)</span></span></span></span>;</code> </pre> <br><ul><li>  elf - the handle returned earlier by the elf_begin function </li></ul><br>  The function returns a pointer to the section or 0 on error. <br>  After creating the section, you need to fill in the section header and create a section data descriptor. <br>  We can get a pointer to the section header using the elf32_getshdr function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Elf32_Shdr * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf32_getshdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Elf_Scn *scn)</span></span></span></span>;</code> </pre> <br><ul><li>  scn is a pointer to the section that we received from the elf_newscn function. </li></ul><br>  The section header looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Elf32_Word sh_name; Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize; } Elf32_Shdr;</code> </pre> <br><ul><li>  sh_name - section name - offset in the string table of section headers (.shstrtab section) - see ‚ÄúRow Tables‚Äù below </li><li>  sh_type is the type of the section contents, for the section with the program code you need to set SHT_PROGBITS, for sections with the row table - SHT_STRTAB, for the symbol table - SHT_SYMTAB </li><li>  sh_flags are section flags that can be combined, and of which we need only three: <br><ul><li>  SHF_ALLOC - means that the section will be loaded into memory </li><li>  SHF_EXECINSTR - section contains executable code </li><li>  SHF_STRINGS - section contains a table of rows </li></ul><br>  Accordingly, for the .text section with the program you need to set the flags SHF_ALLOC + SHF_EXINSTR </li><li>  sh_addr - the address where the section will be loaded into memory </li><li>  sh_offset - section offset in the file - do not touch, the library will install for us </li><li>  sh_size - section size - do not touch </li><li>  sh_link - contains the number of the associated section, it is necessary to link the section with the corresponding line table (see below) </li><li>  sh_info - additional information depending on the type of section, set to 0 </li><li>  sh_addralign - alignment of the address, do not touch </li><li>  sh_entsize - if the section consists of several elements of the same length, indicates the length of such an element, do not touch </li></ul><br>  After filling in the header, you need to create a section data descriptor with the elf_newdata function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Elf_Data * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">elf_newdata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Elf_Scn *scn)</span></span></span></span>;</code> </pre> <br><ul><li>  scn - just received a pointer to a new section. </li></ul><br>  The function returns 0 on error, or a pointer to the Elf_Data structure, which will need to be filled: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* d_buf; Elf_Type d_type; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> d_size; <span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> d_off; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> d_align; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> d_version; } Elf_Data;</code> </pre> <br><ul><li>  d_buf - pointer to the data to be written to the section </li><li>  d_type is a data type, ELF_T_BYTE is suitable for us everywhere </li><li>  d_size - data size </li><li>  d_off - offset in the section, set to 0 </li><li>  d_align - alignment, can be set to 1 - without alignment </li><li>  d_version - version, be sure to install in EV_CURRENT </li></ul><br><br><h5>  Special sections </h5><br>  For our purposes, we will need to create the minimum required set of sections: <br><ul><li>  .text - section with program code </li><li>  .symtab - file symbol table </li><li>  .strtab is a string table containing the names of symbols from the .symtab section, since the latter do not store the names themselves, but their indices </li><li>  .shstrtab - a string table containing section names </li></ul><br>  All sections are created as described in the previous section, but each special section has its own characteristics. <br><br><br><h6>  Section .text </h6><br>  This section contains the executable code, so you need to install sh_type in SHT_PROGBITS, sh_flags in SHF_EXECINSTR + SHF_ALLOC, sh_addr - set equal to the address where this code will be loaded <br><h6>  Section .symtab </h6><br>  The section contains the description of all symbols (functions) of the program and the files in which they were described.  It consists of such elements with a length of 16 bytes: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Elf32_Word st_name; Elf32_Addr st_value; Elf32_Word st_size; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> st_info; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> st_other; Elf32_Half st_shndx; } Elf32_Sym;</code> </pre> <br><ul><li>  st_name - the name of the character (the index in the string table .strtab) </li><li>  st_value - value (entry address for the function or 0 for the file).  Since the Cortex-M3 has a command system of Thumb-2, this address must be odd (real address + 1) </li><li>  st_size - the length of the function code (0 for the file) </li><li>  st_info - the type of the symbol and its scope.  There is a macro to determine the value of this field. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ELF32_ST_INFO(b,t) (((b)&lt;&lt;4)+((t)&amp;0xf))</span></span></code> </pre> <br>  where b is the scope and t is the type of symbol <br>  The scope can be STB_LOCAL (the symbol is not visible from other object files) or STB_GLOBAL (visible).  For simplicity, use STB_GLOBAL. <br>  Symbol type - STT_FUNC for the function, STT_FILE for the file </li><li>  st_other - set to 0 </li><li>  st_shndx - the index of the section for which the symbol is defined (the index of the .text section), or SHN_ABS for the file. <br>  The section index from its scn descriptor can be determined using elf_ndxscn: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> elf_ndxscn( Elf_Scn *scn);</code> </pre> <br></li></ul><br>  The data for the section can be collected when traversing the source text into an array, a pointer to which is then written to the section data descriptor (d_buf). <br>  This section is created in the usual way, only sh_type needs to be set to SHT_SYMTAB, and the index of the .strtab section is written to the sh_link field, so these sections will become linked. <br><br><h6>  Section .strtab </h6><br>  In this section are the names of all the characters from the .symtab section.  It is created as a regular section, but sh_type needs to be set to SHT_STRTAB, sh_flags to SHF_STRINGS, so this section becomes a string table. <br>  The data for the section can be collected when traversing the source text into an array, a pointer to which is then written to the section data descriptor (d_buf). <br><br><h6>  .Shstrtab section </h6><br>  Section - a table of lines, contains the headers of all sections of the file, including its own title.  It is created in the same way as the .strtab section.  After creating its index, you need to write to the e_shstrndx field of the file header. <br><br><br><h6>  Row tables </h6><br>  The row tables contain consecutive rows ending in a zero byte, the first byte in this table must also be 0. The row index in the table is just the offset in bytes from the beginning of the table, so the first line of the 'name' has the index 1, the next line ' var 'has an index of 6. <br><pre>  Index 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
        \ 0 name \ 0 var \ 0 
</pre><br><br><h5>  Write file </h5><br>  So, the headers and sections are already formed, now they need to be written to a file and complete the work with libelf.  The record is produced by the function elf_update: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">off_t</span></span> elf_update( Elf *elf, Elf_Cmd cmd);</code> </pre> <br><ul><li>  elf - handle </li><li>  cmd is a command, must be equal to ELF_C_WRITE for writing. </li></ul><br>  The function returns -1 on error.  Error text can be obtained by calling the function elf_errmsg (-1), which will return a pointer to the string with an error. <br>  We finish work with the library with the function elf_end, with which we pass our descriptor.  It remains only to close the previously opened file. <br>  However, our generated file does not contain debugging information, which we will add in the next section. <br><br><h4>  Create DWARF </h4><br>  We will create debug information using the <a href="http://sourceforge.net/projects/libdwarf/">libdwarf</a> library, complete with which is a pdf-file with documentation (libdwarf2p.1.pdf - A Producer Library Interface to DWARF). <br>  Creating debug information consists of the following steps: <br><ol><li>  Initial libdwarf producer </li><li>  Creating nodes (DIE - Debugging Information Entry) </li><li>  Creating node attributes </li><li>  Creating a Compilation Unit </li><li>  Creating Common Information Entry </li><li>  Creating data types </li><li>  Creating procedures (functions) </li><li>  Creating variables and constants </li><li>  Creating sections with debug information </li><li>  Finishing work with the library </li></ol><br>  Consider the stages in more detail. <br><br><h5>  Initial libdwarf producer </h5><br>  We will create debugging information during compilation simultaneously with the creation of symbols in the .symtab section, so the library must be initialized after libelf is initialized, the ELF header and program header are created, before sections are created. <br>  For initialization, we will use the dwarf_producer_init_c function.  There are several other initialization functions in the library (dwarf_producer_init, dwarf_producer_init_b), which differ in some of the nuances described in the documentation.  In principle, you can use any of them. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Debug </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_producer_init_c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_Unsigned flags, Dwarf_Callback_Func_c func, Dwarf_Handler errhand, Dwarf_Ptr errarg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * user_data, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li>  flags - a combination of ‚Äúor‚Äù several constants that determine some parameters, for example, information width, following bytes (little-endian, big-endian), relocation format, from which we definitely need DW_DLC_WRITE and DW_DLC_SYMBOLIC_RELOCATIONS </li><li>  func is a callback function that will be called when creating ELF sections with debug information.  See below in the section ‚ÄúCreating Debug Information Sections‚Äù for more details. </li><li>  errhand - pointer to the function that will be called when errors occur.  Can pass 0 </li><li>  errarg - the data that will be passed to the errhand function can be set to 0 </li><li>  user_data - the data that will be passed to the func function can be set to 0 </li><li>  error - return error code </li></ul><br>  The function returns Dwarf_P_Debug - a descriptor used in all subsequent functions, or -1 in case of an error, while the error will contain an error code (you can get the error message text by its code using the dwarf_errmsg function, passing this code to it) <br><br><br><h5>  Creating Nodes (DIE - Debugging Information Entry) </h5><br>  As described above, debugging information forms a tree structure.  To create a node of this tree, you need: <br><ul><li>  create it with the dwarf_new_die function </li><li>  add attributes to it (each attribute type is added by its function, which will be described later) </li></ul><br>  The node is created using the dwarf_new_die function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Die </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_new_die</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_Tag new_tag, Dwarf_P_Die parent, Dwarf_P_Die child, Dwarf_P_Die left_sibling, Dwarf_P_Die right_sibling, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li>  dbg - Dwarf_P_Debug handle obtained during library initialization </li><li>  new_tag - node tag (type) - constant DW_TAG_xxxx, which can be found in the file libdwarf.h </li><li>  parent, child, left_sibling, right_sibling - parent, descendant, left and right neighbors of the node, respectively.  It is not necessary to specify all these parameters, it is enough to specify one, put 0 instead of the others. If all parameters are 0, the node will be either root or isolated </li><li>  error - will contain an error code when it occurs </li></ul><br>  The function returns the DW_DLV_BADADDR on error or the handle of the Dwarf_P_Die node if successful. <br><br><h5>  Creating node attributes </h5><br>  To create node attributes there is a whole family of functions dwarf_add_AT_xxxx.  Sometimes it‚Äôs problematic to determine which function needs to create the necessary attribute, so I‚Äôve even dug into the library source code several times.  Some of the features will be described here, some below in the relevant sections.  All of them accept the ownerdie parameter ‚Äî the handle of the node to which the attribute will be added, and return an error code in the error parameter. <br>  The dwarf_add_AT_name function adds a ‚Äúname‚Äù attribute (DW_AT_name) to the node.  Most nodes should have a name (for example, procedures, variables, constants), some names may not be (for example, the Compilation Unit) <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Attribute </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_AT_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Die ownerdie, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li>  name - attribute value itself (node ‚Äã‚Äãname) </li></ul><br>  Returns DW_DLV_BADADDR on error or attribute handle on success. <br>  The functions dwarf_add_AT_signed_const, dwarf_add_AT_unsigned_const add to the node the specified attribute and its signed (unsigned) value.  Character and unsigned attributes are used to set constant values, sizes, line numbers, etc.  Format of functions: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Attribute </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_AT_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(un)</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signed_const</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_P_Die ownerdie, Dwarf_Half attr, Dwarf_Signed value, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li>  dbg - Dwarf_P_Debug handle obtained during library initialization </li><li>  attr - the attribute whose value is set, is the constant DW_AT_xxxx, which can be found in the file libdwarf.h </li><li>  value - attribute value </li></ul><br>  Return DW_DLV_BADADDR in the event of an error or attribute handle on successful completion. <br><br><h5>  Creating a Compilation Unit </h5><br>  There must be a root in any tree - we have a compilation unit that contains information about the program (for example, the name of the main file, the programming language used, the name of the compiler, the sensitivity of characters (variables, functions) to the register, the main function of the program, the starting address and. etc.)  In principle, no attributes are required.  For example, create information about the main file and compiler. <br><br><h6>  Main file information </h6><br>  To store information about the main file, the ‚Äúname‚Äù attribute (DW_AT_name) is used, use the dwarf_add_AT_name function, as shown in the ‚ÄúCreating node attributes‚Äù section. <br><br><h6>  Compiler info </h6><br>  Use the dwarf_add_AT_producer function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Attribute </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_AT_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Die ownerdie, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *producer_string, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li>  producer_string - a string with text information </li></ul><br>  Returns DW_DLV_BADADDR on error or attribute handle on success. <br><br><h5>  Creating Common Information Entry </h5><br>  Usually, when a function (subroutine) is called, its parameters and the return address are pushed onto the stack (although each compiler can do it in its own way), all this is called a call frame.  The debugger needs information about the frame format in order to correctly determine the return address from a function and build a backtrace - a chain of function calls that led us to the current function, and the parameters of these functions.  Also usually indicated processor registers, which are stored on the stack.  The code that reserves space on the stack and keeps the registers of the processor is called the function prologue, the code restoring registers and the stack is called the epilogue. <br>  This information is highly dependent on the compiler.  For example, the prologue and epilogue need not necessarily be at the very beginning and end of a function;  sometimes the frame is used, sometimes not;  processor registers can be stored in other registers, etc. <br>  So, the debugger needs to know how the processor registers change their value and where they will be saved when entering the procedure.  This information is called Call Frame Information - information about the format of the frame.  For each address in the program (containing the code), the frame's memory address (Canonical Frame Address - CFA) and information about processor registers are indicated, for example, you can specify that: <br><ul><li>  the register is not stored in the procedure </li><li>  the register does not change its value in the procedure </li><li>  the register is stored on the stack at the address CFA + n </li><li>  the register is saved in another register </li><li>  the register is stored in memory at some address, which can be calculated in a rather non-obvious way </li><li>  etc. </li></ul><br>  Since the information must be indicated for each address in the code, it is very voluminous and is stored in a compressed form in the .debug_frame section.  Since it changes little from address to address, only its changes are encoded in the form of instructions DW_CFA_xxxx.  Each instruction points to one change, for example: <br><ul><li>  DW_CFA_set_loc - indicates the current address in the program </li><li>  DW_CFA_advance_loc - advances the pointer to a certain number of bytes </li><li>  DW_CFA_def_cfa - specifies the address of the stack frame (numeric constant) </li><li>  DW_CFA_def_cfa_register - specifies the address of the stack frame (taken from the processor register) </li><li>  DW_CFA_def_cfa_expression - specifies how to calculate the address of the stack frame </li><li>  DW_CFA_same_value - indicates that the register does not change </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DW_CFA_register - indicate that the register is stored in another register </font></font></li><li>  etc. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elements of the .debug_frame section are two types of records: Common Information Entry (CIE) and Frame Description Entry (FDE). </font><font style="vertical-align: inherit;">The CIE contains information that is common to many FDE records, roughly speaking it describes a certain type of procedure. </font><font style="vertical-align: inherit;">FDE also describes each specific procedure. </font><font style="vertical-align: inherit;">When entering the procedure, the debugger first executes instructions from the CIE, and then from the FDE. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My compiler creates procedures in which the CFA is in the sp (r13) register. </font><font style="vertical-align: inherit;">Create a CIE for all procedures. </font><font style="vertical-align: inherit;">For this there is a function dwarf_add_frame_cie:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Unsigned </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_frame_cie</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *augmenter, Dwarf_Small code_align, Dwarf_Small data_align, Dwarf_Small ret_addr_reg, Dwarf_Ptr init_bytes, Dwarf_Unsigned init_bytes_len, Dwarf_Error *error)</span></span></span></span>;</code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">augmenter is a UTF-8 encoded string, the presence of which indicates that there is additional platform-specific information to the CIE or FDE. </font><font style="vertical-align: inherit;">Put an empty string</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code_align - code alignment in bytes (we have 2) </font></font></li><li> data_align ‚Äî     ( -4,       4         ) </li><li> ret_addr_reg ‚Äî ,      (  14) </li><li> init_bytes ‚Äî ,   DW_CFA_.  ,      .         elf-,     ,    .      3 : 0x0C, 0x0D, 0,    DW_CFA_def_cfa: r13 ofs 0 (CFA    r13,   0) </li><li> init_bytes_len ‚Äî   init_bytes </li></ul><br>   DW_DLV_NOCOUNT     CIE,       FDE   ,       ¬´ FDE ¬ª <br><br><h5>    </h5><br>  ,     ,    ,   .    ,        (   int, double  .),     . <br>   ‚Äî     DW_TAG_base_type.     : <br><ul><li> ¬´¬ª (DW_AT_name) </li><li> ¬´¬ª (DW_AT_encoding) ‚Äî ,        (, DW_ATE_boolean ‚Äî , DW_ATE_float ‚Äî   , DW_ATE_signed ‚Äî  , DW_ATE_unsigned ‚Äî    .) </li><li> ¬´¬ª (DW_AT_byte_size ‚Äî     DW_AT_bit_size ‚Äî   ) </li></ul><br>       . <br> ,   32-     ¬´int¬ª,        DW_TAG_base_type     DW_AT_name ‚Äî ¬´int¬ª, DW_AT_encoding ‚Äî DW_ATE_signed, DW_AT_byte_size ‚Äî 4. <br>         .      DW_AT_type ‚Äî     .    int ‚Äî    DW_TAG_pointer_type     DW_AT_type      ¬´int¬ª. <br>         dwarf_add_AT_reference: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Attribute </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_AT_reference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_P_Die ownerdie, Dwarf_Half attr, Dwarf_P_Die otherdie, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li> attr ‚Äî ,    DW_AT_type </li><li> otherdie ‚Äî   ,    </li></ul><br><br><h5>   </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create procedures, I need to clarify one more type of debugging information - information about line numbers (Line Number Information). </font><font style="vertical-align: inherit;">It serves to compare each machine instruction to a specific line of source code, as well as to enable the program to debug the program in-line. </font><font style="vertical-align: inherit;">This information is stored in the .debug_line section. </font><font style="vertical-align: inherit;">If we had enough space, then it would be stored as a matrix, one line for each instruction with such columns:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source file name </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> line number in this file </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> column number in file </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the instruction the beginning of the statement or statement block </font></font></li><li>  etc. </li></ul><br>      ,    . -,   ,  -,    ,     .        ,      ,   ¬´¬ª  .    ,  : DW_LNS_advance_pc ‚Äî      , DW_LNS_set_file ‚Äî  ,    , DW_LNS_const_add_pc ‚Äî        .. <br>        ,    libdwarf   ,   . <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is expensive to store the file name for each instruction, so instead of the name its index is stored in a special table. </font><font style="vertical-align: inherit;">To create a file index, use the dwarf_add_file_decl function:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Unsigned </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_file_decl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name, Dwarf_Unsigned dir_idx, Dwarf_Unsigned time_mod, Dwarf_Unsigned length, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> name - file name </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dir_idx - index of the folder where the file is located. </font><font style="vertical-align: inherit;">The index can be obtained using the dwarf_add_directory_decl function. </font><font style="vertical-align: inherit;">If full paths are used, you can put 0 as the folder index and not use dwarf_add_directory_decl at all</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> time_mod - file modification time, can be omitted (0) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> length - file size, also optional (0) </font></font></li></ul><br>      DW_DLV_NOCOUNT  . <br>          dwarf_add_line_entry_b, dwarf_lne_set_address, dwarf_lne_end_sequence,    . <br>         : <br><ul><li>      .symtab </li><li>      </li><li>  FDE  </li><li>    </li><li>      </li></ul><br><br><h6>    </h6><br>         ¬´ .symtab¬ª.               .    ,  .     ,        ,      . <br><br><h6>      </h6><br>       dwarf_new_die (.  ¬´ ¬ª),     DW_TAG_subprogram,     ‚Äî Compilation Unit (   )   DIE ( ).   : <br><ul><li>   ( dwarf_add_AT_name, . ¬´  ¬ª) </li><li>    ,     ( DW_AT_decl_line),  dwarf_add_AT_unsigned_const (. ¬´  ¬ª) </li><li>    ( DW_AT_decl_file),  dwarf_add_AT_unsigned_const (. ¬´  ¬ª) </li><li>    ( DW_AT_low_pc),  dwarf_add_AT_targ_address, .  </li><li>    ( DW_AT_high_pc),  dwarf_add_AT_targ_address, .  </li><li>     ( DW_AT_type ‚Äî     , . ¬´  ¬ª).      ‚Äî      </li></ul><br>  DW_AT_low_pc  DW_AT_high_pc        dwarf_add_AT_targ_address_b: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Attribute </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_AT_targ_address_b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_P_Die ownerdie, Dwarf_Half attr, Dwarf_Unsigned pc_value, Dwarf_Unsigned sym_index, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li> attr ‚Äî  (DW_AT_low_pc  DW_AT_high_pc) </li><li> pc_value ‚Äî   </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sym_index - the index of the procedure symbol in the .symtab table. </font><font style="vertical-align: inherit;">Optional, you can pass 0</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The function will return DW_DLV_BADADDR on error. </font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creating an FDE procedure </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As mentioned above in the ‚ÄúCreating a Common Information Entry‚Äù section, for each procedure you need to create a frame descriptor, which happens in several steps: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> creating a new FDE (see Creating a Common Information Entry) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> joining the created FDE to the common list </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adding instructions to the generated fde </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can create a new FDE with the dwarf_new_fde function: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Fde </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_new_fde</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function will return a handle to a new FDE or DW_DLV_BADADDR on error. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can attach a new FDE to the list using dwarf_add_frame_fde:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Unsigned </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_frame_fde</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_P_Fde fde, Dwarf_P_Die die, Dwarf_Unsigned cie, Dwarf_Addr virt_addr, Dwarf_Unsigned code_len, Dwarf_Unsigned sym_idx, Dwarf_Error* error)</span></span></span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fde - just received handle </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die - DIE procedure (see Creating a procedure node with attributes) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cie - the CIE descriptor (see Creating the Common Information Entry) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virt_addr - the starting address of our procedure </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code_len - procedure length in bytes </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sym_idx - character index (optional, you can specify 0) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function will return DW_DLV_NOCOUNT on error. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After all this, you can add DW_CFA_xxxx instructions to our FDE. </font><font style="vertical-align: inherit;">This is done by the dwarf_add_fde_inst and dwarf_fde_cfa_offset functions. </font><font style="vertical-align: inherit;">The first one adds the specified instruction to the list:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Fde </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_fde_inst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Fde fde, Dwarf_Small op, Dwarf_Unsigned val1, Dwarf_Unsigned val2, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fde - the descriptor of the created FDE </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> op - instruction code (DW_CFA_xxxx) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> val1, val2 - instruction parameters (different for each instruction, see Standard, section 6.4.2 Call Frame Instructions) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The dwarf_fde_cfa_offset function adds the DW_CFA_offset statement: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Fde </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_fde_cfa_offset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Fde fde, Dwarf_Unsigned reg, Dwarf_Signed offset, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fde - the descriptor of the created FDE </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reg - the register that is written to the frame </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> offset - its offset in the frame (not in bytes, but in the frame elements, see Creating Common Information Entry, data_align) </font></font></li></ul><br> ,   ,         lr (r14).      DW_CFA_advance_loc   ,  1,     pc  2  (.  Common Information Entry, code_align),   DW_CFA_def_cfa_offset   4 (      4 )    dwarf_fde_cfa_offset   reg=14 offset=1,     r14     -4   CFA. <br><br><h6>    </h6><br>       , . ¬´   ¬ª <br><br><br><h6> C     </h6><br>     : <br><ul><li>        dwarf_lne_set_address </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for each line of code (or machine instruction) we create information about the source code (dwarf_add_line_entry) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at the end of the procedure, we complete the instruction block with the dwarf_lne_end_sequence function </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The dwarf_lne_set_address function sets the address where the block of instructions begins: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Unsigned </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_lne_set_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_Addr offs, Dwarf_Unsigned symidx, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> offs - the address of the procedure (the address of the first machine instruction) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sym_idx - character index (optional, you can specify 0) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Returns 0 (success) or DW_DLV_NOCOUNT (error). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The dwarf_add_line_entry_b function adds source line information to the .debug_line section. </font><font style="vertical-align: inherit;">I call this function for each machine instruction:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Unsigned </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_line_entry_b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_Unsigned file_index, Dwarf_Addr code_offset, Dwarf_Unsigned lineno, Dwarf_Signed column_number, Dwarf_Bool is_source_stmt_begin, Dwarf_Bool is_basic_block_begin, Dwarf_Bool is_epilogue_begin, Dwarf_Bool is_prologue_end, Dwarf_Unsigned isa, Dwarf_Unsigned discriminator, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> file_index - the source code file index obtained earlier by the dwarf_add_file_decl function (see. "Creating Procedures") </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code_offset - the address of the current machine instruction </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lineno - line number in source file </font></font></li><li> column_number ‚Äî       </li><li> is_source_stmt_begin ‚Äî 1         lineno (   1) </li><li> is_basic_block_begin ‚Äî 1        (   0) </li><li> is_epilogue_begin ‚Äî 1        ( ,    0) </li><li> is_prologue_end ‚Äî 1        (!) </li><li> isa ‚Äî instruction set architecture (  ).    DW_ISA_ARM_thumb  ARM Cortex M3! </li><li> discriminator.   (, , )       .           .    ,   0 </li></ul><br>   0 ()  DW_DLV_NOCOUNT (). <br>  ,  dwarf_lne_end_sequence  : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Unsigned </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_lne_end_sequence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_Addr address; Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li> address ‚Äî     </li></ul><br>  0 ()  DW_DLV_NOCOUNT (). <br>     . <br><br><h5>     </h5><br>  ,   .    ,   (  ),         .    ‚Äî      ,   ‚Äî   (    ,       ).   ,   ,      . <br>          ,             ,        .      ,     ‚Äî   (location expressions).   ‚Äî    ( DW_OP_)  -  ,      ,    .      ,       : <br><ul><li> DW_OP_addr ‚Äî    </li><li> DW_OP_fbreg ‚Äî       (  ) </li><li> DW_OP_reg0‚Ä¶ DW_OP_reg31 ‚Äî   ,       </li></ul><br>      ,      (dwarf_new_expr),     (dwarf_add_expr_addr, dwarf_add_expr_gen  .)          DW_AT_location (dwarf_add_AT_location_expression). <br>          0  : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Expr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_new_expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_Error *error)</span></span></span></span></code> </pre> <br>         dwarf_add_expr_gen: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Unsigned </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_expr_gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Expr expr, Dwarf_Small opcode, Dwarf_Unsigned val1, Dwarf_Unsigned val2, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li> expr ‚Äî   ,     </li><li> opcode ‚Äî  ,  DW_OP_ </li><li> val1, val2 ‚Äî   (. ) </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function returns DW_DLV_NOCOUNT on error. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To explicitly set the address of a variable, the dwarf_add_expr_addr function should be used instead of the previous one:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Unsigned </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_expr_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Expr expr, Dwarf_Unsigned address, Dwarf_Signed sym_index, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> expr - the address expression handle to which the instruction is added </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> address - the address of the variable </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sym_index - the index of the character in the .symtab table. </font><font style="vertical-align: inherit;">Optional, you can pass 0</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function also returns DW_DLV_NOCOUNT on error. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, add the created address expression to the node by using the dwarf_add_AT_location_expr function:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_P_Attribute </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_add_AT_location_expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_P_Die ownerdie, Dwarf_Half attr, Dwarf_P_Expr loc_expr, Dwarf_Error *error)</span></span></span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ownerdie - the node to which the expression is added </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attr - attribute (in our case DW_AT_location) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loc_expr - a handle to a previously created address expression </font></font></li></ul><br>      DW_DLV_NOCOUNT  . <br>  (   )   ‚Äî      DW_TAG_variable, DW_TAG_formal_parameter  DW_TAG_const_type .     : <br><ul><li>  / ( dwarf_add_AT_name, . ¬´  ¬ª) </li><li>    ,    ( DW_AT_decl_line),  dwarf_add_AT_unsigned_const (. ¬´  ¬ª) </li><li>    ( DW_AT_decl_file),  dwarf_add_AT_unsigned_const (. ¬´  ¬ª) </li><li>   / ( DW_AT_type ‚Äî     , . ¬´  ¬ª) </li><li>   (. ) ‚Äî       </li><li>   ‚Äî   ( DW_AT_const_value, . ¬´  ¬ª) </li></ul><br><br><br><h5>      </h5><br>            elf-  .     : <br><ul><li>     dwarf_transform_to_disk_form,          elf-      </li><li>     dwarf_get_section_bytes   ,        </li></ul><br>  <br><pre> <code class="cpp hljs">dwarf_transform_to_disk_form ( Dwarf_P_Debug dbg, Dwarf_Error* error)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translates the debug information we created into binary format, but does not write anything to disk. </font><font style="vertical-align: inherit;">It will return us the number of elf sections created or DW_DLV_NOCOUNT on error. </font><font style="vertical-align: inherit;">At the same time, for each section, a callback function will be called, which we passed during library initialization to the dwarf_producer_init_c function. </font><font style="vertical-align: inherit;">This function must be written by us. </font><font style="vertical-align: inherit;">Its specification is as follows:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Dwarf_Callback_Func_c)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, Dwarf_Unsigned type, Dwarf_Unsigned flags, Dwarf_Unsigned link, Dwarf_Unsigned info, Dwarf_Unsigned* sect_name_index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * user_data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* error)</span></span></span></span></code> </pre> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> name - the name of the elf section to create </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> size - section size </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type - section type </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flags - section flags </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> link - section link field </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> info - section information field </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sect_name_index - you need to return the index of the section with relocation (optional) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> user_data - transmitted to us in the same way we set it in the library initialization function </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> error - here you can pass the error code </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this function, we must: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> create a new section (elf_newscn function, see Creating sections) </font></font></li><li>    ( elf32_getshdr,  ) </li><li>    (.  ).  ,         .   sh_addr, sh_offset, sh_entsize   0,  sh_addralign  1 </li><li>     ( elf_ndxscn, . ¬´ .symtab¬ª)  -1   (  error  ) </li><li>      ".rel" (  ),  0     </li></ul><br>    dwarf_transform_to_disk_form     .        0   ,   : <br><ul><li>        dwarf_get_section_bytes: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_get_section_bytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_Signed dwarf_section, Dwarf_Signed *elf_section_index, Dwarf_Unsigned *length, Dwarf_Error* error)</span></span></span></span></code> </pre> <br><ul><li> dwarf_section ‚Äî  .     0..n,  n ‚Äî ,    dwarf_transform_to_disk_form </li><li> elf_section_index ‚Äî   ,      </li><li> length ‚Äî    </li><li> error ‚Äî   </li></ul><br>        0 (  , <br>       ) </li><li>      ( elf_newdata, .  )    (.  ), : <br><ul><li> d_buf ‚Äî   ,      </li><li> d_size ‚Äî    ( ) </li></ul><br></li></ul><br><br><h5>     </h5><br>        libdwarf  dwarf_producer_finish: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Dwarf_Unsigned </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dwarf_producer_finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Dwarf_P_Debug dbg, Dwarf_Error* error)</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function returns DW_DLV_NOCOUNT on error. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I note that writing to disk at this stage is not performed. </font><font style="vertical-align: inherit;">Recording needs to be done through the functions in the ‚ÄúCreate ELF - Write File‚Äù section.</font></font><br><br><br><h4>  Conclusion </h4><br>  That's all. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I repeat, the creation of debug information is a very extensive topic, and I did not touch on many of those, just opening the curtain. </font><font style="vertical-align: inherit;">Those who wish can go to infinity. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have questions - I will try to answer them.</font></font><br><br><br><h4>  Links </h4><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ELF </font></font></h5><br><ul><li> <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Specification</font></font></a> </li><li> <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0044b/IHI0044B_aaelf.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ELF for the ARM Architecture</font></font></a> </li><li> <a href="http://people.freebsd.org/~jkoshy/download/libelf--/article.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libELF by example</font></font></a> </li><li> <a href="https://fedorahosted.org/elfutils/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elfutils</font></font></a> </li><li> <a href="http://www.nxmnpg.com/3/elf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libelf man pages</font></font></a> </li></ul><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DWARF </font></font></h5><br><ul><li> <a href="http://dwarfstd.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offsite</font></font></a> </li><li> <a href="http://dwarfstd.org/doc/DWARF4.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard</font></font></a> </li><li> <a href="http://dwarfstd.org/doc/Debugging%2520using%2520DWARF-2012.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction to the DWARF Debugging Format (Michael J. Eager)</font></font></a> </li><li> <a href="http://sourceforge.net/projects/libdwarf/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libdwarf</font></font></a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/199490/">https://habr.com/ru/post/199490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../199478/index.html">Switching between ISPs on Debian 7</a></li>
<li><a href="../199480/index.html">Nine-year router optimization</a></li>
<li><a href="../199482/index.html">SonataAdminBundle + AJAX file upload</a></li>
<li><a href="../199484/index.html">Testing terminals VCS Huawei TE30</a></li>
<li><a href="../199488/index.html">Data transfer efficiency and information theory</a></li>
<li><a href="../199492/index.html">External resources in Android applications</a></li>
<li><a href="../199494/index.html">Trackball. Say no to "tunnel syndrome"</a></li>
<li><a href="../199496/index.html">RMI means C ++ and boost.preprocessor</a></li>
<li><a href="../199498/index.html">Easy localization of the name of the Windows Phone application</a></li>
<li><a href="../199500/index.html">Something went wrong</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>