<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write numpy-module to accelerate math functions using SIMD instructions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The numpy and scipy packages provide excellent options for quickly solving various computational problems. The concept of universal functions (ufunc),...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write numpy-module to accelerate math functions using SIMD instructions</h1><div class="post__text post__text-html js-mediator-article">  The numpy and scipy packages provide excellent options for quickly solving various computational problems.  The concept of universal functions (ufunc), working with both scalar values ‚Äã‚Äãand arrays of various dimensions, allows us to achieve high performance while maintaining the intrinsic Python language simplicity and elegance.  A universal function is usually used to perform a single operation on a large array of data, which is ideal for optimization using <a href="http://ru.wikipedia.org/wiki/SIMD">SIMD instructions</a> , but I could not find a complete solution based on free software that allows you to use SIMD for calculating mathematical functions like numpy sine, cosine and exponent.  I didn‚Äôt want to implement the algorithms for calculating these functions from scratch, but fortunately there were several free libraries in the C language on the Internet.  Overcoming <s>laziness</s> , I decided to write my own numpy-module, offering universal functions for sine, cosine and exponential functions.  For details and test results, welcome under cat. <br><a name="habracut"></a><br><br><h2>  A bit about SIMD instructions </h2><br>  SIMD instructions allow you to simultaneously perform the same set of operations on several numbers written in one register.  Thus, you can process several numbers at once in one clock cycle and potentially increase productivity by several times. <br>  For example, the <a href="http://ru.wikipedia.org/wiki/AVX">Advanced Vector Extensions (AVX)</a> set of SIMD instructions allows you to perform operations with 256-bit registers, each of which can include eight 32-bit floating-point numbers (single precision numbers) or four 64-bit (double precision numbers) .  The set of operations is rather modest, mainly it is addition, subtraction, multiplication and division.  Accurate and fast implementation of trigonometric functions using these operations is not a trivial task and, in order not to reinvent the wheel, you should use some kind of ready-made library.  In addition to the proprietary <a href="http://en.wikipedia.org/wiki/Intel_MKL">Intel MKL</a> (which already knows how to work with numpy), there were only three options ( <a href="http://software-lisc.fbk.eu/avx_mathfun/">one</a> , <a href="https://bitbucket.org/eschnett/vecmathlib/wiki/Home">two</a> , <a href="http://shibatch.sourceforge.net/">three</a> ). <br>  The first option is a header file with a very modest set of functions, with almost no documentation and tests.  The second option is the C ++ library vecmathlib, which for some reason I stubbornly refused to compile, despite using the recommended GCC-4.7 compiler.  Option promising, but still seems raw.  The third option, the SLEEF library, was found thanks to vecmathlib, which uses its code base.  I immediately liked the variant with the simplicity and clarity of the code, as well as with an abundance of tests. <br><br><h2>  Motivation test </h2><br>  To get enough motivation to write a module, and at the same time to deal with using SLEEF, I decided to compare the speed of calculating the sine in the ‚ÄúC‚Äù language when using SLEEF with the standard math.h.  Naturally, we are talking about the element-by-element calculation of the sine for a large data array. <br>  Unfortunately, there is practically no documentation and examples in SLEEF, but there are quite clearly written tests, so it was easy to understand the use of the library.  <a href="">The source code SLEEF</a> consists of four directories: <code>java</code> , <code>purec</code> , <code>simd</code> and <code>tester</code> .  In addition, there is a README file with a brief description of the library and a general Makefile pulling the Makefile from the listed directories.  Naturally, I was most interested in the <code>simd</code> directory, which, as the name suggests, contained functions optimized using SIMD instructions. <br>  From the Makefile in the <code>simd</code> directory, <code>simd</code> clear that 4 variants of SIMD instructions are supported: <a href="http://en.wikipedia.org/wiki/SSE2">SSE2</a> , <a href="http://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a> , <a href="http://en.wikipedia.org/wiki/AVX2">AVX2</a> and <a href="http://en.wikipedia.org/wiki/FMA4">FMA4</a> .  The function prototypes are defined in the <code>sleefsimd.h</code> file, and the required set of instructions is selected when compiling with the <code>-DENABLE_SSE2</code> , <code>-DENABLE_AVX</code> , <code>-DENABLE_AVX2</code> or <code>-DENABLE_FMA4</code> .  The makefile collects executables for testing functions using each of the instruction sets: <code>iutsse2</code> , <code>iutavx</code> , <code>iutavx2</code> or <code>iutfma4</code> .  These files are called from the universal tester program (from the <code>tester</code> directory) and execute the commands received from the tester.  The implementation of the commands is in the <code>iut.c</code> file, from where the use of the library becomes obvious. <br><div class="spoiler">  <b class="spoiler_title">Sine test function from the simd / iut.c file of the SLEEF source code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xxsin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> s[VECTLENDP]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;VECTLENDP;i++) { s[i] = random()/(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)RAND_MAX*<span class="hljs-number"><span class="hljs-number">20000</span></span><span class="hljs-number"><span class="hljs-number">-10000</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = random() &amp; (VECTLENDP<span class="hljs-number"><span class="hljs-number">-1</span></span>); s[idx] = d; vdouble a = vloadu(s); a = xsin(a); vstoreu(s, a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s[idx]; }</code> </pre><br></div></div><br>  For double precision numbers ( <code>double</code> ), you need to define an array of length <code>VECTLENDP</code> , fill in the arguments of the function of interest and pass it to the <code>vloadu</code> function, which will copy them to the required place for using SIMD and return the value of type <code>vdouble</code> .  We pass the <code>xsin</code> value to the <code>vdouble</code> function, which calculates the sine value for all <code>VECLENDP</code> arguments at once and returns <code>vdouble</code> again.  The result is unpacked into an array from <code>double</code> using the <code>vstoreu</code> function. <br>  For those who want to check the SLEEF on my machine, I cite the full source code of the program, which I wrote to assess the potential acceleration from using SIMD with the help of SLEEF. <br><div class="spoiler">  <b class="spoiler_title">A program to estimate the speed of calculating the sine using SLEEF</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;math.h&gt; #include "sleefsimd.h" #define TESTSIZE (VECTLENDP*10000000) double s[TESTSIZE]; double r1[TESTSIZE]; double r2[TESTSIZE]; #define COUNT 10 int main(int argc, char *argv[]) { int k, i; clock_t t1, t2; double time1, time2; double max, rmax; srandom(time(NULL)); for(i = 0; i &lt; TESTSIZE; i++) { s[i] = random()/(double)RAND_MAX*20000-10000; } printf("Testing sin, %d values\n", TESTSIZE*COUNT); t1 = clock(); for(k = 0; k &lt; COUNT; k++) { for(i = 0; i &lt; TESTSIZE; i++) { r1[i] = sin(s[i]); } } t2 = clock(); time1 = (double)(t2 - t1)/CLOCKS_PER_SEC; printf("Finish sin, spent time = %lg sec\n\n", time1); printf("Testing xsin\n"); t1 = clock(); for(k = 0; k &lt; COUNT; k++) { for(i = 0; i &lt; TESTSIZE; i += VECTLENDP) { vdouble a = vloadu(s+i); a = xsin(a); vstoreu(r2+i, a); } } t2 = clock(); time2 = (double)(t2 - t1)/CLOCKS_PER_SEC; printf("Finish xsin, spent time = %lg sec\n\n", time2); printf("Speed ratio: %lf\n", time1/time2); max = r1[0] - r2[0]; rmax = (r1[0] - r2[0])/r1[0]; for(i = 0; i &lt; TESTSIZE; i++) { double delta = (r1[i] - r2[i]); if(abs(delta) &gt; abs(max)) max = delta; delta = (r1[i] - r2[i])/r1[i]; if(abs(delta) &gt; abs(max)) rmax = delta; } printf("Max absolute delta: %lg, relative delta %lg\n", max, rmax); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  The most advanced set of commands supported on my computer is AVX, so I compiled a program (recorded in the file <code>simd/speedtest.c</code> in the SLEEF sources) with the following command: <br><pre> <code class="bash hljs">gcc -O3 -Wall -Wno-unused -Wno-attributes -DENABLE_AVX -mavx speedtest.c sleefsimddp.c sleefsimdsp.c -o speedtest -lm</code> </pre><br>  I expected the acceleration about 4 times, but the result exceeded all my expectations: <br><pre> <code class="hljs perl">Testing <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>, <span class="hljs-number"><span class="hljs-number">400000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> Finish <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>, spent <span class="hljs-keyword"><span class="hljs-keyword">time</span></span> = <span class="hljs-number"><span class="hljs-number">14.95</span></span> sec Testing xsin Finish xsin, spent <span class="hljs-keyword"><span class="hljs-keyword">time</span></span> = <span class="hljs-number"><span class="hljs-number">1.31</span></span> sec Speed ratio: <span class="hljs-number"><span class="hljs-number">11.412214</span></span> Max absolute delta: <span class="hljs-number"><span class="hljs-number">5.55112</span></span>e-<span class="hljs-number"><span class="hljs-number">17</span></span>, relative delta <span class="hljs-number"><span class="hljs-number">1.58441</span></span>e-<span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre><br>  Acceleration is more than <b>10 times</b> , with a relative error of calculation of less than <b>2 ¬∑ 10 <sup>-16</sup></b> (the order of accuracy of the <code>double</code> itself), on one processor core!  Of course, in a real application, the acceleration will be less, but the motivation for writing your numpy module is already enough. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  A few words about universal functions </h2><br>  In numpy, data is represented as multidimensional arrays.  Universal functions work elementwise with arrays of any dimension, and in the case of several parameters, their dimension may not coincide.  The parameters of the universal function are first reduced to the same dimension in accordance with special rules (this is called <a href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html">Broadcasting</a> ), and then the necessary calculations are performed element by element.  The output is the largest array of dimensions. <br>  For example, the same add function (which is automatically used when using the "+" operator for numpy arrays) allows you to add both two numbers or one-dimensional arrays, and add a number to an array or a one-dimensional array to a two-dimensional one. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> array, add &gt;&gt;&gt; add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; add(array([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>]), array([<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>])) <span class="hljs-comment"><span class="hljs-comment">#       array([5, 7]) &gt;&gt;&gt; add(array([1,2]), 1) #      (..   ) array([2, 3]) &gt;&gt;&gt; add(array([[1,2],[3,4]]), array([1,2])) #      () array([[2, 4], [4, 6]])</span></span></code> </pre><br></div></div><br>  More information on numpy in English can be found in the <a href="http://docs.scipy.org/doc/numpy/reference/">official documentation</a> , in Russian - <a href="http://pyviy.blogspot.ru/2009/09/numpy.html">for example, here</a> . <br><br><h2>  We write our numpy-module with a universal function and SIMD instructions </h2><br>  Numpy and skipy have a fairly convenient API and good documentation, in which for those who want to write their own numpy-module with a universal function there is a corresponding <a href="http://docs.scipy.org/doc/numpy/user/c-info.ufunc-tutorial.html">tutorial</a> .  First, we write a C-function, in a linear cycle, which calculates the value of the mathematical function of interest from a scalar argument: <br><div class="spoiler">  <b class="spoiler_title">The function for calculating the sine in the numpy-module</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double_xsin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **args, npy_intp *dimensions, npy_intp* steps, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data)</span></span></span><span class="hljs-function"> </span></span>{ npy_intp i; npy_intp n = dimensions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *in = args[<span class="hljs-number"><span class="hljs-number">0</span></span>], *out = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; npy_intp in_step = steps[<span class="hljs-number"><span class="hljs-number">0</span></span>], out_step = steps[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> tmp[VECTLENDP]; vdouble a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> slow_n = n % VECTLENDP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(in_step != <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) || out_step != <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)) slow_n = n; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; slow_n; i += VECTLENDP) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; VECTLENDP &amp;&amp; i + j &lt; slow_n; j++) { tmp[j] = *(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *)in; in += in_step; } a = vloadu(tmp); a = xsin(a); vstoreu(tmp, a); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; VECTLENDP &amp;&amp; i + j &lt; slow_n; j++) { *(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *)out = tmp[j]; out += out_step; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n &gt; slow_n) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *in_array = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *)in; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *out_array = (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *)out; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n - slow_n; i += VECTLENDP) { a = vloadu(in_array + i); a = xsin(a); vstoreu(out_array + i, a); } } }</code> </pre><br></div></div><br>  Pointers to input and output numpy passes to us in the <code>args</code> array.  In our case, the function has one input and one output, so the address of the input data is <code>args[0]</code> , the output is <code>args[1]</code> .  The number of elements is passed to <code>dimensions[0]</code> .  To navigate through the input data, you need to increment the pointer by <code>steps[0]</code> , on weekends - by <code>steps[1]</code> (it is important that the pointer is of type <code>char</code> , since <code>steps</code> specify values ‚Äã‚Äãin bytes).  Unfortunately, I was not able to find in the numpy documentation that the values ‚Äã‚Äãin <code>steps</code> should be equal to the sizes of the corresponding data types, although the experiment showed that on my system for arrays of nonzero dimension this rule is fulfilled.  In case of its violation, the calculations will be slower since additional copying of elements into and out of the <code>tmp</code> array is required. <br>  The same universal function in numpy can work with different data types, but a separate C function is written for each data type.  When registering a universal function, we indicate the supported types and for each combination of input and output types we pass a pointer to a C function that will work with this combination: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PyUFuncGenericFunction funcs[] = {&amp;double_xsin}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> types[] = {NPY_DOUBLE, NPY_DOUBLE}; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data[] = {<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>};</code> </pre><br>  In the <code>types</code> array, both input and output types are <code>funcs</code> , so it is longer than the <code>funcs</code> and <code>data</code> arrays.  The array of <code>data</code> pointers allows for each type combination to specify its own additional parameter, which will be passed to C-Functions as the last argument to <code>void* data</code> .  In particular, this can be used to implement different universal functions with one C-function. <br>  To register our universal function, you need to call <code>PyUFunc_FromFuncAndData</code> and pass the arrays described above ( <code>funcs</code> , <code>data</code> and <code>types</code> ), as well as the number of input and output arguments of the universal function, the number of supported type combinations, the name of the function in the module and the documentation string. <br><div class="spoiler">  <b class="spoiler_title">Full module source code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Python.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"numpy/ndarraytypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"numpy/ufuncobject.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"numpy/npy_3kcompat.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sleef/sleefsimd.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* The loop definition must precede the PyMODINIT_FUNC. */</span></span></span><span class="hljs-meta"> static void double_xsin(char **args, npy_intp *dimensions, npy_intp* steps, void* data) { npy_intp i; npy_intp n = dimensions[0]; char *in = args[0], *out = args[1]; npy_intp in_step = steps[0], out_step = steps[1]; double tmp[VECTLENDP]; vdouble a; int slow_n = n % VECTLENDP; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(in_step != sizeof(double) || out_step != sizeof(double)) slow_n = n; for(i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; slow_n; i += VECTLENDP) { int j; for(j = 0; j &lt; VECTLENDP &amp;&amp; i + j &lt; slow_n; j++) { tmp[j] = *(double *)in; in += in_step; } a = vloadu(tmp); a = xsin(a); vstoreu(tmp, a); for(j = 0; j &lt; VECTLENDP &amp;&amp; i + j &lt; slow_n; j++) { *(double *)out = tmp[j]; out += out_step; } } if(n &gt; slow_n) { double *in_array = (double *)in; double *out_array = (double *)out; for(i = 0; i &lt; n - slow_n; i += VECTLENDP) { a = vloadu(in_array + i); a = xsin(a); vstoreu(out_array + i, a); } } } static PyMethodDef AvxmathMethods[] = { {NULL, NULL, 0, NULL} }; static PyUFuncGenericFunction funcs[1] = {&amp;double_xsin}; static char types[] = {NPY_DOUBLE, NPY_DOUBLE}; static void *data[] = {NULL}; void register_xsin(PyObject *module) { PyObject *xsin, *d; import_array(); import_umath(); xsin = PyUFunc_FromFuncAndData(funcs, data, types, 1, 1, 1, PyUFunc_None, "sin", "AVX-accelerated sine calculation", 0); d = PyModule_GetDict(module); PyDict_SetItemString(d, "sin", xsin); Py_DECREF(xsin); } #if PY_VERSION_HEX &gt;= 0x03000000 static struct PyModuleDef moduledef = { PyModuleDef_HEAD_INIT, "avxmath", NULL, -1, AvxmathMethods, NULL, NULL, NULL, NULL }; PyMODINIT_FUNC PyInit_avxmath(void) { PyObject *m; m = PyModule_Create(&amp;moduledef); if (!m) { return NULL; } register_xsin(m); return m; } #else PyMODINIT_FUNC initavxmath(void) { PyObject *m; m = Py_InitModule("avxmath", AvxmathMethods); if (m == NULL) { return; } register_xsin(m); } #endif</span></span></span></span></code> </pre><br></div></div><br>  To build the module, I used the standard <code>setup.py</code> from the <a href="http://docs.scipy.org/doc/numpy/user/c-info.ufunc-tutorial.html">documentation</a> , replacing the module name and adding the SLEEF library C files, compiler and linker flags.  I saved the above source code for the module next to <code>setup.py</code> in a file called <code>avxmath.c</code> , renamed the <code>sleef</code> directory <code>simd</code> from the source code <code>sleef</code> and also put it next to <code>setup.py</code> . <br><div class="spoiler">  <b class="spoiler_title">Setup.py file to build avxmath module</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configuration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parent_package=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">, top_path=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy.distutils.misc_util <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Configuration config = Configuration(<span class="hljs-string"><span class="hljs-string">''</span></span>, parent_package, top_path) config.add_extension(<span class="hljs-string"><span class="hljs-string">'avxmath'</span></span>, [<span class="hljs-string"><span class="hljs-string">'avxmath.c'</span></span>, <span class="hljs-string"><span class="hljs-string">'sleef/sleefsimddp.c'</span></span>, <span class="hljs-string"><span class="hljs-string">'sleef/sleefsimdsp.c'</span></span>], extra_compile_args=[<span class="hljs-string"><span class="hljs-string">'-O3'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wall'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wno-unused'</span></span>, <span class="hljs-string"><span class="hljs-string">'-Wno-attributes'</span></span>, <span class="hljs-string"><span class="hljs-string">'-DENABLE_AVX'</span></span>,<span class="hljs-string"><span class="hljs-string">'-mavx'</span></span>], extra_link_args=[<span class="hljs-string"><span class="hljs-string">'-lm'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> config <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy.distutils.core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> setup setup(configuration=configuration)</code> </pre><br></div></div><br>  To compile without installing to the system, you need to run the <code>python setup.py build_ext --inplace</code> command <code>python setup.py build_ext --inplace</code> , the result of the successful execution of which should be a ready-made module in the <code>avxmath.so</code> file.  Now you can check the performance of our function.  Run python in the same directory as <code>avxmath.so</code> , and check: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> array, pi &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> avxmath &gt;&gt;&gt; avxmath.sin(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-number"><span class="hljs-number">0.0</span></span> &gt;&gt;&gt; avxmath.sin(pi) <span class="hljs-number"><span class="hljs-number">1.2246467991473532e-16</span></span> &gt;&gt;&gt; avxmath.sin([<span class="hljs-number"><span class="hljs-number">0</span></span>, pi/<span class="hljs-number"><span class="hljs-number">2</span></span>, pi, <span class="hljs-number"><span class="hljs-number">3</span></span>*pi/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*pi]) array([ <span class="hljs-number"><span class="hljs-number">0.00000000e+00</span></span>, <span class="hljs-number"><span class="hljs-number">1.00000000e+00</span></span>, <span class="hljs-number"><span class="hljs-number">1.22464680e-16</span></span>, <span class="hljs-number"><span class="hljs-number">-1.00000000e+00</span></span>, <span class="hljs-number"><span class="hljs-number">-2.44929360e-16</span></span>]) &gt;&gt;&gt;</code> </pre><br>  Making sure that the <code>avxmath</code> module <code>avxmath</code> imported and works without errors, you can do a little test of the performance and accuracy of the new function. <br><div class="spoiler">  <b class="spoiler_title">The program for checking the sin function of the avxmath module and the result of its execution</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> avxmath <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random, pi COUNT=<span class="hljs-number"><span class="hljs-number">10</span></span> x = <span class="hljs-number"><span class="hljs-number">2e4</span></span>*random.random(<span class="hljs-number"><span class="hljs-number">40000000</span></span>) - <span class="hljs-number"><span class="hljs-number">1e4</span></span> t = time.clock() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(COUNT): y1 = numpy.sin(x) duration1 = time.clock() - t <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"numpy.sin %f sec"</span></span> % duration1 t = time.clock() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(COUNT): y2 = avxmath.sin(x) duration2 = time.clock() - t <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"avxmath.sin %f sec"</span></span> % duration2 delta = y2 - y1 rdelta = delta/y1 <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"max absolute difference is %lg, relative %lg"</span></span> % ( delta[abs(delta).argmax()], rdelta[abs(rdelta).argmax()]) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"speedup is %lg"</span></span> % (duration1/duration2)</code> </pre><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">numpy</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sin</span></span> 15<span class="hljs-selector-class"><span class="hljs-selector-class">.510000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sec</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">avxmath</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sin</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.260000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sec</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">max</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">absolute</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">difference</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">is</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.22045e-16</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">relative</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.63873e-16</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">speedup</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">is</span></span> 6<span class="hljs-selector-class"><span class="hljs-selector-class">.86283</span></span></code> </pre><br></div></div><br>  So, we received an acceleration of more than <b>6 times</b> with a calculation accuracy no worse than <b>3 ¬∑ 10 <sup>-16</sup></b> !  Replacing the calls of the <code>xsin</code> function <code>xsin</code> a simple copying of memory, it is easy to verify that the acceleration failed 10 times due to the fact that about 1 second of the 2.26 seconds of execution we received was spent on overhead.  Similarly, replacing the <code>xsin</code> function <code>xsin</code> the usual sine from <code>math.h</code> , we find that the computation times using <code>avxmath.sin</code> and <code>numpy.sin</code> in our test will coincide with high accuracy. <br>  Thus, using SIMD instructions, one can achieve a significant acceleration of calculations performed using numpy and scipy, simply by replacing the import of normal functions with optimized ones.  And of course the source code is somewhat expanded compared with this article <code>avxmath</code> module available on Github by <a href="https://github.com/nikolaynag/avxmath">reference</a> . <br>  <b>Upd</b> : Do not use the sine of SLEEF for argument values ‚Äã‚Äãof the order of 1e10 or more (see <a href="http://habrahabr.ru/post/198916/">comment</a> ) </div><p>Source: <a href="https://habr.com/ru/post/198916/">https://habr.com/ru/post/198916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198904/index.html">Part 2. We divide our "pod" into modules. Use someone else's "pod" to develop your</a></li>
<li><a href="../198906/index.html">Network Render in a Blender</a></li>
<li><a href="../198910/index.html">Jug to every city</a></li>
<li><a href="../198912/index.html">Programming language and database Q: syntax does not matter in the enterprise</a></li>
<li><a href="../198914/index.html">Epilogue of the Opera</a></li>
<li><a href="../198918/index.html">linch.me - add annotations to the image</a></li>
<li><a href="../198920/index.html">DARPA begins developing computer security systems capable of independently finding and fixing vulnerabilities</a></li>
<li><a href="../198924/index.html">LinkMeUp. Release 8. IB - Best Practices and Pentesting Laboratories</a></li>
<li><a href="../198928/index.html">How to get an American diploma from higher education</a></li>
<li><a href="../198930/index.html">Pivotal Tracker as a tool in Waterfall development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>