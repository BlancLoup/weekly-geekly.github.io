<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write your own application with Yandex.Disk REST API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Clemens ower, I am developing a desktop version of Yandex.Disk. When the new REST API appeared, I was so impressed with the new oppo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write your own application with Yandex.Disk REST API</h1><div class="post__text post__text-html js-mediator-article">  Hello!  My name is Clemens ower, I am developing a desktop version of Yandex.Disk.  When the new REST API appeared, I was so impressed with the new opportunities that I started writing SDK for it in my spare time for the new Swift language.  I decided to talk about my experience with the new API and made a short talk on how easy it is to start writing your own application with it.  The report was in English, but I also speak Russian, although not so well.  Based on my presentation, I prepared today's post, which was helped by my colleagues. <br><br><video>  http://video.yandex.ru/users/ya-events/view/3334/ </video><br><br>  I would like to start with some general things about Disk - most likely, you have already heard most of this.  Then I will tell you why I was so impressed with the new API and how it differs from WebDAV.  Well, towards the end, I will share the experience of how to start developing for a new API, and will sort out a few examples of my code.  It will be quite a bit, but with the new API, in order to get something to work, there is practically no code to write. <br><a name="habracut"></a><br><h2>  WebDAV vs.  REST </h2><br>  Probably many of you have already wondered what is the difference between WebDAV and REST and what are the advantages of the latter?  At first glance, there is no difference: both there and there you can upload and download files, create folders, move objects, transfer them to the trash and delete them permanently, create lists, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/files/933/4ac/a00/9334aca00a8e422eb177eabdc33f21c7.png" width="500"></div><br>  In general, the main functionality is completely the same.  If you compare the work with public files, then through WebDAV you can make the files public and make them private again.  With folders the same.  That is, you can get a link to a file or folder, and later make it invalid.  The REST API adds new functionality to this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/133/130/af2/133130af2b3b46dc81d8476860ba7985.png" width="500"></div><br>  For example, you can view public file metadata.  Having only a link to the file, in one request to the API you can find out its size and name.  If this is a folder, you can even see the structure of its contents.  And of course, you can save everything to your disk.  It was one of the most popular features after the release of our SDKs.  And finally, we implemented it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1cd/d74/cb5/1cdd74cb55354df9bfb6e6ae5bdeb386.png" width="500"></div><br>  The REST API has added support for working with the basket.  Now you can view the contents of the basket, clear it or restore the necessary files not only through the web interface. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/595/492/56a/59549256ac254b0e9b6506e3b87d3729.png" width="500"></div><br>  Yes, something is really missing.  For example, we did not add basic authentication and do not plan to do this.  In addition, you can access the new API only via HTTPS.  This is done for the sake of user security.  When I gave a talk, it was impossible to get information about the free and used space on the user's disk through the REST API.  Therefore, in the table opposite this item is a cross.  However, now this feature has already appeared.  Many people know that through WebDAV, you can add files without downloading, through hash sums.  On the client side, MD5, SHA are calculated, the file size is added to them, and this information is transmitted to the server.  If a file with the same hash-sums and size is already in the repository, the download does not happen, the file is simply added to your Disk.  Unfortunately, this is not yet in the REST API. <br><br>  When you work through OAuth, all that you have from the user is a token.  But it is sometimes useful to learn more about the user: what is his login, e-mail, etc. You can get this data through a separate API, the description of which is <a href="http://api.yandex.ru/passport/">here</a> .  Using this API, you can get much more information than through WebDAV. <br><br><h2>  Getting to the development </h2><br>  First you need to register the application and create a developer account.  You do not want, as a result of your experiments, anything to happen to the files on your personal Disk.  Next you need to get a token and a little deal with the site.  That's it, you can start writing code. <br><br>  The process of registering an application is quite simple: you go to <a href="https://oauth.yandex.ru/client/new">https://oauth.yandex.ru/client/new</a> and enter the name and description of the application.  The name will later be used as the name of your application folder in the user's Disk.  In the same place, you need to specify which access you need: access to the application folder on the Disk, read or write access to the entire User disk.  If you tick the ‚ÄúClient for development‚Äù checkbox, the callback UI field will be filled with a default URL that does not redirect anywhere, but simply shows you the token.  Mobile developers will most likely use a special URL handler and an application scheme.  Therefore, in this field you can enter just something like my_application: / authoruze, and Yandex.Disk will target your application, and it will appear with one of the parameters of your token. <br><br>  After registering the application, everything is quite simple.  You get the application ID and password.  The most important is the ID, as it is needed to issue tokens to users.  The password is also important, but it depends on how you use the API, how you work with OAuth.  For web services, the password may even be more important. <br><br>  Most likely, you will need several such accounts at once, because you will need to test the ability to transfer files between accounts.  In addition, today it is desirable to use autotests, they may require a couple more accounts.  Just send invites from your personal account.  This is a nice bonus, because for each account you get 500 megabytes on your drive. <br><br>  You can get the token either at the Polygon or via this link: https://oauth.yandex.ru/authorize?response_type_token&amp;client_id=, substituting the ID that you received during registration. <br><br>  You can experiment on the Polygon with all the features of the new API.  At the same time the service is updated simultaneously with it.  So, even if the documentation is lagging behind for a week or a month, all new features will already be on the Polygon.  You can immediately see how each new feature works in combat conditions.  There is also a table with HTTP response codes, which indicate what these or other error messages or successful completion of operations mean.  This is much better than even the most detailed documentation. <br><br>  When all the preparations are over, you can start writing code.  As I said, I myself started writing an SDK for Swift. <br><br><pre><code class="hljs cs">import Foundation <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Disk</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> disk = Disk(token: <span class="hljs-string"><span class="hljs-string">"d8edc4f3a698473fbc87634c41b2ca81"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileURL : NSURL disk.uploadURL(fileURL, toPath: fileURL.lastPathComponent, overwrite: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// handle errors } disk.deletePath(fileURL.lastPathComponent, permanently: false) { // handle response }</span></span></code> </pre> <br>  Talking about it in full does not make sense, so for the demonstration I removed the most difficult and reduced the amount of code to 200 lines.  Making something work is very simple. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Disk</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> token : <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> baseURL = <span class="hljs-string"><span class="hljs-string">"https://cloud-api.yandex.net:443"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> additionalHTTPHeaders : [<span class="hljs-type"><span class="hljs-type">String</span></span>:<span class="hljs-type"><span class="hljs-type">String</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">"Accept"</span></span> : <span class="hljs-string"><span class="hljs-string">"application/json"</span></span>, <span class="hljs-string"><span class="hljs-string">"Authorization"</span></span> : <span class="hljs-string"><span class="hljs-string">"OAuth \(token)"</span></span>, <span class="hljs-string"><span class="hljs-string">"User-Agent"</span></span> : <span class="hljs-string"><span class="hljs-string">"Mobile Camp Demo"</span></span> ] } ]</code> </pre><br>  In this example, I use pure JSON, but I can also use JSON + HAL.  Be sure to register the authorization.  Most questions about Yandex.Disk concern not the API itself, but OAuth.  It turns out that this causes much more difficulties when working with Disk than the API itself.  So, if you‚Äôve gotten the hang of OAuth, you‚Äôre almost there.  In the User-Agent, you can register anything, for example, some identifier of your application. <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> session : <span class="hljs-type"><span class="hljs-type">NSURLSession</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> config = <span class="hljs-type"><span class="hljs-type">NSURLSessionConfiguration</span></span>.defaultSessionConfiguration() config.<span class="hljs-type"><span class="hljs-type">HTTPAdditionalHeaders</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.additionalHTTPHeaders <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">NSURLSession</span></span>(configuration: config) }() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(token:<span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.token = token</code> </pre><br>  In addition, you need to initialize something like a session that can be used for HTTP requests, etc. When you have a more or less serious application ready, you can add another session, for example, for background transfers.  But as a matter of fact, all JSON requests do ordinary data requests, so if you wish, you can limit yourself to one session.  It will take a small initializer.  We work with JSON, so we have to parse and deserialize a lot of JSON objects. <br><br><pre> <code class="hljs objectivec">extension Disk { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> func JSONDictionaryWithData(data:<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>!, onError:(<span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>!)-&gt;Void) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>? { var error: <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>? let root = <span class="hljs-built_in"><span class="hljs-built_in">NSJSONSerialization</span></span>.JSONObjectWithData(data, options: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, error: &amp;error) as? <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> root == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { onError(<span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>(...)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> root } }</code> </pre><br>  Unfortunately, no matter how cool Swift is, it‚Äôs still a static-typed language, so when using the Objective-C API you have to do a lot of things.  Suppose some data is returned and you want to get it as an NSDictionary.  This generates a lot of extra code, so, as the experience tells me, you will start writing all sorts of auxiliary things like JSONDictionaryWithData.  Thus, you get the data, make a request, process errors, and then return the object you need.  Working with such an API, you need to make a lot of requests.  So I also implemented something like a JSON task with methods: GET, POST, DELETE, etc. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSURLSession</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsonTaskWithMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method:String, url: NSURL!, onError: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-params">(NSError!)</span></span></span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)!, onCompletion: ((<span class="hljs-type"><span class="hljs-type">NSDictionary</span></span>, <span class="hljs-type"><span class="hljs-type">NSHTTPURLResponse</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)!) -&gt; <span class="hljs-type"><span class="hljs-type">NSURLSessionDataTask!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">NSMutableURLRequest</span></span>(<span class="hljs-type"><span class="hljs-type">URL</span></span>: url) request.<span class="hljs-type"><span class="hljs-type">HTTPMethod</span></span> = method <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dataTaskWithRequest(request) { (data, response, error) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonRoot = <span class="hljs-type"><span class="hljs-type">Disk</span></span>.<span class="hljs-type"><span class="hljs-type">JSONDictionaryWithData</span></span>(data, onError: onError) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jsonRoot = jsonRoot { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> response.statusCode { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">400</span></span>...<span class="hljs-number"><span class="hljs-number">599</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> onError(...) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> onCompletion(jsonRoot, response) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">// handler already called from JSONDictionaryWithData } } } }</span></span></code> </pre><br>  And another URL with an error handler and terminations.  Swift is very effective when working with closures, there it is one of the basic types.  Compared to python, closures are well integrated syntactically, and working with them is much more pleasant.  In addition, you can make a special zone for the three hundred and four hundred codes directly in these auxiliary blocks. <br><br>  Let's see how the file is loaded.  I made a couple of screenshots right from the site.  The top one is about parameters.  Here we have a path on the disk where the files will be saved, as well as a note about whether the file should be overwritten.  In response, you will get something like this from Disk: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/14b/e23/5bf/14be235bf02241818ed8cac05a653111.png" width="500"></div><br>  Working with the REST API, you will encounter such a construction most often. <br><br>  How is the file loading?  You make a request, the service in return sends you this design.  You can upload the file to the issued URL using the specified HTTP method.  There is no need to contact a WebDAV proxy, you are working directly with the storage backend.  In addition, it has a good effect on throughput and speed.  If you take measurements, you will see the difference. <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Disk</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uploadURL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fileURL:NSURL, toPath path:String, overwrite:Bool?, handler:</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(NSError!)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">"\(baseURL)/v1/disk/resources/upload?path=\(path.urlEncoded())"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> overwrite = overwrite { url += <span class="hljs-string"><span class="hljs-string">"&amp;overwrite=\(overwrite)"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = { handler($<span class="hljs-number"><span class="hljs-number">0</span></span>) } session.jsonTaskWithMethod(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url: <span class="hljs-type"><span class="hljs-type">NSURL</span></span>(string: url), onError: error) { (jsonRoot, response)-&gt;<span class="hljs-type"><span class="hljs-type">Void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (href, method, templated) = <span class="hljs-type"><span class="hljs-type">Disk</span></span>.hrefMethodTemplatedWithDictionary(jsonRoot) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">NSMutableURLRequest</span></span>(<span class="hljs-type"><span class="hljs-type">URL</span></span>: <span class="hljs-type"><span class="hljs-type">NSURL</span></span>(string: href)) request.<span class="hljs-type"><span class="hljs-type">HTTPMethod</span></span> = method <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.session.uploadTaskWithRequest(request, fromFile: fileURL) { (data, response, trasferError)-&gt;<span class="hljs-type"><span class="hljs-type">Void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error(trasferError) }.resume() }.resume() } }</code> </pre><br>  In JSONDictionary it is useful to have a topper, also a nice type from Swift.  That's the whole download.  Just build the URL, indicate whether you want to do a rewrite, create an error handler.  This is just a closure that a normal handler wraps in the event of an error.  It is especially interesting to create such things when you have more than one parameter.  The types of return values ‚Äã‚Äãare a bit more complicated in this case. <br><br><br>  Downloading files is almost the same.  You just need to replace the upload with the download. <br><br>  We proceed to delete the files.  Turn again to Polygon.  Again we see the path, some parameter and the answer in the form of the same construction.  The difference is in another HTTP code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3fc/b4a/f7d/3fcb4af7d7ec4edaad996d545e038eac.png" width="500"></div><br>  Deletion does not always happen instantly.  If the process is running, but not yet completed, you will receive error 202. You can check the execution status by a separate request.  I forgot to mention that asynchronous operations are provided in the REST API.  So many operations such as move and delete can be performed asynchronously by the server, since they can take several seconds or even more to complete.  WebDAV in such cases gives only error messages or the need to wait. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeletionResult</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">InProcess</span></span>(href:<span class="hljs-type"><span class="hljs-type">String</span></span>, method:<span class="hljs-type"><span class="hljs-type">String</span></span>, templated:<span class="hljs-type"><span class="hljs-type">Bool</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Failed</span></span>(<span class="hljs-type"><span class="hljs-type">NSError!</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Disk</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deletePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(path:String, permanently:Bool?, handler:</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(result:DeletionResult)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">"\(baseURL)/v1/disk/resources?path=\(path.urlEncoded())"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> permanently = permanently { url += <span class="hljs-string"><span class="hljs-string">"&amp;permanently=\(permanently)"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error = { handler(result: .<span class="hljs-type"><span class="hljs-type">Failed</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>)) } session.jsonTaskWithMethod(<span class="hljs-string"><span class="hljs-string">"DELETE"</span></span>, url: <span class="hljs-type"><span class="hljs-type">NSURL</span></span>(string: url), onError: error) { (jsonRoot, response)-&gt;<span class="hljs-type"><span class="hljs-type">Void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> response.statusCode { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">202</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler(result: .<span class="hljs-type"><span class="hljs-type">InProcess</span></span>(<span class="hljs-type"><span class="hljs-type">Disk</span></span>.hrefMethodTemplatedWithDictionary(jsonRoot))) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">204</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler(result: .<span class="hljs-type"><span class="hljs-type">Done</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error(<span class="hljs-type"><span class="hljs-type">NSError</span></span>(...)) } }.resume() } }</code> </pre><br>  In essence, the delete function is no different from upload and download.  It is very convenient that we have an enum type that can accept additional objects.  Using enum as the return type for a handler provides a good advantage.  You write code, use the enum return type, attach some objects to it.  What is good?  The only way to work with enum is to use switch, which means that you cover all possible scenarios in Swift.  Thus, using enum, you automatically force you to handle most possible events. <br><br><h2>  findings </h2><br>  What did I learn from doing all this, what experience did I get?  First of all, I realized that Swift is a really cool language with a great future.  Especially the enum type with switch.  It is convenient to use basic types, such as closures.  In fact, these are unnamed functions that can be created anywhere in the code.  You can simply embed such a function in the pyramid of functions, return it, etc. With it, you can even apply the techniques of functional programming.  One of the main problems with Swift today is strictness with regard to type safety.  For example, when you start calling Objective-C code from Swift, the id type can cause you problems.  It can not be used just like that, you need to explicitly indicate how to use it: like a Dictionary, myType or something else.  So, if you use such structures, you will have to pay a lot of attention to type casting, which will make the code a bit more voluminous.  On the other hand, today there are no native libraries for Swift, only a small base is available.  Most likely, the fact is that Apple‚Äôs resources are limited, they cannot repeat what Microsoft did when launching .NET: huge libraries, ten thousand objects and implementation of everything that they already had in the system.  I hope that over time the situation will change.  By and large type safety is good, the compiler understands better what can go wrong.  Another nuance is language variability.  Those who have already tried to work with it, probably noticed that something changes with every Xcode update.  The old code stops compiling, even the code samples that Apple demonstrated.  Get out strange errors, falls.  Sometimes it's a little frustrating.  Even the development environment itself crashes.  It makes no sense to google or search in Yandex, you will only find outdated information.  Now one of the main skills when working with Swift is the habit of typing <a href="http://devforums.apple.com/">devforums.apple.com</a> .  There are open discussions, no one is afraid to reveal any secrets, etc. There really is a chance to get an answer to your question.  If you did not find the answer in the already existing topics, just create your own, somebody will answer.  Maybe not immediately, but for a couple of days for sure.  This is the most useful resource at the moment. <br><br>  As for the REST API, the main advice here is to use Polygon, it is beautiful.  It took a lot of effort to create documentation, but keeping it up to date is even more difficult.  A polygon is always relevant.  As soon as a new version comes out, all information about it is already there.  In addition, the REST API is fast enough.  It really is noticeably faster than WebDAV.  And working with OAuth is always nice.  Yes, it requires writing more code, but, most likely, you already have some implementation, so it doesn't matter much.  REST API has a lot ahead.  The API still has white spots, but we have a lot of ideas, the implementation of which my colleagues are actively engaged in. <br><br>  To summarize, I want to advise you to develop through testing.  This will save you a lot of time.  Especially when you are writing something like an SDK.  It is much easier to write a small test for the function you are implementing than to try to call it from an application.  Just write tests, call your functions, check the results.  Nowadays, even the development of asynchronous API does not cause problems.  Xcode allows you to create asynchronous tests: you set the conditions and run the test, and the handler tells you if everything‚Äôs done successfully.  Testing asynchronous APIs is very simple there.  In addition, it helps to find bugs.  Mistakes do everything, and we are no exception, so we welcome every bug report.  You can use WCF on the Disk API page.  Usually, we all quickly repair - depending on the complexity and criticality of the problem, of course. </div><p>Source: <a href="https://habr.com/ru/post/241223/">https://habr.com/ru/post/241223/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241213/index.html">Google's Lollipop OS, new Nexus and a list of billions of companies in the mobile market - and other news of the week for a mobile developer</a></li>
<li><a href="../241215/index.html">GLPI and the latest time zone updates in Windows</a></li>
<li><a href="../241217/index.html">Localization of applications for OS X</a></li>
<li><a href="../241219/index.html">Apple obliges developers to create 64-bit applications</a></li>
<li><a href="../241221/index.html">Cryptographic solutions. From crypto providers to browser plug-ins</a></li>
<li><a href="../241227/index.html">SED: look for who benefits</a></li>
<li><a href="../241229/index.html">Pythonista. Writing in Python for iOS</a></li>
<li><a href="../241231/index.html">Persistent queue</a></li>
<li><a href="../241235/index.html">The inability to create a new calendar event through the Kerio Connect client using Google Chrome and Apple Safari browsers</a></li>
<li><a href="../241237/index.html">Cheat Sheet Management Services CentOS 7 with systemd</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>