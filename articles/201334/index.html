<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FindBugs helps learn Java better</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Static code analyzers love for the fact that they help to find errors made by inattention. But it is much more interesting that they help to correct m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FindBugs helps learn Java better</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/825/895/c92/825895c9203cf34e9017a5576651ae2b.png" align="right">  Static code analyzers love for the fact that they help to find errors made by inattention.  But it is much more interesting that they help to correct mistakes made out of ignorance.  Even if everything is written in the official documentation for the language, it is not a fact that all programmers have carefully read this.  And programmers can understand: all the documentation to read tormented. <br><br>  In this regard, the static analyzer is similar to an experienced comrade who sits nearby and looks at how you write code.  He not only tells you: ‚Äúhere you were mistaken when copy-paste‚Äù, but also says: ‚Äúno, you can't write like that, look at the documentation yourself‚Äù.  Such a friend is more useful than the documentation itself, because it tells only those things that you really encounter in your work, and is silent about those that you will never find useful. <br><br>  In this post I will discuss some of the intricacies of Java, which I learned as a result of using the FindBugs static analyzer.  Perhaps some things will be unexpected for you.  It is important that all examples are not speculative, but are based on real code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Ternary operator?: </h4><br>  It would seem that there is nothing easier than a ternary operator, but it has its own pitfalls.  I thought that there was no fundamental difference between the constructions. <br><pre><code class="java hljs">Type <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> = condition ? valTrue : valFalse;</code> </pre>  and <pre> <code class="java hljs">Type <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(condition) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> = valTrue; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> = valFalse;</code> </pre> <br><a name="habracut"></a>  It turned out that there is a subtlety.  Since a ternary operator can be part of a complex expression, its result must be a specific type defined at compile time.  Therefore, for example, with the true condition in the if form, the compiler leads valTrue to Type immediately, and in the form of a ternary operator it first leads to a common type valTrue and valFalse (although valFalse is not calculated), and then the result leads to Type.  Coercion rules are not entirely trivial if primitive types and wrappers over them (Integer, Double, etc.) participate in the expression. All rules are described in detail in <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html">JLS 15.25</a> .  Let's look at some examples. <br><br><pre> <code class="java hljs">Number n = flag ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">1</span></span>) : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Double(<span class="hljs-number"><span class="hljs-number">2.0</span></span>);</code> </pre> <br>  What will happen in n if the flag is set?  Double object with a value of 1.0.  Our clumsy attempts to create an object are ridiculous to the compiler.  Since the second and third arguments are wrappers over different primitive types, the compiler expands them and results in a more accurate type (in this case, double).  And after performing the ternary assignment operator, boxing is performed again.  In essence, the code is equivalent to this: <br><pre> <code class="java hljs">Number n; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( flag ) n = Double.valueOf((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">1</span></span>).intValue() )); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n = Double.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Double(<span class="hljs-number"><span class="hljs-number">2.0</span></span>).doubleValue());</code> </pre> <br>  From the point of view of the compiler, the code does not contain problems and compiles perfectly.  But FindBugs gives a warning: <br><blockquote>  BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR: Primitive value is unboxed and coerced for ternary operator in TestTernary.main (String []) <br><br>  The conditional ternary operator has been wrapped up in a primitive value.  The Semantics of Java and the E2 are wrapped up with the numeric values ‚Äã‚Äãand the E2 is the type of float, then the e1 is unboxed, converted to a floating point value, and boxed. See JLS Section 15.25. </blockquote>  Of course, FindBugs warns that Integer.valueOf (1) is more efficient than new Integer (1), but that's all they already know. <br><br>  Or an example: <br><pre> <code class="java hljs">Integer n = flag ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre> <br>  The author wants to put null in n if the flag is not set.  Think it will work?  Yes.  But let's complicate: <br><pre> <code class="java hljs">Integer n = flag1 ? <span class="hljs-number"><span class="hljs-number">1</span></span> : flag2 ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre> <br>  It would seem that there is not much difference.  Now, however, if both flags are cleared, this line generates a NullPointerException.  The choices for the right ternary operator are int and null, therefore the resulting type is Integer.  The options for the left are int and Integer, therefore, according to the rules of Java, the result is an int.  To do this, you must perform unboxing by calling intValue, which throws an exception.  The code is equivalent to this: <br><pre> <code class="java hljs">Integer n; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( flag1 ) n = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( flag2 ) n = Integer.valueOf(Integer.valueOf(<span class="hljs-number"><span class="hljs-number">2</span></span>).intValue()); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> n = Integer.valueOf(((Integer)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>).intValue()); }</code> </pre> <br>  Here, FindBugs gives two messages, which are enough to suspect an error: <br><blockquote>  BX_UNBOXING_IMMEDIATELY_REBOXED: Boxed value is unboxed and then immediately reboxed in TestTernary.main (String []) <br>  NP_NULL_ON_SOME_PATH: Possible null pointer dereference of TestTernary.main (String []) <br>  If there is a branch of the statement, it will be dereferenced, which will generate a nullPointerException. </blockquote><br>  Well, the last example on this topic: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] vals = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] {<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (idx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || idx &gt;= vals.length) ? <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : vals[idx]; }</code> </pre> <br>  Not surprisingly, this code does not work: how can a function that returns a primitive type return null?  It's amazing that it compiles without problems.  Why compile - you already understand. <br><br><h4>  Dateformat </h4><br>  For formatting dates and times in Java, it is recommended to use classes that implement the DateFormat interface.  For example, it looks like this: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span></span>).format(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date()); }</code> </pre> <br>  Often a class reuses the same format.  Many will come up with the idea of ‚Äã‚Äãoptimization: why create a format object every time when you can use a common instance? <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DateFormat format = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> format.format(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date()); }</code> </pre> <br>  That is so beautiful and cool, but unfortunately it does not work.  It works more precisely, but occasionally it breaks.  The fact is that the documentation for DateFormat <a href="http://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html">says</a> : <br><blockquote>  Date formats are not synchronized.  It is recommended to create a separate format instances for each thread.  If multiple threads access a concurrently, it must be synchronized externally. </blockquote><br>  And this is true, if you look at the internal implementation of SimpleDateFormat.  During the execution of the format () method, the object writes to the class fields; therefore, using SimpleDateFormat from two threads simultaneously will result in an incorrect result with some probability.  Here is what FindBugs writes about this: <br><blockquote>  STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE: Call to method of static java.text.DateFormat in TestDate.getDate () <br>  As the JavaDoc states, DateFormats are inherently unsafe for multithreaded use.  The detector has found that it has been obtained through a static field.  This looks suspicous. <br><br>  <a href="http://bugs.sun.com/bugdatabase/view_bug.do%3Fbug_id%3D6231579">Sun Bug # 6231579</a> and <a href="http://bugs.sun.com/bugdatabase/view_bug.do%3Fbug_id%3D6178997">Sun Bug # 6178997</a> . </blockquote><br><h4>  Pitfalls BigDecimal </h4><br>  Having learned that the BigDecimal class allows storing fractional numbers of arbitrary precision, and seeing that it has a double constructor, some will decide that everything is clear and you can do this: <br><pre> <code class="java hljs">System.out.println(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(<span class="hljs-number"><span class="hljs-number">1.1</span></span>));</code> </pre> <br>  Nobody really forbids doing this, only the result may seem unexpected: 1.1000000000000000888178419700125232338903333727265625.  This happens because primitive double is stored in the IEEE754 format, in which it is impossible to imagine 1.1 perfectly accurate (in binary notation, an infinite periodic fraction is obtained).  Therefore, the closest value to 1.1 is stored there.  On the other hand, the BigDecimal (double) constructor works exactly: it ideally converts a given number in IEEE754 to decimal form (the final binary fraction is always representable as the final decimal).  If you want to represent just 1.1 in the form of BigDecimal, then you can write either <code>new BigDecimal("1.1")</code> or <code>BigDecimal.valueOf(1.1)</code> .  If the number is not output immediately, and you can do some operations with it, you may not understand where the error comes from.  FindBugs issues a DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE warning, which gives the same advice. <br><br>  And here's another thing: <br><pre> <code class="java hljs">BigDecimal d1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(<span class="hljs-string"><span class="hljs-string">"1.1"</span></span>); BigDecimal d2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BigDecimal(<span class="hljs-string"><span class="hljs-string">"1.10"</span></span>); System.out.println(d1.equals(d2));</code> </pre> <br>  In fact, d1 and d2 are the same number, but equals returns false, because it compares not only the value of numbers, but also the current order (the number of decimal places).  This is written in the documentation, but few will read the documentation for such a familiar method as equals.  Such a problem can emerge far from immediately.  FindBugs itself, unfortunately, does not warn about this, but there is a popular extension to it - <a href="http://fb-contrib.sourceforge.net/">fb-contrib</a> , in which this bug is taken into account: <br><blockquote>  MDM_BIGDECIMAL_EQUALS <br><br>  equals () being two java.math.BigDecimal numbers.  It is normally a rule.  To compare BigDecimal objects for mathematical equality, use CompareTo () instead. <br></blockquote><br><h4>  Strings and printfs </h4><br>  Often programmers who switch to Java after C will happily discover <a href="http://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html">PrintStream.printf</a> (and also <a href="http://docs.oracle.com/javase/7/docs/api/java/io/PrintWriter.html">PrintWriter.printf</a> , etc.).  Like, well, I know that, just like in C, nothing new needs to be taught.  In fact, there are differences.  One of them is in the translation of strings. <br><br>  In the C language, there is a division into text and binary streams.  The output of the character '\ n' to a text stream in any way will automatically be converted to a system-dependent newline ("\ r \ n" on Windows).  In Java, there is no such separation: you must pass the correct sequence of characters to the output stream.  This is automatically done, for example, by the methods of the PrintStream.println family.  But when using printf, passing '\ n' in the format string is just '\ n', not a system-dependent newline.  For example, write the following code: <br><pre> <code class="java hljs">System.out.printf(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, <span class="hljs-string"><span class="hljs-string">"str#1"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"str#2"</span></span>);</code> </pre> <br>  Redirecting the result to the file, we will see: <br><img src="https://habrastorage.org/getpro/habr/post_images/85f/6b4/e2a/85f6b4e2ab95807597bed3e209e8a66a.png"><br>  Thus, you can get a strange combination of line breaks in one thread, which looks messy and can tear down the roof to some parser.  You can ignore the error for a long time, especially if you mostly work on Unix-systems.  To insert the correct line feed using printf, the special format character "% n" is used.  Here is what FindBugs writes about this: <br><blockquote>  VA_FORMAT_STRING_USES_NEWLINE: Format string should not use% n rather than \ n in TestNewline.main (String []) <br><br>  This format string includes a newline character (\ n).  In the format of the strings, it will be more convenient to use. </blockquote><br><br>  Perhaps for some readers all of the above was known for a long time.  But I am pretty sure that there will be an interesting warning from them for the static analyzer, which will reveal to them the new features of the programming language used. </div><p>Source: <a href="https://habr.com/ru/post/201334/">https://habr.com/ru/post/201334/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../201324/index.html">time () or now () as a dependency on the global environment</a></li>
<li><a href="../201326/index.html">Pipe Child: How to combine web services into new tools</a></li>
<li><a href="../201328/index.html">Sony digital A4 paper</a></li>
<li><a href="../201330/index.html">Font path on WebFont.ru</a></li>
<li><a href="../201332/index.html">Easy printing from mobile devices or AirPrint without AirPrint</a></li>
<li><a href="../201336/index.html">An example of using WxPython to create a node interface. Part 1: Learning to draw</a></li>
<li><a href="../201338/index.html">Why the TV control method should change</a></li>
<li><a href="../201340/index.html">Today at 10:00 (MSK), see the online broadcast "Developing applications with common code for the Windows platform"</a></li>
<li><a href="../201344/index.html">Infrastructure of the Russian securities market (brief educational program)</a></li>
<li><a href="../201346/index.html">ART is replacing Dalvik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>