<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Discord simultaneously serves 2.5 million voice chats using WebRTC</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the very beginning, we planned engineering and product solutions in such a way that Discord would be well suited for voice chat while playing wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Discord simultaneously serves 2.5 million voice chats using WebRTC</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/no/3o/oj/no3oojc_pnuwknb6hcrplkrhtmq.jpeg"><br><br>  From the very beginning, we planned engineering and product solutions in such a way that Discord would be well suited for voice chat while playing with friends.  These solutions allowed the system to scale greatly, with a small team and limited resources. <br><br>  The article discusses the various technologies that Discord uses for audio / video chats. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>For clarity, the whole group of users and channels we will call ‚Äúgroup‚Äù (guild) - in the client they are called ‚Äúservers‚Äù.</i>  <i>Instead, the term ‚Äúserver‚Äù here refers to our server infrastructure.</i> <br><a name="habracut"></a><br><h1>  Main principles </h1><br>  Each audio / video chat in Discord supports many participants.  We watched a thousand people talk in turns in large group chats.  Such support requires a client-server architecture, because a peer-to-peer peer-to-peer network becomes prohibitively expensive as the number of participants increases. <br><br>  Routing network traffic through Discord servers also ensures that your IP address is never visible - and no one will launch a DDoS attack.  Routing through servers has other advantages: for example, moderation.  Administrators can quickly turn off sound and video offenders. <br><br><h1>  Client architecture </h1><br>  Discord works on many platforms. <br><br><ul><li>  Web (Chrome / Firefox / Edge, etc.) </li><li>  Standalone application (Windows, MacOS, Linux) </li><li>  Phone (iOS / Android) </li></ul><br>  We can support all these platforms in only one way: through the reuse of <a href="https://www.w3.org/TR/webrtc/">WebRTC</a> code.  This specification for real-time communications includes network, audio, and video components.  The standard is adopted <a href="https://www.w3.org/">by the World Wide Web Consortium</a> and the <a href="https://ietf.org/">Internet Engineering Group</a> .  WebRTC is available in all modern browsers and as a native library for embedding in applications. <br><br>  Audio and video in Discord runs on WebRTC.  Thus, the browser application relies on the WebRTC implementation in the browser.  However, applications for desktops, iOS and Android use a single multimedia C ++ engine, built on top of their own WebRTC library, specially adapted to the needs of our users.  This means that some functions in the application work better than in the browser.  For example, in our native applications we can: <br><br><ul><li>  Bypass the volume muted in Windows by default, when <a href="https://docs.microsoft.com/en-us/windows/desktop/coreaudio/stream-attenuation">all applications are automatically muted when using the headset</a> .  This is undesirable when you and your friends go to the raid and coordinate actions in the Discord chat. </li><li>  Use your own volume control instead of the global operating system mixer. </li><li>  Process original audio data to detect voice activity and broadcast audio and video in games. </li><li>  Reduce the bandwidth and CPU consumption during periods of silence - even in the most numerous voice chats at any one time only a few people speak at a time. </li><li>  Provide system-wide functionality of the ‚Äúwalkie-talkie‚Äù mode. </li><li>  Send additional information along with audio-video packages (for example, the priority indicator in the chat). </li></ul><br>  Having your own version of WebRTC means frequent updates for all users: this is a time consuming process that we try to automate.  However, these efforts pay off with specific features for our players. <br><br>  In Discord, voice and video communication is initiated by entering a voice channel or a call.  That is, the connection is always initiated by the client - this reduces the complexity of the client and server parts, as well as increases resistance to errors.  In the event of infrastructure failure, participants can simply reconnect to the new internal server. <br><br><h3>  Under our control </h3><br>  Control of the native library allows you to implement some functions differently than in the browser-based implementation of WebRTC. <br><br>  First, WebRTC relies on the Session Description Protocol ( <a href="https://www.html5rocks.com/en/tutorials/webrtc/basics/">SDP</a> ) to negotiate audio / video between participants (up to 10 KB for each packet exchange).  In its own library, the lower level API from WebRTC ( <code>webrtc::Call</code> ) is used to create both flows - inbound and outbound.  When connected to a voice channel, there is a minimal exchange of information.  This is the address and port of the backend server, encryption method, keys, codec and stream identification (about 1000 bytes). <br><br><pre> <code class="cpp hljs">webrtc::<span class="hljs-function"><span class="hljs-function">AudioSendStream* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAudioSendStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ssrc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> payloadType, webrtc::Transport* transport, rtc::scoped_refptr&lt;webrtc::AudioEncoderFactory&gt; audioEncoderFactory, webrtc::Call* call)</span></span></span><span class="hljs-function"> </span></span>{ webrtc::AudioSendStream::Config config{transport}; config.rtp.ssrc = ssrc; config.rtp.extensions = {{<span class="hljs-string"><span class="hljs-string">"urn:ietf:params:rtp-hdrext:ssrc-audio-level"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}}; config.encoder_factory = audioEncoderFactory; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> webrtc::SdpAudioFormat kOpusFormat = {<span class="hljs-string"><span class="hljs-string">"opus"</span></span>, <span class="hljs-number"><span class="hljs-number">48000</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; config.send_codec_spec = webrtc::AudioSendStream::Config::SendCodecSpec(payloadType, kOpusFormat); webrtc::AudioSendStream* audioStream = call-&gt;CreateAudioSendStream(config); audioStream-&gt;Start(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> audioStream; }</code> </pre> <br>  In addition, WebRTC uses Interactive Connectivity Establishment ( <a href="https://www.html5rocks.com/en/tutorials/webrtc/infrastructure/">ICE</a> ) to determine the best route between participants.  Since we have each client connects to the server, we do not need ICE.  This allows you to provide a much more reliable connection if you are behind NAT, and also to keep your IP address secret from other participants.  Clients periodically ping so that the firewall maintains an open connection. <br><br>  Finally, WebRTC uses Secure Real-time Transport Protocol ( <a href="https://en.wikipedia.org/wiki/Secure_Real-time_Transport_Protocol">SRTP</a> ) to encrypt media.  Encryption keys are established using Datagram Transport Layer Security ( <a href="https://en.wikipedia.org/wiki/Datagram_Transport_Layer_Security">DTLS</a> ) protocol based on standard TLS.  The built-in WebRTC library allows you to implement your own transport layer using the <code>webrtc::Transport</code> API. <br><br>  Instead of DTLS / SRTP, we decided to use <a href="https://en.wikipedia.org/wiki/Salsa20">Salsa20</a> faster <a href="https://en.wikipedia.org/wiki/Salsa20">encryption</a> .  In addition, we do not send audio data during periods of silence - a frequent occurrence, especially in large chats.  This leads to significant savings in bandwidth and CPU resources, however, both the client and the server should be ready at any time to stop receiving data and rewrite the sequence numbers of the audio / video packages. <br><br>  Since the web application uses the browser-based implementation of the <a href="https://www.w3.org/TR/webrtc/">WebRTC API</a> , you cannot abandon SDP, ICE, DTLS and SRTP.  The client and server exchange all the necessary information (less than 1200 bytes when exchanging packets) - and an SDP session is established for the clients on the basis of this information.  Backend is responsible for eliminating the differences between desktop and browser applications. <br><br><h1>  Backend architecture </h1><br>  There are several voice chat services on the backend, but we will focus on three: Discord Gateway, Discord Guilds and Discord Voice.  All of our signal servers are written in <a href="https://elixir-lang.org/">Elixir</a> , which allows you to reuse code repeatedly. <br><br>  When you are online, your client maintains a WebSocket connection to the Discord Gateway Gateway (we call it the WebSocket <i>gateway</i> connection).  Through this connection, your client receives events related to groups and channels, text messages, presence packets, etc. <br><br>  When connected to a voice channel, the connection status is displayed <a href="https://discordapp.com/developers/docs/resources/voice">by the voice communication state object</a> .  The client updates this object through a gateway connection. <br><br><pre> <code class="hljs pgsql">defmodule VoiceStates.VoiceState <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> t :: %{ session_id: String.t(), user_id: Number.t(), channel_id: Number.t() | nil, token: String.t() | nil, mute: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, deaf: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, self_mute: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, self_deaf: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, self_video: <span class="hljs-type"><span class="hljs-type">boolean</span></span>, suppress: <span class="hljs-type"><span class="hljs-type">boolean</span></span> } defstruct session_id: nil, user_id: nil, token: nil, channel_id: nil, mute: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, deaf: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, self_mute: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, self_deaf: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, self_video: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, suppress: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  When you connect to a voice channel, you are assigned one of the Discord Voice servers.  He is responsible for the transmission of sound to each channel participant.  All voice channels in a group are assigned to one server.  If you're the first to chat, the Discord Guilds server is responsible for assigning the Discord Voice server to the whole group using the process described below. <br><br><h3>  Purpose of Discord Voice Server </h3><br>  Each Discord Voice server periodically reports its status and load.  This information is placed on the service discovery system (we use <a href="https://coreos.com/etcd/">etcd</a> ), as discussed in the <a href="https://blog.discordapp.com/we-care-about-your-voice-engineering-special-c6348d7dc068">previous article</a> . <br><br>  Discord Guilds server monitors the service discovery system and assigns the group the least used Discord Voice server in the region.  When selected, all voice status objects (also supported by the Discord Guilds server) are transferred to the Discord Voice server so that it can set up audio / video redirection.  Customers are notified of the selected Discord Voice server.  Then the client opens the <i>second</i> WebSocket connection to the voice server (we call it the WebSocket <i>voice</i> connection), which is used to set up media forwarding and speech indication. <br><br>  When the client displays <i>Awaiting Endpoint</i> status, it means that the Discord Guilds server is looking for the best Discord Voice server.  The <i>Voice Connected</i> message means that the client successfully exchanged UDP packets with the selected Discord Voice server. <br><br>  The Discord Voice server contains two components: a signaling module and a multimedia relay unit, called the selective forwarding unit ( <a href="https://webrtcglossary.com/sfu/">SFU</a> ).  The signaling module fully controls the SFU and is responsible for the generation of flow identifiers and encryption keys, the redirection of speech indicators, etc. <br><br>  Our SFU (in C ++) is responsible for directing audio and video traffic between channels.  It is developed on its own: for our specific case, the SFU provides maximum performance and, thus, the greatest savings.  When moderators violate (mute the server), their audio packs are not processed.  SFU also works as a bridge between native and browser applications: it implements transport and encryption for both the browser and native applications, converting the packets during transmission.  Finally, SFU is responsible for handling the <a href="https://en.wikipedia.org/wiki/RTP_Control_Protocol">RTCP</a> protocol, which is used to optimize video quality.  SFU collects and processes RTCP reports from recipients - and notifies senders which band is available for video transmission. <br><br><h1>  fault tolerance </h1><br>  Since we only have Discord Voice servers directly from the Internet, we‚Äôll talk about them. <br><br>  The signal module continuously monitors the SFU.  If it fails, it instantly restarts with a minimum pause in service (several lost packets).  The status of the SFU is restored by the signal module without any interaction with the client.  Although SFU crashes are rare, we use the same mechanism to upgrade SFU without interruption of service. <br><br>  When the Discord Voice server crashes, it does not respond to the ping ‚Äî and is removed from the service discovery system.  The client also notices the server crash due to the disconnection of the WebSocket voice connection, then it requests the <i>ping of the voice server</i> via the WebSocket gateway connection.  The Discord Guilds server confirms the failure, consults with the service discovery system, and assigns the group a new Discord Voice server.  The Discord Guilds then send all the voice status objects to the new voice server.  All clients receive a notification about the new server and connect to it to start the multimedia setup. <br><br><img src="https://habrastorage.org/webt/tw/1r/kz/tw1rkzplhbqsax95lajz9-ylluu.gif"><br><br>  Quite often, Discord Voice servers fall under DDoS (we see this by a rapid increase in incoming IP packets).  In this case, we perform the same procedure as in the event of a server failure: remove it from the service discovery system, select a new server, transfer all voice state objects to it and notify clients of the new server.  When the DDoS attack subsides, the server returns to the service discovery system. <br><br>  If the group owner decides to choose a new region for a voice, we perform a very similar procedure.  Discord Guilds Server chooses the best available voice server in the new region by consulting with the service discovery system.  Then he translates all voice state objects into it and notify clients of the new server.  Clients break the current WebSocket connection to the old Discord Voice server and create a new connection to the new Discord Voice server. <br><br><h1>  Scaling </h1><br>  The entire Discord Gateway, Discord Guilds and Discord Voice infrastructure supports horizontal scaling.  Discord Gateway and Discord Guilds work in the Google cloud. <br><br>  We have more than 850 voice servers in 13 regions (located in more than 30 data centers) worldwide.  Such infrastructure provides greater redundancy in case of failures in data centers and DDoS.  We work with several partners and use our physical servers in their data centers.  Just recently added the region of South Africa.  Thanks to engineering efforts in both the client and server architecture, Discord is now able to serve simultaneously more than 2.6 million users of voice chat with outgoing traffic of more than 220 Gbit / s and 120 million packets per second. <br><br><h1>  What's next? </h1><br>  We constantly monitor the quality of voice communication (metrics come from the client side to the backend servers).  In the future, this information will help in the automatic detection and elimination of degradation. <br><br>  Although we launched video chat and screencasts a year ago, but now they can only be used in personal messages.  Compared to sound, video requires significantly more CPU power and throughput.  The challenge is to balance the amount of bandwidth and CPU / GPU resources used to ensure the best video quality, especially when the group of gamers in the channel is on different devices.  The solution can be <a href="https://en.wikipedia.org/wiki/Scalable_Video_Coding">Scalable Video Coding</a> (SVC) technology, an extension of the H.264 / MPEG-4 AVC standard. <br><br>  Screencasts require even more bandwidth than video, due to higher FPS and resolution than a regular webcam.  We are currently working on supporting hardware video encoding in a desktop application. </div><p>Source: <a href="https://habr.com/ru/post/423171/">https://habr.com/ru/post/423171/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423161/index.html">Business wants personal data</a></li>
<li><a href="../423163/index.html">Connecting CryptoPro to Mono</a></li>
<li><a href="../423165/index.html">Dynamic mesh drawing in Unreal Engine 4</a></li>
<li><a href="../423167/index.html">What Mark Zuckerberg says about Facebook issues. The main thing from the article The New Yorker</a></li>
<li><a href="../423169/index.html">Startup of the day (July-August 2018)</a></li>
<li><a href="../423173/index.html">Minimum time - maximum pain</a></li>
<li><a href="../423175/index.html">Why write your game engine?</a></li>
<li><a href="../423177/index.html">The book "Microsoft Azure Security Infrastructure"</a></li>
<li><a href="../423179/index.html">The book "Guide to the architecture of cloud applications"</a></li>
<li><a href="../423181/index.html">Azure Developer Guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>