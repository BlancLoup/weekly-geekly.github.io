<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Multithreading" WSH VBScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Crutch 
 Good all the time of day. I propose a crutch that implements a multithreading mechanism (or rather, "multiprocessing") for WSH VBScript. Not ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Multithreading" WSH VBScript</h1><div class="post__text post__text-html js-mediator-article"><h4>  Crutch </h4><br>  Good all the time of day.  I propose a crutch that implements a multithreading mechanism (or rather, "multiprocessing") for WSH VBScript.  Not recommended for individuals allergic to indocode. <br>  The first thought about the potential convenience of multithreading came once during the solution on a voluntary basis regarding a relatively simple task of processing and visualizing information.  And, since installing an IDE like Visual Studio and our Helpdesk are incompatible concepts, only VBA and WSH remained ‚Äúlegal‚Äù.  At that time the last one was chosen.  And the current administrative restrictions and the desire to get friendly methods dictated the requirements for this implementation of multiprocessing: <br><ul><li>  The code is located in one file, like a regular script. </li><li>  Uses a minimum of ActiveX, and only embedded, works without WMI, under WSH x86 / x64. </li><li>  Sufficient functionality and convenience is more important than speed and patterns. </li></ul><br>  Features: <br><ul><li>  The launched script performs the service function.  The main code is executed in subsequent processes. </li><li>  In the "full version" the main code is placed only in classes, an instance of any of which can be created in a separate process.  In each new process, the script creates an instance of the service class, which creates an instance of the specified target class, calls the target method, controls its progress, creates variables in the global context of scripts that refer to the created instances of the classes.  The object of the initialized target class is returned to the preceding script, and the initialization and completion events of the target class of the running script are ‚Äúprocessed‚Äù. </li><li>  In the ‚Äúlight version‚Äù, the logic is similar, only the main code is located inside the sub, the preceding script does not return an object, but an index of the running one, and there is no event handling. </li><li>  To create a new process, the script recursively launches itself, passing data about the called method and the identifying information in the named argument. </li><li>  There is no single execution space, each script stores its data and objects in its context.  For data exchange, the Me object of the first script is transmitted to the subsequent ones using the <b>GlobalContainer</b> described <a href="http://forum.script-coding.com/viewtopic.php%3Fid%3D5573">in the ‚Äúdata and objects exchange between scripts - 2‚Äù topic on the Gray Forum</a> .  Each script, after completing the target method, waits for permission to complete; such a delay allows you to retrieve information from it. </li><li>  It functions the same in WSH WScript and CScript, and in the form of an exe file compiled into ScriptCryptor (though class_terminate methods do not work in exe). </li></ul><a name="habracut"></a><br>  Minuses: <br><ul><li>  Difficulty in debugging due to the use of many methods on error resume next and execute.  All the same, it's a crutch. </li><li>  Bulkiness. </li><li>  The order of completion of the scripts is entirely the responsibility of the developer.  Naturally, when accessing objects of a completed script, an error will occur. </li></ul><br>  Actually: <br><ul><li>  Mutexes and mechanisms for trapping a method from using more than one process are not implemented. </li><li>  Possible failures when accessing script variables from contexts of others at the same time. </li><li>  The Explorer window remains in memory when you close the CScript.exe console window. </li></ul><br><br><h4>  Light version of <b>mproclite.vbs</b> : </h4><br><pre><code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">option</span></span> <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span> launch <span class="hljs-string"><span class="hljs-string">"base"</span></span> <span class="hljs-comment"><span class="hljs-comment">' main programm section sub base() startproc "msg" startproc "msg" startproc "msg" msgbox "base, id = " &amp; id, 64 free id end sub sub msg() msgbox "msg, id = " &amp; id, 64 free id end sub ' do not modify service section sub launch(byval destination) dim job executeglobal "dim scene, container, signature, subname, jobs, id, state, release" release = false if not wscript.arguments.named.exists("task") then dim elt executeglobal "dim found, lost" id = 0 found = 0 lost = 0 signature = "" randomize do signature = signature &amp; hex(rnd * 16) loop while len(signature) &lt; 16 set scene = me set jobs = createobject("Scripting.Dictionary") set jobs(0) = scene set container = getobject("new:{C08AFD90-F2A1-11D1-8455-00A0C91F3880}") container.putproperty signature, scene startproc destination on error resume next do until (lost &gt;= found) or release for elt = found to 1 step -1 if typename(jobs(elt)) = "Object" then lost = lost + 1 jobs(elt) = empty end if err.clear wscript.sleep 1 next loop release = true executeglobal "scene_beforeterminate" for elt = found to 1 step -1 if typename(jobs(elt)) = "VBScriptTypeInfo" then jobs(elt).wscript.timeout = 1 jobs(elt).wscript.quit err.clear nojobs = false end if wscript.sleep 1 next container.quit else job = split(wscript.arguments.named("task"), ";") signature = cstr(job(0)) id = clng(job(1)) subname = cstr(job(2)) do for each container in createobject("Shell.Application").windows if isobject(container.getproperty(signature)) then exit do end if next wscript.sleep 1 loop set scene = container.getproperty(signature) set jobs = scene.jobs state = 4 set jobs(id) = me executeglobal subname state = 24 do until release wscript.sleep 10 loop state = 28 end if end sub function startproc(subname) startproc = createproc(subname) joint startproc, 4, 0 REM do while getstate(startproc) &lt; 4 REM wscript.sleep 10 REM loop end function function createproc(subname) if me is scene then if not release then found = found + 1 createproc = found set jobs(createproc) = nothing createobject("WScript.Shell").exec("""" &amp; wscript.fullname &amp; """ """ &amp; wscript.scriptfullname &amp; """ ""/task:" &amp; join(array(signature, createproc, subname), ";") &amp; """") end if else createproc = scene.createproc(subname) end if end function function getjob(target) on error resume next if jobs.exists(target) then set getjob = jobs(target) if err.number = 0 then exit function err.clear end if set getjob = nothing end function sub share(varname, value) scene.newvar varname if isobject(value) then execute "set scene." &amp; varname &amp; " = value" else execute "scene." &amp; varname &amp; " = value" end if end sub sub newvar(varname) executecommand "dim " &amp; varname end sub sub executecommand(command) executeglobal command end sub function getstate(target) dim elt if jobs.exists(target) then on error resume next set elt = jobs(target) getstate = elt.state if err.number &lt;&gt; 0 then if not(elt is nothing) then getstate = 64 else getstate = 1 end if end if set elt = nothing else getstate = 64 end if end function function isresponsive(target) isresponsive = cbool(getstate(target) and 28) end function sub free(target) if jobs.exists(target) then on error resume next jobs(target).release = true else dim elt, subname for elt = scene.found to 1 step -1 on error resume next subname = jobs(elt).subname if subname = target then free jobs(elt).id end if err.clear next end if end sub function joint(target, state, timeout) dim reftime reftime = timer on error resume next if jobs.exists(target) then if isnumeric(target) then do while getstate(target) &lt; state if timeisout(timeout, reftime) then joint = false exit function end if wscript.sleep 10 loop else dim elt, subname for elt = scene.found to 1 step -1 subname = jobs(elt).subname err.clear if subname = target then do while getstate(target) &lt; state if timeisout(timeout, reftime) then joint = false exit function end if wscript.sleep 10 loop end if err.clear next end if end if joint = true end function function timeisout(timeout, reftime) if timeout &gt; 0 then dim delta delta = timer - reftime if delta &lt; 0 then delta = delta + 86400 if delta &gt; timeout then timeisout = true end if else timeisout = false end if end function sub interrupt(target, timeout) if jobs.exists(target) then on error resume next jobs(target).wscript.timeout = timeout jobs(target).wscript.quit else dim elt, subname for elt = scene.found to 1 step -1 on error resume next subname = jobs(elt).subname if subname = target then interrupt jobs(elt).id end if err.clear next end if end sub sub push(name, value) container.putproperty name, value end sub function pop(name) on error resume next if isobject(container.getproperty(name)) then set pop = container.getproperty(name) else pop = container.getproperty(name) end if end function</span></span></code> </pre> <br><br><h4>  Description: </h4><br>  Functions of the multiprocessing mechanism of the light version: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>launch</b> subname <br>  It starts the service algorithm, the execution of the script always begins with its call. <br>  subname - string, indicates the target sub, which will be executed in the new process. <br>  Arguments of this method are used only in the initially running script to start executing the main code. <br>  In each new script: <br><ul><li>  Variables are declared in the global space of the running script: <br>  <b>scene</b> - a reference to the Me object of the first script, <br>  <b>container</b> - link to the GlobalContainer Explorer window, <br>  <b>signature</b> - a string generated to identify the GlobalContainer, <br>  <b>found, lost</b> - only for the scene - counters of the created and completed script processes, <br>  <b>subname</b> - string, contains the target of the script, <br>  <b>jobs</b> - a link to the dictionary with the Me objects of the running scripts, created in the scene, <br>  <b>id</b> - the sequence number of the script - the key in the dictionary, <br>  <b>release</b> = False - after the completion of the target sub, the script will be completed after the assignment True, <br>  <b>state</b> = 4 - the state in which this script is located. </li><li>  An item is added to the <b>jobs</b> dictionary. </li></ul><br>  <b>startproc</b> (subname) <br>  subname - see launch (). <br>  Creates a new script process, expects its readiness to state 4 (see getstate ()) when you can access the Me object of the script.  Returns a number - the id of the running script. <br><br>  <b>createproc</b> (subname) <br>  subname - see launch (). <br>  Creates a new script process, without waiting, returns a number - the id of the running script.  Used to create asynchronously several processes in a loop, without waiting for each to be ready.  Noticeably faster than using startproc () for this application. <br><br>  <b>getjob</b> (target) <br>  target - number, script id or string, name of the subname group of scripts created. <br>  Provides access to the Me object of the script.  Returns a reference to the Me object of the script, if id is not found or the script is completed - Nothing. <br><br>  <b>getstate</b> (target) <br>  target - number, script id. <br>  Defines the state of the script.  Returns the number of the execution phase: <br>  1 process created (new process exec), <br>  4 script is running (initialized) <br>  24 target sub completed <br>  28 script released <br>  64 not found (host not found), script completed (terminated). <br><br>  <b>isresponsive</b> (target) <br>  target - see getstate (). <br>  Determines the availability of the Me object of the script (status 4 through 28).  Returns a boolean value. <br><br>  <b>executecommand</b> command <br>  command is a string containing instructions. <br>  Call an interpreter to execute statements in the global script space. <br><br>  <b>share</b> varname, value <br>  varname is a string containing the variable name, value is any value. <br>  Declares in the global space of the first script a variable named varname, which becomes available to all scripts in the form of the scene property, assigns the contents of the variable to value. <br><br>  <b>newvar</b> varname <br>  varname is a string containing the variable name. <br>  Declares a new variable in the global script space. <br><br>  <b>free</b> target <br>  target - number, script id or string, name of the subname group of scripts created.  Allows completion of the script after the execution of the target sub'a.  Works with a single script or group. <br><br>  <b>joint</b> (target, state, timeout) <br>  target ‚Äî see free (), state ‚Äî see getstate (), timeout ‚Äî number, in seconds, in milliseconds. <br>  Waiting for the state of the script state, for a group of scripts waiting lasts until everyone reaches the state.  Waiting is limited by timeout, timeout = 0 means unlimited waiting.  Returns a boolean value, True - the wait is complete, False is a timeout.  Designed to synchronize the work of scripts.  For example, if you need to wait for the launch of the script - 4, the full completion of the script - 64; <br><br>  <b>interrupt</b> target, timeout <br>  target - see free (), timeout - value for wscript.timeout, in seconds. <br>  Translates the script to a regular completion, with the execution of the class_terminate methods.  If dialog boxes were opened in the script, it will only be terminated after a timeout pause.  The reappearance of the dialog box in the class_terminate methods will stop completion. <br><br>  <b>push</b> name value <br>  name - string, property name, value - any value. <br>  Places the content of value in the GlobalContainer property named name. <br><br>  <b>pop</b> (name) <br>  name - string, property name. <br>  Returns the content of the property named name from the GlobalContainer. <br><br><h4>  Full version of <b>mproc.vbs</b> : </h4><br><pre> <code class="vbscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">option</span></span> <span class="hljs-keyword"><span class="hljs-keyword">explicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dim</span></span> mproc <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> mproc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> multiprocess mproc.launch <span class="hljs-string"><span class="hljs-string">"base"</span></span>, <span class="hljs-string"><span class="hljs-string">"run"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-comment"><span class="hljs-comment">' main programm section class base public sub run() host.startproc "msg", "run", "first" host.startproc "msg", "run", "second" host.startproc "msg", "run", "third" msgbox "base, id = " &amp; host.id, 64 host.free host.id end sub end class class msg public sub run() msgbox host.aliasname &amp; ", id = " &amp; host.id, 64 host.free host.id end sub end class ' do not modify service class section class multiprocess public primary, ancestor, parent, process, err public names, execs, hosts public id, aid, isprimary public classname, methodname, aliasname public found, lost, active public state, permit, release private container, signature, wshshell public sub launch(startclassname, startmethodname, startaliasname) permit = false release = false executeglobal "dim scene, host, ancestor, process" if not isempty(host) then exit sub set host = me executeglobal "set host.err = err" executeglobal "function getroot: set getroot = me: end function" set parent = getroot isprimary = not wscript.arguments.named.exists("task") if isprimary then dim sample state = 24 randomize signature = "" do signature = signature &amp; hex(rnd * 16) loop while len(signature) &lt; 16 aid = empty id = 0 found = 0 lost = 0 set wshshell = createobject("WScript.Shell") set primary = host set ancestor = nothing set process = nothing set scene = parent set parent.ancestor = nothing set parent.process = nothing set hosts = createobject("Scripting.Dictionary") set execs = createobject("Scripting.Dictionary") set names = createobject("Scripting.Dictionary") classname = empty methodname = empty aliasname = empty set hosts(0) = host set container = getobject("new:{C08AFD90-F2A1-11D1-8455-00A0C91F3880}") container.putproperty signature, parent startproc startclassname, startmethodname, startaliasname on error resume next do for each sample in execs.keys if release or active = 0 then exit do if not (execs(sample) is nothing) then if execs(sample).status &gt; 0 then abolish sample end if end if wscript.sleep 1 next loop release = true state = 28 scenequit else dim job job = split(wscript.arguments.named("task"), ";") signature = cstr(job(0)) do for each container in createobject("Shell.Application").windows if isobject(container.getproperty(signature)) then exit do end if next wscript.sleep 1 loop aid = clng(job(1)) id = clng(job(2)) found = null lost = null set scene = container.getproperty(signature) set primary = scene.host set hosts = primary.hosts set ancestor = hosts(aid) if isresponsive(aid) then set parent.ancestor = ancestor.parent.process else set parent.ancestor = nothing end if classname = cstr(job(3)) methodname = cstr(job(4)) aliasname = cstr(job(5)) state = 4 primary.implicate id, aliasname, host executeglobal "set process = new " &amp; classname executeglobal "set host.process = process" executeglobal "set scene." &amp; aliasname &amp; " = process" if isresponsive(aid) then executeglobal "set host.ancestor.parent." &amp; aliasname &amp; " = process" end if state = 8 primary.staff host ancestorevent "oninitialized" state = 12 if methodname &lt;&gt; "" then do until permit wscript.sleep 10 loop state = 16 executeglobal "process." &amp; methodname end if state = 20 ancestorevent "oncompleted" state = 24 do until release wscript.sleep 10 loop state = 28 end if end sub public default function startproc(classname, methodname, aliasname) set startproc = start(createproc(classname, methodname, aliasname)) end function public function createproc(classname, methodname, aliasname) if aliasname = "" then aliasname = classname newvar aliasname scene.host.newvar aliasname createproc = primary.spawn(id, classname, methodname, aliasname) end function public function spawn(issuer, classname, methodname, aliasname) if not release then found = found + 1 spawn = found active = found - lost names(spawn) = aliasname set hosts(spawn) = nothing if not hosts.exists(aliasname) then hosts.add aliasname, createobject("Scripting.Dictionary") end if set hosts(aliasname)(spawn) = nothing execs.add spawn, wshshell.exec("""" &amp; wscript.fullname &amp; """ """ &amp; wscript.scriptfullname &amp; """ ""/task:" &amp; join(array(signature, issuer, spawn, classname, methodname, aliasname), ";") &amp; """") end if end function public function start(target) select case outline(target) case "Nothing", "multiprocess" do while getstate(target) &lt; 12 wscript.sleep 10 loop if isresponsive(target) then set start = hosts(target).process hosts(target).permit = true else set start = nothing end if case "Dictionary" dim elt set start = hosts(target) for each elt in start.keys do while getstate(elt) &lt; 12 wscript.sleep 10 loop next for each elt in start.keys if isresponsive(elt) then hosts(elt).permit = true end if next case else set start = nothing end select end function public sub implicate(id, aliasname, host) set hosts(aliasname)(id) = host set hosts(id) = host end sub public sub staff(host) set hosts(host.process) = host end sub public sub abolish(id) if hosts.exists(names(id)) then hosts(names(id))(id) = empty end if names(id) = empty if isresponsive(id) then hosts(hosts(id).process) = empty end if hosts(id) = empty set execs(id) = nothing lost = lost + 1 active = found - lost end sub private sub ancestorevent(eventname) if aid &gt; 0 then on error resume next executeglobal "ancestor." &amp; aliasname &amp; "_" &amp; eventname &amp; " host.hosts(" &amp; id &amp; ")" if err.number = 424 or err.number = 438 then err.clear end if end sub public sub assignhandler(handlername, byval varsqty) dim vars vars = "" if varsqty &gt; 0 then do vars = vars &amp; "param" &amp; varsqty varsqty = varsqty - 1 if varsqty = 0 then exit do vars = vars &amp; ", " loop end if executeglobal "sub " &amp; handlername &amp; "(" &amp; vars &amp; "): process." &amp; handlername &amp; " " &amp; vars &amp; ": end sub" end sub public sub newvar(varname) executecommand "dim " &amp; varname end sub public sub executecommand(command) executeglobal command end sub public function getstate(target) select case outline(target) case "multiprocess" on error resume next getstate = hosts(target).state if err.number &lt;&gt; 0 then err.clear getstate = 64 end if case "Nothing" getstate = 1 case "Dictionary" getstate = null case empty getstate = 0 case else getstate = 64 end select end function private function outline(target) on error resume next if hosts.exists(target) then outline = typename(hosts(target)) if err.number &lt;&gt; 0 then err.clear outline = "Object" end if else outline = empty end if end function public function isresponsive(target) isresponsive = cbool(getstate(target) and 28) end function public function getid(target) on error resume next if isobject(target) then if isresponsive(target) then getid = hosts(target).id if err.number = 0 then exit function err.clear end if elseif primary.execs.exists(target) then getid = target exit function end if getid = null end function public function gethost(target) on error resume next if hosts.exists(target) then set gethost = hosts(target) if err.number = 0 then exit function err.clear end if set gethost = nothing end function public sub free(target) select case outline(target) case "multiprocess" on error resume next gethost(target).release = true err.clear case "Dictionary" dim elt for each elt in gethost(target) free(elt) next end select end sub public function joint(target, state, timeout) dim reftime reftime = timer select case outline(target) case "multiprocess", "Nothing" do while getstate(target) &lt; state if timeisout(timeout, reftime) then joint = false exit function end if wscript.sleep 10 loop case "Dictionary" dim elt for each elt in gethost(target) do while getstate(elt) &lt; state if timeisout(timeout, reftime) then joint = false exit function end if wscript.sleep 10 loop next end select joint = true end function private function timeisout(timeout, reftime) if timeout &gt; 0 then dim delta delta = timer - reftime if delta &lt; 0 then delta = delta + 86400 if delta &gt; timeout then timeisout = true end if else timeisout = false end if end function public sub interrupt(target, timeout) select case outline(target) case "multiprocess" on error resume next with gethost(target).parent .wscript.timeout = timeout .wscript.quit end with err.clear case "Dictionary" dim elt for each elt in gethost(target) interrupt elt, timeout next end select end sub public sub kickout(target) if primary.execs.exists(target) then if getstate(target) &lt; 64 then on error resume next primary.execs(target).terminate err.clear end if else select case outline(target) case "multiprocess" kickout getid(target) case "Dictionary" dim elt for each elt in gethost(target) kickout(elt) next end select end if end sub public sub terminate(target) interrupt target, 1 if not joint(target, 64, 2) then kickout target end sub public sub push(name, value) container.putproperty name, value end sub public function pop(name) on error resume next if isobject(container.getproperty(name)) then set pop = container.getproperty(name) else pop = container.getproperty(name) end if end function private sub scenequit if isprimary then dim col, i, status col = execs.keys for i = ubound(col) to 0 step -1 interrupt col(i), 1 next wscript.sleep 2000 on error resume next for i = ubound(col) to 0 step -1 status = execs(col(i)).status if err.number = 0 and status = 0 then execs(col(i)).terminate err.clear next container.quit end if end sub private sub class_terminate() if state &lt; 28 and isprimary then scenequit end sub end class</span></span></code> </pre><br><br><h4>  Description: </h4><br>  Class methods <b>multiprocess</b> : <br><br>  <b>launch</b> classname, methodname, aliasname <br>  It starts the service algorithm, the execution of the script always begins with its call. <br>  classname, methodname, aliasname - strings.  Specify the target class classname and the method of this class methodname, which will be executed in the new process, an instance of the classname class will be placed in a variable named aliasname (or classname if aliasname is the empty string). <br>  Arguments of this method are used only in the initially running script to start executing the main code. <br>  In each new script: <br><ul><li>  Variables are declared in the global space of the running script: <br>  <b>scene</b> - a reference to the Me object of the first script, <br>  <b>host</b> is an instance of the multiprocess class of this script, <br>  <b>process</b> - an instance of the target class with the name classname, which was specified by the preceding script when creating the process of this script, <br>  <b>ancestor</b> is an instance of the target class of the preceding script. </li><li>  Variables are declared in the global space of the scene and the preceding script, with the name <b>aliasname</b> - references to the instance of the target class of the given script. </li><li>  The <b>host</b> properties are set: <br>  <b>primary</b> - a reference to an instance of the multiprocess class of the first script, <br>  <b>ancestor</b> - a link to an instance of the multiprocess class of the preceding script, <br>  <b>parent</b> - the Me object of this script, <br>  <b>process</b> - a reference to process in the global space, <br>  <b>err</b> - reference to the err object of this script, <br>  <b>names</b> - dictionary link with aliasname created in primary, <br>  <b>execs</b> - link to the dictionary with the wshexec objects of running processes, created in primary, <br>  <b>hosts</b> - link to the dictionary with host objects of running processes, created by primary, <br>  <b>id</b> - the sequence number of the script - the key in the dictionaries, <br>  <b>aid</b> - the same as the preceding script <br>  <b>isprimary</b> - boolean, whether this script is initially running, <br>  <b>found, lost, active</b> - only for primary - counters of scripts created, completed and active, <br>  <b>classname, methodname, aliasname</b> - contain the target of the script, <br>  <b>permit</b> = False - the target method will be run after the assignment is True, <br>  <b>release</b> = False - after the completion of the target method, the script will be completed after the assignment True, <br>  <b>state</b> = 4 - the state in which this script is located. </li><li>  Items are added to the <b>names</b> , <b>execs</b> , <b>hosts</b> dictionaries. </li></ul><br>  <b>startproc</b> (classname, methodname, aliasname) <br>  classname, methodname, aliasname - see launch (). <br>  Creates a new script process, expects its readiness to state 12 (see getstate ()), runs the target method.  Returns a reference to an instance of the target class initialized in a new process. <br><br>  <b>createproc</b> (classname, methodname, aliasname) <br>  classname, methodname, aliasname - see launch (). <br>  Creates a new script process, without waiting, returns its id.  Used to create asynchronously several processes in a loop, without waiting for each to be ready.  Noticeably faster than using startproc () for this application. <br><br>  <b>start</b> (target) <br>  target - number, script id, or string, name aliasname of the group of scripts created. <br>  Waiting for a script created using createproc (), to state 12, to allow execution of the target method.  You can use for a group of scripts with the same aliasname.  For one script, returns a reference to its initialized instance of the target class, for a group of scripts, returns a reference to the sub-dictionary containing all host data with aliasname. <br><br>  <b>gethost</b> (target) <br>  target is the number, script id or string, the name of the aliasname group of scripts created, or the process object of the script. <br>  Provides access to the host instance of the multiprocess class of the required script.  For a single script, returns a reference to its host, for a group of scripts, returns a reference to a sub-dictionary containing all host data aliasname, if id is not found or the script is completed - Nothing. <br><br>  <b>getid</b> (target) <br>  target is the number, script id, or process object of the script. <br>  Returns the script id defined by the process object.  Only for valid scripts. <br><br>  <b>getstate</b> (target) <br>  target - see getid (). <br>  Defines the state of the script.  Returns the number of the execution phase: <br>  0 not found (host not found), <br>  1 process created (new process exec), <br>  4 host initialized (host initialized), <br>  8 target class initialized (process initialized), <br>  12 target class initialized, event processed (process initialized handled), <br>  16 target method launched (process method launched), <br>  20 target method completed (process completed), <br>  24 target method completed, event processed (process completed handled), <br>  28 script released <br>  64 script terminated. <br><br>  <b>isresponsive</b> (target) <br>  target - see getid (). <br>  Determines the accessibility of the host object of the script (status 4 through 28).  Returns a boolean value. <br><br>  <b>assignhandler</b> handlername, varsqty <br>  handlername - string, event name, varsqty - number, number of arguments passed. <br>  In the global space, it creates a sub event handler with the name of the handlername event and associates it with the method of the same name in the created process object.  When an event occurs, the handler will redirect the call to process.  handlername (). <br><br>  <b>executecommand</b> command <br>  command is a string containing instructions. <br>  Call an interpreter to execute statements in the global script space. <br><br>  <b>newvar</b> varname <br>  varname is a string containing the variable name. <br>  Declares a new variable in the global script space. <br><br>  <b>free</b> target <br>  target - see gethost (). <br>  Allows completion of the script after the execution of the target method  Works with a single script or group. <br><br>  <b>joint</b> (target, state, timeout) <br>  target ‚Äî see gethost (); state ‚Äî see getstate (), timeout ‚Äî number, in seconds, in milliseconds. <br>  Waiting for the state of the script state, for a group of scripts waiting lasts until everyone reaches the state.  Waiting is limited by timeout, timeout = 0 means unlimited waiting.  Returns a boolean value, True - the wait is complete, False is a timeout.  Designed to synchronize the work of scripts.  For example, if you need to wait for the creation of a process object - 8, the script is fully completed - 64; <br><br>  <b>interrupt</b> target, timeout <br>  target - see gethost (), timeout - value for wscript.timeout, in seconds. <br>  Translates the script to a regular completion, with the execution of the class_terminate methods.  If dialog boxes were opened in the script, it will only be terminated after a timeout pause.  The reappearance of the dialog box in the class_terminate methods will stop completion. <br><br>  <b>kickout</b> target <br>  target - see gethost (). <br>  Terminates the script process at the OS level using wshexec.terminate.  Possible long-term execution, up to 2 seconds for each script.  Works with a single script or group. <br><br>  <b>terminate</b> target <br>  target - see gethost (). <br>  Ends the script, uses interrupt first, then kickout if necessary. <br><br>  <b>push</b> name value <br>  name - string, property name, value - any value. <br>  Places the content of value in the GlobalContainer property named name. <br><br>  <b>pop</b> (name) <br>  name - string, property name. <br>  Returns the content of the property named name from the GlobalContainer. <br><br>  Methods that can be placed in the target class of this script as handlers for the initialization of the target class and the execution of the target method of the running script: <br><br>  <b>&lt;aliasname&gt; _ oninitialized</b> (source) <br>  source - the host object of the script that called the method passed to the method, its aliasname is contained in the method name.  The method is called after the initialization of the target class of the running script (state = 8). <br><br>  <b>&lt;aliasname&gt; _ oncompleted</b> (source) <br>  source - the host object of the script that called the method passed to the method, its aliasname is contained in the method name.  The method is called after the execution of the target method of the running script (state = 20). <br><br><h4>  Example: </h4><br>  For <a href="http://pastebin.com/gwGLXmVH">mproclite</a> and <a href="http://pastebin.com/KSJxpykp">mproc</a> , the work is illustrated by the example of an abstract task: for each character from the letters string, separate processes are created, each in a loop placing its character into the buffer, as it is filled in by another process, 3 ‚Äúwords‚Äù are output to the console.  For WScript, the console is simulated by the IE window.  Along the way, running and stopped OS processes are displayed (in the example, WMI is used, but it is not necessary for the mechanism to function). <br>  During the debug, I have accumulated some observations and comments, with which I will share if there is a demand - the fact is that it will take time to bring them into a readable form.  Constructive criticism is welcome. </div><p>Source: <a href="https://habr.com/ru/post/189786/">https://habr.com/ru/post/189786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../189766/index.html">Color theory in numbers</a></li>
<li><a href="../189772/index.html">About one way to protect the source code of the Python-program</a></li>
<li><a href="../189778/index.html">Client Tests on Lettuce + Selenium</a></li>
<li><a href="../189782/index.html">JavaScript: how to smoke IE10, or migration problems</a></li>
<li><a href="../189784/index.html">Announcement: Introduction to the YotaPhone SDK for Developers</a></li>
<li><a href="../189788/index.html">The basis of AI - the structure of the mind</a></li>
<li><a href="../189792/index.html">Creating a simple bot for WoW, programming routes</a></li>
<li><a href="../189794/index.html">Creating Metaboxes in WordPress</a></li>
<li><a href="../189798/index.html">Hadoop Tutorial. Writing your grep</a></li>
<li><a href="../189802/index.html">Unreal LED, or load management from Unreal Tournament</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>