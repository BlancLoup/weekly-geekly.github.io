<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>5D market. Projection systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have been on the 5D platform market for more than 5 years. During this time I have accumulated a solid store of knowledge, which I decided to share...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>5D market. Projection systems</h1><div class="post__text post__text-html js-mediator-article">  We have been on the 5D platform market for more than 5 years.  During this time I have accumulated a solid store of knowledge, which I decided to share.  In the first part I want to talk about the projection systems used in this industry, as well as about the adaptation of our software for them.  What solutions we used and why.  I deliberately do not invoke the trademark, so that they do not consider that the post is just an advertisement for the next program. <br>  So.  5D is primarily a cinema with stereo content.  After all, sound or tactile sensations are not as important for most people as the video series. <br><a name="habracut"></a><br><h4>  The following technologies are currently used on the market: </h4><br><ol><li>  2-projector system with linear or circular polarization.  The main disadvantage is the frequent burnout of polarizing filters. <br><br></li><li>  Stereo ‚Äúhomemade‚Äù emitter, where for synchronization is used 3-din connector of professional nvidia video cards.  The main disadvantage is that the video card with this connector is now practically not available. <br><br></li><li>  Nvidia 3D vision, where the standard emitter is ‚Äúhacked‚Äù and the synchronization signal is transmitted to another, because the standard is very weak and not stable on a long wire.  There are manufacturers who can only install 301 drivers, as further NVIDIA has improved protection.  But, for example, we solved this question in a fundamentally different way, so we are not afraid of these security updates. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li>  RedPoint sync-based adapter to VGA cable.  Where in each non-even frame, a marker is placed at the top in the form of a red dot, so that the adapter recognizes where the frame is even, where it is not.  The main disadvantage is VGA with all the resulting picture quality. <br><br></li><li>  Various multi-projector solutions based on claim 1, item 3 or mono. </li></ol><br><h4>  And the screens are also different: </h4><br><ol><li>  The usual rectangular screen of various proportions (as a rule, to the maximum for the hall, less often adhering to 16: 9 or 4: 3). <br><br></li><li>  The rectangular main screen and on the sides of 2 non-large screens are also flat. <br><br></li><li>  Cylindrical screen with approximately equal distance from any point along one horizontal line to the projector (s). <br><br></li><li>  Various screens of complex shapes: spheres, uneven walls of museums, etc. </li></ol><br>  And there was a task for the render to work on all systems, OS from win XP to 10, etc.  And, most often, this is the old hardware and windows XP.  Writing the render itself was not a problem, I had previously developed many cool pieces for ProgDVB, including his, but then there was the problem of mixing multi-projector systems.  It is almost impossible to hang 2 different projectors, forcing them to shine at one point.  For this, before, special expensive adjusting platforms had to be used, which had to be wound for a long time somewhere under the ceiling in an uncomfortable position, and since it was a mechanic, the projectors could again ‚Äúdisperse‚Äù from any more or less strong cotton. <br><br>  Yes, and with single-projector systems, too, everything is not so smooth.  Although the projectors themselves are able to adjust the geometry, they do it too stepwise. <br><br><h4>  Therefore, a simple grid was taken from the TV channel settings: </h4><br><img src="https://habrastorage.org/web/074/72e/19d/07472e19d6b641e1ad393a6034317b5a.jpg"><br><br>  <i>That mouse can be distorted like this:</i> <br><br><img src="https://habrastorage.org/web/4ca/b98/a8d/4cab98a8d11d4faaac2f5efdb4e0c577.jpg"><br><br>  So that both projectors start shining on the screen with corresponding pixels at one point. <br>  But manually reducing 2 projectors on a flat screen is not difficult.  Our software also works on more complex systems.  Take, for example, a 6-projection system with a cylindrical screen.  And since the screen is cylindrical - for each of the 6 parts of the ‚Äúgrid‚Äù you need not just linear distortion, but a much more complicated algorithm that is extremely hard and long to manually do. <br><br><img src="https://habrastorage.org/web/164/c8a/d18/164c8ad18a8c48b795fd7f9c5a6dae77.jpg" alt="image"><br>  <i>Six-projector system</i> <br><br>  Therefore, I have developed an <i>optical module for automatic adjustment</i> , naturally adaptable to different screens and lighting: <br><br><img src="https://habrastorage.org/web/d09/0c9/686/d090c9686e2e43f7951ff1295eab3137.jpg"><br><br>  To create the ‚Äúnon-discontinuity‚Äù effect of ‚Äúneighboring‚Äù projectors, a gradient transition is used, damping with the natural logarithm coefficient (of course, through the simplest calculation on a pixel shader of a linearly specified color at a given point).  Those.  one point has a color (1,1,1), the second (0,0,0).  The resulting shader code snippet <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cc=<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(color)*kj; float4 c2=rgb*<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(cc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c2;</code> </pre> <br>  Where kj is a parameter selected every time, for each particular projection system and screen, which depends, first of all, on how much black the projector actually has black. <br><br>  At the bottom there are various settings and a real picture from the camera, at the top, the program itself recognizes the screen and fits into it the setting picture as accurately as possible. <br><br><img src="https://habrastorage.org/web/63e/086/ac2/63e086ac22c743f0aa3b0c954bfcc561.jpg"><br><br>  And then it remains only to run the recalculation.  Thus, to compare, again, with the help of the camera, the position on the screen inside this adjustment grid and what the projector displays.  That is, highlight the individual pixels on the projector and see where they will be on the camera.  But highlighting every n pixel is long.  In order not to delay recalculation, I print vertical lines first, then horizontal lines with a certain step.  And do not forget that the camera in poor lighting conditions is a very inert thing.  Therefore, it is also necessary to correctly select the delay between the line output and its scanning. <br><br>  Some technical details (Delphi).  The most important function is the ‚Äúforest fire‚Äù calculation of the screen area on the camera.  The user pokes the mouse or (usually) a finger at the touchscreen, thereby setting the starting point.  It is important to choose the right lighting for a better screen-non-screen contrast. <br><br><div class="spoiler">  <b class="spoiler_title">Data preparation</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TCam_Geometry_frm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcPixelRegion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y:integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> StartP:TPoint; I: Integer; J: Integer; StaPo,EnPo:integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> StartP.X := x * InternalBitmap.Width <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> Image1.Width; StartP.Y := y * InternalBitmap.Height <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> Image1.Height; SetLength(CheckingMask,InternalBitmap.Height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> InternalBitmap.Height - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(CheckingMask[i],InternalBitmap.Width); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> J := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> InternalBitmap.Width-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckingMask[i][j].IsCheckPoint := false; CheckingMask[i][j].IsPointChecked := false; CheckingMask[i][j].typ := <span class="hljs-number"><span class="hljs-number">0</span></span>; CheckingMask[i][j].texX := -<span class="hljs-number"><span class="hljs-number">1</span></span>; CheckingMask[i][j].texY := -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; SetLength(TempFireBuf,InternalBitmap.Width * InternalBitmap.Height * <span class="hljs-number"><span class="hljs-number">4</span></span>); StaPo := <span class="hljs-number"><span class="hljs-number">0</span></span>; EnPo := <span class="hljs-number"><span class="hljs-number">1</span></span>; TempFireBuf[<span class="hljs-number"><span class="hljs-number">0</span></span>].XPos := StartP.X; TempFireBuf[<span class="hljs-number"><span class="hljs-number">0</span></span>].YPos := StartP.Y; CheckingMask[StartP.Y][StartP.X].IsPointChecked := true; CheckingMask[StartP.Y][StartP.X].IsCheckPoint := true; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> StaPo &lt;&gt; EnPo <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abs(InternalPic.GetRED(TempFireBuf[StaPo].XPos, TempFireBuf[StaPo].YPos)- InternalPic.GetRED(TempFireBuf[TempFireBuf[StaPo].pripos].XPos, TempFireBuf[TempFireBuf[StaPo].pripos].YPos))&lt;SpinEdit1.Value) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (abs(InternalPic.GetGreen(TempFireBuf[StaPo].XPos, TempFireBuf[StaPo].YPos)-InternalPic.GetGreen(TempFireBuf[TempFireBuf[StaPo].pripos].XPos, TempFireBuf[TempFireBuf[StaPo].pripos].YPos))&lt;SpinEdit1.Value) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (abs(InternalPic.GetBlue(TempFireBuf[StaPo].XPos, TempFireBuf[StaPo].YPos)-InternalPic.GetBlue(TempFireBuf[TempFireBuf[StaPo].pripos].XPos, TempFireBuf[TempFireBuf[StaPo].pripos].YPos))&lt;SpinEdit1.Value) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckingMask[TempFireBuf[StaPo].YPos][TempFireBuf[StaPo].XPos].IsCheckPoint := true; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TempFireBuf[StaPo].XPos &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> CheckingMask[TempFireBuf[StaPo].YPos][TempFireBuf[StaPo].XPos-<span class="hljs-number"><span class="hljs-number">1</span></span>].IsPointChecked <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TempFireBuf[EnPo].XPos := TempFireBuf[StaPo].XPos-<span class="hljs-number"><span class="hljs-number">1</span></span>; TempFireBuf[EnPo].YPos := TempFireBuf[StaPo].YPos; TempFireBuf[EnPo].pripos := StaPo; CheckingMask[TempFireBuf[EnPo].YPos][TempFireBuf[EnPo].XPos].IsPointChecked := true; inc(EnPo); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TempFireBuf[StaPo].XPos &lt; InternalBitmap.Width - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> CheckingMask[TempFireBuf[StaPo].YPos][TempFireBuf[StaPo].XPos+<span class="hljs-number"><span class="hljs-number">1</span></span>].IsPointChecked <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TempFireBuf[EnPo].XPos := TempFireBuf[StaPo].XPos+<span class="hljs-number"><span class="hljs-number">1</span></span>; TempFireBuf[EnPo].YPos := TempFireBuf[StaPo].YPos; TempFireBuf[EnPo].pripos := StaPo; CheckingMask[TempFireBuf[EnPo].YPos][TempFireBuf[EnPo].XPos].IsPointChecked := true; inc(EnPo); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TempFireBuf[StaPo].YPos &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> CheckingMask[TempFireBuf[StaPo].YPos-<span class="hljs-number"><span class="hljs-number">1</span></span>][TempFireBuf[StaPo].XPos].IsPointChecked <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TempFireBuf[EnPo].XPos := TempFireBuf[StaPo].XPos; TempFireBuf[EnPo].YPos := TempFireBuf[StaPo].YPos-<span class="hljs-number"><span class="hljs-number">1</span></span>; TempFireBuf[EnPo].pripos := StaPo; CheckingMask[TempFireBuf[EnPo].YPos][TempFireBuf[EnPo].XPos].IsPointChecked := true; inc(EnPo); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TempFireBuf[StaPo].YPos &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (TempFireBuf[StaPo].YPos &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(<span class="hljs-string"><span class="hljs-string">'     .   .'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TempFireBuf[StaPo].YPos &lt; InternalBitmap.Height - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> CheckingMask[TempFireBuf[StaPo].YPos+<span class="hljs-number"><span class="hljs-number">1</span></span>][TempFireBuf[StaPo].XPos].IsPointChecked <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TempFireBuf[EnPo].XPos := TempFireBuf[StaPo].XPos; TempFireBuf[EnPo].YPos := TempFireBuf[StaPo].YPos+<span class="hljs-number"><span class="hljs-number">1</span></span>; TempFireBuf[EnPo].pripos := StaPo; CheckingMask[TempFireBuf[EnPo].YPos][TempFireBuf[EnPo].XPos].IsPointChecked := true; inc(EnPo); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; inc(StaPo); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; SetLength(TempFireBuf,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Then we simply transform this set of pixels into a region, in which we will look for lines later. <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TCam_Geometry_frm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFrame</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nn:<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> integer; i,j,k,l,tmp:integer; rasts:<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">4</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">of</span></span> extended; rad:extended; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> nn[i] := GetMinY(i); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> InternalPic.PicX - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nn[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (nn[<span class="hljs-number"><span class="hljs-number">5</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (nn[<span class="hljs-number"><span class="hljs-number">10</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (abs(nn[<span class="hljs-number"><span class="hljs-number">10</span></span>]-nn[<span class="hljs-number"><span class="hljs-number">1</span></span>])&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> tmp := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> tmp := tmp + nn[l]; tmp := tmp <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nn[<span class="hljs-number"><span class="hljs-number">5</span></span>] &lt; tmp <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckingMask[nn[<span class="hljs-number"><span class="hljs-number">5</span></span>]][i-<span class="hljs-number"><span class="hljs-number">6</span></span>].IsCheckPoint := false; inc(nn[<span class="hljs-number"><span class="hljs-number">5</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nn[<span class="hljs-number"><span class="hljs-number">5</span></span>] &gt; tmp <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckingMask[nn[<span class="hljs-number"><span class="hljs-number">5</span></span>]][i-<span class="hljs-number"><span class="hljs-number">6</span></span>].IsCheckPoint := true; dec(nn[<span class="hljs-number"><span class="hljs-number">5</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j := <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> nn[j-<span class="hljs-number"><span class="hljs-number">1</span></span>] := nn[j]; nn[<span class="hljs-number"><span class="hljs-number">10</span></span>] := GetMinY(i); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> nn[i] := GetMaxY(i); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> InternalPic.PicX - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nn[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (nn[<span class="hljs-number"><span class="hljs-number">5</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (nn[<span class="hljs-number"><span class="hljs-number">10</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (abs(nn[<span class="hljs-number"><span class="hljs-number">10</span></span>]-nn[<span class="hljs-number"><span class="hljs-number">1</span></span>])&lt; <span class="hljs-number"><span class="hljs-number">7</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> tmp := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> tmp := tmp + nn[l]; tmp := tmp <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nn[<span class="hljs-number"><span class="hljs-number">5</span></span>] &lt;= tmp <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckingMask[nn[<span class="hljs-number"><span class="hljs-number">5</span></span>]][i-<span class="hljs-number"><span class="hljs-number">6</span></span>].IsCheckPoint := false; inc(nn[<span class="hljs-number"><span class="hljs-number">5</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nn[<span class="hljs-number"><span class="hljs-number">5</span></span>] &gt; tmp <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CheckingMask[nn[<span class="hljs-number"><span class="hljs-number">5</span></span>]][i-<span class="hljs-number"><span class="hljs-number">6</span></span>].IsCheckPoint := true; dec(nn[<span class="hljs-number"><span class="hljs-number">5</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j := <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> nn[j-<span class="hljs-number"><span class="hljs-number">1</span></span>] := nn[j]; nn[<span class="hljs-number"><span class="hljs-number">10</span></span>] := GetMaxY(i); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; rasts[<span class="hljs-number"><span class="hljs-number">1</span></span>] := <span class="hljs-number"><span class="hljs-number">0</span></span>;rasts[<span class="hljs-number"><span class="hljs-number">2</span></span>] := <span class="hljs-number"><span class="hljs-number">0</span></span>;rasts[<span class="hljs-number"><span class="hljs-number">3</span></span>] := <span class="hljs-number"><span class="hljs-number">0</span></span>;rasts[<span class="hljs-number"><span class="hljs-number">4</span></span>] := <span class="hljs-number"><span class="hljs-number">0</span></span>; Center.X := <span class="hljs-number"><span class="hljs-number">0</span></span>;Center.Y := <span class="hljs-number"><span class="hljs-number">0</span></span>; k := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> InternalPic.PicY - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> J := <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> InternalPic.PicX - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CheckingMask[i][j].IsCheckPoint <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Center.X := Center.X + J; Center.Y := Center.Y + I; inc(k); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Center.X := Center.X <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> k; Center.Y := Center.Y <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> k; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> InternalPic.PicY - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> J := <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> InternalPic.PicX - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CheckingMask[i][j].IsCheckPoint <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rad := (J-Center.X)*(J-Center.X)+(I-Center.Y)*(I-Center.Y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt; Center.Y <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j &lt; Center.X <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rasts[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; rad) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rasts[<span class="hljs-number"><span class="hljs-number">1</span></span>] := rad; X1Y1.X := J; X1Y1.Y := I; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rasts[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt; rad) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rasts[<span class="hljs-number"><span class="hljs-number">2</span></span>] := rad; X2Y1.X := J; X2Y1.Y := I; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> j &lt; Center.X <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rasts[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt; rad) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rasts[<span class="hljs-number"><span class="hljs-number">3</span></span>] := rad; X1Y2.X := J; X1Y2.Y := I; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rasts[<span class="hljs-number"><span class="hljs-number">4</span></span>] &lt; rad) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rasts[<span class="hljs-number"><span class="hljs-number">4</span></span>] := rad; X2Y2.X := J; X2Y2.Y := I; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; LeftSetkaSide.IsHorisontOnScreen := false; LeftSetkaSide.CoordVal := <span class="hljs-number"><span class="hljs-number">0</span></span>; LeftSetkaSide.IsHorisontVals := false; LeftSetkaSide.x[<span class="hljs-number"><span class="hljs-number">1</span></span>] := X1Y1.X; LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">1</span></span>] := X1Y1.Y; LeftSetkaSide.x[<span class="hljs-number"><span class="hljs-number">2</span></span>] := X1Y2.X; LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">2</span></span>] := X1Y2.Y; LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">3</span></span>] := (LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">1</span></span>]+LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">2</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; LeftSetkaSide.x[<span class="hljs-number"><span class="hljs-number">3</span></span>] := GetMinX(Round(LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">3</span></span>])); LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">4</span></span>] := (LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">1</span></span>] + LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">3</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; LeftSetkaSide.x[<span class="hljs-number"><span class="hljs-number">4</span></span>] := GetMinX(Round(LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">4</span></span>])); LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">5</span></span>] := (LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">2</span></span>] + LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">3</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; LeftSetkaSide.x[<span class="hljs-number"><span class="hljs-number">5</span></span>] := GetMinX(Round(LeftSetkaSide.y[<span class="hljs-number"><span class="hljs-number">5</span></span>])); RightSetkaSide.IsHorisontOnScreen := false; RightSetkaSide.CoordVal := <span class="hljs-number"><span class="hljs-number">0</span></span>; RightSetkaSide.IsHorisontVals := false; RightSetkaSide.x[<span class="hljs-number"><span class="hljs-number">1</span></span>] := X2Y1.X; RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">1</span></span>] := X2Y1.Y; RightSetkaSide.x[<span class="hljs-number"><span class="hljs-number">2</span></span>] := X2Y2.X; RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">2</span></span>] := X2Y2.Y; RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">3</span></span>] := (RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">1</span></span>]+RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">2</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; RightSetkaSide.x[<span class="hljs-number"><span class="hljs-number">3</span></span>] := GetMaxX(Round(RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">3</span></span>])); RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">4</span></span>] := (RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">1</span></span>] + RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">3</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; RightSetkaSide.x[<span class="hljs-number"><span class="hljs-number">4</span></span>] := GetMaxX(Round(RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">4</span></span>])); RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">5</span></span>] := (RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">2</span></span>] + RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">3</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; RightSetkaSide.x[<span class="hljs-number"><span class="hljs-number">5</span></span>] := GetMaxX(Round(RightSetkaSide.y[<span class="hljs-number"><span class="hljs-number">5</span></span>])); UpSetkaSide.IsHorisontOnScreen := true; UpSetkaSide.CoordVal := <span class="hljs-number"><span class="hljs-number">0</span></span>; UpSetkaSide.IsHorisontVals := false; UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">1</span></span>] := X1Y1.X; UpSetkaSide.y[<span class="hljs-number"><span class="hljs-number">1</span></span>] := X1Y1.Y; UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">2</span></span>] := X2Y1.X; UpSetkaSide.y[<span class="hljs-number"><span class="hljs-number">2</span></span>] := X2Y1.Y; UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">3</span></span>] := (UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">1</span></span>]+UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">2</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; UpSetkaSide.y[<span class="hljs-number"><span class="hljs-number">3</span></span>] := GetMinY(Round(UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">3</span></span>])); UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">4</span></span>] := (UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">1</span></span>]+UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">3</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; UpSetkaSide.y[<span class="hljs-number"><span class="hljs-number">4</span></span>] := GetMinY(Round(UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">4</span></span>])); UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">5</span></span>] := (UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">2</span></span>]+UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">3</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; UpSetkaSide.y[<span class="hljs-number"><span class="hljs-number">5</span></span>] := GetMinY(Round(UpSetkaSide.x[<span class="hljs-number"><span class="hljs-number">5</span></span>])); DownSetkaSide.IsHorisontOnScreen := true; DownSetkaSide.CoordVal := <span class="hljs-number"><span class="hljs-number">0</span></span>; DownSetkaSide.IsHorisontVals := false; DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">1</span></span>] := X1Y2.X; DownSetkaSide.y[<span class="hljs-number"><span class="hljs-number">1</span></span>] := X1Y2.Y; DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">2</span></span>] := X2Y2.X; DownSetkaSide.y[<span class="hljs-number"><span class="hljs-number">2</span></span>] := X2Y2.Y; DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">3</span></span>] := (DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">1</span></span>]+DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">2</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; DownSetkaSide.y[<span class="hljs-number"><span class="hljs-number">3</span></span>] := GetMaxY(Round(DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">3</span></span>])); DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">4</span></span>] := (DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">1</span></span>]+DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">3</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; DownSetkaSide.y[<span class="hljs-number"><span class="hljs-number">4</span></span>] := GetMaxY(Round(DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">4</span></span>])); DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">5</span></span>] := (DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">2</span></span>]+DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">3</span></span>]) / <span class="hljs-number"><span class="hljs-number">2</span></span>; DownSetkaSide.y[<span class="hljs-number"><span class="hljs-number">5</span></span>] := GetMaxY(Round(DownSetkaSide.x[<span class="hljs-number"><span class="hljs-number">5</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br></div></div><br>  After that, you just need to do all the checks for out-of-bounds, and calculate its texture coordinate for each pixel. <br><br>  Well, now just run the mapping. <br><br><div class="spoiler">  <b class="spoiler_title">The main algorithm for calculating</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TCam_Geometry_frm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddLograngeKoeffs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n:integer;byX:boolean;coord:integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, J: integer; possx,possy,ccou:integer; srX1,srY1:extended; lfid:integer; foundPoints:arrpo; Center:TPoint; Clct,Clct2,Clct3,last:TPoint; dy,sry,ddy,y:extended; <span class="hljs-comment"><span class="hljs-comment">// CheAr:array of array of boolean; begin possx := 0; possy := 0; ccou := 0; SetLength(foundPoints,0); for I := 0 to Length(ProjSetka[n]) - 1 do for J := 0 to Length(ProjSetka[n][i]) - 1 do begin if (byX and (ProjSetka[n][i][j].ProjX = coord) and IsPossHere(n,j,i,byX,20, 20,srX1,srY1))or ((not byX) and (ProjSetka[n][i][j].ProjY = coord) and IsPossHere(n,j,i,byX,20, 20,srX1,srY1))then begin possx := possx + j; possy := possy + i; inc(ccou); SetLength(foundPoints,ccou); foundPoints[ccou-1].X := J; foundPoints[ccou-1].Y := I; end; end; if ccou &lt; 10 then begin possx := -3; exit; end; possx := possx div ccou; possy := possy div ccou; Center.X := possx; Center.Y := possy; lfid := length(LograngeFuncs[n]); SetLength(LograngeFuncs[n],length(LograngeFuncs[n])+1); LograngeFuncs[n][lfid].IsHorisontOnScreen := false; LograngeFuncs[n][lfid].CoordVal := coord; LograngeFuncs[n][lfid].IsHorisontVals := byX; i := GetMinLengthFromArr(foundPoints,Center); if i &lt; 0 then begin ShowMessage('       !'); exit; end; IsPossHere(n,foundPoints[i].X,foundPoints[i].Y,byX,20, 20,srX1,srY1); LograngeFuncs[n][lfid].x[1] := srX1; LograngeFuncs[n][lfid].Y[1] := srY1; foundPoints[i].X := -1; i := GetMaxLengthFromArr(foundPoints,Center); IsPossHere(n,foundPoints[i].X,foundPoints[i].Y,byX,20, 20,srX1,srY1); LograngeFuncs[n][lfid].x[5] := srX1; LograngeFuncs[n][lfid].Y[5] := srY1; foundPoints[i].X := -1; Clct.X := round(srX1); Clct.Y := round(srY1); i := GetMaxLengthFromArr(foundPoints,Center); while abs(GetAngleFrom3Points(Center,Clct,foundPoints[i])) &lt; Pi / 2 do begin foundPoints[i].X := -1; i := GetMaxLengthFromArr(foundPoints,Center); if i &lt; 0 then begin ShowMessage('     !'); exit; end; end; IsPossHere(n,foundPoints[i].X,foundPoints[i].Y,byX,20, 20,srX1,srY1); LograngeFuncs[n][lfid].x[4] := srX1; LograngeFuncs[n][lfid].Y[4] := srY1; Clct2.X := round(srX1); Clct2.Y := round(srY1); LograngeFuncs[n][lfid].x[2] := -1; LograngeFuncs[n][lfid].x[3] := -1; while (LograngeFuncs[n][lfid].x[2] &lt; 0) or (LograngeFuncs[n][lfid].x[3] &lt; 0) do begin i := GetNearestFromArr(foundPoints,Center,min(GetLengthBW2P(Center,Clct),GetLengthBW2P(Center,Clct2)) div 2); if LograngeFuncs[n][lfid].x[2] &lt; 0 then begin IsPossHere(n,foundPoints[i].X,foundPoints[i].Y,byX,20, 20,srX1,srY1); LograngeFuncs[n][lfid].x[2] := srX1; LograngeFuncs[n][lfid].Y[2] := srY1; foundPoints[i].X := -1; Clct3.X := round(srX1); Clct3.Y := round(srY1); end else begin if i &lt; 0 then begin LograngeFuncs[n][lfid].x[3] := last.X; LograngeFuncs[n][lfid].Y[3] := last.Y; end else if abs(GetAngleFrom3Points(Center,Clct3,foundPoints[i])) &gt; Pi / 2 then begin IsPossHere(n,foundPoints[i].X,foundPoints[i].Y,byX,20, 20,srX1,srY1); LograngeFuncs[n][lfid].x[3] := srX1; LograngeFuncs[n][lfid].Y[3] := srY1; end; end; if i &gt;= 0 then begin last := foundPoints[i]; foundPoints[i].X := -1; end; end; if abs(LograngeFuncs[n][lfid].x[1]-LograngeFuncs[n][lfid].x[5]) &gt; abs(LograngeFuncs[n][lfid].y[1]-LograngeFuncs[n][lfid].y[5]) then begin LograngeFuncs[n][lfid].IsHorisontOnScreen := true; end else LograngeFuncs[n][lfid].IsHorisontOnScreen := false; if LograngeFuncs[n][lfid].IsHorisontOnScreen then begin sry := 0; for I := 1 to 5 do sry := sry + LograngeFuncs[n][lfid].y[i]; sry := sry / 5; dy := 0; for I := 1 to 5 do if dy &lt; abs(sry - LograngeFuncs[n][lfid].y[i]) then dy := abs(sry - LograngeFuncs[n][lfid].y[i]); dy := dy * 3 + 5; for I := 10 to 1000 do begin y := CalcPointByPolinom(n,lfid,i,-1); if (y &gt; 0) and(dy &lt; abs(sry - y)) then begin SetLength(LograngeFuncs[n],length(LograngeFuncs[n])-1); exit; end; end; end else begin sry := 0; for I := 1 to 5 do sry := sry + LograngeFuncs[n][lfid].x[i]; sry := sry / 5; dy := 0; for I := 1 to 5 do if dy &lt; abs(sry - LograngeFuncs[n][lfid].x[i]) then dy := abs(sry - LograngeFuncs[n][lfid].x[i]); dy := dy * 3+5; for I := 10 to 1000 do begin y := CalcPointByPolinom(n,lfid,-1,i); if (y &gt; 0) and(dy &lt; abs(sry - y)) then begin SetLength(LograngeFuncs[n],length(LograngeFuncs[n])-1); exit; end; end; end; end;</span></span></code> </pre> <br>  It is applied like this: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TCam_Geometry_frm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sButton3Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, couu: Integer; geom_frms:<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Tcam_geomery_lines_ouput_frm; j,l: Integer; k, pos: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> sButton1.Enabled <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FlagStop:=true;<span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; FlagStop:=false; SetLength(geom_frms,g_MonitorsCount); SetLength(ProjSetka,g_MonitorsCount); SetLength(LograngeFuncs,g_MonitorsCount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> g_MonitorsCount-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> geom_frms[i] := Tcam_geomery_lines_ouput_frm.Create(self); geom_frms[i].PosX := g_MonitorsSetup[i+<span class="hljs-number"><span class="hljs-number">1</span></span>].ScreenPosition.x; geom_frms[i].PosY := g_MonitorsSetup[i+<span class="hljs-number"><span class="hljs-number">1</span></span>].ScreenPosition.y; Application.ProcessMessages; SetLength(ProjSetka[i],length(CheckingMask)); SetLength(LograngeFuncs[i],<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> J := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> length(CheckingMask)-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(ProjSetka[i][j],length(CheckingMask[j])); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> length(CheckingMask[j]) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ProjSetka[i][j][k].ProjX := -<span class="hljs-number"><span class="hljs-number">1</span></span>; ProjSetka[i][j][k].ProjY:= -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; sButton2.Enabled := false; sButton1.Enabled := false; sButton17.Enabled := false; sButton4.Enabled := false; sButton5.Enabled := false; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> g_MonitorsCount-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> geom_frms[i].Show; geom_frms[i].SetBlack; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> L := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Application.ProcessMessages; Sleep(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; GetBitmapFromCam(blackBitmap); InitPicBuffer(blackPic,blackBitmap.Width,blackBitmap.Height); CopyToPic(blackBitmap,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,blackPic); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> g_MonitorsCount-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> L := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Application.ProcessMessages; Sleep(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; GetBitmapFromCam(blackBitmap); CopyToPic(blackBitmap,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,blackPic); couu := <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FlagStop <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> couu <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pos := j*geom_frms[i].Width <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> couu; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> pos := <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos &gt;= geom_frms[i].Width - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> pos := geom_frms[i].Width - <span class="hljs-number"><span class="hljs-number">4</span></span>; geom_frms[i].PaintLine(pos,<span class="hljs-number"><span class="hljs-number">0</span></span>,pos,geom_frms[i].Height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> L := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Application.ProcessMessages; Sleep(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> SaveProjLineCoords(i,pos,-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FlagStop := true; AddLograngeKoeffs(i,true,pos); pos := j*geom_frms[i].Height <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> couu; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> pos := <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos &gt;= geom_frms[i].Height - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> pos := geom_frms[i].Height - <span class="hljs-number"><span class="hljs-number">4</span></span>; geom_frms[i].PaintLine(<span class="hljs-number"><span class="hljs-number">0</span></span>,pos,geom_frms[i].Width,pos); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> L := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Application.ProcessMessages; Sleep(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> SaveProjLineCoords(i,-<span class="hljs-number"><span class="hljs-number">1</span></span>,pos) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FlagStop := true; AddLograngeKoeffs(i,false,pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FlagStop <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; geom_frms[i].SetBlack; <span class="hljs-comment"><span class="hljs-comment">// geom_frms[i].hide; SaveProjSsetka(i); end; if not FlagStop then SetCaptSetkaWidthToOne; if not FlagStop then CreateProjSetka; for I := 0 to g_MonitorsCount-1 do begin geom_frms[i].Free; end; if not FlagStop then SaveGeometry; sButton2.Enabled := true; sButton1.Enabled := true; sButton17.Enabled := true; sButton4.Enabled := true; sButton5.Enabled := true; end;</span></span></code> </pre> <br></div></div><br>  Everything.  Each pixel of the projector (of those that are possible) is associated with a pixel on the screen. <br><br>  Now you can enjoy the result. <br><br><img src="https://habrastorage.org/web/ade/96a/a41/ade96aa41c744b45b8cfba8a6ee07ebe.jpg"><br><br>  The image is split due to the stereo image.  Glasses are much more interesting.  Peresveta information is clearly visible on the camera, as it is on the side.  From the platform, and even with glasses, the effect is minimal. <br><br>  Another part of the video, where the 3D effect is minimal and you can evaluate exactly the reduction. <br><br><img src="https://habrastorage.org/web/5cf/f30/c03/5cff30c038284557a39372daf3bf7d25.jpg"><br><br>  <b>And a couple of important notes:</b> <br><br>  <i>First</i> , the output to each projector is necessarily its own stream, with its frame cache and synchronization with vsync.  Otherwise, you will have everything or slow down or tear the picture.  Especially if the projectors under 12. <br><br>  <i>Secondly</i> , if you stretch a 4: 3 picture, suppose to 16: 9, but the picture is cartoonish, and the proportions of the objects are not very clear, there will be no big problems.  But if you stretch on a cylindrical screen, everything will not be in proportion at all, since there are 21: 9, 27: 9 ratios, etc.  But if you show it in proportion to the right one, then it remains to twist 10-12 videos that were created just for such a screen, and forget about the rest. <br><br>  There is an exit.  With the help of the so-called Super zoom, you can leave the central part of the frame practically without distortion, and stretch the edges.  Peripheral vision proportions are not so important, and the effect of immersion increases greatly.  In this method, of course, there are a lot of minuses, but there are more pluses. <br><br>  <i>Waiting for a question about a programming language, the interface is written in Delphi, the whole render and platform management is in C ++.</i> <br><br>  <b>PS:</b> If the topic 5D will be interesting, I can continue the story about the various protocols of various platforms or about the adaptation of ready-made unity virtual reality videos for this industry.  Or something else interesting.  In general, I am waiting for comments / questions. </div><p>Source: <a href="https://habr.com/ru/post/333652/">https://habr.com/ru/post/333652/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333640/index.html">Emacs + handy window and buffer manager</a></li>
<li><a href="../333642/index.html">Startup eyes of the developer. Which framework is better to choose</a></li>
<li><a href="../333644/index.html">Kernel test automation in microservice architecture</a></li>
<li><a href="../333648/index.html">What's new in IntelliJ IDEA 2017.2</a></li>
<li><a href="../333650/index.html">From repository to CI / CD infrastructure in production for the week</a></li>
<li><a href="../333654/index.html">Work-stealing scheduler in Go</a></li>
<li><a href="../333656/index.html">XBRL: just about the complex - Chapter 2. What is XBRL?</a></li>
<li><a href="../333658/index.html">Cost of data storage: ‚Äúzero-sum game‚Äù</a></li>
<li><a href="../333660/index.html">Use of vulcanization for polymer modules</a></li>
<li><a href="../333662/index.html">DoT.js template engine improvements</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>