<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The implementation of "Tetris" in the game "Life"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What began as an adventure ended in an odyssey. 



 The task of creating a tetris processor of 2,940,928 x 10,295,296 in size 
 This project was the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The implementation of "Tetris" in the game "Life"</h1><div class="post__text post__text-html js-mediator-article">  <em>What began as an adventure ended in an odyssey.</em> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8a/7ef/e3d/e8a7efe3dca396738608308aaf278a24.png" alt="image"><br><br><h2>  The task of creating a tetris processor of 2,940,928 x 10,295,296 in size </h2><br>  This project was the culmination of the work of many users over the past year and a half.  Although the team changed over time, the following authors participated in writing this article: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Phinotpi </li><li>  El'endia starman </li><li>  K Zhang </li><li>  Muddyfish </li><li>  Kritixi lithos </li><li>  Mego </li><li>  Quartata </li></ul><br>  We also want to thank 7H3_H4CK3R, Conor O'Brien and many other users who have invested their work in solving this problem. <br><br>  Due to the unprecedented scale of this task, the article is divided into several parts written by team members.  Each participant wrote about their individual subtheme, approximately corresponding to the areas of the project in which it was involved. <br><br>  It is also worth a look at the <a href="https://github.com/QuestForTetris" rel="noreferrer">GitHub of our organization</a> , in which we put all the code written to solve the problem.  Questions can be asked in our <a href="https://chat.stackexchange.com/rooms/35837/the-quest-for-tetris">development chat</a> . <br><a name="habracut"></a><br><hr><br><h2>  Part 1: Review </h2><br>  This project began as an answer to the Stackexchange <a href="https://codegolf.stackexchange.com/questions/11880/build-a-working-game-of-tetris-in-conways-game-of-life">question</a> : <br><br><blockquote>  This is a theoretical problem ‚Äî it has neither a simple nor a trivial answer. <br><br>  In the game ‚ÄúLife‚Äù of Conway there are such constructions as <a href="http://www.conwaylife.com/wiki/OTCA_metapixel" rel="noreferrer">metapixels</a> that allow the game ‚ÄúLife‚Äù to simulate any system of rules similar to ‚ÄúLife‚Äù.  In addition, it is known that the game "Life" is Turing-complete. <br><br>  Your task is to create a cellular automaton using the rules of Conway's Life game, which allows you to play Tetris. <br><br>  The program should receive input by manually changing the state of the automaton in a certain generation representing an interruption (i.e., moving the figure left or right, turning, dropping down or randomly generating a new figure for placement on the field).  A certain number of generations is considered waiting time.  The result of the game is shown somewhere in the machine.  The result should visually resemble the field for this "Tetris". <br><br>  Your program will be evaluated according to the following criteria, in the following order (the lower criteria are additional to the higher): <br><br><ul><li>  The size of the border rectangle - wins the rectangular field with the smallest area, completely containing the solution. </li><li>  Least change for input ‚Äî wins the solution with the least amount of cells (at worst for your slot machine case) needed to manually configure as an interrupt. </li><li>  Fastest execution ‚Äî wins the solution with the least number of generations to move forward one simulation cycle. </li><li>  The initial number of living cells wins the smallest number. </li><li>  The first published - wins the very first post with the decision. </li></ul></blockquote><br>  The main idea of ‚Äã‚Äãthis project was <em>abstraction</em> .  Instead of directly developing ‚ÄúTetris‚Äù in the game ‚ÄúLife‚Äù, we gradually expanded the abstraction being created.  On each layer, we went further and further away from the difficulties of ‚ÄúLife‚Äù and approached the creation of a computer, which would be as easy to program as any other. <br><br>  First, as a basis for the computer, we used <a href="http://www.conwaylife.com/wiki/OTCA_metapixel" rel="noreferrer">OTCA-metapixels</a> .  These metapixels can emulate any rules of the game, similar to Life.  <a href="https://ru.wikipedia.org/wiki/Wireworld" rel="noreferrer">Wireworld</a> and <a href="https://ru.wikipedia.org/wiki/Wireworld" rel="noreferrer">Wireworld</a> were important sources of inspiration for this project. We wanted to create a similar structure based on metapixels.  Although it is not possible to emulate Wireworld using OTCA metapixels, you can set different rules for different metapixels and create structures of metapixels that work like Wireworld wires. <br><br>  The next step was the creation of many fundamental logic gates that can be used as the basis of a computer.  At this stage, we are already dealing with concepts similar to those of the real-world processor design.  Here is an example of the OR gate, each cell of this image is actually a whole OTCA metapixel.  You see how "electrons" (each of which represents a single bit of data) enter and exit the valve.  Also visible are all the types of metapixels we used to create the computer: B / S - black background, B1 / S - blue, B2 / S - green, B12 / S1 - red. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66e/84f/c70/66e84fc70ae70250e2718c0f0988a45b.gif" alt="image"><br><br>  From this we have developed a processor architecture.  We spent a lot of time developing an architecture that would be both understandable and easy to implement.  Wireworld uses a rudimentary transport-triggered architecture, but our project uses a much more flexible RISC architecture with multiple opcodes and addressing modes.  We created the QFTASM assembly language (Quest for Tetris Assembly), which controlled the manufacture of the processor. <br><br>  Also, our computer is asynchronous, which means that it is not controlled by a global clock.  In the process of transferring data inside the computer, there is a synchronization signal.  This means that we only need to track the local, not global, timings of the computer. <br><br>  Here is an illustration of our processor architecture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93f/181/bd3/93f181bd3aa641b8997196ca225c29a9.png" alt="image"><br><br>  From this moment we can only implement the "Tetris" in the computer.  To simplify the task, we have developed several ways to compile a high-level language in QFTASM.  We have a basic Cogol language, a second, more advanced language is under development, and finally, we are creating a GCC backend.  Now the program "Tetris" is written on Cogol and compiled from it. <br><br>  After the final TFTRM QFTASM code was generated, the next steps were to build from this code into the appropriate ROM, and then from the meta pixels to the underlying Life game, on which our work will be completed. <br><br><h3>  Launch of Tetris </h3><br>  Those who want to play Tetris without fiddling with the compiler can run the <a href="https://github.com/QuestForTetris/Cogol/blob/master/tetris.qftasm" rel="noreferrer">Tetris source code</a> in <a href="http://play.starmaninnovations.com/qftasm/" rel="noreferrer">the QFTASM interpreter</a> .  To view the entire game, specify the displayed addresses of RAM 3-32.  Here is a permanent link for convenience: <a href="http://play.starmaninnovations.com/qftasm/" rel="noreferrer">Tetris in QFTASM</a> . <br><br>  Game features: <br><br><ul><li>  All 7 Tetromino </li><li>  Movement, rotation, smooth lowering of figures </li><li>  Clearing lines and scoring </li><li>  Show the next figure </li><li>  Player input adds randomness </li></ul><br>  <strong>Display</strong> <br>  Our computer presents the Tetris field as a memory grid.  Addresses 10-31 display the field, addresses 5-8 show the next figure, address 3 contains the score. <br><br>  <strong>Input</strong> <br>  Entering in the game is done by manually editing the contents of address 1 in RAM.  When using the QFTASM interpreter, this means direct writing to address 1. See ‚ÄúDirect write to RAM‚Äù on the interpreter page.  Each turn only requires changing one bit of RAM, and this input register is automatically reset after reading the input event. <br><br> <code>value motion <br> 1     <br> 2  <br> 4  ( ) <br> 8  <br> 16    </code> <br> <br>  <strong>Scoring system</strong> <br>  The player receives a bonus for removing multiple lines in one turn. <br><br> <code>1  = 1  <br> 2  = 2  <br> 3  = 4  <br> 4  = 8 </code> <br> <br><h1>  Part 2: OTCA-metapixel and VarLife </h1><br><h2>  Otca metapixel </h2><br> <a href="" rel="noreferrer"><img src="https://habrastorage.org/getpro/habr/post_images/200/f35/0b4/200f350b4a2b7d2ca78838fbb6fefa68.png" alt="Otca metapixel"></a> <br><br>  <a href="http://www.conwaylife.com/w/index.php%3Ftitle%3DOTCA_metapixel" rel="noreferrer">OTCA-metapixel</a> is a structure in the Life game in Konway, which can be used to simulate any cellular automaton similar to Life.  I will quote LifeWiki (link below): <br><br><blockquote>  The OTCA-metapixel is a 2048 √ó 2048 cell of 35328 cells, created by Bryce Dew ... It has many advantages ... including the ability to emulate any cellular automaton similar to Life, and very noticeable when the scale is reduced, the cells are ON and OFF. .. </blockquote><br>  <a href="http://www.conwaylife.com/wiki/Life-like_cellular_automaton" rel="noreferrer">A cellular automaton, similar to Life</a> , essentially means that cells are born and survive on the basis of how many of the eight neighboring cells live.  These rules have the following syntax: the letter B followed by the number of living neighbors leading to birth, the slash, the letter S followed by the number of living neighbors supporting the life of the cell.  A bit confusing, so I think it's better to give an example.  The canonical Life game can be represented as a rule B3 / S23, which states that a dead cell surrounded by three neighbors becomes alive, and any living cell with two or three living neighbors remains alive.  Otherwise, the cell dies. <br><br>  Although the OTCA-metapixel is a 2048 x 2048 cell, it actually has a bounding box of 2058 x 2058 cells because it is overlapped by its <em>diagonal</em> neighbors with five cells in all directions.  The overlapping cells are needed to intercept the ‚Äúgliders‚Äù that are emitted to inform the metacell neighbors that it is included.  Because of this, they will not affect other metapixels or move out of control.  The rules of birth and survival are encoded in a special section of cells in the left part of the metapixel by the presence or absence of ‚Äúeaters‚Äù in certain positions along two columns (one for birth, the other for survival).  Regarding the recognition of the state of neighboring cells, this is what happens: <br><br><blockquote>  Stream 9-LWSS then walks around clockwise around the cell, losing the LWSS on each adjacent ‚Äúon‚Äù cell that starts the honeybit reaction memory cell.  The number of missing LWSSs is calculated by recognizing the position of the front LWSS by colliding with another LWSS from the opposite direction.  This collision releases gliders that trigger another one or two honeybit reactions if there are no ‚Äúfeeders‚Äù determining the state of birth / survival. </blockquote><br>  A more detailed outline of each aspect of the OTCA metapixel is presented on its website: <a href="http://otcametapixel.blogspot.com/2006/05/how-does-it-work.html" rel="noreferrer">How Does It Work?</a>  . <br><br><h2>  Varlife </h2><br>  I created an online simulator of the rules of Life-like games, in which you can set the behavior of any cell in accordance with any rules similar to the rules of "Life."  I called the simulator "Variations of Life".  For brevity, then this name changed to ‚ÄúVarLife‚Äù.  Here is its screenshot (link to the simulator: <a href="http://play.starmaninnovations.com/varlife/BeeHkfCpNR" rel="noreferrer">http://play.starmaninnovations.com/varlife/BeeHkfCpNR</a> ): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a2/c2f/d4d/6a2c2fd4dd8025a0b5ab497d02ca68ef.png" alt="VarLife screenshot"><br><br>  Notable features: <br><br><ul><li>  Switches the cells between live / dead states and colors the field according to different rules. </li><li>  The ability to start and stop the simulation, to perform one step at a time.  It is also possible to perform a specified number of steps with a maximum speed or more slowly, with a speed that is set in cycles / s and ms / cycle. </li><li>  Has the ability to delete all living cells or completely reset the field to an empty state. </li><li>  It can change the size of the field and cells, as well as include horizontal and / or vertical toroidal convolution. </li><li>  Permanent links (which encode all url information) and short url (because sometimes there is too much information, but they are still useful). </li><li>  Rule sets with B / S assignment, colors and optional randomness. </li><li>  And the last - rendering gif! </li></ul><br>  The render-to-gif function is my favorite, because a lot of time was spent on its implementation.  It was great when I finally completed it at seven in the morning.  With its help, you can easily share the designs of VarLife with other people. <br><br><h2>  VarLife basic layout </h2><br>  In general, the VarLife computer requires only four types of cells!  Only eight states, taking into account the ‚Äúdead‚Äù / ‚Äúalive‚Äù states: <br><br><ul><li>  B / S (black / white), which serves as a buffer between all the components, because B / S cells can never be alive. </li><li>  B1 / S (blue / blue) is the main cell type used to propagate signals. </li><li>  B2 / S (green / yellow) - mainly used to control signals, protecting them from back propagation. </li><li>  B12 / S1 (red / orange) - used in some special situations, for example, when crossing signals and storing a bit of data. </li></ul><br>  Use this short url to open VarLife with already coded rules: <a href="http://play.starmaninnovations.com/varlife/BeeHkfCpNR" rel="noreferrer">http://play.starmaninnovations.com/varlife/BeeHkfCpNR</a> . <br><br><h3>  Guides </h3><br>  There are several different designs of conductors with different characteristics. <br><br>  This is the simplest and the main conductor in VarLife, a strip of blue bounded by green stripes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6e/0f7/a9f/c6e0f7a9f8dd21a45695b9b53fcb1b36.gif" alt="basic wire"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/WcsGmjLiBF" rel="noreferrer">http://play.starmaninnovations.com/varlife/WcsGmjLiBF</a> <br><br>  This is a unidirectional conductor.  That is, it will destroy all signals trying to pass in the opposite direction.  In addition, it is one cell narrower than the main conductor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11e/14d/ed1/11e14ded1b4420da6e1dfc18fe39d09d.gif" alt="unidirectional wire"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/ARWgUgPTEJ" rel="noreferrer">http://play.starmaninnovations.com/varlife/ARWgUgPTEJ</a> <br><br>  There are also diagonal conductors, but they are almost never used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/af5/585/ee9/af5585ee9f0ef5d641a998e0828e08bc.gif" alt="diagonal wire"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/kJotsdSXIj" rel="noreferrer">http://play.starmaninnovations.com/varlife/kJotsdSXIj</a> <br><br><h3>  Gateways </h3><br>  In fact, there are many ways to create each individual gateway, so I will show only one example of each type.  The first gif shows the AND, XOR and OR gateways, respectively.  The basic idea is that the green cell acts as AND, the blue one as XOR, and the red one as OR, and all the other cells around them just provide the correct transmission. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1e/046/6b6/d1e0466b6d6a069cc6efe71ef360094b.gif" alt="AND, XOR, OR logic gates"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/EGTlKktmeI" rel="noreferrer">http://play.starmaninnovations.com/varlife/EGTlKktmeI</a> <br><br>  The AND-NOT (ANT for short) gateway proved to be a vital component.  This gateway transmits a signal from A if and only if there is no signal from B. That is, ‚ÄúA AND NOT B‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/690/89e/408/69089e4089ad5c73acbe81e0d6000266.gif" alt="AND-NOT gate"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/RsZBiNqIUy" rel="noreferrer">http://play.starmaninnovations.com/varlife/RsZBiNqIUy</a> <br><br>  Although this is not really a <em>gateway</em> , the intersection of the conductors is very important and useful. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00a/08e/4fb/00a08e4fba90df82e03da3e8f5b0d229.gif" alt="wire crossing"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/OXMsPyaNTC" rel="noreferrer">http://play.starmaninnovations.com/varlife/OXMsPyaNTC</a> <br><br>  By the way, there is no NOT gateway.  This happened because without the incoming signal a permanent output should be created, which does not perform well with the many timings required by modern computer equipment.  But in any case we managed to do without it. <br><br>  In addition, many components were intentionally created in such a way as to fit into the bounding box 11 by 11 ( <em>tile</em> ), in which the signals take 11 ticks from the moment they enter the tile to exit the tile.  This makes the components more modular and easier to connect together without having to adjust the conductors to provide space or timings. <br><br>  About other gateways investigated / created in the process of studying the components of the schemes can be found in the post PhiNotPi: <a href="http://blog.phinotpi.com/2016/05/31/building-blocks-logic-gates/" rel="noreferrer">Building Blocks: Logic Gates</a> . <br><br><h3>  Delay components </h3><br>  In the process of developing computer hardware, KZhang came up with a variety of latency components shown below. <br><br>  Delay on 4 clocks: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/121/1a9/c34/1211a9c34347fa25b82622b13fb11739.gif" alt="4 tick delay"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/gebOMIXxdh" rel="noreferrer">http://play.starmaninnovations.com/varlife/gebOMIXxdh</a> <br><br>  Delay of 5 cycles: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e0/b38/fb2/3e0b38fb2e7c9a68c3adaf7f2cf13f60.gif" alt="5 tick delay"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/JItNjJvnUB" rel="noreferrer">http://play.starmaninnovations.com/varlife/JItNjJvnUB</a> <br><br>  Delay for 8 clocks (three separate entry points): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0aa/1e0/136/0aa1e0136dfc7cfce685ba4a5e55549e.gif" alt="8 tick delay"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/nSTRaVEDvA" rel="noreferrer">http://play.starmaninnovations.com/varlife/nSTRaVEDvA</a> <br><br>  11 clock delay: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb6/6c5/795/fb66c5795861a4ff488b573a6cb148fb.gif" alt="11 tick delay"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/kfoADussXA" rel="noreferrer">http://play.starmaninnovations.com/varlife/kfoADussXA</a> <br><br>  Delay for 12 clocks: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9d/c70/917/c9dc70917172dbf9b2b2c595b9103018.gif" alt="12 tick delay"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/bkamAfUfud" rel="noreferrer">http://play.starmaninnovations.com/varlife/bkamAfUfud</a> <br><br>  14 clock latency: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb2/cec/abd/bb2cecabdc4194c2001f39cdde8ff393.gif" alt="14 tick delay"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/TkwzYIBWln" rel="noreferrer">http://play.starmaninnovations.com/varlife/TkwzYIBWln</a> <br><br>  Delay for 15 cycles (checked by comparison): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab4/ff6/d15/ab4ff6d15af7b292c04e6aea69566ec1.gif" alt="15 tick delay"><br><br>  Short url: <a href="http://play.starmaninnovations.com/varlife/jmgpehYlpT" rel="noreferrer">http://play.starmaninnovations.com/varlife/jmgpehYlpT</a> <br><br>  So, here are the main components of the VarLife schemes!  For descriptions of the basic computer circuits, see the following section, written by KZhang! <br><br><h1>  Part 3: Equipment </h1><br>  Thanks to our knowledge of logical gateways and the overall structure of the processor, we can begin the development of all computer components. <br><br><h2>  Demultiplexer </h2><br>  A demultiplexer, or demux, is a critical component of ROM, RAM, and ALU.  Depending on the given selector data, it sends the input signal to one of several output signals.  It consists of three main parts: a series-parallel converter, a signal control device and a clock separator. <br><br>  We start by converting the serial data of the selector to "parallel".  This is done by strategically dividing and delaying the data so that the leftmost data bit crosses the clock signal in the leftmost 11x11 square, the next data bit crosses the clock signal in the next 11x11 square, and so on. <br><br>  Although every bit of data will be output in every 11x11 square, every bit of data will overlap with a clock signal only once. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/606/861/61d/60686161d48eef026565c375ec6f0acc.png" alt="Serial to parallel converter"><br><br>  Next, we check if the parallel data matches the specified address. <br>  We do this with the AND and ANT gateways used for clock and parallel data.  However, we need to make sure that the parallel data is also output so that they can be compared again.  Here are the gateways that I created as a result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bae/ae1/720/baeae1720ee99e1dc1fbfade01de8708.png" alt="Signal Checking Gates"><br><br>  Finally, we simply divide the clock signal, connect several signal verification devices (one for each address / output), resulting in a multiplexer! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d2/666/36e/8d266636e69ff7d279facf441af94c43.png" alt="Multiplexer"><br><br><h2>  ROM </h2><br>  The ROM should receive an address as input, and send an instruction as an output to that address.  We begin by using a multiplexer to direct the clock signal to one of the instructions.  Then we need to generate a signal by touching several conductors and OR gateways.  Touching the conductors allows the clock signal to pass through all 58 bits of the instruction, and also provides the movement of the generated signal (while parallel) through the ROM to the output. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c51/7ab/cd8/c517abcd85837126c7fbe2c26075e7ee.png" alt="ROM bits"><br><br>  Then we just need to convert the parallel signal into a serial one, and this ROM will be ready. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89b/a77/8c4/89ba778c4b1cfa5b94519861fdeb04fb.png" alt="Parallel to serial converter"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8a/7ef/e3d/e8a7efe3dca396738608308aaf278a24.png" alt="ROM"><br><br>  Currently, the ROM is generated by executing a script on Golly, which transmits the assembler code from the clipboard to the ROM. <br><br><h2>  SRL, SL, SRA </h2><br>  These three logical gateways are used for bit-shifting, and they are more complex than regular AND, OR, XOR, etc.  In order for these gateways to work, we first need to perform a clock delay for the appropriate time to ‚Äúshift‚Äù the data. <br>  The second argument passed to these gateways says that you need to perform an offset for so many bits. <br><br>  For SL and SRL we need <br><br><ol><li>  Ensure that the 12 most significant bits are not included (otherwise the output will be 0), and </li><li>  Perform data delay at the right time based on 4 less significant bits. </li></ol><br>  This can be accomplished using multiple AND / ANT gateways and a multiplexer. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c9/505/cca/0c9505cca5db7e4e9ca3967db575aba1.png" alt="SRL"><br><br>  SRA is a little different, because when we shift, we need to copy the sign bit.  We do this by applying AND to a clock signal with a sign bit, and then copying the output several times using the separators of the conductors and the OR gateways. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d3/30a/9bd/6d330a9bd2556d261e230bba4bbd4099.png" alt="SRA"><br><br><h2>  Trigger Set-Reset (SR) </h2><br>  Many processor functions depend on the ability to store data.  We can implement it with the help of two red cells B12 / S1.  Two cells can keep each other on or off together.  With the help of additional circuits of inclusion, reset and reading, we can create a simple SR-trigger. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c0/0e8/222/3c00e8222149f31606d0279d6ea5111e.png" alt="SR latch"><br><br><h2>  Synchronizer </h2><br>  By converting serial data into parallel, and then including several SR triggers, we can store the whole data word.  Then, to retrieve the data again, we can simply read and reset all the triggers, and properly delay the data.  This will allow us to store one (or several) data words while we are waiting for another.  Due to this we will be able to synchronize two words of data received at different times. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e48/e5f/fad/e48e5ffad6769d4939ac6098aa73b8d8.png" alt="Synchronizer"><br><br><h2>  Readout counter </h2><br>  This device keeps track of how many times it must perform addressing from RAM.  It solves this problem with a device similar to the SR flip-flop: T-flip-flop.  Each time a T-flip-flop receives input data, it changes its state: if it was turned on, it turns off, and vice versa.  When a T-flip-flop changes its state, it sends an output pulse, which can be sent to another T-flip-flop, creating a two-bit counter. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab3/47e/45a/ab347e45ae2bcf88b1bed0be0fb0e007.png" alt="Two bit counter"><br><br>  To create a read counter, we need to transfer the counter to the appropriate addressing mode using two ANT gateways, and use the counter output signal to determine where to send the clock signal: to the ALU or to the RAM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/694/fca/e97/694fcae97660d16d7dcfe9d8939fec2b.png" alt="Read Counter"><br><br><h2>  Read Queue </h2><br>  The read queue must keep track of which of the read counters sent the input data to RAM so that it can send the RAM output to the right place.  To do this, we use several SR triggers: one trigger per input.  When a signal is sent to the RAM from the read counter, the clock signal is split and turns on the SR trigger of the counter.  Then, the RAM output goes along with the SR flip-flop through the AND gateway, and the clock signal from the RAM drops the SR flip-flop. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e23/add/725/e23add72545ab29ff3a5d312f08ad602.png" alt="Read queue"><br><br><h2>  ALU </h2><br>  The ALU is similar in operation to the read queue in that it also uses the SR flip-flop to track where to send the signal.  First, using the multiplexer, the SR trigger of the logic circuit corresponding to the opcode of the instruction is activated.  Then, the values ‚Äã‚Äãof the first and second arguments along with the SR flip-flop pass through the AND gateway, and then are passed to logical circuits.  When passing the clock signal resets the trigger, so that the ALU can be used again. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a4c/198/bf8/a4c198bf8d5540a4c4068370f197e2be.png" alt="ALU"><br><br><h2>  Ram </h2><br>  RAM has become the most difficult part of this project.  It required a very specific control of each SR trigger storing data.  For reading, the address is transmitted to the multiplexer and transmitted to the RAM segments.  Segments of RAM in parallel display the stored data, which is converted to a sequential view and output.  For recording, the address is transferred to another multiplexer, the recorded data is converted from serial to parallel form, and RAM segments distribute the signal over RAM. <br><br>  Metapixels 22x22 each segment of RAM has the following structure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/798/894/18f/79889418f5d08b5bb4779c52306bffac.png" alt="RAM unit"><br><br>  By connecting all the RAM, we get something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1b/a57/2b0/f1ba572b0fa081568d91dbaa9b704f00.png" alt="Ram"><br><br><h2>  We put everything together </h2><br>  With the help of all these components and the general computer architecture described in Part 1, we can build a working computer! <br><br>  Downloadable files: <br>  - <a href="" rel="noreferrer">Ready computer for "Tetris"</a> <br>  - <a href="" rel="noreferrer">ROM creation script, empty computer and computer for finding prime numbers</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/89b/fd0/316/89bfd031642b4d48f209bf35d13410ea.png" alt="The computer"><br><br><h2>  Part 4: QFTASM and Cogol </h2><br><h3>  Architecture Overview </h3><br>  In short, our computer has a 16-bit asynchronous Harvard RISC architecture.  When creating a processor manually, the RISC architecture ( <a href="https://ru.wikipedia.org/wiki/RISC" rel="noreferrer">computer with reduced instruction set</a> ) is a practically mandatory requirement.  In our case, this means that the number of opcodes is small, and, more importantly, all instructions are processed in a very similar way. <br><br>  For reference, the Wireworld computer uses the <a href="https://ru.wikipedia.org/wiki/Transport_triggered_architecture" rel="noreferrer">transport-triggered architecture</a> , in which the only instruction is <code>MOV</code> , and the calculations are performed by writing / reading special registers.  Although this paradigm allows you to create a very simple to implement architecture, the result is on the verge of applicability: all arithmetic / logical / conditional operations require <em>three</em> instructions.  It was obvious that we wanted to create a more understandable architecture. <br><br>  To keep our processor simple, while at the same time increasing its usability, we made several important decisions regarding its design: <br><br><ul><li>  No registers.  Each address in RAM is considered equal and can be used as an argument in any operation.  In a sense, this means that all RAM can be considered registers.  This means that there are no special loading / storage instructions. </li><li>  The same goes for memory allocation.  Everything that can be written or read has a common unified addressing scheme.  This means that the program counter (PC) is the address 0, and the only difference between the normal and control instructions is that the managers use the address 0. </li><li>  The data is sequential in transmission and parallel in storage.  Due to the ‚Äúelectronic‚Äù nature of our computer, addition and subtraction are much easier to implement when data is transmitted sequentially in little-endian order (the least significant bit goes first).  Moreover, sequential data allows you to get rid of cumbersome data buses, which are very wide and inconvenient for proper operation with time (so that the data are together, all the ‚Äúbands‚Äù of the bus must have the same time delay). </li><li>  Harvard architecture, that is, there is a separation between program memory (ROM) and data memory (RAM).  Although this reduces the processor's flexibility, it helps to optimize the size: the length of the program is much more than the amount of RAM we need, so we can split the program into ROM and then focus on compressing the ROM, which is much easier to do when it is read-only. </li><li>  16-bit data width.  This is the smallest power of two, which is wider than the standard field for Tetris (10 blocks).       -32768  +32767      65536 . (2^8=256      ,      ,     ¬´¬ª.) </li><li>  .     (,  ,  ),   ,    ¬´ ¬ª,         .      ,           ,           . </li><li>     .  ,  ,      1     (, ,  )    .        ,    . </li><li>    .          ,    .            . </li></ul><br>       1. <br><br><h3>     </h3><br>     ,      .          . <br><br> <strong> </strong> <br><br>    ,       . ¬´¬ª ‚Äî       ,  ¬´¬ª                .      ,   -           ,        (PC).        ,       :         ,       TRUE. <br><br>       : ¬´,   ¬ª ( <code>MNZ</code> )  ¬´,   ¬ª ( <code>MLZ</code> ).  <code>MNZ</code>   ,       1,  <code>MLZ</code> ‚Äî  ,      1. ,       .      ,  ¬´,  ¬ª ( <code>MEZ</code> )        TRUE,  ¬´,   ¬ª ( <code>MGZ</code> ) ‚Äî    , ,      0           1. <br><br> <strong></strong> <br><br>              .   ,     little-endian,   endian    /.             . <br><br>          ,       .  ,    Wireworld   . <br><br>    ‚Äî       (  ,    ).  , , ,         ,    . <br><br> <strong> </strong> <br><br>   ,      <code>AND</code> , <code>OR</code>  <code>XOR</code> .   <code>NOT</code>     ¬´and-not¬ª ( <code>ANT</code> ).    <code>NOT</code>   ,        ,     .  <code>ANT</code>  1      1,     ‚Äî 0.   <code>NOT x</code>  <code>ANT -1 x</code> (  <code>XOR -1 x</code> ).  , <code>ANT</code>        :     ¬´¬ª       . <br><br> <strong> </strong> <br><br>    ‚Äî    ,  .     :     .     (-   ),       ,     ¬´¬ª ,   ¬´¬ª.        /. <br><br>         ‚Äî ¬´ ¬ª ( <code>SL</code> ), ¬´  ¬ª ( <code>SRL</code> )  ¬´  ¬ª ( <code>SRA</code> ).     ( <code>SL</code>  <code>SRL</code> )     ( ,         ).         0  15, ,   ,    .    , <code>SRA</code> ,      ,        . <br><br><h3>   </h3><br>        .        : <br><br> <strong>1.     </strong> <br><br>   PC       .        .           .          . <br><br>  ‚Äî  4 ,     16  , 11   : <br><br> <code>0000 MNZ Move if Not Zero <br> 0001 MLZ Move if Less than Zero <br> 0010 ADD ADDition <br> 0011 SUB SUBtraction <br> 0100 AND bitwise AND <br> 0101 OR bitwise OR <br> 0110 XOR bitwise eXclusive OR <br> 0111 ANT bitwise And-NoT <br> 1000 SL Shift Left <br> 1001 SRL Shift Right Logical <br> 1010 SRA Shift Right Arithmetic <br> 1011 unassigned <br> 1100 unassigned <br> 1101 unassigned <br> 1110 unassigned <br> 1111 unassigned</code> <br> <br> <strong>2.   ( ) <em></em>   </strong> <br><br>        (,      ).       . <br><br>  ,      .     <a href="https://en.wikipedia.org/wiki/Delay_slot" rel="noreferrer">  </a> ,         ( ,    PC)      . <br><br>    (,   ),       .            .  ,         ,   1     ,     PC. <br><br>  ,            ,       .    PC     . <br><br> <strong>3.        </strong> <br><br>   ,         ,    .    16 ,   ,   .    2 . <br><br>          ,             (,  ).               . <br><br>                  .         :    ‚Äî   , ,         .    , ,     . <br><br> <code>00 :   . (   ) <br> 01 :      . (   ) <br> 10 :    ,    . (   ) <br> 11  :    ,   ,   . (   )</code> <br> <br>          .   ‚Äî      ,     ,      .       .        . <br><br>      ,   ‚Äî ,          ,    . ,           (      ),            (        ). <br><br> <strong>4.  </strong> <br><br>             .  ,         .         . <br><br>        , ,      .      ,    ,   -    1 ( <code>MNZ</code> ),   ,     1 ( <code>MLZ</code> ).      ,     (  ). <br><br> <strong>5.   </strong> <br><br> , , ,      . <br><br> - ,   PC       , ,   PC  1   (no-op). ,  PC   ,        .   ,       ,    PC      ,     . <br><br><h3>      ¬´¬ª </h3><br>         QFTASM.            . <br><br>    QFTASM    .     : <br><br> <code>[ ] [] [1] [2] [3]; [ ]</code> <br> <br> <strong> </strong> <br><br>   ,    ,      : <br><br> <code>MNZ [] [] [ ] ‚Äì ,   ;  [ ]  [],  []   . <br> MLZ [] [] [ ] ‚Äì ,   ;  [ ] [],  []   . <br> ADD [1] [2] [ ] ‚Äì ;  [1] + [2]  [ ]. <br> SUB [1] [2] [ ] ‚Äì ;  [1] - [2]  [ ]. <br> AND [1] [2] [ ] ‚Äì  ;  [1] &amp; []  [ ]. <br> OR [1] [2] [ ] ‚Äì  ;  [1] | [2]  [ ]. <br> XOR [1] [2] [ ] ‚Äì  XOR;  [1] ^ [2]  [ ]. <br> ANT [1] [2] [ ] ‚Äì  -;  [1] &amp; (![2])  [ ]. <br> SL [1] [2] [ ] ‚Äì  ;  [1] &lt;&lt; [2]  [ ]. <br> SRL [1] [2] [ ] ‚Äì   ;  [1] &gt;&gt;&gt; [2]  [ ].   . <br> SRA [1] [2] [ ] ‚Äì   ;  [1] &gt;&gt; [2]  [ ]   .</code> <br> <br> <strong> </strong> <br><br>       ,   .         -32768  65536.        . <br><br> <code>   <br> 0  () <br> 1  A <br> 2  B <br> 3   C</code> <br> <br>  <strong>Code example</strong> <br><br>     : <br><br> <code>0. MLZ -1 1 1;   <br> 1. MLZ -1 A2 3;  ,   <br> 2. MLZ -1 A1 2;   <br> 3. MLZ -1 0 0;   <br> 4. ADD A2 A3 1;   ,   </code> <br> <br>      ,    1   .  28657   . <br><br>  : <br><br> <code>0. MLZ -1 5 1;       <br> 1. SUB A1 5 2;  ,         <br> 2. SRL A2 1 3;    1 <br> 3. XOR A2 A3 A1; XOR        <br> 4. SUB B1 42 4;      42 (101010) <br> 5. MNZ A4 0 0;      (  != 101010),   <br> 6. ADD A1 1 1;   ,   </code> <br> <br>           ,    5.      , ,     .         <code>101010</code> ,     51   56. <br><br><h3> - </h3><br> El'endia Starman    <a href="http://play.starmaninnovations.com/qftasm/" rel="noreferrer">-</a> .      ,   ,           . <br><br><h3> Cogol </h3><br>          ¬´¬ª      ,   ¬´¬ª.    <a href="https://github.com/QuestForTetris/Cogol" rel="noreferrer">Cogol</a> .      ¬´COBOL¬ª,   ¬´C of Game of Life¬ª,    ,  Cogol    C ‚Äî   ,       . <br><br> Cogol        .  ,     Cogol    ,       : <br><br><ul><li>               . , <code>ADD A1 A2 3</code>   <code>z = x + y;</code>  .     . </li><li>  ,   <code>if(){}</code> , <code>while(){}</code>  <code>do{}while();</code>    . </li><li>   (  ),     ¬´¬ª. </li><li>    .  ,          . </li></ul><br>  (    )  /,        ,      . <br><br>       : <br><br> <strong></strong> <br><br>     (  )      ,      .   ,          ,    ,      .   (, <code>{</code>  <code>,</code> )       ,     .  (, <code>&gt;</code>  <code>=</code> )      ,      ,  <code>&gt;&gt;&gt;</code>  <code>==</code> .       ,      .      ‚Äî  <code>-</code> ,       ,   ,     . <br><br> <strong></strong> <br><br>      .         ,            .     ,    . <br><br> <strong>  </strong> <br><br>      (  )   ()  .         <code>my</code> ,   ,      .  ,     ‚Äî     .   (         )  ¬´¬ª     .           .      ,      . ,        ,       ‚Ä¶ <br><br> <strong> <code>IF-ELSE</code></strong> <br><br>  <code>if-else</code>    C : <br><br> <code>  <br> if (cond) { <br>   <br> } else { <br>   <br> } <br>  </code> <br> <br>    QFTASM    : <br><br> <code>  <br>   <br>   <br>   <br>   <br>   (  ) <br>   (  )</code> <br> <br>    ,   .    ,   . <br><br>   ¬´ ¬ª    ,    ,       .    ,  <code>&gt;</code>  <code>&lt;=</code>   <code>MLZ</code> .  <code>MNZ</code>    <code>==</code> ,       ,      (    ).       . <br><br>   <code>else</code> ,     ,    QFTASM  : <br><br> <code>  <br>   <br>   <br>  <br>   (  )</code> <br> <br> <strong> <code>WHILE</code></strong> <br><br>  <code>while</code>     C : <br><br> <code>  <br> while () { <br>  <br> } <br>  </code> <br> <br>    QFTASM    : <br><br> <code>  <br>   <br>  (  ) <br>   (  ) <br>   <br>  </code> <br> <br>         ,   ,        .    false,      .              ,       ,     . <br><br>  <code>MLZ</code>      <code>&gt;</code>  <code>&lt;=</code> .      <code>if</code> ,  <code>MNZ</code>    <code>!=</code> ,      ,      (    ). <br><br> <strong> <code>DO-WHILE</code></strong> <br><br>    <code>while</code>  <code>do-while</code>   ,    <code>do-while</code>     ,        .     <code>do-while</code>      ,   ,       . <br><br> <strong></strong> <br><br>       .     ,   .    : <br><br> <code>my alpha[3]; #   <br> my beta[11] = {3,2,7,8}; #        </code> <br> <br>      , ,      15-18: <br><br> <code>15: alpha <br> 16: alpha[0] <br> 17: alpha[1] <br> 18: alpha[2]</code> <br> <br> ,   <code>alpha</code> ,     <code>alpha[0]</code> ,       15   16.  <code>alpha</code>     Cogol   ,       . <br><br>          <code>array[index]</code> .   <code>index</code>  ,        .        ( )     .    ,  <code>alpha[beta[1]]</code> . <br><br> <strong>  </strong> <br><br>  ‚Äî   ,      ,         .           (  ): <br><br> <code>#      <br> call display = fib(10).sum; <br> sub fib(cur,sum) { <br> if (cur &lt;= 2) { <br> sum = 1; <br> return; <br> } <br> cur--; <br> call sum = fib(cur).sum; <br> cur--; <br> call sum += fib(cur).sum; <br> }</code> <br> <br>     <code>sub</code>        .        ,         .       . <br><br>          .         ,        .          ,          ().         ,  .     ¬´¬ª     .              ,       .         .              : <br><br> <code>RAM map: <br> 0: pc <br> 1: display <br> 2: scratch0 <br> 3: fib <br> 4: scratch1 <br> 5: scratch2 <br> 6: scratch3 <br> 7: call <br> <br> fib map: <br> 0: return <br> 1: previous_call <br> 2: cur <br> 3: sum <br></code> <br><br>      ,       .         ,        .         ,           ( )  . <br><br>     ,      <code>call</code> : <br><br> <code>call fib(10); #  ,      <br> <br> call pointer = fib(10); #      <br> display = pointer.sum; #          <br> <br> call display = fib(10).sum; #     <br> <br> call display += fib(10).sum; #          </code> <br> <br>           .          (  ).            (  /),        . <br><br>  ‚Äî        ,   ,       :      ,    ,  . <br><br> <strong> </strong> <br><br>   <code>{...}</code>    Cogol       .          ,       ,        . <br><br> <strong>   </strong> <br><br>       Cogol        QFTASM      .                  ,      ,     .          . <br><br><h3>   ¬´¬ª  Cogol </h3><br>   ¬´¬ª    Cogol,      <a href="" rel="noreferrer"></a> .   QFTASM  <a href="https://github.com/QuestForTetris/Cogol/blob/master/tetris.qftasm" rel="noreferrer"></a> .      : <a href="http://play.starmaninnovations.com/qftasm/" rel="noreferrer">Tetris in QFTASM</a> .        (    Cogol),    Cogol  .        ,        ,      ,   <code>call</code> .           .  ,             ,        .     QFTASM   300 ,     ,     Cogol. <br><br><h1>  5: ,    </h1><br>     ,         Varlife        ¬´¬ª! <br><br><h2>  Assembly </h2><br>         ,    :      ,          ,   .       ,           . <br><br> K Zhang  <a href="https://github.com/QuestForTetris/QFT/blob/master/CreateROM.py" rel="noreferrer">CreateROM.py</a> ,   Python  Golly,     .   :       ,          .     ,    : <br><br> <code>#0. MLZ -1 3 3; <br> #1. MLZ -1 7 6; preloadCallStack <br> #2. MLZ -1 2 1; beginDoWhile0_infinite_loop <br> #3. MLZ -1 1 4; beginDoWhile1_trials <br> #4. ADD A4 2 4; <br> #5. MLZ -1 A3 5; beginDoWhile2_repeated_subtraction <br> #6. SUB A5 A4 5; <br> #7. SUB 0 A5 2; <br> #8. MLZ A2 5 0; <br> #9. MLZ 0 0 0; endDoWhile2_repeated_subtraction <br> #10. MLZ A5 3 0; <br> #11. MNZ 0 0 0; endDoWhile1_trials <br> #12. SUB A4 A3 2; <br> #13. MNZ A2 15 0; beginIf3_prime_found <br> #14. MNZ 0 0 0; <br> #15. MLZ -1 A3 1; endIf3_prime_found <br> #16. ADD A3 2 3; <br> #17. MLZ -1 3 0; <br> #18. MLZ -1 1 4; endDoWhile0_infinite_loop</code> <br> <br>      : <br><br> <code>0000000000000001000000000000000000010011111111111111110001 <br> 0000000000000000000000000000000000110011111111111111110001 <br> 0000000000000000110000000000000000100100000000000000110010 <br> 0000000000000000010100000000000000110011111111111111110001 <br> 0000000000000000000000000000000000000000000000000000000000 <br> 0000000000000000000000000000000011110100000000000000100000 <br> 0000000000000000100100000000000000110100000000000001000011 <br> 0000000000000000000000000000000000000000000000000000000000 <br> 0000000000000000000000000000000000110100000000000001010001 <br> 0000000000000000000000000000000000000000000000000000000001 <br> 0000000000000000000000000000000001010100000000000000100001 <br> 0000000000000000100100000000000001010000000000000000000011 <br> 0000000000000001010100000000000001000100000000000001010011 <br> 0000000000000001010100000000000000110011111111111111110001 <br> 0000000000000001000000000000000000100100000000000001000010 <br> 0000000000000001000000000000000000010011111111111111110001 <br> 0000000000000000010000000000000000100011111111111111110001 <br> 0000000000000001100000000000000001110011111111111111110001 <br> 0000000000000000110000000000000000110011111111111111110001</code> <br> <br>     Varlife    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31b/1ee/209/31b1ee209845de089e94072058dc6c80.png" alt="ROM"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/784/491/b02/784491b02207260746fee7432bd90821.png" alt="closeup ROM"><br><br>     ,         Varlife.     ‚Ä¶ <br><br><h2>    ¬´¬ª </h2><br>            ¬´¬ª.               ¬´¬ª.   ,      Varlife <a href="http://www.conwaylife.com/w/index.php%3Ftitle%3DOTCA_metapixel" rel="noreferrer">OTCA-</a> .        Varlife    ¬´¬ª. <br><br>  ,  Golly   ( <a href="https://sourceforge.net/p/golly/code/ci/master/tree/Scripts/Python/metafier.py" rel="noreferrer">metafier.py</a> ),      OTCA-        ¬´¬ª.  ,          ,     Varlife.       <a href="https://github.com/QuestForTetris/QFT/blob/master/metafier.py" rel="noreferrer"> </a> ,        Varlife   . <br><br> ,   (  ¬´¬ª)    1 436 x 5 082.  7 297 752    6 075 811 ,     1 221 941 .         OTCA-,    2048 x 2048  ,   64 691 (    ¬´¬ª)  23 920 (  ¬´¬ª).  ,        2 940 928 x 10 407 936 (     )      29 228 828 720  79 048 585 231.  1             27-74 . <br><br>      ,      ,          .     <code>kill</code>      metafier.   10       (  gzip  RLE),    .           ,        . Golly    RLE,     ,         ‚Äî         . <br><br>     K Zhang  <a href="https://github.com/QuestForTetris/QFT/blob/master/MetafierV2.py" rel="noreferrer">  metafier</a> ,      MacroCell,      ,  RLE.      (  ,        metafier),      (121   1,7 ),           ,     .     ,   MacroCell    .                      Varlife. <br><br>         ¬´¬ª   <a href="" rel="noreferrer"></a> . <br><br><h1>   </h1><br> ,   ¬´¬ª,     , ?  Nothing like this.         ,    : <br><br><ul><li> muddyfish  Kritixi Lithos     ,   QFTASM. </li><li> El'endia Starman    - QFTASM. </li><li> quartata   GCC-,     GCC      C  C++ (     , , Fortran, D  Objective-C)  QFTASM.          ,     . </li><li>     ,    ,   ,   ,       -  (PIC) (..  ).  PIC     ,          .        PIC. </li><li>     ,      QFT.       Pong. </li></ul><br><h1>  6:    QFTASM </h1><br>   Cogol     ¬´¬ª,             . <br><br>         2016 .      -  ,     , . <br><br>        Python ,    ,       . <br><br>     QFTASM     : ,  ,     . <br><br><h2>  </h2><br>   Python      ,       . <br><br>           ,      (  <code>#include</code> ). <br><br><h2>   </h2><br>             . <br><br>      XML,              . <br><br>      ,    .      ,    . <br><br>         ,       , , <code>sub</code>  <code>generic_variables</code> ,          . <br><br><h2>     </h2><br>        . , <code>assign(a, 12)</code>  <code>call_subroutine(is_prime, call_variable=12, return_variable=temp_var)</code> .      ,   .    <code>operator</code> ,    ,     ,    ,  <code>+</code>  <code>%</code> .    ,    ‚Äî          ,   . <br><br>        ,   .   : <br><br> <code>operator(int a + int b) -&gt; int c <br> return __ADD__(a, b) <br> int i = 3+3</code> <br> <br>  turns into <br><br> <code>int i = __ADD__(3, 3)</code> <br> <br>         ,           .    ¬´¬ª    <code>unsafe</code>     ,           . <br><br><h3>   (scratch variable)    </h3><br>    <code>a += (b + c) * 4</code>       .      ,     : <br><br> <code>scratch_1 = b + c <br> scratch_1 = scratch_1 * 4 <br> a = a + scratch_1</code> <br> <br>      ,      .            .          .    . <br><br>     VariableStore           .           ,        . <br><br><h3>   </h3><br><br> <code>  <br>    <br>    ( ) <br>   <br>   <br>   <br>  <br> ...</code> <br> <br><h2>   </h2><br> ,       ‚Äî  <code>sub</code> , <code>call_sub</code> , <code>return</code> , <code>assign</code> , <code>if</code>  <code>while</code> .     ,       QFTASM. <br><br><h3> <code>sub</code> </h3> <br>       .    ,     <code>main</code>    (   ). <br><br><h3> <code>if</code>  <code>while</code> </h3><br>   <code>while</code>  <code>if</code>  :           .  <code>while</code>    ,     <br><br> <code>... <br>  <br>    <br>  <br>  <br>  :    <br> ...</code> <br> <br><h3> <code>call_sub</code>  <code>return</code> </h3><br>     , ,     ,         .  ,          .             .             ,    . <br><br>         ,    .              .           .         . <br><br>    <code>return</code> ,          .                . <br><br><h3> <code>assign</code> </h3> <br>     :           : <code>MLZ -1 VALUE VARIABLE</code> <br><br><h3>    </h3><br> ,         .    ,         .     ,  , ,      . <br><br><h2>    </h2><br>     ,         . <br><br> <code>#include stdint <br> <br> sub main <br> int a = 8 <br> int b = 12 <br> int c = a * b</code> <br> <br> ,   . ,     <code>a = 8</code> , <code>b = 12</code> , <code>c = 96</code> .        <code>stdint.txt</code> : <br><br> <code>operator (int a + int b) -&gt; int <br> return __ADD__(a, b) <br> <br> operator (int a - int b) -&gt; int <br> return __SUB__(a, b) <br> <br> operator (int a &lt; int b) -&gt; bool <br> bool rtn = 0 <br> rtn = __MLZ__(ab, 1) <br> return rtn <br> <br> unsafe operator (int a * int b) -&gt; int <br> int rtn = 0 <br> for (int i = 0; i &lt; b; i+=1) <br> rtn += a <br> return rtn <br> <br> sub main <br> int a = 8 <br> int b = 12 <br> int c = a * b</code> <br> <br> ,    .      ,  .            -  <br><br> <code>NAME NAME operator <br> LPAR OP ( <br> NAME NAME int <br> NAME NAME a <br> PLUS OP + <br> NAME NAME int <br> NAME NAME b <br> RPAR OP ) <br> OP OP -&gt; <br> NAME NAME int <br> NEWLINE NEWLINE <br> INDENT INDENT <br> NAME NAME return <br> NAME NAME __ADD__ <br> LPAR OP ( <br> NAME NAME a <br> COMMA OP , <br> NAME NAME b <br> RPAR OP ) <br> ...</code> <br> <br>        ,        .      . <br><br> <code>GrammarTree file <br> 'stmts': [GrammarTree stmts_0 <br> '_block_name': 'inline' <br> 'inline': GrammarTree inline <br> '_block_name': 'two_op' <br> 'type_var': GrammarTree type_var <br> '_block_name': 'type' <br> 'type': 'int' <br> 'name': 'a' <br> '_global': False <br> <br> 'operator': GrammarTree operator <br> '_block_name': '+' <br> <br> 'type_var_2': GrammarTree type_var <br> '_block_name': 'type' <br> 'type': 'int' <br> 'name': 'b' <br> '_global': False <br> 'rtn_type': 'int' <br> 'stmts': GrammarTree stmts <br> ...</code> <br> <br>         .          .         ,   .     . <br><br> <code>('sub', 'start', 'main') <br> ('assign', int main_a, 8) <br> ('assign', int main_b, 12) <br> ('assign', int op(*:rtn), 0) <br> ('assign', int op(*:i), 0) <br> ('assign', global bool scratch_2, 0) <br> ('call_sub', '__SUB__', [int op(*:i), int main_b], global int scratch_3) <br> ('call_sub', '__MLZ__', [global int scratch_3, 1], global bool scratch_2) <br> ('while', 'start', 1, 'for') <br> ('call_sub', '__ADD__', [int op(*:rtn), int main_a], int op(*:rtn)) <br> ('call_sub', '__ADD__', [int op(*:i), 1], int op(*:i)) <br> ('assign', global bool scratch_2, 0) <br> ('call_sub', '__SUB__', [int op(*:i), int main_b], global int scratch_3) <br> ('call_sub', '__MLZ__', [global int scratch_3, 1], global bool scratch_2) <br> ('while', 'end', 1, global bool scratch_2) <br> ('assign', int main_c, int op(*:rtn)) <br> ('sub', 'end', 'main')</code> <br> <br>           QFTASM.       : <br><br> <code>int program_counter <br> int op(*:i) <br> int main_a <br> int op(*:rtn) <br> int main_c <br> int main_b <br> global int scratch_1 <br> global bool scratch_2 <br> global int scratch_3 <br> global int scratch_4 <br> global int &lt;result&gt; <br> global int &lt;stack&gt;</code> <br> <br>    . ,   ,       QFTASM. <br><br> <code>0. MLZ 0 0 0; <br> 1. MLZ -1 12 11; <br> 2. MLZ -1 8 2; <br> 3. MLZ -1 12 5; <br> 4. MLZ -1 0 3; <br> 5. MLZ -1 0 1; <br> 6. MLZ -1 0 7; <br> 7. SUB A1 A5 8; <br> 8. MLZ A8 1 7; <br> 9. MLZ -1 15 0; <br> 10. MLZ 0 0 0; <br> 11. ADD A3 A2 3; <br> 12. ADD A1 1 1; <br> 13. MLZ -1 0 7; <br> 14. SUB A1 A5 8; <br> 15. MLZ A8 1 7; <br> 16. MNZ A7 10 0; <br> 17. MLZ 0 0 0; <br> 18. MLZ -1 A3 4; <br> 19. MLZ -1 -2 0; <br> 20. MLZ 0 0 0;</code> <br> <br><h1>  Syntax </h1><br> ,     ,        .      Python,      .  ,      .      <code>main</code> ,     <code>main()</code> C- .     . <br><br><h2>    </h2><br>    ,      .       <code>int</code>  <code>bool</code>    ,     . <br><br><h2>    </h2><br>   <code>stdint.txt</code> ,   .      ,       .       <code>#include stdint</code> . <code>stdint</code>   ,  <code>+</code> , <code>&gt;&gt;</code>   <code>*</code>  <code>%</code> ,         QFTASM. <br><br>  ,       QFTASM   <code>__OPCODENAME__</code> . <br><br>  <code>stdint</code>     <br><br> <code>operator (int a + int b) -&gt; int <br> return __ADD__(a, b)</code> <br> <br>   ,   <code>+</code>  ,      <code>int</code> . </div><p>Source: <a href="https://habr.com/ru/post/338584/">https://habr.com/ru/post/338584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338572/index.html">Eggs Datacenter: how Emercoin allowed to implement the idea of ‚Äã‚Äãa distributed data center on the blockchain</a></li>
<li><a href="../338576/index.html">Facebook Messenger bug or feature - Poll</a></li>
<li><a href="../338578/index.html">Networks for the harshest. Part thirteen. MPLS Traffic Engineering</a></li>
<li><a href="../338580/index.html">How on animeshniki cryptocurrency mined</a></li>
<li><a href="../338582/index.html">We work with long API in ASP.NET Core correctly or the subtleties of moving to a new platform</a></li>
<li><a href="../338590/index.html">ViewModel and LiveData: patterns and antipatterns</a></li>
<li><a href="../338592/index.html">The digest of interesting materials for the mobile developer # 222 (September 18 - 24)</a></li>
<li><a href="../338594/index.html">Another aspect of JavaScript, which everyone knows about, but not everyone thinks</a></li>
<li><a href="../338596/index.html">Development of profitable Android games by two students</a></li>
<li><a href="../338598/index.html">Illusion of speed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>