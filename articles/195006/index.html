<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Boost.Asio C ++ Network Programming". Chapter 2: Boost.Asio Basics Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming". In this part of the second chapter we will talk about a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Boost.Asio C ++ Network Programming". Chapter 2: Boost.Asio Basics Part 2</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br>  I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming".  In this part of the second chapter we will talk about asynchronous programming. <br><br>  Content: <br><ul><li>  <a href="http://habrahabr.ru/post/192284/">Chapter 1: Getting Started with Boost.Asio</a> </li><li>  Chapter 2: Boost.Asio Basics <br><ul><li>  <a href="http://habrahabr.ru/post/193038/">Part 1: The Basics of Boost.Asio</a> </li><li>  <b>Part 2: Asynchronous Programming</b> </li></ul></li><li>  <a href="http://habrahabr.ru/post/195386/">Chapter 3: Echo Server / Client</a> </li><li>  <a href="http://habrahabr.ru/post/195794/">Chapter 4: Client and Server</a> </li><li>  <a href="http://habrahabr.ru/post/196354/">Chapter 5: Synchronous vs. Asynchronous</a> </li><li>  <a href="http://habrahabr.ru/post/196888/">Chapter 6: Boost.Asio - Other Features</a> </li><li>  <a href="http://habrahabr.ru/post/197392/">Chapter 7: Boost.Asio - additional topics</a> </li></ul><br><br>  This section deeply examines some of the issues that you will encounter when working with asynchronous programming.  Having read it once, I suggest that you return to it as you go through the book in order to strengthen your understanding of these concepts. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Need to work asynchronously </h4><br>  As I said, as a rule, synchronous programming is much simpler than asynchronous.  Because it is much easier to think linearly (we call function A, after it ends we call its handler, we call function B, after we finish it we call its handler, and so on, so we can think of a handler event in a manner).  In the latter case, you can have, say, five events and you can never know the order in which they are performed, and you won‚Äôt even know if they all will be executed! <br>  But even though asynchronous programming is more difficult, you will most likely prefer it, say, in writing servers that have to deal with a large number of clients at the same time.  The more clients you have, the easier the asynchronous programming compared to synchronous. <br>  Let's say you have an application that simultaneously deals with 1000 clients, each message from the client to the server and from the server to the client ends with a '\ n'. <br>  Synchronous code, 1 thread: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::asio; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client</span></span></span><span class="hljs-class"> {</span></span> ip::tcp::socket sock; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// each msg is at maximum this size int already_read; // how much have we already read? }; std::vector&lt;client&gt; clients; void handle_clients() { while ( true) for ( int i = 0; i &lt; clients.size(); ++i) if ( clients[i].sock.available() ) on_read(clients[i]); } void on_read(client &amp; c) { int to_read = std::min( 1024 - c.already_read, c.sock. available()); c.sock.read_some( buffer(c.buff + c.already_read, to_read)); c.already_read += to_read; if ( std::find(c.buff, c.buff + c.already_read, '\n') &lt; c.buff + c.already_read) { int pos = std::find(c.buff, c.buff + c.already_read, '\n') - c.buff; std::string msg(c.buff, c.buff + pos); std::copy(c.buff + pos, c.buff + 1024, c.buff); c.already_read -= pos; on_read_msg(c, msg); } } void on_read_msg(client &amp; c, const std::string &amp; msg) { // analyze message, and write back if ( msg == "request_login") c.sock.write( "request_ok\n"); else if ... }</span></span></code> </pre> <br>  One thing that you want to avoid when writing servers (and basically any network application) is for the code to stop responding.  In our case, we want the <code>handle_clients()</code> function to block as little as possible.  If the function is blocked at any point, then all incoming messages from the client will wait for the function to unlock and begin processing them. <br>  In order to remain responsive, we will read from the socket only when it has data, that is, <code>if ( clients[i].sock.available() ) on_read(clients[i])</code> .  In on_read, we will only read as much as is available;  calling <code>read_until(c.sock, buffer(...),'\n')</code> would not be a very good idea, since it is blocked until we read the message from a specific client to the end (we will never know when this will happen) . <br>  The bottleneck here is the <code>on_read_msg()</code> function;  all incoming messages will be suspended until this function is executed.  A well-written <code>on_read_msg()</code> function will ensure that this does not happen, but it can still happen (sometimes writing to a socket can be blocked, for example, if its buffer is full). <br>  Synchronous code, 10 threads: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::asio; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... same as before bool set_reading() { boost::mutex::scoped_lock lk(cs_); if ( is_reading_) return false; // already reading else { is_reading_ = true; return true; } } void unset_reading() { boost::mutex::scoped_lock lk(cs_); is_reading_ = false; } private: boost::mutex cs_; bool is_reading_; }; std::vector&lt;client&gt; clients; void handle_clients() { for ( int i = 0; i &lt; 10; ++i) boost::thread( handle_clients_thread); } void handle_clients_thread() { while ( true) for ( int i = 0; i &lt; clients.size(); ++i) if ( clients[i].sock.available() ) if ( clients[i].set_reading()) { on_read(clients[i]); clients[i].unset_reading(); } } void on_read(client &amp; c) { // same as before } void on_read_msg(client &amp; c, const std::string &amp; msg) { // same as before }</span></span></code> </pre><br>  In order to use multiple threads, we need to synchronize them, which is what the <code>set_reading</code> () and <code>set_unreading()</code> functions do.  The <code>set_reading()</code> function is very important.  You want to "check whether you can read and start reading" was performed in one step.  If you do this in two steps (‚Äúcheck whether you can read‚Äù and ‚Äústart reading‚Äù), then you can start two streams: one to check for reading for a client, the other to call the <code>on_read</code> function for the same client, in the end, this can lead to data corruption and possibly even a system crash. <br>  You will notice that the code is becoming more complex. <br>  A third option is also possible for synchronous code, namely, to have one thread per client.  But as the number of simultaneous customers grows, this largely becomes an unacceptable operation. <br>  Now consider the asynchronous options.  We are constantly doing asynchronous read operation.  When the client makes a request, the <code>on_read</code> operation is <code>on_read</code> , we respond in response, and then we wait for the next request to arrive (we start another asynchronous read operation). <br>  Asynchronous code, 10 threads: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::asio; io_service service; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client</span></span></span><span class="hljs-class"> {</span></span> ip::tcp::socket sock; streambuf buff; <span class="hljs-comment"><span class="hljs-comment">// reads the answer from the client } std::vector&lt;client&gt; clients; void handle_clients() { for ( int i = 0; i &lt; clients.size(); ++i) async_read_until(clients[i].sock, clients[i].buff, '\n', boost::bind(on_read, clients[i], _1, _2)); for ( int i = 0; i &lt; 10; ++i) boost::thread(handle_clients_thread); } void handle_clients_thread() { service.run(); } void on_read(client &amp; c, const error_code &amp; err, size_t read_bytes) { std::istream in(&amp;c.buff); std::string msg; std::getline(in, msg); if ( msg == "request_login") c.sock.async_write( "request_ok\n", on_write); else if ... ... // now, wait for the next read from the same client async_read_until(c.sock, c.buff, '\n', boost::bind(on_read, c, _1, _2)); }</span></span></code> </pre><br>  Notice how much simpler the code has become.  The <code>client</code> structure has only two members, <code>handle_clients()</code> simply calls <code>async_read_until</code> , and then creates ten threads, each of which calls <code>service.run()</code> .  These threads will handle all asynchronous read or write operations to the client.  Another thing to note is that the <code>on_read()</code> function will constantly prepare for the next asynchronous read operation (see the last line). <br><br><h4>  Asynchronous functions run (), run_one (), poll (), poll_one () </h4><br>  To implement a listen loop, the <code>io_service</code> class provides four functions, such as <code>run(), run_one(), poll()</code> , and <code>poll_one()</code> .  Although most of the time you will be working with <code>service.run()</code> .  Here you will learn what can be achieved with the help of other functions. <br><br><h5>  Constantly working </h5><br>  Once again, <code>run()</code> will work until the pending operations are completed or until you call <code>io_service::stop()</code> yourself.  To keep an <code>io_service</code> instance working, you typically add one or more asynchronous operations, and when they end, you continue to add, as shown in the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::asio; io_service service; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff_read[<span class="hljs-number"><span class="hljs-number">1024</span></span>], buff_write[<span class="hljs-number"><span class="hljs-number">1024</span></span>] = <span class="hljs-string"><span class="hljs-string">"ok"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;err, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;err, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ sock.async_read_some(buffer(buff_read), on_read); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;err, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... process the read ... sock.async_write_some(buffer(buff_write,3), on_write); } void on_connect(const boost::system::error_code &amp;err) { sock.async_read_some(buffer(buff_read), on_read); } int main(int argc, char* argv[]) { ip::tcp::endpoint ep( ip::address::from_string("127.0.0.1"), 2001); sock.async_connect(ep, on_connect); service.run(); }</span></span></code> </pre><br>  When <code>service.run()</code> is called, at least one asynchronous operation is pending.  When the socket connects to the server, <code>on_connect</code> is <code>on_connect</code> , which adds another asynchronous operation.  After the end of work <code>on_connect</code> , we have one scheduled operation ( <code>read</code> ).  When the <code>on_read</code> operation is <code>on_read</code> , we write the answer, another scheduled operation ( <code>write</code> ) is added.  When the <code>on_write</code> function is <code>on_write</code> , we read the following message from the server, which will add another scheduled operation.  When the <code>on_write</code> function <code>on_write</code> , we have one scheduled operation ( <code>read</code> ).  And so the cycle continues until we decide to close the application. <br><br><h5>  Functions run_one (), poll (), poll_one () </h5><br>  It was noted earlier that handlers of asynchronous functions are called on the same thread in which <code>io_service::run</code> was called.  This is noted for simplicity, because at least 90 to 95 percent of the time is the only function you'll use.  The same is true for <code>run_one(), poll()</code> , or <code>poll_one()</code> in the stream. <br>  The <code>run_one()</code> function will perform and send more than one asynchronous operation: <br><ul><li>  If there are no scheduled operations, the function ends immediately and 0 is returned. </li><li>  If there are deferred operations, the functional blocks of the first operation are executed and 1 is returned. </li></ul><br>  You may consider the following equivalent code: <br><br><pre> <code class="cpp hljs">io_service service; service.run(); <span class="hljs-comment"><span class="hljs-comment">// OR while ( !service.stopped()) service.run_once();</span></span></code> </pre><br>  You can use <code>run_once()</code> to start an asynchronous operation, and then wait for it to complete: <br><br><pre> <code class="cpp hljs">io_service service; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> write_complete = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ write_complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> data = <span class="hljs-string"><span class="hljs-string">"login ok"</span></span>; write_complete = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; async_write(sock, buffer(data), on_write); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> service.run_once() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!write_complete);</code> </pre><br>  There are also some examples that use <code>run_one()</code> along with Boost.Asio, for example <code>blocking_tcp_client.cpp</code> and <code>blocking_udp_client.cpp</code> .  The <code>poll_one</code> function runs no more than one deferred operation that is ready to start without blocking: <br><ul><li>  If at least one delayed operation is ready to start without blocking, then <code>run_one()</code> will start it and return 1 </li><li>  Otherwise, the function ends immediately and returns 0. </li></ul><br>  A delayed operation that is ready to be started without blocking is usually one of the following: <br><ul><li>  Timer that has expired and its <code>async_wait</code> handler should be <code>async_wait</code> </li><li>  An I / O operation that has completed (for example, <code>async_read</code> ) and its handler must be called </li><li>  The custom handler that was previously added to the <code>io_services</code> instance <code>io_services</code> (this is explained in detail in the next section) </li></ul><br>  You can use <code>poll_one</code> to make sure that all the I / O handlers are running and proceed to the following tasks: <br><br><pre> <code class="cpp hljs">io_service service; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// run all handlers of completed IO operations while ( service.poll_one()) ; // ... do other work here ... }</span></span></code> </pre><br>  The <code>poll()</code> function will perform all operations that are pending, and can be run without blocking.  The following code is equivalent: <br><br><pre> <code class="cpp hljs">io_service service; service.poll(); <span class="hljs-comment"><span class="hljs-comment">// OR while ( service.poll_one()) ;</span></span></code> </pre><br>  All previous functions will throw exceptions <code>boost::system::system_error</code> in case of failure.  But this should never happen;  an error thrown here usually results in a crash, maybe an error in the resources or one of your handlers threw an exception.  In any case, each of the functions has an overload, which does not throw exceptions, but takes <code>boost::system::error_code</code> as an argument and sets it as a return value. <br><br><pre> <code class="cpp hljs">io_service service; boost::system::error_code err = <span class="hljs-number"><span class="hljs-number">0</span></span>; service.run(err); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( err) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Error "</span></span> &lt;&lt; err &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br><h4>  Asynchronous operation </h4><br>  Asynchronous operation is not only asynchronous processing of clients connecting to the server, asynchronous reading from and writing to the socket.  This covers any operations that can be performed asynchronously. <br>  By default, you do not know the order in which the handlers of all asynchronous functions are called.  In addition, usually the following calls are asynchronous (outgoing from an asynchronous socket read / write / receive).  You can use <code>service.post()</code> to add a custom function that will be called asynchronously, for example: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/thread.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;boost/asio.hpp&gt; #include &lt;iostream&gt; using namespace boost::asio; io_service service; void func(int i) { std::cout &lt;&lt; "func called, i= " &lt;&lt; i &lt;&lt; std::endl; } void worker_thread() { service.run(); } int main(int argc, char* argv[]) { for ( int i = 0; i &lt; 10; ++i) service.post(boost::bind(func, i)); boost::thread_group threads; for ( int i = 0; i &lt; 3; ++i) threads.create_thread(worker_thread); // wait for all threads to be created boost::this_thread::sleep( boost::posix_time::millisec(500)); threads.join_all(); }</span></span></span></span></code> </pre><br>  In the previous example, <code>service.post(some_function)</code> adds an asynchronous function call.  This function is immediately terminated, after an <code>io_service</code> instance is <code>io_service</code> to call this <code>some_function</code> in one of the threads, which calls <code>service.run()</code> .  In our case, we created one of the three streams in advance.  You cannot be sure of the order in which the asynchronous functions will be called.  You should not expect them to be called in the order of their addition ( <code>post()</code> ).  A possible result of the previous example is as follows: <br><br><pre> <code class="cpp hljs">func called, i= <span class="hljs-number"><span class="hljs-number">0</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">2</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">1</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">4</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">3</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">6</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">7</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">8</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">5</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br>  There may be a time when you want to assign a handler for some asynchronous function.  Let's say you have to go to a restaurant ( <code>go_to_restaurant</code> ), place an order ( <code>order</code> ) and eat ( <code>eat</code> ).  You want to first come to the restaurant, make an order, and only then eat.  To do this, you will use <code>io_service::strand</code> , which will assign which asynchronous handler to call.  Consider the following example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::asio; io_service service; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"func called, i= "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-string"><span class="hljs-string">"/"</span></span> &lt;&lt; boost::this_thread::get_id() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ service.run(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ io_service::<span class="hljs-function"><span class="hljs-function">strand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strand_one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strand_two</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) service.post( strand_one.wrap( boost::bind(func, i))); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">5</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i) service.post( strand_two.wrap( boost::bind(func, i))); boost::thread_group threads; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i) threads.create_thread(worker_thread); <span class="hljs-comment"><span class="hljs-comment">// wait for all threads to be created boost::this_thread::sleep( boost::posix_time::millisec(500)); threads.join_all(); }</span></span></code> </pre><br>  In the above code, we see that the first five and the last five thread IDs are output sequentially, namely, <code>func called, i = 0</code> will be output before <code>func called, i = 1</code> , which will be displayed before <code>func called, i = 2</code> and so on .  The same for <code>func called, i = 5</code> , which will be displayed before <code>func called, i = 6</code> and <code>func called, i = 6</code> will be displayed before <code>func called, i = 7</code> and so on.  It should be noted that even if functions are called sequentially, this does not mean that they will all be called in one thread.  A possible implementation of this program may be as follows: <br><br><pre> <code class="cpp hljs">func called, i= <span class="hljs-number"><span class="hljs-number">0</span></span>/<span class="hljs-number"><span class="hljs-number">002</span></span>A60C8 func called, i= <span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-number"><span class="hljs-number">002</span></span>A6138 func called, i= <span class="hljs-number"><span class="hljs-number">6</span></span>/<span class="hljs-number"><span class="hljs-number">002</span></span>A6530 func called, i= <span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">002</span></span>A6138 func called, i= <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-number"><span class="hljs-number">002</span></span>A6530 func called, i= <span class="hljs-number"><span class="hljs-number">2</span></span>/<span class="hljs-number"><span class="hljs-number">002</span></span>A6138 func called, i= <span class="hljs-number"><span class="hljs-number">8</span></span>/<span class="hljs-number"><span class="hljs-number">002</span></span>A6530 func called, i= <span class="hljs-number"><span class="hljs-number">3</span></span>/<span class="hljs-number"><span class="hljs-number">002</span></span>A6138 func called, i= <span class="hljs-number"><span class="hljs-number">9</span></span>/<span class="hljs-number"><span class="hljs-number">002</span></span>A6530 func called, i= <span class="hljs-number"><span class="hljs-number">4</span></span>/<span class="hljs-number"><span class="hljs-number">002</span></span>A6138</code> </pre><br><br><h5>  Asynchronous post () vs. dispatch () vs. wrap () </h5><br>  Boost.Asio provides three ways to add a function handler for an asynchronous call: <br><ul><li>  <code>service.post(handler)</code> : this function ensures that it will complete immediately after it makes a request to the <code>io_service</code> instance to call the specified handler.  The handler will be called later in one of the threads that called <code>service.run()</code> . </li><li>  <code>service.dispatch(handler)</code> : this is a request to an instance of <code>io_service</code> to call a given handler, but, in addition, it can call a handler inside a function if the current thread called <code>service.run()</code> . </li><li>  <code>service.wrap(handler)</code> : this function creates a wrapper function that will call <code>service.dispatch(handler)</code> .  This is a bit confusing, I will explain shortly what it means. </li></ul><br>  You saw an example of using <code>service.post()</code> in the previous section, as well as a possible result of the program execution.  Change it and see how <code>service.dispatch</code> affects the result: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::asio; io_service service; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"func called, i= "</span></span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_dispatch_and_post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i += <span class="hljs-number"><span class="hljs-number">2</span></span>) { service.dispatch(boost::bind(func, i)); service.post(boost::bind(func, i + <span class="hljs-number"><span class="hljs-number">1</span></span>)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ service.post(run_dispatch_and_post); service.run(); }</code> </pre><br>  Before explaining what is happening here, let's look at the result by running the program: <br><br><pre> <code class="cpp hljs">func called, i= <span class="hljs-number"><span class="hljs-number">0</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">2</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">4</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">6</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">8</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">1</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">3</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">5</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">7</span></span> func called, i= <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre><br>  First, even numbers are written, and then odd numbers.  This is because we use <code>dispatch()</code> to write even numbers and <code>post()</code> to write odd numbers.  <code>dispatch()</code> will call the handler before it completes, because the current thread called <code>service.run()</code> , while post () terminates right away. <br>  Now let's talk about <code>service.wrap(handler)</code> .  wrap () returns a functor that can be used as an argument to another function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::asio; io_service service; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatched_func_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"dispatched 1"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatched_func_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"dispatched 2"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(boost::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">()&gt; func)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"test"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; service.dispatch(dispatched_func_1); func(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">service_run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ service.run(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ test( service.wrap(dispatched_func_2)); boost::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">th</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service_run)</span></span></span></span>; boost::this_thread::sleep( boost::posix_time::millisec(<span class="hljs-number"><span class="hljs-number">500</span></span>)); th.join(); }</code> </pre><br>  String <code>test(service.wrap(dispatched_func_2));</code>  will wrap <code>dispatched_func_2</code> and create a functor that will be passed to <code>test</code> as an argument.  When <code>test()</code> called, it redirects the call to <code>dispatched_func_1()</code> and calls <code>func()</code> .  At this point, you will see that calling <code>func()</code> equivalent to <code>service.dispatch(dispatched_func_2)</code> , since they are called sequentially.  The output of the program confirms this: <br><br><pre> <code class="cpp hljs">test dispatched <span class="hljs-number"><span class="hljs-number">1</span></span> dispatched <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  The <code>io_service::strand</code> class (used to serialize asynchronous actions) also contains the <code>poll(), dispatch()</code> and <code>wrap()</code> functions.  Their meaning is the same as the <code>poll(), dispatch()</code> and <code>wrap()</code> <code>io_service</code> from <code>io_service</code> .  However, most of the time, you will only use the <code>io_service::strand::wrap()</code> function as an argument for <code>io_service::poll()</code> or <code>io_service::dispatch()</code> . <br><br><h4>  Stay alive </h4><br>  You say, performing the following operation: <br><br><pre> <code class="cpp hljs">io_service service; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">512</span></span>]; ... read(sock, buffer(buff));</code> </pre><br>  In this case, <code>sock</code> and <code>buff</code> must both survive the <code>read()</code> call.  In other words, they must be valid after the <code>read()</code> call is completed.  This is exactly what you expect, all the arguments you pass to the function must be valid inside it.  Everything becomes more complicated when we go asynchronously: <br><br><pre> <code class="cpp hljs">io_service service; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} ... async_read(sock, buffer(buff), on_read);</code> </pre><br>  In this case, <code>sock</code> and <code>buff</code> must survive the <code>read</code> operation itself, but we do not know when this will happen, since it is asynchronous. <br>  When using socket buffers, you can have a <code>buffer</code> instance that survived the asynchronous call (using <code>boost::shared_array&lt;&gt;</code> ).  Here we can use the same principle by creating a class that internally contains a socket and buffers for reading / writing.  Then for all asynchronous calls we pass the <code>boost::bind</code> shared pointer functor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::asio; io_service service; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection</span></span></span><span class="hljs-class"> :</span></span> boost::enable_shared_from_this&lt;connection&gt; { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::system::error_code error_code; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;connection&gt; ptr; connection() : sock_(service), started_(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::tcp::endpoint ep)</span></span></span><span class="hljs-function"> </span></span>{ sock_.async_connect(ep, boost::bind(&amp;connection::on_connect, shared_from_this(), _1)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started_) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; started_ = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; sock_.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">started</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> started_; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// here you decide what to do with the connection: read or write if ( !err) do_read(); else stop(); } void on_read(const error_code &amp; err, size_t bytes) { if ( !started() ) return; std::string msg(read_buffer_, bytes); if ( msg == "can_login") do_write("access_data"); else if ( msg.find("data ") == 0) process_data(msg); else if ( msg == "login_fail") stop(); } void on_write(const error_code &amp; err, size_t bytes) { do_read(); } void do_read() { sock_.async_read_some(buffer(read_buffer_), boost::bind(&amp;connection::on_read, shared_from_this(), _1, _2)); } void do_write(const std::string &amp; msg) { if ( !started() ) return; // note: in case you want to send several messages before // doing another async_read, you'll need several write buffers! std::copy(msg.begin(), msg.end(), write_buffer_); sock_.async_write_some(buffer(write_buffer_, msg.size()), boost::bind(&amp;connection::on_write, shared_from_this(), _1, _2)); } void process_data(const std::string &amp; msg) { // process what comes from server, and then perform another write } private: ip::tcp::socket sock_; enum { max_msg = 1024 }; char read_buffer_[max_msg]; char write_buffer_[max_msg]; bool started_; }; int main(int argc, char* argv[]) { ip::tcp::endpoint ep( ip::address::from_string("127.0.0.1"), 8001); connection::ptr(new connection)-&gt;start(ep); }</span></span></code> </pre><br>  In all asynchronous calls, the <code>boost::bind</code> functor is sent as an argument.  This functor internally stores the shared pointer on the <code>connection</code> instance.  While an asynchronous operation is pending, Boost.Asio will store a copy of the <code>boost::bind</code> functor, which in turn stores the shared pointer on the <code>connection</code> .  Problem solved! <br>  Of course, the <code>connection</code> class is only a <code>skeleton</code> class;  You will need to adapt it to your needs (in the case of a server, it will look very different).  Notice how easy you are creating a new <code>connection::ptr(new connection)-&gt;start(ep)</code> .  This begins a (asynchronous) connection to the server.  If you want to close the connection, you call <code>stop()</code> . <br>  As soon as the instance began to work ( <code>start()</code> ), it will wait for connections.  When a connection occurs, <code>on_connect()</code> called.  If there are no errors, then a read operation ( <code>do_read()</code> ) is called.  Once the read operation is complete, you can interpret the message;  most likely in your <code>on_read()</code> application will look different.  When you send a message, you have to copy it to a buffer, and then send it, as done in <code>do_write()</code> , because, again, the buffer must survive the asynchronous write operation.  And the last note - when recording, remember that you must specify how much to write, otherwise the entire buffer will be sent. <br><br><h4>  Summary </h4><br>  Network API is very extensive.  This chapter has been implemented as a link to which you should return at the time when you implement your own network application. <br>  Boost.Asio introduces the concept of endpoints that you can think of as an IP address and port.  If you do not know the exact IP address, then you can use a <code>resolver</code> object to include a host name, such as <a href="http://www.yahoo.com/">www.yahoo.com,</a> instead of one or more IP addresses. <br>  We also looked at the socket classes that are in the core of the API.  Boost.Asio provides implementations for TCP, UDP, and ICMP, but you can extend it for your own protocols, although this is not a job for the faint of heart. <br>  Asynchronous programming is a necessary evil.  You have seen why sometimes this is needed, especially when writing servers.  Usually you only need to call <code>service.run()</code> to create an asynchronous loop, but sometimes you need to go further and then you can use <code>run_one(), poll()</code> , or <code>poll_one()</code> . <br>  When using the asynchronous approach, you can have your own asynchronous functions, just use <code>service.post()</code> or <code>service.dispatch()</code> . <br>  Finally, in order for both the socket and the buffer (for reading or writing) to remain valid for the entire period of the asynchronous operation (until completion), we must take special precautions.  Your <code>connection</code> class should <code>enabled_shared_from_this</code> from <code>enabled_shared_from_this</code> , contain all the necessary buffers within it and, at each asynchronous call, pass the shared pointer to this operation. <br>  The next chapter will have a lot of practical work;  many application coding when implementing such applications as client / server echo. <br><br>  Thank you all, until we meet again! </div><p>Source: <a href="https://habr.com/ru/post/195006/">https://habr.com/ru/post/195006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../194994/index.html">iMessage for Android</a></li>
<li><a href="../194998/index.html">Visiting the switch</a></li>
<li><a href="../195000/index.html">Minecraft shoved the whole UK</a></li>
<li><a href="../195002/index.html">Ghost customer focus wanders through Russia</a></li>
<li><a href="../195004/index.html">Digging in JVM memory. Manipulations with flags</a></li>
<li><a href="../195008/index.html">Roskomnadzor bans twenty-nine Japanese manga comics, equates to sex with children</a></li>
<li><a href="../195010/index.html">Backing up data to a free cloud service Wuala</a></li>
<li><a href="../195014/index.html">FileCoder ransomware families intensified</a></li>
<li><a href="../195018/index.html">Silently Apple has updated the iMac line</a></li>
<li><a href="../195024/index.html">IFA 2013 with your own eyes: Samsung, Toshiba, Panasonic, TCL / Alcatel and Archos mobile devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>