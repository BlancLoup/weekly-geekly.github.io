<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FreeRTOS: interprocess communication</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. In this article I will try to describe the method of interprocess data exchange and synchronization with the events. 
 Links to other parts: 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FreeRTOS: interprocess communication</h1><div class="post__text post__text-html js-mediator-article"><img src="http://i.minus.com/jyKeqr9vTIgM3.jpg" align="right"><br>  Hello.  In this article I will try to describe the method of interprocess data exchange and synchronization with the events. <br>  Links to other parts: <br>  <a href="http://habrahabr.ru/blogs/controllers/129105/">FreeRTOS: introduction.</a> <br>  <a href="http://habrahabr.ru/blogs/controllers/129445/">FreeRTOS: mutexes and critical sections.</a> <br><a name="habracut"></a><br>  Any multi-threaded OS will not be considered complete, without the appropriate means of supporting a multi-threaded environment.  FreeRTOS has everything you need for this, namely: <br><ul><li>  Queues for data exchange between tasks, or ISR. </li><li>  Binary semaphores, and countable semaphores for synchronization with events (interrupts). </li><li>  Mutexes for sharing a resource (for example, a port). </li><li>  Critical sections to create a region of code whose execution cannot be interrupted by the scheduler. </li></ul><br><h4>  The queues. </h4><br><img src="http://i.minus.com/iV9qclKu7HFx9.jpg" alt="image" align="right"><br>  Programs written using FreeRTOS are a set of independent tasks, or mini-subprograms, that require an effective and thread-safe data exchange mechanism, in the case of FreeRTOS, these are queues. <br>  A queue is a simple FIFO (although you can also write to the beginning of the queue, and not to the end) a buffer that can store a fixed number of elements of a known size.  Writing to a queue is byte-wise copying data to a buffer, reading is copying data and deleting from a queue. <br>  Queues are, in fact, independent objects that many writers and readers may have, without fear of reading / writing broken data.  When reading data, optionally, we can specify the time during which the task should be waiting for new data to be received.  When recording data, we can also specify this time, but already to wait for a place in the queue. <br><br>  Let us consider in more detail the basic functions for working with queues in FreeRTOS. <br>  Before using any queue, it must be created.  RAM memory for the queue is allocated from the FreeRTOS heap, and its size is equal to the data size + the size of the queue structure.  In the code, each queue is represented by its handle, such as xQueueHandle. <br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">xQueueHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xQueueCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> portBASE_TYPE uxQueueLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> portBASE_TYPE uxItemSize)</span></span></span></span>;</code> </pre> <br>  <strong><em>uxQueueLength</em></strong> - the maximum number of items the queue can store per unit of time. <br>  <strong><em>uxItemSize</em></strong> - the size of each item in the queue. <br>  <strong><em>return xQueueHandle, or NULL</em></strong> - if the queue is created, the corresponding handle will be returned, if not, i.e.  not enough memory, then NULL will be returned. <br><br>  For writing to the queue use special functions: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">portBASE_TYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xQueueSendToFront</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xQueueHandle xQueue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pvItemToQueue, portTickType xTicksToWait</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">portBASE_TYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xQueueSendToBack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xQueueHandle xQueue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pvItemToQueue, portTickType xTicksToWait</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   portBASE_TYPE xQueueSend(xQueueHandle xQueue, const void * pvItemToQueue, portTickType xTicksToWait);</span></span></code> </pre> <br>  <strong><em>xQueue</em></strong> is the handle of the queue in which we write the data. <br>  <strong><em>pvItemToQueue</em></strong> - pointer to the item that will be placed in the queue. <br>  <strong><em>xTicksToWait</em></strong> - the time during which the task must be in a locked state in order for a place in the queue to appear.  You can specify <b>portMAX_DELAY</b> so that the task is in the locked state for an indefinite time, i.e.  until a place in line appears. <br>  <strong><em>return pdPASS, or errQUEUE_FULL</em></strong> - if the new item is successfully written to the queue, the function returns pdPASS, if there is not enough space, and xTicksToWait time is specified, the task will go to the blocked time to wait in the queue. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For reading data, 2 functions are used, the main difference is that xQueueReceive removes an item from the queue, but xQueuePeek does not. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">portBASE_TYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xQueueReceive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xQueueHandle xQueue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pvBuffer, portTickType xTicksToWait</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">portBASE_TYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xQueuePeek</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xQueueHandle xQueue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pvBuffer, portTickType xTicksToWait</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  <strong><em>xQueue</em></strong> is the handle of the queue in which we write the data. <br>  <strong><em>pvBuffer</em></strong> is a pointer to a memory buffer into which data from the queue will be read.  Buffer type = type of queue items. <br>  <strong><em>xTicksToWait</em></strong> - the time during which the task should be in a locked state for the data to appear in the queue.  You can specify <b>portMAX_DELAY</b> so that the task is in the locked state for an indefinite time, i.e.  until new data appears in the queue.  Next, I will explain how this is used to create the Gatekeeper Task. <br>  <strong><em>return pdPASS, or errQUEUE_EMPTY</em></strong> - if the new item is successfully read from the queue, the function returns pdPASS, if the queue is empty, and xTicksToWait is specified, the task will go to the blocked time to wait for new data in the queue. <br><br>  To view the number of items in the queue, you can use the function <pre> <code class="hljs lisp">unsigned portBASE_TYPE uxQueueMessagesWaiting( <span class="hljs-name"><span class="hljs-name">xQueueHandle</span></span> xQueue )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Important: The above functions cannot be used in ISR (interrupts) and there are special versions for them with a special <b>ISR</b> suffix, the behavior of which is similar to the previous functions, except for the last parameter: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">portBASE_TYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xQueueSendToFrontFromISR</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> xQueueHandle xQueue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken </span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">portBASE_TYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xQueueSendToBackFromISR</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xQueueHandle xQueue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">portBASE_TYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xQueueReceiveFromISR</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xQueueHandle xQueue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvBuffer, portBASE_TYPE *pxHigherPriorityTaskWoken</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  <strong><em>pxHigherPriorityTaskWoken</em></strong> - since writing to a queue can lead to unblocking a task that waits for data and has a higher priority than the current task, we need to perform a forced context switch (to do this, call the taskYIELD () macro).  If necessary, this parameter will be equal to <b>pdTRUE</b> . <br><br>  A few words about the effective use of queues.  For example, consider a UART ‚Äî with a typical approach, each byte received is immediately written to a queue, which is not worth doing.  it is terribly inefficient, already at fairly low frequencies.  It is more efficient to conduct basic data processing in an ISR and then transfer them to a queue, but it is important to understand that the ISR code should be as short as possible. <br><br>  Consider an example of the so-called gatekeeper task (I don‚Äôt know how to correctly translate this, if someone tells me, I will be grateful :)). <br>  The gatekeeper task is a simple method that allows you to avoid the main problems of multi-threaded programming: inverting priorities, and getting the task to a deadlock. <br>  The gatekeeper task is the only method that has direct access to the resource, all other tasks must access the resource through this task. <br>  Consider a simple skeleton gatekeeper task.  This is a purely contrived example, but which will help to understand the general principle.  We assume that we need to safely send some data, for example, through the UART. <br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ Gatekeeper    . void vGatekeeperTask( void *pvParameteres ) { char oneByte; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   -   ,      UART ,         . for( ;; ) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     portMAX_DELAY    ,      . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ,     . xQueueReceive( xDataQueue, &amp;oneByte, portMAX_DELAY); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,     . vSendByteToUART( oneByte ); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . } }</span></span></code> </pre> <br>  Thus, any task that wants to send a byte using the UART can use one of the service functions, for example, the following: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vUARTPutByte</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      ,       ,    . xQueueSend( xDataQueue, &amp;byte, 0 ); }</span></span></code> </pre> <br>  It is also worth noting that you should not limit yourself, only char as the data type of the queue, but you can organize entire pipelines using structures. <br><br><h4>  Binary semaphores. </h4><br><img src="http://i.minus.com/ibjTUcfAWpagfq.jpg" alt="image" align="right"><br>  Binary semaphores, can be used to unlock a task whenever an event occurs (for example, pressing a button). <br>  Typical work scenario: when a certain interruption occurs in the ISR, we <em>give up the</em> semaphore, as a result of a task, the waiting semaphore <em>picks up the</em> semaphore and goes out of the unlocked state to perform any operations.  This mechanism is shown in the following figure. <br><img src="https://habrastorage.org/getpro/geektimes/post_images/cf0/201/f1b/cf0201f1b01fbcb58fb127816fba37a1.png" alt="image"><br>  To store all types of semaphores, the data type is <em>xSemaphoreHandle</em> . <br>  Consider the functions for working with semaphores: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vSemaphoreCreateBinary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> xSemaphoreHandle xSemaphore </span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  <strong><em>xSemaphore</em></strong> - this function is implemented using a macro, so it is necessary to transfer the value of the handle, and not a pointer to it.  If the semaphore was successfully created, the xSemaphore value is not NULL. <br><br>  In order to "take" a semaphore, a special function is used: <br><pre> <code class="hljs lisp">portBASE_TYPE xSemaphoreTake( <span class="hljs-name"><span class="hljs-name">xSemaphoreHandle</span></span> xSemaphore, portTickType xTicksToWait )<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  <strong><em>xSemaphore</em></strong> is the handle of the semaphore that is planned to be taken. <br>  <strong><em>xTicksToWait</em></strong> - the time during which the task should be in a locked state, after which the semaphore becomes available.  You can specify <b>portMAX_DELAY</b> so that the task is in a locked state for an indefinite time, i.e.  until the semaphore is available. <br>  <strong><em>return pdPASS, or pdFALSE</em></strong> - pdPASS - if the semaphore is received, pdFALSE - if the semaphore is unavailable. <br><br>  In order to ‚Äúgive away‚Äù the semaphore, special functions are also used.  I will consider the ISR version because  most often semaphores are used in conjunction with ISR. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">portBASE_TYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xSemaphoreGiveFromISR</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> xSemaphoreHandle xSemaphore, portBASE_TYPE *pxHigherPriorityTaskWoken </span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  <strong><em>xSemaphore</em></strong> - the handle of the semaphore, which is planned to "give." <br>  <strong><em>pxHigherPriorityTaskWoken</em></strong> - since the ‚Äútransfer‚Äù of a semaphore can lead to unblocking a task that is waiting for semaphore data that has a higher priority than the current task, we need to perform a forced context switch (to do this, call the taskYIELD () macro).  If necessary, this parameter will be equal to <b>pdTRUE</b> . <br>  <strong><em>return pdPASS, or pdFALSE</em></strong> - pdPASS - if the semaphore is given, pdFALSE - if the semaphore is already available, but not processed. <br><br>  As an example, I will give a short program code, for the ISR, I wrote pseudocode: <br><pre> <code class="hljs pgsql">xSemaphoreHandle xButtonSemaphore; <span class="hljs-type"><span class="hljs-type">void</span></span> vButtonHandlerTask( <span class="hljs-type"><span class="hljs-type">void</span></span> *pvParameteres ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( ;; ) { xSemaphoreTake( xButtonSemaphore, portMAX_DELAY ); //       . } } <span class="hljs-type"><span class="hljs-type">void</span></span> main() { //   vInitSystem(); vSemaphoreCreateBinary( xButtonSemaphore ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( xButtonSemaphore != <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ) { //  .      ,     ! xTaskCreate( &amp;vButtonHandlerTask, (signed <span class="hljs-type"><span class="hljs-type">char</span></span> *)"GreenBlink", configMINIMAL_STACK_SIZE, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ); //  , ..   . vTaskStartScheduler(); } //      ,      ,     .       . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( ;; ) { } } ISR_FUNCTION processButton() { portBASE_TYPE xTaskWoken; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( buttonOnPressed ) { xSemaphoreGiveFromISR( xButtonSemaphore, &amp;xTaskWoken ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( xTaskWoken == pdTRUE) { taskYIELD(); } } }</code> </pre> <br><h4>  Counting semaphores. </h4><br>  Consider a typical situation that exists when using semaphores: <br>  1. An event has occurred that caused an interrupt. <br>  2. The ISR "gives" the semaphore, i.e.  unlocks the waiting semaphore task. <br>  3. Waiting task ‚Äútakes‚Äù semaphore. <br>  4. After the execution of the necessary code, the task again goes into a locked state, waiting for new events. <br>  This algorithm works fine, but not at high frequencies.  At high frequencies it is necessary to use countable semaphores, which, as a rule, are used in 2 cases: <br><ul><li>  Also for synchronization with events, but at high frequencies. </li><li>  Resource management.  In this case, the number of semaphores indicates the amount of available resources. </li></ul><br>  As mentioned above, the xSemaphoreHandle data type is used to store all types of semaphores, and since it must be created before using a semaphore, it is necessary to use a special function to create counting semaphores: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">xSemaphoreHandle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xSemaphoreCreateCounting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> portBASE_TYPE uxMaxCount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> portBASE_TYPE uxInitialCount )</span></span></span></span>;</code> </pre> <br>  <strong><em>uxMaxCount</em></strong> - the maximum number of semaphores that a counter can store.  By analogy with the queue - is the length of the queue. <br>  <strong><em>uxInitialCount</em></strong> - the value of the counter after creating the semaphore. <br>  <strong><em>return is not NULL</em></strong> - the function returns a non-NULL value if the semaphore was created. <br>  Otherwise, functions similar to the previous ones are used to work with counting semaphores. </div><p>Source: <a href="https://habr.com/ru/post/129180/">https://habr.com/ru/post/129180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129175/index.html">Digest Wanted.VC # 16</a></li>
<li><a href="../129176/index.html">How to start and do not stop writing OS</a></li>
<li><a href="../129177/index.html">If This Then That (ifttt). Web services binding mashup</a></li>
<li><a href="../129178/index.html">No one wants to pay for dry reports. Interview with Avinash Koshik</a></li>
<li><a href="../129179/index.html">Analysts: New tablet from Amazon will compete with iPad</a></li>
<li><a href="../129181/index.html">Methods of dealing with DDoS attacks</a></li>
<li><a href="../129183/index.html">Payoneer: not only cards</a></li>
<li><a href="../129184/index.html">Repatriates Diary Part 2: How to attract investment in a startup, without connections and experience</a></li>
<li><a href="../129185/index.html">Redis: light apples</a></li>
<li><a href="../129186/index.html">Smartphone Huawei Honor officially presented</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>