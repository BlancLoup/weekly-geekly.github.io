<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Broccoli: first beta release</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Broccoli is a new automated build system. It can be compared with the Rails asset pipeline, however there are some differences: it runs on Node.JS and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Broccoli: first beta release</h1><div class="post__text post__text-html js-mediator-article">  Broccoli is a new automated build system.  It can be compared with the Rails asset pipeline, however there are some differences: it runs on Node.JS and is independent of the server side of the application. <br><br>  After a long string of 0.0.x alpha releases, I just released the first beta version, Broccoli 0.1.0. <br><br><h6>  Table of contents: </h6><br><ol><li>  Quick example </li><li>  Motivation / Features </li><li>  Architecture </li><li>  Behind the Scenes / General View </li><li>  Comparison with other build systems </li><li>  What's next? </li></ol><br><a name="habracut"></a><br><h4>  1. Quick example </h4><br>  Below is an example of the configuration file for the build (Brocfile.js).  Comments are intentionally omitted; an example is given only to illustrate the syntax: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">broccoli</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filterCoffeeScript = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'broccoli-coffee'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> compileES6 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'broccoli-es6-concatenator'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourceTree = broccoli.makeTree(<span class="hljs-string"><span class="hljs-string">'lib'</span></span>); sourceTree = filterCoffeeScript(sourceTree); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> appJs = compileES6(sourceTree, { ... outputFile: <span class="hljs-string"><span class="hljs-string">'/assets/app.js'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> publicFiles = broccoli.makeTree(<span class="hljs-string"><span class="hljs-string">'public'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [appJs, publicFiles]; };</code> </pre> <br>  Run <code>broccoli serve</code> to start tracking changes to the source files.  Each time any file in the list of monitored changes is changed, broccoli automatically rebuilds it in the target directory.  Broccoli is optimized to serve serve as fast as possible, so you should not pause between successive assemblies. <br><br>  Run <code>broccoli build dist</code> to do a one-time build and put the result in the dist folder. <br><br>  For a more detailed example, take a look at the <a href="https://github.com/joliss/broccoli-sample-app">broccoli-sample-app</a> <br><br><h4>  2. Motivation / Features </h4><br><h5>  2.1.  Fast rebuild </h5><br>  The main challenge in designing Broccoli was the implementation of fast incremental builds.  And that's why: <br><br>  For example, you use Grunt to build an application written in CoffeeScript, SASS, and several other preprocessors.  When you are developing something, you want to edit the files and immediately see the result in the browser, without constantly running the build of the system.  So, for this purpose you are using <code>grunt watch</code> , but as your application grows, the build is going slower and slower.  After several months of working on the project, your ‚Äúedited-updated‚Äù cycle turns into ‚Äúedited-waited-10-seconds-updated‚Äù. <br><br>  Accordingly, in order to speed up your build, you are trying to reassemble only those files that have been changed.  It's pretty hard, because  it happens that one output file depends on several input files.  You have to manually configure the rules to rebuild the correct files, based on the modified and their dependencies.  But Grunt is not designed to cope with this task easily, and therefore, even having written your own sets of rules, you cannot be sure that the necessary files will be rebuilt.  Sometimes, it will re-compile files when it is not necessary (and thus slow down the build), but worse, sometimes it will not re-compile files when it has to do it (which makes your build unreliable). <br><br>  With Broccoli, you can just run <code>broccoli serve</code> , and he himself will understand which files need to be monitored, and will reassemble only those that need it. <br><br>  As a result, this means that a rebuild, as a rule, should have O (1) constant execution time, regardless of how many files are used in a project, since  there is always only one going.  I strive for a 200ms result for each build with a typical set of tasks, but because  such a delay time seems almost instantaneous for the human brain, for me the results are acceptable up to half a second. <br><br><h5>  2.2.  Plugin Chains </h5><br>  Another important task is the possibility of linking call plugins.  Let us consider an example to show how simple, using Broccoli, you can compile CoffeeScript with the following minifacting: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tree = broccoli.makeTree(<span class="hljs-string"><span class="hljs-string">'lib'</span></span>) tree = compileCoffeeScript(tree) tree = uglifyJS(tree) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tree</code> </pre><br>  Using Grunt, you would have to create a temporary directory (besides the final one) to save the CoffeeScript output there.  As a result of all these manipulations, the Gruntfile usually grows to rather large sizes.  With the help of Broccoli, all such actions are resolved automatically. <br><br><h4>  3. Architecture </h4><br>  For the curious, let me tell you about the Broccoli architecture. <br><br><h5>  3.1.  Trees, not files </h5><br>  As a level of abstraction for describing the source and output data, not files are used, but trees are directories with files and sub-directories.  It turns out that we have not ‚Äúfile-to-input-file-to-exit‚Äù, but ‚Äútree-to-input-tree-to-exit‚Äù. <br><br>  If Broccoli worked with separate files, we would still be able to compile CoffeeScript without problems (because files are compiled according to 1 to 1), but this would cause problems when interacting with API preprocessors like SASS (which allows <code>@import</code> , which allows you to compile n files in 1). <br><br>  However, Broccoli is designed in such a way that solving tasks for preprocessors like SASS (n: 1) does not cause problems, and tasks for preprocessors like CoffeeScript (1: 1) are easily solved as a special case n: 1.  In general, for such (1: 1) transformations, we have the <code>Filter</code> class, which makes it as easy as possible to use them in our solutions. <br><br><h5>  3.2.  Plugins just return new trees </h5><br>  First, I designed Broccoli with two primitives: <code>tree</code> (hereafter referred to as "tree"), which represent file directories and <code>transform</code> (hereinafter <code>transform</code> to as "transformation"), which takes the tree as input and returns a new, compiled tree at the output, after transformations. <br><br>  This implies that we are converting trees 1: 1.  Surprisingly, this is not always a good abstraction.  For example, in SASS there are ‚Äúdownload paths‚Äù that are used to find files when using the <code>@import</code> directive.  On a similar principle, concatenators like r.js work: it has the ‚Äúpaths‚Äù option, which is responsible for searching for imported modules.  The best way to represent such paths is a set (data structure) consisting of trees. <br><br>  As you can see, in the real world, many compilers / preprocessors assemble n ‚Äútrees‚Äù into one.  The simplest way to follow this approach is to allow plugins to deal with their input ‚Äútrees‚Äù themselves, thereby allowing them to take 0, 1, or n ‚Äútrees‚Äù as input. <br><br>  But now that we have decided that the plugins themselves will process their input trees, we no longer need to know about compilers as first-order objects.  Plugins simply export a function that takes from zero to n source trees (and possibly some settings), and returns an object representing the new tree.  For example: <br><br><pre> <code class="javascript hljs">broccoli.makeTree(<span class="hljs-string"><span class="hljs-string">'lib'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; a tree compileCoffeeScript(tree) // =&gt; a tree compileSass(tree, { loadPaths: [moreTrees, ...] }) // =&gt; a tree</span></span></code> </pre><br><br><h5>  3.3.  The file system is our API. </h5><br>  Remember that due to the fact that Grunt does not support the use of "chains" of plug-ins, we have to bother with temporary directories for intermediate results of assemblies, which makes our configs too large and heavily supported. <br><br>  To avoid this, the first thing that comes to mind is to bring the file system view into memory, where our trees will be presented as a collection of threads.  Gulp does that.  I also tried to implement this approach in earlier versions of Broccoli, but it turned out that the code became quite complicated: with threads, plugins had to keep track of queues and deadlocks.  Also, speaking about streams and paths: we may need attributes like the last modification time or file size.  Or, for example, if we need the ability to read the file again or find something, display the file in memory, or, eventually, if we need to transfer the input tree to another process through the terminal - here our API for working with streams will not be able to help, and we have to first write the whole tree to the file system.  Too hard! <br><br>  But wait, if we are going to copy every feature of the file system, and sometimes pull out our trees from memory and distill them into a physical representation, then put them into memory again, and again ... Why not just use the file system instead of streams? <br><br>  The <code>fs</code> Node.JS module already provides the required file system API for us - everything we can only wish for. <br><br>  The only inconvenience is that we will have to work with temporary directories "behind the scenes", and then we will have to clean up.  But, in fact, it is not as difficult as it seems. <br><br>  People sometimes worry that writing to disk is slower than into memory.  But even if you take a real hard disk, the throughput of modern SSDs becomes so high that it can be compared with the speed of the CPU, which means that we get only minor overheads. <br><br><h5>  3.4.  Caching instead of partial rebuild </h5><br>  When I tried to solve the problem of incremental builds, I tried to develop a way to check which files to recompile to allow Broccoli to trigger this event only for a subset of the source files.  With an incremental build, we need to know which source files the result depends on, because often we are confronted with n: 1 relations.  ‚ÄúPartial build‚Äù is a classic Make approach, just like the Rails asset pipeline, Rake :: Pipeline or Brunch, but I personally decided for myself that these are unnecessary difficulties. <br><br>  The Broccoli approach is much simpler: we ask all plugins to cache the output.  When we rebuild the project completely or when we restart individual plugins, most of the information will be taken from the cache of the plugins themselves, which will take meager time. <br><br>  At first Broccoli provided some caching primitives, but later it was decided to exclude them from the core API.  Now we just limit ourselves to providing an architecture that does not interfere with the implementation of caching. <br><br>  For plugins that are 1: 1 mapped, such as CoffeeScript, we can use a common caching mechanism (represented in the broccoli-filter package), leaving the plug-in code very simple.  Plugins that are built n: 1, such as SASS, require more careful care about caching, so they need to implement special logic to work with the cache.  I believe that in the future we will still be able to isolate some common part of caching logic. <br><br><h5>  3.5.  "No" parallelism </h5><br>  If we all suffer from slow builds, maybe we should try performing tasks in parallel? <br><br>  My answer is <i>‚Äúno‚Äù</i> : parallel launch of tasks makes it possible to have problems with the order inside the plug-ins, which you can overlook until the deployment.  These are the worst of the bugs, so moving away from a parallel launch, we protect ourselves from the whole category of bugs. <br><br>  On the other hand, the Amadal law stops us from gaining great performance when using parallel launches.  Let's take a simple example: our assembly takes 16 seconds.  Imagine that 50% we can run in parallel, and the rest should be run in the order of the queue (a la coffee-&gt; concate-&gt; uglify).  If we run such an assembly on a quad-core machine, the assembly will take 10 seconds: 8 seconds for the synchronous part, and 8/4 = 2 seconds for the parallel part.  As a result, the build time is still as much as 10 seconds, and this is only + 40% of the performance. <br><br>  For incremental builds that interest us most of all, caching minimizes most of the advantages of running parallel tasks, so we barely lose in performance. <br><br>  That is why I believe that the implementation of the parallelization of the assembly is not worth its advantages.  In principle, you are not prohibited from writing a plugin for Broccoli, which would provide the opportunity to parallelize some of the tasks of your build process.  However, Broccoli primitives are also designed in such a way as to allow the most convenient to design plug-ins that will be run in a deterministic sequence. <br><br><h5>  4. Behind the scenes / General view </h5><br>  At the core of my decision to write a good build system are two reasons. <br><br>  The first reason is improved performance, which is achieved by incremental builds. <br><br>  In general, I believe that the developer‚Äôs productivity is determined by the quality of the libraries and tools he uses.  The cycle ‚Äúedited, reloaded page‚Äù we repeat every day several hundred times, and this is probably the main way to get feedback.  And if we want to improve the performance of our tools, we need to make this cycle as fast as possible. <br><br>  The second reason is in supporting the ecosystem of front-end packages. <br><br>  I believe that Bower and the modular ES6 system will help us build a great ecosystem, but Bower itself is useless unless you build an assembly system over it.  That is why Bower is an absolutely unattached tool that allows you to load all the dependencies of your project (recursively, along with their dependencies) into the file system - this is all that can be done with it.  Broccoli, on the other hand, aims to become just that missing link - a superstructure in the form of an assembly system under which it will work. <br><br>  By the way, Broccoli itself is in no way connected with Bower or ES6 modules - you can use it with whatever you want.  (I know that there are other bundles, for example npm + browserify, or npm + r.js.) I‚Äôll touch on them in one of my next posts. <br><br><h5>  5. Comparison with other build systems </h5><br>  If I‚Äôve almost convinced you, but you‚Äôre still interested in how other build systems behave in comparison to Broccoli, then let me explain why I wrote Broccoli instead of using one of the following: <br><br>  <b>Grunt</b> is a tool for running tasks, and it has never been positioned as a system for building.  If you try to use it as an assembly system, you will quickly be disappointed, because  it does not provide the ability to use chain calls (composition), and you will quickly get tired of dealing with temporary directories, and in the meantime the configuration file will grow and grow.  Also, it cannot provide reliable incremental builds, so your re-assemblies will be slow and / or unreliable, see ‚ÄúFast Rebuild‚Äù above. <br><br>  Grunt was created as a tool for running tasks that allows you to get the functionality of shell scripts on any platform, such as scaffolding or deploying your application.  In the future, Broccoli will be available as a plugin for Grunt, so you can call it directly from your Gruntfile. <br><br>  <b>Gulp is</b> trying to solve the problem with the sequential invocation of plug-ins, but, as for me, it suffers from certain errors in architecture: despite the fact that all his work revolves around the "trees", they are implemented by a sequence of files.  This works fine when one source file is converted to one destination file.  But when the plugin is required to follow <code>import</code> directives, and this requires accessing files out of turn, the work becomes more complicated.  Now, plugins that use <code>import</code> directives suspend execution of the build and read the necessary files directly from the file system.  In the future, I heard that libraries will be used that will allow all threads on the virtual file system to run and pass them to the compiler.  I believe that all these complications are a symptom of a complete discrepancy between the build system and the compiler.  You can once again read the section "Trees, not files", where I stopped in more detail on this issue.  I'm also not at all sure that by abstracting from files to streams or a buffer, we will get a more convenient API;  see "The file system is our API." <br><br>  <b>Brunch</b> , like Gulp, uses an API based on files (rather than trees).  Just like in Gulp, plugins, after all, bypass the build system when they need to get more than one file.  Brunch also tries to perform partial rebuild instead of caching, see ‚ÄúCaching instead of partial rebuild‚Äù above. <br><br>  <b>Rake :: Pipeline is</b> written in Ruby, which is less ubiquitous than Node in the world of front-end development, and it also tries to do partial builds.  Yehuda Katz said that the system is not very actively supported, and he puts on Broccoli. <br><br>  <b>The Rails asset pipeline</b> also uses partial assemblies, and, moreover, uses very different approaches for development and production, which can lead to very unexpected errors at the time of deployment.  But more importantly, it requires a ROR on the backend. <br><br><h4>  6. What's next </h4><br>  The list of plugins is still small.  But if this is enough for your needs, I would highly recommend giving Broccoli a chance: <a href="https://github.com/joliss/broccoli">https://github.com/joliss/broccoli#installation</a> <br><br>  I would like to see how other people are involved in the development of plug-ins.  Compiling compilers is quite simple, but the most important and difficult thing is to achieve proper caching and minimal loss in speed.  We want to highlight more caching patterns to reduce duplicate code in plugins. <br><br>  In the next couple of weeks, my plans include improving the documentation and cleaning up the Broccoli kernel code and plugins.  We also want to add tests for the Broccoli core and provide an elegant solution for integration tests for plug-ins.  Also, in our existing plugins there is no support for source maps.  This is very expensive in terms of performance, because  plugins, when making a sequential call, have to take the Source Maps of the previous plug-in and correctly interpolate them, but I haven‚Äôt yet found the time to do it. <br><br>  Soon you will be able to see the active use of Broccoli in the ecosystem of the Ember framework, which will provide the default ember-cli stack (it will appear soon, its functionality is similar to rails command line).  We also hope to replace Rake :: Pipeline and Grunt during the Ember core build process. <br><br>  I would also very much like to see Broccoli adapted for projects outside the Ember community.  JS MVC applications written using frameworks such as Angular or Backbone, various JS and CSS libraries that require assemblies are the main candidates to be compiled using Broccoli.  Using Broccoli for real build scripts, we need to make sure its API is reliable, and I hope that in the next few months we will be able to release the first stable (1.0.0) version. <br><br>  This post is the first post detailing the Broccoli architecture, so there is still little background information / documentation.  I will be happy to help you get started, and fix any bugs you encounter.  You can find me on #broccolijs on Freenode, or by writing me a mail / calling Google Talk: joliss42@gmail.com.             <a href="https://github.com/joliss/broccoli/issues"> </a>  Github. <br><br>   Jonas Nicklas, Josef Brandl, Paul Miller, Erik Bryn, Yehuda Katz, Jeff Felchner, Chris Willard, Joe Fiorini, Luke Melia, Andrew Davey, and Alex Matchneer       . <br><br><h5>  From translator </h5><br>     <a href="https://habrahabr.ru/users/z6dabrata/" class="user_link">z6Dabrata</a>         . </div><p>Source: <a href="https://habr.com/ru/post/216715/">https://habr.com/ru/post/216715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216695/index.html">About patriotism and realism</a></li>
<li><a href="../216697/index.html">Easy way to write iOS apps on the web</a></li>
<li><a href="../216701/index.html">One! = The only one? Registry of banned sites</a></li>
<li><a href="../216711/index.html">Techniques for character development in games: Part 1 - Tarot</a></li>
<li><a href="../216713/index.html">Long Polling for Android</a></li>
<li><a href="../216719/index.html">As a single prosecution, Microsoft destroyed the trust of customers in the integrity of their data in the "cloud" services</a></li>
<li><a href="../216723/index.html">Mozilla changes the design of Firefox: try Firefox 29 beta</a></li>
<li><a href="../216725/index.html">Abstract Data Type Concept</a></li>
<li><a href="../216729/index.html">Machine learning in a simple project</a></li>
<li><a href="../216733/index.html">Dynamic trees</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>