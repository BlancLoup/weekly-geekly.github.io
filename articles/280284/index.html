<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Teigha for Architecture: First project</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the articles AutoCAD Architecture: First project and Introduction to ACA, I briefly talked about what AutoCAD Architecture (ACA) is, how it differs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Teigha for Architecture: First project</h1><div class="post__text post__text-html js-mediator-article">  In the articles <a href="https://habrahabr.ru/post/265617/">AutoCAD Architecture: First project</a> and <a href="https://habrahabr.ru/post/271571/">Introduction to ACA,</a> I briefly talked about what AutoCAD Architecture (ACA) is, how it differs from the usual AutoCAD, what objects it implements and showed the simplest case of working with walls from .NET plug-in. <br><br>  In this article I will talk about the Teigha library - an alternative for working with dwg files and ACA objects.  We will write a small example that creates a house from ACA objects and saves it to the dwg file.  Then, we will try to open this file in AutoCAD Architecture and check whether these files are compatible with the original AutoCAD. <br><br><img src="https://habrastorage.org/files/570/815/d84/570815d8469d4a41957c21cdee48381d.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h1>  Alternative to AutoCAD and ObjectARX </h1><br>  To work with dwg and acad-objects, besides Avtokad and ObjectARX itself, there is another library: Teigha from the Open Design Alliance.  If you want to work with the dwg format and AutoCAD objects programmatically, then the choice is, in fact, only between ObjectARX and Teigha.  All third-party components and applications that can read and write dwg files are based on Teigha. <br>  Teigha is a set of libraries that allows you to read, write, and manipulate objects of both regular AutoCAD and its ACA-type derivatives.  This library also implements many auxiliary mechanisms for working with Avtokad objects and rendering devices for rendering the dwg base. <br>  Below is the official information from the Open Design Alliance about the features of the library: <br><blockquote><ul><li>  Supported DWG, DXF, and BDXF file formats: <br><ul><li>  Read support for files of version 2.5 through 2014. </li><li>  Write support for files of version 12 through 2014. </li></ul></li><li>  Supported DGN file formats: <br><ul><li>  Read support for V7 and V8 DGN (including V8 XM and V8I). </li><li>  Write support for V8 DGN. </li><li>  Convert from V7 to V8. </li></ul></li><li>  Render drawing files using GDI, OpenGL, or DirectX with select entities. </li><li>  Recover and repair damaged .dwg files. </li><li>  Edit and manipulate CAD data programmatically, including: <br><ul><li>  Explode an entity into a set of simpler entities. </li><li>  Apply a transformation to an entity. </li><li>  Modify arbitrary properties of database objects. </li><li>  Clone a database object. </li><li>  Many more. </li></ul></li><li>  Export to SVG, PDF, DWF, BMP, STL, DAE (Collda). </li><li>  Import DWF / DAE / DGN files into a .dwg database. </li><li>  Support custom objects - you can create custom objects that are usable within any Teigha host application (compatible with .dwg files only). </li><li>  Support external files such as font files (TTF / SHX), linetype files (LIN / RSC), and hatch pattern files (PAT). </li><li>  Recompute dimension geometry from dimension settings. </li><li>  Support transactions and undo / redo capabilities for .dwg file data. </li><li>  If you‚Äôre on the go? </li><li>  Control memory allocation / deallocation. </li><li>  Support .dwg file ‚Äúround-trip‚Äù data.  For example, when you saved a 2007 datasheet </li><li>  Support ACIS / parasolid data internally, including rendering (for wireframe and shaded) </li><li>  Implement custom commands. </li><li>  Sample source code applications </li><li>  Integrate with third-party components. </li></ul><br></blockquote><br><br>  In general, "the library supports a lot of things."  To begin with, we will try to load and draw some dwg drawing using a standard sample from the Teigha package: <br><img src="https://habrastorage.org/files/a29/2e7/546/a292e7546ae64870b521b9a535f3af65.jpg"><br><br>  Ok, the dwg file was read and drawn.  However, like the dwg file that I used for the title image for the article. <br>  This standard sample is a windowed C ++ application and allows you to download, view and edit dwg files without AutoCAD.  Another important feature: the Avtokad and Teigha APIs are almost identical, so you can easily rewrite the existing ObjectARX plugin to work with an application based on Teigha. <br>  Most Avtokad analogs, such as BricsCAD, ZWCad, IntelliCAD, use Teigha for working with the dwg format and acad-objects. <br><br><h1>  Features of AutoCAD Architecture Objects </h1><br>  We now turn to the architectural objects and work with them.  To do this, briefly recall the main points: <br>  AutoCAD Architecture operates with special high-level objects designed for architectural design: walls, doors, windows, roofs and other structural parts.  Viewport-dependent objects, i.e.  they can render themselves differently depending on the direction of the camera.  Objects are assigned a style.  If you change the style, then all objects of this style will change.  Objects consist of components, each of which has its own visual settings: color, line type, material, scale (for example, a 3D door consists of a frame, a canvas, glass).  For different display options, the object draws different geometry, so the number and settings of the components are different for different representations. <br><br><h1>  Teigha for Architecture (TA) Library </h1><br>  To work with architectural objects, besides ACA itself and its open API for creating plug-ins, you can use the Teigha for Architecture library from the Open Design Alliance. <br>  TA is a C ++ class library in which all the basic ACA primitives are implemented, such as walls, windows, doors, roofs, beams, openings, and so on.  The library allows you to read these objects from dwg formats of all versions, write (convert) to the latest version of dwg;  The library renders all primitives for various representations and configurations.  Since  aca objects interact with each other, TA also implements auxiliary ACA classes and mechanisms ‚Äî these are anchor, display manager, property sets, relation graph, and other binding. <br><br><h1>  Getting started with the TA API </h1><br>  In my opinion, there are more than enough common words.  Now let's see what Teigha is physically like and try to write the first simple command.  I will use the old VS 2005, but the libraries are multiplatform and the solution generator is included for studios up to 2015. Depending on the type of license, you may have access to either the full code of the entire library, or the built binaries and header files. <br><br>  The set of TA libraries would be something like this: <br><img src="https://habrastorage.org/files/412/0a5/2f2/4120a52f29804457b8fe1b0f765bd95a.jpg"><br><br>  In fact, this is the usual Windows dll (you can knock and for other platforms: ios, linux, unix, etc.).  Lib files go to them in a separate folder.  In addition to the TA, Teigha Core libraries will be needed, as TA is an extension over Core-objects.  Core implements the basic mechanisms and objects of an ordinary auto-cascade. <br><br><h1>  TA initialization </h1><br>  To initialize the library, we need a class that performs platform-specific file operations. <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyServices</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ExSystemServices, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ExHostAppServices { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: ODRX_USING_HEAP_OPERATORS(ExSystemServices); };</code> </pre> <br>  The kit already has ready-made extensions for Windows: ExSystemServices and ExHostAppServices;  In this case, they will be enough for us. <br>  Next, we initialize the library and graphics subsystem. <br><pre> <code class="cpp hljs">OdStaticRxObject&lt;MyServices&gt; svcs; odInitialize( &amp;svcs ); odgsInitialize();</code> </pre><br>  OdStaticRxObject adds addRef \ Release logic to the object;  The library stores a link to the MyServices object and uses it for platform-specific operations. <br><br>  Initializing TA libraries: <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Loading of all public Teigha Architecture DRX modules. // Note that not all calls are necessary for some of them depend on others // but here we list all of them. // // If a program uses TD doesn't modify or create binary files // it may not load any of DRX modules on start because they will be loaded automatically. // But if a program modifies or creates binary files then it is highly recommended // to load all DRX modules program uses. ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecArchBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecArchDACHBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecScheduleData") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecSchedule") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecStructureBase") );</span></span></code> </pre><br>  AecBase, AecArchBase and all the rest are tx modules (ie dll of the library) from the picture above.  They are already linked using lib files, but this is not enough.  It is necessary to initialize them as modules.  What does it mean?  At runtime, there is a dictionary of loaded classes in memory.  This dictionary is used for the mechanism of castes of pointers between different types of TA objects and for creating instances of TA classes themselves through a centralized pseudo-constructors mechanism. <br>  For example, when executing the command :: odrxDynamicLinker () -&gt; loadApp (OD_T ("AecArchBase")), the AECArchBase :: initApp () function will be called inside the framework.  Schematically, initApp () will register classes in the global dictionary that are implemented in this library by calling the rxInit () static function for each: <br><pre> <code class="cpp hljs">‚Ä¶ AECDbSpaceBoundary::rxInit(); AECDbStair::rxInit(); AECDbWall::rxInit(); AECDbZone::rxInit(); ‚Ä¶</code> </pre><br>  After that, the mechanism for creating objects will work and you can, for example, create a wall by calling AECDbWallPtr pWall = AECDbWall :: CreateAECObject ().  Otherwise, an attempt to create a TA class object will throw an exception. <br><br>  Create an empty dwg database by calling <br><pre> <code class="cpp hljs">OdDbDatabasePtr pDatabase = svcs.createDatabase();</code> </pre><br>  This is a central object, it is an object database, which is stored and loaded from the dwg file.  In it we will add all created architectural objects.  Upon completion, we will save this database in a dwg file by calling <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">OdWrFileBuf </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( strFilename )</span></span></span></span>; pDatabase-&gt;writeFile( &amp;cBuffer, OdDb::kDwg, OdDb::kDHL_CURRENT );</code> </pre><br>  Next, we initialize the loaded libraries and display manager a little more. <br><pre> <code class="cpp hljs">AECArchDACHBaseDatabase( pDatabase ).Init(); AECScheduleDatabase( pDatabase ).Init(); AECStructureBaseDatabase( pDatabase ).Init(); init_display_system( pDatabase );</code> </pre><br>  The database creates an AEC dictionary with default settings for units for length, area, volume, angles, print settings and display representations implemented in these modules are registered.  I will write a separate post about the display manager, display representations and related mechanisms. <br><br>  This completes the initialization.  If you skip some steps, the result may be different: either you will not create objects, or they will not be drawn (you will see a blank screen), or get some other glitches, depending on what step you missed. <br><br>  At the moment, the full code here looks like this: <br><div class="spoiler">  <b class="spoiler_title">Program code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyServices</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ExSystemServices, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ExHostAppServices { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: ODRX_USING_HEAP_OPERATORS(ExSystemServices); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wmain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">wchar_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Initialize TD with system services. // And create single instance of hostapp services // for TD database creation. OdStaticRxObject&lt;MyServices&gt; svcs; odInitialize( &amp;svcs ); odgsInitialize(); // Loading of all public Teigha Architecture DRX modules. // Note that not all calls are necessary for some of them depend on others // but here we list all of them. // // If a program uses TD doesn't modify or create binary files // it may not load any of DRX modules on start because they will be loaded automatically. // But if a program modifies or creates binary files then it is highly recommended // to load all DRX modules program uses. ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecArchBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecArchDACHBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecScheduleData") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecSchedule") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecStructureBase") ); // Create empty TD database. OdDbDatabasePtr pDatabase = svcs.createDatabase();; // Initialize database with default Teigha Architecture content. AECArchDACHBaseDatabase( pDatabase ).Init(); AECScheduleDatabase( pDatabase ).Init(); AECStructureBaseDatabase( pDatabase ).Init(); init_display_system( pDatabase ); // do something here with TA objects // Perform "zoom extents" on model space. { OdDbViewportTablePtr pVT = pDatabase-&gt;getViewportTableId().openObject( OdDb::kForRead ); OdDbViewportTableRecordPtr pV = pVT-&gt;getActiveViewportId().openObject( OdDb::kForWrite ); pV-&gt;zoomExtents(); } OdWrFileBuf cBuffer( "H:\\TA_test.dwg" ); pDatabase-&gt;writeFile( &amp;cBuffer, OdDb::kDwg, OdDb::kDHL_CURRENT ); odgsUninitialize(); odUninitialize(); return 0; }</span></span></code> </pre><br></div></div><br>  I added the zoom extents command so that when opening the created file we immediately saw the objects that added the symmetric deinitialization of the library.  For simplicity, I removed the error checking and try \ catch constructs around the main actions. <br>  Now the program will create an empty dwg file that can be opened and viewed by AutoCAD. <br><br><h1>  Work with objects </h1><br>  <b>Adding walls to the drawing</b> <br>  To demonstrate the work with TA-classes, I want to create a house consisting of a ceiling-foundation, walls, windows, doors and roofs.  Let's start with the walls. <br>  First of all, let's add a wall to our drawing.  To create the wall itself, you must first create a style for it.  Let's write the add_wall_style function: <br><div class="spoiler">  <b class="spoiler_title">Code add_wall_style</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">OdDbObjectId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_wall_style</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OdDbDatabasePtr pDatabase )</span></span></span><span class="hljs-function"> </span></span>{ OdDbObjectId idResult = AECDbWallStyle::CreateAECObject( pDatabase, OD_T(<span class="hljs-string"><span class="hljs-string">"Wall Style Created By Teigha(R) Architecture"</span></span>) ); AECDbWallStylePtr pWallStyle = idResult.openObject( OdDb::kForWrite ); pWallStyle-&gt;SetDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"Wall Style Description"</span></span>) ); pWallStyle-&gt;SetDictRecordDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"Dialog caption"</span></span>) ); pWallStyle-&gt;SetWallWidth( <span class="hljs-number"><span class="hljs-number">4</span></span> ); pWallStyle-&gt;SetWallWidthUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetBaseHeight( <span class="hljs-number"><span class="hljs-number">110</span></span> ); pWallStyle-&gt;SetBaseHeightUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetJustification( AECDefs::ewjLeft ); pWallStyle-&gt;SetJustificationUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetAutomaticCleanups( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetAutomaticCleanupsUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetCleanupRadius( <span class="hljs-number"><span class="hljs-number">4</span></span> ); pWallStyle-&gt;SetCleanupRadiusUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetFloorLineOffset( <span class="hljs-number"><span class="hljs-number">3</span></span> ); pWallStyle-&gt;SetFloorLineOffsetUsed( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); pWallStyle-&gt;SetRoofLineOffset( <span class="hljs-number"><span class="hljs-number">-3</span></span> ); pWallStyle-&gt;SetRoofLineOffsetUsed( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); <span class="hljs-function"><span class="hljs-function">AECDisplayManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cDM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pDatabase )</span></span></span></span>; AECDbDispPropsWallModelPtr pOverrideModel = AECDbDispPropsWallModel::cast( pWallStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWallModel::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverrideModel.isNull() ) { pOverrideModel-&gt;SetIsDisplayOpeningEndcaps( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); pOverrideModel-&gt;GetBoundaryCompByIndex( <span class="hljs-number"><span class="hljs-number">0</span></span> )-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">4</span></span> ) ); } AECDbDispPropsWallPtr pOverridePlan = AECDbDispPropsWall::cast( pWallStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWallPlan::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverridePlan.isNull() ) { pOverridePlan-&gt;GetBoundaryCompByIndex( <span class="hljs-number"><span class="hljs-number">0</span></span> )-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">4</span></span> ) ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( pWallStyle-&gt;objectId() ); }</code> </pre><br></div></div><br>  This function creates an AECDbWallStyle ‚Äúwall style‚Äù object, sets some settings for it, and then accesses the display manager and changes colors for plan display representation (2d top view) and model display representation (3d view). <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AECDisplayManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cDM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pDatabase )</span></span></span></span>; AECDbDispPropsWallModelPtr pOverrideModel = AECDbDispPropsWallModel::cast( pWallStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWallModel::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverrideModel.isNull() ) { pOverrideModel-&gt;SetIsDisplayOpeningEndcaps( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); pOverrideModel-&gt;GetBoundaryCompByIndex( <span class="hljs-number"><span class="hljs-number">0</span></span> )-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">2</span></span> ) ); }</code> </pre><br>  In this case, we set the yellow color for the wall in 3D view.  It looks complicated, but there are reasons for this: this is how the display representations and display manager in ACA work.  It is flexible and has many possibilities, but its logic is not immediately obvious and needs some study. <br><br>  <b>OdDbObjectId - runtime link</b> <br>  OdDbObjectId is the class with which base objects link to each other at run time.  Inside, it stores a pointer to a real object in memory.  Using OdDbObjectId :: openObject () you can get a pointer to the object with which the ObjectId is associated.  The point is that while the object has not been accessed by this id, it may not be loaded into memory and the internal pointer OdDbObjectId may be NULL.  When we specifically addressed this id for reading or writing, then the framework will create an instance of a real object and fill its fields with data from the database, and the internal pointer OdDbObjectId will receive the address of the created object.  openObject () returns this pointer. <br>  Such a mechanism allows partial loading of a large database (dwg file).  In this case, OdDbObjectId will exist for each object, but only those objects that are explicitly addressed will be created in memory. <br>  If you want the object reference to be kept between runs, then you need to use OdDbHandle. <br><br>  For example, the add_wall_style function returned idWallStyle to us.  In this case, the style was just explicitly created by calling AECDbWallStyle :: CreateAECObject () and idWallStyle stores inside a pointer to a real object in memory.  To get write access to a style object, you need to perform an operation <br><pre> <code class="cpp hljs">AECDbWallStylePtr pWallStyle = idResult.openObject( OdDb::kForWrite );</code> </pre><br>  openObject () will return a real pointer to the object and it will be possible to use it. <br><br>  In the library, instead of the usual C ++ pointers, OdSmartPtr smartpoints are used <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> OdSmartPtr&lt;AECDbWallStyle&gt; AECDbWallStylePtr</code> </pre><br>  The destructor of such a smartpointer notifies the framework about closing the object, which may cause recalculation of related objects, sending alerts, etc. <br><br>  Now add a wall call: <br><pre> <code class="cpp hljs">OdDbObjectId idWall1 = add_wall( pDatabase, idWallStyle, OdGePoint2d( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ), OdGePoint2d( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span> ) );</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Add_wall code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">OdDbObjectId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_wall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OdDbDatabasePtr pDatabase, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OdDbObjectId&amp; idStyle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OdGePoint2d&amp; ptStart, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OdGePoint2d&amp; ptEnd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dBulge = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ AECDbWallPtr pWall = AECDbWall::CreateAECObject( pDatabase-&gt;getModelSpaceId(), idStyle ); pWall-&gt;Set( ptStart, ptEnd, dBulge ); pWall-&gt;SetDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"A Wall"</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( pWall-&gt;objectId() ); }</code> </pre><br></div></div><br>  As you can see, add_wall does nothing special.  It creates an AECDbWall object with a style that we created a bit earlier.  The AECDbWall object is added to the model space of the database ‚Äî a special dictionary that stores all the objects that are drawn when rendering the database (this is a simplification). <br>  Next, the starting point, end point, and curvature are set on the wall.  Those.  the wall can be not only straight, but also convex. <br><br>  If everything is done correctly, then we will have a dwg file with one yellow rectangular wall.  In this case, I view the file with a sample from the Teigha delivery, but it will be drawn exactly the same in ACA. <br><img src="https://habrastorage.org/files/3ce/5b8/cf1/3ce5b8cf115442d7900f19079e649fb1.jpg"><br>  True, I manually turned the camera into a 3D view.  By default you will have a top view. <br><br>  Now, let's try to add as many as 4 walls, with one convex: <br><pre> <code class="cpp hljs">OdDbObjectId idWall1 = add_wall( pDatabase, idWallStyle, OdGePoint2d( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ), OdGePoint2d( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span> ) ); OdDbObjectId idWall2 = add_wall( pDatabase, idWallStyle, OdGePoint2d( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span> ), OdGePoint2d( <span class="hljs-number"><span class="hljs-number">110</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span> ) ); OdDbObjectId idWall3 = add_wall( pDatabase, idWallStyle, OdGePoint2d( <span class="hljs-number"><span class="hljs-number">110</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span> ), OdGePoint2d( <span class="hljs-number"><span class="hljs-number">110</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ) ); OdDbObjectId idWall4 = add_wall( pDatabase, idWallStyle, OdGePoint2d( <span class="hljs-number"><span class="hljs-number">110</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ), OdGePoint2d( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ), <span class="hljs-number"><span class="hljs-number">-1</span></span> );</code> </pre><br><br>  Received some rudiment of the future house: <br><img src="https://habrastorage.org/files/a64/600/616/a64600616b584babade23fc6b3950c35.jpg"><br>  As you can see, the walls were not simply drawn by separate objects, but between them a smooth transition was built automatically at the points of contact with each other.  This is one of the automatic features of TA, called cleanup walls. <br><br><div class="spoiler">  <b class="spoiler_title">Full code for now</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">OdDbObjectId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_wall_style</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OdDbDatabasePtr pDatabase )</span></span></span><span class="hljs-function"> </span></span>{ OdDbObjectId idResult = AECDbWallStyle::CreateAECObject( pDatabase, OD_T(<span class="hljs-string"><span class="hljs-string">"Wall Style Created By Teigha(R) Architecture"</span></span>) ); AECDbWallStylePtr pWallStyle = idResult.openObject( OdDb::kForWrite ); pWallStyle-&gt;SetDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"Wall Style Description"</span></span>) ); pWallStyle-&gt;SetDictRecordDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"Dialog caption"</span></span>) ); pWallStyle-&gt;SetWallWidth( <span class="hljs-number"><span class="hljs-number">4</span></span> ); pWallStyle-&gt;SetWallWidthUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetBaseHeight( <span class="hljs-number"><span class="hljs-number">110</span></span> ); pWallStyle-&gt;SetBaseHeightUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetJustification( AECDefs::ewjLeft ); pWallStyle-&gt;SetJustificationUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetAutomaticCleanups( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetAutomaticCleanupsUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetCleanupRadius( <span class="hljs-number"><span class="hljs-number">4</span></span> ); pWallStyle-&gt;SetCleanupRadiusUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetFloorLineOffset( <span class="hljs-number"><span class="hljs-number">3</span></span> ); pWallStyle-&gt;SetFloorLineOffsetUsed( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); pWallStyle-&gt;SetRoofLineOffset( <span class="hljs-number"><span class="hljs-number">-3</span></span> ); pWallStyle-&gt;SetRoofLineOffsetUsed( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); <span class="hljs-function"><span class="hljs-function">AECDisplayManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cDM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pDatabase )</span></span></span></span>; AECDbDispPropsWallModelPtr pOverrideModel = AECDbDispPropsWallModel::cast( pWallStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWallModel::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverrideModel.isNull() ) { pOverrideModel-&gt;SetIsDisplayOpeningEndcaps( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); pOverrideModel-&gt;GetBoundaryCompByIndex( <span class="hljs-number"><span class="hljs-number">0</span></span> )-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">4</span></span> ) ); } AECDbDispPropsWallPtr pOverridePlan = AECDbDispPropsWall::cast( pWallStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWallPlan::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverridePlan.isNull() ) { pOverridePlan-&gt;GetBoundaryCompByIndex( <span class="hljs-number"><span class="hljs-number">0</span></span> )-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">4</span></span> ) ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( pWallStyle-&gt;objectId() ); } <span class="hljs-function"><span class="hljs-function">OdDbObjectId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_wall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OdDbDatabasePtr pDatabase, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OdDbObjectId&amp; idStyle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OdGePoint2d&amp; ptStart, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OdGePoint2d&amp; ptEnd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dBulge = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ AECDbWallPtr pWall = AECDbWall::CreateAECObject( pDatabase-&gt;getModelSpaceId(), idStyle ); pWall-&gt;Set( ptStart, ptEnd, dBulge ); pWall-&gt;SetDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"A Wall"</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( pWall-&gt;objectId() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wmain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">wchar_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Initialize TD with system services. // And create single instance of hostapp services // for TD database creation. OdStaticRxObject&lt;MyServices&gt; svcs; odInitialize( &amp;svcs ); odgsInitialize(); // Loading of all public Teigha Architecture DRX modules. // Note that not all calls are necessary for some of them depend on others // but here we list all of them. // // If a program uses TD doesn't modify or create binary files // it may not load any of DRX modules on start because they will be loaded automatically. // But if a program modifies or creates binary files then it is highly recommended // to load all DRX modules program uses. ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecArchBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecArchDACHBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecScheduleData") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecSchedule") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecStructureBase") ); // Create empty TD database. OdDbDatabasePtr pDatabase = svcs.createDatabase();; // Initialize database with default Teigha Architecture content. AECArchDACHBaseDatabase( pDatabase ).Init(); AECScheduleDatabase( pDatabase ).Init(); AECStructureBaseDatabase( pDatabase ).Init(); init_display_system( pDatabase ); OdDbObjectId idWallStyle = add_wall_style( pDatabase ); OdDbObjectId idWall1 = add_wall( pDatabase, idWallStyle, OdGePoint2d( 0, 0 ), OdGePoint2d( 0, 110 ) ); OdDbObjectId idWall2 = add_wall( pDatabase, idWallStyle, OdGePoint2d( 0, 110 ), OdGePoint2d( 110, 110 ) ); OdDbObjectId idWall3 = add_wall( pDatabase, idWallStyle, OdGePoint2d( 110, 110 ), OdGePoint2d( 110, 0 ) ); OdDbObjectId idWall4 = add_wall( pDatabase, idWallStyle, OdGePoint2d( 110, 0 ), OdGePoint2d( 0, 0 ), -1 ); // Perform "zoom extents" on model space. { OdDbViewportTablePtr pVT = pDatabase-&gt;getViewportTableId().openObject( OdDb::kForRead ); OdDbViewportTableRecordPtr pV = pVT-&gt;getActiveViewportId().openObject( OdDb::kForWrite ); pV-&gt;zoomExtents(); } OdWrFileBuf cBuffer( "H:\\TA_test.dwg" ); pDatabase-&gt;writeFile( &amp;cBuffer, OdDb::kDwg, OdDb::kDHL_CURRENT ); odgsUninitialize(); odUninitialize(); return 0; }</span></span></code> </pre><br></div></div><br><br>  <b>Add windows to drawing</b> <br>  Now add to our house window.  With windows, the logic is similar to the doors: you need to create a style of windows that we want to add to the drawing, and then add window objects of this style. <br><pre> <code class="cpp hljs">OdDbObjectId idWindowStyle = add_window_style( pDatabase );</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Add_window_style code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">OdDbObjectId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_window_style</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OdDbDatabasePtr pDatabase )</span></span></span><span class="hljs-function"> </span></span>{ OdDbObjectId idWStyle = AECDbWindowStyle::CreateAECObject( pDatabase, OD_T(<span class="hljs-string"><span class="hljs-string">"Window Style Created By Teigha(R) Architecture"</span></span>) ); AECDbWindowStylePtr pWindowStyle = idWStyle.openObject( OdDb::kForWrite ); pWindowStyle-&gt;SetDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"Window Style Description"</span></span>) ); pWindowStyle-&gt;SetDictRecordDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"Dialog caption"</span></span>) ); pWindowStyle-&gt;SetAutoAdjustToWidthOfWall( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWindowStyle-&gt;SetFrameWidth( <span class="hljs-number"><span class="hljs-number">2</span></span> ); pWindowStyle-&gt;SetFrameDepth( <span class="hljs-number"><span class="hljs-number">5</span></span> ); pWindowStyle-&gt;SetSashWidth( <span class="hljs-number"><span class="hljs-number">2</span></span> ); pWindowStyle-&gt;SetSashDepth( <span class="hljs-number"><span class="hljs-number">3</span></span> ); pWindowStyle-&gt;SetGlassThickness( <span class="hljs-number"><span class="hljs-number">1</span></span> ); pWindowStyle-&gt;SetWindowType( AECDefs::ewtGlider ); pWindowStyle-&gt;SetWindowShape( AECDefs::esRectangular ); <span class="hljs-function"><span class="hljs-function">AECDisplayManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cDM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pDatabase )</span></span></span></span>; AECDbDispPropsWindowPtr pOverrideModel = AECDbDispPropsWindow::cast( pWindowStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWindowModel::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverrideModel.isNull() ) { pOverrideModel-&gt;GetFrameComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); pOverrideModel-&gt;GetSashComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">2</span></span> ) ); pOverrideModel-&gt;GetGlassComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">3</span></span> ) ); } AECDbDispPropsWindowPtr pOverridePlan = AECDbDispPropsWindow::cast( pWindowStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWindowPlan::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverridePlan.isNull() ) { pOverridePlan-&gt;GetFrameComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); pOverridePlan-&gt;GetSashComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">2</span></span> ) ); pOverridePlan-&gt;GetGlassComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">3</span></span> ) ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( pWindowStyle-&gt;objectId() ); }</code> </pre><br></div></div><br>  As the code shows, an AECDbWindowStyle object is created and added to the database.  Further, the style is set to some of the settings (although you can use the default), and then override the colors of several components for 2D and 3D representation.  The components in this case are the physical parts of the window: glass, frame, sash. <br><br>  Add a window to the first wall with the add_window function: <br><pre> <code class="cpp hljs">OdDbObjectId idWindow01 = add_window( pDatabase, idWindowStyle, idWall1, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> );</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Add_window function code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Inserts a window into a database using the specified window style. // If idWall parameter is not null it also attaches the window to the wall. // Returns Object ID of newly created window. OdDbObjectId add_window( OdDbDatabasePtr pDatabase, const OdDbObjectId&amp; idStyle, const OdDbObjectId&amp; idWall, double dOffsetAlongX, double dOffsetAlongZ ) { AECDbWindowPtr pWindow = AECDbWindow::CreateAECObject( pDatabase-&gt;getModelSpaceId(), idStyle ); pWindow-&gt;SetRise( 10 ); pWindow-&gt;SetWidth( 40 ); pWindow-&gt;SetHeight( 40 ); pWindow-&gt;SetOpenPercent( 60 ); pWindow-&gt;SetMeasureTo( AECDefs::eomtOutsideFrame ); pWindow-&gt;SetLeaf( 10 ); if ( !idWall.isNull() ) { pWindow-&gt;AttachWallAnchor( idWall ); AECDbAnchorEntToCurvePtr pAnchor = pWindow-&gt;GetAnchor().openObject( OdDb::kForWrite ); pAnchor-&gt;GetXParams()-&gt;SetOffset( dOffsetAlongX ); pAnchor-&gt;GetZParams()-&gt;SetOffset( dOffsetAlongZ ); } return( pWindow-&gt;objectId() ); }</span></span></code> </pre><br></div></div><br>  The add_window () function is similar to add_wall () with one difference: the anchor object is used here. <br>  We create the AECDbWindow object and place it in the model space of the base.  Then expose some settings to this particular instance of AECDbWindow. <br>  After that we insert the window into the wall.  A wall and a window are linked by a special object derived from AECDbAnchorEntToCurve.  It contains padding along the x, y, z axes from the beginning of the wall coordinate system to the beginning of the window coordinate system.  When you call AttachWallAnchor (), an instance of this object is created and placed in the database.  The wall itself does not directly know whether windows are inserted into it or not.  Creating an anchor affects another basic mechanism - the relation graph.  Relation graph contains relationships between objects - who is attached to whom, who belongs to whom, who owns whom.  When the wall is modified, the relation graph will receive a message stating that the AECDbWall object has changed, will pass through all dependencies and will cause the associated objects to be updated (in this case AECDbWindow).  So, if we pushed the wall, the windows will move with it, because they will receive a notification from the relation graph.  You can access this column and query dependencies for a particular object.  The window, in principle, knows to whom it is attached, it stores the link to the created anchor. <br><br>  Look what happened: <br><img src="https://habrastorage.org/files/1f6/141/31c/1f614131caea4259bde964ee6e0fdd2d.jpg"><br><br>  I specifically changed the color of the walls so that the window was better visible.  In the code, your walls should be blue at once, I just selected colors as I wrote the article. <br>  In TA there are a lot of predefined styles and window types, which are specified through enumerations: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> WindowType { ewtPicture = <span class="hljs-number"><span class="hljs-number">1</span></span>, ewtSingleHung = <span class="hljs-number"><span class="hljs-number">2</span></span>, ewtDoubleHung = <span class="hljs-number"><span class="hljs-number">3</span></span>, ewtAwningTransom = <span class="hljs-number"><span class="hljs-number">4</span></span>, ewtDoubleCasement = <span class="hljs-number"><span class="hljs-number">5</span></span>, ewtGlider = <span class="hljs-number"><span class="hljs-number">6</span></span>, ewtHopperTransom = <span class="hljs-number"><span class="hljs-number">7</span></span>, ewtPassThrough = <span class="hljs-number"><span class="hljs-number">8</span></span>, ewtSingleCasement = <span class="hljs-number"><span class="hljs-number">9</span></span>, ewtSingleHopper = <span class="hljs-number"><span class="hljs-number">10</span></span>, ewtSingleAwning = <span class="hljs-number"><span class="hljs-number">11</span></span>, ewtVerticalPivot = <span class="hljs-number"><span class="hljs-number">12</span></span>, ewtHorizontalPivot = <span class="hljs-number"><span class="hljs-number">13</span></span>, ewtUnevenSingleHung = <span class="hljs-number"><span class="hljs-number">14</span></span>, ewtUnevenDoubleHung = <span class="hljs-number"><span class="hljs-number">15</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Shape { esRectangular = <span class="hljs-number"><span class="hljs-number">0</span></span>, esRound = <span class="hljs-number"><span class="hljs-number">1</span></span>, esHalfRound = <span class="hljs-number"><span class="hljs-number">2</span></span>, esQuarterRound = <span class="hljs-number"><span class="hljs-number">3</span></span>, esOval = <span class="hljs-number"><span class="hljs-number">4</span></span>, esArch = <span class="hljs-number"><span class="hljs-number">5</span></span>, esTrapezoid = <span class="hljs-number"><span class="hljs-number">6</span></span>, esGothic = <span class="hljs-number"><span class="hljs-number">7</span></span>, esIsoscelesTriangle = <span class="hljs-number"><span class="hljs-number">8</span></span>, esRightTriangle = <span class="hljs-number"><span class="hljs-number">9</span></span>, esPeakPentagon = <span class="hljs-number"><span class="hljs-number">10</span></span>, esOctagon = <span class="hljs-number"><span class="hljs-number">11</span></span>, esHexagon = <span class="hljs-number"><span class="hljs-number">12</span></span>, esCustom = <span class="hljs-number"><span class="hljs-number">13</span></span> };</code> </pre><br>  We chose AECDefs :: ewtGlider and AECDefs :: esRectangular, but as you can see, there are many variations of the forms.  Using other settings you can create a very complex type of window with an internal pattern on the glass and many doors.  And it‚Äôs not necessary to draw all this manually or implement it programmatically, you just need to set a few settings for an existing object or style. <br>  In general, all TA objects are complex and have a lot of settings.  This gives quite ample opportunities right out of the box. <br><br>  Add windows to all straight walls: <br><pre> <code class="cpp hljs">OdDbObjectId idWindow01 = add_window( pDatabase, idWindowStyle, idWall1, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> ); OdDbObjectId idWindow02 = add_window( pDatabase, idWindowStyle, idWall1, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> ); OdDbObjectId idWindow03 = add_window( pDatabase, idWindowStyle, idWall1, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span> ); OdDbObjectId idWindow04 = add_window( pDatabase, idWindowStyle, idWall1, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span> ); OdDbObjectId idWindow05 = add_window( pDatabase, idWindowStyle, idWall2, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> ); OdDbObjectId idWindow06 = add_window( pDatabase, idWindowStyle, idWall2, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> ); OdDbObjectId idWindow07 = add_window( pDatabase, idWindowStyle, idWall2, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span> ); OdDbObjectId idWindow08 = add_window( pDatabase, idWindowStyle, idWall2, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span> ); OdDbObjectId idWindow09 = add_window( pDatabase, idWindowStyle, idWall3, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> ); OdDbObjectId idWindow10 = add_window( pDatabase, idWindowStyle, idWall3, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> ); OdDbObjectId idWindow11 = add_window( pDatabase, idWindowStyle, idWall3, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span> ); OdDbObjectId idWindow12 = add_window( pDatabase, idWindowStyle, idWall3, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span> );</code> </pre><br><br><img src="https://habrastorage.org/files/b30/ff5/ddc/b30ff5ddc2744a43bda2f3129244b432.jpg"><br>  I did not begin to write the code, but each window can be managed separately: change the percentage of its opening, colors, and so on.  And if you change their style, then this change will affect all of them at once. <br><br>  <b>Adding doors to a drawing</b> <br>  To complete the picture, add the door.  For the door we will create a 2D profile for the canvas (a sash with a hole-window), then create a style with this profile, and then we will be able to create door objects of this style.  But you can use default styles.  Doors, like windows (and all other openings) are attached to the walls with an anchor. <br><div class="spoiler">  <b class="spoiler_title">Code add_profile_def, add_door_style, add_door</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Inserts profile definition into a database. // Returns Object ID of newly created profile definition. OdDbObjectId add_profile_def( OdDbDatabasePtr pDatabase ) { OdDbObjectId idProfDef = AECDbProfileDef::CreateAECObject( pDatabase, OD_T("Profile Definition Created By Teigha(R) Architecture") ); AECDbProfileDefPtr pProfileDefinition = idProfDef.openObject( OdDb::kForWrite ); AECGe::Profile2D cProfile; cProfile.resize( 2 ); cProfile[ 0 ].appendVertex( OdGePoint2d( 0, 0 ) ); cProfile[ 0 ].appendVertex( OdGePoint2d( 1, 0 ) ); cProfile[ 0 ].appendVertex( OdGePoint2d( 1, 1 ) ); cProfile[ 0 ].appendVertex( OdGePoint2d( 0, 1 ) ); cProfile[ 0 ].setClosed(); // Forces the contour to be counter-clockwise. // So if the contour is already ccw this call is not needed. cProfile[ 0 ].makeCCW(); cProfile[ 1 ].appendVertex( OdGePoint2d( 0.2, 0.2 ) ); cProfile[ 1 ].appendVertex( OdGePoint2d( 0.2, 0.8 ) ); cProfile[ 1 ].appendVertex( OdGePoint2d( 0.8, 0.8 ) ); cProfile[ 1 ].appendVertex( OdGePoint2d( 0.8, 0.2 ) ); cProfile[ 1 ].setClosed(); cProfile[ 1 ].makeCCW( false ); pProfileDefinition-&gt;GetProfile()-&gt;Init( cProfile ); return( pProfileDefinition-&gt;objectId() ); } // Inserts a door style into a database. // Returns Object ID of newly created door style. OdDbObjectId add_door_style( OdDbDatabasePtr pDatabase, const OdDbObjectId&amp; idProfile ) { OdDbObjectId idDoorStyle = AECDbDoorStyle::CreateAECObject( pDatabase, OD_T("Door Style Created By Teigha(R) Architecture") ); AECDbDoorStylePtr pDoorStyle = idDoorStyle.openObject( OdDb::kForWrite ); pDoorStyle-&gt;SetDescription( OD_T("Door Style Description") ); pDoorStyle-&gt;SetDictRecordDescription( OD_T("Dialog caption") ); pDoorStyle-&gt;SetAutoAdjustToWidthOfWall( true ); pDoorStyle-&gt;SetFrameWidth( 2 ); pDoorStyle-&gt;SetFrameDepth( 5 ); pDoorStyle-&gt;SetStopWidth( 2 ); pDoorStyle-&gt;SetStopDepth( 3 ); pDoorStyle-&gt;SetShapeAndType( AECDefs::esCustom, AECDefs::edtSingle ); pDoorStyle-&gt;SetProfile( idProfile ); pDoorStyle-&gt;SetGlassThickness( 1 ); AECDisplayManager cDM( pDatabase ); AECDbDispPropsDoorPtr pOverrideModel = AECDbDispPropsDoor::cast( pDoorStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepDoorModel::desc() ) ).openObject( OdDb::kForWrite ) ); if ( !pOverrideModel.isNull() ) { pOverrideModel-&gt;GetPanelComp()-&gt;SetColor( colorAt( 1 ) ); pOverrideModel-&gt;GetFrameComp()-&gt;SetColor( colorAt( 2 ) ); pOverrideModel-&gt;GetStopComp()-&gt;SetColor( colorAt( 3 ) ); pOverrideModel-&gt;GetSwingComp()-&gt;SetColor( colorAt( 4 ) ); pOverrideModel-&gt;GetGlassComp()-&gt;SetColor( colorAt( 5 ) ); } AECDbDispPropsDoorPtr pOverridePlan = AECDbDispPropsDoor::cast( pDoorStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepDoorPlan::desc() ) ).openObject( OdDb::kForWrite ) ); if ( !pOverridePlan.isNull() ) { pOverridePlan-&gt;GetPanelComp()-&gt;SetColor( colorAt( 1 ) ); pOverridePlan-&gt;GetFrameComp()-&gt;SetColor( colorAt( 2 ) ); pOverridePlan-&gt;GetStopComp()-&gt;SetColor( colorAt( 3 ) ); pOverridePlan-&gt;GetSwingComp()-&gt;SetColor( colorAt( 4 ) ); pOverridePlan-&gt;GetDirectionComp()-&gt;SetColor( colorAt( 5 ) ); } return( pDoorStyle-&gt;objectId() ); } // Inserts a door into a database using the specified door style. // If idWall parameter is not null it also attaches the door to the wall. // Returns Object ID of newly created door. OdDbObjectId add_door( OdDbDatabasePtr pDatabase, const OdDbObjectId&amp; idStyle, const OdDbObjectId&amp; idWall, double dOffsetAlongX, double dOffsetAlongZ ) { AECDbDoorPtr pDoor = AECDbDoor::CreateAECObject( pDatabase-&gt;getModelSpaceId(), idStyle ); pDoor-&gt;SetRise( 10 ); pDoor-&gt;SetWidth( 40 ); pDoor-&gt;SetHeight( 50 ); pDoor-&gt;SetOpenPercent( 20 ); pDoor-&gt;SetMeasureTo( AECDefs::eomtOutsideFrame ); pDoor-&gt;SetLeaf( 10 ); if ( !idWall.isNull() ) { pDoor-&gt;AttachWallAnchor( idWall ); AECDbAnchorEntToCurvePtr pAnchor = pDoor-&gt;GetAnchor().openObject( OdDb::kForWrite ); pAnchor-&gt;GetXParams()-&gt;SetOffset( dOffsetAlongX ); pAnchor-&gt;GetZParams()-&gt;SetOffset( dOffsetAlongZ ); } return( pDoor-&gt;objectId() ); }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And we add in main: </font></font><br><pre> <code class="cpp hljs">AECDbWallPtr pWall = idWall4.openObject( OdDb::kForRead ); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dLength = pWall-&gt;GetLength(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dOWidth = <span class="hljs-number"><span class="hljs-number">40</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dL1 = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dL3 = dLength - dOWidth - <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dL2 = dL1 + dOWidth + (dL3 - (dL1 + <span class="hljs-number"><span class="hljs-number">2</span></span> * dOWidth)) / <span class="hljs-number"><span class="hljs-number">2</span></span>; OdDbObjectId idDoor = add_door ( pDatabase, idDoorStyle, idWall4, dL2, <span class="hljs-number"><span class="hljs-number">0</span></span> );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is one new moment here: we open the wall for reading and take its length to calculate the indent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we have a door inserted into a round wall: </font></font><br><img src="https://habrastorage.org/files/422/15b/2a8/42215b2a82ce4c7a9f67c69104fb582b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insert another window into a round wall:</font></font><br><pre> <code class="cpp hljs">OdDbObjectId idWindow13 = add_window ( pDatabase, idWindowStyle, idWall4, dL1, <span class="hljs-number"><span class="hljs-number">10</span></span> ); OdDbObjectId idWindow14 = add_window ( pDatabase, idWindowStyle, idWall4, dL3, <span class="hljs-number"><span class="hljs-number">10</span></span> ); OdDbObjectId idWindow15 = add_window ( pDatabase, idWindowStyle, idWall4, dL1, <span class="hljs-number"><span class="hljs-number">60</span></span> ); OdDbObjectId idWindow16 = add_window ( pDatabase, idWindowStyle, idWall4, dL2, <span class="hljs-number"><span class="hljs-number">60</span></span> ); OdDbObjectId idOpening = add_window ( pDatabase, idWindowStyle, idWall4, dL3, <span class="hljs-number"><span class="hljs-number">60</span></span> );</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we got a very leaky house without a roof and floor: </font></font><br><img src="https://habrastorage.org/files/cf0/7ec/061/cf07ec061e4d424baa7236a26b9e8671.jpg"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adding a roof to a drawing</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's write the function add_roof ()</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roof function code</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_roof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OdDbDatabasePtr pDatabase )</span></span></span><span class="hljs-function"> </span></span>{ AECGe::Profile2D cProfile; cProfile.resize( <span class="hljs-number"><span class="hljs-number">1</span></span> ); cProfile.front().appendVertex( OdGePoint2d( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ) ); cProfile.front().appendVertex( OdGePoint2d( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span> ) ); cProfile.front().appendVertex( OdGePoint2d( <span class="hljs-number"><span class="hljs-number">110</span></span>, <span class="hljs-number"><span class="hljs-number">110</span></span> ) ); cProfile.front().appendVertex( OdGePoint2d( <span class="hljs-number"><span class="hljs-number">110</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> ), <span class="hljs-number"><span class="hljs-number">-1</span></span> ); cProfile.front().setClosed(); cProfile.front().makeCCW(); AECDbRoofPtr pRoof = AECDbRoof::CreateAECObject( pDatabase-&gt;getModelSpaceId() ); <span class="hljs-comment"><span class="hljs-comment">// Initialize roof profile. // By default all edges of Roof Profile have single slope of 45 degrees. pRoof-&gt;GetProfile()-&gt;Init( cProfile ); pRoof-&gt;SetThickness( 2 ); //// Manually modify Roof Segments. AECGeRingSubPtr pRoofLoop = pRoof-&gt;GetProfile()-&gt;GetRingByIndex( 0 ); if ( !pRoofLoop.isNull() ) { OdUInt32 i, iSize = pRoofLoop-&gt;GetSegmentCount(); for ( i = 0; i &lt; iSize; i++ ) { AECGeRoofSegmentSubPtr pSeg = pRoofLoop-&gt;GetSegments()-&gt;GetAt( i ); pSeg-&gt;SetFaceCount(1); pSeg-&gt;SetFaceHeightByIndex(0, 110); pSeg-&gt;SetBaseHeight(0); pSeg-&gt;SetOverhang(10.0); pSeg-&gt;SetFaceSlopeByIndex(0, OdaPI4); pSeg-&gt;SetSegmentCount(10); } } pRoof-&gt;setColorIndex( 3 ); }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The roof is created on the basis of a two-dimensional profile, the direction of the bypass of which is counterclockwise. A call to makeCCW () just converts the direction of the traversal, if it was the opposite. This is important, because the algorithm waits for the input of just such a profile and will not work otherwise. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our profile coincides with the central line of the walls. Further, for each section of the profile, the slope of the roof slope is set, the number of faces to which the ramp will be presented, the rise of the ramp beginning in Z relative to the OXY plane (SetFaceHeightByIndex), and the overhang of the roof (overhang). SetSegmentCount () works only for segments that have a curvature. This value determines the accuracy of the approximation - how many straight line segments will be used to approximate the semicircular segment. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turned out this roof:</font></font><br><img src="https://habrastorage.org/files/ce9/ebb/b71/ce9ebbb71b01416880ec69380792579e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are a lot of variations of roof settings and you can create a roof of almost any shape - gable, multi-skid, tent, and so on. </font><font style="vertical-align: inherit;">Each ramp is a separate RoofSlab object that can be edited manually. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adding overlap to the drawing It</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> remains to add at least a small imitation of the floor / foundation. </font><font style="vertical-align: inherit;">To do this, use the slab object (overlap). </font><font style="vertical-align: inherit;">Let's write the add_slab function</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Function code add_slab</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_slab</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OdDbDatabasePtr pDatabase )</span></span></span><span class="hljs-function"> </span></span>{ OdDbObjectId idStyle = AECDbSlabStyle::GetAECObject( pDatabase, OD_T(<span class="hljs-string"><span class="hljs-string">"Slab Style"</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( idStyle.isNull() ) { idStyle = AECDbSlabStyle::CreateAECObject( pDatabase, OD_T(<span class="hljs-string"><span class="hljs-string">"Slab Style"</span></span>) ); } AECDbSlabStylePtr pStyle = idStyle.openObject( OdDb::kForWrite ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pStyle.isNull() ) { pStyle-&gt;GetComponents()-&gt;Clear(); AECSlabStyleCompPtr pCmp = AECSlabStyleComp::createObject(); pCmp-&gt;SetName( OD_T(<span class="hljs-string"><span class="hljs-string">"Base"</span></span>) ); pCmp-&gt;GetPosition()-&gt;GetThickness()-&gt;SetUseBaseValue( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); pCmp-&gt;GetPosition()-&gt;GetThickness()-&gt;SetBaseValue( <span class="hljs-number"><span class="hljs-number">6</span></span> ); pCmp-&gt;GetPosition()-&gt;GetThicknessOffset()-&gt;SetUseBaseValue( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); pCmp-&gt;GetPosition()-&gt;GetThicknessOffset()-&gt;SetBaseValue( - <span class="hljs-number"><span class="hljs-number">6</span></span> ); pStyle-&gt;GetComponents()-&gt;Insert( pCmp ); } AECDbSlabPtr pSlab = AECDbSlab::CreateAECObject( pDatabase-&gt;getModelSpaceId(), idStyle ); { AECGe::Profile2D cBase; cBase.resize( <span class="hljs-number"><span class="hljs-number">1</span></span> ); cBase.front().appendVertex( OdGePoint2d( <span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">-5</span></span> ), <span class="hljs-number"><span class="hljs-number">1</span></span> ); cBase.front().appendVertex( OdGePoint2d( <span class="hljs-number"><span class="hljs-number">115</span></span>, <span class="hljs-number"><span class="hljs-number">-5</span></span> ) ); cBase.front().appendVertex( OdGePoint2d( <span class="hljs-number"><span class="hljs-number">115</span></span>, <span class="hljs-number"><span class="hljs-number">115</span></span> ) ); cBase.front().appendVertex( OdGePoint2d( <span class="hljs-number"><span class="hljs-number">-5</span></span>, <span class="hljs-number"><span class="hljs-number">115</span></span> ) ); cBase.front().setClosed(); cBase.front().makeCCW(); pSlab-&gt;GetSlabFace()-&gt;Init( cBase ); } pSlab-&gt;SetThickness( <span class="hljs-number"><span class="hljs-number">5</span></span> ); pSlab-&gt;SetVerticalOffset( <span class="hljs-number"><span class="hljs-number">0</span></span> ); pSlab-&gt;SetHorizontalOffset( <span class="hljs-number"><span class="hljs-number">0</span></span> ); pSlab-&gt;SetPivotPoint( OdGePoint3d::kOrigin ); <span class="hljs-function"><span class="hljs-function">AECDisplayManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cDM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pDatabase )</span></span></span></span>; AECDbDispPropsSlabPtr pOverrideModel = AECDbDispPropsSlab::cast( pSlab-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepSlabModel::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverrideModel.isNull() ) { pOverrideModel-&gt;GetBoundaryCompByIndex( <span class="hljs-number"><span class="hljs-number">0</span></span> )-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); pOverrideModel-&gt;GetBaselineComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">4</span></span> ) ); pOverrideModel-&gt;GetPivotPointComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">5</span></span> ) ); pOverrideModel-&gt;GetFasciaComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">6</span></span> ) ); pOverrideModel-&gt;GetSoffitComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">7</span></span> ) ); pOverrideModel-&gt;GetShrinkWrapBodyComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">8</span></span> ) ); } AECDbDispPropsSlabPlanPtr pOverridePlan = AECDbDispPropsSlabPlan::cast( pSlab-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepSlabPlan::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverridePlan.isNull() ) { pOverridePlan-&gt;SetIsOverrideCutPlane( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); pOverridePlan-&gt;GetHatchComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); pOverridePlan-&gt;GetBelowCutPlaneBodyComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">2</span></span> ) ); pOverridePlan-&gt;GetAboveCutPlaneBodyComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">3</span></span> ) ); pOverridePlan-&gt;GetBelowCutPlaneOutlineComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">4</span></span> ) ); pOverridePlan-&gt;GetAboveCutPlaneOutlineComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">5</span></span> ) ); } }</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, we create a new style of overlap and add components to it. A component is a piece of overlap and contains such parameters as thickness, rise above OXY, name, material, index, etc. The overlap can contain several components that differ in their settings. For example, if they have a different indent from OXY, then one object-overlapping of such a style can draw all the floors and ceilings in a high-rise building. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The style settings apply to a specific object that stores the shape of a given overlap. In this case, we create a slab, and initialize its profile with the same outline as the bottom of the walls, with only a small indentation around the edges. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next comes the work with the display manager to override the colors of the different overlapping components. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the final, our house will look like this:</font></font><br><img src="https://habrastorage.org/files/17d/a8a/b08/17da8ab0855d49138f6e043f877c4703.jpg"><br><br>  ,    dwg   Autodesk ACA: <br><img src="https://habrastorage.org/files/c83/5b6/b82/c835b6b82e3f49a8b888a7a117f5c766.jpg"><br>   ,   Autocad Architecture.   . <br><br><div class="spoiler">  <b class="spoiler_title">Full code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">OdDbObjectId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_wall_style</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OdDbDatabasePtr pDatabase )</span></span></span><span class="hljs-function"> </span></span>{ OdDbObjectId idResult = AECDbWallStyle::CreateAECObject( pDatabase, OD_T(<span class="hljs-string"><span class="hljs-string">"Wall Style Created By Teigha(R) Architecture"</span></span>) ); AECDbWallStylePtr pWallStyle = idResult.openObject( OdDb::kForWrite ); pWallStyle-&gt;SetDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"Wall Style Description"</span></span>) ); pWallStyle-&gt;SetDictRecordDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"Dialog caption"</span></span>) ); pWallStyle-&gt;SetWallWidth( <span class="hljs-number"><span class="hljs-number">4</span></span> ); pWallStyle-&gt;SetWallWidthUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetBaseHeight( <span class="hljs-number"><span class="hljs-number">110</span></span> ); pWallStyle-&gt;SetBaseHeightUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetJustification( AECDefs::ewjLeft ); pWallStyle-&gt;SetJustificationUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetAutomaticCleanups( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetAutomaticCleanupsUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetCleanupRadius( <span class="hljs-number"><span class="hljs-number">4</span></span> ); pWallStyle-&gt;SetCleanupRadiusUsed( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWallStyle-&gt;SetFloorLineOffset( <span class="hljs-number"><span class="hljs-number">3</span></span> ); pWallStyle-&gt;SetFloorLineOffsetUsed( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); pWallStyle-&gt;SetRoofLineOffset( <span class="hljs-number"><span class="hljs-number">-3</span></span> ); pWallStyle-&gt;SetRoofLineOffsetUsed( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); <span class="hljs-function"><span class="hljs-function">AECDisplayManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cDM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pDatabase )</span></span></span></span>; AECDbDispPropsWallModelPtr pOverrideModel = AECDbDispPropsWallModel::cast( pWallStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWallModel::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverrideModel.isNull() ) { pOverrideModel-&gt;SetIsDisplayOpeningEndcaps( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); pOverrideModel-&gt;GetBoundaryCompByIndex( <span class="hljs-number"><span class="hljs-number">0</span></span> )-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">4</span></span> ) ); } AECDbDispPropsWallPtr pOverridePlan = AECDbDispPropsWall::cast( pWallStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWallPlan::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverridePlan.isNull() ) { pOverridePlan-&gt;GetBoundaryCompByIndex( <span class="hljs-number"><span class="hljs-number">0</span></span> )-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">4</span></span> ) ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( pWallStyle-&gt;objectId() ); } <span class="hljs-function"><span class="hljs-function">OdDbObjectId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_wall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OdDbDatabasePtr pDatabase, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OdDbObjectId&amp; idStyle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OdGePoint2d&amp; ptStart, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OdGePoint2d&amp; ptEnd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dBulge = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ AECDbWallPtr pWall = AECDbWall::CreateAECObject( pDatabase-&gt;getModelSpaceId(), idStyle ); pWall-&gt;Set( ptStart, ptEnd, dBulge ); pWall-&gt;SetDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"A Wall"</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">/*AECGe::Contour2D cContour; cContour.appendVertex( OdGePoint2d( 0, pWall-&gt;GetHeight() ) ); cContour.appendVertex( OdGePoint2d( pWall-&gt;GetLength() / 2, pWall-&gt;GetHeight() * 1.5 ) ); cContour.appendVertex( OdGePoint2d( pWall-&gt;GetLength(), pWall-&gt;GetHeight() ) ); AECWallCutLineSubPtr pTop = pWall-&gt;CreateTopCutLine(); pTop-&gt;SetRawCutLine( cContour );*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( pWall-&gt;objectId() ); } <span class="hljs-function"><span class="hljs-function">OdDbObjectId </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_window_style</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OdDbDatabasePtr pDatabase )</span></span></span><span class="hljs-function"> </span></span>{ OdDbObjectId idWStyle = AECDbWindowStyle::CreateAECObject( pDatabase, OD_T(<span class="hljs-string"><span class="hljs-string">"Window Style Created By Teigha(R) Architecture"</span></span>) ); AECDbWindowStylePtr pWindowStyle = idWStyle.openObject( OdDb::kForWrite ); pWindowStyle-&gt;SetDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"Window Style Description"</span></span>) ); pWindowStyle-&gt;SetDictRecordDescription( OD_T(<span class="hljs-string"><span class="hljs-string">"Dialog caption"</span></span>) ); pWindowStyle-&gt;SetAutoAdjustToWidthOfWall( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); pWindowStyle-&gt;SetFrameWidth( <span class="hljs-number"><span class="hljs-number">2</span></span> ); pWindowStyle-&gt;SetFrameDepth( <span class="hljs-number"><span class="hljs-number">5</span></span> ); pWindowStyle-&gt;SetSashWidth( <span class="hljs-number"><span class="hljs-number">2</span></span> ); pWindowStyle-&gt;SetSashDepth( <span class="hljs-number"><span class="hljs-number">3</span></span> ); pWindowStyle-&gt;SetGlassThickness( <span class="hljs-number"><span class="hljs-number">1</span></span> ); pWindowStyle-&gt;SetWindowType( AECDefs::ewtGlider ); pWindowStyle-&gt;SetWindowShape( AECDefs::esRectangular ); <span class="hljs-function"><span class="hljs-function">AECDisplayManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cDM</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( pDatabase )</span></span></span></span>; AECDbDispPropsWindowPtr pOverrideModel = AECDbDispPropsWindow::cast( pWindowStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWindowModel::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverrideModel.isNull() ) { pOverrideModel-&gt;GetFrameComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); pOverrideModel-&gt;GetSashComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">2</span></span> ) ); pOverrideModel-&gt;GetGlassComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">3</span></span> ) ); } AECDbDispPropsWindowPtr pOverridePlan = AECDbDispPropsWindow::cast( pWindowStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepWindowPlan::desc() ) ).openObject( OdDb::kForWrite ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !pOverridePlan.isNull() ) { pOverridePlan-&gt;GetFrameComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); pOverridePlan-&gt;GetSashComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">2</span></span> ) ); pOverridePlan-&gt;GetGlassComp()-&gt;SetColor( colorAt( <span class="hljs-number"><span class="hljs-number">3</span></span> ) ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( pWindowStyle-&gt;objectId() ); } <span class="hljs-comment"><span class="hljs-comment">// Inserts a window into a database using the specified window style. // If idWall parameter is not null it also attaches the window to the wall. // Returns Object ID of newly created window. OdDbObjectId add_window( OdDbDatabasePtr pDatabase, const OdDbObjectId&amp; idStyle, const OdDbObjectId&amp; idWall, double dOffsetAlongX, double dOffsetAlongZ ) { AECDbWindowPtr pWindow = AECDbWindow::CreateAECObject( pDatabase-&gt;getModelSpaceId(), idStyle ); pWindow-&gt;SetRise( 10 ); pWindow-&gt;SetWidth( 40 ); pWindow-&gt;SetHeight( 40 ); pWindow-&gt;SetOpenPercent( 60 ); pWindow-&gt;SetMeasureTo( AECDefs::eomtOutsideFrame ); pWindow-&gt;SetLeaf( 10 ); if ( !idWall.isNull() ) { pWindow-&gt;AttachWallAnchor( idWall ); AECDbAnchorEntToCurvePtr pAnchor = pWindow-&gt;GetAnchor().openObject( OdDb::kForWrite ); pAnchor-&gt;GetXParams()-&gt;SetOffset( dOffsetAlongX ); pAnchor-&gt;GetZParams()-&gt;SetOffset( dOffsetAlongZ ); } return( pWindow-&gt;objectId() ); } // Inserts profile definition into a database. // Returns Object ID of newly created profile definition. OdDbObjectId add_profile_def( OdDbDatabasePtr pDatabase ) { OdDbObjectId idProfDef = AECDbProfileDef::CreateAECObject( pDatabase, OD_T("Profile Definition Created By Teigha(R) Architecture") ); AECDbProfileDefPtr pProfileDefinition = idProfDef.openObject( OdDb::kForWrite ); AECGe::Profile2D cProfile; cProfile.resize( 2 ); cProfile[ 0 ].appendVertex( OdGePoint2d( 0, 0 ) ); cProfile[ 0 ].appendVertex( OdGePoint2d( 1, 0 ) ); cProfile[ 0 ].appendVertex( OdGePoint2d( 1, 1 ) ); cProfile[ 0 ].appendVertex( OdGePoint2d( 0, 1 ) ); cProfile[ 0 ].setClosed(); // Forces the contour to be counter-clockwise. // So if the contour is already ccw this call is not needed. cProfile[ 0 ].makeCCW(); cProfile[ 1 ].appendVertex( OdGePoint2d( 0.2, 0.2 ) ); cProfile[ 1 ].appendVertex( OdGePoint2d( 0.2, 0.8 ) ); cProfile[ 1 ].appendVertex( OdGePoint2d( 0.8, 0.8 ) ); cProfile[ 1 ].appendVertex( OdGePoint2d( 0.8, 0.2 ) ); cProfile[ 1 ].setClosed(); cProfile[ 1 ].makeCCW( false ); pProfileDefinition-&gt;GetProfile()-&gt;Init( cProfile ); return( pProfileDefinition-&gt;objectId() ); } // Inserts a door style into a database. // Returns Object ID of newly created door style. OdDbObjectId add_door_style( OdDbDatabasePtr pDatabase, const OdDbObjectId&amp; idProfile ) { OdDbObjectId idDoorStyle = AECDbDoorStyle::CreateAECObject( pDatabase, OD_T("Door Style Created By Teigha(R) Architecture") ); AECDbDoorStylePtr pDoorStyle = idDoorStyle.openObject( OdDb::kForWrite ); pDoorStyle-&gt;SetDescription( OD_T("Door Style Description") ); pDoorStyle-&gt;SetDictRecordDescription( OD_T("Dialog caption") ); pDoorStyle-&gt;SetAutoAdjustToWidthOfWall( true ); pDoorStyle-&gt;SetFrameWidth( 2 ); pDoorStyle-&gt;SetFrameDepth( 5 ); pDoorStyle-&gt;SetStopWidth( 2 ); pDoorStyle-&gt;SetStopDepth( 3 ); pDoorStyle-&gt;SetShapeAndType( AECDefs::esCustom, AECDefs::edtSingle ); pDoorStyle-&gt;SetProfile( idProfile ); pDoorStyle-&gt;SetGlassThickness( 1 ); AECDisplayManager cDM( pDatabase ); AECDbDispPropsDoorPtr pOverrideModel = AECDbDispPropsDoor::cast( pDoorStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepDoorModel::desc() ) ).openObject( OdDb::kForWrite ) ); if ( !pOverrideModel.isNull() ) { pOverrideModel-&gt;GetPanelComp()-&gt;SetColor( colorAt( 1 ) ); pOverrideModel-&gt;GetFrameComp()-&gt;SetColor( colorAt( 2 ) ); pOverrideModel-&gt;GetStopComp()-&gt;SetColor( colorAt( 3 ) ); pOverrideModel-&gt;GetSwingComp()-&gt;SetColor( colorAt( 4 ) ); pOverrideModel-&gt;GetGlassComp()-&gt;SetColor( colorAt( 5 ) ); } AECDbDispPropsDoorPtr pOverridePlan = AECDbDispPropsDoor::cast( pDoorStyle-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepDoorPlan::desc() ) ).openObject( OdDb::kForWrite ) ); if ( !pOverridePlan.isNull() ) { pOverridePlan-&gt;GetPanelComp()-&gt;SetColor( colorAt( 1 ) ); pOverridePlan-&gt;GetFrameComp()-&gt;SetColor( colorAt( 2 ) ); pOverridePlan-&gt;GetStopComp()-&gt;SetColor( colorAt( 3 ) ); pOverridePlan-&gt;GetSwingComp()-&gt;SetColor( colorAt( 4 ) ); pOverridePlan-&gt;GetDirectionComp()-&gt;SetColor( colorAt( 5 ) ); } return( pDoorStyle-&gt;objectId() ); } // Inserts a door into a database using the specified door style. // If idWall parameter is not null it also attaches the door to the wall. // Returns Object ID of newly created door. OdDbObjectId add_door( OdDbDatabasePtr pDatabase, const OdDbObjectId&amp; idStyle, const OdDbObjectId&amp; idWall, double dOffsetAlongX, double dOffsetAlongZ ) { AECDbDoorPtr pDoor = AECDbDoor::CreateAECObject( pDatabase-&gt;getModelSpaceId(), idStyle ); pDoor-&gt;SetRise( 10 ); pDoor-&gt;SetWidth( 40 ); pDoor-&gt;SetHeight( 50 ); pDoor-&gt;SetOpenPercent( 20 ); pDoor-&gt;SetMeasureTo( AECDefs::eomtOutsideFrame ); pDoor-&gt;SetLeaf( 10 ); if ( !idWall.isNull() ) { pDoor-&gt;AttachWallAnchor( idWall ); AECDbAnchorEntToCurvePtr pAnchor = pDoor-&gt;GetAnchor().openObject( OdDb::kForWrite ); pAnchor-&gt;GetXParams()-&gt;SetOffset( dOffsetAlongX ); pAnchor-&gt;GetZParams()-&gt;SetOffset( dOffsetAlongZ ); } return( pDoor-&gt;objectId() ); } void add_roof( OdDbDatabasePtr pDatabase ) { AECGe::Profile2D cProfile; cProfile.resize( 1 ); cProfile.front().appendVertex( OdGePoint2d( 0, 0 ) ); cProfile.front().appendVertex( OdGePoint2d( 0, 110 ) ); cProfile.front().appendVertex( OdGePoint2d( 110, 110 ) ); cProfile.front().appendVertex( OdGePoint2d( 110, 0 ), -1 ); cProfile.front().setClosed(); cProfile.front().makeCCW(); AECDbRoofPtr pRoof = AECDbRoof::CreateAECObject( pDatabase-&gt;getModelSpaceId() ); // Initialize roof profile. // By default all edges of Roof Profile have single slope of 45 degrees. pRoof-&gt;GetProfile()-&gt;Init( cProfile ); pRoof-&gt;SetThickness( 2 ); //// Manually modify Roof Segments. AECGeRingSubPtr pRoofLoop = pRoof-&gt;GetProfile()-&gt;GetRingByIndex( 0 ); if ( !pRoofLoop.isNull() ) { OdUInt32 i, iSize = pRoofLoop-&gt;GetSegmentCount(); for ( i = 0; i &lt; iSize; i++ ) { AECGeRoofSegmentSubPtr pSeg = pRoofLoop-&gt;GetSegments()-&gt;GetAt( i ); pSeg-&gt;SetFaceCount(1); pSeg-&gt;SetFaceHeightByIndex(0, 110); pSeg-&gt;SetBaseHeight(0); pSeg-&gt;SetOverhang(10.0); pSeg-&gt;SetFaceSlopeByIndex(0, OdaPI4); pSeg-&gt;SetSegmentCount(10); } } pRoof-&gt;setColorIndex( 3 ); } void add_slab( OdDbDatabasePtr pDatabase ) { OdDbObjectId idStyle = AECDbSlabStyle::GetAECObject( pDatabase, OD_T("Slab Style") ); if ( idStyle.isNull() ) { idStyle = AECDbSlabStyle::CreateAECObject( pDatabase, OD_T("Slab Style") ); } AECDbSlabStylePtr pStyle = idStyle.openObject( OdDb::kForWrite ); if ( !pStyle.isNull() ) { pStyle-&gt;GetComponents()-&gt;Clear(); AECSlabStyleCompPtr pCmp = AECSlabStyleComp::createObject(); pCmp-&gt;SetName( OD_T("Base") ); pCmp-&gt;GetPosition()-&gt;GetThickness()-&gt;SetUseBaseValue( false ); pCmp-&gt;GetPosition()-&gt;GetThickness()-&gt;SetBaseValue( 6 ); pCmp-&gt;GetPosition()-&gt;GetThicknessOffset()-&gt;SetUseBaseValue( false ); pCmp-&gt;GetPosition()-&gt;GetThicknessOffset()-&gt;SetBaseValue( - 6 ); pStyle-&gt;GetComponents()-&gt;Insert( pCmp ); } AECDbSlabPtr pSlab = AECDbSlab::CreateAECObject( pDatabase-&gt;getModelSpaceId(), idStyle ); { AECGe::Profile2D cBase; cBase.resize( 1 ); cBase.front().appendVertex( OdGePoint2d( -5, -5 ), 1 ); cBase.front().appendVertex( OdGePoint2d( 115, -5 ) ); cBase.front().appendVertex( OdGePoint2d( 115, 115 ) ); cBase.front().appendVertex( OdGePoint2d( -5, 115 ) ); cBase.front().setClosed(); cBase.front().makeCCW(); pSlab-&gt;GetSlabFace()-&gt;Init( cBase ); } pSlab-&gt;SetThickness( 5 ); pSlab-&gt;SetVerticalOffset( 0 ); pSlab-&gt;SetHorizontalOffset( 0 ); pSlab-&gt;SetPivotPoint( OdGePoint3d::kOrigin ); AECDisplayManager cDM( pDatabase ); AECDbDispPropsSlabPtr pOverrideModel = AECDbDispPropsSlab::cast( pSlab-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepSlabModel::desc() ) ).openObject( OdDb::kForWrite ) ); if ( !pOverrideModel.isNull() ) { pOverrideModel-&gt;GetBoundaryCompByIndex( 0 )-&gt;SetColor( colorAt( 1 ) ); pOverrideModel-&gt;GetBaselineComp()-&gt;SetColor( colorAt( 4 ) ); pOverrideModel-&gt;GetPivotPointComp()-&gt;SetColor( colorAt( 5 ) ); pOverrideModel-&gt;GetFasciaComp()-&gt;SetColor( colorAt( 6 ) ); pOverrideModel-&gt;GetSoffitComp()-&gt;SetColor( colorAt( 7 ) ); pOverrideModel-&gt;GetShrinkWrapBodyComp()-&gt;SetColor( colorAt( 8 ) ); } AECDbDispPropsSlabPlanPtr pOverridePlan = AECDbDispPropsSlabPlan::cast( pSlab-&gt;OverrideDispProps( cDM.UpdateDisplayRepresentation( AECDbDispRepSlabPlan::desc() ) ).openObject( OdDb::kForWrite ) ); if ( !pOverridePlan.isNull() ) { pOverridePlan-&gt;SetIsOverrideCutPlane( false ); pOverridePlan-&gt;GetHatchComp()-&gt;SetColor( colorAt( 1 ) ); pOverridePlan-&gt;GetBelowCutPlaneBodyComp()-&gt;SetColor( colorAt( 2 ) ); pOverridePlan-&gt;GetAboveCutPlaneBodyComp()-&gt;SetColor( colorAt( 3 ) ); pOverridePlan-&gt;GetBelowCutPlaneOutlineComp()-&gt;SetColor( colorAt( 4 ) ); pOverridePlan-&gt;GetAboveCutPlaneOutlineComp()-&gt;SetColor( colorAt( 5 ) ); } } class MyServices : public ExSystemServices, public ExHostAppServices { protected: ODRX_USING_HEAP_OPERATORS(ExSystemServices); }; int wmain(int argc, wchar_t* argv[]) { // Initialize TD with system services. // And create single instance of hostapp services // for TD database creation. OdStaticRxObject&lt;MyServices&gt; svcs; odInitialize( &amp;svcs ); odgsInitialize(); // Loading of all public Teigha Architecture DRX modules. // Note that not all calls are necessary for some of them depend on others // but here we list all of them. // // If a program uses TD doesn't modify or create binary files // it may not load any of DRX modules on start because they will be loaded automatically. // But if a program modifies or creates binary files then it is highly recommended // to load all DRX modules program uses. ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecArchBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecArchDACHBase") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecScheduleData") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecSchedule") ); ::odrxDynamicLinker()-&gt;loadApp( OD_T("AecStructureBase") ); // Create empty TD database. OdDbDatabasePtr pDatabase = svcs.createDatabase();; // Initialize database with default Teigha Architecture content. AECArchDACHBaseDatabase( pDatabase ).Init(); AECScheduleDatabase( pDatabase ).Init(); AECStructureBaseDatabase( pDatabase ).Init(); init_display_system( pDatabase ); OdDbObjectId idWallStyle = add_wall_style( pDatabase ); OdDbObjectId idWall1 = add_wall( pDatabase, idWallStyle, OdGePoint2d( 0, 0 ), OdGePoint2d( 0, 110 ) ); OdDbObjectId idWall2 = add_wall( pDatabase, idWallStyle, OdGePoint2d( 0, 110 ), OdGePoint2d( 110, 110 ) ); OdDbObjectId idWall3 = add_wall( pDatabase, idWallStyle, OdGePoint2d( 110, 110 ), OdGePoint2d( 110, 0 ) ); OdDbObjectId idWall4 = add_wall( pDatabase, idWallStyle, OdGePoint2d( 110, 0 ), OdGePoint2d( 0, 0 ), -1 ); AECDbWallPtr ptWall = AECDbWall::cast( idWall1.openObject( OdDb::kForRead ) ); OdDbObjectId idWindowStyle = add_window_style( pDatabase ); OdDbObjectId idWindow01 = add_window( pDatabase, idWindowStyle, idWall1, 10, 10 ); OdDbObjectId idWindow02 = add_window( pDatabase, idWindowStyle, idWall1, 60, 10 ); OdDbObjectId idWindow03 = add_window( pDatabase, idWindowStyle, idWall1, 10, 60 ); OdDbObjectId idWindow04 = add_window( pDatabase, idWindowStyle, idWall1, 60, 60 ); OdDbObjectId idWindow05 = add_window( pDatabase, idWindowStyle, idWall2, 10, 10 ); OdDbObjectId idWindow06 = add_window( pDatabase, idWindowStyle, idWall2, 60, 10 ); OdDbObjectId idWindow07 = add_window( pDatabase, idWindowStyle, idWall2, 10, 60 ); OdDbObjectId idWindow08 = add_window( pDatabase, idWindowStyle, idWall2, 60, 60 ); OdDbObjectId idWindow09 = add_window( pDatabase, idWindowStyle, idWall3, 10, 10 ); OdDbObjectId idWindow10 = add_window( pDatabase, idWindowStyle, idWall3, 60, 10 ); OdDbObjectId idWindow11 = add_window( pDatabase, idWindowStyle, idWall3, 10, 60 ); OdDbObjectId idWindow12 = add_window( pDatabase, idWindowStyle, idWall3, 60, 60 ); OdDbObjectId idProfile = add_profile_def( pDatabase ); OdDbObjectId idDoorStyle = add_door_style( pDatabase, idProfile ); AECDbWallPtr pWall = idWall4.openObject( OdDb::kForRead ); double dLength = pWall-&gt;GetLength(); double dOWidth = 40; double dL1 = 10; double dL3 = dLength - dOWidth - 10; double dL2 = dL1 + dOWidth + (dL3 - (dL1 + 2 * dOWidth)) / 2; OdDbObjectId idDoor = add_door ( pDatabase, idDoorStyle, idWall4, dL2, 0 ); OdDbObjectId idWindow13 = add_window ( pDatabase, idWindowStyle, idWall4, dL1, 10 ); OdDbObjectId idWindow14 = add_window ( pDatabase, idWindowStyle, idWall4, dL3, 10 ); OdDbObjectId idWindow15 = add_window ( pDatabase, idWindowStyle, idWall4, dL1, 60 ); OdDbObjectId idWindow16 = add_window ( pDatabase, idWindowStyle, idWall4, dL2, 60 ); OdDbObjectId idOpening = add_window ( pDatabase, idWindowStyle, idWall4, dL3, 60 ); add_roof(pDatabase); add_slab(pDatabase); // Perform "zoom extents" on model space. { OdDbViewportTablePtr pVT = pDatabase-&gt;getViewportTableId().openObject( OdDb::kForRead ); OdDbViewportTableRecordPtr pV = pVT-&gt;getActiveViewportId().openObject( OdDb::kForWrite ); pV-&gt;zoomExtents(); } OdWrFileBuf cBuffer( "H:\\TA_test.dwg" ); pDatabase-&gt;writeFile( &amp;cBuffer, OdDb::kDwg, OdDb::kDHL_CURRENT ); odgsUninitialize(); odUninitialize(); return 0; }</span></span></code> </pre><br></div></div><br><br><h1>  Total </h1><br>   Teigha    ,       ,             dwg   . <br> ,         ,     ‚Äì    TA      Teigha        dwg    . </div><p>Source: <a href="https://habr.com/ru/post/280284/">https://habr.com/ru/post/280284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280272/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ204 (March 21 - 27, 2016)</a></li>
<li><a href="../280274/index.html">Rust and Swift (introduction, first and second parts)</a></li>
<li><a href="../280276/index.html">Development Case on Golang: ITooLabs Virtual PBX Platform</a></li>
<li><a href="../280278/index.html">PHP Digest number 82 - interesting news, materials and tools (March 14 - 27, 2016)</a></li>
<li><a href="../280280/index.html">Once again, the benefits of traffic analyzers</a></li>
<li><a href="../280286/index.html">MSLibrary. Creating and compiling cross-platform (universal) libraries in Xcode</a></li>
<li><a href="../280292/index.html">Linux for beginners or what can a girl teach?</a></li>
<li><a href="../280294/index.html">Not IoT, but raspberry! We build the IoT-project on Raspberry Pi with Windows 10 and DeviceHive</a></li>
<li><a href="../280296/index.html">How to clean up the mailbox using a neural network. Part 2</a></li>
<li><a href="../280298/index.html">Pitfalls .load () and .get ()</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>