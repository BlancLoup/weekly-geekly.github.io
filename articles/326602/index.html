<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Terrible import kraken - how to use ES6-modules and not go crazy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The global scope (aka namespace in TypeScript) is no longer cool. It can take a long time to list the advantages of the modules (ES6 modules, in parti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Terrible import kraken - how to use ES6-modules and not go crazy</h1><div class="post__text post__text-html js-mediator-article"><p>  The global scope (aka namespace in TypeScript) is no longer cool.  It can take a long time to list the advantages of the modules (ES6 modules, in particular), but for me personally, the ability to use SystemJS for dynamically loading source files and Rollup to build a bundle became decisive for me. </p><br><p>  However, the first thing you had to face when introducing ES6 modules is an insane amount of import expressions, with an insane amount of points inside: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { FieldGroup } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../../Common/Components/FieldGroup/FieldGroup";</code> </pre> <br><img width="100%" src="https://habrastorage.org/files/bca/31f/bea/bca31fbeabf74293b907db2edb81cd6e.jpg"><a name="habracut"></a><br><br><h2>  Where do tentacles grow from? </h2><br><p>  The ES6 specification doesn‚Äôt really say anything about it, waving the phrase that the paths to the modules are "loader specific".  Well, that is, if you use SystemJS, then the format of the paths is determined by SystemJS, if Webpack, then Webpack.  Work on the bootloader specification is underway, but, as the <a href="https://github.com/whatwg/loader">main page of the watwg repository says</a> : </p><br><blockquote>  This spec is currently undergoing global redesigns (see # 147 and # 149) and is not ready for implementations. <br></blockquote><br><p>  The agreement between the loaders so far is only that the path starting with "./" means that you need to search in the same directory where the current module is located.  The double dots "../", respectively, allow you to go up a level and look in the parent directory.  At the same time, even in the simplest project it is very easy to get paths that contain 3-4 double points "../../../", which is terrible in every sense. </p><br><p>  Since there is no specification, now everyone solves the problem who can.  Usually, a root folder is configured for this purpose and all paths are relative to it.  For example, the babel community invented a <a href="https://github.com/entwicklerstube/babel-plugin-root-import">plugin for</a> itself, and the webpack supports the setting resolve.root. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BasicEvent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'~/Common/Utils/Events/BasicEvent'</span></span></code> </pre> <br><p>  However, even if you set up a root folder, it still does not save you from the huge header of import-expressions at the beginning of each file.  The rules of good form speak about breaking the code into as small modules as possible, which is the source of the problem (they will now say that it is better to decompose the code, but the real world is always not the same as we would like). </p><br><img src="https://habrastorage.org/files/5fe/7a8/3d4/5fe7a83d4f4346e8b85d967d74de5e16.png"><br><br><p>  What is especially sad is that every time you import a module, you create a hard link to the location of this module in the file system.  Therefore, 1) you, at a minimum, need to remember exactly where each module is located 2) if you want to do refactoring (for example, rename a file), then you will have a lot of pain. </p><br><p>  Well, the last pain you will face when using TypeScript in VisualStudio is that syntax highlighting does not work there, as well as JSX lintting for imported characters.  For example: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { FieldGroup } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../Components/FieldGroup/FieldGroup"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BasicEvent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../Common/Utils/Events/BasicEvent' ... var event = new BasicEvent(); // BasicEvent  VisualStudio     ... render() { // JSX  FieldGroup  VisualStudio   (   ), //  intellicese  , .. FieldGroup   return &lt;FieldGroup name="blabla" /&gt;; }</code> </pre> <br><p>  In Microsoft, it seems, they are not in a hurry to solve the problem ( <a href="https://github.com/Microsoft/TypeScript/issues/2890">issue 1</a> , <a href="https://github.com/Microsoft/TypeScript/issues/3025">issue 2</a> ). </p><br><h2>  Magic packages all save </h2><br><img src="https://habrastorage.org/files/84b/9ea/df3/84b9eadf3d344acfbe32fe8059788943.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  The solution to the problem is to abandon the idea of ‚Äã‚Äãindividual modules, randomly interconnected, and start using, hmm, something like ‚Äúmodule packages‚Äù.  I'm not sure if such a decision has already been published somewhere in this context (UPD: <a href="https://habrahabr.ru/users/gogolor/" class="user_link">gogolor</a> suggested that Angular is called a <a href="https://angular.io/docs/ts/latest/glossary.html">barrel</a> at the docks), but the idea itself is not new.  For example, in C # we also have separate files with code, but at the same time, these files are collected in "assemblies" (dll), which already explicitly declare references to other assemblies. </p><br><p>  Imagine that we have the following project structure (screenshot from the real project of some admin panel): </p><br><img src="https://habrastorage.org/files/f5a/373/2c7/f5a3732c700746e0b043ced0aff005da.png"><br><br><p>  In order for the file AssignmentTemplatSettings.tsx to reach BasicEvent.ts, you would have to write something like: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BasicEvent } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../Common/Utils/Events/BasicEvent'</span></span>;</code> </pre> <br><p>  This is terrible for all the reasons I described above.  However, if you look at the project structure, it is easy to see that all modules are naturally distributed into folders.  The more complex the project, the more extensive the folder structure becomes.  This desire for ordering lives in every developer, and most likely there is something similar in your project. </p><br><p>  The good news is that ES6 modules allow you to convert this folder structure into a "package" structure, very much like dll in the desktop world.  You can make each folder a package (for example, Common / Utils / Events will be nested packages), you can limit it to larger units (only Common / Utils).  For each package of modules, it will be clearly indicated which packages it depends on and what it ‚Äúputs out‚Äù.  All these dependencies will be collected at one point, so that the modules of the package will not know anything about the location of the modules of other packages.  In this case, the number of points ("../../") in relative paths will be no more than the nesting of folders inside one package, and the number of import-expressions will be reduced down to one. </p><br><h2>  Implementation </h2><br><img src="https://habrastorage.org/files/68d/4d1/44f/68d4d144f72f468f8692b771493cdad9.jpg"><br><br><p>  In order to convert a folder into a package, it is enough to add two files to it - imports and exports.  In the first file, we import and re-export everything that is necessary for the modules of this package.  In the second file is placed the export of all that the package makes available for import into other packages. </p><br><h3>  We realize export </h3><br><p>  Let's try to make a package from the Events folder.  Let him expose two classes - BasicEvent and SimpleEvent.  Then, the @ EventsExports.ts file will look like this: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./BasicEvent"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SimpleEvent"</span></span>;</code> </pre> <br><img src="https://habrastorage.org/files/312/665/651/312665651a04429da1e01b5a87ce633e.png"><br><br><p>  The dog "@" in the file name ensures that he is not lost among the other package files and will always be at the very top.  We don‚Äôt need anything from other packages here, so we don‚Äôt make the imports file here yet.  Next, convert the parent folder Utils and Common into packages.  For example, @ UtilsExports.ts will contain: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Events <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Events/@EventsExports"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ModalWindow <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./ModalWindow/@ModalWindowExports"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Other <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Other/@OtherExports"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> RequestManager <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./RequestManager/@RequestManagerExports"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ServiceUtils <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./ServiceUtils/@ServiceUtilsExports"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { Events, ModalWindow, RequestManager, ServiceUtils };</code> </pre> <br><img src="https://habrastorage.org/files/0c4/da4/9ea/0c4da49ea1b64669bb35c69ba0c7baa9.png"><br><br><p>  The CachingLoader and other modules that were directly in the Utils folder are not listed here.  This is a limitation of this approach; packages that export other packages cannot contain their modules.  Therefore, I had to move all these files to the child package Other.  The contents of the imports file will be reviewed later. </p><br><p>  Similarly, we do @ CommonExports.ts: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Components <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Components/@ComponentsExports"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Extensibility <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Extensibility/@ExtensibilityExports"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Models <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Models/@ModelsExports"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Services <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Services/@ServicesExports"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Utils <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./Utils/@UtilsExports"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> { Components, Extensibility, Models, Services, Utils };</code> </pre> <br><img src="https://habrastorage.org/files/d7e/4e1/ac1/d7e4e1ac163649139c41b03da1bf7784.png"><br><br><h3>  We realize import </h3><br><p>  We now turn to the Tabs package.  Obviously, he will need a lot of classes from the Common package.  Accordingly, its @ TabsImports.ts file will look like this: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">import</span></span> * as Common from <span class="hljs-string"><span class="hljs-string">"../Common/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@CommonExports</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-section"><span class="hljs-section">export</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">Common</span></span> };</code> </pre> <br><img src="https://habrastorage.org/files/1f9/475/780/1f9475780a5643ae99553be10d2c6c3c.png"><br><br><p>  Now in the package's AssignmentTemplatesSettings.tsx module, it suffices to write the following: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Common } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../@TabsImports"; // -  <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>       var Events = Common.Utils.Events; //   BasicEvent   Common/Utils/Events/BasicEvent.ts var basicEvent = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Events.BasicEvent();</code> </pre> <br><img src="https://habrastorage.org/files/f3f/0ba/1fa/f3f0ba1fa5d24435a2eba87b21fb451e.png"><br><br><p>  As you can see, instead of specifying the full path to the BasicEvent file, we simply indicate in which package it is located.  What is especially nice is that when writing Events.BasicEvent syntax highlighting and linting JSX in VisualStudio work great! </p><br><p>  If the Tabs package only needs the Events package, then you can rewrite TabsImports.ts as follows: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">import</span></span> * as Common from <span class="hljs-string"><span class="hljs-string">"../Common/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@CommonExports</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">var</span></span> Events = Common.Utils.Events; <span class="hljs-section"><span class="hljs-section">export</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">Events</span></span> };</code> </pre> <br><p>  Either way: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">import</span></span> * as Events from <span class="hljs-string"><span class="hljs-string">"../Common/Utils/</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@EventsExports</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-section"><span class="hljs-section">export</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">Events</span></span> };</code> </pre> <br><p>  In the latter case, we again become attached to the path, however this binding goes at the packet level, so pain refactoring will be much less than when the binding is in each module.  By reducing the number of imported code, we limited the number of files that the loader must prepare before executing the code of our module (for example, this is true if you break the bundle into several parts that are loaded lazily). <br><br></p><br><h3>  Internal communications modules in the package </h3><br><p>  Communication modules inside the package is not such a terrible problem, because  they are all close by.  However, for several reasons, it may be necessary to use the same mechanism for importing modules of the current package.  You can't use the exports file because  by definition, it should not include the entire contents of the package.  However, you can use it to create the third internals service file: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./@EventsExports"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -   <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SomeInternalEventImpl"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./SomeAnotherInternalEventImpl</span></span></code> </pre> <br><p>  Accordingly, after that we can use this file everywhere inside the package: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Events <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./@EventsInternals"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventImpl = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Events.SomeInternalEventImpl();</code> </pre> <br><p>  Cyclic dependencies are resolved by specification, so there should be no problems with the import of internals.  At the very least, SystemJS correctly handles such situations. </p><br><h2>  results </h2><br><ol><li>  We got rid of the terrible points "../../../" in the import path, without resorting to absolute paths, while maintaining relative flexibility. </li><li>  We have eliminated the need to import each used module separately, creating a huge import header in each file.  Instead, we import the necessary packages from the import-file of our package once. </li><li>  We returned syntax highlighting and linting JSX in VisualStudio. </li><li>  Since we use variables (packages) rather than file names during import, refactoring in the TypeScript environment becomes elementary.  The package is renamed automatically, find-all-references, etc. works. </li><li>  Dependencies between modules are ordered and concentrated in special files, which are not very many.  Even without TypeScript, refactoring such code is much easier. </li><li>  If desired, any package will be easily separated into a separate project, since it is to some extent isolated and all its dependencies are clearly spelled out.  Dividing into packages naturally forces the developer to better structure the application. </li><li>  For frequently used packages, you can configure alias in your loader and import it simply by name, without specifying the path. </li></ol><br><p>  Among the shortcomings, additional imports / exports files have appeared that need to be constantly updated.  In principle, the compilation of such files can be automated by a not very complicated gulp-task; the main thing is to come up with a convention on how to distinguish between exported and internal modules of a package.  Well, and as a drawback - when accessing imported characters, you must add the name of the package (Events.BasicEvent instead of BasicEvnet).  But, I think you can accept this, given that we get in return. </p><br><p>  UPD: <a href="https://habrahabr.ru/users/justboris/" class="user_link">justboris</a> noticed that exports can be conveniently called index.ts, since  Many collectors and IDE consider it as the ‚Äúdefault‚Äù file in the directory. <br>  UPD: <a href="https://habrahabr.ru/users/dzigoro/" class="user_link">dzigoro</a> noted that WebStorm supports the automatic addition of import declarations, as well as their updating during refactoring. </p></div><p>Source: <a href="https://habr.com/ru/post/326602/">https://habr.com/ru/post/326602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326590/index.html">Mail.Ru Group Online Course News: Restarting Advanced C ++ Programming</a></li>
<li><a href="../326592/index.html">Fat programs - speed factors</a></li>
<li><a href="../326594/index.html">Bash scripts, part 4: input and output</a></li>
<li><a href="../326596/index.html">Exoskeleton do it yourself</a></li>
<li><a href="../326600/index.html">Hello, who is calling or determining the number in Asterisk</a></li>
<li><a href="../326608/index.html">Personal vDisk in Citrix XenDesktop: what is the advantage and how it works</a></li>
<li><a href="../326610/index.html">Functional components</a></li>
<li><a href="../326612/index.html">The digest of interesting materials for the mobile developer # 199 (April 10-16)</a></li>
<li><a href="../326614/index.html">Simple JDBC Beginner Example</a></li>
<li><a href="../326616/index.html">Fast loading data from files in R</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>