<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Own platform. Part 0.1 Theory. Little about processors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello world! Today we have a series of articles for people with average knowledge of the processor in which we will deal with processor architectures ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Own platform. Part 0.1 Theory. Little about processors</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello world!  Today we have a series of articles for people with average knowledge of the processor in which we will deal with processor architectures (I have a spell checker swears at the word Architectures / Architectures, I hope I write the word correctly), create my own processor architecture and much more. </p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/5/52/Intel_4004.jpg" alt="4004"></p><br><p>  Any comments are welcome! </p><br><a name="habracut"></a><br><h1 id="nemnogo-pro-arhitekturu-processora">  A little about the processor architecture </h1><br><p>  Historically, there are many processors and many architectures.  But many architectures have similarities.  Especially for this appeared "Groups" of architectures such as RISC, CISC, MISC, OISC (URISC).  In addition, they may have different memory addressing architectures (von Neumann, Harvard).  Each processor has its own architecture.  For example, most modern architectures are RISC (ARM, MIPS, OpenRISC, RISC-V, AVR, PIC **, etc.), but there are architectures that have won simply due to other factors (eg convenience / price / popularity / etc) which x86, x86-64 (It is worth noting that x86-64 and x86 in the latest processors use microcode and inside them stands the RISC core), M68K.  What is the difference between them? </p><br><h2 id="risc">  RISC </h2><br><p>  Reduced Instruction Set Computer - An architecture with a reduced instruction execution time (from decoding RISC you might think that this is a reduced number of instructions, but it is not).  This direction developed as a result after it turned out that the majority of compilers of that time did not use all instructions and the processor developers decided to get more performance using Conveyors.  In general, RISC is the golden mean between all architectures. </p><br><p>  Vivid examples of this architecture: ARM, MIPS, OpenRISC, RISC-V </p><br><h2 id="tta">  Tta </h2><br><p>  What is TTA?  TTA is an architecture based on just one instruction moving from one memory address to another.  This option complicates the operation of the compiler, but it gives great performance.  This architecture has one drawback: Strong dependency on the data bus.  This was the reason for its lesser popularity.  It should be noted that TTA is a type of OISC. </p><br><p>  Vivid examples: MOVE Project </p><br><h2 id="oisc-urisc">  OISC (URISC)? </h2><br><p>  One Instruction Set Computer - Architecture with a single instruction.  For example SUBLEQ.  Such architectures often have the form: Make an action and, depending on the result, make a jump or continue execution.  Often its implementation is quite simple, the performance is small, while again limiting the data bus. </p><br><p>  Vivid examples: BitBitJump, ByteByteJump, SUBLEQ <del>  thousands of them! </del></p><br><h2 id="cisc">  CISC </h2><br><p>  CISC - Complex Instruction Set Computer - its feature in increased numbers of actions per instruction.  Thus, it was possible to theoretically increase the performance of programs by increasing the complexity of the compiler.  But in fact, CISC had poorly implemented some instructions.  they were rarely used, and productivity gains were not achieved.  The peculiarity of this group is still a huge difference between architectures.  And despite the names were architecture with a small number of instructions. </p><br><p>  Vivid examples: x86, M68K </p><br><h1 id="adresaciya-pamyati">  Memory addressing </h1><br><h2 id="arhitektura-fon-neymana">  Architecture Neumann Background </h2><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0.png/250px-%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0.png" alt="Von neuman wiki"></p><br><p>  A feature of such architectures was a common data bus and instructions.  Most modern architectures are software von Neumann, but no one forbids making Harvard hardware.  In this architecture, a big disadvantage is the large dependence of processor performance on the bus.  (Which limits overall processor performance). </p><br><h2 id="arhitektura-garvarda">  Harvard architecture </h2><br><p><img src="https://habrastorage.org/files/b05/66a/680/b0566a6807114bc89ea852458767d8bd.gif" alt="Harvard"></p><br><p>  The peculiarity of this architecture is a separate data bus and instructions.  It gives greater performance than von Neumann due to the possibility to use both buses in one cycle (read instructions from the bus and simultaneously write to the data bus), but complicates the architecture and has some limitations.  Mainly used in microcontrollers. </p><br><h1 id="osobennosti-processorov">  Processor features </h1><br><h2 id="konveyery">  Conveyors </h2><br><p>  What are conveyors?  If you say a very stupid language, these are several parallel actions in one measure.  This is very rude, but at the same time displays the essence.  Conveyors due to the complexity of the architecture can improve performance.  For example, the pipeline allows you to read the instructions, execute the previous one and write to the data bus at the same time. </p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/2/21/Fivestagespipeline.png" alt="pipeline"><br>  The picture is more clear, is not it? </p><br><blockquote>  IF - receiving instructions <br>  ID - decryption instructions <br>  EX - execution, <br>  MEM - memory access, <br>  WB - write to the register. </blockquote><p>  It seems everything is simple?  And no!  The problem is that, for example, a jump (jmp / branch / etc) forces the pipeline to start execution (receiving the next instruction) again, thus causing a delay of 2-4 cycles before the execution of the next instruction. </p><br><h2 id="rasshirenie-suschestvuyuschih-arhitektur">  Extend existing architectures </h2><br><p>  A rather popular technique is adding more instructions through extensions to an existing architecture.  A prime example is SSE under x86.  The same ARM and MIPS sin and almost everything.  Why?  Because it is impossible to create a universal architecture. </p><br><p>  Another option is to use other architectures to reduce the size of the instructions. <br>  Bright example: ARM with the Thumb, MIPS with MIPS16. </p><br><h1 id="tehniki-primenyaemye-v-gpu">  Techniques used in the GPU </h1><br><p>  Many cores are often found in video cards, and because of this feature, there is a need for additional solutions.  If the pipelines can be found even in microcontrollers, then the solutions used in the GPU are rare.  For example, Masked Execution (occurs in ARM instructions, but not in Thumb-I / II).  There are other features: this is a bias towards Floating Number (Floating Point Numbers), a decrease in performance versus a larger number of cores, etc. </p><br><h2 id="masked-execution">  Masked Execution </h2><br><p>  This mode differs from the classic ones in that instructions are executed sequentially without using jumps.  The instruction stores a certain amount of information about the conditions under which this instruction will be executed and if the condition is not met, then the instruction is skipped. </p><br><p>  But why? </p><br><p>  The answer is simple!  That would not load the tire instructions.  For example, in video cards you can load thousands of cores in one instruction.  And if the jump system were used, then for each core we would have to wait for the instruction from the slow memory.  Cache partially solves the problem, but still does not completely solve the problem. </p><br><h1 id="prochee">  Other </h1><br><p>  Here we will describe several techniques used in central processors and microcontrollers. </p><br><h2 id="preryvaniya">  Interruptions </h2><br><p><img src="https://habrastorage.org/files/fe0/1fe/365/fe01fe365d1d44319169dadaf9a31cf3.jpg" alt="Interrupts"></p><br><p>  An interrupt is a technique in which the currently executing code is suspended to perform some other task under certain conditions.  For example, when accessing a non-existent section of memory, HardFault or MemoryFault interrupts or exceptions are called.  Or for example if the timer counted to zero.  This allows you to not idle until you need to wait for some event. </p><br><p>  What are the disadvantages?  An interrupt call is a few idle cycles and a few when returning from an interrupt.  Also, a few instructions at the beginning of the code will be occupied by the instructions for the Interrupt Table. </p><br><h2 id="exception-isklyucheniya">  Exception </h2><br><p>  But besides interrupts, there are still exceptions that arise, for example, when dividing by zero.  It is often combined with interrupts and system calls, such as in MIPS.  Exceptions are not always present in the processor such as in the AVR or lower PIC </p><br><h2 id="sistemnye-vyzovy">  System calls </h2><br><p>  System calls are used in Operating Systems so that programs can communicate with the operating system, for example, ask the OS to read the file.  Very similar to interrupts.  Similarly, exceptions are not always present in the processor. </p><br><h1 id="kontrollery-dostupa-v-pamyat-i-prochie-metody-sderzhivaniya-programm">  Memory Access Controllers and Other Program Restraints </h1><br><p>  It describes methods of prohibiting access of applications to hardware directly. </p><br><h2 id="privilegirovannyy-rezhim">  Privileged mode </h2><br><p>  This is the mode in which the processor starts.  In this mode, the program or the OS have full memory access bypassing the MMU / MPU.  All programs are launched in the unprivileged mode in order to avoid direct access to the hardware subsystems of the programs for this purpose not intended.  For example, malware.  In Windows, it is often called Ring-0, and in * nix it is called system.  Do not confuse Privileged User and Privileged Mode because in the root you still cannot have direct access to the hardware (you can download a system module that allows you to do this, but more on that later :) </p><br><h2 id="mpu-i-mmu">  MPU and MMU </h2><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/d/dc/MMU_principle_updated.png" alt="MMU"></p><br><p>  MPU and MMU are used in modern systems to isolate multiple applications.  BUT, if the MMU allows you to "move" the memory, then the MPU only allows you to block access to memory / run code in memory. </p><br><h2 id="pic-pie">  PIC (PIE) </h2><br><p>  What is PIE?  (I do not use PIC to avoid confusion with PIC MK).  PIE is a technique by which the compiler generates code that will work anywhere in memory.  This technique in combination with MPU allows you to compile high programming languages ‚Äã‚Äãthat will work with MPU. </p><br><h1 id="simd">  SIMD </h1><br><p>  The popular SIMD technique is used to perform several actions on several registers in a single clock cycle.  Sometimes there are as additions to the basic architecture, for example, as in MIPS, ARM with its NEON / VFP / etc, x86 with its SSE2. </p><br><h1 id="reposition-for-optimization">  Reposition for Optimization </h1><br><p>  This technique is used to optimize the code generated by the compiler by re-sorting instructions, increasing processor performance.  This allows you to use the conveyor to the fullest. </p><br><h1 id="status-register">  Status register </h1><br><p><img src="https://habrastorage.org/files/92c/359/13a/92c35913aa644b40ad949f6bc6f0d833.png" alt="Status"></p><br><p>  What is a status register?  This is the register that stores the state of the processor.  For example, is the processor in privileged mode, which is how the last comparison operation ended. </p><br><p>  Used in conjunction with the Masked Execution.  Some developers specifically exclude the status register because it may be a bottleneck as they did at MIPS. </p><br><h1 id="mov-vs-0-reg">  mov vs $ 0 reg </h1><br><p>  In MIPS there is no separate instruction for loading a constant into memory, but there is an instruction addi and ori which allows, in conjunction with a zero register ($ 0), to emulate the work of loading a constant into a register.  In other architectures, it is present.  I touched on this topic because it will be useful to us in articles with practice. </p><br><h1 id="rd-rs-vs-rd-rs-rt">  Rd, Rs vs Rd, rs, rt </h1><br><p>  There are a lot of controversy about how many operands there should be in arithmetic instructions.  For example, in MIPS, a variant with 3 registers is used.  2 operands, 1 register of record.  On the other hand, the use of two operands reduces the code by reducing the size of the instruction.  An example of combining is MIPS16 in MIPS and Thumb-I in ARM.  In terms of performance, they are almost identical (If we exclude the size of the instructions as a factor). </p><br><h1 id="endianness">  Endianness </h1><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Endianmem.PNG/300px-Endianmem.PNG" alt="Endianness"></p><br><p>  Byte order  You may know Big-Endian and Little-Endian expressions.  They describe the byte order in instructions / in registers / in memory / etc.  Here I think everything is simple :).  There are processors that combine modes, like MIPS, or which use the same command system, but have different byte order, for example, ARM. </p><br><h1 id="bitnost-processora">  CPU Bit </h1><br><p>  So, what is the processor bit?  Many people believe that this is the bit bus data, but it is not.  Why?  In the early periods of microcontrollers and microprocessors, the bus could be, for example, 4-bit, but transmitted in packets of 8 bits.  It seemed to the program that it was an 8-bit mode, but it was an illusion, as it is now.  For example, the ARM SoC-ah often uses a 128-bit data bus or instructions. </p><br><p><img src="https://habrastorage.org/files/32a/ac1/59a/32aac159aff84de6b89ff6005adb909e.png" alt="128/64/32"></p><br><h1 id="soprocessory">  Coprocessors </h1><br><p>  What are coprocessors?  Coprocessors are the elements of the processor or external chip.  They allow you to execute instructions that are too cumbersome for the main part of the processor.  As a prime example, MIPS coprocessors for division and multiplication.  Or for example 387 for 80386, which added support for floating-point numbers.  And there were a lot of coprocessors in MIPS and they fulfilled their roles: they controlled interrupts, exceptions and system calls.  Often, coprocessors have their own instructions and on systems where there are no such instructions (ARM example) emulate it through Traps (traps?).  Despite their crutches and low performance, they are often the only choice in microcontrollers. </p><br><h1 id="atomarnost-operaciy">  Atomicity of operations </h1><br><p>  The atomic nature of operations provides a stream-independent execution due to instructions that perform several actions for one pseudo-tact. </p><br><p>  Alternative solution atomic peripheral.  For example, different registers are used to set the legs in the STM32 in the high and low states, which makes it possible to have atomicity at the periphery level. </p><br><h1 id="kesh">  Cache </h1><br><p><img src="https://habrastorage.org/files/631/056/2b4/6310562b4ec44c3ab1dff6a1a578fbfc.jpg" alt="Cache"></p><br><p>  You probably heard about L1, L2, L3 and registers.  In short, the processor analyzes a piece of code to predict jumps and memory access and asks the cache to get this data from the memory in advance.  Cache is often transparent to the program, but there are exceptions to this rule.  For example, in software cores in the FPGA software cache is used. </p><br><p>  And you‚Äôve overly heard of a thing like Cache Miss or a cache miss.  This is an operation that was not provided for by the processors or the processor did not manage to cache this part of the memory.  What is often a problem of slowing down memory access.  A slip passes unnoticed by the program, but drawdowns in performance will not remain unnoticeable. Similarly, context switches for example during interruptions also cause the cache to suffer because a small code knocks down the pipeline and the cache for its own needs. </p><br><h1 id="shadow-registers">  Shadow registers </h1><br><p>  Modern processors often use shadow register technology.  They allow you to switch between interrupts and user code with almost no delays associated with saving registers. </p><br><h1 id="stack">  Stack </h1><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Lifo_stack.png/350px-Lifo_stack.png" alt="Stack"></p><br><p>  Stack?  I saw Stack in .NET and in Java!  Well, you are partially right.  The stack exists, but it has never been hardware in most processors.  For example, in MIPS it is simply not there.  Ask AS SO THAT ?!  The answer is simple.  A stack is simply a memory access that does not need to be backed up (a very crude definition).  The stack is used to call functions, pass arguments, save registers in order to restore them after function execution, etc. </p><br><p>  Then ask what the heap is?  A pile is a memory much larger than a stack (the stack is usually ~ 1MB).  Everything is global in the hip.  For example, all pointers obtained with Malloc point to a part of the heap.  And pointers are stored on the stack or in registers.  Using the instructions for loading data on the register, you can speed up the stack and other memory accesses by the type of stack, since you do not need to constantly use PUSH / POP, INC / DEC or ADDI, SUBI operations (add a constant) to get data deeper in the stack, and you can simply use access relative to the stack with a negative offset. </p><br><h1 id="registry">  Registers </h1><br><p><img src="https://habrastorage.org/files/3ec/bcb/ed9/3ecbcbed917a4f91a98985ab956da811.png" alt="Registers"></p><br><p>  I will not describe registers in too much detail.  This we will address in a practical article. </p><br><p>  The x86 registers are quite small.  MIPS uses an increased number of registers, namely, 31 ($ 0 has a value always equal to zero).  The Berkeley University processor used register windows, which tightly limited the nesting of functions, while having better performance.  In others, such as AVR, they restricted the use of registers.  For example: three 16-bit can be interpreted as six eight-bit, where the first 16t are not available for some operations.  I believe that the best method was chosen by MIPS.  This is my personal opinion. </p><br><h1 id="vyravnivanie">  Alignment </h1><br><p>  What is alignment?  I'll leave this question to you :) </p><br><h1 id="konec">  the end </h1><br><p>  This is the end of the first chapter of part zero.  The whole series will revolve around the theme of creating your own processor.  Own operating system.  Own assembler.  Own compiler and much more. </p><br><p>  The zero parts will be devoted to the theory.  I doubt that I will bring the entire series to a victorious end, but the attempt is not torture!  ) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/316520/">https://habr.com/ru/post/316520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316504/index.html">Infrastructure in a box: Schneider Electric container data centers</a></li>
<li><a href="../316506/index.html">Brilliance and misery php. Language evolution from 4.x to 7.1</a></li>
<li><a href="../316512/index.html">How IT professionals work. Daniel Pivovarov, Vscale</a></li>
<li><a href="../316516/index.html">Low-level optimization and measurement of code performance on R</a></li>
<li><a href="../316518/index.html">OSPF protocol in Quagga (one zone)</a></li>
<li><a href="../316522/index.html">Five aspects of information security that will change with the development of fifth-generation mobile networks</a></li>
<li><a href="../316524/index.html">Attackers exploit the 0day vulnerability in the Tor web browser for cyber attacks</a></li>
<li><a href="../316526/index.html">About broadband microwave switches from Peregrine Semiconductor</a></li>
<li><a href="../316528/index.html">Adding admob ads to an android app using firebase</a></li>
<li><a href="../316530/index.html">New opportunity to find a freelancer on his projects from the portfolio on "Freelance"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>