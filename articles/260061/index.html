<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of modular C / C ++ applications using annotations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my first article I talked about the use of the preprocessor for organizing modularity at the source level in C / C ++ languages. In short, this met...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of modular C / C ++ applications using annotations</h1><div class="post__text post__text-html js-mediator-article">  In my <a href="http://habrahabr.ru/post/171479/">first article</a> I talked about the use of the preprocessor for organizing modularity at the source level in C / C ++ languages.  In short, this method is reduced to writing specific metadata inside the source code, which is analyzed by an external tool and used to generate glue sources that allow for modularity.  The implementation details are described in the mentioned article, so I will not repeat here.  In this article I will go a little further and try to show that using metadata or annotations you can realize not only modularity, but also some other useful features.  You should get something like <a href="https://ru.wikipedia.org/wiki/Google_Guice">Google Guice</a> or Spring for C (the part that deals with modularity and aspects).  Separately, I emphasize that this article is the addition and improvement of the first one, so here I will speak not so much about the technical details of the implementation as about how it all looks to the user.  If this topic is of interest, then I will write a sequel with explanations about how the configurator application itself is organized. <br><a name="habracut"></a><br><h4>  Universal annotations </h4><br>  The previous approach was based on the use of <i>#pragma directives</i> as a way of recording metadata inside sources.  The format of this metadata was chosen arbitrarily and honed for a specific application (description of the connection between the source and the abstract module with which it is associated).  In fact, the concept of annotations is somewhat more broad.  In particular, it is possible to draw parallels with languages ‚Äã‚Äãlike Java or C #, where annotations can describe arbitrary statements about the code in which they are contained, so it would be convenient to use some universal format. <br><br>  As examples of existing implementations of such an approach, you can bring things like the <a href="http://www.keil.com/support/man/docs/uv4/uv4_ut_configwizard.htm">Keil configuration wizard</a> , which allow you to describe various variables within a file as XML (for example, some constants, size of arrays, etc.).  Then, right in the editor, you can go to the configuration tab and configure these options graphically, rather than looking for them inside the file.  In addition, the source often contains other information that could be called annotations (for example, what is written inside <i>__ attribute</i> to GCC, all kinds of <i>__ declpec</i> , etc.). <br><br>  For a number of reasons, it was decided to refuse to write annotations in the comments, since the latter, in my opinion, should always perform only one function.  As you know, "it is so much complexity in software.  On the other hand, using <i>#pragma is</i> also fraught with problems: unknown <i>#pragma</i> cause a warning that with a large number of files in a project it does not look very nice: (several warnings in each file).  To avoid this, it was decided to wrap the annotations in a macro, which when compiled to display in an empty.  If some compiler suddenly starts supporting such a format for its internal needs and requires <i>#pragma</i> , then the C99 standard finally introduces the ability to define <i>#pragma</i> via a macro, so the macro in this sense is a more universal solution. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second question was related to the format of the annotations themselves, which are recorded inside the macro.  Although, in recent times, XML is becoming increasingly common for these tasks.  It is used, in addition to the above example with Keil, also in the FreeRTOS project (also in the comments).  I must say that XML is still not very good for aesthetic reasons - it is quite verbose, therefore, it is not very convenient for a person to work with information in this format.  At the same time, there is a machine-readable markup language that is adapted for people to read and write, and is also compatible with C syntax - this is JSON.  However, the need to quote the keys led to a not very beautiful appearance of annotations in the code, so an extended version was used - YAML.  It should be particularly noted that, of all the possibilities of YAML, ONLY the opportunity to write keys without quotes is used.  Annotations, before being transferred to the parser, are always converted to a single line, so the YAML capabilities associated with the line breaks cannot be used.  Since JSON is a subset of YAML, you can write everything in pure JSON, the ability to omit the quotes from the keys should be considered as a small nice bonus. <br><br>  Thus, in the bottom line, we have the following: the source code for C can contain the macro <b>FX_METADATA (x)</b> (with one argument), inside which annotations are written in JSON format.  Annotations are enclosed in brackets in order to avoid errors in the case of using a closing bracket inside the annotations themselves.  By convention, annotations are always a set of key-value pairs, that is, in terms of JSON, they are a hash.  Example: <br><br><pre><code class="javascript hljs">FX_METADATA(( { <span class="hljs-attr"><span class="hljs-attr">annotation</span></span>: <span class="hljs-string"><span class="hljs-string">"hello world!"</span></span> } ))</code> </pre> <br>  As you already guessed, the pragmas from the first article were ‚Äútranslated‚Äù into a new format, and now what was previously written as: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fx interface MY_INTERFACE:MY_IMPLEMENTATION</span></span></code> </pre><br>  Now it is written as: <br><br><pre> <code class="javascript hljs">FX_METADATA(( { <span class="hljs-attr"><span class="hljs-attr">interface</span></span>: [MY_INTERFACE, MY_IMPLEMENTATION] } ))</code> </pre><br>  As regards the implementation of modularity, the changes are purely cosmetic, just everything that used to be recorded as horrible, began to be recorded in a more or less universal format. <br><br>  As for #include, everything has remained almost unchanged: the FX_INTERFACE macro is still used as an argument, only now it always has one argument - it is always assumed that the interface is turned on by default, without being able to specify any particular interface. <br><br>  To summarize: The source code contains annotations, which describe the source code belonging to a module.  A module is a set of sources containing one header file (describing the interface) and an arbitrary number of source files (* .c, * .cpp, etc.).  Information about the belonging of files to modules is retrieved at the stage before compilation.  After that, an external application generates a file that maps the names of header files to module names, which allows <i>#include</i> to work in terms of modules, and not just file names, as is usually the case.  Since we have a way to find out which modules should be included in the system, and each source contains information on the belonging to modules, we can automatically find out all the files that need to be compiled.  That is, having written in some source code <b>#include FX_INTERFACE (MY_MODULE)</b> , we get that all source codes that contain a tag about belonging to the MY_MODULE interface will be included in the system. <br><br><h4>  Configurator </h4><br>  Naturally, the fact that in managed languages ‚Äã‚Äãdoes <i>runtime</i> , here, too, should someone do, so I'll tell you a little about the application that implements it.  The annotation framework is implemented in C # as a set of classes (DLL).  The question of whether it was worth writing it in C # is left behind the scenes for now.  The framework was created in such a way that the use of metadata is not limited to assembly only.  Among other things, it provides interfaces for accessing the metadata repository from outside.  This opens up possibilities for creating third-party modules that, based on metadata, can do certain actions.  In the future, all plug-ins are planned to be connected via MEF and untie them from the project structure. <br><br>  In addition to the DLL set, there are also two applications that implement the functions of the configurator: console and graphics.  The latter is in a highly prototypical state and I will not discuss it now, but the console will be considered briefly. <br><br>  The configurator has 7 command line keys, and only 3 of them are required, a list of paths to source folders, a target module (the one that starts dependency resolution) and an output file / folder.  For example, if our annotated sources are in the c: \ src1 and d: \ src2 folders, and you need to build the MY_MODULE module, the command will look something like this: <br><br><pre> <code class="dos hljs">fx_mgr -pc:\src1,d:\src2 -t MY_MODULE -o output_folder</code> </pre><br>  Running the command will result in metadata being extracted from sources, dependencies starting from the MY_MODULE module resolved, all files to be compiled are determined, after which the output of files for compilation will be generated. <br><br>  There are two ways to "withdraw". <br><br><h5>  First way </h5><br>  It is suitable for small projects, as well as convenient for the supply of something in the form of source code.  When an existing folder was specified as an argument with the <b>-o</b> key, in this case all the necessary files will be copied to the specified folder, and the header files will be renamed according to the name of the interface they implement.  Since the system can contain only one implementation of each interface, there will be no name conflict and when placing the files for compilation in a flat form in one folder, the macro <b>FX_INTERFACE</b> ( <i>#include</i> argument) can be defined very simply: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FX_INTERFACE(i) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ih&gt;</span></span></span></span></code> </pre><br>  No additional files required.  In embedded it is quite often necessary to use the libraries supplied in the form of source codes, because of the need to compile them with specific compiler keys.  This flat-file approach makes it easy to use make and add files to an IDE, etc. <br><br><h5>  Second way </h5><br>  Of course, every time something is copied when building is bad, so there is another way: if what was specified with the <b>-o</b> key is not a folder, a new file with the specified name is created (or the existing one is overwritten) and put a list of absolute paths to files that need to be compiled.  After that, this file can be used in the build system (including in make or MSBuild) to compile the files.  This raises the question, if the files contain annotations, and include use modules, where will the FX_INTERFACE / FX_METADATA macros come from?  From nowhere.  To get them, use the <b>-h</b> key.  If it is specified, a so-called is created.  a common header file, the one that contains mappings of file names to module names, as well as definitions of FX_INTERFACE and FX_METADATA.  This file must be forced by the compiler directive into all compiled files if this type of assembly is used. <br>  These were all the basics that were implemented before and worked perfectly on <i>#pragma</i> without universal annotations, now let's consider briefly the implementation of dependencies, and move on to issues that already require structured metadata. <br><br><h4>  Dependency injection </h4><br>  It is worth giving a few words to the need to support multiple implementations of a single interface.  Initially, the entire framework grew out of the configuration system for RTOS, which had to perfectly adjust to the requirements of the application.  So perfect that a single implementation of each interface might not be enough.  The OS itself, as a single entity, did not exist, it was built from smaller blocks.  In this case, several implementations of the module were made, each of which was ‚Äúsharpened‚Äù under specific requirements.  Then, since the interfaces of all the implementations are the same, it was possible to select the implementations of each interface that are ideal for the application.  In other words, this is a static dependency injection in C at the source level.  The sources in the project tree do not contain any information about which modules will actually be used; they import abstract interfaces without specifying implementations.  The actual implementations are specified by the configurator at the system assembly stage as a file in which this information is described, similar to how it is written in external languages ‚Äã‚Äãin external XML (if desired, nothing prevents you from writing such XML here).  Finally, using the same metadata, it is possible to determine some additional features by which the configurator itself can determine which implementations should be used. <br><br>  If the source contains only one implementation of each interface, then the configurator itself understands that there is no alternative, and if this interface is imported by someone, it automatically uses the only existing module with the specified interface.  If each interface has many implementations, then, in the absence of prompts, the configurator selects the first implementation (and issues a warning about what happened to the console).  Since for a given system configuration it is usually known which interface implementations should be used, you can give a hint to the configurator, it is given with the <b>‚Äìa</b> <i>&lt;file name&gt;</i> key.  The specified file contains lines of the form INTERFACE = VERSION, where INTERFACE is the name of the interface, and VERSION is the name of the implementation you want to use.  This is all close to what was described in the first part, the syntax is only slightly simplified, so it‚Äôs better to turn to the original source for technical details. <br><br><h4>  Aspects </h4><br>  Well, here we are getting close to the most interesting, for which everything was started.  There are many definitions of aspects in programming, so I will not try to embrace the immense in one short note.  Aspect is a part of something that should be assembled depending on the modules included in the project.  For example, if there are several types of some objects, sometimes you really want to have an enum containing all these types, and when you add a new type (just include the file in the project), this enum should automatically expand.  You may need to know the number of any modules included in this project, and so on. <br><br>  Obviously, no tricks with the preprocessor and code can achieve this, since  information about the modules that are included in this particular project is not available even to the compiler.  Perhaps it is better to start with the background here: among the requirements for the OS was the ability to adjust the table of system calls for the set of services available in the OS, while if a module was included in the assembly and had the functionality exported to user-mode, the table of system calls should was to take this into account.  All this is not new, such methods are used in some operating systems (for example, in NuttX), however, as a rule, all this is done on the preprocessor.  If a module is enabled, then a certain <i>#define is</i> defined; if it is defined, then <i>#ifdef</i> works, which lists the functions of this module inside the table.  The table itself, therefore, consists of <i>#ifdefs</i> .  This approach, in addition to difficult maintenance, also has such a problem that if a new module appears, then the corresponding functions must be manually added to this table, and the table thus contains knowledge about everything that can appear in the system.  Aspects are intended to solve a problem when to add something to a project, you need to make a lot of small edits in different places: expanding enums, adding entries to the configuration of the build system, and so on. <br><br>  In the proposed configurator, a different approach is implemented.  Since we have modules, why not make some modules generated by the configurator itself?  After all, he has knowledge of the structure of the system and the metadata of all modules, after the dependencies have been introduced. <br><br>  Sources contain as a special key of annotations a set of pairs of the form ‚Äúkey-array of values‚Äù.  After the configurator resolves all dependencies, the modules included in this configuration become known.  Further, all these modules are examined for the presence of the aspects key in them, and if such is found, then #define is created with the name of the key, in which all values ‚Äã‚Äãare listed (from all modules in the system).  That is, if one of the modules contains for example the following entry: <br><br><pre> <code class="javascript hljs">FX_METADATA(({ <span class="hljs-attr"><span class="hljs-attr">aspects</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">key</span></span>: [ val1, val2, val3 ] } ] }))</code> </pre><br>  And another, like this: <br><br><pre> <code class="javascript hljs">FX_METADATA(({ <span class="hljs-attr"><span class="hljs-attr">aspects</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">key</span></span>: [ val4, val5, val6 ] } ] }))</code> </pre><br>  That will be generated by the #define view <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> key val1 val2 val3 val4 val5 val6</span></span></code> </pre><br>  All values ‚Äã‚Äã(and keys and values) are treated as text, so you can write, for example, like this: <br><br><pre> <code class="javascript hljs">FX_METADATA(({ <span class="hljs-attr"><span class="hljs-attr">aspects</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">key</span></span>: [ <span class="hljs-string"><span class="hljs-string">"val1,"</span></span> , <span class="hljs-string"><span class="hljs-string">"val2,"</span></span> , <span class="hljs-string"><span class="hljs-string">"val3,"</span></span> ] } ] }))</code> </pre><br>  And then the values ‚Äã‚Äãinside #define will be separated by commas.  Well, you get the idea. <br><br>  Where will this #define be generated?  In the header file, which is indicated to the configurator as the key -e &lt;file name&gt;.  If this key is specified, the configurator adds the generated interface to the metadata store.  This interface is called CFG_ASPECTS and is available for inclusion as #include FX_INTERFACE (CFG_ASPECTS), which contains aspects from all modules.  It is important to note that if such an interface is already there (that is, the user has already written it manually and it is contained in the source pool after analyzing them), then nothing will be generated, and the existing module will be used. <br><br><h4>  Options </h4><br>  Options are some external #defines that define some configuration constants for this module.  Similar to Keil‚Äôs, not in terms of files, but in terms of modules.  Their main purpose is to set these parameters through the GUI, so using the options in the console application is rather difficult.  As in the case with aspects, options are represented by the generated interface CFG_OPTIONS, which contains all the options for this module configuration, which were described as corresponding annotations inside the source code.  The console application generates a file with the options set to default values, while the graphical application allows you to set them. <br><br>  The model of using the options was assumed as follows: the user receives the OS as a set of sources, launches the configurator, which analyzes these sources and shows the available options, the user sets them up to fit his needs, and the configurator generates the very CFG_OPTIONS file.  After that, the user has a full set of necessary configured sources.  That is, in the context of the development of them, in general, there is little use, so with this I think it is worth finishing. <br><br><h4>  Restrictions </h4><br>  In the current version, a simplified model of extracting metadata is used - comments are simply excluded from the file (by regular expressions), and further there is a search for include and metadata (also regular expressions).  In 98% of cases, this approach works flawlessly, but in some difficult cases, like redefining macros and included files, it will not work.  In this case, you need to use a full-fledged metadata provider that preprocesses every file (with a preprocessor) and extracts metadata and include files with a 100% guarantee, even in the case of any tricks with the preprocessor.  But, of course, in the case of a large number of files, this will be rather slow (seconds for a project of several hundred files, which is quite tedious when debugging). <br><br>  Parallel extraction of metadata is supported in the current implementation: since this operation is perfectly parallelized, the extraction and parsing of metadata takes place using the Parallel.ForEach cycle, which runs on a thread pool, so that if there are multiple processors, this operation is seriously accelerated. <br><br>  There is also a little difficulty with using IDE, the fact is that IDE IDs assume that all files that are in the current project need to be compiled.  In the proposed approach, the configurator, according to the list of folder paths, the project itself determines which files should be compiled, so if the IDE does not allow you to somehow filter the input files (using some kind of plug-in that could say at the time of the build) necessary, and what not to compile), then using such an IDE will be somewhat problematic.  I do not use the IDE myself, use Sublime Text or Visual Studio Code as an editor, and the build is configured to run from the command line.  In addition, RTOS is supplied as source for a specific configuration, so there are no problems with it, but those who cannot live without an IDE may be disappointed, yes.  In fact, an additional build phase is introduced that runs before compilation ‚Äî the configuration phase, and not all IDEs are compatible with this approach. <br><br><h4>  Conclusion </h4><br>  I apologize for some confusion of presentation, annotations, aspects and modularity are large separate topics that are very difficult to embrace and fully cover in one post, so I view this post not as something complete, but as the beginning of a discussion.  If someone described the things seemed interesting, then you can go to the next step and look at the examples of use and source code of the configurator.  All this is available <a href="https://github.com/Eremex/fx-mgr">on the githaba</a> .  That's all for now, thank you all for your attention. </div><p>Source: <a href="https://habr.com/ru/post/260061/">https://habr.com/ru/post/260061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260033/index.html">Is it true that Go is faster than Ruby?</a></li>
<li><a href="../260045/index.html">Material Design and Search by the example of a reference application</a></li>
<li><a href="../260047/index.html">Interesting notes on C # and CLR (v2.0)</a></li>
<li><a href="../260049/index.html">One of the features of PHP related to methods and functions</a></li>
<li><a href="../260053/index.html">How to bind Docker containers without forcing the application to read environment variables</a></li>
<li><a href="../260065/index.html">NGINX inside: born for performance and scaling</a></li>
<li><a href="../260067/index.html">Reactive User Interface Programming in Jancy</a></li>
<li><a href="../260069/index.html">Squires of microelectronics. Video report from the San Francisco Electronics Design Conference</a></li>
<li><a href="../260071/index.html">Charm Solitaire game defense study</a></li>
<li><a href="../260073/index.html">The construction of Bitcoin data centers continues, despite the fall in the cost of cryptocurrency</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>