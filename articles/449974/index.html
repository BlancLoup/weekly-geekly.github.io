<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Netramesh - lightweight service mesh solution</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of transition from a monolithic application to microservice architecture, we face new problems. 


 In a monolithic application, it is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Netramesh - lightweight service mesh solution</h1><div class="post__text post__text-html js-mediator-article"><p>  In the process of transition from a monolithic application to microservice architecture, we face new problems. </p><br><p>  In a monolithic application, it is usually sufficient to simply determine in which part of the system the error occurred.  Most likely, the problem is in the code of the monolith itself, or in the database.  But when we start looking for a problem in microservice architecture, everything is not so obvious.  It is necessary to find the entire path that passed the request from start to finish, select it from hundreds of microservices.  Moreover, many of them also have their own storage facilities, in which both logical errors and problems with performance and fault tolerance can arise. </p><br><p><img src="https://habrastorage.org/webt/m8/0j/9n/m80j9nw5mgqijdf5crurmq7jv0q.png"></p><br><p>  I spent a long time looking for a tool that would help cope with such problems (I wrote about it on Habr√©: <a href="https://habr.com/ru/company/avito/blog/419319/">1</a> , <a href="https://habr.com/ru/company/avito/blog/433650/">2</a> ), but in the end I made my own open source solution.  In the article, I talk about the benefits of the service mesh approach and share a new tool for its implementation. </p><a name="habracut"></a><br><p>  Distributed tracing is a common solution to the problem of finding errors in distributed systems.  But what if the system has not yet implemented such an approach to collecting information about network interactions, or, worse, in part of the system it already works properly, but in part it does not exist, since it is not added to the old services?  To determine the exact root cause of the problem, you must have a complete picture of what is happening in the system.  It is especially important to understand which microservices are involved in the main business-critical ways. </p><br><p>  Here a service mesh approach can come to our aid, which will take care of the whole machine for collecting network information at a level lower than the services themselves.  This approach allows us to intercept all traffic and analyze it on the fly.  Moreover, applications about it should not even know anything. </p><br><h1 id="service-mesh-podhod">  Service mesh approach </h1><br><p>  The main idea of ‚Äã‚Äãthe service mesh approach is to add another infrastructure layer above the network, which will allow us to do any things with inter-service interaction.  Most implementations work as follows: an additional sidecar container with a transparent proxy is added to each microservice, through which all incoming and outgoing service traffic is passed.  And this is the very place where we can do client balancing, apply security policies, impose restrictions on the number of requests and collect important information on the interaction of services in production. </p><br><p><img src="https://habrastorage.org/webt/6r/zb/zk/6rzbzk2278btzronnwaok9jyqcw.png"></p><br><h1 id="resheniya">  Solutions </h1><br><p>  There are already several implementations of this approach: <a href="https://istio.io/">Istio</a> and <a href="https://linkerd.io/2/overview/">linkerd2</a> .  They provide many opportunities out of the box.  But at the same time a big overhead comes to resources.  Moreover, the larger the cluster in which such a system operates, the more resources will be required to maintain the new infrastructure.  In Avito, we exploit kubernetes clusters in which there are thousands of instances of services (and their number continues to grow rapidly).  In the current implementation, Istio consumes ~ 300Mb of RAM for each instance of the service.  Due to the large number of possibilities, transparent balancing also affects the total response time of services (up to 10ms). </p><br><p>  As a result, we looked at exactly what opportunities we need right now, and decided that the main thing, because of which we began to implement such solutions, was the ability to collect tracing information from the entire system transparently.  We also wanted to have control over the interaction of services and do various manipulations with the headers that are transferred between services. </p><br><p>  As a result, we came to our decision: <a href="http://bit.ly/netra_ru">Netramesh</a> . </p><br><h1 id="netramesh">  Netramesh </h1><br><p>  <a href="http://bit.ly/netra_ru">Netramesh</a> is a lightweight service mesh solution with the possibility of infinite scaling regardless of the number of services in the system. </p><br><p>  The main objectives of the new solution were a small resource overhead and high performance.  Of the main features, we wanted to immediately be able to transparently send tracing spans to our Jaeger system. </p><br><p>  Today, most cloud solutions are implemented on Golang.  And, of course, there are reasons for this.  Writing network applications that work asynchronously with I / O and are scaled to kernels as needed on Golang is easy and convenient.  And, which is also very important, the performance is sufficient to solve this problem.  Therefore, we also chose Golang. </p><br><h1 id="proizvoditelnost">  Performance </h1><br><p>  We focused our efforts on achieving maximum performance.  For a solution that is deployed next to each instance of the service, a small consumption of RAM and processor time is required.  And, of course, the delay in response should also be small. </p><br><p>  Let's see what the results are. </p><br><h2 id="ram">  Ram </h2><br><p>  Netramesh consumes ~ 10Mb without traffic and 50Mb at a maximum with a load of up to 10,000 RPS per instance. </p><br><p>  Istio envoy proxy always consumes ~ 300Mb in our clusters with thousands of instances.  It does not allow to scale it on the whole cluster. </p><br><p><img src="https://habrastorage.org/webt/y6/io/ys/y6ioysd0roxkllgujmzof3lps30.png"></p><br><p><img src="https://habrastorage.org/webt/mi/70/2q/mi702qegemdopjkdh7or3bqv9c0.png"></p><br><p>  With Netramesh, we have ~ 10 times less memory consumption. </p><br><h2 id="cpu">  CPU </h2><br><p>  CPU usage is relatively equal under load.  It depends on the number of requests per unit time to the sidecar.  Values ‚Äã‚Äãat 3000 requests per second in peak: </p><br><p><img src="https://habrastorage.org/webt/nm/dp/5s/nmdp5ssxux47zzuohvhacbgjqzw.png"></p><br><p><img src="https://habrastorage.org/webt/8y/kn/bq/8yknbqlejeqprvut2c2n_pgsay0.png"></p><br><p>  There is one more important point: Netramesh - a solution without a control plane and without load does not consume processor time.  With Istio, sidecars always update service endpoints.  As a result, we can see such a picture without load: </p><br><p><img src="https://habrastorage.org/webt/hz/ne/2h/hzne2hf6m_z_tefolvtoiwuwcpq.png"></p><br><p>  We use HTTP / 1 for communication between services.  The increase in response time for Istio when proxying through envoy was up to 5-10ms, which is quite a lot for services that are ready to be responsible for a millisecond.  With Netramesh this time decreased to 0.5-2ms. </p><br><h1 id="masshtabiruemost">  Scalability </h1><br><p>  A small amount of resources spent by each proxy allows you to place it near each service.  Netramesh was intentionally created without a control plane component to simply maintain the lightness of each sidecar.  Often, in service mesh solutions, the control plane spreads service discovery information to each sidecar.  Along with her comes information about timeouts and balancing settings.  All this allows you to do a lot of useful things, but, unfortunately, inflates sidecar'y in size. </p><br><h1 id="service-discovery">  Service discovery </h1><br><p><img src="https://habrastorage.org/webt/sl/2o/gf/sl2ogfr5t31zfqwefxmcoe89xmu.png"></p><br><p>  Netramesh does not add any additional mechanisms for service discovery.  All traffic is proxied transparently via netra sidecar. </p><br><p> Netramesh supports HTTP / 1 application protocol.  To determine it, a configurable list of ports is used.  Usually there are several ports in the system that communicate over HTTP.  For example, 80, 8890, 8080 are used for interaction between services and external requests. In this case, they can be set using the environment variable <code>NETRA_HTTP_PORTS</code> . </p><br><p>  If you use Kubernetes as an orchestrator and its entity service mechanism for intracluster communication between services, then the mechanism remains exactly the same.  First, microservice gets the service IP address using kube-dns and opens a new connection to it.  This connection is established first with the local netra-sidecar and all TCP packets initially arrive in netra.  Next, netra-sidecar establishes a connection with the original destination point.  NAT on pod IP on a node remains exactly the same as without netra. </p><br><h1 id="raspredelennyy-tracing-i-prokidyvanie-konteksta">  Distributed tracing and context passing </h1><br><p>  Netramesh provides the functionality necessary to send tracing spans for HTTP communication.  Netra-sidecar parses the HTTP protocol, measures the delay of requests, extracts the necessary information from the HTTP headers.  Ultimately, we get all the trace'y in a single Jaeger system.  For a fine configuration, you can also use the environment variables provided by the official <a href="https://github.com/jaegertracing/jaeger-client-go">jaeger go library</a> . </p><br><p><img src="https://habrastorage.org/webt/ak/rg/_a/akrg_a52och5z3sfg625xb8se6m.png"></p><br><p><img src="https://habrastorage.org/webt/ol/c9/ga/olc9gakhzkqcbgkcnjbhsy2e5eo.png"></p><br><p>  But there is a problem.  Until the services generate and wrap a special uber header, we will not see the connected tracing span in the system.  And this is what we need to quickly find the cause of problems.  Here Netramesh has a solution again.  Proxies read HTTP headers and, if they do not have a uber trace id, generate it.  Netramesh also stores information about incoming and outgoing requests in sidecar and compares them by enriching them with the necessary outgoing requests headers.  All that needs to be done in services is to send only one <code>X-Request-Id</code> header, which can be configured using the <code>NETRA_HTTP_REQUEST_ID_HEADER_NAME</code> environment <code>NETRA_HTTP_REQUEST_ID_HEADER_NAME</code> .  To control the size of the context in Netramesh, you can set the following environment variables: <code>NETRA_TRACING_CONTEXT_EXPIRATION_MILLISECONDS</code> (the time during which the context will be stored) and <code>NETRA_TRACING_CONTEXT_CLEANUP_INTERVAL</code> (the frequency of clearing the context). </p><br><p>  It is also possible to combine several paths in your system by marking them with a special session marker.  Netra allows you to set the <code>HTTP_HEADER_TAG_MAP</code> to turn HTTP headers into corresponding tracing span tags.  This can be especially useful for testing.  After passing the functional test, you can see which part of the system was affected by filtering on the corresponding session key. </p><br><h1 id="opredelenie-istochnika-zaprosa">  Identify the source of the request </h1><br><p>  To determine where the request came from, you can use the function of automatically adding a header with the source.  Using the environment variable <code>NETRA_HTTP_X_SOURCE_HEADER_NAME</code> you can set the name of the header to be automatically installed.  Using the <code>NETRA_HTTP_X_SOURCE_VALUE</code> you can set the value to which the X-Source header will be set for all outgoing requests. </p><br><p>  This allows unified throughout the network to make the distribution of this useful header.  Then you can already use it in services and add logs, metrics. </p><br><h1 id="routing-trafika-i-vnutrennosti-netramesh">  Routing traffic and internals Netramesh </h1><br><p>  Netramesh consists of two main components.  The first, netra-init, establishes network rules for intercepting traffic.  It uses <a href="">iptables redirect rules</a> to intercept all or part of the traffic on the sidecar, which is the second main component of Netramesh.  You can configure which ports to intercept for incoming and outgoing TCP sessions: <code>INBOUND_INTERCEPT_PORTS, OUTBOUND_INTERCEPT_PORTS</code> . </p><br><p>  Also in the tool there is an interesting opportunity - probabilistic routing.  If you use Netramesh exclusively for collecting tracing spans, then in a production environment you can save resources and enable probabilistic routing using the variables <code>NETRA_INBOUND_PROBABILITY</code> and <code>NETRA_OUTBOUND_PROBABILITY</code> (from 0 to 1).  The default value is 1 (all traffic is intercepted). </p><br><p>  After successfully intercepting the netra sidecar, it accepts a new connection and uses the <code>SO_ORIGINAL_DST</code> socket option to obtain the original destination.  Then, Netra opens a new connection to the original IP address and establishes two-way TCP-communication between the parties, listening to all the traffic going through.  If the port is defined as HTTP, Netra tries to parse it and trace.  If HTTP parsing is unsuccessful, Netra makes a fallback on TCP and transparently proxies the bytes. </p><br><h1 id="postroenie-grafa-zavisimostey">  Building a dependency graph </h1><br><p>  After receiving a lot of tracing information in Jaeger, I want to get a complete graph of interactions in the system.  But if your system is loaded enough and billions of tracing span accumulate in a day, making their aggregation becomes not so easy.  There is an official way for this: <a href="https://github.com/jaegertracing/spark-dependencies">spark-dependencies</a> .  Nevertheless, he will take hours to build a complete graph and force the entire dataset to be pumped out of Jaeger over the past 24 hours. </p><br><p>  If you use Elasticsearch to store tracing span'ov, you can use a <a href="https://github.com/Lookyan/jaeger-dependencies">simple utility on Golang</a> , which will build the same graph in minutes using the features and capabilities of Elasticsearch. </p><br><p><img src="https://habrastorage.org/webt/ob/t8/av/obt8avxi13fb9ykb1rj3ljreup0.png"></p><br><h1 id="kak-ispolzovat-netramesh">  How to use netramesh </h1><br><p>  Netra can be simply added to any service running any orchestrator.  You can see an example <a href="http://bit.ly/2HVRv7D">here</a> . </p><br><p>  Currently, Netra does not have the ability to automatically introduce sidecar to services, but there are plans for implementation. </p><br><h1 id="buduschee-netramesh">  Future netramesh </h1><br><p>  The main goal of <a href="http://bit.ly/netra_ru">Netramesh</a> is to achieve minimum resource costs and high performance, providing basic opportunities for observability and control of interservice service. </p><br><p>  In the future, Netramesh will receive support from other application layer protocols besides HTTP.  In the near future, L7 routing will be possible. </p><br><p>  Use Netramesh if you encounter similar problems and email us with questions and suggestions. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/449974/">https://habr.com/ru/post/449974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449964/index.html">Test drive nanoCAD SPDS Construction site 8. Part 2</a></li>
<li><a href="../449966/index.html">Tables in Figma. Data Grid Design by One Component</a></li>
<li><a href="../449968/index.html">Redmadrobot discusses AppsConf 2019: video</a></li>
<li><a href="../44997/index.html">Improving my health helps</a></li>
<li><a href="../449970/index.html">Under the black flag post, or As I did not put your video course on the tracker</a></li>
<li><a href="../449976/index.html">Multi-threaded associative containers in C ++. Yandex report</a></li>
<li><a href="../449978/index.html">Igor Antarov from Moscow Tesla Club fights with 20 Tesla and electric car myths</a></li>
<li><a href="../44998/index.html">Yandex. Search Tabs</a></li>
<li><a href="../449990/index.html">How to make friends latex, formulas and Habr?</a></li>
<li><a href="../449994/index.html">Schneiderman's eight golden rules will help you create a better interface.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>