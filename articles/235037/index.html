<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A few words about pipelines in FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 Many people know that in all modern processors there is a computing pipeline. There is a misconception that the pipeline is some kind of chi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A few words about pipelines in FPGA</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  Many people know that in all modern processors there is a computing pipeline.  There is a misconception that the pipeline is some kind of chip processors, and in chips for other applications (for example, network) this is not.  In fact, pipelining (or pipelining) is the key to building high-performance ASIC / FPGA applications. <br><br>  Very often, to achieve high performance, such algorithms are chosen that are easily pipelined in the chip.  If you are interested in learning about low-level details, welcome under the cat! <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Simple example </h4><br>  Consider the following example: it is necessary to sum four unsigned eight-bit numbers.  Within the framework of this task, I neglected the fact that the result of summing up 8-bit numbers may be greater than 255. <br><br>  Quite an obvious SystemVerilog code for this task: <br><pre><code class="vhdl hljs">module no_pipe_example( input clk_i, input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x_i [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>], output logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] no_pipe_res_o ); // no pipeline always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> no_pipe_res_o &lt;= ( x_i[<span class="hljs-number"><span class="hljs-number">0</span></span>] + x_i[<span class="hljs-number"><span class="hljs-number">1</span></span>] ) + ( x_i[<span class="hljs-number"><span class="hljs-number">2</span></span>] + x_i[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre> <br><br>  Take a look at the resulting circuit of registers and adders.  Use for this RTL Viewer in Quartus'e.  (Tools -&gt; Netlist Viewer -&gt; RTL Viewer).  In this article, the words "register" and "trigger" are fully-fledged synonyms. <br><br><img src="//habrastorage.org/files/560/294/03d/56029403da6044e687647ec5e51c17db.png"><br><br>  What happened? <br><ol><li>  The inputs <b>x_i [0]</b> and <b>x_i [1]</b> are fed to the adder <b>Add0</b> , and <b>x_i [2]</b> and <b>x_i [3]</b> to <b>Add1</b> . </li><li>  Outputs with <b>Add0</b> and <b>Add1</b> are fed to the <b>Add2</b> adder. </li><li>  The output from the <b>Add2</b> adder <b>is</b> latched into the trigger <b>no_pipe_res_o</b> . </li></ol><br>  Add registers between the <b>Add0 / Add1</b> and <b>Add2 adders</b> . <br><br><pre> <code class="vhdl hljs">module pipe_example( input clk_i, input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x_i [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>], output logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] pipe_res_o ); // pipeline logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] s1 = '<span class="hljs-number"><span class="hljs-number">0</span></span>; logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] s2 = '<span class="hljs-number"><span class="hljs-number">0</span></span>; always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s1 &lt;= x_i[<span class="hljs-number"><span class="hljs-number">0</span></span>] + x_i[<span class="hljs-number"><span class="hljs-number">1</span></span>]; s2 &lt;= x_i[<span class="hljs-number"><span class="hljs-number">2</span></span>] + x_i[<span class="hljs-number"><span class="hljs-number">3</span></span>]; pipe_res_o &lt;= s1 + s2; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre><br><br><img src="//habrastorage.org/files/af4/c06/7ad/af4c067ad2404a278643e4b03046a55c.png"><br><br><ol><li>  The inputs <b>x_i [0]</b> and <b>x_i [1]</b> are fed to the adder <b>Add0</b> , and <b>x_i [2]</b> and <b>x_i [3]</b> to <b>Add1</b> . </li><li>  After summation, the result is put into registers <b>s1</b> and <b>s2</b> . </li><li>  The data from the registers <b>s1</b> and <b>s2</b> are fed to <b>Add2</b> , the result of summation is latched into <b>pipe_res_o</b> . </li></ol><br>  In order to see the difference in the behavior of the modules <b>no_pipe_example</b> and <b>pipe_example</b> combine them into one and simulate. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">module pipe_and_no_pipe_example( input clk_i, input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x_i [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>], output logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] no_pipe_res_o, output logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] pipe_res_o ); // no pipeline always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> no_pipe_res_o &lt;= ( x_i[<span class="hljs-number"><span class="hljs-number">0</span></span>] + x_i[<span class="hljs-number"><span class="hljs-number">1</span></span>] ) + ( x_i[<span class="hljs-number"><span class="hljs-number">2</span></span>] + x_i[<span class="hljs-number"><span class="hljs-number">3</span></span>] ); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> // pipeline logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] s1 = '<span class="hljs-number"><span class="hljs-number">0</span></span>; logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] s2 = '<span class="hljs-number"><span class="hljs-number">0</span></span>; always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s1 &lt;= x_i[<span class="hljs-number"><span class="hljs-number">0</span></span>] + x_i[<span class="hljs-number"><span class="hljs-number">1</span></span>]; s2 &lt;= x_i[<span class="hljs-number"><span class="hljs-number">2</span></span>] + x_i[<span class="hljs-number"><span class="hljs-number">3</span></span>]; pipe_res_o &lt;= s1 + s2; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre><br></div></div><br> <a href="http://http:"><img src="//habrastorage.org/files/a6d/509/ca3/a6d509ca348548f2bacdaf451217ac8b.png"><br></a> <br>  On the positive front (the so-called posedge) <b>clk_i,</b> 4 numbers were <b>sent</b> to the input of the module: 4, 8, 15 and 23. The next positive front in the <b>no_pipe_res_o</b> register appeared 50, and in the <b>s1</b> and <b>s2</b> registers the half sums are 12 and 38. Next posedge in the pipe_res_o register appeared the answer 50, and 0 appeared in <b>no_pipe_res_o</b> , which is not surprising, since  four zeros were given as input values ‚Äã‚Äãand the circuit honestly added them. <br><br>  It is immediately noticeable that the result in <b>pipe_res_o is</b> delayed by one clock cycle than in <b>no_pipe_res_o</b> , since  registers <b>s1</b> and <b>s2</b> were added. <br><br>  Consider what happens if we each time we submit a new array of numbers for summation: <br> <a href="http://http:"><img src="//habrastorage.org/files/e6a/c11/c80/e6ac11c8015840b0855883fc6c86df98.png"><br></a> <br>  It is easy to see that both branches (with and without a pipeline) are ready for each new tact to receive each measure. <br><br>  A fair question arises: <i>why use a pipeline, if calculations take more time (cycles) and it takes more triggers (resources)?</i> <br><br><h4>  Conveyor capacity </h4><br>  The performance of this scheme is determined by the number of 8-bit fours, which it can accept and process per second.  The circuit is ready for a new piece of data every clock; therefore, the higher the frequency value <b>clk_i</b> , the better the circuit performance. <br><br>  There is a formula that calculates the maximum allowable frequency between two triggers.  Its simplified version: <br><img src="//habrastorage.org/files/9bb/3e7/7cf/9bb3e77cf8094a74b9da2226603ebbf8.png" width="150"><br>  <b>Legend</b> : <br><ul><li>  <b>Fmax</b> - the maximum clock frequency. </li><li>  <b>Tlogic</b> - the delay in the passage of a signal through the logic elements. </li></ul><br>  Under the spoiler is a complete formula, an explanation of which can be found in the list of references, which is given at the end of the article. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><img src="//habrastorage.org/files/17d/abe/046/17dabe0468ba4a268e33b8ccde528faf.png" width="500"><br></div></div><br>  To estimate the maximum frequency, paths are considered between all triggers within one clok domain: that is, only those triggers that run from the clock that interests us.  Then the longest path is determined, which shows the maximum frequency at which the circuit will operate without errors. <br><br>  The more logical elements in the signal path from one trigger to another, the greater the value of <b>Tlogic</b> .  If we want to increase the frequency, then we need to reduce this value!  How to do it? <br><ol><li>  Optimize code.  Sometimes newbies (and experienced developers, to be honest!) Write such constructs that turn into <b>very</b> long chains of logic: this should be avoided with various tricks.  Sometimes it is necessary to optimize the circuit for a specific FPGA architecture. </li><li>  Add register (s).  Just cut the logic into pieces. </li></ol><br>  Adding registers - this is pipelining!  Pipelined circuits in most cases can operate at higher frequencies than those without a pipeline. <br><br>  Consider the following example: <br>  There are two triggers, <b>A</b> and <b>B</b> , the signal between them overcomes two ‚Äúclouds‚Äù of logic, one of which takes 4 ns, the other 7 ns.  If it is easier, imagine that the green cloud is an adder and the orange one is a multiplexer.  Examples and numbers are taken from the head. <br><img src="//habrastorage.org/files/de7/d47/f69/de7d47f6912240549c8093739f13c17f.png"><br><br>  What will be equal to <b>Fmax</b> ?  A sum of 4 and 7 ns will display the value of <b>Tlogic</b> : <b>Fmax</b> ~ 91 MHz. <br><br>  Add a <b>C</b> register between the combination: <br><img src="//habrastorage.org/files/c89/2f2/aac/c892f2aac48f4d169dd69e9228d6910d.png"><br><br>  <b>Fmax</b> is estimated by the worst path, the time of which is now 7 ns, or ~ 142 MHz.  Of course, do not rush and add registers to increase the frequency anywhere, because  it is easy to run into the most frequent mistake (in my experience) that somewhere the circuit went for one clock cycle, since  somewhere added a register, but somewhere not.  It happens, the scheme for the pipeline was not ready, because  There is a feedback, due to the delay per clock (s), it began to work incorrectly. <br><br>  Let's summarize a little: <br><ol><li>  Through pipelining, you can increase the throughput of the circuit by sacrificing processing time and resources. </li><li>  It is necessary to break the logic as evenly as possible, since  maximum frequency of the circuit depends on the worst path.  Smashing 11 ns in half, it would be possible to get 182 MHz. </li><li>  Of course, to infinity increase the frequency does not work, because  Temporary parameters, which we have now closed our eyes, can not be neglected.  <b>Trouting</b> first. </li></ol><br>  I note that sometimes the goal to achieve the maximum frequency is not, most often the opposite: the frequency is known, to which we must strive.  For example, the standard frequency of 10G MAC-core is 156.25 MHz.  It may be convenient for the whole circuit to operate from this frequency.  There are requirements that are not directly related to the clock frequency: for example, there is a task for a search system to do 10 million searches per second.  On the one hand, you can make a pipeline at a frequency of 10 MHz, and prepare a circuit to receive data every clock cycle.  On the other, a more advantageous option may be this: increase the frequency to 100 MHz and make a pipeline that is ready to receive data every 10th clock cycle. <br><br>  Of course, this example is very childish, but it is the key to creating circuits with very high performance. <br><br><h4>  Tips and personal experience </h4><br>  In the last article I mentioned that I am developing high-speed Ethernet applications based on FPGA.  The main basis of such applications are pipelines, which grind packages.  It so happened that during the preparation of this article I gave a short lecture on pipelining in FPGA to student interns who are gaining experience in this craft.  I thought that these tips would be appropriate here, and, perhaps, will cause some discussion.  Experienced developers, most likely, will not find something new or original) <br><br><h5>  Use validity cues </h5><br>  Sometimes novice FPGA developers make the following error: they determine the fact of the arrival of new data on the data itself.  For example, they check the data for zero: if not zero, then the new data came, otherwise we do nothing.  Also, instead of zero, they use some other ‚Äúforbidden‚Äù combination (all units). <br><br>  This is not a very correct approach, as: <br><ul><li>  Resources are spent on zeroing and checking.  On large data buses, this can be very expensive. </li><li>  It may not be obvious to other developers what is happening here (WTF code). </li><li>  Some kind of forbidden combination may not be.  As in the example with the adder above: all values ‚Äã‚Äãfrom 0 to 255 are valid and can be fed to the adder. </li></ul><br>  By entering validity signals, we inform the module of the fact of the presence of valid data at the input, and it in turn shows when the data at the output is correct.  These signals can use the following module, which stands in a conveyor chain. <br><br>  Add the validity signals <b>x_val_i</b> and <b>pipe_res_val_o</b> to the example above: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">module pipe_with_val_example( input clk_i, input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] x_i [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>], input x_val_i, output logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] pipe_res_o, output logic pipe_res_val_o ); logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] s1 = '<span class="hljs-number"><span class="hljs-number">0</span></span>; logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] s2 = '<span class="hljs-number"><span class="hljs-number">0</span></span>; logic x_val_d1 = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; logic x_val_d2 = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> x_val_d1 &lt;= x_val_i; x_val_d2 &lt;= x_val_d1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always_ff @( posedge clk_i ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> s1 &lt;= x_i[<span class="hljs-number"><span class="hljs-number">0</span></span>] + x_i[<span class="hljs-number"><span class="hljs-number">1</span></span>]; s2 &lt;= x_i[<span class="hljs-number"><span class="hljs-number">2</span></span>] + x_i[<span class="hljs-number"><span class="hljs-number">3</span></span>]; pipe_res_o &lt;= s1 + s2; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> assign pipe_res_val_o = x_val_d2; endmodule</code> </pre><br></div></div><br><br> <a href="http://http:"><img src="//habrastorage.org/files/532/7d6/b0f/5327d6b0fa124f348d0db911a9ad70e6.png"><br></a> <br>  You must admit that it immediately became clearer what is happening here: at what cycle are the input and output data valid? <br><br>  A couple of comments: <br><ul><li>  In this example, it would be nice to add a <b>reset</b> , so that he would reset <b>x_val_d1 / d2</b> . </li><li>  Despite the fact that the data is invalid, the adders still add them and put the data in the registers.  On the other hand, one would be allowed to save to registers only when the data is valid.  In this example, saving invalid data does not lead to anything bad: I didn‚Äôt add permission to work.  However, if there is a need to optimize for power consumption, you will have to add such signals and simply do not drive the current :). </li></ul><br><h5>  Think about the sender and the data recipient </h5><br>  Most often, when developing, it is immediately clear that it is necessary to build a pipeline to achieve the desired frequency.  When a pipeline is written from scratch, you need to think about the architecture, for example, decide when you can send data to the pipeline.  By way of illustration, here is a typical Ethernet pipeline processing architecture. <br><br><img src="//habrastorage.org/files/cab/f60/d2a/cabf60d2a4a5424cbb65e240e18b7237.png"><br><br>  <b>Legend:</b> <br><ul><li>  <b>fifo_0</b> , <b>fifo_1</b> - fifoshki to accommodate the package data.  In this example, it is assumed that before the start of reading from <b>fifo_0 the</b> entire package is already placed there, and the logic behind <b>fifo_1</b> does not require a whole package to start processing. </li><li>  <b>arb</b> is the arbiter who decides when to read the data from <b>fifo_0</b> and to submit to the input of module <b>A.</b>  Subtraction is performed by setting the signal <b>rd_req</b> (read request). </li><li>  <b>A</b> , <b>B</b> , <b>C</b> - abstract modules that form a conveyor chain.  It is not at all necessary that each module processes the data one clock cycle.  The modules inside can also be pipelined.  They perform some kind of packet processing, for example, they form a system of parsers or modify a packet (for example, they substitute the source or destination MAC addresses). </li></ul><br>  In this example, <b>fifo_0</b> is the sender of the data, and <b>fifo_1</b> is the receiver.  Suppose that for some reason <b>data is</b> not read out from <b>fifo_1</b> or data reading speed is lower than the write speed, as a result, this fifo may overflow.  It is not necessary to write in full fifoshku, because, at least, you break the package (some data set may disappear from the package) and transfer it incorrectly. <br><br>  What can <b>fifo</b> say? <br><ol><li>  <b>used_words</b> is the number of words used.  Knowing the size of the fiesta, you can calculate the number of free words.  In this example, we assume that one word is equal to one byte. </li><li>  <b>full</b> and <b>almost_full</b> - signals that the fifo has already filled, or "almost" filled.  ‚ÄúAlmost‚Äù is determined by the custom boundary of the words used. </li></ol><br>  In order not to break the data, we need once to not read package data from <b>fifo_0</b> and suspend the operation of the pipeline.  How to do it? <br><br><h6>  <b><i>Forehead algorithm</i></b> </h6><br>  Suppose we allocated <b>fifo_1</b> for MTU, for example, 1500 bytes.  Before starting to read a packet from <b>fifo_0,</b> <b>arb</b> looks at the number of free bytes in <b>fifo_1</b> .  If it is larger than the size of the current package, then set <b>rd_req</b> and do not remove it to the end of the package.  Otherwise, wait until the fifo is released. <br><br>  <b>Pros:</b> <br><ul><li>  Arbitration is relatively simple and done quickly. </li><li>  Fewer boundary conditions to check. </li></ul><br>  <b>Minuses:</b> <br><ul><li>  <b>fifo_1</b> must be allocated for MTU.  And if you have an MTU 64K, then a couple of such fifo will give you half FPGA). Sometimes it is impossible to get by without the fifo for a package, but it‚Äôs better to save resources. </li><li>  If the conveyor is idle, because  space for the whole package is not enough, then we lose in performance.  More precisely, the worst case (the overflow of <b>fifo_0</b> , in which someone also puts packages) comes faster. </li></ul><br>  <b>Note:</b> <br>  When calculating the free space you need to make a margin for the length of the conveyor.  For example, right now in <b>fifo_1</b> 100 bytes are free, a packet of 95 bytes has come to us.  We look that 100 is more than 95 and start forwarding the packet.  This is not entirely true.  we do not know the current state of the pipeline - if we process the previous packet, then in the worst case, in <b>fifo_1,</b> additional words will be written in the amount of the length of the pipeline (in cycles).  If the pipeline is working 10 cycles, then another 10 words will fall into <b>fifo_1</b> , and the fifo may overflow when we write a packet of 95 bytes. <br><br><h6>  <b><i>Improving the "algorithm in the forehead"</i></b> </h6><br>  We reserve in <b>fifo_1 the</b> number of words equal to the length of the conveyor.  We use the <b>almost_full</b> signal. <br>  The arbitrator watches every signal on this signal.  If it is 0, then we read one word of the package, otherwise - no. <br><br>  <b>Pros:</b> <br><ul><li>  <b>Fifo_1</b> may not be very big, for example, a couple of dozen words. </li></ul><br>  <b>Minuses:</b> <br><ul><li>  Modules <b>A</b> , <b>B</b> , <b>C</b> must be prepared for the fact that a packet will come not every clock cycle, but in parts.  If more formally: the validity signal inside the packet may be interrupted. </li><li>  Need to check more boundary conditions. </li><li>  If new pipeline stages are added (hence, its length increases), then you can forget to reduce the upper limit in <b>fifo_1</b> .  Or it is necessary somehow to calculate this border with the parameter, which can be nontrivial. </li></ul><br><h6>  <b><i>Stopping the conveyor during operation</i></b> </h6><br>  The previous options have a common feature: if the word of the package got to the beginning of the pipeline, then nothing can be done: through a constant number of ticks this word (or its modification) will fall into <b>fifo_1</b> . <br><br>  An alternative option is that the conveyor can be stopped during operation.  Each stage with the number M appears <b>ready</b> input, which shows whether stage M + 1 is ready to receive data or not.  At the entrance of the latest stage, the inversion is <b>full</b> or <b>almost_full</b> (if there is a desire to be safe a little). <br><br><img src="//habrastorage.org/files/2bf/550/eae/2bf550eae3ea46c3b3ce65507d8e11b7.png"><br><br>  <b>Pros</b> : <br><ul><li>  You can painlessly add new pipeline stages. </li><li>  Each stage may now have nuances in the work, but there is no need to redesign the architecture.  For example: we wanted to add some VLAN-tag to the packet before putting the packet in <b>fifo_1</b> .  VLAN-tag is 4 bytes, in our case - 4 words.  If the packets go one after the other, then in the first two cases, <b>arb</b> should have <b>realized</b> that after the end of the packet, it was necessary to pause 4 cycles, since  package will increase by 4 words.  In this case, everything will be adjusted by itself and the module that inserts the VLAN at the time of its insertion will set <b>ready</b> to zero at the stage of the pipeline that stands before it. </li></ul><br>  <b>Minuses:</b> <br><ul><li>  The code gets more complicated. </li><li>  During verification, it is necessary to check even more boundary conditions. </li><li>  Most likely it takes more resources than previous versions. </li></ul><br><br><h5>  Use standardized interfaces </h5><br>  The above problems can be resolved using interfaces that already contain auxiliary signals.  Altera for data streams suggests using Avalon Streaming interface ( <b>Avalon-ST</b> ).  Its detailed description can be found <a href="http://www.altera.com/literature/manual/mnl_avalon_spec.pdf">here</a> .  By the way, this interface is used in Alterovsky 10G / 40G / 100G Ethernet MAC cores. <br><br><img src="//habrastorage.org/files/cf8/4c3/444/cf84c3444ebe4646835e186ee18f2dda.png"><br>  Immediately draws attention to the presence of signals <b>valid</b> and <b>ready</b> , about which we spoke earlier.  The <b>empty</b> signal indicates the number of free (unused) bytes in the last word of the packet.  The <b>startofpacket</b> and <b>endofpacket signals</b> determine the beginning and end of the packet: it is convenient to use these signals to reset various counters that count offsets to get the necessary data. <br><br>  Xilinx proposes using the <b>AXI4-Stream</b> for this purpose. <br><br><img src="//habrastorage.org/files/c49/499/50c/c4949950c00c46e093d520c00dc35699.png"><br><br>  In general, the set of signals is similar (in this picture, not all signals are possible available in this standard).  To be honest, I have never used AXI4-Stream.  If someone has used both interfaces, I would appreciate if you share the comparison and impressions. <br><br>  I think the advantages of using standard interfaces should not be mentioned.  Well, the drawbacks are obvious: it is necessary to comply with the standard, which is expressed in more code, resources, tests, etc. Of course, you can make your bikes, but in the long run on a large project (and top-end chips) this can get sideways. <br><br><h4>  Bonus </h4><br>  As an example, it is more complicated than a pair of adders, I propose to make a module that in the Ethernet packet swaps the source and destination MAC addresses ( <b>mac_src</b> and <b>mac_dst</b> ).  This can be useful if you want all the traffic that comes to the device to send back (the so-called traffic invert / loop or loopback).  Implementation, of course, must be done with a pipeline. <br><br>  We use the <b>Avalon-ST</b> interface with a 64-bit data bus (for 10G) without <b>ready</b> and <b>error</b> signals.  As a test package, take the one that looked at <b>xgmii</b> in the previous <a href="http://habrahabr.ru/post/234369/">article</a> .  Then: <br><ul><li>  <b>mac_dst</b> - 00: 21: CE: AA: BB: CC (bytes 0 to 5).  Located in the 0 word in bytes 7: 2. </li><li>  <b>mac_src</b> - 00: 22: 15: BF: 55: 62 (bytes 6 to 11).  Is located in the 0 word in bytes 1: 0 and in 1 word in bytes 7: 4. </li></ul><br><br>  Code on SystemVerilog under the spoiler: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="vhdl hljs">module loop_l2( input clk_i, input rst_i, input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_i, input startofpacket_i, input endofpacket_i, input [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] empty_i, input valid_i, output logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_o, output logic startofpacket_o, output logic endofpacket_o, output logic [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] empty_o, output logic valid_o ); logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_d1; logic startofpacket_d1; logic endofpacket_d1; logic [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] empty_d1; logic valid_d1; logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_d2; logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] new_data_c; always_ff @( posedge clk_i <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> posedge rst_i ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( rst_i ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> data_d1 &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; startofpacket_d1 &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; endofpacket_d1 &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; empty_d1 &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; valid_d1 &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; data_o &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; startofpacket_o &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; endofpacket_o &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; empty_o &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; valid_o &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; data_d2 &lt;= '<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> data_d1 &lt;= data_i; startofpacket_d1 &lt;= startofpacket_i; endofpacket_d1 &lt;= endofpacket_i; empty_d1 &lt;= empty_i; valid_d1 &lt;= valid_i; data_o &lt;= new_data_c; startofpacket_o &lt;= startofpacket_d1; endofpacket_o &lt;= endofpacket_d1; empty_o &lt;= empty_d1; valid_o &lt;= valid_d1; data_d2 &lt;= data_d1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always_comb <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> new_data_c = data_d1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( startofpacket_d1 ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> new_data_c = { data_d1[<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>], data_i[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>], data_d1[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>] }; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( startofpacket_o ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> new_data_c[<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] = data_d2[<span class="hljs-number"><span class="hljs-number">5</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre><br></div></div><br>  Not everything is as scary as it might have seemed before: most of the lines went to the description of the inputs / outputs of the module and the delay line.  By <b>startofpacket, we</b> define in which word we are, and what data should be substituted into the <b>new_data_c</b> , which is then <b>clicked</b> into the <b>data_o</b> .  The <b>startofpacket</b> , <b>endofpacket</b> , <b>empty</b> , <b>valid</b> signals are delayed by the desired number of ticks. <br><br>  Module simulation: <br> <a href="http://http:"><img src="//habrastorage.org/files/908/8f0/ee0/9088f0ee047f4247bace500b96729d6c.png" width="944"><br></a> <br><br>  As you can see, the MAC addresses are swapped, and all other data in the package has not changed. <br><br>  In the next article, we will examine the <b>quadtree</b> : a more serious example of pipelining, where we use one of the architectural features of FPGA - block memory. <br><br>  Thanks for your time and attention!  If you have questions, ask without a doubt. <br><br><h4>  Bibliography </h4><br><ul><li>  <a href="http://www.amazon.com/Advanced-FPGA-Design-Architecture-Implementation/dp/0470054379">Advanced FPGA Design</a> is one of the best FPGA books I've ever seen.  Chapter 1 covers pipelining in detail.  IMHO, the book is for those who have already received some experience in FPGA development and want to systematize their knowledge or some intuitive guesswork. </li><li>  <a href="http://www.altera.com/support/software/timequest/sof-qts-timequest.html">TimeQuest Timing Analyzer</a> is an application for estimating the value of timings (including <b>Fmax</b> ) for Altera FPGAs. </li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS I</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> thank </font></font><a href="https://habrahabr.ru/users/des333/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des333</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for constructive criticism and advice.</font></font></div><p>Source: <a href="https://habr.com/ru/post/235037/">https://habr.com/ru/post/235037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../235021/index.html">YUI developers have announced the termination of further library development.</a></li>
<li><a href="../235023/index.html">Intel introduced its first 8-core processor for desktop computers</a></li>
<li><a href="../235031/index.html">Internet Archive will upload over 14 million free historical images to Flickr</a></li>
<li><a href="../235033/index.html">On e-bikes around Russia or in search of outlets outside the Moscow Ring Road</a></li>
<li><a href="../235035/index.html">Support for jQuery events has been added to Firefox Developer Tools.</a></li>
<li><a href="../235041/index.html">NSProxy, as a way to cut corners</a></li>
<li><a href="../235047/index.html">Samsung Unveils New Gear S Smart Watch and Gear Circle Headset</a></li>
<li><a href="../235049/index.html">ICANN gave green light to BEL</a></li>
<li><a href="../235055/index.html">Horace Dediu: what it means to be a professional analyst in the field of smartphones</a></li>
<li><a href="../235057/index.html">The beauty of the cosmos or how I read popular science lecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>