<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Model of Actors and C ++: What, Why and How?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a modified text version of the report of the same name from the C ++ CoreHard Autumn 2016 conference , which was held in Minsk last Oc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Model of Actors and C ++: What, Why and How?</h1><div class="post__text post__text-html js-mediator-article"><p>  This article is a modified text version of <a href="https://corehard.by/2016/10/25/actors-model-and-c-what-how-and-why/">the report of the same name from the C ++ CoreHard Autumn 2016 conference</a> , which was held in Minsk last October.  The desire to make this article arose under the impression that in the world of C ++, developers, as it were, are divided into two large and non-intersecting camps.  In the first camp, there are experienced specialists who have seen everything, everyone knows and can do everything, behind which are dozens of hand-written implementations of the Actor Model, inside of which are tricky, of course, self-made, lock-free queues and state-of-the-art message handling mechanisms.  Such professionals themselves can spend hours talking about the subtleties of multi-threaded programming (only for some reason they rarely do this).  In the second camp, green newbies, who by fate have brought into the world of C ++, who still have little idea of ‚Äã‚Äãthe differences between unique_ptr and shared_ptr, have only heard about patterns, and in the thread area they only have a superficial impression of std :: thread, std :: mutex and maybe std :: condition_variable.  For people from the first camp, I can hardly tell you anything interesting, but I‚Äôll try to briefly tell the developers from the second camp that the Actor Model in C ++ is normal.  And there are a number of ready-made tools, by the example of which you can see what it is. </p><a name="habracut"></a><br><h1>  Introduction </h1><br><p>  The talk will be about the Model of Actors and whether it should be used in C ++ programs and, if necessary, then what can be used to not reinvent your own bike.  We will speak about the Model of Actors as applied to the solution of problems of multithreading; therefore, the context should be narrowed so that there are no discrepancies. </p><br><p>  Multithreading, as a tool, is used in two very different directions.  The first is <a href="https://en.wikipedia.org/wiki/Parallel_computing">parallel computing</a> .  Multithreading is needed here for parallel execution of the same operations on different data blocks.  Thereby greatly reducing the time to solve a specific computational problem.  For example, transcoding a video file into one stream may take an hour.  And transcoding into four parallel streams is only 15 minutes. </p><br><p>  The second direction is <a href="https://en.wikipedia.org/wiki/Concurrent_computing">concurrent computing</a> .  Those.  simultaneous execution of many different operations.  For example, a multi-threaded DBMS server that simultaneously receives requests, makes plans for their execution, performs I / O operations, gives results to clients, updates statistics, etc.  Multithreading is needed here to ensure truly parallel execution of various operations.  Although, by and large, concurrency can be ensured even on one stream (so-called quasi-parallelism). </p><br><p>  And so further it will be a question of a multithreading with reference to concurrent computing.  For it is in this direction that the use of the Actor Model is fully justified. </p><br><h2>  What is so complicated about multithreaded programming? </h2><br><p>  One of the biggest difficulties in multithreading is the mutable shared state. </p><br><p>  As soon as we have an object that we need to modify from different streams, problems immediately begin.  The more threads, the smarter the scenarios of their work, the harder it is to imagine the intricacies of the interaction between them.  Hence, errors that are far from always easy to detect and fix. </p><br><h2>  How to simplify your life? </h2><br><p>  Do not divide anything.  <a href="https://en.wikipedia.org/wiki/Shared_nothing_architecture">The principle of shared nothing</a> , which is widely known in narrow circles. </p><br><p>  Instead of having N threads that compete with each other for resources, you can make M threads, each of which will own its own data.  None of the threads have access to the data of other threads. </p><br><p>  Great, but what if thread X needed some information that thread Y has?  Or if stream Y wants stream Z to update some data on itself? </p><br><p>  Hence, the threads must somehow interact with each other.  How? </p><br><p>  At first glance, it seems that there are two options: </p><br><p>  Or synchronously. <br>  Either asynchronously. </p><br><p>  However, synchronous interaction is not an option.  Synchronous interaction of independent threads is also the same work with shared data.  Only as shared data are the streams themselves. </p><br><p>  Asynchronous interaction remains. </p><br><h2>  We approach the model of actors from afar ... </h2><br><p>  How can we communicate workflows on messages?  For example, like this: </p><br><ul><li>  flow X sends a request message to flow Y; </li><li>  stream Y once receives a request for stream X and sends a response to stream X; </li><li>  stream Y sends an update message to stream Z; </li><li>  The Z stream will sometime receive an update message from the Y stream and update the data that belongs to the Z stream. </li></ul><br><p>  It turns out a picture in which there are threads, each thread has its own queue of incoming messages.  Each thread takes messages from its queue and processes them.  If the queue is empty, the thread sleeps until new messages arrive. </p><br><p>  If thread X needs something from another thread Y, then thread X puts the message on the incoming queue of thread Y. </p><br><blockquote><p>  A nice addition: if the messages transfer a copy of the data, and not a link to the original data somewhere in the shared memory, then a sudden bonus is obtained - a transparent transition to distribution. </p><br><p>  Indeed, if the flow Y gives all the necessary data to the message queue for Z, then it is no longer important whether the queue clears the flow Z in the same process, or it is the queue to send data to another network node.  The message is self-contained, so its contents can be serialized, transmitted over the network, deserialized and delivered to the receiver. </p></blockquote><br><p>  Here we are on the fingers and showed some of the basic principles of the Model Actors. </p><br><h1>  Actually, Model Actors.  In two or three words </h1><br><p>  The Model Actors appeared in 1973 thanks to the work of Carl Hewitt, and then it was developed in 1981 by William Clinger and in 1985 by Gul Agha. </p><br><p>  Model Actors several times attracted widespread attention.  The last wave of fame, according to a subjective impression, began to rise about 10-12 years ago.  At first this was facilitated by the Erlang programming language.  Then the Akka framework. </p><br><p>  Those who want to immerse themselves in the theoretical part of the Model Actors can start with the following review articles on Wikipedia and further links: </p><br><p>  <a href="https://en.wikipedia.org/wiki/History_of_the_Actor_model">History of the Actor Model</a> <br>  <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a> <br>  <a href="https://en.wikipedia.org/wiki/Actor_model_theory">Actor model theory</a> <br></p><br><p>  However, immersion in the theory of the Actor Model is a pure leap into Computer Science.  But I am not a scientist, but a software engineer in the past, a manager in the present, so I allow myself to concentrate only on practical aspects. </p><br><h2>  Model Actors "on the fingers" </h2><br><p>  If you do not go into the boring formal theory, the Actor Model is based on the following principles: </p><br><ul><li>  an actor is an entity with behavior; </li><li>  actors respond to incoming messages; </li><li>  having received the message the actor can: <br><ul><li>  send some (finite) number of messages to other actors; </li><li>  create a certain (finite) number of new actors; </li><li>  define for yourself a new behavior for processing subsequent messages. </li></ul></li></ul><br><p>  The principles are simple.  And, when you get used to them, the obvious.  However, one important point needs to be addressed separately.  This moment is very important, because  he explains why implementations of the Actor Model may look different and very different from each other. </p><br><h2>  More actors, good and different! </h2><br><p>  Actor is some kind of entity. </p><br><p>  The actor model does not say exactly how this entity should be implemented. </p><br><p>  Actor can be a separate process.  For example, this happens in Erlang, where every lightweight process inside an Erlang VM can be considered an actor. </p><br><p>  The actor can be a separate thread (OS thread, "green" thread, fiber, etc ...).  For example, goroutines in the Go language can also be considered as actors (with a stretch). </p><br><p> An actor can be a separate object that wanders from one working context to another.  For example, such are the actors in Akka and not only.  There may be implementations in which, in general, all actors work on the context of a single thread. </p><br><h1>  What is the Actor Model associated with now? </h1><br><h2>  Erlang </h2><br><p>  First of all - this is <a href="http://www.erlang.org/">Erlang</a> . </p><br><blockquote>  The irony is that I have never met Joe Armstrong saying that Model Actors influenced Erlang. <br></blockquote><br><p>  Erlang by itself.  As well as attempts to create languages ‚Äã‚Äãmore convenient for developers based on Erlang VM.  For example, <a href="http://elixir-lang.org/">Elixir</a> . </p><br><p>  The history of Erlang began back in 1986 in one of the laboratories of the company Ericsson.  Joe Armstrong experimented with Prolog for writing telephony software.  As a result of these experiments, Erlang appeared. </p><br><p>  In 1995, the unsuccessful development of the new telephone switch AX-N (by the way, in C ++) was closed in Ericsson.  In the new development, Erlang was used as the main language.  <a href="http://eao197.blogspot.com.by/2010/01/compprog-axd-301.html">The result was a successful software and hardware product AXD301, within which there were about a million (!) Lines of code in Erlang</a> . </p><br><p>  True, the story of Erlang in Ericsson developed in a paradoxical way.  Soon after the creation of the AXD301, the use of Erlang in the development of new products within Ericsson was prohibited.  Joe Armstrong retired from Ericsson, founded his company, the language of Erlang entered OpenSource. </p><br><p>  A few years later, when Erlang proved its worth while being in ‚Äúfree‚Äù navigation, the ban on Ericsson was lifted.  In 2004, Armstrong returns to Ericsson. </p><br><p>  Over the past 15 years, Erlang has proven its worth more than convincingly. <br>  A huge number of products developed by Erlang, a number of companies use Erlang as a key tool. </p><br><p>  For example, <a href="https://habrahabr.ru/post/276951/">whatsapp</a> . </p><br><p>  Many companies are convinced of the advantages of Erlang and begin to use it at home.  For example, Wargaming has formed a serious Erlang-development team (perhaps the most serious in the CIS) and is slowly re-educating Python sources for Erlang. </p><br><p>  Let's look at a small example of the simplest program on Erlang.  A classic example for the Model Actor is ‚Äúping-pong‚Äù: </p><br><pre><code class="erlang hljs"><span class="hljs-keyword"><span class="hljs-keyword">-module</span></span><span class="hljs-params"><span class="hljs-params">(tut15)</span></span>. -export([start/<span class="hljs-number"><span class="hljs-number">0</span></span>, ping/<span class="hljs-number"><span class="hljs-number">2</span></span>, pong/<span class="hljs-number"><span class="hljs-number">0</span></span>]). ping(<span class="hljs-number"><span class="hljs-number">0</span></span>, Pong_PID) -&gt; Pong_PID ! finished, io:format(<span class="hljs-string"><span class="hljs-string">"ping finished~n"</span></span>, []); ping(N, Pong_PID) -&gt; Pong_PID ! {ping, self()}, <span class="hljs-keyword"><span class="hljs-keyword">receive</span></span> pong -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"Ping received pong~n"</span></span>, []) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, ping(N - <span class="hljs-number"><span class="hljs-number">1</span></span>, Pong_PID). pong() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">receive</span></span> finished -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"Pong finished~n"</span></span>, []); {ping, Ping_PID} -&gt; io:format(<span class="hljs-string"><span class="hljs-string">"Pong received ping~n"</span></span>, []), Ping_PID ! pong, pong() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>. start() -&gt; Pong_PID = spawn(tut15, pong, []), spawn(tut15, ping, [<span class="hljs-number"><span class="hljs-number">3</span></span>, Pong_PID]).</code> </pre> <br><h2>  Akka </h2><br><p>  The second most famous ‚Äúicon‚Äù of the Model Actors is the <a href="http://akka.io/">Akka</a> framework for Scala and Java languages. </p><br><p>  The history of Akka can be started from the year 2006, when Philipp Haller (Philipp Haller) developed the implementation of the Actor Model for the Scala language.  This implementation is included in the standard Scala library. </p><br><p>  A few years later, when Scala and the actors from its standard library proved their viability, Jonas Boner (Jonas Bon√©r) <a href="http://www.lightbend.com/akka-five-year-anniversary">in 2008 began to create the Akka framework</a> , the first public version of which was released in the 2010th.  One of the significant differences between Akka and Scala standard library actors was that Akka supported both Scala and Java.  In this sense, it is noteworthy that the Lightbend company (formerly TypeSafe), which is behind Akka development and provides commercial support to Akka, has announced a shift in its focus from Scala in favor of Java. </p><br><p>  Akka is widely used in the field of Web and online services (for example, Twitter, LinkedIn).  The people behind Akka are involved in such modern buzz-words as <a href="http://www.reactivemanifesto.org/">Reactive Manifesto</a> and <a href="https://en.wikipedia.org/wiki/Microservices">Microservices</a> . </p><br><p>  Well, in order to make an impression about how the code looks using Akka, one of the ping-pong implementations for Akka on Scala (there are many such implementations, this one is found <a href="http://alvinalexander.com/scala/scala-akka-actors-ping-pong-simple-example">here</a> ): </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.actor._ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PingMessage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PongMessage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartMessage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StopMessage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ping</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">pong: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ActorRef</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementAndPrint</span></span></span><span class="hljs-function"> </span></span>{ count += <span class="hljs-number"><span class="hljs-number">1</span></span>; println(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function"> </span></span>= { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">StartMessage</span></span> =&gt; incrementAndPrint pong ! <span class="hljs-type"><span class="hljs-type">PingMessage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PongMessage</span></span> =&gt; incrementAndPrint <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &gt; <span class="hljs-number"><span class="hljs-number">99</span></span>) { sender ! <span class="hljs-type"><span class="hljs-type">StopMessage</span></span> println(<span class="hljs-string"><span class="hljs-string">"ping stopped"</span></span>) context.stop(self) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sender ! <span class="hljs-type"><span class="hljs-type">PingMessage</span></span> } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pong</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function"> </span></span>= { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PingMessage</span></span> =&gt; println(<span class="hljs-string"><span class="hljs-string">" pong"</span></span>) sender ! <span class="hljs-type"><span class="hljs-type">PongMessage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">StopMessage</span></span> =&gt; println(<span class="hljs-string"><span class="hljs-string">"pong stopped"</span></span>) context.stop(self) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PingPongTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> system = <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span>(<span class="hljs-string"><span class="hljs-string">"PingPongSystem"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pong = system.actorOf(<span class="hljs-type"><span class="hljs-type">Props</span></span>[<span class="hljs-type"><span class="hljs-type">Pong</span></span>], name = <span class="hljs-string"><span class="hljs-string">"pong"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ping = system.actorOf(<span class="hljs-type"><span class="hljs-type">Props</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Ping</span></span>(pong)), name = <span class="hljs-string"><span class="hljs-string">"ping"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// start them going ping ! StartMessage }</span></span></code> </pre><br><h1>  What is the strength in, brother? </h1><br><p>  Why did Erlang, Akka and other tools like them get so popular? </p><br><p>  Here it would be appropriate to quote from Joe Armstrong (the creator of the Erlang language): </p><br><blockquote>  It is also possible that it will be possible to make it possible to parallel programming. </blockquote><br><p>  What a rough retelling, but with preservation of the meaning of the above, may sound like: </p><br><p>  <i>I also suspect that the advent of true multi-core CPUs will make programming of parallel systems using traditional mutexes and shared data structures difficult to impossible, and that just message exchange will become the dominant way of developing parallel systems.</i> </p><br><p>  I note several key factors that explain the success of Erlang and Akka: </p><br><ul><li>  ease of development.  Using asynchronous messaging makes life a lot easier when you have to deal with concurrent computing; </li><li>  scaling.  Model Actors allows you to create a huge number of actors, each of which is responsible for their particular task.  The principle of shared nothing and asynchronous messaging allows you to build distributed applications, scaling horizontally as needed; </li><li>  fault tolerance.  Failure of one actor can be caught by other actors who take appropriate actions to restore the situation (for example, the mechanism of supervisors from Erlang). </li></ul><br><p>  But these are all secure languages ‚Äã‚Äãand managed environments. </p><br><p>  And, by the way, the issues of fault tolerance and safe languages ‚Äã‚Äãthat work in managed environments are quite strongly linked to each other.  So, if some lightweight process inside the Erlang VM is divided by zero, then the Erlang VM will simply close this process alone and this will not affect the performance of other processes.  However, if we take a multi-threaded application in C ++, which divides by zero in one of the threads, the entire application will crash. </p><br><p>  So the fact that in recent years, the Model of Actors has become popular primarily in safe languages, there are some objective factors. </p><br><h2>  Is there any sense in implementations of the Actor Model for the C ++ language? </h2><br><p>  To answer this question, you must first answer another question: is C ++ needed at all now? </p><br><p>  C ++ is an old language with a very long history.  Even if we count from the moment of the official release (autumn of 1985), then he is already more than thirty years old.  The name C ++ itself appeared in 1983, and work on the language began in 1979.  Those.  Soon we can talk about the forty-year history of the language. </p><br><p>  During this time, C ++ has incorporated many innovations and borrowings.  But it retained, at the same time, compatibility with a fair subset of C. </p><br><p>  Those.  became a real monster.  It is unlikely that there are more than a couple hundred people in the world, about whom it can be said that they know C ++. </p><br><p>  Using C ++ is difficult.  C ++ is often criticized.  Very often criticized deservedly. </p><br><p>  The development of such languages ‚Äã‚Äãas Java / Scala / C # on the one hand, the growing popularity of functional languages ‚Äã‚Äã(such as OCaml and Haskell) on the other, as well as the emergence of new and "modern" alternatives, like Go, supplanted C ++ from many application niches in which by the will of fate was in the 1980s and 1990s. </p><br><p>  Therefore, the last 15 years, the C ++ language has been regularly buried.  I myself 8 years ago seriously believed that C ++ has no future. </p><br><p>  However, C ++ is here.  Alive and well.  Successfully developed.  It becomes more of a monster than it was.  But, surprisingly, the more complex the C ++ language becomes, the easier it is to use in everyday work. </p><br><p>  If we put aside religious attachments, it is easy to see that there is only one native language without GC in the mainstream, which makes it easy to switch from the lowest level close to the hardware to the very high level, like OOP and generalized programming.  At the same time, this language is equipped with a wide range of tools, books and documentation, and various Internet resources.  Plus a huge number of developers all over the world. </p><br><p>  This language is C ++. </p><br><p>  Therefore, if we need to do something complex and / or large, if at the same time we are not indifferent to either the speed of the resulting product or its resource intensity, if we don‚Äôt have an infinite budget and have deadlines, then C ++ will have one or two alternatives miscalculated. </p><br><blockquote>  With all my interest in Rust-y, I think that it will take him several more years of intensive development to become mainstream.  But Swift cannot yet boast of cross-platform. </blockquote><br><p>  So whether we like it or not, but C ++ is still here.  And, apparently, will be here for a long time. </p><br><p>  And if so, and once in C ++, large and complex programs are developed, including those using multithreading, then why not simplify your life by using the Actor Model? </p><br><h2>  What is ready for C ++? </h2><br><p>  Let's see what for C ++ there is a ready-made implementation of the Actor Model.  In order not to reinvent the wheel and be able to take something in existence, instead of giving something of your own from scratch.  Well, or make sure that there is no implementation you need and it makes sense to kill a couple of person-years to create another solution. </p><br><p>  Generally speaking, there are not so many ready-made implementations of the Actor Model.  One of the lists can be found in Wikipedia: <a href="https://en.wikipedia.org/wiki/Actor_model">Actor Libraries and Frameworks</a> .  But there, unfortunately, not everything is listed and some of the projects no longer show signs of life. </p><br><p>  Below we look at several implementations that are clearly alive, healthy, not just showing signs of life, but also evolving in an evolutionary way.  In addition, these projects can boast portability across multiple platforms.  For example, for this reason, the review does not include the <a href="https://msdn.microsoft.com/en-us/library/dd492627.aspx">Asynchonous Agents Library from Microsoft</a> , which is available in Microsoft Visual Studio.  Also, <a href="http://www.oosmos.com/">OOSMOS</a> (sharpened primarily under pure C, and not under C ++) and <a href="https://github.com/smart-cloud/actor-zeta">actor-zeta</a> (which is still at an early stage of its development) did not get into the review. </p><br><h3>  QP / C ++ </h3><br><p>  Let's start with the <a href="http://www.state-machine.com/qpcpp/">QP / C ++ library</a> . </p><br><p>  QP / C ++ is a mature (more than 15 years of development) software under a dual license, designed for the development of embedded software, including real-time systems.  Including systems that can work directly on bare metal.  Including QP / C ++ partially complies with MISRA C ++ 2008.  From all this, and results in its specificity.  It is also the only framework in the review that is sufficiently C ++ 98. </p><br><p>  Actors in QP / C ++ are called active objects and are hierarchical finite automata.  Actor code can be typed as ordinary C ++ classes.  And you can draw an actor in a special tool for visual modeling and its code will be generated automatically. </p><br><p>  Active objects in QP / C ++ work on the context that QP allocates to them.  Depending on the environment, the active objects can each work on their own thread, or they can share a common working context. </p><br><p>  As an illustration, we will look at one of the examples from the QP composition, in which the LED on a device is periodically blinking. </p><br><p>  The source file blinky.h, which declares the actor and everything connected with it: <br></p><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> blinky_h #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> blinky_h using namespace QP; enum BlinkySignals { DUMMY_SIG = Q_USER_SIG, MAX_PUB_SIG, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// the last published signal TIMEOUT_SIG, MAX_SIG // the last signal }; extern QMActive * const AO_Blinky; // opaque pointer #endif // blinky_h</span></span></span></span></code> </pre><br><p>  The main.cpp file in which the actor's operation is initiated: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"qpcpp.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bsp.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"blinky.h"</span></span></span><span class="hljs-meta"> int main() { static QEvt const *blinkyQSto[10]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Event queue storage for Blinky BSP_init(); // initialize the Board Support Package QF::init(); // initialize the framework and the underlying RT kernel // instantiate and start the active objects... AO_Blinky-&gt;start(1U, // priority blinkyQSto, Q_DIM(blinkyQSto), // event queue (void *)0, 0U); // stack (unused) return QF::run(); // run the QF application }</span></span></span></span></code> </pre><br><p>  Well, the blinky.cpp file, in which the actor is implemented: </p><br><pre> <code class="hljs lua">#include <span class="hljs-string"><span class="hljs-string">"qpcpp.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"bsp.h"</span></span> #include <span class="hljs-string"><span class="hljs-string">"blinky.h"</span></span> class Blinky : public QActive { private: QTimeEvt m_timeEvt; public: Blinky(); protected: static QState initial(Blinky * const me, QEvt const * const e); static QState off(Blinky * const me, QEvt const * const e); static QState on(Blinky * const me, QEvt const * const e); }; Blinky l_blinky; QMActive * const AO_Blinky = &amp;l_blinky; // opaque pointer Blinky::Blinky() : QActive(Q_STATE_CAST(&amp;Blinky::initial)), m_timeEvt(this, TIMEOUT_SIG, <span class="hljs-number"><span class="hljs-number">0</span></span>U) {} QState Blinky::initial(Blinky * const me, QEvt const * const e) { (void)e; // unused parameter // arm the <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> event to expire <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> half a second <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> every half second me-&gt;m_timeEvt.armX(BSP_TICKS_PER_SEC/<span class="hljs-number"><span class="hljs-number">2</span></span>U, BSP_TICKS_PER_SEC/<span class="hljs-number"><span class="hljs-number">2</span></span>U); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Q_TRAN(&amp;Blinky::off); } QState Blinky::off(Blinky * const me, QEvt const * const e) { QState <span class="hljs-built_in"><span class="hljs-built_in">status</span></span>; switch (e-&gt;sig) { case Q_ENTRY_SIG: { BSP_ledOff(); <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = Q_HANDLED(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } case TIMEOUT_SIG: { <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = Q_TRAN(&amp;Blinky::on); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } default: { <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = Q_SUPER(&amp;QHsm::top); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">status</span></span>; } QState Blinky::on(Blinky * const me, QEvt const * const e) { QState <span class="hljs-built_in"><span class="hljs-built_in">status</span></span>; switch (e-&gt;sig) { case Q_ENTRY_SIG: { BSP_ledOn(); <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = Q_HANDLED(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } case TIMEOUT_SIG: { <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = Q_TRAN(&amp;Blinky::off); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } default: { <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = Q_SUPER(&amp;QHsm::top); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">status</span></span>; }</code> </pre><br><h3>  Just :: Thread Pro: Actors Edition </h3><br><p>  The next tool is <a href="http://www.stdthread.co.uk/pro/">Just :: Thread Pro: Actors Edition</a> . </p><br><p>  Paid library from Anthony Williams, very famous in C ++ world.  The author of the book "C ++ Concurrency in Action". </p><br><p>  Actually, the advantages of the library end there :) </p><br><p>  Each actor is allocated a separate OS thread.  Accordingly, the number of actors that it makes sense to create inside the application is very limited. </p><br><p>  As an illustration, look at the classic <a href="http://www.stdthread.co.uk/doc/headers/actor.html">ping-pong example</a> . </p><br><pre> <code class="hljs rust">#include &lt;jss/actor.hpp&gt; #include &lt;iostream&gt; #include &lt;thread&gt; int main() { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pingpong</span></span></span></span> { jss::actor_ref sender; pingpong(jss::actor_ref sender_): sender(sender_) {} }; jss::actor pp1( []{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { jss::actor::receive().<span class="hljs-keyword"><span class="hljs-keyword">match</span></span>&lt;pingpong&gt;( [](pingpong p){ std::cout&lt;&lt;<span class="hljs-string"><span class="hljs-string">"ping\n"</span></span>; p.sender.send(pingpong(jss::actor::<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>())); }); } }); jss::actor pp2( []{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { jss::actor::receive().<span class="hljs-keyword"><span class="hljs-keyword">match</span></span>&lt;pingpong&gt;( [](pingpong p){ std::cout&lt;&lt;<span class="hljs-string"><span class="hljs-string">"pong\n"</span></span>; p.sender.send(pingpong(jss::actor::<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>())); }); } }); pp1.send(pingpong(pp2)); std::this_thread::sleep_for(std::chrono::seconds(<span class="hljs-number"><span class="hljs-number">2</span></span>)); pp1.stop(); pp2.stop(); }</code> </pre><br><h3>  C ++ Actor Framework </h3><br><p>  The next tool is the <a href="http://www.actor-framework.org/">C ++ Actor Framework</a> .  He is CAF, he is libcppa in the recent past. </p><br><p>  OpenSource project under the BSD license. </p><br><p>  If you can talk about the most famous implementation of the Model Actors for C ++, then this is about CAF.  Perhaps there is no more expansive library on this topic for C ++. </p><br><p>  CAF copies Erlang to C ++ as closely as possible.  Therefore, if you know Erlang, you like Erlang, but you need to develop in C ++ and you would like to write in C ++ like Erlang, then you go straight to CAF. </p><br><p>  The price for mimicry under Erlang is CAF high requirements for the level of standards support in C ++ in the compiler.  Because of this, CAF developers have never considered Windows and VC ++ as one of the significant platforms for their development, limited to Linux, FreeBSD MacOS, as well as the latest versions of the gcc and clang compilers.  In addition, the authors of CAF have stated several times that they will continue to focus primarily on the most new features of the C ++ language and will switch to features from the new standards as quickly as possible. </p><br><p>  Note that CAF offers off-the-shelf tools for building distributed applications.  For this, CAF has its own protocol for communicating remote agents and the implementation of this protocol through Boost :: Asio. </p><br><p>  I have the most ambiguous impression of the CAF.  Written in CAF, the code looks very cool and succinct in tiny examples.  But it is not clear how convenient large and complex actors are implemented in CAFs. </p><br><p>  In addition, during the two and a half years that CAF looms in my field of view, several times it has been declared that there is a violation of compatibility when new CAF versions are released. </p><br><p>  Well, the developers of CAF also position it as a very smart framework, although some <a href="https://sourceforge.net/p/sobjectizer/wiki/Performance%2520Comparison%2520SO-5.5.15.2%2520vs%2520CAF-0.14.4/">have reasonable doubts</a> on this score;) </p><br><p>  As an illustration, you can cite the example code fixed_stack from the CAF itself. </p><br><pre> <code class="hljs kotlin">#include &lt;cassert&gt; #include &lt;cstdint&gt; #include &lt;iostream&gt; #include <span class="hljs-string"><span class="hljs-string">"caf/all.hpp"</span></span> using std::endl; using namespace caf; namespace { using pop_atom = atom_constant&lt;atom(<span class="hljs-string"><span class="hljs-string">"pop"</span></span>)&gt;; using push_atom = atom_constant&lt;atom(<span class="hljs-string"><span class="hljs-string">"push"</span></span>)&gt;; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fixed_stack_errc</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">uint8_t { push_to_full = 1</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">pop_from_empty }; error make_error</span></span></span></span>(fixed_stack_errc x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error{static_cast&lt;uint8_t&gt;(x), atom(<span class="hljs-string"><span class="hljs-string">"FixedStack"</span></span>)}; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fixed_stack</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public event_based_actor { public: fixed_stack</span></span></span></span>(actor_config&amp; cfg, size_t stack_size) : event_based_actor(cfg), size_(stack_size) { full_.assign( [=](push_atom, int) -&gt; error { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fixed_stack_errc::push_to_full; }, [=](pop_atom) -&gt; int { auto result = data_.back(); data_.pop_back(); become(filled_); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } ); filled_.assign( [=](push_atom, int what) { data_.push_back(what); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data_.size() == size_) become(full_); }, [=](pop_atom) -&gt; int { auto result = data_.back(); data_.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data_.empty()) become(empty_); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } ); empty_.assign( [=](push_atom, int what) { data_.push_back(what); become(filled_); }, [=](pop_atom) -&gt; error { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fixed_stack_errc::pop_from_empty; } ); } behavior make_behavior() <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> { assert(size_ &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> empty_; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: size_t size_; std::vector&lt;int&gt; data_; behavior full_; behavior filled_; behavior empty_; }; void caf_main(actor_system&amp; system) { scoped_actor self{system}; auto st = self-&gt;spawn&lt;fixed_stack&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span>u); <span class="hljs-comment"><span class="hljs-comment">// fill stack for (int i = 0; i &lt; 10; ++i) self-&gt;send(st, push_atom::value, i); // drain stack aout(self) &lt;&lt; "stack: { "; bool stack_empty = false; while (!stack_empty) { self-&gt;request(st, std::chrono::seconds(10), pop_atom::value).receive( [&amp;](int x) { aout(self) &lt;&lt; x &lt;&lt; " "; }, [&amp;](const error&amp;) { stack_empty = true; } ); } aout(self) &lt;&lt; "}" &lt;&lt; endl; self-&gt;send_exit(st, exit_reason::user_shutdown); } } // namespace &lt;anonymous&gt; CAF_MAIN()</span></span></code> </pre><br><h3>  SObjectizer </h3><br><p>  Well, the fourth framework, on which we dwell a little more - is <a href="https://sourceforge.net/projects/sobjectizer/">SObjectizer</a> . </p><br><p>  OpenSource project under BSD license. </p><br><p>  The project has been developing since 2002, although it is based on ideas that were developed and tested in the mid-90s when developing a small object-oriented SCADA system (the development of which, unfortunately, ended in the 2000th). </p><br><p>  SObjectizer has never been an experimental project, it was created specifically to simplify the development of multithreaded software in C ++.  Until now, software systems written on different versions of SObjectizer are in operation. </p><br><p>  Therefore, in SObjectizer great attention is paid to compatibility.  For example, in the fall of 2014, the SObjectizer version 5.5.0 was released.  Since then, more than twenty releases have passed under version 5.5, the last stable version has the number 5.5.18, but there have been no breaking changes.  So <a href="https://habrahabr.ru/post/304386/">SObjectizer is a project with a very long history</a> and a reverent attitude towards compatibility between versions. </p><br><p>  The actors in SObjectizer are called agents.  Just for historical reasons. </p><br><p>  As in QP / C ++, the agents in a SObjectizer are, as a rule, instances of individual C ++ classes.  As in QP / C ++, agents are hierarchical finite automata (including nested states, deep and shallow history, input / output handlers, time limits). </p><br><p>  As in QP / C ++, the working context is provided by the framework to agents.  For this, in SObjectizer there is such a thing as a dispatcher: a special entity that dispatches agent events.  The composition of SObjectizer includes eight types of controllers available to the developer out of the box.  Among them is such an interesting dispatcher, as adv_thread_pool, which allows you to simultaneously run event handlers of the same agent on different working threads if these handlers are marked as thread-safe. </p><br><p>  What makes SObjectizer very different from the projects listed above is the symbiosis of the Actor, Publish-Subscribe and Comminicating Sequential Processes models. </p><br><p>  In SObjectizer, messages are not sent directly to recipient agents, but to mboxes (mailboxes).  And already from mbox, messages are delivered to those agents that are subscribed to it.  Thus, mboxes in SObjectizer work as Topic-and in the model of Publish-Subscribe.  Sending a message to mbox is like a Publish operation.  Agents must perform a Subscribe operation to receive messages of interest to them. </p><br><p>  This is what SObjectizer does not provide right now, so these are ready-made tools for building distributed applications.  Such tools were in earlier versions of SObjectizer, but over time, for a number of objective reasons, they were abandoned and, starting from 2010, there are no similar tools in the core of SObjectizer.  The user chooses which communication layer is more convenient for him to use - be it REST, MQTT, CoAP, AMQP or something else. </p><br><p>  As an illustration, we will show the implementation of the CAF example of fixed_stack, <a href="https://bitbucket.org/sobjectizerteam/fixed_stack_example">but on SObjectizer</a> (actually, personally this example seems strange to me, to say the least, not to say stupid, because there is no practical sense in creating such actors from the word, but since SObjectizer is often asked to compare it with the CAF, then let it be just such an example): </p><br><pre> <code class="hljs rust">#include &lt;iostream&gt; #include &lt;so_5/all.hpp&gt; class fixed_stack final : public so_5::agent_t { state_t st_empty{ this }, st_filled{ this }, st_full{ this }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> size_t m_max_size; std::vector&lt; int &gt; m_stack; public : class empty_stack final : public std::logic_error { public : using std::logic_error::logic_error; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">push</span></span></span></span> { int m_val; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pop</span></span></span></span> : public so_5::signal_t {}; fixed_stack( context_t ctx, size_t max_size ) : so_5::agent_t( ctx ) , m_max_size( max_size ) { this &gt;&gt;= st_empty; so_subscribe_self() .<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>( st_empty ) .<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>( st_filled ) .event( &amp;fixed_stack::on_push ); so_subscribe_self() .<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>( st_filled ) .<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>( st_full ) .event( &amp;fixed_stack::on_pop_when_not_empty ); so_subscribe_self() .<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>( st_empty ) .event( &amp;fixed_stack::on_pop_when_empty ); } private : void on_push( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> push &amp; w ) { m_stack.push_back( w.m_val ); this &gt;&gt;= ( m_stack.size() == m_max_size ? st_full : st_filled ); } int on_pop_when_not_empty( mhood_t&lt; pop &gt; ) { auto r = m_stack.back(); m_stack.pop_back(); this &gt;&gt;= ( m_stack.empty() ? st_empty : st_filled ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } int on_pop_when_empty( mhood_t&lt; pop &gt; ) { throw empty_stack( <span class="hljs-string"><span class="hljs-string">"empty_stack"</span></span> ); } }; int main() { try { so_5::launch( []( so_5::environment_t &amp; env ) { so_5::mbox_t stack; env.introduce_coop( [&amp;stack]( so_5::coop_t &amp; coop ) { stack = coop.make_agent&lt; fixed_stack &gt;( <span class="hljs-number"><span class="hljs-number">5</span></span>u )-&gt;so_direct_mbox(); } ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i ) so_5::send&lt; fixed_stack::push &gt;( stack, i ); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"stack { "</span></span>; try { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) std::cout &lt;&lt; so_5::request_value&lt; int, fixed_stack::pop &gt;( stack, std::chrono::seconds(<span class="hljs-number"><span class="hljs-number">10</span></span>) ) &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; } catch( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fixed_stack::empty_stack &amp; ) {} std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"}"</span></span> &lt;&lt; std::endl; env.stop(); } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } catch( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> std::exception &amp; x ) { std::cerr &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Oops! "</span></span> &lt;&lt; x.what() &lt;&lt; std::endl; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre><br><h1>  Conclusion </h1><br><p>  The Actor Model is a very convenient tool in cases where the use of this model is appropriate.  This has been repeatedly proven by the successful use of tools such as Erlang and Akka in a wide variety of projects.           .    ,    . </p><br><p> <i>   :      .</i> </p><br><p>   ,             C++.    C++    .     . </p><br><p>   ,  .     QP/C++   Just::Thread Pro  .  SObjectizer  CAF ‚Äî .      . </p><br><p>     ,        . </p><br><p>   .   .  -  - . </p><br><p>   -       :) </p><p></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322250/">https://habr.com/ru/post/322250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322240/index.html">YaBB - forum of the XX century</a></li>
<li><a href="../322242/index.html">Premature architecture optimization</a></li>
<li><a href="../322244/index.html">Secure routing: solution out of the box (webinar)</a></li>
<li><a href="../322246/index.html">Classification of data. Monitoring the use of critical information on file servers</a></li>
<li><a href="../322248/index.html">Physical backup: Veeam Endpoint Backup replaces Veeam Agent for Microsoft Windows</a></li>
<li><a href="../322252/index.html">What questions to ask at the interview</a></li>
<li><a href="../322254/index.html">Examples of how partners lose money when collaborating with CPA networks</a></li>
<li><a href="../322256/index.html">Why Kotlin sucks</a></li>
<li><a href="../322258/index.html">We write game logic in C #. Part 1/2</a></li>
<li><a href="../322262/index.html">Mustached shooter of twenty-three polygons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>