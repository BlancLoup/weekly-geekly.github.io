<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>learnopengl. Lessons 3.1 (Assimp) + 3.2 (Mesh class)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Assimp 
 In all the lessons, we mostly used our little friend - the container, but after a while, even our best friends become a bit boring. In a larg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>learnopengl. Lessons 3.1 (Assimp) + 3.2 (Mesh class)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="Ogl3" align="left" width="300"><h3>  <b>Assimp</b> </h3><br>  In all the lessons, we mostly used our little friend - the container, but after a while, even our best friends become a bit boring.  In a large graphic application, there are usually many models that are much more pleasant to look at than our static container.  Although, unlike the container, it will be very difficult for us, manually, to determine all the vertices, normals and textural coordinates of such complex models as, for example, a house or human-like characters.  Instead, we will import the models into our application;  models that have been carefully drawn in 3D editors such as Blender, 3DS MAX or Maya. <br><br><div class="spoiler">  <b class="spoiler_title">Menu</b> <div class="spoiler_text"><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting <br><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br></div></div><br>  These so-called 3D modeling tools allow artists to create complex models and apply textures to them using a process called texture mapping (uv-mapping).  The tools automatically generate all vertex coordinates, normal vertices and texture coordinates, exporting them to a model file.  Thus, artists have an extensive set of tools for creating high-quality models without worrying about technical details.  All technical aspects are hidden in the exported file.  We, as graphics programmers, need to take care of these technical details. <br><a name="habracut"></a><br>  So our job is to analyze these exported model files and extract all the relevant information so that we can store them in a format that OpenGL understands.  However, a common problem is that there are dozens of different file formats, each of which exports these models in its own unique way.  Wavefront model formats like <a href="https://ru.wikipedia.org/wiki/Obj">.obj</a> contain only model data with little material information, such as color models or diffuse / specular maps, while model files based on XML are extremely extensive and contain models, lighting, a lot of material information , animation and more.  The obj format is considered to be easily analyzed.  It is recommended to get acquainted with the structure of the file, for example, on a page on Wikipedia.  This should give you basic information about how to store the model in an obj format file. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, there are many different formats where the stored data structure is different.  Therefore, if we want to import a model from these files, we need to write the importer ourselves, for each format we want to import.  Fortunately for us, for this there is a library. <br><br><h3>  Library for loading models </h3><br>  Assimp is a very popular library for importing models, which stands for Open Asset Import Library.  This library can import many different formats that contain models, saving the data that is imported in a simple hierarchical data structure.  As soon as Assimp finishes loading the models, we will be able to get all the data we need from this structure.  No matter what file format we import, the data access in the structures does not change, the structure remains the same for all the different file formats. <br><br>  When importing a model using Assimp, the library loads the entire model into a scene object (Scene) containing all the data of the imported model.  Assimp then creates a collection of nodes, where each node contains indexes to the data stored in the scene object, each node can have a descendant.  A simple model of the structure of Assimp is presented below: <br><div style="text-align:center;"><img src="https://habrastorage.org/web/fa0/227/276/fa02272769f0488e8deb5720338b49fe.png" alt="image"></div><br><ul><li>  All model data is contained in the Scene object, as well as data on materials and polygonal mesh.  The scene also contains a link to the root node of the scene. </li><li>  The Root node can have children (Child nodes) (as well as other nodes) and can have indices that indicate polygon mesh data stored in an array of the mMeshes scene object.  The mMeshes array of the root node contains specific polygon mesh objects, and the values ‚Äã‚Äãin the mMeshes array for any descendant are only indices for sampling the array of the root node grids. </li><li>  The polygon mesh object contains all the relevant data needed for drawing: vertex coordinates, normal vectors, texture coordinates, faces, and material information for the object. </li><li>  A polygonal mesh (mesh) contains several faces.  Faces are the primitives of an object (triangles, squares, points).  They contain vertex indices that make up the primitives.  Since we have vertices and their indices, drawing is much easier thanks to element buffer objects ( <a href="https://habrahabr.ru/post/311808/">Hello Triangle</a> ) </li><li>  Also, a polygonal mesh contains an index on a material object (Material), which has several functions for obtaining material properties. </li></ul><br>  And so, we first need to load our object into the scene object, recursively retrieve the corresponding polygon mesh objects from each of the nodes (recursively traversing the descendants of each node) and process each element of the polygonal mesh to extract vertices, indices and material properties.  The result is a collection of polygonal meshes that we will contain in the Model object. <br><br><blockquote>  Mesh - a set of vertices and triangles <br>  A single mesh (Mesh) is the minimum data set required for output by means of OpenGL (vertex, index, material) data.  The model, however, usually consists of several grids.  When modeling objects in special programs (Blender, 3D max), artists do not create a whole model from a single form.  Usually, each model has several sub-models / forms of which it consists.  Think of a person as a model: the artist usually models the head, limbs, clothing, weapons, all as separate components, then combining all the sub-models, gets the original. </blockquote><br>  In the following lessons, we will create our own Model and Mesh classes that load and store imported models using the structure we just described.  If we want to draw a model, then we do not derive it entirely, but carry out the derivation of each of the grids making up the model separately.  Before we can import the models, we need to first include Assimp in our project. <br><br><h3>  Build assimp </h3><br>  You can download Assimp from this <a href="http://assimp.org/main_downloads.html">page</a> by selecting the appropriate version.  At the time of writing, the latest version of Assimp was 3.1.1.  It is recommended to compile the libraries yourself, as their precompiled libraries do not work on most systems.  Review the <a href="https://habrahabr.ru/post/311198/">Create Window</a> lesson if you forgot how to compile the library yourself using CMake. <br><br>  Several problems appeared during the build of Assimp, so I‚Äôll mark them here, with their solutions in case any of you get the same errors: <br><br><ul><li>  CMake gives errors about missing DiretX libraries, such as: <br>  <i>Could not locate DirectX</i> <i><br></i>  <i>CMake Error at cmake-modules / FindPkgMacros.cmake: 110 (message):</i> <i><br></i>  <i>Required library DirectX not found!</i>  <i>Install the library (including dev packages)</i> <i><br></i>  <i>and try again.</i>  <i>If the library is already installed</i> <i><br></i>  <i>manually in cmake.</i> <br>  You need to install DirectX SDK, in case it has not been installed.  You can download the SDK <a href="http://www.microsoft.com/en-us/download/details.aspx%3Fid%3D6812">here</a> . </li><li>  During installation, the DirectX SDK pops up error code s1023. <br>  In this case, you first need to install the C ++ package, before installing the SDK, <br>  as described <a href="https://blogs.msdn.microsoft.com/chuckw/2011/12/09/known-issue-directx-sdk-june-2010-setup-and-the-s1023-error/">here</a> . </li></ul><br><ul><li>  After setup is complete, you can create a project file, open it, and compile libraries. </li><li> By default, Assimp is provided as a dynamic library, so we need to include in the project a corresponding dll named assimp.DLL.  You can simply file the DLL in the same folder as the executable file of the application. </li><li>  After compilation, the library and its dll file will be located in the code / Debug or code / Release folders. </li><li>  Then simply link the library file and the dll file with your project, and make sure that you also remember to include the Assimp header files. </li></ul><br><blockquote>  If you want to use multithreading to increase performance, you can build Assimp with Boost.  Full instructions are <a href="http://assimp.org/lib_html/install.html">here</a> . </blockquote><br>  At this point, you had to compile Assimp and inject it into your application. <br><br><h3>  Mesh class </h3><br>  Using Assimp, we can load many different models into our application, but after downloading, the data is still stored in the Assimp structure.  We need to convert this data to a format that OpenGL understands, so that we can draw the model.  In the previous lesson, we learned that a polygonal mesh is a single drawable entity, so let's start by defining our own Mesh class. <br><br>  Let's think about what data set we need for our class.  A polygonal mesh needs a set of vertices, where each vertex contains a position vector, a normal vector and a vector of texture coordinates.  Polygonal mesh should also contain indexes <br>  for indexed rendering, and data for materials. <br><br>  Now, we can define the structure of the vertex: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> glm::vec3 Position; glm::vec3 Normal; glm::vec2 TexCoords; };</code> </pre> <br>  Each vertex is stored in a Vertex structure, which can be used to index each vertex.  In addition to the Vertex structure, we also need to create a structure that stores texture data. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Texture</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> type; };</code> </pre> <br>  It stores id and texture type (diffuse or specular). <br><br>  Having written the structures, you can start writing our class: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mesh</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* Mesh Data */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Vertex&gt; vertices; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indices; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; textures; <span class="hljs-comment"><span class="hljs-comment">/* Functions */</span></span> Mesh(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Vertex&gt; vertices, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indices, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; textures); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader shader)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* Render data */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VAO, VBO, EBO; <span class="hljs-comment"><span class="hljs-comment">/* Functions */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupMesh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; };</code> </pre> <br>  As you can see, the class is not very complicated.  The constructor takes all the data we need, in the setupMesh method we initialize the buffers, in the Draw method we will draw our polygonal mesh.  Notice that the draw function takes a shader object so that we can set the corresponding uniform variables to draw. <br><br>  The constructor code is quite simple, we simply assign the class arguments, the corresponding arguments.  We also call the setupMesh function: <br><br><pre> <code class="cpp hljs">Mesh(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Vertex&gt; vertices, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indices, <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Texture&gt; textures) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;vertices = vertices; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;indices = indices; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;textures = textures; setupMesh(); }</code> </pre> <br>  As you can see, nothing unusual happens here.  Next, go to the setupMesh function. <br><br><h3>  Initialization </h3><br>  Thanks to the constructor, we have all the data we need that we can use to draw.  However, we first need to configure the appropriate buffers.  At this point you should have no problems with these concepts, but perhaps we will surprise you a little how to transfer data to the buffer that is in the structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupMesh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;EBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, vertices.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vertex), &amp;vertices[<span class="hljs-number"><span class="hljs-number">0</span></span>], GL_STATIC_DRAW); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), &amp;indices[<span class="hljs-number"><span class="hljs-number">0</span></span>], GL_STATIC_DRAW); <span class="hljs-comment"><span class="hljs-comment">// vertex positions glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0); // vertex normals glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)); // vertex texture coords glEnableVertexAttribArray(2); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords)); glBindVertexArray(0); }</span></span></code> </pre> <br>  The code is not much different than what you expected, but a few small tricks were used using the Vertex structure. <br><br>  In C ++, structures have an excellent property ‚Äî their memory is consistent.  That is, if we presented a structure as an array of data, then it would contain variables in the order in which they are defined in the structure itself.  For example, if we fill the Vertex structure with some values, then their placement in memory will be: <br><br><pre> <code class="cpp hljs">Vertex vertex; vertex.Position = glm::vec3(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>); vertex.Normal = glm::vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); vertex.TexCoords = glm::vec2(<span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>); <span class="hljs-comment"><span class="hljs-comment">// = [0.2f, 0.4f, 0.6f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f];</span></span></code> </pre> <br>  Thanks to this property, for example, if we apply the sizeof function to our structure, it will return the size of all the arguments that are defined in it.  It should weigh 32 bytes. <br>  (8 * 4 - size 1 float).  We can use this for the glBufferData function: <br><br><pre> <code class="cpp hljs">glBufferData(GL_ARRAY_BUFFER, vertices.size() * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vertex), vertices[<span class="hljs-number"><span class="hljs-number">0</span></span>], GL_STATIC_DRAW);</code> </pre> <br>  We also use the offsetof macro, which takes the structure as the first argument, and the name of the structure variable as the second.  And it returns the offset in bytes of the specified structure, to the variable passed in the second argument.  This is ideal for determining the last parameter of the glVertexAttribPointer function: <br><br><pre> <code class="cpp hljs">glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Vertex), (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)offsetof(Vertex, Normal));</code> </pre> <br>  The offset is now determined using the macro offsetof, which, in this case, sets the byte offset for the normal vector.  Please also note that we specify a step size equal to the size of the structure. <br><br>  Using this structure not only provides more readable code, but also allows us to expand it in the future.  If we want to use some other vertex art attribute, we can easily add it to our structure, and because of its flexibility, the code will not break. <br><br><h3>  Drawing </h3><br>  The last function we need to write is Draw.  But before drawing our polygons, we first need to bind our textures before calling the glDrawElements function.  However, it is a bit hard, because  we don‚Äôt know how much texture (if any) we have and what type they are.  And also, how to set texture units and texture objects in a shader? <br><br>  To solve this problem, we will adopt some naming conventions: each diffuse texture is called texture_diffuseN, and each highlight texture map must be called texture_specularN, where N is any number starting from 1 to the maximum number of allowed textures.  Suppose we have 3 diffuse textures and 2 specular textures for a particular polygonal mesh, we must define them like this: <br><br><pre> <code class="cpp hljs">uniform sampler2D texture_diffuse1; uniform sampler2D texture_diffuse2; uniform sampler2D texture_diffuse3; uniform sampler2D texture_specular1; uniform sampler2D texture_specular2;</code> </pre> <br>  Thanks to this agreement, we can define as many texture objects as we want, and if the polygonal mesh does contain a lot of textures, we know what their names will be.  We can process any number of textures on a single polygonal mesh and the developer can freely use as many textures as he wants, simply by defining additional texture objects in the shader. <br><br><blockquote>  Besides this solution, there are also many others, and if you don‚Äôt like it, you can show your creative ability and come up with your own solution. </blockquote><br>  Draw method code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader shader)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diffuseNr = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> specularNr = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; textures.size(); i++) { glActiveTexture(GL_TEXTURE0 + i); <span class="hljs-comment"><span class="hljs-comment">//   ,   //    stringstream ss; string number; string name = textures[i].type; if(name == "texture_diffuse") ss &lt;&lt; diffuseNr++; //  unsigned int  stream else if(name == "texture_specular") ss &lt;&lt; specularNr++; //  unsigned int  stream number = ss.str(); shader.setFloat(("material." + name + number).c_str(), i); glBindTexture(GL_TEXTURE_2D, textures[i].id); } glActiveTexture(GL_TEXTURE0); //    glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0); glBindVertexArray(0); }</span></span></code> </pre> <br>  This is not the most beautiful code, but C ++ is partly to blame for this, since, for example, there is no such type conversion as int into string.  We go over the N-textures and define the assignment of their types to a string variable, so that we would then have an idea what the number of the specific texture type is.  Next, we find out the number of our texture object, and finally, we set to this texture object the number corresponding to the active texture unit and bind the texture.  Notice that we are going to store textural objects in the Material structure, as we usually did. <br><br><blockquote>  Please note that by increasing the diffuse and specular counters, we immediately transfer them to stringstream.  The right increment in C ++ increases the value by 1, but returns the old value. </blockquote><br>  You can find the full code for the Mesh class <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dincludes/learnopengl/mesh.h">here</a> . <br><br>  In the next lesson, we will create a Model class that works as a container for objects of the Mesh class and actually implements the Assimp boot interface. </div><p>Source: <a href="https://habr.com/ru/post/338436/">https://habr.com/ru/post/338436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338426/index.html">Three ideas on how to improve development efficiency: the results of the hackathon for Machine Learning in SberTech</a></li>
<li><a href="../338428/index.html">How we teach AI to help find employees</a></li>
<li><a href="../338430/index.html">REQ Labs 2017. Online conference for business and system analysts</a></li>
<li><a href="../338432/index.html">Uptime day 2: Russian IT companies will talk about how to cope with disasters</a></li>
<li><a href="../338434/index.html">Oblique frustum. Inside the oblique visibility pyramid</a></li>
<li><a href="../338438/index.html">Storage Recycling Analysis</a></li>
<li><a href="../338440/index.html">Library of quick path search on the graph</a></li>
<li><a href="../338442/index.html">Stages of development of the Java Online Projects learning project: how it was, an inside look</a></li>
<li><a href="../338444/index.html">VEDO. External electronic document management what it is and how to choose</a></li>
<li><a href="../338450/index.html">How to run your project on Product Hunt: Administration Guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>