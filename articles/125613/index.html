<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>StructureMap - quick reference for work (1/3)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I want to talk about the IoC container StructureMap (and this is not a translation of outdated official documentation), which I liked much more ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>StructureMap - quick reference for work (1/3)</h1><div class="post__text post__text-html js-mediator-article">  Today I want to talk about the IoC container StructureMap (and this is not a translation of outdated official documentation), which I liked much more than Unity.  Although, to be honest, my relationship with Unity did not work out from the very beginning, when I saw kilometer configuration files for it or two hundred character configuration lines in code.  Let's not talk about sad things. <br><br>  StructureMap not only seemed to me more convenient than other <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BA%25D0%25BE%25D0%25BD%25D1%2582%25D1%2580%25D0%25BE%25D0%25BB%25D1%258F">DI \ IoC</a> implementations, it‚Äôs enough to go to StructureMap vs Unity in Google and get a bunch of links where people discuss and show clearly that StructureMap is the most convenient, flexible and natural in work. <br><br>  Link <a href="http://stackoverflow.com/questions/411660/enterprise-library-unity-vs-other-ioc-containers">one</a> , <a href="http://stackoverflow.com/questions/21288/which-net-dependency-injection-frameworks-are-worth-looking-into">two</a> and <a href="http://weblogs.asp.net/gunnarpeipman/archive/2010/09/21/unity-castle-windsor-structuremap-ninject-who-has-best-performance.aspx">three</a> .  Everything else StructureMap is also quite fast. <br>  Here are some very interesting collections of materials comparing the <a href="http://www.sturmnet.org/blog/2010/03/04/poll-results-ioc-containers-for-net">http://www.sturmnet.org/blog/2010/03/04/poll-results-ioc-containers-for-net</a> frameworks 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I think you can omit the argument about whether to use such containers in your project or not, and whether to write your own implementation.  I can say that in my practice, at first it happened that there were self-written implementations that were noticeably inferior in terms of capabilities and convenience, but they solved their specific tasks and this was enough at that time.  With the development of the project, somehow there was no time to transfer everything to some other technology.  Then there was Unity, Unity, but in the end I came to the conclusion that I should try StructureMap and did not regret it even once. <br><br>  What are, in my opinion, the advantages of StructureMap: <br><ul><li>  DSL Setup </li><li>  Very flexible customization of everything </li><li>  Ease of end use </li><li>  Opportunities to test internal communications </li><li>  Out-of-the-box testing support </li></ul><br>  There are many more interesting and useful things in StructureMap, but it would be wrong to attribute them to pluses, it would be better to call them a pleasant addition, which only make life easier. <br><a name="habracut"></a><br>  A brief outline of the subsequent material is as follows: <br><ul><li>  Installation </li><li>  Registration (Base, Profiles, Plugins, Crawl, Deployment) </li><li>  Constructors (Simple Types, Default Constructor, Compound Types, Type Casting, Specifying Arguments) </li><li>  Properties (Simple setting of properties, Built-in setting of properties, Setting properties by a framework, Finishing existing classes) </li><li>  Lifetime </li><li>  Interceptors (OnCreation, EnrichWith) </li><li>  Generic types </li><li>  Attributes (DefaultConstructor, ValidationMethod, All others) </li><li>  Tests </li></ul><br><br><h1>  Installing StructureMap </h1><br>  I recommend installing StructureMap in my application using NuGet.  A single command in the Package Manager Console (install-Package StructureMap) or search and install using a wizard is the easiest way to get.  But if you want, you can download the project from the official page <a href="http://github.com/structuremap/structuremap/downloads">http://github.com/structuremap/structuremap/downloads</a> <br><br><br><h1>  check in </h1><br>  The most important action probably for any IoC container is registration.  The extent to which it is convenient and clear depends on whether people will use it and how likely the tool will be misused. <br><br>  The author advises to use DSL as widely as possible and resort to the configuration file only when you need to separately specify connection strings, URL addresses, file paths and everything else in the same spirit. <br><br>  Let's start with the simplest, registering a class with a default constructor. <br><br>  Suppose we have such a simple set of classes: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IClass</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IClass1</span></span> : <span class="hljs-title"><span class="hljs-title">IClass</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IClass2</span></span> : <span class="hljs-title"><span class="hljs-title">IClass</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class1</span></span> : <span class="hljs-title"><span class="hljs-title">IClass1</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class2</span></span> : <span class="hljs-title"><span class="hljs-title">IClass2</span></span> {}</code> </pre> <br>  This set will be for the time being the main one for demonstrating the possibilities.  But you do not worry, further classes and connections will be more difficult, because in such classes you will not show much either. <br><br><br><h2>  The foundation </h2><br>  Registration is possible using a <strong>Container</strong> , using a static <strong>ObjectFactory</strong> class <strong>,</strong> or using the <strong>Registry</strong> class.  Gradually consider registering using all of these objects.  The main class for registration is Registry, the rest of the classes prokidyvat its functionality, for convenience. <br><br>  Registration using the static ObjectFactory class. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RegisterByObjectFactory</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterByObjectFactory</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ObjectFactory.Initialize(x =&gt; { x.For&lt;IClass1&gt;().Use&lt;Class1&gt;(); x.For&lt;IClass2&gt;().Use&lt;Class2&gt;(); }); } }</code> </pre> <br>  Everything is done using DSL and lambda expressions.  DSL itself is quite concise and clear, the resulting code easily folds up into meaningful expressions.  In this case, you can easily read that <em>you must use</em> <em>Class1</em> <em>for the</em> <em>IClass1</em> <em>interface</em> . <br><br>  Obtaining objects can be done in the following way, also intuitive: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectFactoryExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegisterByObjectFactory(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class1Inst = ObjectFactory.GetInstance&lt;IClass1&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class2Inst = ObjectFactory.GetInstance&lt;IClass2&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjectFactory.WhatDoIHave(); }</code> </pre> <br>  The main method for getting a GetInstance object, in this case, specifying an interface.  Next, we will consider various ways to get ready-made objects.  You may notice that the method returns the string that we get from the method with the talking name <strong>WhatDoIHave</strong> .  Using this method, you can diagnose the internal organs of the container, see what, how and where it is registered. <br><br>  For a long time, the framework author could not accept the term container in relation to his brainchild, so the following method was hidden for quite a long time and only in later implementations discovered the natural course of registration, as it was implemented inside, behind the static class.  So, <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RegisterByContainer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterByContainer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; { x.For&lt;IClass1&gt;().Use&lt;Class1&gt;(); x.For&lt;IClass2&gt;().Use&lt;Class2&gt;(); }); } }</code> </pre> <br>  At first glance, everything is the same, lambda is the same, but now we are creating a class, which we will then give out, and by which we will turn to the container.  Those.  again, ObjectFactory is just a static wrapper class over a Container class. <br><br>  Obtaining objects will follow the same scenario: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContainerExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegisterByContainer().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class1Inst = container.GetInstance&lt;IClass1&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class2Inst = container.GetInstance&lt;IClass2&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container.WhatDoIHave(); }</code> </pre> <br>  The next object in turn is the <strong>Registry</strong> .  Actually, you indirectly called him all the previous times.  For a change we will register specific classes. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RegisterByRegister</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterByRegister</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> registry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Registry(); registry.ForConcreteType&lt;Class1&gt;(); registry.ForConcreteType&lt;Class2&gt;(); Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.AddRegistry(registry)); } }</code> </pre> <br>  In this case, the <strong>ForConcreteType</strong> method is <strong>used</strong> , which is a synonym for <strong>.</strong>  <strong>For &lt;</strong> <strong>T&gt; ().</strong>  <strong>Use &lt;</strong> <strong>T&gt; ()</strong> .  You can also see that the Registry class can be used as a sub-container, assemble it and then transfer to the assembly in one container.  In this case, the addition of the Registry at the time of its creation is illustrated, but nothing prevents to write: <br><pre> <code class="cs hljs">Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(); Container.Configure(x =&gt; x.AddRegistry(registry));</code> </pre> <br>  Reading "concrete" classes is no different from the usual: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConcreteClassExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegisterByRegister().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class1Inst = container.GetInstance&lt;Class1&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class2Inst = container.GetInstance&lt;Class2&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container.WhatDoIHave(); }</code> </pre> <br><br><h2>  Profiles </h2><br>  StructureMap allows you to group class mappings using named profiles.  Those.  You can quickly switch between mapping classes. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RegisteringProfiles</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisteringProfiles</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> registry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Registry(); registry.Profile(<span class="hljs-string"><span class="hljs-string">"p1"</span></span>, x =&gt; x.For&lt;IClass&gt;().Use&lt;Class1&gt;()); registry.Profile(<span class="hljs-string"><span class="hljs-string">"p2"</span></span>, x =&gt; x.For&lt;IClass&gt;().Use&lt;Class2&gt;()); Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.AddRegistry(registry)); } }</code> </pre> <br>  Here it is worth paying attention that the classes Class1 and Class2 are registered on the common interface, but in different profiles.  In order to get the required class, you need to switch between profiles in a container using the <strong>SetDefaultProfile</strong> method which accepts the profile name. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilesExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegisteringProfiles().Container; container.SetDefaultsToProfile(<span class="hljs-string"><span class="hljs-string">"p1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class1Inst = container.GetInstance&lt;IClass&gt;(); container.SetDefaultsToProfile(<span class="hljs-string"><span class="hljs-string">"p2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class2Inst = container.GetInstance&lt;IClass&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container.WhatDoIHave(); }</code> </pre> <br>  The profile name may only be a string variable, but this is no longer a big problem.  I mean, you don‚Äôt really have to write a profile name as in the example with an open string.  Harmful to karma. <br><br>  After installing the active profile, you can work with the container as usual.  As a result, when the same line is executed, <em>container.GetInstance &lt;IClass&gt; ();</em>  we get different classes. <br><br><br><h2>  Plugins </h2><br>  There is another way to solve the problem of getting a particular class on a common interface, this is a named plugin. <br><br>  A little about the terminology.  In IntelliSense and a little here you can come across the term plugin, PluginType and PluggedType, which generally means the <em>type you want to get</em> .  Those.  In all previous examples of IClass, PluginType can be called, and Class1 or Class2 - PluggedType. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RegisterAsPlugin</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterAsPlugin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; { x.For&lt;IClass&gt;().Use&lt;Class1&gt;().Named(<span class="hljs-string"><span class="hljs-string">"Class1"</span></span>); x.For&lt;IClass&gt;().Use&lt;Class2&gt;().Named(<span class="hljs-string"><span class="hljs-string">"Class2"</span></span>); }); } }</code> </pre> <br>  The example shows that we register classes by a common interface, but at the same time we give them specific names.  With the <strong>Named</strong> method, you can now easily request a specific type. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PluginExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegisterAsPlugin().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class1Inst = container.GetInstance&lt;IClass&gt;(<span class="hljs-string"><span class="hljs-string">"Class1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class2Inst = container.GetInstance&lt;IClass&gt;(<span class="hljs-string"><span class="hljs-string">"Class2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> instanceDef = container.GetInstance&lt;IClass&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container.WhatDoIHave(); }</code> </pre> <br>  The example shows how to access the container and get a specific type on a common interface.  However, here we will at the same time touch on the question, what will happen if we try to call the GetInstance method with a common interface without specifying the name of the plugin? <br><br>  <strong>The default behavior</strong> follows the adage ‚Äúwho is the last, he and the father‚Äù, i.e.  in this case, an <strong>instance of the</strong> class <strong>Class2</strong> will fall into the <strong>instanceDef</strong> variable.  However, we can define quite explicitly the ‚Äúdefault‚Äù class.  To do this, use a slightly different form of registration plugins. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RegisterAsPluginWithDefault</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterAsPluginWithDefault</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.For&lt;IClass&gt;() .AddInstances(i =&gt; { i.Type(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Class1)).Named(<span class="hljs-string"><span class="hljs-string">"Class1"</span></span>); i.Type(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Class2)).Named(<span class="hljs-string"><span class="hljs-string">"Class2"</span></span>); }) .Use(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class1()) ); } }</code> </pre> <br>  And again we can say that the example describes itself.  If you read it, it will literally literally: <em>for the</em> <em>IClass</em> <em>interface,</em> <em>add implementations of the</em> <em>Class1</em> <em>types</em> <em>Class1</em> <em>,</em> <em>Class2 named</em> <em>Class2, use</em> <em>Class1</em> (in this case, a very specific class, but you could write .Use &lt;Class1 in the previous examples) &gt; ()). <br><br>  In this case, the <strong>Use</strong> method says what type will be used for the default interface.  If now run the following code <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> instanceDef = container.GetInstance&lt;IClass&gt;();</code> </pre> <br>  then we get an instance of class Class1. <br><br>  Use already in itself exposes the type used by default. <br><br><br><h2>  Scanning </h2><br>  Logical continuation will be the search and automatic registration of types in the container.  Imagine that not two classes are inherited from the general interface, but 50!  It will be very sad and boring to fill in your hands with all these registrations and dependencies.  In such a case, StructureMap has a <strong>Scan</strong> method that runs through the assemblies or folders of interest and registers suitable objects.  In this way, you can implement the plugin structure for the application and even compete with the MEF in something or replace it. <br><br>  In order for the Scan method to find and register types, several conditions must be met: <br><ul><li>  The type must be explicit; generic types are not registered automatically; </li><li>  The type must have a public constructor; </li><li>  A constructor cannot have arguments of primitive types; </li><li>  Multiple registration is not allowed. </li></ul><br>  The scan method and behavior can be overridden, but so far this will not be considered. <br><br>  Assembly specification for scanning can be defined in several ways: <br><ul><li>  Explicitly prescribe the name of the assembly or pass it to itself; </li><li>  Refer to the caller assembly; </li><li>  Find an assembly containing a specific type; </li><li>  Find assemblies for a specific path. </li></ul><br>  After you have specified the experimental assemblies, you can customize the import process in more detail using the methods for including / excluding types according to various parameters.  For more detailed information it is better to refer to the <a href="http://structuremap.net/structuremap/ScanningAssemblies.htm">documentation</a> .  It is outdated, but gives a general idea of ‚Äã‚Äãthe possibilities. <br><br>  So, let's take a simpler example: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RegisterByScan</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterByScan</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.Scan(s =&gt; { s.AddAllTypesOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (IClass)); s.AssembliesFromPath(<span class="hljs-string"><span class="hljs-string">"."</span></span>); s.WithDefaultConventions(); s.LookForRegistries(); })); } }</code> </pre> <br>  In this class, we say that we want to import all types that implement the IClass interface from the application folder, which should be guided by default conventions.  And the last line is the command to start the search.  Previously, everything worked without explicit instructions.  But now we need to clearly <strong>define the LookForRegistries</strong> method. <br><br>  After the method works, you can see what was found and registered in the container. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterByScanExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegisterByScan().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> instances = container.GetAllInstances&lt;IClass&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container.WhatDoIHave(); }</code> </pre> <br>  Notice that the Get <strong>All</strong> Instances method is being called.  If you call a method to get a particular class from the registered ones, then there will be an error, since StructureMap does not know which class to return ‚Äúby default‚Äù. <br><br>  Honestly, with such an implementation, it is impossible to use the results of the Scan command.  In order for everything to become good, and it would be possible to refer to the found classes by name, you need to rewrite the scan code a bit. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RegisterByScanWithNaming</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IContainer Container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterByScanWithNaming</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Container(x =&gt; x.Scan(s =&gt; { s.AddAllTypesOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (IClass)).NameBy(t =&gt; t.Name); s.AssembliesFromPath(<span class="hljs-string"><span class="hljs-string">"."</span></span>); s.WithDefaultConventions(); s.LookForRegistries(); })); } }</code> </pre> <br>  To the AddAllTypesOf method they added a clarifying rule that all classes should be registered by their name.  After this modification, you can work with specific types: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> instance = container.GetInstance&lt;IClass&gt;(<span class="hljs-string"><span class="hljs-string">"Class1"</span></span>);</code> </pre> <br><br><h2>  Implementation </h2><br>  In the process of working with the container, you can override the type returned by default.  This is mainly used in tests.  Demonstration of work: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InjectExample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RegisterAsPluginWithDefault().Container; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> instance1 = container.GetInstance&lt;IClass&gt;(<span class="hljs-string"><span class="hljs-string">"Class1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> instance2 = container.GetInstance&lt;IClass&gt;(<span class="hljs-string"><span class="hljs-string">"Class2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class1Inst = container.GetInstance&lt;IClass&gt;(); container.Inject(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (IClass), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Class2()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class2Inst = container.GetInstance&lt;IClass&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> container.WhatDoIHave(); }</code> </pre> <br>  We previously declared the RegisterAsPluginWithDefault class, which returns the default Class1 class.  Using the <strong>Inject</strong> method, <strong>you</strong> can override the return type, you only need to specify the type of the plug-in and the new class. <br><br>  These examples were on the general principles of registration when the classes themselves are simple.  In the next topic, we will look at how to deal with classes that have constructors with parameters. <br><br>  To be continued. </div><p>Source: <a href="https://habr.com/ru/post/125613/">https://habr.com/ru/post/125613/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../125607/index.html">Quality assurance management</a></li>
<li><a href="../125608/index.html">Solution of the problem of the second contest CUBRID it!</a></li>
<li><a href="../125610/index.html">Online game based on real estate data</a></li>
<li><a href="../125611/index.html">DISLIN - high-level user data visualization library</a></li>
<li><a href="../125612/index.html">6 tips for motivating a team</a></li>
<li><a href="../125614/index.html">Fuzzy logic in practice</a></li>
<li><a href="../125616/index.html">The German government is unhappy with the facial recognition service Tag Suggestions from Facebook</a></li>
<li><a href="../125617/index.html">Fuzzy search on the client and Soundex</a></li>
<li><a href="../125619/index.html">Post-mortem creation of cross-platform casual engine</a></li>
<li><a href="../125620/index.html">Algorithm for Finding N First Primes - Atkin Sieve</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>