<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Applying local binary patterns to solving face recognition tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day everyone! 

 The article has already briefly reviewed the LBP operator. I would like to dwell on this issue in more detail, and also consider...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Applying local binary patterns to solving face recognition tasks</h1><div class="post__text post__text-html js-mediator-article">  Good day everyone! <br><br>  The <a href="http://habrahabr.ru/post/153109/">article</a> has already briefly reviewed the LBP operator.  I would like to dwell on this issue in more detail, and also consider the application of LBP to the solution of the problem of face recognition. <br><br><h4>  1. Introduction </h4><br>  As a rule, the face recognition system is a software and hardware complex for automatic verification or identification of an individual from a digital image (photograph or frame of a video sequence).  The task of face recognition is solved in the development of access control systems, border control systems, conducting operational search activities, etc. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the process of face recognition, a number of difficulties arise associated with changes in lighting conditions, head rotation, age-related changes, and so on.  The following main stages of the verification and identification process can be distinguished: <br><ol><li>  image registration and normalization; </li><li>  feature selection; </li><li>  calculation of the proximity measure; </li><li>  building a decision rule. </li></ol><br><br>  The main objectives of this work were the development and analysis of the facial recognition algorithm based on local binary patterns (LBT).  We indicate the main stages of solving the task: <br><ol><li>  pre-processing (normalization) of the image; </li><li>  plotting the feature vector; </li><li>  the choice of a measure of proximity; </li><li>  building a decision rule; </li><li>  testing and comparing different approaches. </li></ol><br><br><h4>  2. Local binary patterns </h4><br>  A local binary pattern is a specific type of feature used for classification in computer vision and is a simple operator.  Local binary patterns were first proposed in 1996 for analyzing the texture of halftone images.  Moreover, further studies have shown that LBPs are invariant to small changes in lighting conditions and small image rotations [1]. <br><br>  LBP is a description of the neighborhood of a pixel image in binary representation.  The base LBR operator, applied to the image pixel, uses eight neighborhood pixels, taking the intensity value of the central pixel as a threshold (Figure 2.1).  Pixels with an intensity value greater than or equal to the intensity value of the central pixel take values ‚Äã‚Äãequal to "1", the rest take values ‚Äã‚Äãequal to "0".  Thus, the result of applying the base LBR operator to an image pixel is an eight-bit binary code that describes the neighborhood of this pixel [1]. <br><table><tbody><tr><td><img src="https://habrastorage.org/storage3/ca1/047/f92/ca1047f92e83e90e72ce184848e1bf30.jpg"></td></tr><tr><td>  Figure 2.1 - Basic LBP operator </td></tr></tbody></table><br>  Using a circular neighborhood and bilinear interpolation of pixel intensity values ‚Äã‚Äãallows you to build a local binary pattern with an arbitrary number of points <i>P</i> and radius <i>R</i> (Figure 2.2) [1-4]. <br><table><tbody><tr><td><img src="https://habrastorage.org/storage3/090/fd8/517/090fd8517af3c1818bd576660d9df779.jpg"></td></tr><tr><td>  Figure 2.2 - Extended LBP operator </td></tr></tbody></table><br>  Some binary codes carry more information than others.  Thus, a local binary pattern is called uniform if it contains no more than three ‚Äú0‚Äù and ‚Äú1‚Äù series (for example, 00000000, 001110000 and 11100001).  First, uniform LBPs determine only important local features of the image, such as the ends of lines, faces, angles, and spots (Figure 2.3).  Second, they provide significant memory savings ( <i>P</i> ( <i>P</i> -1) +2 different patterns instead of 2 <sup><i>P</i></sup> ). <br><table><tbody><tr><td><img src="https://habrastorage.org/storage3/c6c/291/8f2/c6c2918f251848419b15cd6ca0588e52.jpg"></td></tr><tr><td>  Figure 2.3 - Examples of local features detected by RLBS </td></tr></tbody></table><br><h4>  3. Histogram LBSH </h4><br>  Applying the LBP operator to each pixel of the image, we can construct a histogram in which a separate column corresponds to each uniform LBP code.  There is also another additional column that contains information about all non-uniform patterns. <br><br>  Face images can be considered as a set of various local features that are well described using local binary patterns.  However, a histogram built for the entire image as a whole encodes only the presence of certain local features, but does not contain any information about their location in the image.  To account for this kind of information, the image is divided into subregions, each of which calculates its LBP histogram (Figure 3.1).  By concatenating these histograms, a common histogram can be obtained, taking into account both local and global features of the image [2, 3]. <br><table><tbody><tr><td><img src="https://habrastorage.org/storage3/697/945/019/6979450194af6bb3d917a9ee181c668a.jpg"></td></tr><tr><td>  Figure 3.1 - Splitting a face image into subdomains </td></tr></tbody></table><br>  With this approach, for better extraction of features, it is possible to vary the parameters of the LBR operator and the number of image splits into subregions. <br><br><h4>  4. Building a decision rule </h4><br>  In the course of the work, three approaches were studied to calculate the measure of the difference between the histograms of two matched images and the construction of the corresponding decision rule. <br><br><h5>  4.1.  Kullback-Leibler Weighted Distance </h5><br>  Some subregions of the image may contain more important information than the others, and in accordance with this, each of them can be assigned its own weighting factor.  Thus, for example, weights can be obtained using the Student‚Äôs criterion, which consists in testing the hypothesis of differences between two samples, according to training data representing two classes (‚Äúown‚Äù and ‚Äúalien‚Äù in the case of solving the verification or identification problem). <br><br>  As a measure of the difference between the two histograms, the Kullback-Leibler weighted distance was used in a symmetric form: <br><table><tbody><tr><td><img src="https://habrastorage.org/storage3/68e/930/c12/68e930c125a2f18e5c329a8e8e277899.jpg"></td><td>  (4.1) </td></tr></tbody></table><br>  where ( <i>i</i> , <i>j</i> ) is the index of the subregion of the image, <i>w</i> <sub><i>ij</i></sub> is the weighting factor of the subregion, <i>S</i> <sup>1</sup> , <i>S</i> <sup>2</sup> are the LBR histograms of the first and second images, respectively <i>, k</i> is the column number of the LBR histogram, <i>P</i> is the number of neighborhood points in the LBS template. <br><br>  In this case, the identification problem was solved using the classifier by the method of the nearest neighbor, and the verification problem was solved by the threshold classification. <br><br><h5>  4.2.  Mahalanobis Distance </h5><br>  This approach is to use the Mahalanobis distance: <br><table><tbody><tr><td><img src="https://habrastorage.org/storage3/e11/c62/b1a/e11c62b1af19b71bbb6fe778219aac40.jpg"></td><td>  (4.2) </td></tr></tbody></table><br>  where <i>x</i> , <i>y</i> are random vectors with the same distribution and the correlation matrix <i>S.</i> <br><br>  The correlation matrix <i>S</i> can be obtained using a training sample of images.  By determining the Kullback-Leibler distance (4.1) for each of the subdomains of images, we can obtain a vector of differences between two images.  By calculating such vectors for each pair of images of the training set, we obtain two sets of image difference vectors corresponding to two classes ‚Äî the class of ‚Äúfriends‚Äù and the class of ‚Äúalien‚Äù.  After that we can calculate the average values ‚Äã‚Äãof the vectors representing each of the classes, as well as two correlation matrices. <br><br>  In practice, for any two images, we can calculate their difference vector, and then determine the Mahalanobis distance <i>d</i> <sub>1</sub> and <i>d</i> <sub>2</sub> between this vector and average vectors of ‚Äúown‚Äù and ‚Äúalien‚Äù classes, respectively.  Identification and verification can be made by comparing the two obtained distances or using the discriminating function <i>f</i> ( <i>d</i> <sub>1</sub> , <i>d</i> <sub>2</sub> ) = <i>d</i> <sub>2</sub> ‚ÅÑ ( <i>d</i> <sub>1</sub> + <i>d</i> <sub>2</sub> ) and a certain threshold value. <br><br><h5>  4.3.  The use of linear discriminant Fisher </h5><br>  The following approach relies on the use of the Fisher linear discriminant (LDF): <br><table><tbody><tr><td><img src="https://habrastorage.org/storage3/d8f/3e9/c23/d8f3e9c23eb4f7c4902a464a2293ce09.jpg"></td><td>  (4.3) </td></tr></tbody></table><br>  where <i>Œº</i> <sub><i>i</i></sub> is the average for the <i>i</i> -th class, <i>Œº</i> is the general average, <i>N</i> <sub><i>i</i></sub> is the number of representatives in the <i>i</i> -th class, <i>N</i> is the total number of representatives in the training set, <i>x</i> <sub><i>ij</i></sub> is the <i>j</i> -th representative of the <i>i</i> -th class. <br><br>  Let there be two sets of vectors corresponding to two classes.  The eigenvector corresponding to the largest eigenvalue of the matrix <i>S</i> <sub><i>w</i></sub> <sup>-1</sup> <i>S</i> <sub><i>b</i></sub> specifies a transformation to a space of dimension 1. <br><br>  The task of identification and verification can be solved in a way similar to the previous one (by constructing image difference vectors using the Kullback-Leibler distance).  In this case, instead of the Mahalanobis distance, the vector is mapped into one-dimensional space. <br><br><h4>  5. Image preprocessing </h4><br>  In order to reduce the noise level, median and Gaussian filters were used.  In addition, the images underwent the normalization procedure, i.e.  they were cropped, scaled and turned to the horizontal position of the line connecting the centers of the eyes (Figure 5.1). <br><table><tbody><tr><td><img src="https://habrastorage.org/storage3/a50/8eb/d84/a508ebd842d79dd09be7c0834be3ee3e.png"></td></tr><tr><td>  Figure 5.1 - Image Normalization Parameters </td></tr></tbody></table><br><h4>  6. Description and results of the experiment </h4><br>  The ColorFERET database was used for training and testing. <br><ul><li>  training sample: 100 people, 5 photos for each; </li><li>  test sample: 329 people, 2 photos for each. </li></ul><br>  All algorithms were trained so as to ensure a false tolerance probability (FAR) value of 0.1%.  The best results were obtained using the following parameters: <br><ul><li>  LBSH operator parameters: P = 8, R = 2; </li><li>  Number of image splits: 6 √ó 6 (along the x and y axes, respectively). </li></ul><br>  Table 6.1 shows the results of testing the developed algorithms. <br><table><caption>  Table 6.1 - Algorithm Test Results </caption><tbody><tr><td>  <b>Measure of difference</b> </td><td>  <b>Closed set identification</b> </td><td>  <b>Verification</b> </td></tr><tr><td>  Kullback-Leibler Weighted Distance </td><td>  89.5% </td><td>  84.2% </td></tr><tr><td>  Mahalanobis Distance </td><td>  89.8% </td><td>  80.8% </td></tr><tr><td>  Conversion to 1-dimensional space using LDF </td><td>  92.0% </td><td>  86.0% </td></tr></tbody></table><br><h4>  7. Conclusion </h4><br>  This article briefly describes the algorithm for constructing a feature vector based on local binary patterns. <br><br>  It is shown that the use of different decision rules for the same feature vectors can improve the quality of the face recognition system.  As can be seen from table 6.1, the best probability characteristics are obtained using the Fisher linear discriminant. <br><br>  In addition, it should be noted that the quality of the system depends significantly on the pre-processing of input images.  In the course of the work, it was noted that the absence of a filtering step leads to a decrease in the likelihood of correct identification and verification. <br><br><h4>  8. List of sources used </h4><br><ol><li>  T. Maenpaa.  Texture Extensions and Applications.  <i>Oulu University Press</i> , 2003. </li><li>  D. Maturana, D. Mery, A. Soto.  Face Recognition with Spatial Pyramid Histograms and Naive Bayes Nearest Neighbor classification.  <i>In Proc.</i>  <i>of the XXVIII International Conference of the Chilean Computer Science Society, IEEE CS Society</i> , 2009. </li><li>  C. Shan, S. Gong, PW McOwan.  A comprehensive study of facial expression patterns.  <i>Image and Vision Computing</i> , (27), 2009. </li><li>  T. Ahonen, A. Hadid, M. Pietikainen.  Face Recognition with Local Binary Patterns.  <i>Lecture Notes in Computer Science</i> , 2004. </li></ol><br><br>  <b>PS</b> I would like to separately note that in further work the probabilistic characteristics of the verification and identification algorithm were slightly improved.  This was achieved by constructing feature vectors not only for the image of the face as a whole, but also for the areas of a pair of eyes, nose and mouth, as well as a significant increase in the size of the training set.  Unfortunately, I can not present in more detail the materials of these studies, since the results obtained are a commercial secret. <br><br>  <b>PPS</b> This article is based on my other publication and includes some corrections.  A big request when using the materials of this article (especially in scientific papers) to refer to the original version: <br>  Petruk V.I., Samorodov A.V., Spiridonov I.N.  The use of local binary patterns to solve the problem of face recognition.  <i>Bulletin of the Moscow State Technical University.</i>  <i>N.E.</i>  <i>Bauman.</i>  <i>Series: Instrument making.</i>  2011. No. S. p. 58-63. </div><p>Source: <a href="https://habr.com/ru/post/193658/">https://habr.com/ru/post/193658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../193642/index.html">Asm.js practice</a></li>
<li><a href="../193644/index.html">Homemade LED illuminator for photo and video</a></li>
<li><a href="../193646/index.html">Direct data transfer between FPGA Virtex-7 over the bus PCI Express</a></li>
<li><a href="../193650/index.html">How to buy a 3D printer in China, or Toy for $ 1000</a></li>
<li><a href="../193654/index.html">Application of EDS in SAP NetWeaver web templates</a></li>
<li><a href="../193660/index.html">Media Center from MacMini and Rapsberry PI</a></li>
<li><a href="../193662/index.html">Sharing SAML 2.0 SSO Integration Experience</a></li>
<li><a href="../193666/index.html">Steganography in .NET applications or watermarks</a></li>
<li><a href="../193668/index.html">Straight lines in a hexagonal raster</a></li>
<li><a href="../193670/index.html">Autonomous operation of the smartphone: "intelligible" comparative guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>