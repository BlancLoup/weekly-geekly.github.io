<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript transducers. Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part, we stopped at the following specification: A transducer is a function that accepts the step function, and returns a new step functi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript transducers. Part two</h1><div class="post__text post__text-html js-mediator-article"> In the <a href="http://habrahabr.ru/post/237613/">first part,</a> we stopped at the following specification: A transducer is a function that accepts the <code>step</code> function, and returns a new <code>step</code> function. <br><br><pre> <code class="javascript hljs">step‚Å∞ ‚Üí step¬π</code> </pre><br>  The <code>step</code> function, in turn, accepts the current result and the next element, and should return the new current result.  In this case, the data type of the current result is not specified. <br><br><pre> <code class="javascript hljs">result‚Å∞, item ‚Üí result¬π</code> </pre><br>  To get the new current result in the <code>step¬π</code> function, you need to call the <code>step‚Å∞</code> function, passing in it the old current result and the new value that we want to add.  If we do not want to add a value, then simply return the old result.  If we want to add one value, then we call <code>step‚Å∞</code> , and then what it returns will return as a new result.  If we want to add several values, then we call <code>step‚Å∞</code> several times along the chain, this is easier to show in the example of the implementation of the <a href="http://underscorejs.org/">flatten</a> transducer: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flatten</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">step</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; item.length; i++) { result = step(result, item[i]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flattenT = flatten(); _.reduce([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], [], [<span class="hljs-number"><span class="hljs-number">3</span></span>]], flattenT(append), []); <span class="hljs-comment"><span class="hljs-comment">// =&gt; [1, 2, 3]</span></span></code> </pre><br>  Those.  you need to call <code>step</code> several times, each time saving the current result to a variable, and passing it the next time you call it, and at the end return the final one. <br><br>  As a result, when processing each element, one <code>step</code> function calls another, and that next one, and so on until the last service <code>step</code> function, which already saves the result to the collection ( <code>append</code> from the first part). <br><br>  So now we can: <br><ol><li>  Modify items (note map) </li><li>  Skip items (approx. Filter) </li><li>  Issue several new items for one item (approx. Flatten) </li></ol><br><a name="habracut"></a><br><h4>  Premature termination </h4><br>  But what if we want to interrupt the whole process in the middle?  Those.  implement <a href="http://underscorejs.org/">take</a> , for example.  To do this, Rich offers to wrap the return value in a special ‚Äúreduced‚Äù wrapper. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reduced</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">wrapped</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._wrapped = wrapped; } Reduced.prototype.unwrap = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._wrapped; } Reduced.isReduced = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Reduced); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">step</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count++ <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span></span><span class="xml"><span class="hljs-tag">) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">step</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">result</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">item</span></span></span></span><span class="xml"><span class="hljs-tag">); } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">new</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Reduced</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">result</span></span></span></span><span class="xml"><span class="hljs-tag">); } } } } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">var</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">first5T</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">take(5);</span></span></span></span></span></span></code> </pre><br>  If we want to complete the process, instead of returning the next <code>result</code> as usual, we return the <code>result</code> wrapped in <code>Reduced</code> .  Immediately update the step function signature: <br><br><pre> <code class="javascript hljs">result‚Å∞, item ‚Üí result¬π | reduced(result¬π)</code> </pre><br>  But the <code>_.reduce</code> function <code>_.reduce</code> no longer be able to handle this version of the transducer.  We'll have to write a new one. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">coll, fn, seed</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = seed; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; coll.length; i++) { result = fn(result, coll[i]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Reduced.isReduced(result)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.unwrap(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  Now you can use the <code>first5T</code> transducer. <br><br><pre> <code class="javascript hljs">reduce([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>], first5T(append), []); <span class="hljs-comment"><span class="hljs-comment">// =&gt; [1, 2, 3, 4, 5]</span></span></code> </pre><br><br>  You also have to add the <code>Reduced.isReduced(result)</code> test to transducers that call step several times (note flatten).  Those.  if in flatten, if we call step step, the result wrapped in Reduced will be returned to us, we must complete our loop, and return this wrapped result. <br><br><h4>  condition </h4><br>  Another important detail is the take transducer.  He remembers how many elements already passed through him.  In order for everything to work correctly, this counter needs to be created exactly in the place where it was created in the example (see var count), i.e.  inside the function that returns step.  If it were, for example, a global variable, then we would consider the elements for all transducers of type take in one counter, and would get the wrong result. <br><br>  Let's create another service function for launching transducers to more clearly show the moment where the state is created. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transducer, append, seed, coll</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step = transducer(append); <span class="hljs-comment"><span class="hljs-comment">//       . // step    , //   (step)      //    ,   . return reduce(coll, step, seed); } transduce(first5T, append, [], [1, 2, 3, 4, 5, 6, 7]); // =&gt; [1, 2, 3, 4, 5]</span></span></code> </pre><br><br><h4>  Completion </h4><br>  We have already talked about premature termination, but there can be a normal termination when the original collection just ends.  Some transducers can somehow handle the completion. <br><br>  For example, we want to break the collection into small collections of a given length, but if there are not enough elements for the last small collection, then simply return an incomplete one.  We need to somehow understand that the elements will no longer exist, and return what is. <br><br>  In order to be able to do this, Rich suggests adding another variant of the step function, to which the next value is not passed, but only the current result.  This option will be called at the end of processing the collection, if there was no premature termination. <br><br>  In clojure, these two functions are combined into one; we can do this in JavaScript too. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   //  step(result, item)     } if (arguments.length === 1) { //   //    step c  ,     . //     -     , //      step   ,    . //    return step(result); // -  result = step(result, -); return step(result); } }</span></span></code> </pre><br>  Update the signature of the step function, now it has two options depending on the number of arguments: <br><br><pre> <code class="javascript hljs">result‚Å∞ ‚Üí result¬π * result‚Å∞, item ‚Üí result¬π | reduced(result¬π) *        reduced(result¬π),      .      .</code> </pre><br><br>  All transducers must support both operations ‚Äî normal step and final call.  Also, the <code>transduce()</code> and <code>append()</code> functions will have to be updated to add support for the final call. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transducer, append, seed, coll</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step = transducer(append); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = reduce(coll, step, seed); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> step(result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.concat([item]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre><br><br>  So, here is the implementation of the partition (breaks the collection into small collections): <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'n     1'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">step</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cur = []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">2</span></span>) { cur.push(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur.length === n) { result = step(result, cur); cur = []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { result = step(result, cur); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> step(result); } } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> by3ItemsT = partition(<span class="hljs-number"><span class="hljs-number">3</span></span>); transduce(by3ItemsT, append, [], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// =&gt; [[1,2,3], [4,5,6], [7,8]]</span></span></code> </pre><br><br><h4>  Initialization </h4><br>  Rich also suggests adding the ability for transducers to create an initial empty result value.  (We used an empty array everywhere for this purpose, which we explicitly passed first to <code>reduce</code> , and then to <code>transduce</code> .) <br><br>  To do this, you need to add another version of the step function ‚Äî no parameters at all.  If step is called without parameters, it should return an initial value, for example, an empty array. <br><br>  Obviously, transducers cannot create an empty array, since they are not tied to the type of collection being processed.  But besides the step function in transducers, there is also an external step function, which just knows about the type of collection.  In our examples, this is the append function. <br><br>  Update the signature of the <code>step</code> function. <br><br><pre> <code class="javascript hljs">‚Üí result result‚Å∞ ‚Üí result¬π result‚Å∞, item ‚Üí result¬π | reduced(result¬π)</code> </pre><br>  Update the <code>transduce()</code> and <code>append()</code> functions. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">transducer, append, coll</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> step = transducer(append); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> seed = step(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = reduce(coll, step, seed); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> step(result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.concat([item]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; } }</code> </pre><br>  And for example rewrite the transducer generator map. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">step</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> step(result, fn(item)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> step(result); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> step(); } } } }</code> </pre><br>  It turns out we just transferred an empty array from the <code>transduce()</code> parameter inside <code>append()</code> , at first glance this is an unnecessary action, but it gave us the opportunity to create transducers that add something to the beginning of the collection (just like the ones that add to the end, just the opposite) . <br><br>  Thus, all transducers must support three operations in the step function ‚Äî normal step, final call, and initial call.  But most of them will simply pass on the initiative to the next transducer in the last two cases. <br><br><h4>  Results </h4><br>  That's all.  I retold the entire <a href="http://www.youtube.com/watch%3Fv%3D6mTbuzafcII">report of Rich Hickey</a> .  And, as I understand it, this is so far all that can be told about transducers. <br><br>  Summarize once again what we got.  We got a universal way to create operations on collections.  These operations can: change elements (map), skip elements (filter), multiply elements (flatten), have a state (take, partition), prematurely complete processing (take), add something at the end (partition) and add something then first.  We can easily combine all these operations using compose, and use them both on ordinary collections and, for example, in FRP.  In addition, all this will work quickly and consume little memory, because  Temporary collections are not created. <br><br>  This is all cool!  But how do we start using them?  The problem is that in order to use transducers to the maximum, the JavaScript community must agree on a specification (and we can do it, right? :-).  Then a cool scenario could be realized in which libraries for working with collections (underscore, etc.) will be able to create transducers, and other libraries that are not quite about collections (eg FRP) will simply be supported by transducers. <br><br>  The specification that Rich offers, at first glance, falls quite well with JavaScript, with the exception of the details about Reduced.  The fact is that Clojure already has a global Reduced (it‚Äôs been there for a long time), but not in JavaScript.  It is, of course, easy to create, but each library will create its own Reduced.  In the end, if I, for example, want to add support for transducers in Kefir.js, I will have to add support for transducer-underscore, transducer-LoDash, etc.  Reduced is a weak point in the specification proposed by Rich. <br><br>  Another scenario is the appearance of different transducer libraries, each of which will have its own specification.  Then we can only get some of the benefits.  There is already a library <a href="">transducers.js</a> , it has of course created its own Reduced, and so far there is no support for the final and initial calls, and it is not known in what form the author will add them. <br><br>  Well, considering that many transducers do not seem to be something new and very useful, it is not clear how we will be and whether we will use them in JavaScript. <br><br></div><p>Source: <a href="https://habr.com/ru/post/237733/">https://habr.com/ru/post/237733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237721/index.html">Sony Xperia Z3 and Xperia Z3 Compact have broken the record of the duration of work in the ranking of flagship smartphones</a></li>
<li><a href="../237725/index.html">Localization of applications for the Chinese market</a></li>
<li><a href="../237727/index.html">Resuscitate Ubuntu servers on Hetzner or some useful commands</a></li>
<li><a href="../237729/index.html">Progress of an abstract project in a vacuum: a random process model</a></li>
<li><a href="../237731/index.html">The Security Council today decided not to discuss Russia's disconnection from the Internet</a></li>
<li><a href="../237737/index.html">Why don't you need sshd in a Docker container</a></li>
<li><a href="../237739/index.html">California will allow unmanned vehicles to drive through busy streets</a></li>
<li><a href="../237741/index.html">New book ‚ÄúZero to One‚Äù released - Peter Thiel‚Äôs view on the startup world</a></li>
<li><a href="../237743/index.html">Bundle Transformer: Summer Updates</a></li>
<li><a href="../237745/index.html">Modern spam filters and end-to-end encryption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>