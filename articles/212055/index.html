<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Methods of organizing interaction between scripts in Unity3D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Even the average Unity3D project is very quickly filled with a large number of different scripts and the question arises of how these s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Methods of organizing interaction between scripts in Unity3D</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Even the average Unity3D project is very quickly filled with a large number of different scripts and the question arises of how these scripts interact with each other. <br>  This article offers several different approaches to the organization of such interactions from simple to advanced and describes what problems each of the approaches can lead to, as well as suggest ways to solve these problems. <br><a name="habracut"></a><br><h4>  Approach 1. Purpose through the Unity3D editor </h4><br>  Suppose we have two scripts in the project.  The first creak is responsible for scoring points in the game, and the second for the user interface, which displays the number of points scored on the game screen. <br>  Let's call both scripts managers: ScoresManager and HUDManager. <br>  How does the manager in charge of the menu of the screen get the current number of points from the manager in charge of scoring? <br>  It is assumed that in the object hierarchy (Hierarchy) of the scene there are two objects, one of which is assigned the ScoresManager script and the other is the HUDManager script. <br>  One approach contains the following principle: <br>  In the UIManager script, we define a variable of the ScoresManager type: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HUDManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ScoresManager ScoresManager; }</code> </pre> <br>  But the ScoresManager variable must also be initialized with an instance of the class.  To do this, select the object in the object hierarchy to which the HUDManager script is assigned and in the object settings we will see the ScoresManager variable with the value None. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/900/ef2/696/900ef2696d5182d43a87f20483dfe6c1.jpg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Next, drag and drop an object from the hierarchy window containing the ScoresManager script into the area where None is written and assign it to the declared variable: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6dc/5a7/da3/6dc5a7da31258029d78f692b51778e73.jpg" alt="image"><br><br>  After that, we have the opportunity from the HUDManager code to access the ScoresManager script, thus: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HUDManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ScoresManager ScoresManager; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ShowScores(ScoresManager.Scores); } }</code> </pre><br>  It's simple, but the game is not limited to the points scored, the HUD can display the player‚Äôs current lives, the menu of available player actions, level information, and more.  The game can consist of tens and hundreds of different scripts that need to receive information from each other. <br>  To get data from another script in one script, we will have to describe a variable in one script and assign it (drag it manually) using an editor, which is a tedious job in itself, which you can easily forget and then find which of the variables is not initialized for a long time . <br>  If we want to refactor something, rename the script, then all the old initializations in the hierarchy of objects associated with the renamed script will be reset and we will have to assign them again. <br>  At the same time, such a mechanism does not work for prefabs (prefab) - the dynamic creation of objects from a template.  If a prefab needs to contact a manager located in the object hierarchy, then you cannot assign an element from the hierarchy to the prefab itself, but you will have to first create an object from the prefab and then programmatically assign an instance of the variable manager of the newly created object.  Not necessary work, not necessary code, additional connectedness. <br>  The following approach solves all these problems. <br><br><h4>  Approach 2. "Singltons" </h4><br>  Let's apply the simplified classification of possible scripts that are used when creating the game.  The first type of scripts: ‚Äúscripts-managers‚Äù, the second: ‚Äúscripts-game-objects‚Äù. <br>  The main difference between some of them is that the ‚Äúscript managers‚Äù always have a single instance in the game, while the ‚Äúscripts-game-objects‚Äù can have more than one instance. <br><br><h4>  Examples </h4><br>  As a rule, in a single copy there are scripts that are responsible for the general logic of the user interface, for playing music, for tracking the conditions for completing a level, for managing the task system, for displaying special effects, and so on. <br>  At the same time, game object scripts exist in a large number of instances: each bird from the ‚ÄúAngry Birds‚Äù is controlled by a bird script instance with its own unique state;  for any unit in the strategy, a copy of the unit script is created, containing its current number of lives, position on the field and personal goal;  The behavior of five different icons is provided by different instances of the same scripts responsible for this behavior. <br>  In the example from the previous step, the HUDManager and ScoresManager scripts always exist in a single instance.  For their interaction with each other, apply the singleton pattern (Singleton, aka single). <br>  In the ScoresManager class, we will describe a static property of the ScoresManager type, in which a single instance of the points manager will be stored: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ScoresManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ScoresManager Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Scores; }</code> </pre><br>  It remains to initialize the Instance property with an instance of the class that creates the Unity3D environment.  Since ScoresManager is a successor of MonoBehaviour, it participates in the life cycle of all active scripts in the scene and during the script initialization it calls the Awake method.  In this method we place the initialization code of the Instance property: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ScoresManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ScoresManager Instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Scores; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre><br>  After that, you can use ScoresManager from other scripts as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HUDManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ShowScores(ScoresManager.Instance.Scores); } }</code> </pre><br>  Now there is no need for HUDManager to describe the ScoresManager type field and assign it in the Unity3D editor; any ‚Äúscript manager‚Äù can provide access to itself through the static Instance property, which will be initialized in the Awake function. <br><br><h4>  pros </h4><br>  - there is no need to describe the script field and assign it through the Unity3D editor. <br>  - you can safely refactor the code, if something falls off, the compiler will let you know. <br>  - other ‚Äúscript managers‚Äù can now be accessed from prefabs, through the Instance property. <br><br><h4>  Minuses </h4><br>  - the approach provides access only to the ‚Äúscript managers‚Äù existing in a single copy. <br>  - strong coherence. <br>  On the last "minus" dwell in more detail. <br>  Let us develop a game in which there are characters (unit) and these characters can die (die). <br>  Somewhere there is a section of code that checks whether our character has died: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Unit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LifePoints; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TakeDamage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { LifePoints -= damage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LifePoints &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) Die(); } }</code> </pre><br>  How can the game respond to the death of the character?  Many different reactions!  I will give several options: <br>  - it is necessary to remove the character from the scene of the game so that it no longer appears on it. <br>  - In the game, points are added for each dead character, you need to accrue them and update the value on the screen. <br>  - a special panel displays all the characters in the game, where we can choose a particular character.  When a character dies, we need to refresh the panel, or remove the character from it, or display that it is dead. <br>  - you need to play the sound effect of the death of the character. <br>  - you need to play the visual effect of the death of the character (explosion, splashes of blood). <br>  - The system of achievements of the game has an achievement that considers the total number of killed characters for all time.  It is necessary to add a newly deceased character to the counter. <br>  - the analytics system of the game sends to the external server the fact of the death of the character, this fact is important for us to track the player's progress. <br>  Considering all of the above, the Die function might look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { DeleteFromScene(); ScoresManager.Instance.OnUnitDied(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); LevelConditionManager.Instance.OnUnitDied(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); UnitsPanel.Instance.RemoveUnit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); SoundsManager.Instance.PlayUnitDieSound(); EffectsManager.Instance.PlaySmallExplosion(); AchivementsManager.Instance.OnUnitDied(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); AnaliticsManager.Instance.SendUnitDiedEvent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  It turns out that the character after his death must send out all the components that are interested in this sad fact, he should know about the existence of these components and should know that they are interested in them.  Is it too much knowledge for a small unit? <br>  Since the game, according to logic, is a very connected structure, then events that occur in other components are of interest to others, the unit is nothing special here. <br>  Examples of such events (not all): <br>  - The condition of passing the level depends on the number of points scored, scored 1000 points - completed the level (LevelConditionManager is associated with ScoresManager). <br>  - When we score 500 points, we reach an important stage of passing the level, you need to play a funny melody and visual effect (ScoresManager is connected with EffectsManager and SoundsManager). <br>  - When a character recovers health, you need to lose the cure effect on the character in the character panel (UnitsPanel is associated with EffectsManager). <br>  - and so on. <br>  As a result of such connections, we come to a picture similar to the following, where everyone knows everything about everyone: <br><br><img src="https://lh4.googleusercontent.com/-AMjWHrGQ4Qs/UvdERpSw-KI/AAAAAAAAzV0/omPPQOdLxJc/w952-h540-no/example03.jpg" alt="image"><br><br>  The example with the death of a character is a bit exaggerated, it is not often necessary to report the death (or other event) to six different components.  But the options, when at some event in the game, the function in which the event occurred, reports this to 2-3 other components found very often throughout the code. <br>  The following approach tries to solve this problem. <br><br><h4>  Approach 3. The World Broadcast (Event Aggregator) </h4><br>  We introduce a special component ‚ÄúEventAggregator‚Äù, the main function of which is to store a list of events occurring in the game. <br>  An event in the game is a functional that provides any other component with the opportunity to subscribe to itself as well as publish the fact of the event.  The implementation of the event functional can be any taste of the developer, you can use standard language solutions or write your own implementation. <br>  An example of a simple implementation of an event from the last example (about the death of a unit): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UnitDiedEvent</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;Action&lt;Unit&gt;&gt; _callbacks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Action&lt;Unit&gt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action&lt;Unit&gt; callback</span></span></span><span class="hljs-function">)</span></span> { _callbacks.Add(callback); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Publish</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Unit unit</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Action&lt;Unit&gt; callback <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _callbacks) callback(unit); } }</code> </pre><br>  Add this event to the ‚ÄúEventAggregator‚Äù: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EventAggregator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> UnitDiedEvent UnitDied; }</code> </pre><br>  Now, the Die function from the previous example with eight lines is converted to a function with one line of code.  We do not need to report that the unit has died to all interested components and to know about these interested.  We simply publish the fact of the event: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Die</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EventAggregator.UnitDied.Publish(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br>  And any component that is interested in this event can react to it as follows (using the example of a manager who is responsible for the number of points scored): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ScoresManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Scores; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EventAggregator.UnitDied.Subscribe(OnUnitDied); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUnitDied</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Unit unit</span></span></span><span class="hljs-function">)</span></span> { Scores += CalculateScores(unit); } }</code> </pre><br>  In the Awake function, the manager subscribes to the event and passes the delegate responsible for handling this event.  The event handler itself takes an instance of a dead unit as a parameter and adds the number of points depending on the type of this unit. <br>  In the same way, all other components who are interested in the event of the death of a unit can subscribe to it and process when the event occurs. <br>  As a result, the diagram of connections between components, when each component knew about each other, turns into a diagram, when components know only about events that occur in the game (only about events of interest to them), but they don‚Äôt care where these events came from.  The new chart will look like this: <br><br><img src="https://lh3.googleusercontent.com/-j-Fk8LOBCKs/UvdESA_Nh9I/AAAAAAAAzV4/_BJFPjQTTbg/w958-h542-no/example04.jpg" alt="image"><br><br>  I love another interpretation: Imagine that the ‚ÄúEventAggregator‚Äù rectangle stretched in all directions and captured all the other rectangles, turning into the boundaries of the world.  In my head, in this diagram, "EventAggregator" is completely absent.  ‚ÄúEventAggregator‚Äù is just a game world, a kind of ‚Äúgame broadcast‚Äù where the different parts of the game shout ‚ÄúHey, people!  A unit is dead! ‚Äù, And everyone listens on the air, and if they are interested in some of the events heard, they will react to it.  Thus - there are no connections, each component is independent. <br>  If I am a component and are responsible for the publication of some event, then I scream on the air saying this one died, this one got a level, the shell hit the tank.  And I don‚Äôt care about anyone.  Perhaps no one is listening to this event now, or maybe hundreds of other objects are signed to it.  As an event author, I don‚Äôt care about a single gram, I don‚Äôt know anything about them and I don‚Äôt want to know. <br>  This approach allows you to easily introduce new functionality without changing the old one.  Suppose we decided to add an achievement system to the finished game.  We create a new component of the achievement system and subscribe to all the events of interest to us.  No other code changes.  No need to walk on other components and from them cause the system of achievements and say to her they say, and count my event please.  In addition, all who publish events in the world do not know anything about the system of achievements, even the fact of its existence. <br><br><h4>  Comment </h4><br>  Saying that no other code is changing, of course, I'm a little cunning.  It may turn out that the achievement system is interested in events that had previously simply not been published in the game, because no other system had previously been interested in it.  And in this case, we will need to decide what new events to add to the game and who will publish them.  But in an ideal game, all possible events are already there and the air is full of them. <br><br><h4>  pros </h4><br>  - not connectedness of components, it is enough for me to simply publish an event, and who it is of interest does not matter. <br>  - not connectedness of components, I just subscribe to the events I need. <br>  - you can add individual modules without changing the existing functionality. <br><br><h4>  Minuses </h4><br>  - you need to constantly describe new events and add them to the world. <br>  - violation of functional atomicity. <br><br><h4>  We consider the last minus in more detail. </h4><br>  Imagine that we have an ObjectA object in which the MethodA method is called.  The ‚ÄúMethodA‚Äù method consists of three steps and calls within itself three other methods that perform these steps sequentially (‚ÄúMethodA1‚Äù, ‚ÄúMethodA2‚Äù and ‚ÄúMethodA3‚Äù).  In the second method ‚ÄúMethodA2‚Äù some event is published.  And here the following happens: all those who are subscribed to this event will begin to process it, following some of their own logic.  In this logic, the publication of other events may also occur, the processing of which may also lead to the publication of new events and so on.  Tree publications and reactions in some cases can grow very much.  Such long chains are extremely hard to debug. <br>  But the most terrible problem that can occur here is when one of the branches of the chain leads back to ObjectA and starts processing the event by calling some other MethodB method.  It turns out that the ‚ÄúMethodA‚Äù method has not yet completed all the steps, as it was interrupted at the second step, and now contains an invalid state (in step 1 and 2 we changed the state of the object, but the last change from step 3 is not yet done) and at the same time ‚ÄúMethodB‚Äù starts to be executed in the same object, having this not a valid state.  Such situations give rise to errors, are very difficult to catch, lead to the need to control the order of calling methods and publishing events when, logically, there is no need to do this and introduce additional complexity that we would like to avoid. <br><br><h4>  Decision </h4><br>  Solving the described problem is not difficult; it is enough to add the delayed reaction functional to the event.  As a simple implementation of such a functional, we can get a repository into which we will add the events that have occurred.  When an event has occurred, we do not execute it immediately, but simply save it somewhere.  And at the moment of the occurrence of the execution queue of the functionality of some component in the game (in the Update method, for example), we check for the occurrence of events and perform processing, if there are such events. <br>  Thus, when the ‚ÄúMethodA‚Äù method is executed, it is not interrupted, and the interested event is recorded by all interested parties in a special repository.  And only after the queue reaches the interested subscribers, they will get an event from the storage and process it.  At this point, the entire ‚ÄúMethodA‚Äù will be completed and ‚ÄúObjectA‚Äù will have a valid state. <br><br><h4>  Conclusion </h4><br>  A computer game is a complex structure with a large number of components that interact closely with each other.  You can think of many mechanisms for organizing this interaction, but I prefer the mechanism that I described, based on events, and which I came to by an evolutionary path of walking through all kinds of rakes.  I hope someone will like it too and my article will clarify and be useful. </div><p>Source: <a href="https://habr.com/ru/post/212055/">https://habr.com/ru/post/212055/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../212045/index.html">Like graphene, only from phosphorus</a></li>
<li><a href="../212047/index.html">Several useful Django fields</a></li>
<li><a href="../212049/index.html">Managing the process of exchanging routing updates using prefix lists (prefix-list)</a></li>
<li><a href="../212051/index.html">Watching IPTV on Xbox360</a></li>
<li><a href="../212053/index.html">Reflections on beautiful code</a></li>
<li><a href="../212057/index.html">Installing ST-LINK V2 on MAC OS X for development under STM32</a></li>
<li><a href="../212059/index.html">Survival kit for web developer under win *</a></li>
<li><a href="../212061/index.html">A little more about the project ¬´Outernet¬ª</a></li>
<li><a href="../212065/index.html">HMVC pattern in web development</a></li>
<li><a href="../212067/index.html">Newsstand app. Create iOS Journal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>