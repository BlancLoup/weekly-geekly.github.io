<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mastering programming - no problem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is this article about 
 Attempting to explain why the study of modern technologies is difficult, how to find the easiest way to master them and b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mastering programming - no problem</h1><div class="post__text post__text-html js-mediator-article"><h1>  What is this article about </h1><br>  Attempting to explain why the study of modern technologies is difficult, how to find the easiest way to master them and become an expert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a2a/81e/a32/a2a81ea32e78428d9c0b47c452959726.png" alt="image"></div><br><br><h1>  Who is this article for? </h1><br>  In order not to disappoint the reader, you must immediately decide for whom this article is intended.  First of all, this article may be useful for programmers who want to independently master the creation of software.  It may be useful to teachers of programming.  At the same time, she describes a point of view that may differ from the vision of professionals who have passed their way and have their own well-established understanding of things. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article is also more research than strong recommendations.  In view of this, it may require the reader to attempt to consider issues from the point of view of the author.  Also having a direct relationship to learning this article may seem useless and boring when viewed from a production point of view. <br><a name="habracut"></a><br><h1>  Foreword </h1><br>  Although information technologies are very developed these days, their mastering and becoming a qualified professional continues to be difficult.  The author, being an instructor coach, made several attempts to find his students the most convenient way to master programming and related topics.  This article is an attempt to build a simple structured picture of this issue. <br><br>  The author tried to write the article as simply as possible, to indicate the key principles of his vision and to offer a useful self-development strategy to specialists at all levels. <br><br>  The author began using the C # language since its inception.  Until this time, the author has gained rich experience in working with a variety of IT technologies - hardware, internal OS features, the language Assembler, C ++, COM, WinApi, networks, multithreading, etc ... These skills have essentially helped to master C #, as well as their new versions.  But for beginners, training also requires them to learn a lot of new technologies from various unfamiliar areas, which makes studying a long and difficult process. <br><br><h1>  Greatest difficulty </h1><br>  The greatest difficulty arising from the study of something is the huge number of different technologies, as well as the industrial sectors where these technologies can be applied.  Also, this number is constantly increasing (see the so-called "technological singularity"). <br><br>  Orientation in such a complex environment becomes very difficult.  Simple rules, explanation and strategy would be very helpful. <br><br><h1>  Man, Tool, Problem </h1><br>  To understand many important processes and elements of the training system, the Human-Tool-Problem link can be used. <br><br>  For the convenience of analyzing the problem, we take the following assumptions: <br><ul><li>  Man - the main character.  The person uses the Tool to solve the Problem.  A person must have the necessary skills to use the Tool; </li><li>  The problem is the main task for Man - it requires a solution; </li><li>  A tool is a tool to solve a Problem.  Each tool is designed to solve only specific problems.  That is, there is no Instrument capable of solving all problems.  A programming language is also a tool designed to solve the problems of creating software; </li><li>  During the solution of the Problem, the Person does not interact with it directly, but through the Tool (It is understood that the Tools make the interaction of the Person with the Problem easier than the direct interaction of Person-Problem. If such a tool does not exist, it should be created). </li></ul><br><br><h1>  Complexity of Problem and Tool </h1><br>  Different problems have different difficulty solving.  Accounting for the family budget is a much simpler task than managing the delivery of goods around the city. <br><br>  To simplify the explanation, we can consider the complexity of the problem only as the complexity of its solution.  The complexity of the tool, in turn, can be considered as the complexity of its use by humans.  The simpler the tool, the easier it is for a person to use it. <br><br>  Various tools can be used to solve one problem.  For ease of use Tools can be divided into groups: <br><ul><li>  <b>The most useful ones</b> are easy-to-use solving difficult problems; </li><li>  <b>Medium</b> - difficult to use solving difficult problems; </li><li>  <b>Useless</b> - difficult to use solving simple problems. </li></ul><br><br><h1>  Difficulty of Use </h1><br>  For a person, ease of use of the tool is most important.  The complexity of the tool can lead to delays, poor quality results, and the impossibility of solving the problem.  It goes without saying that the lack of a tool can be the cause of the complete impossibility of solving a problem (We don‚Äôt consider a solution without a tool - this is the rank of the simplest problems).  Thus, when creating a tool, the main criterion is ease of use. <br><br>  The complexity of something for a person can be classified as follows: <br><ul><li>  Too many simple elements.  These simple elements are very simple and require a complex composition to solve the problem.  Low-level languages ‚Äã‚Äãsuch as Assembler or MSIL are examples of languages ‚Äã‚Äãwith a similar type of complexity.  This level of complexity is most convenient to implement hardware, since the equipment is capable of performing a huge number of relatively simple actions; </li><li>  A small number of elements with a small number of properties.  This is the most convenient level of complexity for a person.  The basic elements of high-level languages ‚Äã‚Äãcan be attributed to this level; </li><li>  Items with too many properties.  Tools of this level of complexity are designed to solve a narrow range of tasks and require customization if the task is slightly different.  Software packages and libraries can be assigned to this level of complexity. </li></ul><br><br><h1>  Low, High, and Super High </h1><br><br>  The evolution of programming languages ‚Äã‚Äãhas led to an increase in the level of abstraction of programming languages ‚Äã‚Äãfrom the hardware platform: <br><ol><li>  Low-level languages ‚Äã‚Äãare convenient for hardware implementation, but difficult for a person due to the large number of commands that perform the simplest operations; </li><li>  High-level languages ‚Äã‚Äãare convenient for human understanding, which allows you to develop programs faster.  But these languages ‚Äã‚Äãare difficult to implement for hardware implementation, which generally leads to slower code and greater resource consumption; </li><li>  Very high-level programming languages ‚Äã‚Äã(VHLL) are programming languages ‚Äã‚Äãwith a very high level of abstraction.  Unlike high-level programming languages, where the ‚Äúhow to do‚Äù principle is described, in the super-high-level programming languages ‚Äã‚Äãonly the principle ‚Äúwhat needs to be done‚Äù is described. </li></ol><br><br>  With the normal development of programming languages, their level corresponds to the level of abstraction from the low hardware level.  With increasing abstraction complexity of use should not increase.  However, in reality, it can be difficult to understand.  Increasing the level of abstraction is almost always associated with the creation of large structures that hide the complexity inside and give the simplicity of their use from the outside. <br><br>  But for correct use in order to avoid negative side effects, the developer needs to know the internal structure of the structures.  So when using sockets in a network application, you need to know the appropriate network protocols and how networks work.  Without their understanding, it is unlikely to write a quality product in reality.  That is, increasing the level of abstraction simply hides the complexity inside, but does not eliminate it. <br><br>  The evolution of programming languages ‚Äã‚Äãshows their constant improvement, but over a long period of development has not simplified their understanding.  It should also be mentioned here that the range of problems solved by IT has significantly expanded - therefore, they remain complex. <br><br>  This evolution is not an easy process.  However, some features may help to understand this process: <br><ul><li>  The evolution of hardware platforms provides growth opportunities for the entire IT sector; </li><li>  The growing capacity of the IT sector allows these technologies to be used to solve increasingly complex and complex problems; </li><li>  Difficult problems can be solved only by tools that have internal complexity but are easy to use.  (If the tool is difficult to use - it is not necessary); </li><li>  Internally complex tools are more difficult to create (than internally simple ones); </li><li>  The complexity of programming languages ‚Äã‚Äãreflects the complexity of the tasks. </li></ul><br><br><h1>  The complexity of programming languages </h1><br>  The complexity of modern programming languages ‚Äã‚Äãis the result of the following main factors: <br><ul><li>  <b>Multithreading</b>  There is a constant increase in the parallelism of command execution, supported by a growing number of devices.  This requires additional forces to synchronize the flow and use of resources; </li><li>  <b>Complex components in standard libraries.</b>  There is a constant growth of components that are embedded in standard libraries and have a large number of properties.  It is necessary to know how these components are arranged internally in order to avoid negative side effects; </li><li>  <b>Multi-platform support.</b>  There is a steady increase in the range of devices and platforms that require ensuring the correct behavior of the program on as many devices as possible.  This is particularly evident for mobile applications; </li><li>  <b>Evolution.</b>  The development of other languages, the development of equipment and even commerce (a new version is a new product for sale in the market) influence a certain programming language. </li></ul><br><br><h1>  Upper-Level Languages </h1><br>  The described evolution of programming languages ‚Äã‚Äãhas led to the emergence of large components with a large number of properties.  The development of high-level languages ‚Äã‚Äãis based on low-level languages ‚Äã‚Äã(for example, compilation from high-level to low levels is used) by integrating small components (commands) into larger structures.  Among other things, the described processes have inertia, which ultimately translates the programming language from a high level further to the so-called Super-high. <br><br>  As noted, the growth of the level of abstraction leads to the appearance of large structures (elements of the language, functions, libraries, etc.) that hide the complexity in the internal implementation.  However, to create a high-quality product, it is necessary to know the internal implementation, operating time, consumed memory and other properties of the structures used.  This leads to a shift in complexity above from being convenient for the developer, as shown in the following figure. <br><br>  The figure shows the increase in complexity with a large number of simple elements or properties of elements.  As you can see tasks with a lot of simple elements, the corresponding low-level languages ‚Äã‚Äãare convenient for execution by a computer.  Tasks with components with multiple properties, in turn, are difficult for a single developer, but can be more easily mastered by a group of developers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6e6/254/87c/6e625487c7ce4413bfef305aadb195f3.png" alt="image"></div><br><br><h1>  Strategy </h1><br><h2>  First level </h2><br>  The easiest to learn programming level is the level where the number of components and properties of these components is convenient for the developer to understand.  Typically, these components reflect simple popular operations ‚Äî arithmetic operations, processing lines of text, input / output of simple data, and so on.  Most books begin the story from this level. <br><br>  At the initial stage, the most important thing is to understand the question - ‚Äúwhat's next?‚Äù This is a key tactical question, which allows you to see your development from the current point further.  The question ‚Äúwhat next?‚Äù Can arise in two important cases: <br><ul><li>  The developer is faced with the problem of not understanding the topic or method (the problem of getting stuck) or; </li><li>  The developer is faced with the problem that there are a large number of topics that can be studied (the problem of choice). </li></ul><br><br>  If the developer is stuck on any topic, he should change the direction (vector) of the study - find another way to study this topic or choose another topic to study.  If the developer is faced with the problem of choice - he just has to make a choice.  That is, you can not stop. <br><br>  After mastering the entry level, the developer can make a choice of further development in two main areas: <br><ul><li>  Low-level programming; </li><li>  High-level programming. </li></ul><br><br><h3>  Low-level programming </h3><br>  Low-level programming is hardware-friendly programming.  Mastering system programming requires learning low-level languages ‚Äã‚Äãand a platform.  The complexity of learning low-level languages, in turn, requires the study of a large number of small simple elements and ways of organizing them in a computer system. <br><br>  Low-level programming is a specific approach.  The developer must decide to follow this direction.  This is also a trend rarely chosen by developers. <br><br><h3>  High-level programming </h3><br>  High-level programming - programming, with the help of which software is usually created that automates major human life processes.  It is aimed at solving applied problems, without worrying about the optimization of the equipment operation. <br><br>  Such systems use high-level languages.  The complexity of the study here includes the study of larger (as compared with low-level programming) components of the language and a certain number of their properties.  So for example, developers need to know the internal structure and properties of containers (array, stack, hash table, ...) in order to apply them without negative side effects (high memory consumption, slowdown, etc.). <br><br>  The development of high-level languages ‚Äã‚Äãleads to an increase in the "size" of the constituent components and, accordingly, the number of their properties (both external and internal).  The complexity for the developer increases both in the need to study these components and their properties, and the need to keep track of the constant appearance of new components and versions. <br><br><h2>  Organization </h2><br>  The problems described above are not intractable.  However, if you do not take the right action, you can go to a dead end.  Many actions are known and clear.  The above description allows you to understand the effectiveness and necessity of these actions: <br><ul><li>  <b>Specialization.</b>  Since it is impossible to master all the features of a modern programming language, the available components and libraries, specialization allows you to select only one or a few areas (for example, desktop applications, network applications, function libraries, etc.) and work only with them; </li><li>  <b>Cooperation.</b>  The solution of many tasks by one developer is impossible due to specialization (as it was described it is impossible for one specialist to own a wide range of technologies).  Thus, the following necessary action occurs - cooperation with developers owning other technologies. </li></ul><br><br><h1>  Recommendations </h1><br>  Summing up we can highlight the following important facts: <br><ul><li>  In self-development and professional growth, knowledge of the direction of the desired development is needed - to higher level (more abstract) programming languages ‚Äã‚Äãor tasks close to the platform / hardware (for example, system programming or real-time systems programming); </li><li>  In the case of a stuck in studying a particular topic, you can not stop - you need to either change the way you study this topic or start another topic, putting aside the current until better times; </li><li>  If you choose, you also can not stop - you just need to make a choice.  And in no case can one be afraid of the fact that so many and all of them cannot be mastered; </li><li>  The aim should not be to study a wide range of topics, i.e.  need to specialize by choosing a specific series of topics; </li><li>  Even in mastering programming, cooperation is very important.  Communicate with other developers and participate in forums. </li></ul><br><br>  And most importantly, without the love of programming and the desire to work hard, learn programming and become a professional will not succeed. Even in the absence of talent, with perseverance you can achieve some results and find your place in a wide range of IT. </div><p>Source: <a href="https://habr.com/ru/post/302556/">https://habr.com/ru/post/302556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302544/index.html">Unwanted DNS Unlocker uses the DNS hijack method to trick users</a></li>
<li><a href="../302548/index.html">Security Week 22: Microsoft against passwords, legal issues with Tor, crypto-fiber attacks Amazon customers</a></li>
<li><a href="../302550/index.html">IBM introduces the world's first PCM memory with three bits per cell</a></li>
<li><a href="../302552/index.html">Dynamic blur on Android</a></li>
<li><a href="../302554/index.html">Uber founder Travis Kalanik - "a rebel in the elite of Silicon Valley"</a></li>
<li><a href="../302560/index.html">Mars rover Opportunity more than 40 times the planned service life</a></li>
<li><a href="../302562/index.html">How to set up two-factor authentication for login and sudo</a></li>
<li><a href="../302566/index.html">Wolfram Technologies: 4th Russian Conference</a></li>
<li><a href="../302568/index.html">Already 2016, and the future does not come. Who is to blame and what to do?</a></li>
<li><a href="../302570/index.html">Write the code as if it would be accompanied by a violent psychopath who knows where you live.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>