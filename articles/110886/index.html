<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>App Engine API under the hood</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This topic I want to open a series of translations blog Nick Johnson . Nick publishes extremely useful articles on GAE, shares his experience, and put...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>App Engine API under the hood</h1><div class="post__text post__text-html js-mediator-article">  <em>This topic I want to open a series of translations <a href="http://blog.notdot.net/">blog Nick Johnson</a> .</em>  <em>Nick publishes extremely useful articles on GAE, shares his experience, and puts on unusual experiments.</em>  <em>I hope these materials will be useful to you.</em> <br><br>  If you use the App Engine only for simple applications, it is better to refrain from further reading.  If you are interested in low-level optimizations or you want to write a library to work with the most intimate components of App Engine, please read more! <br><br><h3>  Common API </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Ultimately, each API call passes through one common interface with 4 arguments: the name of the service (for example, 'datastore_v3' or 'memcache'), the name of the method (for example, 'Get' or 'RunQuery'), request and response .  Request and response are <a href="http://en.wikipedia.org/wiki/Protocol_buffer">protocol buffers</a> ‚Äî a binary format commonly used by Google to exchange structured data between processes.  The specific type of request and response of the protocol buffers depends on the method called.  When an API call occurs, the request protocol buffer is generated from the data sent in the request, and the response protocol buffer remains empty and is subsequently filled with the data returned by the API call response. <br><a name="habracut"></a><br>  API calls are made by passing the four parameters described above to the 'dispatch' function.  In Python, the <a href="http://code.google.com/p/googleappengine/source/browse/trunk/python/google/appengine/api/apiproxy_stub_map.py">apiproxy_stub_map</a> module performs this role.  This module is responsible for maintaining the correspondence between the service name ‚Äî the first of the parameters described ‚Äî and the stub that processes it.  In the SDK, this correspondence is provided by creating local stubs ‚Äî modules that mimic the behavior of the API.  In production, the interfaces to the real API are transferred to this module during the start of the application, i.e.  before the application code is loaded.  A program that makes API calls should never care about implementing the APIs themselves;  she does not know how the call is handled: locally or was it serialized and sent to another machine. <br><br>  As soon as the dispatch function finds the appropriate stub for the called API, it sends a call to it.  What happens next depends entirely on the API and the environment, but in production as a whole the following happens: the protocol buffer request is serialized into binary data, which is then sent to the server (s) responsible for processing this API.  For example, calls to the repository are serialized and sent to the repository service.  This service deserializes the request, executes it, creates a response object, serializes it and sends it to the stub that made the call.  Finally, the stub de-serializes the response to the buffer protocol response and returns a value. <br><br>  You must be wondering why you need to handle the buffer protocol response in each API call.  This is because the protocol buffer format does not provide any way to distinguish the types of data being transferred;  It is assumed that you know the structure of the message you are planning to receive.  Therefore, it is necessary to provide a ‚Äúcontainer‚Äù that understands how to deserialize the response received. <br><br>  Let us look at an example of how this all works by running a low-level query to the repository ‚Äî the resulting entity instances by the key name: <br><blockquote><ol><li></li><li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li></li><li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li> <code><font color="black">from google.appengine.datastore import datastore_pb from google.appengine.api import apiproxy_stub_map def do_get(): request = datastore_pb.GetRequest() key = request.add_key() key.set_app(os.environ['APPLICATION_ID']) pathel = key.mutable_path().add_element() pathel.set_type('TestKind') pathel.set_name('test') response = datastore_pb.GetResponse() apiproxy_stub_map.MakeSyncCall('datastore_v3', 'Get', request, response) return str(response)</font></code> </li> <li></li></ol></blockquote><br>  Very thorough, right?  Especially in comparison with the similar high-level method - TestKind.get_by_key_name ('test')!  You must understand the entire sequence of actions: generating a request and a response of the protocol buffers, filling the request with relevant information (in this case, the name of the entity and the name of the key), then calling apiproxy_stub_map.MakeSyncCall to create a remote object (RPC).  When the call is completed, the answer is filled in, which can be seen by its string display: <br><blockquote><ol><li></li><li>  Entity { </li><li>  entity &lt; </li><li>  key &lt; </li><li>  app: "deferredtest" </li><li>  path &lt; </li><li>  Element { </li><li>  type: "TestKind" </li><li>  name: "test" </li><li>  } </li><li>  &gt; </li><li>  &gt; </li><li>  entity_group &lt; </li><li>  Element { </li><li>  type: "TestKind" </li><li>  name: "test" </li><li>  } </li><li>  &gt; </li><li>  property &lt; </li><li>  name: "test" </li><li>  value &lt; </li><li>  stringValue: "foo" </li><li>  &gt; </li><li>  multiple: false </li><li>  &gt; </li><li>  &gt; </li><li>  } </li><li></li></ol></blockquote><br>  Each remote call for each API uses the same pattern inside - only the set of parameters in the request and response objects are different. <br><br><h3>  Asynchronous calls </h3><br>  The process described above refers to a synchronous API call ‚Äî that is, we wait for a response before we can do anything further.  But the App Engine platform supports asynchronous API calls.  With asynchronous requests, we send a call to a stub, which is returned instantly, without waiting for a response.  Then we can request a response later (or wait for it if necessary) or set a callback function that will be automatically called when the answer is received. <br><br>  At the time of this writing, only some APIs support asynchronous calls, in particular, <a href="http://code.google.com/appengine/docs/python/urlfetch/asynchronousrequests.html">URL fetch APIs</a> , which are extremely useful for retrieving several web resources in parallel.  The principle of operation of the asynchronous API is the same as that of the ordinary ones - it simply depends on whether asynchronous calls are implemented in the library.  APIs like urlfetch are adapted for asynchronous operations, but other, more complex APIs are much more difficult to get to work asynchronously. <br>  Consider an example of how to convert a synchronous call to asynchronous.  Differences from the previous example are highlighted in bold: <br><blockquote><ol><li></li><li>  from google.appengine.datastore import datastore_pb </li><li>  from google.appengine.api import apiproxy_stub_map </li><li>  <b>from google.appengine.api import datastore</b> </li><li></li><li>  def do_ <b>async</b> _get (): </li><li>  request = datastore_pb.GetRequest () </li><li>  key = request.add_key () </li><li>  key.set_app (os.environ ['APPLICATION_ID']) </li><li>  pathel = key.mutable_path (). add_element () </li><li>  pathel.set_type ('TestKind') </li><li>  pathel.set_name ('test') </li><li>  response = datastore_pb.GetResponse () </li><li></li><li>  <b>rpc = datastore.CreateRPC ()</b> <br></li><li>  <b>rpc.make_call ('Get', request, response)</b> </li><li>  <b>return rpc, response</b> </li></ol></blockquote><br><br>  The differences are that we create an RPC object for one particular access to the repository and call its make_call () method, instead of MakeSyncCall ().  Then we return the object and the response of the protocol buffer. <br><br>  Since this is an asynchronous call, it was not completed when we returned the RPC object.  There are several ways to handle an asynchronous response.  For example, you can pass a callback function to the CreateRPC () method or call the .check_success () method of an RPC object to wait for the call to complete.  We demonstrate the last option, as it is easier to implement.  Here is a simple example of our function: <br><blockquote><ol><li></li><li>  TestKind (key_name = 'test', test = 'foo'). Put () </li><li>  self.response.headers ['Content-Type'] = 'text / plain' </li><li>  rpc, response = do_async_get () </li><li>  self.response.out.write ("RPC status is% s \ n"% rpc.state) </li><li>  rpc.check_success () </li><li>  self.response.out.write ("RPC status is% s \ n"% rpc.state) </li><li>  self.response.out.write (str (response)) </li><li></li></ol></blockquote><br>  Output: <br><blockquote><ol><li></li><li>  RPC status is 1 </li><li>  RPC status is 2 </li><li>  Entity { </li><li>  entity &lt; </li><li>  key &lt; </li><li>  app: "deferredtest" </li><li>  path &lt; </li><li>  Element { </li><li>  type: "TestKind" </li><li>  name: "test" </li><li>  } </li><li>  &gt; </li><li>  &gt; </li><li>  entity_group &lt; </li><li>  Element { </li><li>  type: "TestKind" </li><li>  name: "test" </li><li>  } </li><li>  &gt; </li><li>  property &lt; </li><li>  name: "test" </li><li>  value &lt; </li><li>  stringValue: "foo" </li><li>  &gt; </li><li>  multiple: false </li><li>  &gt; </li><li>  &gt; </li><li>  } </li><li></li></ol></blockquote><br>  The status constants are defined in the <a href="http://code.google.com/p/googleappengine/source/browse/trunk/python/google/appengine/api/apiproxy_rpc.py">google.appengine.api.apiproxy_rpc</a> module - in our case, 1 means ‚Äúin progress‚Äù, 2 means ‚Äúfinished‚Äù, which means that the RPC is really executed asynchronously!  The actual result of this query is, of course, the same as the regular synchronous one. <br><br>  Now that you know how low-level RPC works and how to make asynchronous calls, your capabilities as a programmer have greatly expanded.  Who will be the first to write a new asynchronous interface to the App Engine APIs like Twisted? </div><p>Source: <a href="https://habr.com/ru/post/110886/">https://habr.com/ru/post/110886/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../110873/index.html">A laptop is not for everyone, but for everyone</a></li>
<li><a href="../110876/index.html">SEO spam on –†–µ–π—Ç–∏–Ω–≥@Mail.ru!</a></li>
<li><a href="../110880/index.html">Holidays in calendars or who works the most</a></li>
<li><a href="../110881/index.html">New life of old Wi-Fi module</a></li>
<li><a href="../110884/index.html">PhpBB 3 and Kohana 3 integration</a></li>
<li><a href="../110888/index.html">Since January 1! Happy Public Domain Day!</a></li>
<li><a href="../110890/index.html">Life after copyright</a></li>
<li><a href="../110892/index.html">Family tree software</a></li>
<li><a href="../110893/index.html">Plan4Year - Plan for 2011</a></li>
<li><a href="../110894/index.html">Few conclusions? Use RESET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>