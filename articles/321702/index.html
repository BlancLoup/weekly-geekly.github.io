<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Incremental analysis in PVS-Studio: now also on the assembly server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 When implementing a static analyzer into an existing development process, the team may encounter certain difficulties. For example, it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Incremental analysis in PVS-Studio: now also on the assembly server</h1><div class="post__text post__text-html js-mediator-article"><p><img align="left" src="https://habrastorage.org/files/526/803/574/52680357457e499f87a9168307654576.png"></p><br><h2>  Introduction </h2><br>  When implementing a static analyzer into an existing development process, the team may encounter certain difficulties.  For example, it is very useful to check the modified code before it enters the version control system.  However, performing static analysis in this case can take quite a long time, especially on projects with a large code base.  In this article, we will look at the incremental analysis mode in the PVS-Studio static analyzer, which allows you to check only modified files, which significantly reduces the time required for code analysis.  Consequently, developers will be able to use static analysis as often as necessary, and minimize the risk of code containing an error in the version control system.  The reason for writing the article was, firstly, the desire to once again tell about such a useful function of our analyzer, and secondly, the fact that we completely rewrote the incremental analysis mechanism and added support for this mode to the version of our analyzer for the command line. <br><a name="habracut"></a><br><h2>  Static Analyzer Usage Scenarios </h2><br>  Any approach to improving software quality implies that defects should be detected as early as possible.  In an ideal situation, the code needs to be written without any errors at all, but nowadays this practice has been successfully implemented only in one corporation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fad/515/f76/fad515f767d3875e7673eb80448d0e0b.png" alt="Picture 1"></div><br>  Why is it so important to detect and fix errors as early as possible?  I will not speak here about such trivial things as reputational risks that inevitably arise if your users begin to detect defects in your software in large quantities.  Let's focus on the economic component of fixing errors in the code.  We do not have statistics on the average price of the error.  Errors are very different, are detected at different stages of the software life cycle, the software can be applied in different subject areas, both critical to errors and not so much.  Therefore, although the industry average cost of correcting a defect depending on the stage of the software life cycle is unknown, it is possible to estimate the change in this cost using the well-known rule ‚Äú1-10-100‚Äù.  With regard to software development, this rule states that if the cost of eliminating a defect at the design stage is 1?, Then after transferring this code to testing will be already 10?, And it grows to 100?  after the defect code is gone to production: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/858/1d8/f49/8581d8f49a61568209bc59bd323d84a1.png" alt="Picture 2"></div><br>  There are many reasons for such a rapid increase in the cost of correcting a defect, for example: <br><ul><li>  Changes to one part of the code can affect many other parts of the application. </li><li>  Repeating tasks that have already been done: design changes, coding, documentation adjustments, etc. </li><li>  Delivery of the revised version to users, the need to convince users to upgrade. </li></ul><br>  Understanding the importance of eliminating errors at the earliest stages of the software life cycle, we offer our customers to use a two-level code verification scheme with a static analyzer.  The first level is the verification of the code on the developer‚Äôs computer before the code is incorporated into the version control system.  That is, the developer writes some piece of code and immediately inspects it with a static analyzer.  For this task, we have a plugin for Microsoft Visual Studio (all versions from 2010 to 2015 are supported).  The plugin allows you to check one or more source code files, one or several projects, or the entire solution. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second level of protection is the launch of static analysis during the nightly build of the project.  This allows you to make sure that new errors were not added to the version control system, or to take the necessary actions to correct these errors.  In order to minimize the risk of errors penetrating into the later stages of the software life cycle, we propose to use both levels of static analysis: locally on the developers' machines and on the centralized server of continuous integration. <br><br>  This approach, however, is not without flaws and does not guarantee that errors that can be detected by the static analyzer will not get into the version control system or, as a last resort, will be corrected before the build goes into testing.  Forcing developers to manually perform static analysis before a commit will most likely encounter strong resistance.  First, on projects with a large code base, no one wants to sit and wait until the project is verified.  Or, if the developer decides to save time and check only those files in which he has changed the code, he will have to keep records of changed files, which, naturally, no one will do either.  If we consider an assembly server, on which, besides nightly assemblies, an assembly is also set up after detecting changes in the version control system, then performing a static analysis of the entire code base during numerous daytime assemblies is also not applicable due to the fact that static analysis will take a long time . <br><br>  An incremental analysis mode that allows you to check only recently modified files helps to solve these problems.  Let us consider in more detail what advantages the incremental analysis mode can bring when used on developers' computers and on an assembly server. <br><br><h2>  Incremental analysis on the developer's computer - a barrier to bugs in the version control system </h2><br>  If the development team decided to use static code analysis, and the analysis is performed only on the build server, during, for example, nightly builds, sooner or later, the developers will begin to perceive the static analyzer as an enemy.  It is not surprising, because all team members will see what mistakes their colleagues make.  We strive to ensure that all project participants perceive the static analyzer as a friend and as a useful tool that helps improve the quality of the code.  In order for errors that a static analyzer can detect, not to get into the version control system and for everyone to see, static analysis should also be performed on the developers' computers in order to detect possible problems in the code as early as possible. <br><br>  As I already mentioned, manual launch of static analysis on the entire code base can take quite a long time.  If the developer is forced to remember which files with the source code he worked on, it will also be very annoying. <br><br>  Incremental analysis allows you to reduce the time it takes to perform a static analysis, and get rid of the need to manually run the analysis.  Incremental analysis starts automatically after building a project or solution.  We consider this trigger as the most suitable for launching the analysis.  It is logical to check that the project is going, before making changes to the version control system.  Thus, the incremental analysis mode allows you to get rid of the annoying actions associated with the need to manually perform static analysis on the developer's computer.  Incremental analysis is performed in the background, so the developer can continue to work on the code, without waiting for the end of the test. <br><br>  You can enable the post-assembly incremental analysis mode in the PVS-Studio / Incremental Analysis After Build (Modified Files Only) menu, this item is activated in PVS-Studio by default: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/933/d84/ca7/933d84ca763c02042cec4cb7ee5c2e7d.png" alt="Picture 3"></div><br>  After activating the incremental analysis mode, PVS-Studio will automatically in the background analyze all the affected files immediately after the project has finished building.  If PVS-Studio detects such modifications, the incremental analysis will be automatically launched, and the animated PVS-Studio icon will appear in the Windows notification area: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf0/3af/165/bf03af165e9124e96d47a65165d740b4.png" alt="Picture 4"></div><p></p><br>  Details related to the use of incremental analysis are discussed in the article <a href="http://www.viva64.com/ru/m/0024/">PVS-Studio's incremental analysis mode</a> . <br><br><h2>  Incremental analysis on a continuous integration server - an additional barrier to bugs </h2><br>  The practice of continuous integration means that the project is assembled on the build server after each commit to the version control system.  As a rule, besides the project build, the existing set of unit tests is also executed.  In addition to unit tests, many teams that use the practice of continuous integration use an assembly server to provide continuous quality control processes.  For example, in addition to running modular and integration tests, these processes may include performing static and dynamic analysis, measuring performance, etc. <br><br>  One of the important requirements for the tasks performed on the continuous integration server is that the project must be built quickly and all additional actions must be completed so that the team can quickly respond to the detected problems.  Performing static analysis on a large code base after each commit to a version control system is contrary to this requirement, since this can take a very long time.  We did not agree to put up with this restriction, so we looked at our plug-in for Visual Studio, which already has an incremental analysis mode for a long time, and asked ourselves: why don't we implement the same mode in the command line module PVS-Studio_Cmd.exe ? <br><br>  It is said - done, and in our module for the command line, which is designed to integrate the static analyzer into various building systems, an incremental analysis mode has appeared.  This mode works the same way as incremental analysis in a plugin. <br><br>  Thus, with the addition of support for incremental analysis in PVS-Studio_Cmd.exe, it became possible to use our static analyzer in the continuous integration system during numerous daily builds.  Due to the fact that only the modified files will be checked since the last update of the code from the version control system, static analysis will be performed very quickly and the project will not be prolonged much longer. <br><br>  To activate the incremental analysis mode in the module for the PVS-Studio_Cmd.exe command line, specify the <i>--incremental</i> key and set one of the following modes of operation: <br><br><ul><li>  Scan - analyze all dependencies to determine which files should be used for incremental analysis.  The analysis itself will not be performed. </li><li>  Analyze - perform incremental analysis.  This step must be performed after the Scan step, and can be performed both before and after assembling the solution or project.  Static analysis will be performed only for modified files since the last build. </li><li>  ScanAndAnalyze ‚Äî analyze all dependencies to determine on which files the incremental analysis should be performed, and immediately perform an incremental analysis of the modified files with the source code. </li></ul><br>  For more information about the incremental analysis mode in the PVS-Studio_Cmd.exe command line module, refer to the <a href="http://www.viva64.com/ru/m/0024/">PVS-Studio incremental analysis mode</a> and <a href="http://www.viva64.com/ru/m/0035/">Visual C ++ Verification (.vcxproj) and Visual C # (.csproj) projects from the command line using PVS-Studio</a> . <br><br>  I also want to note that the use of the BlameNotifier utility supplied in the PVS-Studio distribution is perfectly combined with the functionality of the incremental analysis.  This utility interacts with popular version control systems (Git, Svn, and Mercurial are currently supported) to get information about which developer has committed code that contains errors and send notifications to these developers. <br><br>  Thus, we recommend using the following scenario of using a static analyzer on a continuous integration server: <br><br><ul><li>  for multiple daily builds, perform incremental analysis to control the quality of the code of the modified files only; </li><li>  for nightly assembly, it is advisable to perform a full analysis of the entire code base in order to have complete information about defects in the code. </li></ul><br><h2>  Features of the implementation of the incremental analysis mode in PVS-Studio </h2><br>  As I have already noted, the mode of incremental analysis in the PVS-Studio plugin for Visual Studio has existed for a long time.  In the plugin, the definition of modified files for which incremental analysis should be performed was implemented using Visual Studio COM wrappers.  This approach is absolutely inapplicable to the implementation of the mode of incremental analysis in the version of our analyzer for the command line, since it is completely independent of the internal infrastructure of Visual Studio.  Support for different implementations that perform the same function in different components is not a good idea, so we immediately decided that the plugin for Visual Studio and the command line utility PVS-Studio_Cmd.exe would use a common code base. <br><br>  Theoretically, the task of detecting modified files since the last build of the project is not particularly difficult.  To solve this problem, we need to obtain the modification time of the target binary file and the modification time of all the files that participated in the construction of the target binary file.  Those source code files that were modified later than the target file should be added to the list of files for incremental analysis.  The real world, however, is much more complicated.  In particular, for projects implemented in C or C ++, it is very difficult to identify all the files that participated in the construction of the target file, for example, those header files that were directly connected in the code and are not in the project file.  Here I want to note that under Windows and our plug-in for Visual Studio (which is obvious), the command-line version PVS-Studio_Cmd.exe only supports the analysis of MSBuild projects.  This fact greatly simplified our task.  It is also worth mentioning that in Linux version of PVS-Studio it is also possible to use incremental analysis - there it works out of the box: when using compilation monitoring, only the collected files will be analyzed.  Accordingly, with incremental build, incremental analysis will start;  with direct integration into the build system (for example, in make files), the situation will be similar. <br><br>  MSBuild has a file tracking mechanism ( <a href="https://msdn.microsoft.com/en-us/library/ee886424.aspx%3Ff%3D255%26amp%3BMSPPError%3D-2147217396">File Tracking</a> ).  For an incremental build of projects implemented in C and C ++, correspondences between source files (for example, cpp files, header files) and target files are recorded in * .tlog files.  For example, for a <a href="https://msdn.microsoft.com/en-us/library/ee862477.aspx%3Ff%3D255%26amp%3BMSPPError%3D-2147217396">CL task, the</a> paths to all source files read by the compiler will be written to the CL.read. {ID} .tlog file, and the paths to the target files will be stored in the CL.write. {ID} .tlog file. <br><br>  So, in the CL. *. Tlog files we already have all the information about the source files that were compiled and the target files.  The task is gradually simplified.  However, it still remains the task to bypass all the source and target files and compare the dates of their modification.  Is it possible to simplify more?  Of course!  In the <a href="https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.aspx">Microsoft.Build.Utilities</a> namespace <a href="https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.aspx">,</a> we find the classes <a href="https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.canonicaltrackedinputfiles.aspx%3Ff%3D255%26amp%3BMSPPError%3D-2147217396">CanonicalTrackedInputFiles</a> and <a href="https://msdn.microsoft.com/en-us/library/microsoft.build.utilities.canonicaltrackedoutputfiles.aspx%3Ff%3D255%26amp%3BMSPPError%3D-2147217396">CanonicalTrackedOutputFiles</a> , which are responsible for working with the CL.read. *. Tlog and CL.write. *. Tlog files, respectively.  Creating instances of these classes and using the method <a href="https://msdn.microsoft.com/en-us/library/dd984925.aspx%3Ff%3D255%26amp%3BMSPPError%3D-2147217396">CanonicalTrackedInputFiles.ComputeSourcesNeedingCompilation</a> , we obtain a list of source files that need to be compiled, based on the analysis of the target files and the dependency graph of the source files. <br><br>  Here is an example of code that allows you to get a list of files on which to perform an incremental analysis, using the chosen approach.  In this example, <i>sourceFiles</i> is a collection of full normalized paths to all project source files, <i>tlogDirectoryPath</i> is the path to the directory where * .tlog files are located: <br><br><pre><code class="cpp hljs">var sourceFileTaskItems = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ITaskItem[sourceFiles.Count]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var index = <span class="hljs-number"><span class="hljs-number">0</span></span>; index &lt; sourceFiles.Count; index++) sourceFileTaskItems[index] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(sourceFiles[index]); var tLogWriteFiles = GetTaskItemsFromPath(<span class="hljs-string"><span class="hljs-string">"CL.write.*"</span></span>, tlogDirectoryPath); var tLogReadFiles = GetTaskItemsFromPath(<span class="hljs-string"><span class="hljs-string">"CL.read.*"</span></span>, tlogDirectoryPath); var trackedOutputFiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CanonicalTrackedOutputFiles(tLogWriteFiles); var trackedInputFiles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CanonicalTrackedInputFiles(tLogReadFiles, sourceFileTaskItems, trackedOutputFiles, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); ITaskItem[] sourcesForIncrementalBuild = trackedInputFiles.ComputeSourcesNeedingCompilation(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Thus, using standard MSBuild tools, we achieved that the mechanism for determining files for incremental analysis is identical to the internal mechanism for MSBuild for incremental assembly, which ensures a very high reliability of this approach. <br><br><h2>  Conclusion </h2><br>  In this article, we looked at the benefits of using incremental analysis on developers' computers and on the build server.  We also looked under the hood and learned how, using the capabilities of MSBuild, to determine which files to perform incremental analysis for.  I suggest everyone who is interested in the capabilities of our product, download the trial version of the <a href="http://www.viva64.com/ru/pvs-studio-download/">PVS-Studio</a> analyzer and see what can be found in your projects.  All quality code! <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0475/"><img src="https://habrastorage.org/files/8d2/41b/5bf/8d241b5bf34747169141ed7c1997143b.png"></a> </div><br><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Pavel Kuznetsov.  <a href="http://www.viva64.com/en/b/0475/">Incremental analysis in PVS-Studio: now on the build server</a> <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. </div></div></div><p>Source: <a href="https://habr.com/ru/post/321702/">https://habr.com/ru/post/321702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321692/index.html">Distributed xargs, or Execution of Heterogeneous Applications on Hadoop Cluster</a></li>
<li><a href="../321694/index.html">Personal experience: Raiffeisen, Alfa-Bank and VTB24</a></li>
<li><a href="../321696/index.html">Remotely reinstalling Linux via ssh without accessing the console</a></li>
<li><a href="../321698/index.html">Advanced Threat Protection in Windows Defender</a></li>
<li><a href="../321700/index.html">Stream WebRTC video stream from browser to YouTube Live in 65 lines of JavaScript / HTML code</a></li>
<li><a href="../321704/index.html">Multifactor analyzer of arbitrary enterprise activity on the IEM platform</a></li>
<li><a href="../321708/index.html">A note about licensing Windows Server or how not to bankrupt a company during a licensed audit</a></li>
<li><a href="../321710/index.html">Free QGIS and NextGIS geographic information solutions</a></li>
<li><a href="../321714/index.html">How IT professionals work. Andrei Gajariga, Head of Development and Development, Orange Business Services</a></li>
<li><a href="../321716/index.html">When a bug is inseparable from features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>