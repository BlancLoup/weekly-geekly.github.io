<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to frameworks (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 

 Second generation frameworks  This generation is an intermediate level of automated testing frameworks, among them there can be quite simple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to frameworks (Part 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/6c7/c6b/ebf/6c7c6bebf6c4788d38f9a84192339273.png" align="left" alt="Testing"><br>  <a href="http://habrahabr.ru/post/150508/">Part 1</a> <br><br><h4>  Second generation frameworks </h4>  This generation is an intermediate level of automated testing frameworks, among them there can be quite simple frameworks, and they can be quite well designed.  Such frameworks should be considered in the case when the support of autotests is an important factor.  A good understanding of this generation of frameworks is important, since third-generation frameworks are based on the concepts of frameworks of this level. <br>  Second-generation frameworks include data-oriented frameworks and frameworks using functional decomposition.  Most frameworks of this level are hybrids and use both approaches, but since only one of them can be used, these approaches will be considered independently of each other. <br><a name="habracut"></a><br><h5>  Functional decomposition </h5>  Functional decomposition in a broad sense is the process of creating modular components (user-defined functions) in such a way that automated testing scripts can be created by combining these components. <br><img src="https://habrastorage.org/storage2/c57/ab4/f4b/c57ab4f4b78ef75d0deaa66a5ead2802.png" alt="Reusable functions"><br>  Modularity is often used to implement functionality tests for the application under test, but there are other user-defined functions that can be created.  These functions include: <br><ul><li>  <b>Utilities</b> - here you can include functions related to the main mechanisms of the framework or providing access to the basic functionality of the application under test.  For example, the function responsible for logging into an application can be viewed as a utility function.  These functions can be determined from requirements or based on ‚Äúmanual‚Äù test cases related to groups of tests intended for automation. </li><li>  <b>Navigation functions</b> - in most applications there are several main areas, the transition between which during testing is carried out repeatedly.  The implementation of transitions is a basic component and can be easily determined at the very beginning of the automation process. </li><li>  <b>Error handling functions</b> are created to deal with unexpected situations that may arise during testing. </li><li>  <b>All other functions</b> are not in any of the categories listed above. </li></ul>  Framework based on functional decomposition may vary in complexity depending on the complexity of the functions included in them.  Functions can be created for solving simple tasks, such as working with menus, as well as for complex functional procedures, complex error handling systems, and reporting mechanisms. <br><br><h6>  The advantages of functional decomposition </h6><ul><li>  <b>Increase code reuse</b> - after the application of functional decomposition the volume of reuse is greatly increased, since the code sections combined into functions can be accessed for calls by various tests.  The redundancy of the source code can be reduced both for all tests of one application, and for tests of different applications, depending on the level of abstraction of functions created.  With the increase in reuse volumes, the ease of support grows. </li><li>  <b>Script independence</b> - although a framework with functional decomposition may use external components, individual tests are not reused.  This allows you to implement reuse while maintaining the independence of the scripts. </li><li>  <b>Early development of scripts</b> - in some cases, functional decomposition allows you to start developing automated tests even before the application is ready.  Using information obtained from requirements or other documentation, a component template can be created, which can then be used to develop autotests using the top-down approach. </li><li>  <b>Ease of reading</b> - when dividing scripts into logical components, autotests are easier to maintain, since it is enough just to visually determine which result should be obtained when the script is applied. </li><li>  <b>Standardization growth</b> - with an increase in the number of reusable components standardization grows, which helps in the development of autotests, as the number of intuitive actions in writing code and its support decreases. </li><li>  <b>Simple implementation of error handling</b> - local solutions for error handling in different scripts create difficulties when adding and maintaining.  With the use of reusable components, error handling can be implemented, spanning multiple scripts.  Ultimately, this will improve the efficiency of automatic tests. </li></ul><br><h6>  Disadvantages of functional decomposition </h6><ul><li>  <b>It requires technical knowledge</b> - after the automated testing framework begins to use more technical solutions than the first generation framework, more technically competent specialists are required for its design, development and support.  This position is true for a framework that uses functional decomposition. </li><li>  <b>Less effect from intuitive actions</b> ‚Äî to effectively use an advanced framework, you need to rely less on intuition and more on standards.  Standardization is a positive result of functional decomposition, but at the same time it creates the need to provide sources of data on standards, to understand standards and to be able to apply them.  Most likely, to familiarize yourself with the capabilities of the framework, you will need documentation describing them. </li><li>  <b>The support process becomes more complex</b> - along with the increasing complexity of the framework, the complexity of autotest support grows.  When using linear scripts, fixes affect only the autotest that has stopped working.  Although this may lead to redundancy (since one change to the application under test can lead to failures at once in several autotests), the use of linear scripts helps to make maintenance less complicated.  When using functional decomposition, support is often required both for the framework itself and for the scripts using it.  Although this may reduce the amount of support activities, it also increases the complexity of servicing autotests. </li></ul><br><h5>  Data orientation </h5>  The frameworks created using this approach are similar to the first-generation frameworks in that the majority of components used in scripts are mainly within these scenarios.  The difference is in the way of working with data.  Data-oriented frameworks usually store information in sources that are external to scripts.  Using parameterization of the fields for entering application data and binding external data to the corresponding parameters, test data is not placed inside the script itself. <br>  Below is an example of a linear script. <br><blockquote><ol><li>  <font color="#FF8000">Input</font> ‚ÄúJohn‚Äù into Username textbox </li><li>  <font color="#FF8000">Input</font> ‚ÄúJPass‚Äù into Password textbox </li><li>  Click Login button </li><li>  <font color="#0600FF">If</font> ‚ÄúWelcome Screen‚Äù exists <font color="#FF8000">then</font> </li><li>  Pass the test </li><li>  <font color="#FF8000">Else</font> </li><li>  Fail the test </li><li>  <font color="#0600FF">End</font> <font color="#0600FF">if</font> </li></ol></blockquote>  The data-oriented version of this script will use information from an external source (spreadsheet, database, XML file, etc.), something like the one shown below. <br><table><tbody><tr><th>  <b>NameParameter</b> </th><th>  <b>PasswordParameter</b> </th></tr><tr><td>  John </td><td>  Jpass </td></tr><tr><td>  Sue </td><td>  SPass </td></tr><tr><td>  Randy </td><td>  RPass </td></tr><tr><td>  Trina </td><td>  TPass </td></tr></tbody></table>  The data-driven version of the linear script shown above may look like this: <br><blockquote><ol><li>  <font color="#0600FF">Open</font> data table </li><li>  <font color="#FF8000">Input</font> &lt;NameParameter&gt; in Username textbox </li><li>  <font color="#FF8000">Input</font> &lt;PasswordParameter&gt; into Password textbox </li><li>  Click Login button </li><li>  <font color="#0600FF">If</font> ‚ÄúWelcome Screen‚Äù exists <font color="#FF8000">then</font> </li><li>  Pass the test </li><li>  <font color="#FF8000">Else</font> </li><li>  Fail the test </li><li>  <font color="#0600FF">End</font> <font color="#0600FF">if</font> </li><li>  <font color="#0600FF">Close</font> Data Table </li></ol></blockquote>  Note that the data has been removed from the script and replaced with parameters. <br>  This approach allows you to use the same code on different data.  Data orientation is often viewed as a technique contrary to the frameworks, but its use can help reuse the same script using different information.  This approach does not solve many of the problems inherent in linear scenarios, but it can be useful. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  The benefits of data orientation </h6><ul><li>  <b>Reuse</b> - this approach provides a relatively simple way to reuse automated tests.  A piece of code can be used with various data, providing the ability to perform many automated tests with minimization of the script creation phase. </li><li>  <b>Simplicity of implementation</b> - the simplicity is that only minimal updates of existing scripts are required, often consisting only of parameterization and the conclusion of the body of an already existing test inside the loop. </li></ul><br><h6>  Lack of data orientation </h6>  The disadvantages of this approach include the following aspects inherited from linear scripts (see <a href="http://habrahabr.ru/post/150508/">Part 1</a> ): <br><ul><li>  <b>Redundancy.</b> </li><li>  <b>One dimensionality</b> </li><li>  <b>Difficult to read.</b> </li><li>  <b>Requires a higher level of knowledge to support.</b> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/150603/">https://habr.com/ru/post/150603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150598/index.html">The practice of obtaining and using digital signatures when submitting reports to government agencies</a></li>
<li><a href="../150599/index.html">There, the dwarf leader for the quest gives the quest until you get bored</a></li>
<li><a href="../150600/index.html">Kindle touch paperwhite</a></li>
<li><a href="../150601/index.html">Study schedules online. The history of the startup Schoodle</a></li>
<li><a href="../150602/index.html">The strange logic of the programmers of Sberbank is dedicated to</a></li>
<li><a href="../150604/index.html">John's Phone - the world's simplest mobile phone.</a></li>
<li><a href="../150606/index.html">Share your impressions on Yandex.Maps</a></li>
<li><a href="../150607/index.html">Recommended systems: LDA</a></li>
<li><a href="../150608/index.html">We return to the distribution or how to do the impossible</a></li>
<li><a href="../150609/index.html">Hard disk in the printer / MFP - convenience or excess?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>