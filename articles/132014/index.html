<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Operator Overloading in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! 

 The desire to write this article appeared after reading the post Overloading C ++ operators , because many important topics were not cove...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Operator Overloading in C ++</h1><div class="post__text post__text-html js-mediator-article">  Good day! <br><br>  The desire to write this article appeared after reading the post <a href="http://habrahabr.ru/blogs/cpp/123417/">Overloading C ++ operators</a> , because many important topics were not covered in it. <br><br>  The most important thing to remember is operator overloading, it‚Äôs just a more convenient way to call functions, so don‚Äôt get carried away with operator overloading.  It should be used only when it is easier to write code.  But not enough to make it difficult to read.  After all, as you know, the code is read much more often than it is written.  And do not forget that you will never be allowed to overload operators in a tandem with built-in types, the possibility of overloading is only for custom types / classes. <br><a name="habracut"></a><br><h4>  Overload syntax </h4><br>  The syntax for operator overloading is very similar to the definition of a function named operator @, where @ is the operator identifier (for example +, -, &lt;&lt;, &gt;&gt;).  Consider the simplest example: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Integer(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i): value(i) {} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; rv) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (value + rv.value); } };</code> </pre> <br>  In this case, the operator is designed as a member of the class, the argument specifies the value on the right side of the operator.  In general, there are two main ways of overloading operators: global functions, class- <a href="http://en.wikipedia.org/wiki/Friend_function">friendly</a> , or inline functions of the class itself.  What way, for which operator is better, consider at the end of the topic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In most cases, operators (except conditional) return an object, or a reference to the type to which its arguments relate (if the types are different, then you decide how to interpret the result of the calculation of the operator). <br><br><h4>  Overloading unary operators </h4><br>  Consider examples of overloading unary operators for the Integer class defined above.  At the same time, we define them as friendly functions and consider decrement and increment operators: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Integer(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i): value(i) {} <span class="hljs-comment"><span class="hljs-comment">// + friend const Integer&amp; operator+(const Integer&amp; i); // - friend const Integer operator-(const Integer&amp; i); //  friend const Integer&amp; operator++(Integer&amp; i); //  friend const Integer operator++(Integer&amp; i, int); //  friend const Integer&amp; operator--(Integer&amp; i); //  friend const Integer operator--(Integer&amp; i, int); }; //    . const Integer&amp; operator+(const Integer&amp; i) { return i.value; } const Integer operator-(const Integer&amp; i) { return Integer(-i.value); } //      const Integer&amp; operator++(Integer&amp; i) { i.value++; return i; } //      const Integer operator++(Integer&amp; i, int) { Integer oldValue(i.value); i.value++; return oldValue; } //      const Integer&amp; operator--(Integer&amp; i) { i.value--; return i; } //      const Integer operator--(Integer&amp; i, int) { Integer oldValue(i.value); i.value--; return oldValue; }</span></span></code> </pre><br>  Now you know how the compiler distinguishes between prefix and postfix versions of decrement and increment.  In the case when he sees the expression ++ i, then the function operator ++ (a) is called.  If he sees i ++, operator ++ (a, int) is called.  That is, the overloaded function operator ++ is called, and it is for this that the dummy int parameter is used in the postfix version. <br><br><h4>  Binary operators </h4><br>  Consider the syntax for overloading binary operators.  We will overload one operator that returns the l-value, one conditional operator, and one operator that creates a new value (we define them globally): <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Integer(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i): value(i) {} <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; right); <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> Integer&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(Integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; right); <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; right); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; right) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Integer(left.value + right.value); } Integer&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(Integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; right) { left.value += right.value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; right) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left.value == right.value; }</code> </pre><br>  In all these examples, operators are overloaded for one type, however, this is not necessary.  It is possible, for example, to overload the addition of our type Integer and Float defined by its similarity. <br><br><h4>  Arguments and Return Values </h4><br>  As you can see, the examples use different ways to pass arguments to functions and return operator values. <br><ul><li>  If the argument is not changed by the operator, in the case of, for example, a unary plus, it must be passed as a reference to a constant.  In general, this is true for almost all arithmetic operators (addition, subtraction, multiplication ...) </li><li>  The type of return value depends on the essence of the operator.  If the operator must return a new value, it is necessary to create a new object (as in the case of a binary plus).  If you want to forbid changing an object as l-value, then you need to return it as a constant. </li><li>  For assignment statements, you must return a reference to the changed item.  Also, if you want to use an assignment operator in constructions of the form (x = y) .f (), where the function f () is called for the variable x, after assigning it to y, then do not return a reference to a constant, simply return the reference. </li><li>  Logical operators must return an int at worst, and at the best a bool. </li></ul><br><br><h4>  Return value optimization </h4><br>  When creating new objects and returning them from a function, use the record as for the above-described example of the binary plus operator. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Integer(left.value + right.value);</code> </pre> <br>  Honestly, I don‚Äôt know which situation is relevant for C ++ 11, all the reasoning is further valid for C ++ 98. <br>  At first glance, this is similar to the syntax for creating a temporary object, that is, as if there is no difference between the code above and this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">temp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(left.value + right.value)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp;</code> </pre><br>  But in fact, in this case the constructor will be called in the first line, then the copy constructor will be called, which will copy the object, and then, when the stack is expanded, the destructor will be called.  When using the first record, the compiler initially creates an object in memory into which to copy it, thus saving a call to the copy constructor and destructor. <br><br><h4>  Special operators </h4><br>  In C ++, there are statements that have a specific syntax and overload method.  For example, the index operator [].  It is always defined as a member of the class and, since it implies the behavior of the object being indexed as an array, it should return a reference. <br><br><h5>  Operator comma </h5><br>  The ‚Äúspecial‚Äù operators also include the comma operator.  It is called for objects that have a comma next to it (but it is not called in function argument lists).  It‚Äôs not so easy to come up with a meaningful example of using this operator.  Habrayuzer <a href="https://habrahabr.ru/users/axispod/" class="user_link">AxisPod</a> in the comments to the previous article on overload <a href="http://habrahabr.ru/blogs/cpp/123417/">told about one</a> . <br><br><h5>  Pointer dereference operator </h5><br>  Overloading these operators can be justified for classes of smart pointers.  This operator is necessarily defined as a function of a class, and some restrictions are imposed on it: it must return either an object (or reference) or a pointer that allows access to the object. <br><br><h5>  Assignment operator </h5><br>  The assignment operator is necessarily defined as a class function, because it is inextricably linked with the object to the left of the "=".  The definition of the assignment operator in a global form would make it possible to redefine the standard behavior of the operator "=".  Example: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Integer(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i): value(i) {} Integer&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Integer&amp; right) { <span class="hljs-comment"><span class="hljs-comment">//   if (this == &amp;right) { return *this; } value = right.value; return *this; } };</span></span></code> </pre><br><br>  As you can see, a self-assignment check is performed at the beginning of the function.  In general, in this case, self-assignment is harmless, but the situation is not always so simple.  For example, if the object is large, you can spend a lot of time on unnecessary copying, or when working with pointers. <br><br><h5>  Non-transferable operators </h5><br>  Some operators in C ++ are not overloaded in principle.  Apparently, this is done for security reasons. <br><br><ul><li>  The selector operator of the class ".". </li><li>  The pointer dereference operator to the member of the class ". *" </li><li>  In C ++ there is no exponentiation operator (as in Fortran) "**". </li><li>  It is forbidden to define their own operators (there may be problems with prioritization). </li><li>  Operator priorities cannot be changed. </li></ul><br><br><h4>  Recommendations to the form of definition of operators </h4><br>  As we have already found out, there are two ways of operators - in the form of a class function and in the form of a friendly global function. <br>  Rob Murray, in his book <a href="http://www.amazon.com/Strategies-Tactics-Robert-B-Murray/dp/0201563827">C ++ Strategies and Tactics,</a> defined the following guidelines for choosing the form of an operator: <br><table><tbody><tr><td>  <b>Operator</b> <br></td><td>  <b>Recommended form</b> <br></td></tr><tr><td>  All unary operators <br></td><td>  Class member <br></td></tr><tr><td>  = () [] -&gt; -&gt; * <br></td><td>  Required class member <br></td></tr><tr><td>  + = - = / = * = ^ = &amp; = | =% = &gt;&gt; = &lt;&lt; = <br></td><td>  Class member <br></td></tr><tr><td>  Remaining binary operators <br></td><td>  Not a member of the class <br></td></tr></tbody></table><br><br>  Why is that?  First, some operators were initially restricted.  In general, if semantically there is no difference in how to define an operator, then it is better to arrange it as a function of a class in order to emphasize the connection, plus in addition the function will be inline.  In addition, sometimes it may be necessary to represent the left-hand operand as an object of another class.  Probably the most striking example is redefining &lt;&lt; and &gt;&gt; for input / output streams. <br><br><h4>  Literature </h4><br>  Bruce Ekkel - <a href="http://www.ozon.ru/context/detail/id/1631049/">Philosophy C ++.</a>  <a href="http://www.ozon.ru/context/detail/id/1631049/">Introduction to standard C ++</a> . </div><p>Source: <a href="https://habr.com/ru/post/132014/">https://habr.com/ru/post/132014/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../132006/index.html">Videos from our Qt-training for beginners</a></li>
<li><a href="../132008/index.html">Section "My things"</a></li>
<li><a href="../132009/index.html">Experience using the ThinkPad Tablet</a></li>
<li><a href="../132010/index.html">The mathematician composed ‚Äúthe most unpleasant music in the world‚Äù</a></li>
<li><a href="../132013/index.html">Captcha when registering on Habr√©</a></li>
<li><a href="../132017/index.html">Generating a version of the android application from the subversion revision and git</a></li>
<li><a href="../132020/index.html">Batch Usage Example</a></li>
<li><a href="../132021/index.html">Robanuka - the intersection of it-blogs</a></li>
<li><a href="../132022/index.html">Adidas website hacked</a></li>
<li><a href="../132023/index.html">Synology DiskStation 211j Review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>