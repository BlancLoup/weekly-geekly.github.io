<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Under the hood Ethereum Virtual Machine. Part 1 - Solidity basics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, the words ‚Äúcryptocurrency‚Äù and ‚Äúblockchain‚Äù can be heard more and more often in the news and, as a result, there is an influx of a large num...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Under the hood Ethereum Virtual Machine. Part 1 - Solidity basics</h1><div class="post__text post__text-html js-mediator-article"><p>  Recently, the words ‚Äúcryptocurrency‚Äù and ‚Äúblockchain‚Äù can be heard more and more often in the news and, as a result, there is an influx of a large number of people interested in these technologies, and with it a huge amount of new products.  Often, to implement some kind of internal logic of the project or to collect funds, smart contracts are used - special programs created on the Ethereum platform and living inside its blockchain.  There is already enough material in the network devoted to the creation of simple smart contracts and basic principles, but there is practically no description of the work of the Ethereum virtual machine (hereinafter referred to as EVM) at a lower level, therefore in this series of articles I would like to analyze the work of EVM in more detail. </p><br><p>  Solidity - the language created for the development of smart contracts, exists relatively recently - its development began only in 2014 and, as a result, in places it is ‚Äúraw‚Äù.  In this article I will begin with a more general description of the work of EVM and some of the distinctive features of solidity, which are needed for understanding lower-level work. </p><br><p>  Ps The article assumes some basic knowledge about writing smart contracts, as well as about the Ethereum blockchain in general, so if you hear about it for the first time, I recommend that you first familiarize yourself with the basics, for example, here: </p><br><ul><li>  <a href="https://habrahabr.ru/post/312008/">Hello world on solidity and network contract</a> </li><li>  <a href="https://habrahabr.ru/post/327236/">A selection of development tools</a> </li><li>  <a href="https://geektimes.ru/post/294611/.com%255Biz-pesochnitsy%255D-kak-rabotaet-efirium-v">Job Description of Ethereum and its blockchain</a> <a name="habracut"></a></li></ul><br><h2 id="table-of-contents">  Table of contents </h2><br><ol><li>  Memory <br><ul><li>  Storage </li><li>  Memory </li><li>  Stack </li></ul></li><li>  Data location of complex types </li><li>  Transactions and message calls </li><li>  Visibility </li><li>  Links </li></ol><br><h2 id="memory-types">  Memory types </h2><br><p>  Before you begin to dive into the subtleties of EVM, you should understand one of the most important moments - where and how all data is stored.  This is very important, because the memory areas in EVM are very different in their device, and, as a result, not only the cost of reading / writing data, but also the mechanisms for working with them differ. </p><br><h3 id="storage">  Storage </h3><br><p>  The first and most expensive type of memory is Storage.  Each contract has its own storage memory, where all global variables ( <strong>state variables</strong> ) are stored, the state of which is constantly between function calls.  It can be compared with a hard disk - after the completion of the current code, everything will be recorded in the blockchain, and the next time we call the contract, we will have access to all the data obtained earlier. </p><br><pre><code class="javascript hljs">contract Test { <span class="hljs-comment"><span class="hljs-comment">// this variable is stored in storage uint some_data; // has default value for uint type (0) function set(uint arg1) { some_data = arg1; // some_data value was changed and saved in global } }</span></span></code> </pre> <br><p>  Structurally, storage is a key-value type of storage, where all cells are 32 bytes in size, which strongly resembles hash tables, so this memory is very sparse and we will not get any benefit from storing data in two neighboring cells: storing one variable in The first cell and the other in the 1000th cell will cost as much gas as if we stored them in cells 1 and 2. </p><br><pre> <code class="javascript hljs">[<span class="hljs-number"><span class="hljs-number">32</span></span> bytes][<span class="hljs-number"><span class="hljs-number">32</span></span> bytes][<span class="hljs-number"><span class="hljs-number">32</span></span> bytes]...</code> </pre> <br><p>  As I said before, this type of memory is the most expensive - to take a new cell in storage costs 20,000 gas, change the occupied one - 5,000 and read - 200. Why is it so expensive?  The reason is simple - the data stored in the storage contract will be recorded in the blockchain and will remain there forever. </p><br><p>  Also, it is not difficult to calculate the maximum amount of information that can be stored in the contract: the number of cells is 2 ^ 256, the size of each is 32 bytes, so we have 2 ^ 261 bytes!  In fact, we have a certain Turing machine - the possibility of recursive challenge / jumps and almost infinite memory.  More than enough to simulate inside another Ethereum that will simulate Ethereum :) <br></p><br><img src="https://habrastorage.org/getpro/habr/post_images/3a0/e07/8a1/3a0e078a1263724a991e808c92f4c4c4.jpg" alt="https://i.imgur.com/fPD96YR.jpg"><br><br><h3 id="memory">  Memory </h3><br><p>  The second type of memory is Memory.  It is much cheaper than storage, cleared between external (you can read about the types of functions in the following chapters) function calls and is used to store temporary data: for example, arguments passed to functions, local variables, and storage of return values.  It can be compared with RAM - when the computer (in our case, EVM) is turned off, its contents are erased. </p><br><pre> <code class="javascript hljs">contract Test { ... function (uint a, uint b) returns (uint) { <span class="hljs-comment"><span class="hljs-comment">// a and b are stored in memory uint c = a + b // c has been written to memory too return c } }</span></span></code> </pre> <br><p>  By internal memory device is a byte array.  At first it has a size of zero, but can be expanded with 32-byte chunks.  Unlike storage, memory is continuous and therefore well packed ‚Äî it is much cheaper to store an array of length 2, storing 2 variables, than an array of length 1000, storing the same 2 variables at the ends and zeroes in the middle. </p><br><p>  Reading and writing one machine word (recall, in EVM is 256 bits) costs only 3 gases, while expanding the memory increases its value depending on the current size.  Storage of several KBs will be inexpensive, but already 1 MB will cost millions of gas, because the price grows quadratically. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// fee for expanding memory to SZ TOTALFEE(SZ) = SZ * 3 + floor(SZ**2 / 512) // if we need to expand memory from x to y, it would be // TOTALFEE(y) - TOTALFEE(x)</span></span></code> </pre> <br><h3 id="stack">  Stack </h3><br><p>  Since EVM has a stack organization, it is not surprising that the last memory area is the stack - it is used for all the EVM calculations, and the price of its use is similar to memory.  It has a maximum size of 1024 elements of 256 bits, but only the top 16 elements are available for use.  Of course, you can move elements of the stack to memory or storage, however, random access is impossible without first removing the top of the stack.  If the stack is full, contract execution will be interrupted, so I advise you to leave the compiler to work with him;) </p><br><h2 id="data-location-of-complex-types">  Data location of complex types </h2><br><p>  In solidity, working with 'complex' types, such as structures and arrays that may not fit into 256 bits, should be organized more carefully.  Since copying them can be quite expensive, we need to think about where to store them: in memory (which is not permanent) or in storage (where all global variables are stored).  For this, in solidity for arrays and structures there is an additional parameter - 'data location'.  Depending on the context, this parameter is always the default value, but it can be changed by the keywords storage and memory.  The standard value for the function arguments is memory, for local variables it is storage (for simple types it is still memory) and for global variables it is always storage. </p><br><p>  There is also a third location - calldata.  The data there is immutable, and work with them is organized as well as in memory.  Arguments of external functions are always stored in calldata. </p><br><p>  The location of the data is also important because it affects the way the assignment operator works: assignments between variables in storage and memory always create an independent copy, while assigning a local storage variable will only create a link that points to a global variable.  Assigning the type of memory - memory also does not create a copy. </p><br><pre> <code class="javascript hljs">contract C { uint[] x; <span class="hljs-comment"><span class="hljs-comment">// the data location of x is storage // the data location of memoryArray is memory function f(uint[] memoryArray) { x = memoryArray; // works, copies the whole array to storage // var is just a shortcut, that allows us automatically detect a type // you can replace it with uint[] var y = x; // works, assigns a pointer, data location of y is storage y[7]; // fine, returns the 8th element of x y.length = 2; // fine, modifies x through y delete x; // fine, clears the array, also modifies y uint[3] memory tmpArr = [1, 2, 3]; // tmpArr is located in memory var z = tmpArr; // works, assigns a pointer, data location of z is memory // The following does not work; it would need to create a new temporary / // unnamed array in storage, but storage is "statically" allocated: y = memoryArray; // This does not work either, since it would "reset" the pointer, but there // is no sensible location it could point to. delete y; g(x); // calls g, handing over a reference to x h(x); // calls h and creates an independent, temporary copy of x in memory h(tmpArr) // calls h, handing over a reference to tmpArr } function g(uint[] storage storageArray) internal {} function h(uint[] memoryArray) internal {} }</span></span></code> </pre> <br><h2 id="transactions-and-message-calls">  Transactions and message calls </h2><br><p>  In Ethereum, there are 2 types of accounts that share the same address space: <strong>External accounts</strong> are regular accounts controlled by pairs of private-public keys (or, more simply, people's accounts) and <strong>contract accounts</strong> are controlled by the code stored with them (smart contracts).  A transaction is a message from one account to another (which may be the same, or a special zero account, see below) containing some data ( <strong>payload</strong> ) and Ether. </p><br><p>  With transactions between regular accounts, everything is clear - they just convey the value.  When the target account is a zero account (with address 0), the transaction creates a new contract, and its address forms from the sender's address and the number of transactions sent (the 'nonce' account).  Payload of such a transaction is interpreted by EVM as bytecode and executed, and the output is saved as a contract code. </p><br><p>  If the target account is a contract account, the code in it is executed, and the payload is passed as input.  Contract account transactions cannot be sent on their own, but they can be launched in response to received ones (both from external account and from other contract accounts).  Thus it is possible to ensure the interaction of contracts with each other through internal transactions ( <strong>message calls</strong> ).  Internal transactions are identical to the usual - they also have the sender, recipient, Ether, gas, etc., and the contract can set their gas-limit when sending.  The only difference from transactions created by regular accounts is that they live exclusively in the Ethereum execution environment. </p><br><h2 id="visibility">  Visibility </h2><br><p>  In solidity, there are 4 types of 'visibility' of functions and variables - <strong>external</strong> , <strong>public</strong> , <strong>internal</strong> and <strong>private</strong> , the standard is public.  For global variables, the standard is internal, and external is not possible.  So, consider all the options: </p><br><ul><li>  <code>External</code> - functions of this type are part of the contract interface, which means they can be called from other contracts by means of a message call.  The called contract will receive a clean copy of the memory and access to payload data, which will be located in a separate section - calldata.  After completion of the execution, the returned data will be placed in a pre-allocated place of the calling contract in memory.  The external function cannot be called directly from within the contract (that is, we cannot use <code>func()</code> , however such a call is still possible - <code>this.func()</code> ).  In the case when a lot of data is supplied to the input, these functions may be more efficient than the public (I will write about this below). </li><li>  <code>Internal</code> - functions, as well as global variables of this type can be used only within the contract itself, as well as contracts inherited from it.  Unlike the external functions, the former do not use message calls, but work by means of 'jumping' over the code (the JUMP instruction).  Due to this, when calling such a function, memory is not cleared, which allows you to pass complex types stored in memory by reference (remember the example from the chapter Data location - tmpArr is passed to function h by reference). </li><li>  <code>Public</code> - public functions are universal: they can be called both externally - that is, they are part of the contract interface, as well as from the inside of the contract.  For public global variables, a special getter function is automatically generated - it has external visibility and returns the value of the variable. </li><li>  <code>Private</code> - private functions and variables are no different from internal, except that they are not visible in inherited contracts. </li></ul><br><p>  For clarity, consider a small example. </p><br><pre> <code class="javascript hljs">contract C { uint private data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint a</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint a</span></span></span><span class="hljs-function">) </span></span>{ data = a; } <span class="hljs-comment"><span class="hljs-comment">// default to public function getData() public returns(uint) { return data; } function compute(uint a, uint b) internal returns (uint) { return a+b; } } contract D { uint local; function readData() { C c = new C(); uint local = cf(7); // error: member "f" is not visible c.setData(3); local = c.getData(); local = c.compute(3, 5); // error: member "compute" is not visible } } contract E is C { function g() { C c = new C(); uint val = compute(3, 5); // acces to internal member (from derivated to parent contract) uint tmp = f(8); // error: member "f" is not visible in derived contracts } }</span></span></code> </pre> <br><p>  One of the most frequent questions is "why do we need external functions, if you can always use public?"  In fact, there is no case when external cannot be replaced by public, however, as I already wrote, in some cases it is more efficient.  Let's look at a specific example. </p><br><pre> <code class="javascript hljs">contract Test { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">] a</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uint</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// a is copied to memory return a[2]*2; } function test2(uint[3] a) external returns (uint) { // a is located in calldata return a[2]*2; } }</span></span></code> </pre> <br><p>  Performing the public function costs 413 gas, while calling the external version of only 281. This happens because in the public function the array is copied into memory, while in the external function the reading comes directly from the calldata.  Allocating memory is obviously more expensive than reading from calldata. </p><br><p>  The reason that public functions need to copy all the arguments into memory is that they can also be called from within the contract, which is a completely different process - as I wrote earlier, they work by jumping in the code, and the arrays are passed through pointers to memory.  Thus, when the compiler generates code for the internal function, it expects to see the arguments in memory. </p><br><p>  For external functions, the compiler does not need to provide internal access, so it provides access to reading data directly from calldata, bypassing the copy step into memory. </p><br><p>  Thus, competent selection of the type of 'visibility' serves not only to limit access to functions, but also allows them to be used more efficiently. </p><br><p>  <strong>PS:</strong> In the following articles I will go over to the analysis of work and optimization of complex types at the level of bytecode, and also I will write about the main vulnerabilities and bugs that are present in solidity at the moment. </p><br><h2 id="links">  Links </h2><br><ul><li>  <a href="https://github.com/ethereum/wiki/wiki">https://github.com/ethereum/wiki/wiki</a> </li><li>  <a href="https://solidity.readthedocs.io/en/develop">https://solidity.readthedocs.io/en/develop</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/340928/">https://habr.com/ru/post/340928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340918/index.html">Optimization of Viola and Jones method for Elbrus platform</a></li>
<li><a href="../340920/index.html">Automation of work with current customers. Account Management. Choose a CRM system. Part 3</a></li>
<li><a href="../340922/index.html">We explain the modern JavaScript dinosaur</a></li>
<li><a href="../340924/index.html">Using the neural network to build a model for assessing borrowers in the field of online microfinance</a></li>
<li><a href="../340926/index.html">Web application on Node and Vue, part 2: components, forms, routes</a></li>
<li><a href="../340932/index.html">REST in the real world and the practice of hypermedia</a></li>
<li><a href="../340934/index.html">Autumn changes on Habr√© and Geektimes</a></li>
<li><a href="../340936/index.html">Agile in Russia - 82.9% of companies report that they use at least something from Agile. First poll results</a></li>
<li><a href="../340938/index.html">New virus Reaper infected 2 million IoT devices</a></li>
<li><a href="../340940/index.html">Windows Defender removes the bootloader from DiskCryptor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>