<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Spaghetti in the sequential invocation of asynchronous functions. Theory and practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the continuation of the article Sequential call asynchronous functions . 

 Part 1. Theory 
 Most traditional non-web programming languages ‚Äã‚Äãare s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Spaghetti in the sequential invocation of asynchronous functions. Theory and practice</h1><div class="post__text post__text-html js-mediator-article">  In the continuation of the article <a href="http://habrahabr.ru/blogs/javascript/134823/">Sequential call asynchronous functions</a> . <br><br><h4>  Part 1. Theory </h4><br>  Most traditional non-web programming languages ‚Äã‚Äãare synchronous (blocking). <br>  How can I determine if this language is synchronous or asynchronous?  For example, by the presence / absence of the sleep function (it can also be called delay, pause, etc.) when the program completely stops for a certain amount of time. <br><br>  In JavaScript, as you know, there is no such function.  There are for example <a name="habracut"></a>  <b>setTimeout</b> , but it does something completely different.  It may delay the execution of the command, but this does not mean that after <b>setTimeout</b> , the program stops and nothing can be done in it. <br>  On the contrary, theoretically, after <b>setTimeout has</b> been called, some of the resources may even become free and the delayed callbacks (functions in the queue) can be executed faster. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is recommended not to confuse synchronicity / asynchrony with single-threaded / multi-threaded.  These concepts are loosely connected. <br>  Implementing asynchronous JavaScript is just one approach to another concept ‚Äî multitasking, for which there is the most traditional solution ‚Äî multithreading. <br><br><h6>  Advantages of multithreading: </h6><ul><li>  No need to change thinking, retrain from traditional blocking languages ‚Äã‚Äã(C ++, Java, Python) </li><li>  If you have a multiprocessor computer and the program is written using threads and they do not block each other, i.e.  operate with independent data, then the program on such a processor will run somewhat faster </li></ul><br><h6>  Disadvantages of multithreading: </h6><ul><li>  Each thread needs a place to work with data, so each thread eats away the RAM even if this memory is not used and the stream is sleeping. <br>  Previously, it was a big problem, now the memory is cheap, but it still somehow becomes unpleasant when simple but multi-threaded Java program takes 2 GB in memory. </li><li>  If two streams use the same scarce resource (an object in memory, a network connection, etc.), a race condition for the resource (Race Condition) may occur.  ‚ÄúIt can happen‚Äù is even worse than if we said ‚Äúit will happen‚Äù. <br>  To combat the competition of threads, flags, semaphores, etc. are used, with one goal being to make other threads wait for a scarce resource.  But then there may be a deadlock problem when thread A is waiting for thread B, and B is waiting for A. <br>  These are the two biggest disadvantages of multi-threading; this is such a big problem that, for example, in an interview when hiring a Java programmer, there are necessarily questions about threads like " <i>how does Thread.start () differ from Thread.run ()?</i> ", " <i>to deal with deadlocks?</i> ", etc.  Java programmers spend a huge amount of time on the heroic creation of threads and then on the no less heroic overcoming of the problems associated with this. <br>  As you probably know, the development of traditional processors rested on a certain limit, and it is no longer possible to increase the productivity of the race with gigahertz.  In this case, multi-streaming gives a big boost in processing a large amount of more or less independent data, for example, when encoding a video. <br>  Despite this, the impression of multitasking through multithreading on the part of the programmer is this: "it is <i>incredibly difficult to program so that the memory is spent so that 90% of the time threads wait for each other, and as soon as they stop waiting, they fight with each other deadlock</i> . " </li></ul><br>  In Javascript, to create a parallel task you need to write only: <br><pre><code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Async'</span></span>); }, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  or <br><br><pre> <code class="javascript hljs">button.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Async click'</span></span>); }, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><br>  However, the ‚Äúparallel task‚Äù does not mean that your JavaScript will work faster on a 10-core processor.  JavaScript is thread-neutral, the ECMA specification does not describe how a JavaScript machine implements multitasking.  As far as I know, all existing implementations of JavaScript use a multitasking type of ‚ÄúThreads in user space‚Äù (the processor quickly and quickly switches tasks by interrupting with a timer inside one process), which however does not guarantee that nuclear multithreading can never appear in JavaScript in the future. <br>  Looking ahead, I‚Äôll say that in the end the threads were forcibly entered into JavaScript in a slightly strange way through the Web Worker, but this will be discussed later in the second part. <br><br>  So, in standard JavaScript everything is done differently, through an endless loop of events (Event Loop) and non-blocking calls.  In the main and only UI thread, this Event Loop runs, which accesses the callback queue and selects and sequentially executes them until the queue is cleared. <br>  A call to setTimeout, onclick, and XmlHttpRequest with the true flag places a new callback on the event queue.  When a callback is selected from the queue and executed, it can place another callback in the queue, etc. <br>  If you want a fast working site with rich JavaScript, which doesn‚Äôt ‚Äú <i>load in two hours</i> ‚Äù, you should postpone as many operations as possible and jump into the main thread as soon as possible to release the UI, and the event manager will figure out when and what to call from the queue, and items will be loaded gradually. <br>  The scanning process of a queue of callbacks is never interrupted but never waits.  Although gradual loading of data will not change the final speed of the program itself, but an asynchronous site with gradually appearing elements will be perceived by the visitor as faster. <br><br>  JavaScript is very well suited for asynchronous operation and was conceived like this. <br>  Unfortunately, there are synchronous exceptions in the syntax - these are the <b>alert</b> , <b>confirm</b> , <b>promt</b> and <b>xmlhttprequest commands with the false flag,</b> which block everything. <br>  It is strongly not recommended to use these commands in any cases, except, perhaps, one exception which will be discussed at the end of this article. <br>  An asynchronous call is always better than a synchronous one in terms of performance.  Look, for example, at <b>nginx</b> - it became super-popular precisely because of the high performance that is achieved, basically, asynchronous work. <br>  To my great regret, <b>node.js</b> still could not resist and introduced another synchronous command - require.  As long as this command is in node.js, I personally will never use it, because I am convinced that performance will always be lame. <br><br>  Why, then, in an asynchronous language are introduced synchronous commands that spoil the whole ideology of the language? <br>  First, the JavaScript machine does not work by itself, but in the browser in which the user sits, and the blocking commands were added not to the JavaScript language, but to the environment that surrounds it ‚Äî the browser, although it is difficult for us to logically separate these concepts. <br>  "On the other side of the browser," there are programmers, the most diverse, coming from different languages, most often synchronous.  Writing asynchronous code is much more difficult, it requires a completely different way of thinking. <br>  Therefore, " <i>according to numerous requests from programmers, they have little understanding of asynchrony,</i> " they added the usual vicious synchronous functions that completely stop the Event Loop. <br>  It is always possible to perform a task asynchronously, but the temptation to simplify your life by replacing an asynchronous call with a synchronous call is too great. <br><br>  What is the complexity of asynchronous development? <br>  For example, sooner or later, any JavaScript programmer will encounter such a ‚Äúbug‚Äù (One of the most popular questions on StackOverflow): <br><h6>  Server code </h6><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">#booklist.php header('Content-type: application/json'); echo json_encode(array(1, 2, 88)); ?&gt;</span></span></code> </pre> <br><br><h6>  Client Code </h6><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getBookList = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boolListReturn; $.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span> : <span class="hljs-string"><span class="hljs-string">'bookList.php'</span></span>, <span class="hljs-attr"><span class="hljs-attr">dataType</span></span> : <span class="hljs-string"><span class="hljs-string">'json'</span></span>, <span class="hljs-attr"><span class="hljs-attr">success</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ boolListReturn = data; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> boolListReturn; }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(getBookListSorted()); <span class="hljs-comment"><span class="hljs-comment">// -   :)</span></span></code> </pre> <br><br>  Here, of course, misunderstanding is caused by the fact that the ajax request went to the queue, and console.log remained in the main Ui thread. <br>  When ajax is executed successfully, it will queue the success callback, which may also be executed sometime.  Of course, console.log will already be far in the past with the fact that the function returned (undefined). <br><br>  It is more correct to change the program a little, let's say by passing the console.log call inside the success callback. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getBookList = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ $.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span> : <span class="hljs-string"><span class="hljs-string">'bookList.php'</span></span>, <span class="hljs-attr"><span class="hljs-attr">dataType</span></span> : <span class="hljs-string"><span class="hljs-string">'json'</span></span>, <span class="hljs-attr"><span class="hljs-attr">success</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ callback(data); } }); }; getBookList(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bookList</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(bookList); });</code> </pre> <br><br>  An even more modern way is to move to some convenient interface for working with callbacks, for example, the so-called concept of ‚Äúpromise‚Äù (promise, also known as Deferred) - a special object that stores its own queue of callbacks, flags of the current state and other goodies. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getBookList = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span> : <span class="hljs-string"><span class="hljs-string">'bookList.php'</span></span>, <span class="hljs-attr"><span class="hljs-attr">dataType</span></span> : <span class="hljs-string"><span class="hljs-string">'json'</span></span>, }).promise(); }; <span class="hljs-comment"><span class="hljs-comment">//     promise    done getBookList().done(function (bookList) { console.log(bookList); });</span></span></code> </pre> <br><br>  However, increasing the load on callbacks, there may be a second problem, which is that it is problematic to use more than one or two asynchronous commands. <br>  Imagine that by the received id list we need to find the names of books using another service book.php <br><br><h6>  Server part: </h6><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">#book.php $id = $_REQUEST['id']; $response = array( "id" =&gt; $id ); switch ($id) { case '1': $response['title'] = "Bobcat 1"; break; case '2': $response['title'] = "Lion 2"; break; case '88': $response['title'] = "Tiger 88"; break; } header('Content-type: application/json'); echo json_encode($response); ?&gt;</span></span></code> </pre> <br><br><h6>  Our client code will be: </h6><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getBookList = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span> : <span class="hljs-string"><span class="hljs-string">'bookList.php'</span></span>, <span class="hljs-attr"><span class="hljs-attr">dataType</span></span> : <span class="hljs-string"><span class="hljs-string">'json'</span></span>, }).promise(); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getBook = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span> : <span class="hljs-string"><span class="hljs-string">'book.php?id='</span></span>+id, }).promise(); }; getBookList().done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bookList</span></span></span><span class="hljs-function">) </span></span>{ $.each(bookList, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index, bookId</span></span></span><span class="hljs-function">) </span></span>{ getBook(bookId).done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(book.title); }); }); });</code> </pre> <br><br>  Here this three-story code is not very.  Of course, it is possible to understand what is happening here, but a large level of nesting is very disturbing and becomes a place where bugs can potentially arise. <br>  Here is one of the bugs:  If the id list has been sorted, a sorting loss may occur.  For example, if some requests are returned more slowly than others, or simply the user simultaneously runs the torrent to swing, the speed of issuing the results of the requests can ‚Äúride‚Äù. <br>  On php, we emulate this with the sleep command: <br>  ... <br>  case '2': <br>  sleep (2); <br>  $ response ['title'] = "Lion 2"; <br>  break; <br>  ... <br>  our script will output <br>  Bobcat 1 <br>  Tiger 88 <br>  Lion 2 <br>  The trouble is visible here, because our list is no longer sorted alphabetically! .. <br>  How can we maintain the orderliness of the list, while the requests take different time? <br>  This problem is not as simple as it seems, even promising objects will not help much here, try to solve this problem yourself and you will feel the drama of the situation on your skin. <br><br><h4>  Part 2. Practice </h4><br>  Look at this incomplete list of JavaScript libraries: <br>  async.js, async, async-mini, atbar, begin, chainsaw, channels, Cinch, cloudd, deferred, each, EventProxy.js, fiberize, fibers, proms, asyncblock, first, flow-js, funk, futures, promise, groupie, Ignite, jam, Jscex, JobManager, jsdeferred, LAEH2, miniqueue, $ N, nestableflow, node.flow, node-fnqueue, node-chain, node-continuables, node-cron, node-crontab, node-inflow , node_memo, node-parallel, node-promise, narrow, neuron, noflo, observer, poolr, q, read-files, Rubberduck, SCION, seq, sexy, Signals, simple-schedule, Slide, soda.js, Step, stepc , streamline.js, sync, QBox, zo.js, pauseable, waterfall <br>  All these bike libraries promise to solve approximately one problem "Write async code in sync form.".  Those.  allow to write asynchronous code as easily as in the synchronous style. <br>  I tried most of them, but in reality they do not really help.  I didn‚Äôt notice much comfort compared to standard jQuery.Deferred. <br>  But still let's consider what are the options: <br><br><h5>  Option 1 "Synchronous calls" </h5><br>  The obvious solution to the problem of subqueries (get a list, go through the list items and execute another request for each item, while maintaining the orderliness of the original list) will be stupid to make all calls synchronous: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getBookList = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> strReturn; $.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span> : <span class="hljs-string"><span class="hljs-string">'../bookList.php'</span></span>, <span class="hljs-attr"><span class="hljs-attr">dataType</span></span> : <span class="hljs-string"><span class="hljs-string">'json'</span></span>, <span class="hljs-attr"><span class="hljs-attr">success</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">html</span></span></span><span class="hljs-function">) </span></span>{ strReturn = html; }, <span class="hljs-attr"><span class="hljs-attr">async</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strReturn; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getBook = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> strReturn; $.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span> : <span class="hljs-string"><span class="hljs-string">'../book.php?id='</span></span>+id, <span class="hljs-attr"><span class="hljs-attr">success</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">html</span></span></span><span class="hljs-function">) </span></span>{ strReturn = html; }, <span class="hljs-attr"><span class="hljs-attr">async</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strReturn; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getBookTitles = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $.map(getBookList(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val, i</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getBook(val).title; }); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ul = $(<span class="hljs-string"><span class="hljs-string">'&lt;ul/&gt;'</span></span>).appendTo($(<span class="hljs-string"><span class="hljs-string">'body'</span></span>)); $.each(getBookTitles(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index, title</span></span></span><span class="hljs-function">) </span></span>{ $(<span class="hljs-string"><span class="hljs-string">'&lt;li&gt;'</span></span>+ title +<span class="hljs-string"><span class="hljs-string">'&lt;/li&gt;'</span></span>).appendTo(ul); });</code> </pre> <br>  This solution is from the ‚Äúvery fast and dirty‚Äù series because requests not only block the browser but also make it take longer, because each next request is waiting for the previous one. <br><br><h6>  Virtues </h6><ol><li>  Simple code, easy to catch bugs </li><li>  Easy to test </li></ol><br><h6>  Disadvantages: </h6><ol><li>  Blocks browser </li><li>  The resulting time is the sum of the time of all requests. </li></ol><br><br><h5>  Option 2 ‚ÄúA promise that awaits the fulfillment of all the promises on his list‚Äù </h5><br>  The list of books in itself will be one promise (not a list), but inside it will contain a list of individual promises and only after all the promises in it are fulfilled, <br>  the result will be returned as an array containing synchronous data <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getBookTitles = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listOfDeferreds = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listDeferred = $.Deferred(); getBookList().done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bookList</span></span></span><span class="hljs-function">) </span></span>{ $.each(bookList, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i, val</span></span></span><span class="hljs-function">) </span></span>{ listOfDeferreds.push(getBook(val)); }); $.when.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, listOfDeferreds).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ listDeferred.resolve($.map(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">triple</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> triple[<span class="hljs-number"><span class="hljs-number">0</span></span>].title; })); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listDeferred.promise(); }; getBookTitles().done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bookTitles</span></span></span><span class="hljs-function">) </span></span>{ $.each(bookTitles, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index, title</span></span></span><span class="hljs-function">) </span></span>{ $(<span class="hljs-string"><span class="hljs-string">'&lt;li&gt;'</span></span>+ title +<span class="hljs-string"><span class="hljs-string">'&lt;/li&gt;'</span></span>).appendTo(<span class="hljs-string"><span class="hljs-string">'#ul'</span></span>); }); });</code> </pre> <br><br>  The getBookTitles function code is quite heavy.  The main problem is that it is mistaken, difficult to catch problems, difficult to debug. <br><br><h6>  Advantages of this option: </h6><ol><li>  Does not block the browser </li><li>  The resulting time is the longest of the requests. </li></ol><br><h6>  Disadvantages: </h6><ol><li>  Difficult, erratic code </li><li>  Hard to test </li></ol><br><br><h5>  Option 3 "Reservation of a place for ui result" </h5><br>  In this case, having received the id list, we iterate over the elements included in it, immediately create a UI object. <br>  In the same iteration, we request the second portion of asynchronous data, while the UI element is visible through the closure and we fill it with the contents: <br><pre> <code class="javascript hljs">getBookList().done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bookList</span></span></span><span class="hljs-function">) </span></span>{ $.each(bookList, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index, id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> li = $(<span class="hljs-string"><span class="hljs-string">'&lt;li&gt;Loading...&lt;/li&gt;'</span></span>); li.appendTo(<span class="hljs-string"><span class="hljs-string">'#ul'</span></span>); getBook(id).done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function">) </span></span>{ li.html(book.title); }); }); });</code> </pre> <br><br><h6>  Virtues </h6><ol><li>  Does not block the browser </li><li>  The result is shown immediately as each individual request ends. </li><li>  Requests go in parallel </li></ol><br><h6>  Disadvantages: </h6><ol><li>  Average readability code </li><li>  Hard to test </li></ol><br><br><h5>  Option 4 "Synchronous calls in a separate thread webworker" </h5><br>  In the process of writing this article, I came up with a slightly exotic option - to run synchronous requests but in a separate thread through WebWorker and modules.  At the same time, the browser is not blocked, but the code is simplified. <br>  To do this, we will write a file for the worker, plus there will be a synchronous function like <b>require</b> from <b>node.js.</b> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// wwarpc.js var require = function () { // Only load the module if it is not already cached. var cache = {}; var gettext = function (url) { var xhr = new XMLHttpRequest(); xhr.open("GET", url, false); // sync xhr.send(null); if (xhr.status &amp;&amp; xhr.status != 200) throw xhr.statusText; return xhr.responseText; }; return function (url) { if (!cache.hasOwnProperty(url)) { try { // Load the text of the module var modtext = gettext(url); // Wrap it in a function var f = new Function("require", "exports", "module", modtext); // Prepare function arguments var context = {}; // Invoke on empty obj var exports = cache[url] = {}; // API goes here var module = { id: url, uri: url }; // For Modules 1.1 f.call(context, require, exports, module); // Execute the module } catch (x) { throw Error("ERROR in require: Can't load module " + url + ": " + x); } } return cache[url]; } }(); onmessage = function(e){ if ( e.data.message !== "start" ) { return } var url = e.data.url; var funcname = e.data.funcname; var args = e.data.args; var module = require(url); postMessage(module[funcname].apply(null, args)); };</span></span></code> </pre> <br><br>  An auxiliary function for the convenient start of the worker will be as follows: <br>  It will also cache both the worker and modules in order not to load the module from the server with each call. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,     ,  &lt;script src="http://ie-web-worker.googlecode.com/svn/trunk/worker.js"&gt;&lt;/script&gt; /** * Web Worker Asynchroneous Remote Procedure Call */ var wwarpc = function () { var worker; var getWorker = function () { // for lazy load if (worker === undefined) { worker = new Worker("wwarpc.js"); } return worker; }; return function (url, funcname) { var args = Array.prototype.slice.call(arguments, 2); var d = $.Deferred(); var worker = getWorker(); worker.onmessage = function (e) { d.resolve(e.data); }; worker.postMessage({ message : "start", url : url, funcname : funcname, args : args }); return d.promise(); }; }();</span></span></code> </pre> <br>  It is interesting that the modules will be node.js-like <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//modules/Books.js exports.getBookList = function () { var the_object = {}; var http_request = new XMLHttpRequest(); http_request.open( "GET", 'bookList.php', false ); http_request.send(null); if ( http_request.readyState == 4 &amp;&amp; http_request.status == 200 ) { the_object = JSON.parse( http_request.responseText ); } return the_object; }; exports.getBook = function (id) { var the_object = {}; var http_request = new XMLHttpRequest(); http_request.open( "GET", 'book.php?id='+id, false ); http_request.send(null); if ( http_request.readyState == 4 &amp;&amp; http_request.status == 200 ) { the_object = JSON.parse( http_request.responseText ); } return the_object; }; exports.getBookTitles = function () { var Books = exports; return Array.prototype.map.call(Books.getBookList(), function (val, i) { return Books.getBook(val).title; }); };</span></span></code> </pre> <br>  In this case, the same module code can be called both synchronously (during testing with unit tests) and asynchronously (in production). <br>  Thanks to this, the main code will be much simpler, two-story instead of three: <br><pre> <code class="javascript hljs">wwarpc(<span class="hljs-string"><span class="hljs-string">'modules/Books.js'</span></span>, <span class="hljs-string"><span class="hljs-string">'getBookTitles'</span></span>).done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bookTitles</span></span></span><span class="hljs-function">) </span></span>{ $.each(bookTitles, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index, title</span></span></span><span class="hljs-function">) </span></span>{ $(<span class="hljs-string"><span class="hljs-string">'&lt;li&gt;'</span></span>+ title +<span class="hljs-string"><span class="hljs-string">'&lt;/li&gt;'</span></span>).appendTo(<span class="hljs-string"><span class="hljs-string">'#ul'</span></span>); }); });</code> </pre> <br>  The ideology will be such that all operations will be performed in the worker but the worker himself will be called asynchronously, as a result, the nesting will always be minimal. <br><br><h6>  Advantages: </h6><ol><li>  Does not block new browsers </li><li>  Simple, easy to understand code. </li><li>  Easy to test (can be tested in synchronous mode, and called asynchronous) </li></ol><br><h6>  Disadvantages: </h6><ol><li>  Blocks IE and old browsers that do not support workers </li><li>  The resulting time is the sum of the time of all requests. </li></ol><br><br><h6>  Conclusion: </h6><ul><li>  Option 3 "Reservation of a place for the result in ui" is the fastest option, but a bit complicated code </li><li>  If the readability and testability of the code is more important than the comfort of IE users, then Option 4 ‚ÄúSynchronous calls in a separate webworker thread‚Äù can be a good choice. </li><li>  Option 2 should be strictly avoided (‚ÄúA promise that awaits the fulfillment of all the promises on its list‚Äù) </li><li>  The use of synchronous calls cannot be justified. </li><li>  <b>IE must die!</b> </li></ul><br><br>  The article was written under the impression of the following materials: <ul><li>  <a href="http://www.yuiblog.com/blog/2010/08/30/yui-theater-douglas-crockford-crockford-on-javascript-scene-6-loopage-52-min/">Presentation Doug Crockford loopage</a> </li><li>  <a href="http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript">Presentation of Callbacks, Promises, and Coroutines</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/137778/">https://habr.com/ru/post/137778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137772/index.html">ForkCMS - a new fork with a spoon</a></li>
<li><a href="../137773/index.html">PHDays Young School: Young Scientists Wanted</a></li>
<li><a href="../137774/index.html">How OnLaym got me on digital tv</a></li>
<li><a href="../137775/index.html">Jelastic on Java Day SPB 2012</a></li>
<li><a href="../137776/index.html">Applications for BlackBerry Playbook can be written on Qt</a></li>
<li><a href="../137783/index.html">5 gems for all occasions</a></li>
<li><a href="../137785/index.html">"Programmer" is super-generalization</a></li>
<li><a href="../137787/index.html">Droider Chart. Release 87, mobile</a></li>
<li><a href="../137788/index.html">How I bought a domain</a></li>
<li><a href="../137789/index.html">Who surrendered to antivirus?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>