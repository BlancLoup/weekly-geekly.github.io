<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>There's More Than One Way To Do It</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="#!/usr/bin/perl -c Please, listen to, my $words; seek love, joy, happiness for everything; study hard and sleep longer if able; # Perl Poetry, The Sen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>There's More Than One Way To Do It</h1><div class="post__text post__text-html js-mediator-article"><img title="perl-camel" src="http://caiiiycuk.info/wp-content/uploads/2012/10/Perl.png" width="200" height="200" align="right"><br><pre><code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl -c Please, listen to, my $words; seek love, joy, happiness for everything; study hard and sleep longer if able; # Perl Poetry, The Sentiment # (c) http://www.perlmonks.org/?node_id=882536</span></span></code> </pre> <br><br><a name="habracut"></a><br><h3>  Desert ... </h3><br><br>  Proud and stately stands by the Perl Desert.  He began his journey back in 1987, having walked thousands of deserts over many years, he saw wonderful and caressing oases full of water here and there, as the rainy seasons began alternating with prolonged droughts.  Deserts are different, more than once there was trouble with him, when an imprudent rider led him deeper and deeper into the arid desert where there is no place for even hope.  On the contrary, there were cases when whole megacities full of life and people appeared in the middle of the desert, it seemed that it was a mirage, but no - it was a reality.  Perl never wondered at the creative talent of people.  He did not impose a path on a man, trusting in his will followed the depths of the desert to the unknown.  He was disappointed by <sup>1</sup> ‚Äúwild‚Äù riders - people from big cities who got used to moving around in difficult machines.  Here, in the desert, even the most attractive thorn cannot make them move forward even by a meter.  Out of habit, they take a lot of rubbish with them, and constantly push them in, forcing them to run faster and faster.  The beauty of the desert, its philosophy, rushes past them, but not many of them reach the goal, leaving behind them all the same lifeless desert.  On the contrary, there were other people who perceived the desert as something new, free, unlimited space for creativity.  Keeping track with such satellites has always been a great pleasure.  The path led them through the bizarre, full of life islets of the desert.  Sometimes a group of such people could collect whole caravans of camels, not hastily wandering through the desert.  The desert was drunk, and somehow in a special way, magically acted on the young minds of riders who had not got stronger.  Perl often saw poor fellows go crazy starting to build sand castles that were not destined to become something big.  Others drew in the sand do not even understand him doodle.  Mirages, who never really existed, either destroyed them.  Unfortunately, Perl could not help these poor fellows, just as he couldn‚Äôt refuse to travel, because Perl felt great about traveling, it was for this that he was born. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And here he is in front of you, happily kicking with his foot, offering to make a fascinating walk through this still lifeless desert, to the distance where you think you should go. <br><br><h3>  ... camel <sup>2</sup> </h3><br><br>  <strong>(*)</strong> Perl's philosophy is that it is easy to solve simple tasks, while still being able to solve difficult ones.  These are the tasks that we solve every day.  You do not need to pronounce many preliminary words before saying what you are going to do.  Perl is traditionally included in the delivery of almost all * nix distributions, which makes starting especially easy.  In fact, after installing the operating system, Perl is ready for work (of course, we are talking about * nix). <br><br>  <strong>(*)</strong> When developing every new version of Perl, special attention is paid to maintaining backward compatibility.  Which is very important, considering how much is written in Perl. <br><br>  <strong>(*)</strong> <a href="http://www.cpan.org/">CPAN</a> .  A distribution network for Perl modules, something like ( <a href="http://ru.wikipedia.org/wiki/Apache_Maven">maven</a> , <a href="http://en.wikipedia.org/wiki/Apache_Ivy">ivy</a> ) / Java, <a href="http://ru.wikipedia.org/wiki/RubyGems">RubyGems</a> , <a href="http://en.wikipedia.org/wiki/Npm_%2528software%2529">npm</a> /Node.JS.  The tablecloth is a groundwork, a storehouse of ready-made solutions for all occasions.  Currently one of the largest among languages ‚Äã‚Äã(more than <strong>121,000</strong> modules).  Thanks to CPAN, many complex problems are solved by a trivial search for a suitable module.  However, the comparison with maven is somewhat strained, CPAN is much simpler in terms of dependency management.  It does not require any pre-set up magic, it is more like <a href="http://ru.wikipedia.org/wiki/Advanced_Packaging_Tool">apt</a> from Debian / Ubuntu. <br><br>  <strong>(*)</strong> Perl compiles text programs into an intermediate representation before interpreting them.  That allows, though not often, to detect errors in the program at <strong>the compilation stage</strong> .  This, above all, includes checking the correctness of syntactic constructions, checking the correctness of the names and arguments of subprograms (only if there is a prototype), checking the correctness of references to the fields of a class.  Of course, this is not a C ++ compiler, but for a dynamic language it‚Äôs not bad at all.  It's interesting, but in some ways even the C ++ compiler can leave behind, so the Perl compiler can define incorrect calls to mathematical operations (for example: a root from a negative number causes a compilation error).  Here are some examples: <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl -w use strict; my Dog $aDog = new Dog; # :   Dog $aDog-&gt;{wings} = '?'; #  (. ):     feed $aDog; # :     sqrt -2; # :    </span></span></code> </pre><br><br>  Perl always follows <a href="http://en.wikipedia.org/wiki/There%2527s_more_than_one_way_to_do_it">its own principle</a> , and it costs nothing to turn off most of these checks, but more on that later. <br><br>  <strong>(*)</strong> Function prototypes allow you to pre-declare subprograms and a list of their arguments, something like a <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BE%25D0%25B1%25D1%258A%25D1%258F%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">forward declaration</a> in C ++, if there is a prototype, the compiler checks the correctness of the subprograms call, and also does not require paired brackets when calling the subprogram. <br><br><pre> <code class="perl hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">feed</span></span></span></span>($$); feed <span class="hljs-string"><span class="hljs-string">'Sharik'</span></span>, <span class="hljs-string"><span class="hljs-string">'Fruit'</span></span>; <span class="hljs-comment"><span class="hljs-comment"># Ok feed 'Sharik'; # :    feed 'Sharik', 'Apple', 'Fruit'; #:   sub feed($$) { print shift, ' eat ', shift, "\n"; }</span></span></code> </pre><br><br>  <strong>(*) $ @%</strong> .  Perl separates the variables by purpose: the ' <strong>$</strong> ' scalar (number, string, link), the ' <strong>@</strong> ' array (sequence of scalars), ' <strong>%</strong> ' hash (associative array of scalars).  As you can see, classic primitive types are represented by scalar.  However, they are strictly separated from the containers, which allows the compiler to perform additional checks, saving us from the hassle.  Perl does not allow its types to be introduced (for the OOP, indulgence is introduced - any of the built-in types can be blessed into the class).  Thanks to such a clear separation, in the same area you can have non-conflicting variables of all types: <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl -w use strict; my $solarSystem = 'Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune'; my @solarSystem = qw(Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune); my %solarSystem = (haveLife =&gt; 1, havePerl =&gt; 1); sub solarSystem() { print 'Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune'; }</span></span></code> </pre><br><br>  Each operation in Perl is non-separable and associated with the execution context.  Perl understands three types of context: empty (without context), scalar and list (for example, assigning a value to a scalar variable forms a scalar context, and assigning to an array or hash is a list context).  Perl routines are able to determine the execution context and, accordingly, can behave differently in different contexts, which gives room for creativity. <br><br>  There is no pointer arithmetic in the language, but there are links.  Arguments in the subroutines are passed by reference, but the assignment operator performs the copying of the variable value itself (not only scalars are copied, but also containers).  Thus, passing arguments to a subroutine by value is easily implemented.  Moreover, the classic Perl subroutine record involves passing by value, i.e.  does not introduce side effects for its arguments. <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl -w use strict; sub upper { my $value = $_[0]; #    $value $value = uc $value; #    $_[0] = $value; #      } my $bigLetters = 'big-letters'; upper $bigLetters; print $bigLetters, "\n"; #  BIG-LETTERS</span></span></code> </pre><br><br>  <strong>(*)</strong> <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B3%25D1%2580%25D1%2583%25D0%25B7%25D0%25BA%25D0%25B0_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B2">Operator overloading</a> (for rare cases when it is necessary).  You can overload almost everything except spaces, commas, and perhaps I have not heard that someone could reload the comment.  The only language (known to me) that allows you to overload constants (numbers, letters, words).  This can be used, for example, to replace all numbers entered as constants with equivalent objects representing complex numbers.  Or use numbers of unlimited size: <br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#  BigMath.pm package BigMath; use overload; use Math::BigInt; sub import { overload::constant integer =&gt; sub { Math::BigInt-&gt;new(shift) }; } 1; #  BigMath.pl { use BigMath; my $bigInt = 2123; #  BigInt print $bigInt-&gt;as_bin(); # 0b100001001011 } { my $int = 2123; print $int-&gt;as_bin(); #   as_bin() }</span></span></code> </pre><br><br>  Perl allows you to overload the standard language routines. <br><br>  <strong>(*)</strong> <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B3%25D1%2583%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">Regular expressions are</a> deeply integrated into Perl.  In addition to the usual regular expression patterns, Perl supports its extensions.  For example, Perl allows you to use direct Perl code in search patterns and replacement patterns: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $math = <span class="hljs-string"><span class="hljs-string">'100 + 200 = 300'</span></span>; $math =~ <span class="hljs-regexp"><span class="hljs-regexp">s/(\d+)/$1 * 2/ge</span></span>; <span class="hljs-comment"><span class="hljs-comment">#       2 print $math, "\n"; # 200 + 400 = 600</span></span></code> </pre><br><br>  Regular expressions support <a href="http://en.wikipedia.org/wiki/Unicode_character_property">Unicode properties</a> and even allow you to enter your own character properties.  Allowing you to enter your abbreviations for complex patterns (like \ s, \ w, etc.). Naturally, regular expressions in Perl support both greedy and non-greedy searches. <br><br>  <strong>(*)</strong> Perl, in the absence of the <em>return</em> keyword in the subroutine, returns the last calculated expression (it looks like it is fashionable now).  In addition, when calling subroutines, you can omit brackets if you understand what you are doing. <br><br>  <strong>(*)</strong> Blocks in Perl.  A block is a pair of curly braces <em>{...}</em> , such constructions as <em>while</em> , <em>if</em> , <em>for</em> accept a block, although a block may exist by itself.  The most interesting is that any block supports the operators <em>next</em> , <em>last</em> and <em>redo</em> .  Those.  Quite a legal entry: <br><br><pre> <code class="perl hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Yeah\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">last</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Unreachable code\n"</span></span>; } { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Forever loop\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">redo</span></span>; }</code> </pre><br><br>  In addition, subroutines can take blocks as arguments, which allows richly expanding the language with its syntactic constructions.  This makes it possible to write beautiful self-documented programs on Perl, of course the presence of fantasy is necessary. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-comment"><span class="hljs-comment">#sub transaction(&amp;$); #sub update($$$); #sub set(+); #sub where(+); #sub rollback(&amp;); #sub throw($$); transaction { update 'user', set { name =&gt; 'caiiiycuk' }, where { id =&gt; '1' }; } rollback { throw 500, "rollback exception"; }</span></span></code> </pre><br><br>  Perl does not support a <em>try</em> / <em>catch</em> / <em>finally</em> <em>block</em> , but it is easily implemented through subroutines, receiving blocks.  Just because <em>if</em> / <em>else</em> accepts a block, in Perl the <em>if</em> / <em>else if</em> / <em>else</em> syntax cannot exist, <em>if</em> / <em>elsif</em> / <em>else is</em> used instead.  Similarly, there is no <em>switch</em> / <em>case</em> , it is implemented trivially. <br><br>  <strong>(*)</strong> The while loop can define a <em>continue</em> section, which is executed regardless of whether <em>next</em> , <em>last</em> <s>or <em>redo</em></s> was called <s>(ie it is always executed)</s> (as rightly noted by the <a href="https://habrahabr.ru/users/alienator/" class="user_link">alienator</a> , the redo call skips the continue section). <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Yet another loop done \n"</span></span>; }</code> </pre><br><br>  <strong>(*)</strong> Three scopes for variables: global, lexical and local.  Local scope extends the value of a variable to the current block and to all subroutine calls from this block, useful for redefining the values ‚Äã‚Äãof global variables in a particular block.  The local scope is determined at runtime, and lexical at the compilation stage (this is the most common scope, inside the block). <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> $a = <span class="hljs-string"><span class="hljs-string">'global scope'</span></span>; <span class="hljs-comment"><span class="hljs-comment">#   sub printLocal { local $a = 'local scope'; #   (    ) printGlobal(); } sub printGlobal { print $a, "\n"; } printGlobal(); # 'global scope' printLocal(); # 'local scope' printGlobal(); # 'global scope'</span></span></code> </pre><br><br>  <strong>(*)</strong> Perl implements closures, it is good that the syntax for declaring an anonymous subroutine does not differ from a regular declaration, as it happens in some other languages. <br><br>  <strong>(*)</strong> Already since 2002 Perl has supported a mechanism for calculating constant subroutines, and replacing their call locations with the values ‚Äã‚Äãof a calculated constant ( <a href="http://en.wikipedia.org/wiki/Constexpr">constexpr</a> ). <br><br>  <strong>(*)</strong> Convenient file scan operators (- <em>rwxoRWXOezsfdlpSbctugkTBMAC</em> ). <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (-e <span class="hljs-string"><span class="hljs-string">'/tmp'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> -d <span class="hljs-string"><span class="hljs-string">'/tmp'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'/tmp is directory'</span></span>, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre><br><br>  <strong>(*)</strong> Operator <strong>&lt;&gt;</strong> .  Performs multiple functions.  First, it can be used to search for files by a pattern in the current directory (by the way, the search method can be changed, <a href="http://en.wikipedia.org/wiki/Glob_%2528programming%2529">glob is</a> used by default). <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-string"><span class="hljs-string">','</span></span>, &lt;*.pl&gt;, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">#   *.pl</span></span></code> </pre><br><br>  Secondly, it is an operator to read data from a file descriptor.  Moreover, in a scalar context, it reads the data line by line, and in the list context, it reads the file lines completely into an array. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> F, <span class="hljs-string"><span class="hljs-string">'&lt;somefile'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @random = &lt;F&gt;; <span class="hljs-comment"><span class="hljs-comment">#      close F;</span></span></code> </pre><br><br>  Finally, the empty <strong>&lt;&gt;</strong> operator reads from files whose names were passed in program launch arguments.  It does this explicitly, as if you are working with one large file.  If the program was launched without arguments, it reads from <em>STDIN</em> .  This is very convenient for developing programs for pipelines that will be joined through |, since you do not need to worry about opening and closing files.  Applying this statement, the analogue of the <em>cat command</em> is implemented in one line. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (&lt;&gt;);</code> </pre><br><br>  <strong>(*)</strong> Useful default variable <strong>$ _</strong> .  Most standard subroutines and Perl operators can work with it, and assume that it is used if the input argument of the function is omitted.  Sometimes it allows you to write more concise code. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (&lt;&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">s/^print\s*(.*)/$1/</span></span>); } <span class="hljs-comment"><span class="hljs-comment">#  while ($_ = &lt;&gt;) { print $_ if ($_ =~ s/^print\s*(.*)/$1/); }</span></span></code> </pre><br><br>  <strong>(*)</strong> In Perl, the result of an assignment is an <a href="http://en.wikipedia.org/wiki/Value_%2528computer_science%2529">lvalue</a> .  Therefore, in Perl, it is possible to change the value during assignment. <br><br><pre> <code class="perl hljs">($new = $old) =~ <span class="hljs-regexp"><span class="hljs-regexp">s/bad/good/g</span></span>; <span class="hljs-comment"><span class="hljs-comment">## chomp($answer = &lt;STDIN&gt;); ## if ( ($k, $v) = $string =~ m/(\w+)=(\w+)/ ) { print "key: $k value: $v", "\n"; }</span></span></code> </pre><br><br>  <strong>(*)</strong> The increment operator applied to the string returns the next permutation from the character set. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $a = <span class="hljs-string"><span class="hljs-string">'aa'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ++$a, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">#  ab</span></span></code> </pre><br><br>  <strong>(*)</strong> Automatic expansion of hashes and arrays to an arbitrary depth.  Those.  when accessing a hash on a key that has not yet been added, this element is automatically created.  And Perl guesses the type of element to be created, for example, it can create an anonymous hash, an anonymous array, or a scalar. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $hash = {}; $hash-&gt;{first}-&gt;{second}-&gt;{third} = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $hash-&gt;{first}-&gt;{second}-&gt;{third}, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment"># 5</span></span></code> </pre><br><br>  An interesting feature is the behavior of negative indices in arrays.  A negative index selects elements from the end of the array. <br><br>  <strong>(*)</strong> Strings and quotes.  It's nice that Perl supports entering multi-line documents in a single assignment: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $doc1 = <span class="hljs-string"><span class="hljs-string">'There'</span></span><span class="hljs-keyword"><span class="hljs-keyword">s</span></span> More Than One Way To Do It -- <span class="hljs-number"><span class="hljs-number">2012</span></span><span class="hljs-string"><span class="hljs-string">'; my $doc2 =&lt;&lt;"_DOC2_"; There'</span></span><span class="hljs-keyword"><span class="hljs-keyword">s</span></span> More Than One Way To Do It -- <span class="hljs-number"><span class="hljs-number">2012</span></span> _DOC2<span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>&lt;&lt;<span class="hljs-string"><span class="hljs-string">"_DOC3_"</span></span>; There<span class="hljs-string"><span class="hljs-string">'s More Than One Way To Do It -- 2012 _DOC3_</span></span></code> </pre><br><br>  Using the operator <strong>= &lt;&lt;</strong> allows you to conveniently perform operations with a multi-line document in the same line where the assignment is performed.  It is also convenient to use this operator to transfer documents to functions. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printAll</span></span></span></span>(@) { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> '', @_; } (<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $quote =&lt;&lt;'__QUOTE__')=~<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>/^\<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>+//gm; The Road goes ever on <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> on, down from the door where it began. __QUOTE__ printAll(&lt;&lt;'__GOOD__',&lt;&lt;'__BAD__', $quote); There<span class="hljs-string"><span class="hljs-string">'s More Than One Way To Do It __GOOD__ TIMTOWTDI __BAD__</span></span></code> </pre><br><br>  Perl distinguishes between two ways to enter lines ‚Äî with and without interpretation.  If you use single quotes <strong>'</strong> , the string is assigned to the variable as is (without changes), even the characters \ n are not converted to line breaks.  On the other hand, if you use double quotes, the string is interpreted - Perl detects and replaces variable names with their values, and does it quite skillfully, you can even make a function call directly from the string. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $car = { <span class="hljs-string"><span class="hljs-string">brend =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Lada'</span></span>, <span class="hljs-string"><span class="hljs-string">name =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Kalina'</span></span>, <span class="hljs-string"><span class="hljs-string">drive =&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-string"><span class="hljs-string">"WEEEEEE!\n"</span></span>; } }; <span class="hljs-comment"><span class="hljs-comment">#  Do you want to drive on $car-&gt;{brend} $car-&gt;{name}?\n print 'Do you want to drive on $car-&gt;{brend} $car-&gt;{name}?\n', "\n"; #  Do you want to drive on Lada Kalina? print "Do you want to drive on $car-&gt;{brend} $car-&gt;{name}?\n"; #  WEEEEEE! print "@{[ $car-&gt;{drive}-&gt;() ]}"; #  print "@{[ exit ]}";</span></span></code> </pre><br><br>  However, Perl gives you the right to choose a character for escaping strings and regular expressions. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">q {   ! }</span></span>; (<span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $text = <span class="hljs-string"><span class="hljs-string">"ab c"</span></span>) =~ <span class="hljs-keyword"><span class="hljs-keyword">s</span></span>{\<span class="hljs-keyword"><span class="hljs-keyword">s</span></span>}{}g;</code> </pre><br><br>  Another very useful feature of Perl is the behavior of strings when using `as the escape character of a string.  In this case, Perl executes this string in a shell and returns the result of the command. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">`uptime`</span></span>; <span class="hljs-comment"><span class="hljs-comment">#    print &lt;&lt; `EOC`; #   pwd ls -l EOC</span></span></code> </pre><br><br>  <strong>(*)</strong> Perl supports an interesting subroutine attribute mechanism.  You can draw an analogy with <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2582%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%2528Java%2529">annotations</a> from Java.  Attributes are specified in the declaration of the subroutine with a colon.  You can declare as many multiplayer attributes as you want.  There are also built-in attributes <em>method</em> and <em>lvalue</em> .  The remarkable <em>lvalue</em> attribute allows a subroutine to participate in operations like an <em>lvalue</em> .  For example, you can implement the <em>get</em> and <em>set</em> methods in a single subroutine. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $_name = <span class="hljs-string"><span class="hljs-string">'?'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function">(</span></span>;$): lvalue { $_name = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> || $_name } name = <span class="hljs-string"><span class="hljs-string">'caiiiycuk'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> name(), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre><br><br>  <strong>(*) The</strong> remarkable <em>AUTOLOAD</em> mechanism allows processing calls to non-declared subroutines, which is often used to dynamically load a program in parts.  This means that if Perl does not find the declaration of the subroutine, it calls the <em>AUTOLOAD</em> call with the signature of the function and only if it turns out to be unsuccessful will throw an error.  Using <em>AUTOLOAD</em> , for example, you can achieve a more clear call of system functions, as if they themselves are Perl operators (as the <em>Shell</em> module does). <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AUTOLOAD</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $program = <span class="hljs-keyword"><span class="hljs-keyword">our</span></span> $AUTOLOAD; $program =~ <span class="hljs-regexp"><span class="hljs-regexp">s/.*:://</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>($program, @_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uptime</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echo</span></span></span></span>(@); uptime; echo <span class="hljs-string"><span class="hljs-string">"AUTOLOAD"</span></span>;</code> </pre><br><br>  <strong>(*)</strong> <em>tie</em> - a mechanism for replacing the internal implementation of scalars, arrays and hashes.  Using this mechanism, you can associate an array or hash directly with the database in such a way that any read and write from / to it will automatically be mapped to the database.  Another possible application of this technology may be the calculation of allocated resources. <br><br>  <strong>(*)</strong> Perl supports two models of multithreading: the thread model and the process model.  The process model implies the creation of a new system process with a full copy of the parent process data for parallel data processing.  This is done by the <em>fork</em> , with heroic efforts, the process model is fully supported in Windows, although this parallelization model is more typical of * nix.  It is not quite convenient to use the bare fork function, CPAN is full of modules for easier use of <em>fork</em> , for example, the code could look like this: <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Proc::Fork; run_fork { child { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Process 1\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } parent { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Process 2\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre><br><br>  In contrast to the process model, the thread model is used; these threads share access to all data resources, such threads are more like Java threads.  The thread support module is called <em>Thread</em> , it provides a very convenient async function, which helps to write clear code. <br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> Thread <span class="hljs-string"><span class="hljs-string">'async'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $thread1 = async { <span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $thread2 = async { <span class="hljs-keyword"><span class="hljs-keyword">sleep</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $thread1-&gt;<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $thread2-&gt;<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(), <span class="hljs-string"><span class="hljs-string">"\n"</span></span>;</code> </pre><br><br>  The mechanisms of synchronization of streams are supported: mutexes, semaphores, falling asleep and awakening streams by condition. <br><br>  <strong>(*)</strong> The powerful <em>pack</em> / <em>unpack</em> functions allow you to convert Perl structures into an array of bytes and vice versa.  A very useful thing when reading binary data and for their arbitrary conversion. <br><br>  <strong>(*)</strong> OOP and Perl, this is probably the only thing that makes me have mixed feelings.  This is very similar to what we have in JavaScript, as such, there is no special support for OOP capabilities in the language; nevertheless, all the paradigms of OOP are realizable and quite viable.  However, sometimes there comes a feeling of some kind of a chilliness.  An object can be any scalar, array, or hash data structure.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the help of a special command, the reference to the data structure is blessed into an object ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bless</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), after this action Perl knows that this reference is an object. The methods of this object should be sought in the package in which the link was blessed. Accordingly, there is no classic concept of a constructor; any subprogram that returns blessed data structures can be a constructor. Perl supports the indirect form of calling the object's methods; in this form, the method comes first, then the object reference, and only then the method arguments. Because of this, the call to the new method may look like you expect, but when calling the usual methods, this form of writing may seem strange.</font></font><br><br><pre> <code class="perl hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> Dog; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $class = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bless</span></span> { <span class="hljs-string"><span class="hljs-string">name =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span> }, $class; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gav</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $self = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"$self-&gt;{name}: gav\n"</span></span>; } } { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $dog = Dog-&gt;new(<span class="hljs-string"><span class="hljs-string">'Mona'</span></span>); $dog-&gt;gav(); } { <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> $dog = new Dog <span class="hljs-string"><span class="hljs-string">'Sharik'</span></span>; gav $dog; }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl OOP supports multiple inheritance. </font><font style="vertical-align: inherit;">When using the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use fields</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pragma, it </font><font style="vertical-align: inherit;">is possible to check references to the fields of a class at the compilation stage using pseudo hashes, as well as implementing private class data.</font></font><br><br><pre> <code class="perl hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">package</span></span> Foo; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> fields <span class="hljs-string"><span class="hljs-string">qw(foo)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Foo $self = <span class="hljs-keyword"><span class="hljs-keyword">shift</span></span>; $self = fields::new($self); $self-&gt;{foo} = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $self; } } <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> Foo $var = Foo-&gt;new; $var-&gt;{foo} = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment"># :     $var-&gt;{zap} = 42;</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, class methods cannot have prototypes, so we lose the ability to check the correctness of calling methods and passing arguments, this is regrettable. </font><font style="vertical-align: inherit;">Perl supports object destructors. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(*) The</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> special label __DATA__ indicates the end of the script, all the text after this label is available to the program through a special file descriptor DATA. </font><font style="vertical-align: inherit;">This is very convenient for writing small tests when the data and the test itself are not separable from each other. </font><font style="vertical-align: inherit;">But the whole system of testing in Perl is more than convenient, which is inherent in all dynamic languages.</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> strict; <span class="hljs-keyword"><span class="hljs-keyword">my</span></span> @content = &lt;DATA&gt;; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span>, @content; __DATA_<span class="hljs-number"><span class="hljs-number">_</span></span> A B C</code> </pre><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(*)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A huge number of Perl command flags allow you to write the shortest one-liners to process files. For example, the -n flag encloses the script in a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">while (&lt;&gt;) loop</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which we considered earlier. That is, an analogue cat can be written like this:</font></font><br><br><pre> <code class="perl hljs">perl -<span class="hljs-keyword"><span class="hljs-keyword">ne</span></span> <span class="hljs-string"><span class="hljs-string">"print;"</span></span> file1 file2 ... fileN</code> </pre><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(*)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A very interesting opportunity to write code generators. After compiling the code, the Perl program is a graph of operators. This graph is normally transmitted to the Perl interpreter, but you can change this behavior by performing your actions with this graph. For example, you can simply serialize the entire graph to a file, and then read it on another computer and transfer it to Perl interpretation, omitting the compilation phase. A more complex application of this technology is the generation of C or C ++ code from a Perl program. Generators </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B :: C</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B :: CC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they are directed at this; when using them, the Perl program is converted to source codes in the target language, then they are compiled into machine codes and can be run without the Perl interpreter. In addition to the code generators in Perl, there are also code filters, they allow you to arbitrarily convert the source code of a program before compiling and interpreting, you can write your own language if you want. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(*)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Labeled data mode. While in this mode, Perl takes special precautions to avoid obvious and hidden security holes. The principle is simple: you cannot use data obtained from outside the program being executed to influence anything else outside of it. Any data entering the program from the outside becomes ‚Äúmarked‚Äù as data of dubious origin. Labeled data cannot be used directly or indirectly in any operation that causes a "shell", as well as in any operations modifying files, directories or processes. Therefore, many security problems are avoided. The use of labeled data mode is a good way to run scripts on the server. There are modules that go even further in improving security, for example, the Safe module.</font></font><br><br><pre> <code class="perl hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/perl -T use strict; print "Enter file/directory name to delete: \n"; my $file = &lt;STDIN&gt;; # :   ,    #    `rm -rf $file`;</span></span></code> </pre><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(*)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PSGI / Plack is a specification designed to separate the web server environment from the web framework code. Simply put, this is something like a container servlet from the world of Java. We write a web application using this specification and run it on any of the servers supporting PSGI, of which there are a great many.</font></font> <a href="http://habrahabr.ru/post/78377/">More details</a> . <br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(*)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And Perl is a sea of ‚Äã‚Äãpleasant emotions, which is only a set of ACME modules. </font><font style="vertical-align: inherit;">For example, the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACME :: EyeDrops module</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allows </font><a href=""><font style="vertical-align: inherit;">you</font></a><font style="vertical-align: inherit;"> to convert Perl programs into ASCII art that works. </font><font style="vertical-align: inherit;">There is a </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buffy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fan </font><a href=""><font style="vertical-align: inherit;">module</font></a><font style="vertical-align: inherit;"> , using which programs can only be written using the word buffy. </font><font style="vertical-align: inherit;">Well, the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ACME :: ChuckNorris module</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> speaks for itself. </font><font style="vertical-align: inherit;">In addition, there is Perl poetry - this is a valid syntactic program from the point of view of Perl, and poetry from the point of view of man is one of those in the title of this article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bon Voyage! </font></font><br><br> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So thinks my Perl, yours might think differently </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIMTOWTDI </font></font></em> <br> <sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interesting possibilities in my opinion Perl</font></font></div><p>Source: <a href="https://habr.com/ru/post/155461/">https://habr.com/ru/post/155461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155445/index.html">An example of the development of simple casual games for Windows 8</a></li>
<li><a href="../155447/index.html">Custom CSS Filters</a></li>
<li><a href="../155449/index.html">Curiosity sent the first soil sample for internal research</a></li>
<li><a href="../155451/index.html">A scientific journal in mathematics accepted an article from the text generator Mathgen</a></li>
<li><a href="../155459/index.html">A look from Google on site optimization</a></li>
<li><a href="../155465/index.html">Easy way to create Unity Lens for Ubuntu (translation)</a></li>
<li><a href="../155467/index.html">Introduction to CMake</a></li>
<li><a href="../155469/index.html">9 core issues in a developer‚Äôs career</a></li>
<li><a href="../155471/index.html">Holographic properties of bit-reversible permutation</a></li>
<li><a href="../155473/index.html">About unmanned vehicles or why I do not want to live in a "smart house"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>