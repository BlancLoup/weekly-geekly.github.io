<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expressive javascript: Project: programming language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


- Introduction 
- Values, Types and Operators 
- Program structure 
- Functions 
- Data Structures: Objects and Arrays 
- Higher order func...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expressive javascript: Project: programming language</h1><div class="post__text post__text-html js-mediator-article"><h4>  Content </h4><br><ul><li>  <a href="http://habrahabr.ru/post/240219/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/240223/">Values, Types and Operators</a> </li><li>  <a href="http://habrahabr.ru/post/240225/">Program structure</a> </li><li>  <a href="http://habrahabr.ru/post/240349/">Functions</a> </li><li>  <a href="http://habrahabr.ru/post/240813/">Data Structures: Objects and Arrays</a> </li><li>  <a href="http://habrahabr.ru/post/241155/">Higher order functions</a> </li><li>  <a href="http://habrahabr.ru/post/241587/">The secret life of objects</a> </li><li>  <a href="http://habrahabr.ru/post/241776/">Project: e-life</a> </li><li>  <a href="http://habrahabr.ru/post/242609/">Search and error handling</a> </li><li>  <a href="http://habrahabr.ru/post/242695/">Regular expressions</a> </li><li>  <a href="http://habrahabr.ru/post/243273/">Modules</a> </li><li>  <a href="http://habrahabr.ru/post/243277/">Project: programming language</a> </li><li>  <a href="http://habrahabr.ru/post/243311/">Javascript and browser</a> </li><li>  <a href="http://habrahabr.ru/post/243815/">Document Object Model</a> </li><li>  <a href="http://habrahabr.ru/post/244041/">Event handling</a> </li><li>  <a href="http://habrahabr.ru/post/244405/">Project: Platform Game</a> </li><li>  <a href="http://habrahabr.ru/post/244545/">Drawing on canvas</a> </li><li>  <a href="http://habrahabr.ru/post/245145/">HTTP</a> </li><li>  <a href="http://habrahabr.ru/post/245731/">Forms and form fields</a> </li><li>  <a href="http://habrahabr.ru/post/245767/">Project: Paint</a> </li><li>  <a href="http://habrahabr.ru/post/245775/">Node.js</a> </li><li>  <a href="http://habrahabr.ru/post/246331/">Project: website sharing experience</a> </li><li>  <a href="http://eloquentjavascript.net/code">Sandbox for code</a> </li></ul><br><br>  <i>That which checks and determines the meaning of expressions in a programming language is in turn simply a program.</i> <i><br><br></i>  <i>Hal Abelson and G√©rald Sasman, "Structure and Interpretation of Computer Programs."</i> <i>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </i>  <i>When the teacher asked the teacher about the nature of the Data and Control cycle, Yuan-Ma replied: "Think about a compiler compiling yourself."</i> <i><br><br></i>  <i>Master Yuan-Ma, "Programming Book"</i> <br><br>  Creating your own programming language is surprisingly easy (as long as you do not set any extraordinary goals) and quite instructive. <br><br>  The main thing that I want to demonstrate in this chapter is that there is no magic in the construction of a language.  It often seemed to me that some human inventions are so complex and abstruse that I will never understand them.  However, after a little self-education and picking, such things often turn out to be quite ordinary. <br><br>  We will build the programming language Egg (Egg).  It will be small, simple, but powerful enough to express any calculations.  It will also implement simple abstractions based on functions. <br><a name="habracut"></a><br><h4>  Parsing </h4><br>  What lies on the surface of the language is syntax, notation.  A grammar analyzer, or parser, is a program that reads a piece of text and issues a data structure that describes the structure of the program contained in the text.  If the text does not describe the correct program, the parser should complain and indicate an error. <br><br>  Our language will have a simple and uniform syntax.  In Egg, everything will be an expression.  An expression can be a variable, a number, a string, or an application.  Applications are used to call functions and constructions of if or while type. <br><br>  To simplify parsing, strings in Egg will not support backslashes and similar things.  A string is simply a sequence of characters that are not double quotes enclosed in double quotes.  Number - a sequence of numbers.  Variable names can consist of any characters that are not spaces and have no special meaning in the syntax. <br><br>  Applications are written the same way as in JS - with the help of brackets after the expression and with any number of arguments in brackets, separated by commas. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span>(define(x, <span class="hljs-number"><span class="hljs-number">10</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(&gt;(x, <span class="hljs-number"><span class="hljs-number">5</span></span>)), print(<span class="hljs-string"><span class="hljs-string">""</span></span>), print(<span class="hljs-string"><span class="hljs-string">""</span></span>))</code> </pre> <br><br>  The homogeneity of the language means that what is an operator in JS is applied in the same way as other functions.  Since there is no concept of blocks in the syntax, we need the do construction to refer to several things that are performed sequentially. <br><br>  The data structure that describes the program will consist of expression objects, each of which will have a type property that reflects the type of this expression and other properties that describe the content. <br><br>  Expressions of type ‚Äúvalue‚Äù represent strings or numbers.  Their value property contains the string or number they represent.  Expressions like ‚Äúword‚Äù are used for identifiers (names).  Such objects have a name property that contains the name of the identifier as a string.  Finally, the ‚Äúapply‚Äù clauses represent applications.  They have an ‚Äúoperator‚Äù property, referencing the applicable expression, and an ‚Äúargs‚Äù property with an array of arguments. <br><br>  The&gt; (x, 5) part will be represented as: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, <span class="hljs-attr"><span class="hljs-attr">operator</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"word"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>}, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: [ {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"word"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"x"</span></span>}, {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"value"</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>} ] }</code> </pre><br><br>  This data structure is called a syntax tree.  If you represent objects as points, and connections between them as lines, you will get a tree structure.  The fact that expressions contain other expressions, which in turn may contain their own expressions, is similar to how branches branch. <br><br><h4>  Syntax tree structure </h4><br>  Compare this with the parser we wrote for the configuration file in Chapter 9, which had a simple structure: it divided the input into lines and processed them one by one.  There were only a few forms that are allowed to take the string. <br><br>  Here we need a different approach.  Expressions are not divided into lines, and their structure is recursive.  Application expressions contain other expressions.  Fortunately, this problem is elegantly solved by using a recursive function that reflects the recursiveness of the language. <br><br>  We define the parseExpression function, which accepts an input string and returns an object containing the data structure for the expression from the beginning of the string, along with the portion of the string left after parsing.  When parsing subexpressions (such as an application argument), this function is called again, returning the expression of the argument along with the remaining text.  That text may, in turn, contain more arguments, or be a closing parenthesis, completing the list of arguments. <br><br>  The first part of the parser: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseExpression</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">program</span></span></span><span class="hljs-function">) </span></span>{ program = skipSpace(program); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> match, expr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (match = <span class="hljs-regexp"><span class="hljs-regexp">/^"([^"]*)"/</span></span>.exec(program)) expr = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"value"</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: match[<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (match = <span class="hljs-regexp"><span class="hljs-regexp">/^\d+\b/</span></span>.exec(program)) expr = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"value"</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(match[<span class="hljs-number"><span class="hljs-number">0</span></span>])}; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (match = <span class="hljs-regexp"><span class="hljs-regexp">/^[^\s(),"]+/</span></span>.exec(program)) expr = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"word"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: match[<span class="hljs-number"><span class="hljs-number">0</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>(<span class="hljs-string"><span class="hljs-string">" : "</span></span> + program); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseApply(expr, program.slice(match[<span class="hljs-number"><span class="hljs-number">0</span></span>].length)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skipSpace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first = string.search(<span class="hljs-regexp"><span class="hljs-regexp">/\S/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string.slice(first); }</code> </pre><br><br>  Because Egg allows any number of spaces in the elements, we need to constantly cut the spaces from the beginning of the line.  SkipSpace copes with this. <br><br>  Passing leading spaces, parseExpression uses three regulars to recognize three simple (atomic) elements supported by the language: strings, numbers, and words.  The parser creates different structures for different types.  If the input does not match any of the forms, this is not a valid expression, and it throws an error.  SyntaxError is a standard error object that is created when you try to run an incorrect JavaScript program. <br><br>  We can cut off the processed part of the program, and pass it, along with the expression object, to parseApply, which determines whether the expression is not an application.  If so, it parses the list of arguments in brackets. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseApply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">expr, program</span></span></span><span class="hljs-function">) </span></span>{ program = skipSpace(program); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (program[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">"("</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-attr"><span class="hljs-attr">expr</span></span>: expr, <span class="hljs-attr"><span class="hljs-attr">rest</span></span>: program}; program = skipSpace(program.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>)); expr = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, <span class="hljs-attr"><span class="hljs-attr">operator</span></span>: expr, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: []}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (program[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">")"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arg = parseExpression(program); expr.args.push(arg.expr); program = skipSpace(arg.rest); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (program[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">","</span></span>) program = skipSpace(program.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (program[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">")"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>(<span class="hljs-string"><span class="hljs-string">" ',' or ')'"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseApply(expr, program.slice(<span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre><br><br>  If the next program character is a non-opening parenthesis, then this is not an application, and parseApply simply returns the expression given to it. <br><br>  Otherwise, it skips the opening bracket and creates a syntax tree object for this expression.  It then recursively calls parseExpression to parse each argument until it encounters a closing bracket.  Indirect recursion, parseApply and parseExpression cause each other. <br><br>  Since the application itself can be an expression (multiplier (2) (1)), parseApply should, after parsing the application, invoke itself again by checking if there is another pair of braces. <br><br>  That's all we need to parse Egg.  We wrap this into a convenient parse function that checks that it reached the end of the line after parsing an expression (the Egg program is one expression), and this will give us the program's data structure. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">program</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = parseExpression(program); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skipSpace(result.rest).length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>(<span class="hljs-string"><span class="hljs-string">"   "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.expr; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(parse(<span class="hljs-string"><span class="hljs-string">"+(a, 10)"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {type: "apply", // operator: {type: "word", name: "+"}, // args: [{type: "word", name: "a"}, // {type: "value", value: 10}]}</span></span></code> </pre><br><br>  Works!  It does not provide useful information in case of an error, and does not store the row and column numbers from which each expression begins, which could be useful in analyzing errors - but that‚Äôs enough for us. <br><br><h4>  Interpreter </h4><br>  And what should we do with the syntax tree of the program?  Run it!  The interpreter does this.  You give it a syntax tree and an environment object that associates names with values, and it interprets the expression represented by the tree and returns the result. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">expr, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(expr.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> expr.value; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"word"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr.name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> env) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env[expr.name]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ReferenceError</span></span>(<span class="hljs-string"><span class="hljs-string">" : "</span></span> + expr.name); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"apply"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr.operator.type == <span class="hljs-string"><span class="hljs-string">"word"</span></span> &amp;&amp; expr.operator.name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> specialForms) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialForms[expr.operator.name](expr.args, env); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> op = evaluate(expr.operator, env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> op != <span class="hljs-string"><span class="hljs-string">"function"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">"   ."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> op.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, expr.args.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(arg, env); })); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> specialForms = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><br>  The interpreter has code for each type of expression.  For literals, it returns their value.  For example, the expression 100 is interpreted into the number 100. We must check the variable if it is defined in the environment, and if so, ask for its value. <br><br>  With applications harder.  If this is a special form of the if type, we do not interpret anything, but simply pass the arguments along with the environment to the function that processes the form.  If this is a simple call, we interpret the operator, verify that it is a function and call it with the result of the interpretation of the arguments. <br><br>  To represent the values ‚Äã‚Äãof Egg functions, we will use simple values ‚Äã‚Äãof JavaScript functions.  We will come back to this later when we define a special form of fun. <br><br>  The recursive interpreter structure resembles a parser.  Both reflect the structure of the language.  One could integrate the parser into the interpreter and interpret it during parsing, but their separation makes the program more readable. <br><br>  That's all you need to interpret Egg.  Just like that.  But without defining a few special forms and adding useful values ‚Äã‚Äãto the environment, you cannot do anything with this language. <br><br><h4>  Special forms </h4><br>  The specialForms object is used to define special Egg syntax.  He matches words with functions that interpret these special forms.  While it is empty.  Let's add some forms. <br><br><pre> <code class="javascript hljs">specialForms[<span class="hljs-string"><span class="hljs-string">"if"</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.length != <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>(<span class="hljs-string"><span class="hljs-string">"    if"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (evaluate(args[<span class="hljs-number"><span class="hljs-number">0</span></span>], env) !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(args[<span class="hljs-number"><span class="hljs-number">1</span></span>], env); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(args[<span class="hljs-number"><span class="hljs-number">2</span></span>], env); };</code> </pre><br><br>  The if construct of the Egg language waits for three arguments.  It calculates the first, and if the result is not false, it calculates the second.  Otherwise, it calculates the third.  This if is more like a ternary operator?:.  It is an expression, not an instruction, and it gives the value, namely, the result of the second or third expression. <br><br>  Egg differs from JavaScript in how it handles an if condition.  It will not count a zero or empty string as false. <br><br>  if is represented as a special form and not as an ordinary function, because the arguments of functions are evaluated before the call, and if must interpret one of two arguments, the second or third, depending on the value of the first. <br><br>  The form for while is similar. <br><br><pre> <code class="javascript hljs">specialForms[<span class="hljs-string"><span class="hljs-string">"while"</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.length != <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>(<span class="hljs-string"><span class="hljs-string">"    while"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (evaluate(args[<span class="hljs-number"><span class="hljs-number">0</span></span>], env) !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) evaluate(args[<span class="hljs-number"><span class="hljs-number">1</span></span>], env); <span class="hljs-comment"><span class="hljs-comment">//  undefined    Egg, //      false return false; };</span></span></code> </pre><br><br>  Another main part of the language is do, which performs all the arguments from top to bottom.  Its value is the value returned by the last argument. <br><pre> <code class="javascript hljs">specialForms[<span class="hljs-string"><span class="hljs-string">"do"</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; args.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">) </span></span>{ value = evaluate(arg, env); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; };</code> </pre><br><br>  To create variables and give them values, we create a define form.  She expects word as the first argument, and an expression that produces the value to assign to this word as the second.  define, like everything, is an expression, so it must return a value.  Let it return the assigned value (just like the operator = in JavaScript). <br><br><pre> <code class="javascript hljs">specialForms[<span class="hljs-string"><span class="hljs-string">"define"</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.length != <span class="hljs-number"><span class="hljs-number">2</span></span> || args[<span class="hljs-number"><span class="hljs-number">0</span></span>].type != <span class="hljs-string"><span class="hljs-string">"word"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>(<span class="hljs-string"><span class="hljs-string">"Bad use of define"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = evaluate(args[<span class="hljs-number"><span class="hljs-number">1</span></span>], env); env[args[<span class="hljs-number"><span class="hljs-number">0</span></span>].name] = value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; };</code> </pre><br><br><h4>  Environment </h4><br>  The environment accepted by the interpreter is an object with properties, whose names correspond to the names of variables, and values ‚Äã‚Äã- to the values ‚Äã‚Äãof these variables.  Let's define an environment object that represents a global scope. <br><br>  To use the if construct, we must create boolean values.  Since there are only two of them, special syntax is not needed for them.  We simply make two variables true and false. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> topEnv = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); topEnv[<span class="hljs-string"><span class="hljs-string">"true"</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; topEnv[<span class="hljs-string"><span class="hljs-string">"false"</span></span>] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;      ,     . var prog = parse(<span class="hljs-string"><span class="hljs-string">"if(true, false, true)"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(evaluate(prog, topEnv)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí false</span></span></code> </pre><br><br>  To support simple arithmetic operators and comparisons, we add several functions to the environment.  To simplify the code, we will use the new Function to create a set of operator functions in a loop, rather than defining them all separately. <br><br><pre> <code class="javascript hljs">[<span class="hljs-string"><span class="hljs-string">"+"</span></span>, <span class="hljs-string"><span class="hljs-string">"-"</span></span>, <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-string"><span class="hljs-string">"=="</span></span>, <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>].forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op</span></span></span><span class="hljs-function">) </span></span>{ topEnv[op] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>(<span class="hljs-string"><span class="hljs-string">"a, b"</span></span>, <span class="hljs-string"><span class="hljs-string">"return a "</span></span> + op + <span class="hljs-string"><span class="hljs-string">" b;"</span></span>); });</code> </pre><br><br>  Also useful is a way to output values, so we wrap console.log into a function and call it print. <br><br><pre> <code class="javascript hljs">topEnv[<span class="hljs-string"><span class="hljs-string">"print"</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; };</code> </pre><br><br>  This gives us enough elementary tools for writing simple programs.  The next run function provides a convenient way to write and run.  It creates a fresh environment, parsit and parses the lines that we pass to it, as if they were one program. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> env = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(topEnv); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> program = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.slice .call(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).join(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(parse(program), env); }</code> </pre><br><br>  Using Array.prototype.slice.call is a trick to turning an object like an array, such as an argument, into a real array, so we can apply join to it.  It takes all the arguments passed to run, and considers that all of them are program lines. <br><br><pre> <code class="javascript hljs">run(<span class="hljs-string"><span class="hljs-string">"do(define(total, 0),"</span></span>, <span class="hljs-string"><span class="hljs-string">" define(count, 1),"</span></span>, <span class="hljs-string"><span class="hljs-string">" while(&lt;(count, 11),"</span></span>, <span class="hljs-string"><span class="hljs-string">" do(define(total, +(total, count)),"</span></span>, <span class="hljs-string"><span class="hljs-string">" define(count, +(count, 1)))),"</span></span>, <span class="hljs-string"><span class="hljs-string">" print(total))"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 55</span></span></code> </pre><br><br>  We have already seen this program several times - it calculates the sum of numbers from 1 to 10 in the Egg language.  It is uglier than an equivalent JavaScript program, but not so bad for a language given in less than 150 lines of code. <br><br><h4>  Functions </h4><br>  A programming language without functions is a bad language. <br><br>  Fortunately, it is easy to add the fun construct, which regards the last argument as the function body, and all the previous ones are the function argument names. <br><br><pre> <code class="javascript hljs">specialForms[<span class="hljs-string"><span class="hljs-string">"fun"</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.length) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">expr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expr.type != <span class="hljs-string"><span class="hljs-string">"word"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>(<span class="hljs-string"><span class="hljs-string">"     word"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> expr.name; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> argNames = args.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, args.length - <span class="hljs-number"><span class="hljs-number">1</span></span>).map(name); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = args[args.length - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length != argNames.length) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localEnv = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(env); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length; i++) localEnv[argNames[i]] = <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[i]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(body, localEnv); }; };</code> </pre><br><br>  Functions in Egg have their own local environment, just like in JavaScript.  We use Object.create to create a new object that has access to variables in the external environment (of its prototype), but it can also contain new variables without changing the external scope. <br><br>  The function created by the fun form creates its local environment and adds variable arguments to it.  She then interprets the body in this environment and returns the result. <br><br><pre> <code class="javascript hljs">run(<span class="hljs-string"><span class="hljs-string">"do(define(plusOne, fun(a, +(a, 1))),"</span></span>, <span class="hljs-string"><span class="hljs-string">" print(plusOne(10)))"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 11 run("do(define(pow, fun(base, exp,", " if(==(exp, 0),", " 1,", " *(base, pow(base, -(exp, 1)))))),", " print(pow(2, 10)))"); // ‚Üí 1024</span></span></code> </pre><br><br><h4>  Compilation </h4><br>  We have built an interpreter.  During interpretation, it works with the program representation created by the parser. <br><br>  Compiling - adding one more step between the parser and running the program, which turns into a program into something that can be performed more efficiently, by doing most of the work in advance.  For example, in well-organized languages, each time a variable is used, it is obvious which variable is accessed, even without starting the program.  This can be used not to look for a variable by name every time it is accessed, but to directly call it from some predetermined area of ‚Äã‚Äãmemory. <br><br>  By tradition, the compilation also turns the program into machine code - a raw format suitable for execution by the processor.  But each process of turning a program into a different kind is, in fact, a compilation. <br><br>  You could create another Egg interpreter, which first turns the program into a JavaScript program, uses the new Function to invoke the JavaScript compiler, and returns the result.  If implemented correctly, Egg would execute very quickly with a relatively simple implementation. <br><br>  If this is interesting for you and you want to spend time on it, I encourage you to try to make such a compiler as an exercise. <br><br><h4>  Fraud </h4><br>  When we defined if and while, you might notice that they were simple wrappers around if and while in JavaScript.  Values ‚Äã‚Äãin Egg are also common JavaScript values. <br><br>  By comparing the JavaScript implementation of Egg with the amount of work needed to create a programming language directly in machine language, the difference becomes huge.  Nevertheless, this example, I hope, gives you an idea of ‚Äã‚Äãthe work of programming languages. <br><br>  And when you need to do something, it will be more efficient to cheat than to do everything from scratch yourself.  And although a toy language is no better than JavaScript, in some situations, writing your own language helps you do work faster. <br><br>  Such a language is not obliged to remind ordinary PL.  If JavaScript did not contain regular expressions, you could write your own parser and interpreter for such a sub-language. <br><br>  Or imagine that you are building a giant dinosaur robot and you need to program its behavior.  JavaScript is not the most efficient way to do this.  You can instead choose a language like this: <br><br><pre> <code class="javascript hljs">behavior walk perform when destination ahead actions move left-foot move right-foot behavior attack perform when Godzilla <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>-view actions fire laser-eyes launch arm-rockets</code> </pre><br><br>  This is commonly referred to as a domain-specific language (domain-specific language), a language specifically designed to work in a narrow direction.  Such a language can be more expressive than a general purpose language, because it is designed to express precisely those things that need to be expressed in this area - and nothing more. <br><br><h4>  Exercises </h4><br><h5>  Arrays </h5><br>  Add array support to Egg.  To do this, add three functions to the main scope: array (...) to create an array containing the values ‚Äã‚Äãof the arguments, length (array) to return the length of the array, and element (array, n) to return the nth element. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   topEnv["array"] = "..."; topEnv["length"] = "..."; topEnv["element"] = "..."; run("do(define(sum, fun(array,", " do(define(i, 0),", " define(sum, 0),", " while(&lt;(i, length(array)),", " do(define(sum, +(sum, element(array, i))),", " define(i, +(i, 1)))),", " sum))),", " print(sum(array(1, 2, 3))))"); // ‚Üí 6</span></span></code> </pre><br><br><h5>  Closures </h5><br>  The definition of fun allows functions in Egg to lock around the environment, and use local variables in the function body that are visible during the definition, just like in JavaScript functions. <br><br>  The following program illustrates this: the function f returns a function that adds its argument to the argument f, that is, it needs access to the local scope within f to use the variable a. <br><br><pre> <code class="javascript hljs">run(<span class="hljs-string"><span class="hljs-string">"do(define(f, fun(a, fun(b, +(a, b)))),"</span></span>, <span class="hljs-string"><span class="hljs-string">" print(f(4)(5)))"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 9</span></span></code> </pre><br><br>  Explain, using the form definition fun, which mechanism allows this construction to work. <br><br><h5>  Comments </h5><br>  It would be nice to have comments in Egg.  For example, we could ignore the rest of the line, encountering the ‚Äú#‚Äù character, as it does with ‚Äú//‚Äù in JS. <br><br>  Big changes in the parser do not have to.  We will simply change skipSpace so that it skips comments, as if they are spaces - and in all places where skipSpace is called, comments will also be skipped.  Make this change. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    function skipSpace(string) { var first = string.search(/\S/); if (first == -1) return ""; return string.slice(first); } console.log(parse("# hello\nx")); // ‚Üí {type: "word", name: "x"} console.log(parse("a # one\n # two\n()")); // ‚Üí {type: "apply", // operator: {type: "word", name: "a"}, // args: []}</span></span></code> </pre><br><br><h5>  We fix the scope </h5><br>  Now we can assign a variable value only through define.  This construct works both when assigning old variables and creating new ones. <br><br>  This ambiguity leads to problems.  If you are trying to assign a new value to a non-local variable, instead you define a local with the same name.  (Some languages ‚Äã‚Äãdo that, but it has always seemed to me a foolish way of working with the scope). <br><br>  Add a set form, similar to define, which assigns a new value to a variable, updating the variable in the external scope if it is not set in the local one.  If the variable is not set at all, throw a ReferenceError (another standard error type). <br><br>  The technique of presenting scopes as simple objects, which until now has been convenient, will now disturb you.  You may need the Object.getPrototypeOf function to return the prototype of the object.  Also remember that the scope is not inherited from the Object.prototype, so if you need to call hasOwnProperty on them, you will have to use this clumsy construct: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.hasOwnProperty.call(scope, name);</code> </pre><br><br>  This calls the hasOwnProperty method of the Object prototype and then calls it on the scope object. <br><br><pre> <code class="javascript hljs">specialForms[<span class="hljs-string"><span class="hljs-string">"set"</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   }; run("do(define(x, 4),", " define(setx, fun(val, set(x, val))),", " setx(50),", " print(x))"); // ‚Üí 50 run("set(quux, true)"); // ‚Üí   ReferenceError</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/243277/">https://habr.com/ru/post/243277/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243257/index.html">Google: recommendations for apps on Google Play</a></li>
<li><a href="../243263/index.html">Running Lean. Retelling one of the best books about startups</a></li>
<li><a href="../243271/index.html">Simple one-sided universal connector for Chrome</a></li>
<li><a href="../243273/index.html">Expressive JavaScript: Modules</a></li>
<li><a href="../243275/index.html">Virtual hackathon with a prize fund of $ 30,000 in early December</a></li>
<li><a href="../243279/index.html">Apple commented on the situation with the Masque vulnerability in iOS</a></li>
<li><a href="../243281/index.html">New dangerous vulnerability discovered in Windows</a></li>
<li><a href="../243283/index.html">Create products, shape habits. Interview with Nir Eyal</a></li>
<li><a href="../243285/index.html">Likbez: image resize methods</a></li>
<li><a href="../243291/index.html">Java: IP telephony from scratch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>