<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Personalize IMGUI and Unity Editor. Part one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="More than a year has passed since the release of the Unity UI system, so Richard Fine decided to write about its predecessor, IMGUI. 
 At first glance...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Personalize IMGUI and Unity Editor. Part one</h1><div class="post__text post__text-html js-mediator-article"> More than a year has passed since the release of the Unity UI system, so Richard Fine decided to write about its predecessor, IMGUI. <br>  At first glance, this is completely illogical.  Why write about an obsolete UI system, if a new one has long been released?  Well, the new system does offer a wide range of options for customizing game interfaces, but if you want to add new tools and functions to the editor, IMGUI will surely come in handy. <br><br><img src="https://habrastorage.org/files/59a/333/b26/59a333b26acd4d06a62c3f0a21e28c77.jpg"><br><a name="habracut"></a><br>  <b>Getting started</b> <br><br>  So the first question: what does <a href="http://docs.unity3d.com/Manual/GUIScriptingGuide.html">IMGUI</a> mean?  IMGUI stands for Immediate Mode GUI.  This is worth telling in more detail.  There are 2 main approaches to GUI systems: direct (Immediate Mode GUI) and saved (Retained Mode GUI). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When using the saved mode, the system remembers the information about the interface.  The developer adds various elements: labels, buttons, sliders, text fields, then the data is saved and used to determine the appearance of the screen, event processing, etc. When you change the text on the label or move the button, you actually change the data stored in the system and create a new system state.  When you interact with the interface, the system remembers your actions, but does nothing more without an additional request.  Unity UI works in this mode.  You create components like UI.Labels or UI.Buttons, configure them, and the system takes care of the rest. <br><br>  When using direct mode, the system does not remember information about the interface, but instead constantly requests and refines information about its elements.  Each of them must be specified by calling a function.  Reaction to any user action is returned immediately, without additional request.  Such a system is ineffective for the user interface of the game and inconvenient for artists due to the dependence on the code.  At the same time, it is well suited for the Unity editor, whose interface already depends on the code and does not change in real time, unlike the game.  Direct mode also allows you to change the displayed tools in accordance with the new state of the system. <br><br>  As a digression, you can watch Casey Muratori's <a href="http://mollyrocket.com/861">excellent video</a> , in which he examines the basic principles and benefits of direct mode. <br><br>  <b>Event handling</b> <br><br>  The active IMGUI interface always has an event to handle, for example, ‚Äúuser clicks the mouse button‚Äù or ‚Äúneed to redraw the interface‚Äù.  The type of the current event can be found in the value of Event.current.type. <br>  Imagine that you need to add a set of buttons to the interface window.  In this case, to handle each event, you must write a separate code.  Schematically, this can be represented as: <br><br><img src="https://habrastorage.org/files/a28/927/5bf/a289275bfd914ef4909adc81075ef5e1.png"><br><br>  Writing separate functions for each event takes a lot of time, but in their structure they are very similar.  At each stage, we will perform actions with the same elements (button 1, 2 or 3).  The concrete action depends on the event, but the structure remains unchanged.  This means that instead of the first algorithm, you can make a single function: <br><br><img src="https://habrastorage.org/files/eaf/142/fd0/eaf142fd0eec4a92983b2df52bb15496.png"><br><br>  The single OnGUI function calls the library functions (for example, <a href="http://docs.unity3d.com/ScriptReference/GUI.Button.html">GUI.Button</a> ), which perform various actions depending on the type of event being processed.  Nothing complicated! <br><br>  The most commonly used events are the following five types: <br><br>  EventType.MouseDown - The user pressed the mouse button. <br>  EventType.MouseUp - The user pressed the mouse button. <br>  EventType.KeyDown - The user has pressed a key. <br>  EventType.KeyUp - The user has pressed a key. <br>  EventType.Repaint - Need to redraw the interface <br><br>  For a complete list of event types, see the <a href="http://docs.unity3d.com/ScriptReference/EventType.html">EventType documentation.</a> <br>  How does the standard GUI.Button control respond to events? <br><br>  EventType.Repaint - Redrawing the button in the specified rectangle <br>  EventType.MouseDown - If the coordinates of the cursor coincide with the area of ‚Äã‚Äãthe button, check the ‚Äúbutton pressed‚Äù checkbox and start the button redrawing when pressed. <br>  EventType.MouseUp - Uncheck the box ‚Äúpressed‚Äù and start redrawing the button in the released form.  If the cursor is in the button area, return TRUE (the button was pressed and released). <br><br>  In practice, everything is not so simple.  For example, buttons should respond to keystroke events.  In addition, you need to add a code that stops the response to the MouseUp from any buttons except the one that the cursor was hovering at the time of clicking.  In any case, if the GUI.Button is called at the same place in the code and retains the same coordinates and content, the code snippets will work together to define the button behavior. <br><br>  For the unified model of the interface behavior at various events in IMGUI, the control identifier is used - control ID.  Using this identifier, you can make uniform calls to the interface elements in any event.  A Control ID is assigned to each interface element with non-trivial interactive behavior.  The assignment is performed depending on the order of requests, therefore, if the interface functions are called in the same order from different events, they will be assigned the same identifiers, and the events will be synchronized. <br><br>  <b>Creating interface elements</b> <br><br>  The <a href="http://docs.unity3d.com/ScriptReference/GUI.html">GUI</a> and <a href="http://docs.unity3d.com/ScriptReference/EditorGUI.html">EditorGUI classes</a> provide a library of standard Unity interface elements.  You can use them to create your own Editor, EditorWindow, or PropertyDrawer classes. <br><br>  Novice developers often neglect the GUI class, preferring to use EditorGUI.  In fact, the elements of both classes are equally useful and can be shared to enhance the functionality of the editor.  The main difference is that EditorGUI elements cannot be used in game interfaces, as they are part of the editor, while GUI elements are part of the engine itself. <br><br>  But what if you don‚Äôt have enough standard library resources? <br><br>  <a href="http://blogs.unity3d.com/2015/12/22/going-deep-with-imgui-and-editor-customization/">Let's take a look</a> at what a unique user interface element looks like on the example of this demo application (viewing requires a browser with WebGL support, for example, the latest version of Firefox). <br><br>  The color scroll bars in the demo are associated with floating variables that have a value from 0 to 1. You can use them in the Unity Inspector to display the state of individual parts of a game object, for example, a spacecraft (suppose the value 1 means ‚Äúno damage‚Äù and 0 critical damage ").  The color of the bars changes depending on the value, so that the user can quickly understand the situation.  These interface elements are easily created using IMGUI. <br><br>  First you need to decide how the function signature will look.  Our element will need 3 components to fully cover the various types of events: <br><br>  ‚Ä¢ Rect, which determines the coordinates of drawing the element and reading the mouse clicks; <br>  ‚Ä¢ float, a floating variable that the color bar represents; <br>  ‚Ä¢ GUIStyle, containing the necessary information about indents, fonts, textures, etc. In our case, this will be the texture used when drawing the strip.  Next we look at this parameter in more detail. <br><br>  The function will have to return the new value of the floating number set after moving the slider.  This makes sense for mouse-related events, but not for element redraw events, so by default the function will return the value passed in the call.  In this case, calls of the form ‚Äúvalue = MyCustomSlider (... value ...)‚Äù are independent of the event, and the value of the variable remains unchanged. <br><br>  As a result, the function signature takes the following form: <br><br> <code>public static float MyCustomSlider(Rect controlRect, float value, GUIStyle style)</code> <br> <br>  We proceed to the implementation of the function.  First of all, we need to get the control ID that will be used when reacting to mouse events.  At the same time, even if the current event does not interest us, it still needs to request an identifier so that it is not assigned to another element in the context of this event, since the IMGUI assigns identifiers in the order in which requests are received.  To avoid problems with the use of different identifiers for the same element in the context of different events, it is necessary to request them for all types of events (or not to ask for one if the element is not interactive, but this is not our case). <br><br><pre> <code class="cs hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> controlID = GUIUtility.GetControlID (FocusType.Passive);</code> </pre><br><br>  The FocusType.Passive parameter defines the role of the element in keyboard navigation.  Passive means that our bar does not respond to keyboard input.  Otherwise, Native or Keyboard is used.  More information about the <a href="http://docs.unity3d.com/ScriptReference/FocusType.html">FocusType</a> parameter can be found in the corresponding documentation. <br><br>  Now we use the branch statement to separate the code needed for the different types of events.  Instead of using Event.current.type directly, we will use <a href="http://docs.unity3d.com/ScriptReference/Event.GetTypeForControl.html">Event.current.GetTypeForControl () to</a> give it a control ID.  In this way, we filter the event types so that, for example, a keyboard event does not refer to the wrong element.  However, this filtering is not universal, so later we will have to add additional checks. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Event.current.GetTypeForControl(controlID)) {</code> </pre><br>  So, you can start implementing behaviors for different types of events.  Let's start with drawing: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EventType.Repaint: { <span class="hljs-comment"><span class="hljs-comment">// Work out the width of the bar in pixels by lerping int pixelWidth = (int)Mathf.Lerp (1f, controlRect.width, value); // Build up the rectangle that the bar will cover // by copying the whole control rect, and then setting the width Rect targetRect = new Rect (controlRect){ width = pixelWidth }; // Tint whatever we draw to be red/green depending on value GUI.color = Color.Lerp (Color.red, Color.green, value); // Draw the texture from the GUIStyle, applying the tint GUI.DrawTexture (targetRect, style.normal.background); // Reset the tint back to white, ie untinted GUI.color = Color.white; break; }</span></span></code> </pre><br><br>  At this point one could stop and get a ready-made item for visualization of floating values ‚Äã‚Äãfrom 0 to 1 in read-only mode.  But let's continue and make it interactive. <br><br>  To make the use of the element convenient, after the slider is captured by pressing the button, you should consider only the horizontal movement of the mouse, regardless of whether the cursor remains within the bar.  In this case, you need to do the following thing: until the user releases the mouse button, its movement should not affect other elements of the interface. <br><br>  To do this, we will use the <a href="http://docs.unity3d.com/ScriptReference/GUIUtility-hotControl.html">GUIUtility.hotControl</a> variable containing the control ID that is currently interacting with the mouse.  IMGUI uses it in the GetTypeForControl () function.  If it is not zero, mouse events are filtered out (assuming that the control ID passed does not match the value of hotControl). <br>  Installing and resetting hotControl is very simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> EventType.MouseDown: { <span class="hljs-comment"><span class="hljs-comment">// If the click is actually on us... if (controlRect.Contains (Event.current.mousePosition) // ...and the click is with the left mouse button (button 0)... &amp;&amp; Event.current.button == 0) // ...then capture the mouse by setting the hotControl. GUIUtility.hotControl = controlID; break; } case EventType.MouseUp: { // If we were the hotControl, we aren't any more. if (GUIUtility.hotControl == controlID) GUIUtility.hotControl = 0; break; }</span></span></code> </pre><br><br>  Note: if any other element is hotControl (for example, GUIUtility.hotControl is non-zero and contains a different identifier), GetTypeForControl () will not return mouseUp / mouseDown, but simply ignore these events. <br>  Now you need to create code to change the floating variable while the mouse button is held down.  The easiest way is to close the branch and indicate that any event associated with the mouse and occurring while the element identifier is in hotControl (i.e. while the drag is in progress and the mouse button has not yet been released) should change the value of the variable: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Event.current.isMouse &amp;&amp; GUIUtility.hotControl == controlID) { <span class="hljs-comment"><span class="hljs-comment">// Get mouse X position relative to left edge of the control float relativeX = Event.current.mousePosition.x - controlRect.x; // Divide by control width to get a value between 0 and 1 value = Mathf.Clamp01 (relativeX / controlRect.width); // Report that the data in the GUI has changed GUI.changed = true; // Mark event as 'used' so other controls don't respond to it, and to // trigger an automatic repaint. Event.current.Use (); }</span></span></code> </pre><br><br>  The last two steps ‚Äî setting the <a href="http://docs.unity3d.com/ScriptReference/GUI-changed.html">GUI.changed</a> and calling the <a href="http://docs.unity3d.com/ScriptReference/Event.Use.html">Event.current.Use () ‚Äîare</a> especially important for correct interaction within the set of IMGUI elements.  Setting the value to TRUE for GUI.changed allows you to use the <a href="http://docs.unity3d.com/ScriptReference/EditorGUI.BeginChangeCheck.html">EditorGUI.BeginChangeCheck ()</a> and <a href="http://docs.unity3d.com/ScriptReference/EditorGUI.EndChangeCheck.html">EditorGUI.EndChangeCheck ()</a> functions to test the change in the value of a variable by user actions.  FALSE is better not to use, so as not to miss previous changes. <br><br>  Finally, our function should return the new value of the floating variable.  Most often it will be different from the previous value: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre><br><br>  MyCustomSlider is ready.  We have a simple functional element IMGUI, which can be used in custom editors, PropertyDrawers, EditorWindows, etc. But this is not all.  Next we will talk about how you can extend its functionality, for example, add the ability to multi-edit. </div><p>Source: <a href="https://habr.com/ru/post/278041/">https://habr.com/ru/post/278041/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278025/index.html">Security Week 08: Mice theft through a whistle, Blockbuster operation, Linux Mint with backdoor</a></li>
<li><a href="../278031/index.html">Problems of access control based on the access list in ECM systems (part 2)</a></li>
<li><a href="../278033/index.html">TOM.js is a special library for special cases.</a></li>
<li><a href="../278037/index.html">Handlersocket protocol in detail</a></li>
<li><a href="../278039/index.html">Again about STL</a></li>
<li><a href="../278043/index.html">The story of the endless city. On Three.js</a></li>
<li><a href="../278045/index.html">Configuring fault tolerance in 3CX Version 14</a></li>
<li><a href="../278047/index.html">jsPDF + canvas: export to PDF of a multipage table in Russian</a></li>
<li><a href="../278049/index.html">How to create your own Dependency Injection Container</a></li>
<li><a href="../278051/index.html">Patch gnupg or a pair of RSA-32768 in 106 minutes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>