<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Attempts to open a new checkers tactic or what to do with a pipe dream</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Sports game "Checkers" is one of the games of mankind, which the computer has not yet fully calculated. There is news that scientists h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Attempts to open a new checkers tactic or what to do with a pipe dream</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  Sports game "Checkers" is one of the games of mankind, which the computer has not yet fully calculated.  There is news that scientists have found a strategy in which the computer will never lose.  During my 9 years dedicated to this game, I met only one program that I could not win.  Perhaps my sports experience will make the assumption that it was a program that implements the strategy described above.  To my great surprise, it occupied only 60 MB.  Or maybe there was a well-trained neural network based on it?  But I still can not believe that it is impossible to calculate them.  There are only 10 ^ 20 positions, will my computer really not cope with such a task?  And also, is there really no tactic in which at the beginning of the game the opponent gives up the piece and find themselves in a tactical advantage ?!  Not a single debut of this I have not seen.  I'm going to check ... <br><a name="habracut"></a><br><h3>  The implementation of the algorithm for solving combinational problems </h3><br>  The first attempt was made at the end of the 2nd course.  After a qualitative study of the C language, I thought that it would not hurt to learn C ++.  After watching a large number of lectures on this language, I wanted to take up some project.  And he took up the checkers.  More subtle work with variables allowed more efficient to spend time on the miscalculation of positions.  If these actions are similar to actions with graphs, then this algorithm could be called a search in width.  Stopping the work of the algorithm was the complete passage through the graph. <br><br>  One object described the situation on the board.  In one object was stored: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Queue *pnr; <span class="hljs-comment"><span class="hljs-comment">/*pointer to next record*/</span></span> Queue *ppr; <span class="hljs-comment"><span class="hljs-comment">/*pointer to prev record*/</span></span> Map *pdb; <span class="hljs-comment"><span class="hljs-comment">/*pointer to draught board*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *action; <span class="hljs-comment"><span class="hljs-comment">/*actions of parents*/</span></span> Queue *pp; <span class="hljs-comment"><span class="hljs-comment">/*pointer to parent*/</span></span> Queue *pfc; <span class="hljs-comment"><span class="hljs-comment">/*pointer to first child*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nmd; <span class="hljs-comment"><span class="hljs-comment">/*Approval of the number of moves to a draw*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> color; };</code> </pre> <br>  Since the search algorithm was implemented in width, the data could be stored in a doubly linked sheet, where pnr and ppr are pointers implementing this collection. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  <i>pdb</i> - A pointer to the board layout. <br>  <i>action</i> - information about the progress made by the parent, in order to achieve this position.  It looked like a normal recording of moves in ‚Äúc3 ‚Äì d4‚Äù checkers when moving checkers or ‚Äúc3: e5‚Äù at a wooden house.  The variable was necessary for more accurate debugging of the situation. <br>  <i>pp</i> , <i>pfc</i> - pointers to the parent and to the first generated position.  Since  the search algorithm was implemented in width, then all generated positions in the doubly linked list were located side by side, one after the other.  Therefore, in order to save the data in the form of a tree, it is enough to store a pointer to the first child, and all other subsequent children referred to the same parent.  This algorithm allowed the parent to retrieve the results of the children, that is, to analyze the current situation, looking only at what a given move may have engendered a child. <br>  <i>nmd</i> - A number indicating how many moves are left before the game will be considered a draw.  For example, in a situation of 3 queens versus the 1st, only 15 moves are allocated for the completion of the game.  When you change the number of checkers, as well as after the formation of a checker dam, this number is recalculated. <br>  <i>color</i> - Whose turn now. </blockquote><br>  I was very afraid of stack overflow and thought that it would still be better to pass pointers to functions, so I decided to avoid direct passing an object as a parameter.  The implementation was simple: we take an element from the queue, consider it, giving rise to subsequent positions, then take the next element from the queue and so on in a circle. <br><br><h4>  Result: </h4><br><blockquote>  Viewed: 61.133 items <br>  Stored records in the queue: 264.050 positions <br>  RAM (2 GB) ended only on such data.  Such results are suitable only for short combinational problems. <br>  But this way of working with checkers positions allowed me to thoroughly debug the work of the ‚Äúcore‚Äù of the program. </blockquote><br><h3>  Transition to "version control system" </h3><br>  In the algorithm, a lot of memory was spent on saving data about the board.  Each position required to allocate a section of memory.  Moreover, how to encode the current checker layout better, I did not think: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* info about one checker */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Checkers</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: chlive live; chstatus status; }; <span class="hljs-comment"><span class="hljs-comment">/* info about position a checker */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PosCheckers</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: chcolor color; Checkers *ptrCheckers; }; <span class="hljs-comment"><span class="hljs-comment">/* battlefield */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PosCheckers coordinate[<span class="hljs-number"><span class="hljs-number">8</span></span>][<span class="hljs-number"><span class="hljs-number">8</span></span>]; };</code> </pre><br><blockquote>  <i>color</i> - Color checkers.  Black, white, or empty. <br>  <i>ptrCheckers</i> - If there are no checkers in this field, then we do not allocate memory. <br>  <i>status</i> - Lady or saber. <br>  <i>live</i> - whether checker is alive  Only in order not to cut down this checker again. </blockquote><br>  I understand that instead of coordinate [8] [8], only coordinate [8] [4] could have been dispensed with, but understanding my own code would be very badly damaged. <br><br>  In general, a lot of memory was required to maintain the position, so I decided to place the responsibility for identifying the checkers positions on the action - a record of the progress of the parent, which contained data like "c3-d4". <br><br>  Now, when we take an element from the queue, we, starting from the very beginning.  We take the initial position of the checkers and from it already on the way back, we execute the moves that attracted this child.  Thus was the placement of the checkers on the board for each element of the queue. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/854/a0b/337/854a0b3378694c75b4ac9e983dc0a267.png"></div><br><h4>  Result: </h4><br><blockquote>  Viewed: 1.845.265 items <br>  Stored records in the queue: 8.209.054 positions </blockquote><br><br><h3>  Rejection of the ‚Äúversion control system‚Äù;  go to depth search </h3><br>  Unfortunately, the search in width had at least some significant problems: Sometimes he created the same constellations.  And to recognize, already created party, at a large amount of data, it was laborious.  It was also not clear what to do when we did not have enough memory.  All the stored data was necessary to restore the ideological chain, so that if necessary, "scoop" from somewhere in the memory, it did not turn out. <br><br>  The search ‚Äúin depth‚Äù made it possible to move from problems of a local character (solutions of combinational problems) to global ones (miscalculation of the whole batch).  This algorithm considers the current arrangement of checkers, giving rise to descendants, selects the first of them and assigns it to the current role.  If there are no descendants, then we indicate that we have lost in this position and are moving on to considering the next placement with the parent. <br><br>  Also in order not to calculate repeated positions in the presence of ladies, it was decided to look through all the positions of the parents.  If there is one, I do not consider it, but turn to the next one. <br><br>  It was decided to remove the great-grandchildren from the memory of the constellation, in which the result was known.  Thereby it was possible to avoid its overflow.  If overflow does not occur when searching for the deepest element. <br><br>  It was also decided to add a new way of storing a position - a list of figures: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListCheckers</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ListCheckers *pnr; chcolor color; chstatus status; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x,y; <span class="hljs-comment"><span class="hljs-comment">/* coordinate */</span></span> };</code> </pre><br>  With the help of it, we began to more quickly find the possibility of a felling, as well as sort out checkers to check the possibility of a move.  Now our ‚Äúposition‚Äù object stored in the queue had the following fields: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ListCheckers *plch; <span class="hljs-comment"><span class="hljs-comment">/*pointer to list of checkers*/</span></span> ListChilds *pcs; <span class="hljs-comment"><span class="hljs-comment">/*pointer to list of childs*/</span></span> chcolor color; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> draw; chresult result; };</code> </pre><br>  I did not expect that the <b>free</b> command <b>does not guarantee 100% memory freeing</b> .  When debugging, it turned out that after executing the free command, the memory was not released at all.  Somewhere in the darkness of the forums, I learned that free only gives the OS instructions for freeing memory, and the OS itself decides whether to free memory or not.  In general, the OS I was ‚Äúgreedy,‚Äù so I had to work with memory differently.  I allocated memory as needed to hold the chain of the first "children."  And instead of deleting the ‚Äúfirst‚Äù child we reviewed, the data about him was overwritten with the data about the next child. <br><br>  To this end, an element was developed responsible for dynamic work with memory: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainQueue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MainQueue* parent; <span class="hljs-comment"><span class="hljs-comment">/*pointer to parent's record*/</span></span> MainQueue* next_record; <span class="hljs-comment"><span class="hljs-comment">/*pointer to child's record*/</span></span> Queue* now; <span class="hljs-comment"><span class="hljs-comment">/*pointer to record on data with position*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> draw; };</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ec5/2b8/0fe/ec52b80fe2834483ac0efd53bc63b099.png"></div><br><h4>  Result: </h4><br><blockquote>  For 1 day of continuous work: <br>  created was 2.040.963 batches <br>  seen was 1.241.938 lots <br>  Occupied space on RAM: 1.378 MB </blockquote><br><br><h3>  Work with files </h3><br>  Unfortunately, with such a choice of the next element we would have ‚Äúhung up‚Äù for a long time with identical positions.  Especially when miscalculations for the ladies.  Therefore, I wanted to implement a database where the results of already viewed positions would be stored.  Therefore, I decided to store data about each batch. <br><br>  Avoiding memory problems, I ran into her again.  Since I did not have enough RAM, I decided to use external media.  I recorded all positions in the index.txt and queue.txt file.  In queue.txt I kept data about each batch.  And in index.txt - the batch ID and the location of information about this batch in queue.txt, that is, the offset.  I wanted to compress the data, but leave it in a readable form.  Because I thought that the finish was still far away.  Therefore, I saved the data in the following form: <br><br><pre> <code class="hljs pgsql">queue.txt : aaaaeaaaaacaaaaa aaaaeaaaaaakaaaa <span class="hljs-number"><span class="hljs-number">50</span></span> U Aaaaaaeaaacaaaaa Aaaaaaauaacaaaaa <span class="hljs-number"><span class="hljs-number">49</span></span> U aaaaaaeakaaaaaaa aaaaaaeacaaaaaaa <span class="hljs-number"><span class="hljs-number">48</span></span> W Aaaaaaaaaauaaaaa <span class="hljs-number"><span class="hljs-number">47</span></span> L ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.txt : Aaaaeaaaaaaacaaa000000000000000000000 aaaaeaaaaacaaaaa000000000000000000040 aaaaeaaaaaakaaaa<span class="hljs-comment"><span class="hljs-comment">--------------------- Aaaaaaeaaacaaaaa000000000000000000080 Aaaaaaauaacaaaaa000000000000000000178 ‚Ä¶</span></span></code> </pre> <br>  On the board, a game cell can take 5 states: white / black checker, white / black woman, or empty.  This means that the two cells will have 25 states in various combinations.  Note that in the Latin alphabet there are 26 letters and it is quite suitable in order to describe the state of 2 playing cells at once in one letter.  This means that the entire board with 32 game cells can be described by 16 letters of the Latin alphabet, which have a more or less readable form.  It is also necessary to keep whose turn in this position.  Then, if the first letter is capitalized, then the move is now black.  We also need to remember the number of moves from the current placement, before making a positional draw.  And also the result: W-win, L-lose, D-draw, U-unknown.  And debugging did not become more difficult. <br><br><h4>  Result: </h4><br>  For two hours, the program required only 4 MB of RAM, but the parties calculated very little.  In queue.txt there were 2918 records and was equal to 401 KB.  The index.txt file contained 6095 entries and weighed 232 KB.  At this rate, it will turn out to calculate only 500 million = 5 * 10 ^ 8 positions and my 1TB disk reported that it does not have enough memory.  Yes, and it will happen very, very not soon.  My calculated positions will have little effect on the game as a whole. <br><br><h3>  Data compression </h3><br>  I was able to come up with only 3 options for promoting the project: <br><br><ol><li>  5 ^ 32 - various arrangements of figures, <br>  2 * 5 ^ 32 - considering whose move <br>  2 * (2 * 5 ^ 32) - the maximum amount of occupied space is ~ <u>9.32 * 10 ^ 22 bits</u> , provided that it is sufficient for each arrangement to indicate the result equal to 2 bits. <br>  Moreover, in the normal party there are 5 * 10 ^ 20 different positions. <br>  So, about 2 * (2 * 5 * 10 ^ 20) = 2 * 10 ^ 21 bits will be informational, and the rest ~ (9.12 * 10 ^ 21) will mean that such an arrangement of checkers does not exist in this game. <br><br>  There is 1TB = <u>8 * 10 ^ 12 bits available</u> <br>  It is necessary to develop a compression algorithm for this task, while maintaining fast data indexing. <br><br></li><li>  In a normal game there are 5 * 10 ^ 20 different positions. <br>  For quick indexing, we will keep its ‚Äúchildren‚Äù at each position, as well as the result.  On average, a position has about Y descendants. <br><br>  Encode the "links" to descendants in X bits, and the result in 2 bits, as well as the separator between entries in Z. We get (X * Y + 2 + Z) bits for each position.  Total <u>(X * Y + 2 + Z) * ‚Äã‚Äã5 * 10 ^ 20 bits</u> required to allocate to store all the positions used in the initial arrangement. <br><br>  There is 1TB = <u>8 * 10 ^ 12 bits available</u> <br>  It is necessary to develop a compression algorithm for this task, while maintaining fast data indexing. <br><br></li><li>  Let's try to find repetitive patterns in the records and implement the replacement of repeats for shorter records.  Ideologically, the algorithm is similar to the Huffman code. <br><br>  Negative impact on not so fast indexing. <br></li></ol><br>  Total need to compress data c ‚âà 10 ^ 22 to 10 ^ 13 bits.  So, it was necessary to write an algorithm that would allow compressing the data by only 99.9999999914163%.  I doubt that any algorithm is capable of it, and without taking into account that it is necessary to maintain fast indexing. <br><br><h4>  Result: </h4><br>  Saving any data on all batches <u>is</u> not applicable <u>at</u> all. <br><br><h3>  Return to the project only on RAM.  Creating a "processor" </h3><br>  It was customary to store data that was stored in files in RAM.  To this end, it was decided to change the data storage structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_strings</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: list_strings* next; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* data; list_strings() { data = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">17</span></span>]; data[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; next = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ListCheckers *plch; <span class="hljs-comment"><span class="hljs-comment">/*pointer to list of checkers*/</span></span> list_strings *pcs; <span class="hljs-comment"><span class="hljs-comment">/*list of data of childs*/</span></span> chcolor color; chresult result; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to_draw; }</code> </pre><br>  And also changed the principle of storage of the object Queue.  After the MainQueue was overwritten, the Queue object pointed to by the MainQueue is also overwritten. <br><br>  The ‚Äúpcs‚Äù field for storing ‚Äúchildren‚Äù is now implemented as a single-linked list with data of the ‚ÄúAaaaaaaaacaaaaa‚Äù type, expanding as necessary.  In order to use the allocated memory repeatedly (when overwriting) the fields with data became equal to '\ 0' - zero, to indicate that the fields do not contain important information.  Since  The ‚Äúobject‚Äù has changed. <br><br><h4>  Result: </h4><br>  Maximum space occupied on RAM: 844 KB.  Run at 7 o'clock allowed to see 8.865.798.818 positions.  But, positions can be repeated.  These results are not sufficient to achieve a complete miscalculation of the party for an acceptable execution time. <br><br>  Now we can say that there is a ‚Äúprocessor‚Äù that will grind the positions and it will only need 844 KB of RAM, which means that the remaining memory can be spent usefully, for example, to implement ‚Äúcache memory‚Äù in order not to calculate the positions that have already been calculated . <br><br><h3>  Creation of "cache memory" </h3><br>  For the fastest possible sampling of data from memory, a hash table was selected that populates the maximum possible memory space.  As the hash function, the last numbers of the md5 algorithm were selected, at the input of which the coded position described was fed.  That is, the position ‚ÄúAaauaueaaacckaaa‚Äù with md5 <u>0237d0d0b76bcb8872ecc05a455e5dcf</u> will be stored at: f * 2 ^ 12 + c * 2 ^ 8 + d * 2 ^ 4 + 5 = 15 * 4096 + 12 * 256 + 13 * 16 + 5 = 64725. <br><br>  The unit for storing an entry in a hash table was a cell.  This approach allows you to delete data from ‚Äúobsolete‚Äù cells and reuse their space.  "Obsolescence" is implemented using a ring buffer: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/330/c67/b1b/330c67b1b6634609911a48bcdafc2712.png"></div><br>  At the first address in the cache-memory cells ‚Ññ 1 and ‚Ññ 5 are stored, in the second ‚Ññ 3 ... And in the circular buffer the cells are stored in chronological order.  If we could keep a maximum of 5 cells, then the cell from No. 1 would be ‚Äúpulled out‚Äù from the place where it is now and placed in the place of the 6th cell.  Moreover, now only the number 5 cell will be stored in the cache memory at the first address. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mem_cel</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: mem_cel* pnhc; <span class="hljs-comment"><span class="hljs-comment">/* pointer to next in hash collection */</span></span> mem_cel* pphc; <span class="hljs-comment"><span class="hljs-comment">/* pointer to prev in hash collection */</span></span> mem_cel* pnrb; <span class="hljs-comment"><span class="hljs-comment">/* pointer to next "mem_cel" record in ring buffer */</span></span> mem_cel* pprb; <span class="hljs-comment"><span class="hljs-comment">/* pointer to prev "mem_cel" record in ring buffer */</span></span> chresult result; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> draw; stringMap condition; };</code> </pre><br>  The condition field is necessary to identify the desired checker placement, because different arrangements can be stored at the same cache address. <br><br>  The <i>draw</i> field is required to determine if the query matches.  If there is a drawable result of a position in memory, for which only 3 moves were allocated, then if there are more moves, you can either win or lose. <br><br><h4>  Result: </h4><br>  Run for 1 hour allowed to see 10.400.590 positions.  It is necessary to realize something, allowing to accelerate the given miscalculation.  But, if you make calculations, then my computer, at best, will calculate 10 ^ 20 positions in the current: 10 ^ 20 / 10.400.590 = 9.6 * 10 ^ 12 hours = 4 * 10 ^ 11 days. <br><br>  Let's see which piece of code is ‚Äúnarrow neck‚Äù.  For this purpose, I used the OProfile profiler: <br><br><img src="https://habrastorage.org/files/e97/017/477/e97017477d444cc9b95a5c3a30c1a79c.png"><br><br>  one. <br><pre> <code class="cpp hljs">Queue::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(Queue)</code> </pre> <br>  Check the difference of elements of the queue  Called when a new item is added to the queue to check for a triple repetition of a position.  The check is performed with all elements that led to the current position. <br><br>  Optimization: When changing the number of pieces on the board or their status, mark.  In order with the positions that have a different set of shapes, do not produce a check. <br><br>  2 <br><pre> <code class="cpp hljs">code_string(PosCheckers*)</code> </pre> <br>  Used to convert a checkpoint element to a letter.  Required for the Board_to_String function (Map *, char *, chcolor). <br><br>  Optimization: First, reduce the number of calls to the Board_to_String function (Map *, char *, chcolor) <br><br>  3 <br><pre> <code class="cpp hljs">String_to_Lcheckers(stringMap, ListCheckers**, chcolor*)</code> </pre> <br>  four. <br><pre> <code class="cpp hljs">Board_to_String(Map*, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*, chcolor)</code> </pre> <br>  Called often enough.  So it is necessary to reduce the number of calls to them. <br>  String_to_Lcheckers is needed to convert text into a collection of checker data. <br>  Board_to_String is required to translate a position into text that can be stored in an OP. <br><br>  Optimization: Since in order to represent the same position on the board I need to work with three data structures: <br><br>  <i>Lcheckers</i> - a list of checkers on the field.  Required for quick selection of checkers to view the possibility of a move.  Map or ‚ÄúBoard‚Äù - array [8] [8].  Contains a complete balance of power. <br>  stringMap or ‚ÄúString‚Äù is a string for storing data.  It means that you need to reduce the number of conversions from one data view to another, or try to reduce the number of data structures. <br><br><h3>  Magic bitBoards </h3><br>  Unexpectedly, I found a solution for habrahabr: <a href="https://habrahabr.ru/post/272815/">Magic beatboards and Russian checkers</a> .  In which the author of the article proposes to encode information about the board with the help of 4 32-bit words. <br><br>  The words: <br><br>  1) the positions of all the figures in white <br>  2) positions of all black pieces <br>  3) white drafts positions <br>  4) the position of the black pieces <br><br>  Moreover, the positions of the figures are numbered as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/663/6f8/613/6636f861388e43cab8adecea1c0940e4.png"></div><br>  Now, to clarify the possibility of cutting at least one checker, it is enough to move the position of all checkers in the appropriate direction: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bitboard_t</span></span> try_left_up = ((((checkers &amp; possible_left_up) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; enemy) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; empty;</code> </pre><br>  Thereby accelerating the search for opportunities, as a felling, and a simple move.  To my great regret, I did not understand the author of this article, how he decided to work with the woman.  I currently have not beautiful for, which, of course, should be corrected in the future. <br><br>  Thus, it is possible to replace the 3 data structures described above with one: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bitboard_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bitboard_t</span></span> bbMap[<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre><br>  Also, this change allowed not to use md5 to find the number in the hash-table.  This mission was assigned to this formula: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HASH_NUM 0xFFFFFF hash_num = ((bbMap[0] ^ ~bbMap[1]) ^ ReverseBits(~bbMap[2] ^ bbMap[3])) &amp; HASH_NUM;</span></span></code> </pre><br>  Where <i>ReverseBits</i> is a reversal of bits.  Example: there was a number 0x80E0, it became 0x0701. <br><br><h4>  Result: </h4><br>  The launch for 1 hour allowed to view 15.140.000 positions, which is undoubtedly better.  But this is still not enough for a complete miscalculation. <br><div class="spoiler">  <b class="spoiler_title">Fixed bug</b> <div class="spoiler_text">  Earlier, I indicated 754.000.000 positions per hour.  A shameful typo in the code ... <br></div></div><br><br>  I believe that the project algorithm is implemented.  Therefore, you can focus on speeding up the functions. <br><br><h3>  Acceleration of functions </h3><br>  Having read of the likely / unlikely I decided to test its ‚Äúacceleration‚Äù of the code.  In general, likely / unlikely indicates which instructions should be loaded by the processor during the execution of an if statement.  Either those that are after then, or after else.  When an unsuccessful choice of instructions, for example then, the processor is idle, waiting for the instructions specified after else.  Under the MS compiler, this instruction is called __assume. <br><br>  Having implemented each if in this way, I decided to test: <br><br><pre> <code class="cpp hljs">__assume(selected == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (selected != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> selected; }</code> </pre><br><h4>  Result: </h4><br>  To my great surprise, the code has really sped up a lot.  During the first hour, 16,750.000 positions were calculated. <br><br>  I did not dare to implement assembler inserts.  My code becomes immediately unreadable, and this is an important aspect for me.  Since the breaks in the project, I sometimes reached several months. <br><br><h3>  The limiter of the number of counted moves into the depths </h3><br>  Unfortunately, it can be called this: over time, I really realized that it‚Äôs still impossible to calculate all the positions.  Therefore, I added a move limiter with a result function: <br>  checker = +1 point, lady = +3 points.  I am aware that this approach is not entirely correct, but for the most part it will produce valid values.  So I decided to stop there. <br><br><h4>  Result: </h4><br>  I went back to where I started.  With a limiter on the number of counted moves, my program is currently a program for solving combinational problems.  But it's not scary, the limiter can be postponed. <br><br><h3>  Overall result: </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first hour, ‚âà17 million positions are calculated.</font></font><br>  What to do next?  Unclear.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use CUDA, parallelize the calculations ... But I don‚Äôt think that with this you can achieve a calculation of at least 50 moves for each player on one computer. You would have to know how many positions you have to go through ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is necessary to change the algorithm ... How? There are no ideas ... Can use advertised neural networks? I do not think that the neural network will appreciate the loss of checkers at the beginning of the game. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far I will wait for the coming time of the appearance / cheapening of faster computers. Perhaps, then, more advanced technologies in code acceleration will appear. And while I'm going to study neural networks, maybe I'm wrong and they will be at the head of the computational algorithm ... We will live and see. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some data: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maximum depth of rendering - The number of viewed positions </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 - 7</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 - 56 (We make White's first move. Then we generate 7 new positions for black. We look at each of them, make sure we don‚Äôt need to calculate further. We make the second move of White ... 7 + 7 * 7) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 - 267 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 - 1017 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 - 3570 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 - 11 460 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 - 34 455 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 - 95 921 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9 - 265 026 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 - 699 718 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11 - 1 793 576 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12 - 4 352 835 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13 - 10 571 175</font></font></div><p>Source: <a href="https://habr.com/ru/post/318210/">https://habr.com/ru/post/318210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318198/index.html">Excel Almighty and Redmine: how to generate tasks right in Excel</a></li>
<li><a href="../318200/index.html">Mobile bank for iOS: add block architecture to Cocoa MVC</a></li>
<li><a href="../318202/index.html">Modification of stock firmware for Android. Part 5. Revolution c Xposed Framework</a></li>
<li><a href="../318204/index.html">How I translated the BEM project ... and translated</a></li>
<li><a href="../318208/index.html">12 more big data cases</a></li>
<li><a href="../318212/index.html">Secrets of a successful update: interface, backend, application structure</a></li>
<li><a href="../318214/index.html">5 really free non-linear video editors for Windows</a></li>
<li><a href="../318216/index.html">DevOps - speed? Yes speed</a></li>
<li><a href="../318218/index.html">From Intranet to Digital Workplace</a></li>
<li><a href="../318220/index.html">SetGoroutineName</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>