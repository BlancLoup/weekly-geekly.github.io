<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Office lighting control over Wi-Fi. Part 3: Driving the Light</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will finally complete this cycle by connecting the knowledge and developments gained in the first and second parts: we will manage office lig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Office lighting control over Wi-Fi. Part 3: Driving the Light</h1><div class="post__text post__text-html js-mediator-article"><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/D8Yhl1LRSsE%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgPJvjqRWGeiSDmtuTrrr0O4wUUqA" frameborder="0" allowfullscreen=""></iframe><br><br>  Today we will finally complete this cycle by connecting the knowledge and developments gained in the <a href="https://habrahabr.ru/company/rainbow/blog/275359/">first</a> and <a href="https://habrahabr.ru/company/rainbow/blog/275361/">second</a> parts: we will manage office lights using touch-sensitive buttons via Wi-Fi using the ModBus TCP protocol via the ModBus-DALI gateway. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Summary of the previous series</b> <div class="spoiler_text">  We learned using the Atmel WINC1500 Wi-Fi module, connects to a third-party access point, and also connect as a client to a TCP server and transfer data to it.  The work with touch buttons and sliders was also mastered, and the corresponding video was captured. <br></div></div><br>  Recall the overall concept.  The <a href="http://www.atmel.com/tools/ATSAMD21-XPRO.aspx%3Ftab%3Doverview">Atmel SAMD21</a> microcontroller is connected to debugging with a Q-touch expansion board, on which there are three buttons, a slider and a rotor.  We will use one button to turn on the lights, another to turn off and a slider to smoothly adjust the brightness.  A board with a WINC1500 module is connected to the second port.  Our device (or rather, the prototype) will act as a TCP client.  The <a href="http://ecodim.ru/produkciya/dali/kontrollery/dali-gw1/">server</a> will be the <a href="http://ecodim.ru/produkciya/dali/kontrollery/dali-gw1/">DALIGW1</a> - ModBus TCP device, which converts ModBus commands into <a href="https://ru.wikipedia.org/wiki/DALI">DALI</a> (Digital Addressable Lighting Interface) protocol commands - a special protocol for digital lighting control.  Thus, we will receive the position values ‚Äã‚Äãof the sensors and form requests in accordance with the Modbus protocol and send via Wi-fi to the gateway. <br><br><h5>  TCP client </h5><br>  For simplicity, we will not create an access point, scan available networks and ask the user to connect to one of them, but specify the necessary settings for our office LAN directly in the code. <br>  At the beginning of work, you can open one of the projects created earlier (according to previous parts of the article) or a sample project for Qtouch or WINC1500, and add the necessary modules using Wizard, as described in one of our previous articles. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Configure the network settings in the <b>main.h</b> file: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_WLAN_SSID </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Habrahabr"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   #define MAIN_WLAN_AUTH M2M_WIFI_SEC_WPA_PSK //   #define MAIN_WLAN_PSK "123456789" //    #define MAIN_WIFI_M2M_PRODUCT_NAME "Hello world!\n\r" #define MAIN_WIFI_M2M_SERVER_IP 0xc0a81490 // IP   () #define MAIN_WIFI_M2M_SERVER_PORT (502) //  .  502  ModBus TCP</span></span></span></span></code> </pre> <br><br>  In <b>main.c, we</b> set up a library to work with winc1500 in tcp client mode. <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//Initialize the BSP. nm_bsp_init(); // Initialize socket address structure. addr.sin_family = AF_INET; addr.sin_port = _htons(MAIN_WIFI_M2M_SERVER_PORT); addr.sin_addr.s_addr = _htonl(MAIN_WIFI_M2M_SERVER_IP); // Initialize Wi-Fi parameters structure. memset((uint8_t *)¬∂m, 0, sizeof(tstrWifiInitParam)); // Initialize Wi-Fi driver with data and status callbacks. param.pfAppWifiCb = wifi_cb; ret = m2m_wifi_init(¬∂m); if (M2M_SUCCESS != ret) { printf("main: m2m_wifi_init call error!(%d)\r\n", ret); while (1); } // Initialize socket module socketInit(); registerSocketCallback(socket_cb, NULL); // Connect to router. m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);</span></span></code> </pre><br><br>  Do not forget about our favorite callbacks.  We register functions of event handling on a network. <br><div class="spoiler">  <b class="spoiler_title">Callback code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socket_cb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SOCKET sock, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> u8Msg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pvMsg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (u8Msg) { <span class="hljs-comment"><span class="hljs-comment">// Socket connected case SOCKET_MSG_CONNECT: { tstrSocketConnectMsg *pstrConnect = (tstrSocketConnectMsg *)pvMsg; if (pstrConnect &amp;&amp; pstrConnect-&gt;s8Error &gt;= 0) { printf("socket_cb: connect success!\r\n"); if (button_pressed!=0) { send(tcp_client_socket, &amp;data_to_send, 12, 0); printf("socket_number after connection: %d\r\n", tcp_client_socket); } close(tcp_client_socket); delay_ms(50); } else { printf("socket_cb: connect error!\r\n"); close(tcp_client_socket); tcp_client_socket = -1; } } break; // Message send case SOCKET_MSG_SEND: { printf("socket_cb: send success!\r\n"); recv(tcp_client_socket, gau8SocketTestBuffer, sizeof(gau8SocketTestBuffer), 0); } break; // Message receive case SOCKET_MSG_RECV: { tstrSocketRecvMsg *pstrRecv = (tstrSocketRecvMsg *)pvMsg; if (pstrRecv &amp;&amp; pstrRecv-&gt;s16BufferSize &gt; 0) { printf("socket_cb: recv success!\r\n"); printf("TCP Client Test Complete!\r\n"); } else { printf("socket_cb: recv error!\r\n"); close(tcp_client_socket); tcp_client_socket = -1; } } break; default: break; } } static void wifi_cb(uint8_t u8MsgType, void *pvMsg) { printf("wifi_cb: u8MsgType= %d\n",u8MsgType); switch (u8MsgType) { case M2M_WIFI_RESP_CON_STATE_CHANGED: { tstrM2mWifiStateChanged *pstrWifiState = (tstrM2mWifiStateChanged *)pvMsg; if (pstrWifiState-&gt;u8CurrState == M2M_WIFI_CONNECTED) { printf("wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: CONNECTED\r\n"); m2m_wifi_request_dhcp_client(); } else { if (pstrWifiState-&gt;u8CurrState == M2M_WIFI_DISCONNECTED) { printf("wifi_cb: M2M_WIFI_RESP_CON_STATE_CHANGED: DISCONNECTED\r\n"); wifi_connected = 0; m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL); } } break; } case M2M_WIFI_REQ_DHCP_CONF: { uint8_t *pu8IPAddress = (uint8_t *)pvMsg; wifi_connected = 1; printf("wifi_cb: M2M_WIFI_REQ_DHCP_CONF: IP is %u.%u.%u.%u\r\n", pu8IPAddress[0], pu8IPAddress[1], pu8IPAddress[2], pu8IPAddress[3]); printf("wifi_cb: M2M_WIFI_REQ_DHCP_CONF: getaway IP is %u.%u.%u.%u\r\n", pu8IPAddress[4], pu8IPAddress[5], pu8IPAddress[6], pu8IPAddress[7]); printf("wifi_cb: M2M_WIFI_REQ_DHCP_CONF: DNS IP is %u.%u.%u.%u\r\n", pu8IPAddress[8], pu8IPAddress[9], pu8IPAddress[10], pu8IPAddress[11]); printf("wifi_cb: M2M_WIFI_REQ_DHCP_CONF: mask is %u.%u.%u.%u\r\n", pu8IPAddress[12], pu8IPAddress[13], pu8IPAddress[14], pu8IPAddress[15]); break; } default: break; } }</span></span></code> </pre><br></div></div><br><br>  In practice, this is all the code needed to work with winc as a client tcp. <br><br><h5>  Qtouch </h5><br>  All the code described in the second part of our article for handling buttons and slider is completely transferred, you just need to add the formation and sending of the tcp parcels. <br><br><h5>  Putting it all together </h5><br>  The ModBus protocol is simple, open and passionately loved in automation systems, so you can find lots of information about it on the Internet.  That's what the <a href="https://ru.wikipedia.org/wiki/Modbus">wiki</a> says.  We, as already mentioned, will use its TCP modification designed for operation in local networks. <br>  Since we have a training task, we will not implement the beautiful ModBus library (through separate functions, indicating the register, data, etc.), but simply form the corresponding set of bytes and send them to an open socket.  In our case, the Modbus package will change only in the part of the data recorded in the register (in accordance with the protocol of work with our gateway).  Use the write command in one register - command code 0x06. <br>  Package Fields: <br><ul><li>  Transaction ID, Protocol ID as per Modbus specification </li><li>  length = 6 </li><li>  Unit ID as per Modbus specification </li><li>  command code 0x06 </li><li>  register number 25 (0x0019) </li><li>  register value: DALI command code, luminaire / luminaire address and command data (depending on command type). </li></ul><br>  The purpose of this article was not to immerse the reader into the specifics of the DALI protocol, therefore I will simply list the commands used with a brief explanation: <br><ul><li>  OFF - immediately turn off the specified lamp, hang it on the left touch button </li><li>  RECALL MAX LEVEL - smoothly set the maximum brightness of the lamp, right button </li><li>  ON AND STEP UP - if the lamp is off, set the minimum brightness.  will call before RECALL MAX LEVEL </li><li>  DIRECT ARC POWER X- smoothly set the specified brightness X for the luminaire, hang it on the slider </li></ul><br>  <i>Note: ‚Äúscientists argue‚Äù about how correctly the ModBus master (which is our debugging role) to communicate with the slaves - close the socket after the end of the current communication session or keep it open.</i>  <i>In our example, we went the first way, assuming that other masters may also be on the bus who wish to connect to our gateway.</i>  <i>But there‚Äôs probably no right approach, and it all depends on the developer‚Äôs worldview.</i> <br><br>  That's all.  The final part came out not particularly voluminous, but the whole main stuffing was in the first two parts.  I hope it was interesting. <br><div class="spoiler">  <b class="spoiler_title">Summary code main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> button1_state; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> button2_state; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> slider_state; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> slider_position; tstrWifiInitParam param; <span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> ret; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// Initialize and configure system and generic clocks. // Use conf_clocks.h to configure system and generic clocks. system_init(); // Enable global interrupts. system_interrupt_enable_global(); //Initialize delay service. delay_init(); //Initialize timer. (RTC actually) timer_init(); //Initialize QTouch library and configure touch sensors. touch_sensors_init(); // Configure port pins configure_port_pins(); // Turn off all extension board LEDs port_pin_set_output_level(LED_0_PIN, 1); port_pin_set_output_level(LED_1_PIN, 1); port_pin_set_output_level(LED_2_PIN, 1); port_pin_set_output_level(LED_3_PIN, 1); port_pin_set_output_level(LED_4_PIN, 1); port_pin_set_output_level(LED_5_PIN, 1); port_pin_set_output_level(LED_6_PIN, 1); port_pin_set_output_level(LED_7_PIN, 1); port_pin_set_output_level(LED_8_PIN, 1); port_pin_set_output_level(LED_9_PIN, 1); port_pin_set_output_level(LED_R_PIN, 1); port_pin_set_output_level(LED_G_PIN, 1); port_pin_set_output_level(LED_B_PIN, 1); PWM_Count = 0; NVMCTRL-&gt;CTRLB.bit.SLEEPPRM = 3; system_set_sleepmode(SYSTEM_SLEEPMODE_STANDBY); // Initialize the UART console. configure_console(); printf(STRING_HEADER); //Initialize the BSP. nm_bsp_init(); // Initialize socket address structure. addr.sin_family = AF_INET; addr.sin_port = _htons(MAIN_WIFI_M2M_SERVER_PORT); addr.sin_addr.s_addr = _htonl(MAIN_WIFI_M2M_SERVER_IP); // Initialize Wi-Fi parameters structure. memset((uint8_t *)¬∂m, 0, sizeof(tstrWifiInitParam)); // Initialize Wi-Fi driver with data and status callbacks. param.pfAppWifiCb = wifi_cb; ret = m2m_wifi_init(¬∂m); if (M2M_SUCCESS != ret) { printf("main: m2m_wifi_init call error!(%d)\r\n", ret); while (1); } // Initialize socket module socketInit(); registerSocketCallback(socket_cb, NULL); // Connect to router. m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL); while (1) { // Goto STANDBY sleep mode, unless woken by timer or PTC interrupt. system_sleep(); // Start touch sensor measurement, if touch_time.time_to_measure_touch flag is set by timer. touch_sensors_measure(); if (measure_tick&lt;INACTIVITY_DELAY) { measure_tick++; } if ((p_mutlcap_measure_data-&gt;measurement_done_touch == 1u)) { p_mutlcap_measure_data-&gt;measurement_done_touch = 0u; // Get touch sensor states button1_state = GET_MUTLCAP_SENSOR_STATE(0); button2_state = GET_MUTLCAP_SENSOR_STATE(1); rotor_state = GET_MUTLCAP_SENSOR_STATE(2); slider_state = GET_MUTLCAP_SENSOR_STATE(3); if (button1_state) { if(button_pressed!=1) { port_pin_set_output_level(LED_8_PIN, 0); button_pressed=1; form_modbus_packet(0x05,DALI_OFF ); tcp_client_socket = socket(AF_INET, SOCK_STREAM, 0); ret=connect(tcp_client_socket, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_in)); } } else { port_pin_set_output_level(LED_8_PIN, 1); if (button_pressed==1) { button_pressed=0; } } if (button2_state) { if(button_pressed!=2) { port_pin_set_output_level(LED_9_PIN, 0); button_pressed=2; form_modbus_packet(0x05,DALI_RECALL_MAX_LEVEL); tcp_client_socket = socket(AF_INET, SOCK_STREAM, 0); ret=connect(tcp_client_socket, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_in)); } } else { port_pin_set_output_level(LED_9_PIN, 1); if (button_pressed==2) { button_pressed=0; } } // Clear all slider controlled LEDs port_pin_set_output_level(LED_0_PIN, 1); port_pin_set_output_level(LED_1_PIN, 1); port_pin_set_output_level(LED_2_PIN, 1); port_pin_set_output_level(LED_3_PIN, 1); port_pin_set_output_level(LED_4_PIN, 1); port_pin_set_output_level(LED_5_PIN, 1); port_pin_set_output_level(LED_6_PIN, 1); port_pin_set_output_level(LED_7_PIN, 1); // If slider is activated if(slider_state) { // Parse slider position slider_position = GET_MUTLCAP_ROTOR_SLIDER_POSITION(1); // slider_position = slider_position &gt;&gt; 5u; printf("slider_position= %d\n",slider_position); if (measure_tick==INACTIVITY_DELAY) { button_pressed=4; form_modbus_packet(0x05,DALI_ON_AND_STEP_UP); tcp_client_socket = socket(AF_INET, SOCK_STREAM, 0); ret=connect(tcp_client_socket, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_in)); delay_ms(500); } else { if (button_pressed==4) { button_pressed=0; } if ((button_pressed!=3)&amp;&amp;(previous_slider_position!=slider_position)) { button_pressed=3; brightness=slider_position;//&lt;&lt;5u; if (brightness==255) { brightness=254; } printf("brightness= %d \n",brightness); form_modbus_packet(0x04,brightness); tcp_client_socket = socket(AF_INET, SOCK_STREAM, 0); ret=connect(tcp_client_socket, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_in)); previous_slider_position=slider_position; } else { if (button_pressed==3) { button_pressed=0; } } } measure_tick=0; switch(slider_position) { case 0: port_pin_set_output_level(LED_0_PIN, 0); break; case 1: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); break; case 2: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); break; case 3: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); port_pin_set_output_level(LED_3_PIN, 0); break; case 4: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); port_pin_set_output_level(LED_3_PIN, 0); port_pin_set_output_level(LED_4_PIN, 0); break; case 5: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); port_pin_set_output_level(LED_3_PIN, 0); port_pin_set_output_level(LED_4_PIN, 0); port_pin_set_output_level(LED_5_PIN, 0); break; case 6: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); port_pin_set_output_level(LED_3_PIN, 0); port_pin_set_output_level(LED_4_PIN, 0); port_pin_set_output_level(LED_5_PIN, 0); port_pin_set_output_level(LED_6_PIN, 0); break; case 7: port_pin_set_output_level(LED_0_PIN, 0); port_pin_set_output_level(LED_1_PIN, 0); port_pin_set_output_level(LED_2_PIN, 0); port_pin_set_output_level(LED_3_PIN, 0); port_pin_set_output_level(LED_4_PIN, 0); port_pin_set_output_level(LED_5_PIN, 0); port_pin_set_output_level(LED_6_PIN, 0); port_pin_set_output_level(LED_7_PIN, 0); break; default: port_pin_set_output_level(LED_0_PIN, 1); port_pin_set_output_level(LED_1_PIN, 1); port_pin_set_output_level(LED_2_PIN, 1); port_pin_set_output_level(LED_3_PIN, 1); port_pin_set_output_level(LED_4_PIN, 1); port_pin_set_output_level(LED_5_PIN, 1); port_pin_set_output_level(LED_6_PIN, 1); port_pin_set_output_level(LED_7_PIN, 1); break; } } }//measurement done flag m2m_wifi_handle_events(NULL); if (wifi_connected == M2M_WIFI_CONNECTED) { // Open client socket. if (tcp_client_socket &lt; 0) { if ((tcp_client_socket = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) { printf("main: failed to create TCP client socket error!\r\n"); continue; } // Connect server printf("socket_number new connection: %d\r\n", tcp_client_socket); ret=connect(tcp_client_socket, (struct sockaddr *)&amp;addr, sizeof(struct sockaddr_in)); printf("ret value: %d\r\n", ret); if (ret &lt; 0) { close(tcp_client_socket); tcp_client_socket = -1; } } } }//while(1) }//main</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/276007/">https://habr.com/ru/post/276007/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275995/index.html">Software licensing</a></li>
<li><a href="../275997/index.html">What's new in Windows Server 2016 RDS. Part 1</a></li>
<li><a href="../275999/index.html">Processing a temporary or permanent replacement of a 1C: Enterprise 8.2-8.3 authentication password</a></li>
<li><a href="../276003/index.html">Cach√© Class Explorer - explore Cach√© in UML notation</a></li>
<li><a href="../276005/index.html">Unsafe to Swift</a></li>
<li><a href="../276009/index.html">In Lenovo software, the immutable password was sewn 12345678</a></li>
<li><a href="../276011/index.html">Unmanaged C ++ library in .NET. Full integration</a></li>
<li><a href="../276013/index.html">Practical use of Linux Deploy on desktops</a></li>
<li><a href="../276015/index.html">HPE Proactive Care Advanced - a new service for a new type of IT</a></li>
<li><a href="../276017/index.html">Adjusted sliding exam, coclassifiers, fractal classifiers and local error probability</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>