<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Page-by-page navigation with MySQL with a large number of records</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sooner or later, many large projects face performance problems when paging through records. Some of them solve this problem by limiting the number of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Page-by-page navigation with MySQL with a large number of records</h1><div class="post__text post__text-html js-mediator-article">  Sooner or later, many large projects face performance problems when paging through records.  Some of them solve this problem by limiting the number of records available for viewing (say, no more than 1000).  It is an acceptable solution.  But in this case, there may be problems with indexing the site by third-party search engines, which pose the greatest threat.  In this article, I would like to abandon the ‚Äú1..2..3..4 ..‚Äù habitual navigation panel in favor of a simple ‚Äúforward ... backward‚Äù (it will be easier to explain), but it‚Äôs not a problem to implement this and with first option. <br>  It is not possible to define the topic more precisely, naming how many records are large enough for brakes to appear, since this figure is different for everyone and depends greatly on how fast your hard drives are, how much memory is, and how much of your data is cached in it and so on.  But if you and your servers feel that the n-page when outputting is harder than the first, and you don‚Äôt know what to do with this, the article is for you.  But for starters, I would like to explain on my fingers why IT is slow. <br><br>  By the way, the test takes place on a virtual machine, I work with the DBMS under the root, the MySQL version is 5.0.32. <br><a name="habracut"></a><br><br><h4>  1 Let's start with the data. </h4><br>  For testing, we will create a small table and fill it with something. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code>CREATE TABLE items ( <br> id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, <br> height INT UNSIGNED NOT NULL DEFAULT 0, <br> width INT UNSIGNED NOT NULL DEFAULT 0, <br> price DECIMAL(10,2) NOT NULL DEFAULT 0.0, <br> title VARCHAR(255) NOT NULL <br> ) ENGINE=InnoDB DEFAULT CHARSET=UTF8; <br></code> <br><br>  A small PHP script generated INSERT 100,000 records.  Data of this type: <br>  - field order in INSERT: <br>  height, width, price, title <br>  - template for fields: <br>  $ val_tmpl = "\ t (% d,% d,% f, 'Item% d')"; <br>  - test values ‚Äã‚Äã($ i = 1..100000): <br>  sprintf ($ val_tmpl, rand (0, 120), rand (0, 220), 10 * rand (0, $ i) / $ i, $ i); <br><br>  We bring it all in our DB.  And you can start ... <br><br><h4>  2 The usual pagination method </h4><br>  Anyone who already knows what COUNT (*) and LIMIT ... OFFSET are bad for can skip this part. <br><br>  Before drawing the navigator, we do SELECT COUNT (*) ... WHERE (selection conditions).  Many, for some reason, are sure that even if we have millions of records, but selection conditions allow us to use an index, such a query will work very quickly.  Let's do an experiment.  Select the number of records that have a height greater than 100. First, let's see what happens if there is no index across the height field. <br><br>  FLUSH STATUS; <br><br>  SELECT SQL_NO_CACHE COUNT (*) FROM items WHERE height&gt; 100; <br>  + ---------- + <br>  |  count (*) | <br>  + ---------- + <br>  |  16405 | <br>  + ---------- + <br>  1 row in set (0.09 sec) <br><br>  SHOW STATUS LIKE 'handler%'; <br><br>  The last command will show how much and what actions the DBMS had to do in order to fulfill our request.  Since we don't have an index, MySQL had to read the data directly from the table, so we are interested in the line: <br>  ... <br>  |  Handler_read_rnd_next |  100001 | <br>  ... <br><br>  That is, MySQL had to do 100001 operation to move to the next record in order to find all matching the query. <br><br>  Everywhere below, before each SELECT, FLUSH STATUS is meant to be executed, and after it: SHOW STATUS LIKE 'handler%'. <br><br>  How can the index help us? <br><br>  ALTER TABLE items ADD INDEX height_idx (height); <br><br>  SELECT SQL_NO_CACHE COUNT (*) FROM items FORCE INDEX (height_idx) WHERE height&gt; 100; <br>  + ---------- + <br>  |  count (*) | <br>  + ---------- + <br>  |  16405 | <br>  + ---------- + <br>  1 row in set (0.04 sec) <br><br>  In this case, the index was used, so Handler_read_rnd_next will be equal to 0, but <br>  ... <br>  |  Handler_read_next |  16405 | <br>  ... <br>  That is, the index allows you to initially count only those records that are needed, but he still needs to run through them all.  There is no magic, MySQL does not store anywhere the number of records matching the request.  Therefore, if you have millions of records matching the query conditions, COUNT will work very slowly. <br><br>  Second moment.  LIMIT ... OFFSET.  The same experiment.  Ask us for 5 entries. <br><br>  SELECT SQL_NO_CACHE * FROM items FORCE INDEX (height_idx) WHERE height&gt; 100 LIMIT 5; <br>  ... <br>  5 rows in set (0.00 sec) <br>  ... <br>  |  Handler_read_next |  4 | <br>  ... <br>  It seems everything is logical.  And now we will ask to return other 5 records, since 16401. <br><br>  SELECT SQL_NO_CACHE * FROM items FORCE INDEX (height_idx) WHERE height&gt; 100 LIMIT 16400, 5; <br>  ... <br>  5 rows in set (0.13 sec) <br><br>  We see that the sampling time has increased significantly.  We look at the status: <br>  ... <br>  |  Handler_read_next |  16404 | <br>  ... <br>  That is, MySQL, read all 16405, and only then just threw away all unnecessary. <br>  How to be? <br><br><h4>  3 How to be </h4><br>  So.  We are required to display 10 entries, as well as draw a navigation menu.  We realized that in order to get to the record with which we must begin to give us the results, MySQL spends a lot of unnecessary actions.  The only way to avoid it is to go directly to the desired one by changing the sampling conditions. <br>  Consider everything on a simple example: let the records be issued sorted by id.  In this case, we need, together with the link, to transfer the id of the record where we stopped.  And we will stop on record with id = 10.  That is, in the parameters of the link to the next page, we need to pass 10. Accordingly, for the second page, the request will look like this: <br><br>  SELECT SQL_NO_CACHE id FROM items WHERE id&gt; 10 ORDER BY id LIMIT 10; <br><br>  By the way, in both cases, Handler_read_next will be equal to 9. That is, we jumped to the first entry corresponding to the request (thanks to the index) and made 9 transitions to the next.  The most important thing is that whatever number instead of 10 we put in the condition - we will always see the same thing as a result of SHOW STATUS, and the execution time of such a query will no longer depend on where we are, but will depend only on how much and what we choose. <br>  I hope you understand the meaning.  Let's then decide what to do with the navigation menu, and then move on to a more difficult situation.  Let us use the keywords next, previous, and last in url.  When do I show links ‚Äúforward‚Äù, ‚Äúbackward‚Äù and ‚Äúlast‚Äù? <br>  Every time when we receive next (request for the next page), we choose not 10 entries, but 11, starting with the id transmitted in the request parameters.  If we returned 11 entries, then we should show the link forward with the id of the 10th entry, and the 11th fold.  If less than 11 entries are returned, then you do not need to show the forward link.  At the same time, we always (always, when next came) show the link back (previous) with the id of the first record from the selection.  Links "to the beginning" and "last" are always shown together with "back" and "forward", respectively.  That is, if we decide to show ‚Äúback‚Äù, we must show ‚Äúto the beginning‚Äù. <br>  Every time when we receive a previous (request to the previous page), we select 11 entries that have id less than the one specified in the query, sorted in the reverse order.  The same thing: if 11 records returned, then the link ‚Äúback‚Äù is shown.  Link forward always show. <br>  I hope, clearly wrote ... <br>  What if we received the request "last"?  Just show 10 entries, starting with the most recent.  I.e: <br><br>  SELECT id FROM items ORDER BY id DESC LIMIT 10; <br><br>  Do you think any of the users have enough strength to squander several hundred, or even thousands of pages, in order to accuse you of lying, having finally found out not 10 entries on the first page?  Even if that's enough, you can answer that he shook too long ... <br><br>  The previous example was simple because id is unique.  And what if you want to sort by field, whose values ‚Äã‚Äãcan be repeated?  For example, height in our case.  By a simple query, it was found out that in the table each height value occurs approximately 800 times.  Simply passing the last height displayed in the request parameters is already small.  It will help us all the same id.  We are asked to sort the records by height, but this does not prevent us from sorting them out then by id? <br>  For this we need a new index: <br><br>  ALTER TABLE items ADD KEY height_id_idx (height, id); <br><br>  The request for the first page will be: <br><br>  SELECT SQL_NO_CACHE id, height FROM items ORDER BY height, id LIMIT 10; <br><br>  In my results, the last entry has height = 0, id = 1174.  So it should be transferred to the next page.  For example, next_0_1174 or next / 0/1074 - as you prefer. <br>  Now we need to select records for which either height is greater than 0, or height = 0, and id&gt; 1174 (this is what we did for additional sorting). <br>  I.e: <br><br>  SELECT SQL_NO_CACHE * FROM items WHERE (height&gt; 0) OR (height = 0 AND id&gt; 1174) ORDER BY height, id LIMIT 10; <br><br>  I hope, to explain why this is not necessary.  The status still shows only 9 steps forward. <br>  Thus, we can add other sortings.  For example, if we want to display all records sorted by price and height, the query would be: <br><br>  SELECT SQL_NO_CACHE * FROM items WHERE (price&gt; 5) OR (price = 5 AND height&gt; 0) AND (price = 5 AND height = 0 AND id&gt; 1174) ORDER BY price, height, id LIMIT 10; <br><br>  It remains only to transmit all the necessary data, process them correctly and substitute them in the request.  And do not forget about the index. <br><br><h4>  4 What to do with the number of results </h4><br>  What if we want to show users how many results were found?  Since we are talking about large numbers, it is unlikely that someone will check us.  The same Google can show that it has found 1000000 pages matching the query, but you will not see more than 1000.  We can also give the number of results only approximately.  Where to get it and how to evaluate?  Remember, we ran the query: <br><br>  SELECT SQL_NO_CACHE COUNT (*) FROM items FORCE INDEX (height_idx) WHERE height&gt; 100; <br><br>  And let's do this: <br>  EXPLAIN SELECT SQL_NO_CACHE * FROM items FORCE INDEX (height_idx) WHERE height&gt; 100; <br><br>  As a result, we get something like this: <br>  + ---- + ------------- + ------- + ------- + -------------- - + ------------ + --------- + ------ + ------- + ---------- --- + <br>  |  id |  select_type |  table |  type |  possible_keys |  key |  key_len |  ref |  rows |  Extra | <br>  + ---- + ------------- + ------- + ------- + -------------- - + ------------ + --------- + ------ + ------- + ---------- --- + <br>  |  1 |  SIMPLE |  items |  range |  height_idx |  height_idx |  4 |  NULL |  22616 |  Using where | <br>  + ---- + ------------- + ------- + ------- + -------------- - + ------------ + --------- + ------ + ------- + ---------- --- + <br><br>  The rows column shows the estimated number of records to be viewed.  22616 and 16405 - the difference is not at all great.  You can round up to ~ 20,000, and all right.  Come down.  Just remember that if you use, for example, subqueries and / or joins, then EXPLAIN will return several rows.  They must all be read and multiplied by the rows. <br><br><h4>  Conclusion </h4><br>  This problem has already been highlighted casually at habr, but not so detailed. <br>  The article turned out more than expected, although the text is diluted with inserts of queries and results.  At the moment, there is no place to put the script used to generate data + sql files.  In general ... there is no strength left for the conclusion :) </div><p>Source: <a href="https://habr.com/ru/post/44608/">https://habr.com/ru/post/44608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../44607/index.html">Cracker Half Life 2 tried to lure in the US</a></li>
<li><a href="../446072/index.html">Using signed bootloaders to bypass UEFI Secure Boot protection</a></li>
<li><a href="../446074/index.html">How we broke the development into teams (and forgot about endless sprints and useless stand-ups)</a></li>
<li><a href="../446076/index.html">QlikView. Conditional Formatting "Like Excel"</a></li>
<li><a href="../446078/index.html">"Sound": discussing a podcast about audio equipment</a></li>
<li><a href="../446080/index.html">In the US, the court recommended banning the import of certain iPhone models due to Apple‚Äôs violation of Qualcomm patents.</a></li>
<li><a href="../446082/index.html">Tale of semirings</a></li>
<li><a href="../446088/index.html">Things I don't know in 2018</a></li>
<li><a href="../44609/index.html">Google added voice search to iPhone software.</a></li>
<li><a href="../446090/index.html">Micropython on GSM + GPS A9G module</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>