<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Two simple tasks on Haskell (for beginners)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings to all users of Habrahabr! 
 I recently began to learn Haskell, and, having mastered it a little, I decided to share a little accumulated ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Two simple tasks on Haskell (for beginners)</h1><div class="post__text post__text-html js-mediator-article">  Greetings to all users of Habrahabr! <br>  I recently began to learn Haskell, and, having mastered it a little, I decided to share a little accumulated experience.  Of course, Haskell‚Äôs knowledge is not at the same level as that of <a href="https://habrahabr.ru/users/darkus/" class="user_link">Darkus</a> , so the two tasks described below are more focused on beginners, but experienced users will probably fix it and tell you how to do it better.  This is not only my first article on Habrahabr, but in general my first tutorial that I have ever written. <br><a name="habracut"></a><br><h3>  Task 1 </h3><br>  In a city consisting of n districts, it is necessary to create customs points.  But you need to put them in the busiest areas of the city.  A loaded area is considered to be an area through which one must pass if one goes from part of city A to part B, that is,  if there is no detour.  If we imagine the city as a graph, and the districts as nodes, then we will search for all ‚Äúbottlenecks‚Äù (= bottlenecks or also called ‚Äúneedle eye‚Äù) for a specific path.  The following declarations are given: <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">District</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Integer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NumOfDistricts</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Integer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Route</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">District</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">District</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CityMap</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CM</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NumOfDistricts</span></span></span><span class="hljs-class">, [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Route</span></span></span><span class="hljs-class">]) </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--  : type Path = [District] type Bottleneck = District</span></span></span></span></code> </pre> <br><br>  In the end, the function should turn out: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bottlenecks</span></span> :: <span class="hljs-type"><span class="hljs-type">CityMap</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">District</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">District</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Bottleneck</span></span>]</code> </pre> <br>  Those.  passing this CityMap function and two districts (beginning and end), we will get an array of all nodes through which we definitely need to go if we want to get from one point to another. <br><br>  To begin, give an example.  Suppose we have the next city <br><br>  city ‚Äã‚Äã= CM (6, [(2,3), (1,2), (3,1), (4,3), (4,6), (5,6), (5,3)]) <br><br><img src="https://habrastorage.org/storage2/72e/2e0/33a/72e2e033a9d2b97c4a6a242476a65e3c.png"><br><br>  then the function call <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bottlenecks</span></span> city <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre>  should return node number 3 (an array consisting of one node). <br><br>  To begin with, we write a function that returns all the neighbors of a particular node. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">neighbours</span></span> :: <span class="hljs-type"><span class="hljs-type">CityMap</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">District</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">District</span></span>]</code> </pre> <br><br>  Since each element of the Route consists of only two elements, it is possible to simply check whether one of the elements of the pair (p, q) is the desired (b) element.  If b is equal to p, then we add q and vice versa.  You can use the mapMaybe function to do this. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">neighbours</span></span> (<span class="hljs-type"><span class="hljs-type">CM</span></span> (_,rs)) b = mapMaybe neighbour rs <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> neighbour (p,q) | b == p = <span class="hljs-type"><span class="hljs-type">Just</span></span> q | b == q = <span class="hljs-type"><span class="hljs-type">Just</span></span> p | otherwise = <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><br>  Testing: <br><br> <code>*Main Data.List&gt; neighbours city 3</code> <br> <code>[2,1,4,5]</code> <br> <br>  Works!  Now, when you can find the neighbors of any node, it would be good to find a path between any two points.  Or rather not just a path, but all possible paths: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">paths</span></span> :: <span class="hljs-type"><span class="hljs-type">CityMap</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">District</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">District</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Path</span></span>]</code> </pre> <br><br>  We must not forget at every step of the algorithm to memorize the node that we have already visited (otherwise we will walk endlessly in circles).  Algorithm for finding ways from start to goal: <br><br>  1. if start == goal, then return [[start]] <br>  2. if start is NOT present in the array of visited nodes (= visited), then for each element of the neighbors (= next) we look for a path from this neighbor to the goal. <br>  3. otherwise return [] (i.e. if we have already visited start) <br><br>  The problem is that our paths function does not ‚Äúsave‚Äù at each step an array of visited nodes.  This can be done using the paths' sub-function: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">paths</span></span> :: <span class="hljs-type"><span class="hljs-type">CityMap</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">District</span></span>-&gt; <span class="hljs-type"><span class="hljs-type">District</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Path</span></span>] paths cm start goal = paths' [] cm start goal <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> paths' visited cm start goal | start == goal = [[start]] | start `notElem` visited = [start:rest | next &lt;- neighbours cm start, rest &lt;- paths' (start:visited) cm next goal] | otherwise = []</code> </pre> <br><br>  Testing: <br><br> <code>*Main Data.List&gt; paths city 1 2</code> <br> <code>[[1,2],[1,3,2]]</code> <br> <br>  Having all the possible paths from A to B, it is quite easy to find a bottleneck - this is the node that is used in all the paths.  It should be noted that nodes A and B will also be present in all paths, so they should be immediately excluded from the possible set of solutions: <br><br><pre> <code class="haskell hljs">[<span class="hljs-number"><span class="hljs-number">1.</span></span>.n] \\ [start, goal] <span class="hljs-comment"><span class="hljs-comment">--  n - </span></span></code> </pre> <br><br>  In order to find the number that is used in all paths, we will use the intersect function, which returns only those elements that are found in both sets.  Those.  it is necessary to apply this function to the set of all possible solutions and the first element of the paths set, then apply the answer to the second element, etc.  The answer can be written as follows: <br><br> <code>((((([1..n] \\ [start, goal]) intersect paths[0]) intersect paths[1]) intersect paths[2]) intersect...)</code> <br> <br>  Then, the function bottlenecks can be written in one line: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bottlenecks</span></span> :: <span class="hljs-type"><span class="hljs-type">CityMap</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">District</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">District</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Bottleneck</span></span>] bottlenecks cm@(<span class="hljs-type"><span class="hljs-type">CM</span></span> (n,_)) start goal = foldl intersect ([<span class="hljs-number"><span class="hljs-number">1.</span></span>.n] \\ [start, goal]) $ (paths cm start goal)</code> </pre> <br><br>  Remember to import the Data.Maybe (for mapMaybe) and Data.List (for intersect) modules. <br><br><h3>  Task 2 </h3><br>  Consider a very similar problem, namely the problem of the <a href="http://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25BE_%25D0%25AD%25D1%2580%25D0%25B4%25D1%2591%25D1%2588%25D0%25B0">Erds Number</a> .  Briefly explain what it is: all those who wrote a scientific article with mathematician <a href="http://ru.wikipedia.org/wiki/%25D0%25AD%25D1%2580%25D0%25B4%25D1%2591%25D1%2588,_%25D0%259F%25D0%25BE%25D0%25BB">Paul Erd√∂s</a> receive the number 1, all those who have written a scientific article with co-authors Paul Erdos (but not with him) get the number 2, etc.  That is, co-authors of people with Erd s number equal to n have Erdos number n + 1.  The task is to find this number for a specific person (if the connection between this person and Erd√∂s cannot be found, we display the number -1).  So, to begin with, we will define the types of data with which we will work - these are scientists (the scientist consists of an initial and a surname), they are also authors, as well as a database each item that contains the name of the article (scientific work) and the names of the authors who published .  We will also declare a database that we will use for tests: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ErdosNumber</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Scientist</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Initial</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SurName</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Initial</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SurName</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Author</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Scientist</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Database</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Db</span></span></span><span class="hljs-class"> [([</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Author</span></span></span><span class="hljs-class">],</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PaperTitle</span></span></span><span class="hljs-class">)] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PaperTitle</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Path</span></span></span><span class="hljs-class"> = [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Author</span></span></span><span class="hljs-class">] db = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Db</span></span></span><span class="hljs-class"> [([</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Smith</span></span></span><span class="hljs-class">",</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">G</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Martin</span></span></span><span class="hljs-class">",</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">P</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Erdos</span></span></span><span class="hljs-class">"],"</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Newtonian</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Forms</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prime</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Factors</span></span></span><span class="hljs-class">"), ([</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">P</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Erdos</span></span></span><span class="hljs-class">",</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">W</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Reisig</span></span></span><span class="hljs-class">"],"</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stuttering</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Petri</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nets</span></span></span><span class="hljs-class">"), ([</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Smith</span></span></span><span class="hljs-class">",</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">X</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Chen</span></span></span><span class="hljs-class">"],"</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">First</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Order</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Derivates</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Structured</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Programming</span></span></span><span class="hljs-class">"), ([</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Jablonski</span></span></span><span class="hljs-class">",</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Hsueh</span></span></span><span class="hljs-class">"],"</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Selfstabilizing</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Structures</span></span></span><span class="hljs-class">"), ([</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">X</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Chen</span></span></span><span class="hljs-class">",</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sc</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">L</span></span></span><span class="hljs-class">' "</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Li</span></span></span><span class="hljs-class">"],"</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prime</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Numbers</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">and</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Beyond</span></span></span><span class="hljs-class">")]</span></span></code> </pre><br><br>  As in the previous problem, we start by writing a function that defines all the neighbors (that is, those who are in direct connection with this author): <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">neighbours</span></span> :: <span class="hljs-type"><span class="hljs-type">Database</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Author</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Author</span></span>]</code> </pre> <br><br>  Unlike the previous task, each element of the database, we may contain more than two elements of type Author, so the function mapMaybe can not do.  For each element of the database ([Author], PaperTitle) we will check whether the author whose neighbors we are trying to find is in the [Author] array, if so, take the entire [Author] array, if not, go to the next element Database.  In the end, it will be necessary to remove the name of the author of which we were looking for from the resulting list (we are looking for its neighbors, therefore, we need nothing): <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">neighbours</span></span> :: <span class="hljs-type"><span class="hljs-type">Database</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Author</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Author</span></span>] neighbours (<span class="hljs-type"><span class="hljs-type">Db</span></span> []) _ = [] neighbours (<span class="hljs-type"><span class="hljs-type">Db</span></span> ((a,_):xs)) (<span class="hljs-type"><span class="hljs-type">Sc</span></span> is) = filter (/= (<span class="hljs-type"><span class="hljs-type">Sc</span></span> is)) ((neighbour a) ++ (neighbours (<span class="hljs-type"><span class="hljs-type">Db</span></span> xs) (<span class="hljs-type"><span class="hljs-type">Sc</span></span> is))) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> neighbour a | (<span class="hljs-type"><span class="hljs-type">Sc</span></span> is) `elem` a = a | otherwise = []</code> </pre> <br><br>  Do not forget to declare how we will compare our scientists: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Scientist</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (<span class="hljs-type"><span class="hljs-type">Sc</span></span> i1 s1) == (<span class="hljs-type"><span class="hljs-type">Sc</span></span> i2 s2) = (i1 == i2) &amp;&amp; (s1 == s2)</code> </pre> <br><br>  Now we will look for all possible paths from the author of "start" to the scientist (Sc 'P' "Erdos").  The paths function is almost the same as the one we have already written: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">paths</span></span> :: <span class="hljs-type"><span class="hljs-type">Database</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Author</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Path</span></span>] paths db start = paths' [] db start <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> paths' visited db start | start == (<span class="hljs-type"><span class="hljs-type">Sc</span></span> '<span class="hljs-type"><span class="hljs-type">P'</span></span> <span class="hljs-string"><span class="hljs-string">"Erdos"</span></span>) = [[start]] | start `notElem` visited = [start:rest | next &lt;- neighbours db start, rest &lt;- paths' (start:visited) db next] | otherwise = []</code> </pre> <br><br>  Having an array of all possible paths from the author to Erdos, you can convert each of the paths into its length using the length function (that is, we obtain an array that contains the lengths of each path).  From the resulting array, select the minimum number (= shortest path) and subtract one from this number, since  Erdos himself has the number 0. We will not forget to check before that if there is any way at all that leads to Erdos (if not, then return -1): <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">erdosNum</span></span> :: <span class="hljs-type"><span class="hljs-type">Database</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Scientist</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ErdosNumber</span></span> erdosNum db sc | length (paths db sc) == <span class="hljs-number"><span class="hljs-number">0</span></span> = (<span class="hljs-number"><span class="hljs-number">-1</span></span>) | otherwise = (-) (minimum (map length (paths db sc))) <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><br><br>  Successes in programming! </div><p>Source: <a href="https://habr.com/ru/post/159127/">https://habr.com/ru/post/159127/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../159109/index.html">Phased array antenna</a></li>
<li><a href="../159113/index.html">Hibernation on PROXMOX2</a></li>
<li><a href="../159115/index.html">We improve labor productivity. Objective-c macros and literals</a></li>
<li><a href="../159121/index.html">We solder a ‚Äúsmart‚Äù car PSU on 5v with USB charging and automatic on / off</a></li>
<li><a href="../159123/index.html">We turn on FCoE on the Cisco Nexus 5000 switch</a></li>
<li><a href="../159129/index.html">Proper definition of the user's language</a></li>
<li><a href="../159131/index.html">Mysql PARTITION BY YEAR (date) / MONTH (date) / DAYOFWEEK (date)</a></li>
<li><a href="../159133/index.html">Configuring Asus RT-N56U Router to Access Pandora, Hulu and Other Resources</a></li>
<li><a href="../159135/index.html">Android 4.2 calendar is missing December</a></li>
<li><a href="../159137/index.html">Vkontakte has its own advertising network for partner sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>