<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automatic generation of resources for Android applications using scripts for Adobe Photoshop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 When developing for Android, as you know, you need to build on creating resources under all possible pixel densities. Initially, there were...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automatic generation of resources for Android applications using scripts for Adobe Photoshop</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  When developing for Android, as you know, you need to build on creating resources under all possible pixel densities.  Initially, there were only three such densities: <i>ldpi</i> , <i>mdpi</i> and <i>hdpi</i> .  However, progress is not in place: the pixel density of the screens grow to irresponsible values, and in the meantime Google put the letter ‚Äúx‚Äù on sly and got to <i>xxxhdpi</i> , receiving as a result as many as six basic screen configurations.  This means that if you play by the rules, then you need to save a half-dozen resources per icon.  But that's not all, because some resources have several different states.  The buttons on the action bar have two states, and this is all right, but the usual buttons have much more. <br><br>  There are several ways out: you can torture the artist, you can spit on the support of many densities and hope that the system somehow scales them, or you can use the fact that programmers like to do the most: automation.  There are different tools with which to do this.  The most advanced is probably <a href="http://android-ui-utils.googlecode.com/hg/asset-studio/dist/index.html">Android Asset Studio</a> .  This is a very sensible tool, but, of course, icons are drawn there only for standard cases, and if you need to make buttons with your own unique styles, it‚Äôs not our helper here.  And here we are rescued by the support of scripts in the well-known tool: Adobe Photoshop.  In order to simplify the whole process, your humble servant has written several tools for himself on a similar occasion and is now sharing them with readers.  How to use them, and how they work, I describe further.  All the sources are on <a href="https://bitbucket.org/DrMetallius/photoshop-scripts-for-android-resources">BitBucket</a> , and here I will tell the main points and show some tricks of working with Photoshop scripts that may not be obvious to beginners.  Just in case, I note that I wrote them for Photoshop CS6. <a name="habracut"></a><br><br><h4>  Using scripts and working principles </h4><br>  Before you talk about scripts, you should give a link to the <a href="http://habrahabr.ru/post/112907/">predecessor article</a> , which explains the general process of writing scripts for Photoshop.  In short, the standard tool for this is the ExtendScript Toolkit, distributed with the graphic editor itself.  I have to be sad to say that I absolutely agree with the author of the above article that the editor is really rather stupid.  But so what is, such is.  You can write scripts directly, of course, and not in it, but for debugging you will have to make friends with it.  There is in it on the F1 button and documentation on functions built into Photoshop, which is just as inconvenient as the editor itself, but at least performs its main function.  The scripts themselves can be written in different languages, and I myself used JavaScript. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/aaa/e3b/ced/aaae3bcedfe80d25cd21bca929e22970.png" alt="Adobe ExtendScript Toolkit"><br><br><h5>  Creating an icon for all densities </h5><br>  Returning to our sheep, all written scripts for working with resources can be divided into two parts: some of them directly launch the execution of the necessary actions (they all begin with the word ‚ÄúMake‚Äù), while others serve as libraries with functions.  The most important and versatile tool is <b>MakeForAllDensities</b> , which does what the name suggests: it creates resources for all densities from a single document.  There are some requirements for the document: <br><br><ol><li>  The document must be created for <i>mdpi</i> pixel density.  It is taken as the base and then scaled to the desired size. </li><li>  The document should already be saved somewhere for the script to correctly read the file name (and also determine if it is not the <a href="http://habrahabr.ru/post/113623/">nine-patch</a> , using the prefix ".9").  It is best to save in the subfolder of the root folder of the Android project, then the script itself will find the res folder. </li><li>  An additional requirement: if it is a nine-patch, then the lines should be drawn on a separate layer, the lowest one. </li><li>  Well, of course, the image should be vectorial, not raster, otherwise there is no special point in scaling it with Photoshop, not Android.  There is one exception: this does not apply to the nine-patch lines, and they can also be raster. </li></ol><br>  If all these requirements are met, then the rest is already a matter of technology: open the document in Photoshop and launch the script with a double click.  After launching, the script will ask you to specify a folder with resources (res), and if the document is saved in a project subfolder, then it will figure out where to save itself, and then everything else will be done by itself. <br><br>  The script itself looks very simple: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//@include ResizingAndSaving.jsx #target photoshop var outputFolder = detectFolder(); if (outputFolder) saveForAllDensities(outputFolder, 0, "");</span></span></code> </pre> <br>  Typical javascript except for the weird first two lines.  The first strange line looks like a regular comment, which is actually not a comment, but an import of another file with the functions we need.  This is <b>trick number one</b> , because in standard JavaScript such a chip does not roll.  The second strange line, as you can easily guess, suggests that the script should run in Photoshop.  What do the rest of the lines, we will open ResizingAndSaving.jsx. <br><br>  <code>detectFolder</code> don‚Äôt quote <code>detectFolder</code> here, because there is nothing special in it: the function checks whether there is a res folder in the folder folder of the document, and returns it if it finds it, and if not, it asks the user.  But then the more important part of the script begins. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveForAllDensities</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">outputFolder, version, postfix, ninePatchLines</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ninePatchLines) ninePatchLines = computeNinePatchLines(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> versionStr = version ? <span class="hljs-string"><span class="hljs-string">"-v"</span></span> + version : <span class="hljs-string"><span class="hljs-string">""</span></span>; saveInFolder(outputFolder, <span class="hljs-string"><span class="hljs-string">"drawable-mdpi"</span></span> + versionStr, <span class="hljs-number"><span class="hljs-number">100</span></span>, postfix, ninePatchLines); saveInFolder(outputFolder, <span class="hljs-string"><span class="hljs-string">"drawable-hdpi"</span></span> + versionStr, <span class="hljs-number"><span class="hljs-number">150</span></span>, postfix, ninePatchLines); saveInFolder(outputFolder, <span class="hljs-string"><span class="hljs-string">"drawable-xhdpi"</span></span> + versionStr, <span class="hljs-number"><span class="hljs-number">200</span></span>, postfix, ninePatchLines); saveInFolder(outputFolder, <span class="hljs-string"><span class="hljs-string">"drawable-xxhdpi"</span></span> + versionStr, <span class="hljs-number"><span class="hljs-number">300</span></span>, postfix, ninePatchLines); saveInFolder(outputFolder, <span class="hljs-string"><span class="hljs-string">"drawable-xxxhdpi"</span></span> + versionStr, <span class="hljs-number"><span class="hljs-number">400</span></span>, postfix, ninePatchLines); }</code> </pre><br>  I answer in advance the question if someone came up with it: <i>ldpi</i> is not here, because Google <a href="http://developer.android.com/design/style/iconography.html">does not recommend creating resources for it</a> .  As mentioned earlier, the file may be a nine-patch, which in terms of editing the file means that it has a separate layer with black lines along the edges.  And these lines can not be simply taken and scaled: it is necessary to paint over the pixels completely black, or not to paint at all, and you cannot climb onto the neighboring pixels.  In addition, you need to consider that the lines may not be solid.  This is where the <code>computeNinePatchLines</code> function comes into <code>computeNinePatchLines</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeNinePatchLines</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> docName = getDocName(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isNinePatch(docName)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ninePatchLines = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doc = app.activeDocument; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areaCheckingFunctions = [ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> areaIsEmpty(doc, pos, <span class="hljs-number"><span class="hljs-number">0</span></span>);}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> areaIsEmpty(doc, <span class="hljs-number"><span class="hljs-number">0</span></span>, pos);}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> areaIsEmpty(doc, pos, doc.height - <span class="hljs-number"><span class="hljs-number">1</span></span>);}, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> areaIsEmpty(doc, doc.width - <span class="hljs-number"><span class="hljs-number">1</span></span>, pos);} ]; maxPositions = [doc.width, doc.height, doc.width, doc.height]; ninePatchLines = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos &lt; areaCheckingFunctions.length; pos++) { ninePatchLines.push(findLines(maxPositions[pos], areaCheckingFunctions[pos])); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ninePatchLines; }</code> </pre><br>  The main point of this function is to walk on each side of the picture and check where the black lines are hidden there.  After they are found, it will be possible to multiply their length by the necessary coefficient without any knowledge and continue to paint over the necessary area as it should be.  It will be interesting to look into the <code>areaIsEmpty</code> function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">areaIsEmpty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">doc, x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = getState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc.colorSamplers.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colorSampler = doc.colorSamplers.add([x,y]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colorSampler = doc.colorSamplers[<span class="hljs-number"><span class="hljs-number">0</span></span>]; colorSampler.move([x, y]); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areaEmpty; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { areaEmpty = colorSampler.color.rgb.hexValue !== <span class="hljs-string"><span class="hljs-string">"000000"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { areaEmpty = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } restoreState(state); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> areaEmpty; }</code> </pre><br>  This function is designed to check whether a pixel is blacked out or not.  Only here the thing is that in Photoshop, as it turned out, using the standard API it‚Äôs impossible to check whether a certain pixel is empty, not to mention just finding out its color.  Therefore, you have to put a color sampler on it and see if it will throw an exception when checking the color or not.  If issued, then the pixel is empty.  If not, you can watch its color.  That is <b>cunning number two</b> .  The <code>findLines</code> function, which I do not cite here, simply applies <code>areaIsEmpty</code> in a row for all pixels along one of the four edges of the screen and records their positions. <br><br>  Then you can scale the resources and save them to a folder. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveInFolder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">outputFolder, subFolder, scaling, postfix, ninePatchLines</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> opts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExportOptionsSaveForWeb(); opts.format = SaveDocumentType.PNG; opts.PNG8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; opts.transparency = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; opts.quality = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = getState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ninePatchLines) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doc = app.activeDocument; doc.resizeCanvas(doc.width - <span class="hljs-number"><span class="hljs-number">2</span></span>, doc.height - <span class="hljs-number"><span class="hljs-number">2</span></span>); resize(scaling, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); doc.resizeCanvas(doc.width + <span class="hljs-number"><span class="hljs-number">2</span></span>, doc.height + <span class="hljs-number"><span class="hljs-number">2</span></span>); drawLines(doc, scaling / <span class="hljs-number"><span class="hljs-number">100</span></span>, ninePatchLines); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { resize(scaling, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } activeDocument.exportDocument(createFile(outputFolder, subFolder, postfix, <span class="hljs-string"><span class="hljs-string">".png"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>), ExportType.SAVEFORWEB, opts); restoreState(state); }</code> </pre><br>  Everything is, in principle, obvious, but the way the resizing of the image itself is done deserves a separate explanation.  It would seem that there is a <code>Document.resizeImage</code> function, and you just need to call it, right?  But nothing will come of it: the layer styles do not scale.  You can record the action and then play it programmatically.  This option works, but it‚Äôs bad because then you definitely need to attach a library of these actions to the script, which you need to import before launching, which is somehow not very convenient. <br><br>  Another option is to use the tool that was described by <a href="http://habrahabr.ru/post/112907/">my already mentioned predecessor</a> , namely ScriptListener.8li.  This tool allows you to record all actions that are performed in Photoshop, in the script, even if these actions are not supported in the standard API.  The exit scripts come out, of course, rather vague, but they do their job perfectly well.  With a little effort, you can understand which parameters are responsible for what, and make a function from the recorded specific actions.  It is this way that such an indistinct, but workable function appeared: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size, relative</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idImgS = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"ImgS"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionDescriptor(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idWdth = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"Wdth"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idPxl = charIDToTypeID( relative ? <span class="hljs-string"><span class="hljs-string">"#Prc"</span></span> : <span class="hljs-string"><span class="hljs-string">"#Pxl"</span></span> ); desc.putUnitDouble( idWdth, idPxl, size ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idscaleStyles = stringIDToTypeID( <span class="hljs-string"><span class="hljs-string">"scaleStyles"</span></span> ); desc.putBoolean( idscaleStyles, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idCnsP = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"CnsP"</span></span> ); desc.putBoolean( idCnsP, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idIntr = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"Intr"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idIntp = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"Intp"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idbicubicSharper = stringIDToTypeID( <span class="hljs-string"><span class="hljs-string">"bicubicAutomatic"</span></span> ); desc.putEnumerated( idIntr, idIntp, idbicubicSharper ); executeAction( idImgS, desc, DialogModes.NO ); }</code> </pre><br>  That was <b>trick number three</b> .  After the required image sizes are obtained, the script draws, if necessary, the nine-patch lines, and the new resource is sent to the required folder. <br><br><h5>  Creating icons for the action bar </h5><br>  In addition to MakeForAllDensities, there are four more <b>MakeActionBarIcons</b> scripts that make icons for the action bar: for the black and white theme, which can be turned off and off.  They are used in the same way as MakeForAllDensities, except that now the document should contain only one layer.  In this layer, it is important only to observe the shape of the icon, and the styles will be applied by the script itself. <br><br>  Now the difficulty is that Google has certain <a href="http://developer.android.com/design/style/iconography.html">requirements for the style of icons depending on their state</a> .  If the icon exists only in one state, then everything is simple, but if you need to turn it off, then here you need to figure out how to modify the appearance of the layers programmatically.  For icons on the action bar, we need to know how to change the transparency of the layer and its color.  There are no problems with the first one, but in relation to the latter, the standard API again gives up the slack.  So, you will have to re-apply to saving ScriptListener.8li.  As a result of its use in the Styles file, a function appeared that will help us change the color of the vector layer: <code>setLayerColor</code> .  That gibberish, which is in the body of the function, I, perhaps, omit. <br><br>  In principle, for the icons of the action bar, nothing but the above described is needed.  But those who have already looked into the Styles file, noticed that there are still many functions obtained using ScriptListener.8li, which can manipulate the effects of layers.  They were written for my own icons, the scripts for the creation of which I‚Äôm not adding to the repository anymore.  For this reason, the existing functions, of course, may be someone is not enough, and you will need to make your own.  Again, you can either record actions or make styles and apply them programmatically.  But this is inconvenient, so it‚Äôs better to get away with functions again, since we have already mastered the benefit of ScriptListener.8li.  And here there is another snag: if you write a script to add a particular layer effect and arrange it into a function, then when it is applied, the already installed effects will disappear.  Here comes <b>trick number four</b> .  If you pay attention to the beginning of the rubbish that ScriptListener.8li gives out for each application of the effect, the lines similar to the following will be everywhere: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idsetd = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"setd"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionDescriptor(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idnull = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"null"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ref = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionReference(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idPrpr = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"Prpr"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idLefx = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"Lefx"</span></span> ); ref.putProperty( idPrpr, idLefx ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idLyr = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"Lyr "</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idOrdn = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"Ordn"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idTrgt = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"Trgt"</span></span> ); ref.putEnumerated( idLyr, idOrdn, idTrgt ); desc.putReference( idnull, ref ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idT = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"T "</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> desc2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionDescriptor(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idScl = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"Scl "</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idPrc = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"#Prc"</span></span> ); desc2.putUnitDouble( idScl, idPrc, <span class="hljs-number"><span class="hljs-number">100.000000</span></span> );</code> </pre><br>  And at the very end of the script everything ends with this chord: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> idLefx = charIDToTypeID( <span class="hljs-string"><span class="hljs-string">"Lefx"</span></span> ); desc.putObject( idT, idLefx, desc2 ); executeAction( idsetd, desc, DialogModes.NO );</code> </pre><br>  The creation of the layer style itself is the responsibility of the last four lines from the first portion of the code above, which create <code>desc2</code> and set the scale for the style.  Everything else is just the application of style.  Now that we know which lines they are doing, we can separate the veins from the meat and isolate that part of the code that directly applies the effect.  Duplicate plots are decorated in separate functions in Styles, which are applied in a similar way: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> style = newStyle(); <span class="hljs-comment"><span class="hljs-comment">//   addColorOverlay(style, 0xFF, 0xFF, 0xFF, 100); //  addStroke(style, 0x00, 0x00, 0x00, 3); //    applyStyle(style); //, ,   </span></span></code> </pre><br>  Now we have all the tools in hand, it remains to use it.  I remind you that all these miraculous means were started in order to apply different styles to the resource depending on the state.  The <code>makeIcons</code> function in MenuIcons is what it does: it applies different styles to the icon for the action bar and saves the result.  I bring here its main piece. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (makeStateful) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> selectorData = [ { <span class="hljs-attr"><span class="hljs-attr">state_enabled</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">postfix</span></span>: <span class="hljs-string"><span class="hljs-string">"disabled"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">postfix</span></span>: <span class="hljs-string"><span class="hljs-string">"normal"</span></span> } ]; makeSelectorXml(selectorData, outputFolder, <span class="hljs-string"><span class="hljs-string">"drawable"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> styleFunctions = [<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">style</span></span></span><span class="hljs-function">) </span></span>{applyActionBarItemStyle(whiteTheme, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)}]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> postfixes = [<span class="hljs-string"><span class="hljs-string">"normal"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (makeStateful) { styleFunctions.unshift(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">style</span></span></span><span class="hljs-function">) </span></span>{applyActionBarItemStyle(whiteTheme, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)}); postfixes.unshift(<span class="hljs-string"><span class="hljs-string">"disabled"</span></span>); } saveStyledDrawables(outputFolder, styleFunctions, postfixes);</code> </pre><br>  The first part of the function creates a selector for our resource.  Selectors have been described in a recent article, The <a href="http://habrahabr.ru/post/206012/">Secrets of Buttons on Android</a> .  In our case, two states are created for the action panel: when the button is turned off and when it is in the normal state.  Accordingly, an array of objects describing states is passed to the function <code>makeSelectorXml</code> .  Objects have a <code>postfix</code> field and, if necessary, one or more fields starting with ‚Äústate_‚Äù.  After that, <code>makeSelectorXml</code> makes an XML file of a selector from this miracle, which is sent to the drawables folder. <br><br>  The second part of the function creates two arrays: one contains functions that apply styles for the given state, and the second array contains postfixes corresponding to the states.  Each function for applying styles has at its disposal a <code>style</code> argument.  This is the object that emerges at the exit from <code>newStyle</code> , over which we fought not long ago.  <code>applyStyle</code> does not need to be called in these functions, the <code>saveStyledDrawables</code> function will take care of <code>saveStyledDrawables</code> .  I don‚Äôt think I <code>saveStyledDrawables</code> bring the functions <code>makeSelectorXml</code> and <code>saveStyledDrawables</code> , because there is the most common, boring JavaScript. <br><br><h4>  Conclusion </h4><br>  In this way, you can not manually draw a cloud of icons, but use the ready-made solution and set everything up from one picture.  You can, of course, use Android Asset Studio, but the approach with scripts has its advantages.  First, you can make scripts for your own buttons, the styles of which are simply not in someone else's tool (why, in fact, I decided to write the whole thing).  Secondly, after all, uploading a file to the site, conjuring with the settings, and then downloading and stuffing the received files into folders is not as easy as double clicking on the script so that everything will turn out right.  In addition, Android Asset Studio does not want to work with PSD directly (at least at the time of this writing), does not distinguish the nine-patch from the usual icon, and the files in it can not be massively processed. <br><br>  I hope that the article turned out to be useful both for those who are creating applications on Android, and for those who want to learn how to write scripts for Photoshop. <br><br><h4>  useful links </h4><br><ul><li>  <a href="https://bitbucket.org/DrMetallius/photoshop-scripts-for-android-resources">The project page on BitBucket</a> is actually what the article is about. </li><li>  <a href="http://developer.android.com/design/style/iconography.html">Android iconography</a> - official requirements for icons.  I think that all of them have already read them, but if someone suddenly did not read, I advise you to fix it urgently. </li><li>  <a href="http://habrahabr.ru/post/112907/">We process pictures using Photoshop and ExtendScript Toolkit</a> - the basics of creating scripts for Photoshop, at the end of the article there are also useful links. </li><li>  <a href="http://habrahabr.ru/post/113623/">Android nine-patch - we stretch the android</a> - about what nine-patch is and why it is needed. </li><li>  <a href="http://habrahabr.ru/post/206012/">Secrets of buttons in Android.</a>  <a href="http://habrahabr.ru/post/206012/">Part 1: Layout basics</a> - if someone does not know all the subtleties of creating buttons and other elements of the Android interface that have different states, then this article is what you need. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/206952/">https://habr.com/ru/post/206952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206940/index.html">Removing the post-sale shock: a short tip for online stores</a></li>
<li><a href="../206942/index.html">CorelCAD 2014: Product Overview. Part 1</a></li>
<li><a href="../206944/index.html">CorelCAD 2014: Product Overview. Part 2</a></li>
<li><a href="../206948/index.html">CorelCAD 2014: Product Overview. Part 3</a></li>
<li><a href="../206950/index.html">The digest of news from the world of mobile development for the last week ‚Ññ34 (December 16-22, 2013)</a></li>
<li><a href="../206956/index.html">About variables in CSS and abstractions in web programming</a></li>
<li><a href="../206958/index.html">When does a sales manager become a programmer?</a></li>
<li><a href="../206960/index.html">DIY: HTPC with external video card</a></li>
<li><a href="../206962/index.html">Localizing ApplicationBar with Binding</a></li>
<li><a href="../206964/index.html">Install and configure Asterisk under iD Phone (iDPhone)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>