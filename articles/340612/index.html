<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Classes of matrices and vectors in Delphi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article discusses type design for working with objects of linear algebra: vectors, matrices, quaternions. Shows the classic use of the mechanism ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Classes of matrices and vectors in Delphi</h1><div class="post__text post__text-html js-mediator-article">  This article discusses type design for working with objects of linear algebra: vectors, matrices, quaternions.  Shows the classic use of the mechanism for overloading standard operations, using the ‚ÄúCopy On Write‚Äù method and annotations. <br><a name="habracut"></a><br>  Working in the field of mathematical modeling, I often have to deal with computational algorithms that use operations on matrices, vectors, and quaternions.  Surprisingly, he found that, despite the possibilities of a modern development environment, fellow programmers often use a procedural approach in solving such problems.  So, to calculate the product of a matrix and a vector, types and functions like these are described: <br><br><pre><code class="delphi hljs">TVec3 = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Extended; TMatrix3x3 = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Extended; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MVMult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(M: TMatrix3x3; V: TVec3)</span></span></span><span class="hljs-function">:</span></span> TVec3;</code> </pre> <br>  It is proposed to use an object-based approach, which, in turn, involves the joint distribution of data and methods for their processing.  Let's see what features Delphi provides for solving this class of tasks in an object form.  Designing the structure of objects we will proceed from the following requirements: <br><br><ul><li>  Version of the development environment Delphi XE7 </li><li>  For numeric data, use the Extended type as the most accurate; </li><li>  Use dynamic arrays to store data, because  sizes of vectors and matrices can be any and convenient to look at in the debugger; </li><li>  The elements of vectors and matrices are numbered with 1, the elements of quaternions with 0; </li><li>  For calculations, use the operations +, -, *, /; </li><li>  Provide the ability to transfer by value and copy vectors and matrices with the ": =" operation; </li><li>  To provide the possibility of automated initialization of vectors and matrices by predetermined sizes. </li></ul><br><h3>  Design </h3><br>  For convenience, we define auxiliary types: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="delphi hljs">TAbstractVector = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Extended; TAbstractMatrix = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Extended;</code> </pre> <br>  Now we define the quaternion structure, vector and matrix: <br><br><pre> <code class="delphi hljs">TQuaternion = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FData: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Extended; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Byte; Value: Extended)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Byte)</span></span></span><span class="hljs-function">:</span></span> Extended; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Element[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>: Byte]: Extended <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> GetElement <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> SetElement; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TVector = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FData: TAbstractVector; FCount: Word; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Word; Value: Extended)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Word)</span></span></span><span class="hljs-function">:</span></span> Extended; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ElementsCount: Word)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Count: Word <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FCount; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Elements[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>: Word]: Extended <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> GetElement <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> SetElement; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TMatrix = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FData: TAbstractMatrix; FRowsCount: Word; FColsCount: Word; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Row, Col: Word; Value: Extended)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Row, Col: Word)</span></span></span><span class="hljs-function">:</span></span> Extended; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RowsCount, ColsCount: Word)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> RowCount: Word <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FRowsCount; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> ColCount: Word <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FColsCount; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Elements[Row, Col: Word]: Extended <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> GetElement <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> SetElement; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  We use exactly <i>record</i> , since  overloading operations for <i>class</i> construction in Delphi is not allowed.  In addition, record objects have a useful property ‚Äî their data is deployed in memory at the place of declaration, in other words, the record object is not a reference to an instance in dynamic memory. <br>  However, in our case, the elements of vectors and matrices will be stored in a dynamic array, the object of which is a reference.  Therefore, it will be convenient to use explicit constructors.  They perform the initialization of internal fields, allocating memory for the required number of elements: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVector</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ElementsCount: Word)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCount := ElementsCount; FData := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; SetLength(FData, FCount); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMatrix</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RowsCount, ColsCount: Word)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FRowsCount := RowsCount; FColsCount := ColsCount; FData := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; SetLength(FData, FRowsCount, FColsCount); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  A quaternion at this stage does not require a constructor, since  it stores data in a static array and is deployed in memory at the place of its declaration. <br>  To access the elements, here are the properties-indexers, they are convenient to make default to omit the name.  Access to the requested item occurs after checking its index for valid values.  The implementation for TVector is shown: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVector</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Word)</span></span></span><span class="hljs-function">:</span></span> Extended; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R+}</span></span> Result := FData[Pred(<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>)]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVector</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Word; Value: Extended)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R+}</span></span> FData[Pred(<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>)] := Value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  At this stage, to create our objects, you will have to use the following code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> V: TVector; . . . V := TVector.Create(<span class="hljs-number"><span class="hljs-number">3</span></span>); V[<span class="hljs-number"><span class="hljs-number">1</span></span>] := <span class="hljs-number"><span class="hljs-number">1</span></span>; V[<span class="hljs-number"><span class="hljs-number">2</span></span>] := <span class="hljs-number"><span class="hljs-number">2</span></span>; V[<span class="hljs-number"><span class="hljs-number">3</span></span>] := <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br>  Practice has shown that it is useful to have the means to use a more concise syntax for creating a vector or matrix.  To do this, add additional constructors, as well as implement the implicit casting operation, which will allow to overload the ": =". <br><br><pre> <code class="delphi hljs">TQuaternion = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Q: TAbstractVector)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> Implicit(V: TAbstractVector): TQuaternion; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TVector = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(V: TAbstractVector)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> Implicit(V: TAbstractVector): TVector; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TMatrix = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(M: TAbstractMatrix)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> Implicit(M: TAbstractMatrix): TMatrix; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  And implementation: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TQuaternion</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Q: TAbstractVector)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Length(Q) &lt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> EMathError.Create(WRONG_SIZE); Move(Q[<span class="hljs-number"><span class="hljs-number">0</span></span>], FData[<span class="hljs-number"><span class="hljs-number">0</span></span>], SizeOf(FData)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> TQuaternion.Implicit(V: TAbstractVector): TQuaternion; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result.Create(V); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVector</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(V: TAbstractVector)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FCount := Length(V); FData := Copy(V); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> TVector.Implicit(V: TAbstractVector): TVector; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result.Create(V); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMatrix</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(M: TAbstractMatrix)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FRowsCount := Length(M); FColsCount := Length(M[<span class="hljs-number"><span class="hljs-number">0</span></span>]); FData := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; SetLength(FData, FRowsCount, FColsCount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Pred(FRowsCount) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> FData[I] := Copy(M[I]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> TMatrix.Implicit(M: TAbstractMatrix): TMatrix; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result.Create(M); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Now, to create and initialize a vector or matrix, it suffices to write: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> V: TVector; M: TMatrix; . . . V := [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// M := [[1, 2, 3], [4, 5, 6], [7, 8, 9]];</span></span></code> </pre> <br><h3>  Operation overload </h3><br>  Here, for example, only the operation overload * for multiplying the matrix by the vector will be implemented.  The remaining operations can be viewed in the <a href="https://yadi.sk/d/PNds8oOS3P4X4v">file</a> attached to the article.  A full list of overload capabilities is <a href="http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Operator_Overloading_%2528Delphi%2529">here</a> . <br><br><pre> <code class="delphi hljs">TMatrix = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> Multiply(M: TMatrix; V: TVector): TVector; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> TMatrix.Multiply(M: TMatrix; V: TVector): TVector; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I, J: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (M.FColsCount &lt;&gt; V.FCount) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> EMathError.Create(WRONG_SIZE); Result.Create(M.FRowsCount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> M.FRowsCount - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> J := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> M.FColsCount - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Result.FData[I] := Result.FData[I] + M.FData[I, J] * V.FData[J]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The first argument of the Multiply () method is the matrix to the left of the * sign, the second argument is the column vector to the right of the * sign.  The result of the product is a new vector whose object is created in the process of calculation.  In case of mismatch of the number of columns of the matrix and the number of elements of the vector, an exception is raised.  Here is the use of this operation in the program: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> V, VResult: TVector; M: TMatrix; . . . VResult := M * V;</code> </pre> <br>  It is convenient to use wrapper functions to construct anonymous vectors and matrices from array literals on the fly: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(V: TAbstractVector)</span></span></span><span class="hljs-function">:</span></span> TVector; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result.Create(V); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(M: TAbstractMatrix)</span></span></span><span class="hljs-function">:</span></span> TMatrix; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result.Create(M); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TQuat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Q: TAbstractVector)</span></span></span><span class="hljs-function">:</span></span> TQuaternion; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result.Create(Q); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The use of wrappers is as follows.  The equivalent of the expression from the previous example is shown: <br><br><pre> <code class="delphi hljs"> V := TMat([[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>], [<span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>]]) * TVec([<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]);</code> </pre> <br>  In addition to standard operations, it is useful to add specific methods to our object types, such as transposing or referencing.  The following is an example of a matrix inversion (inversion) method.  Despite its size, it is the fastest I've ever seen (in high-level languages). <br><br><pre> <code class="delphi hljs">TMatrix = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inv</span></span></span><span class="hljs-function">:</span></span> TMatrix; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMatrix</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inv</span></span></span><span class="hljs-function">:</span></span> TMatrix; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Ipiv, Indxr, Indxc: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Integer; DimMat, I, J, K, L, N, ICol, IRow: Integer; Big, Dum, Pivinv: Extended; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//  . if (FRowsCount &lt;&gt; FColsCount) then raise EMathError.Create(NOT_QUAD); Result := Self; DimMat := FRowsCount; SetLength(Ipiv, DimMat); SetLength(Indxr, DimMat); SetLength(Indxc, DimMat); IRow := 1; ICol := 1; for I := 1 to DimMat do begin Big := 0; for J := 1 to DimMat do if (Ipiv[J - 1] &lt;&gt; 1) then for K := 1 to DimMat do if (Ipiv[K - 1] = 0) then if (Abs(Result[J, K]) &gt;= Big) then begin Big := Abs(Result[J, K]); IRow := J; ICol := K; end; Ipiv[ICol - 1] := Ipiv[ICol - 1] + 1; if (IRow &lt;&gt; ICol) then for L := 1 to DimMat do begin Dum := Result[IRow, L]; Result[IRow, L] := Result[ICol, L]; Result[ICol, L] := Dum; end; Indxr[I - 1] := IRow; Indxc[I - 1] := ICol; if Result[ICol, ICol] = 0 then raise EMathError.Create(SINGULAR); Pivinv := 1.0 / Result[ICol, ICol]; Result[ICol, ICol] := 1.0; for L := 1 to DimMat do Result[ICol, L] := Result[ICol, L] * Pivinv; for N := 1 to DimMat do if (N &lt;&gt; ICol) then begin Dum := Result[N, ICol]; Result[N, ICol] := 0.0; for L := 1 to DimMat do Result[N, L] := Result[N, L] - Result[ICol, L] * Dum; end; end; for L := DimMat downto 1 do if (Indxr[L - 1] &lt;&gt; Indxc[L - 1]) then for K := 1 to DimMat do begin Dum := Result[K, Indxr[L - 1]]; Result[K, Indxr[L - 1]] := Result[K, Indxc[L - 1]]; Result[K, Indxc[L - 1]] := Dum; end; end;</span></span></code> </pre> <br><h3>  Copy by value </h3><br>  Using dynamic arrays to store elements of vectors and matrices leads to the fact that when you try to copy them entirely in the receiving object (the one to the left of ": ="), a copy of the link to this dynamic array is created. <br>  For example, an attempt to preserve the value of the matrix M after evaluating the expression will also result in the inversion of the MStore matrix. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> M, MStore: TMatrix; . . . MStore := M; M := M.Inv;</code> </pre> <br>  In order to correctly implement copying by value, we use the fact that, along with the negative offset from the address of the first element of the dynamic array, along with the length value, the counter of references to this array is stored.  If the value of the counter is 0, then the memory manager frees this array.  If the value of the counter is 1, this means that there is only one reference to the array instance in memory. <br>  Therefore, when copying, we must analyze the value of the counter and, if it is greater than 1, then create a full-fledged copy of the array by copying it into the receiving object <i>elementwise</i> .  Below is the function code, which returns True only in the case when the value of the reference counter passed in the input parameter of the dynamic array exceeds 1. <br><br><pre> <code class="delphi hljs"><span class="hljs-meta"><span class="hljs-meta">{$POINTERMATH ON}</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NotUnique</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Arr)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (PCardinal(Arr) - <span class="hljs-number"><span class="hljs-number">2</span></span>)^ &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  At what point should a full copy be performed?  This is a rather expensive operation, so there is no point in performing it when accessing an element of a vector / matrix for reading.  If we have at least a thousand references to the original, if he himself does not undergo any changes, then they all remain the same.  Therefore, you need to copy only when accessing the item for writing.  To do this, we modify the SetElement () methods for vectors and matrices, adding at the beginning a check for the uniqueness of an instance of the FData array: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVector</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Index</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Word; Value: Extended)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R+}</span></span> CheckUnique; FData[Pred(<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>)] := Value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVector</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckUnique</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NotUnique(FData) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FData := Copy(FData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMatrix</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Row, Col: Word; Value: Extended)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-meta"><span class="hljs-meta">{$R+}</span></span> CheckUnique; FData[Pred(Row), Pred(Col)] := Value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMatrix</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckUnique</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> I: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NotUnique(FData) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FData := Copy(FData); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Pred(FRowsCount) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> FData[i] := Copy(FData[i]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Thus, when you try to change the value of an element, a check will be made on the uniqueness of the link, and, if it is not confirmed, an element-by-element copy will be created, to which the change will be made. <br><br><h3>  Annotations and automatic initialization </h3><br>  Elements of vectors and matrices should be accessed only after allocating memory for them.  Element values ‚Äã‚Äãare stored in a dynamic array, the dimensions of which are set in the object's constructor.  An implicit constructor call can occur during object initialization, or in the process of evaluating an expression. <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> V: TVector; M: TMatrix; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">// V[1] := 1; // :    V := TVector.Create(4); //    M := TMatrix.Create(4, 4); //    // V := [1, 0, 0, 0]; //    // V := M * TVec([1, 0, 0, 0]); //    V[1] := 1; //    :  </span></span></code> </pre> <br>  The use of implicit constructors can lead to errors when, sooner or later, it will be allowed to refer to an element of an uncreated object.  According to the rules of good tone, the constructor should be called explicitly. <br>  But what if there are hundreds and thousands of vectors and matrices in our program?  Consider the description of a class that uses a set of vectors and matrices as its fields. <br><br><pre> <code class="delphi hljs">TMovement = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> R: TVector; V: TVector; W: TVector; Color: TVector; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TMovementScheme = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FMovement: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TMovement; FOrientation: TMatrix; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  It is required to develop a method for automated initialization of all fields of the TVector and TMatrix types: to allocate memory for vectors and matrices in accordance with the necessary element numbers and sizes.  The annotation mechanism (or attributes, in Delphi terms) will help us in this - a tool that allows you to add types with arbitrary metadata.  So, for each vector, the number of its elements must be known in advance, for the matrix - the number of rows and columns. <br>  Create a class that encapsulates data about dimensions, according to the rules for creating attribute classes. <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TDim</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TCustomAttribute) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FRowCount: Integer; FColCount: Integer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ARowCount: Integer; AColCount: Integer = 0)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> RowCount: Integer <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FRowCount; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> ColCount: Integer <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FColCount; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TDim</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ARowCount: Integer; AColCount: Integer = 0)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FRowCount := ARowCount; FColCount := AColCount; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The constructor gets the number of rows and columns, and in the case of a vector, we can do with only the number of rows.  Now we add the definition of the types from the previous listing with new annotations: <br><br><pre> <code class="delphi hljs">TMovement = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> [TDim(<span class="hljs-number"><span class="hljs-number">3</span></span>)] R: TVector; [TDim(<span class="hljs-number"><span class="hljs-number">3</span></span>)] V: TVector; [TDim(<span class="hljs-number"><span class="hljs-number">3</span></span>)] W: TVector; [TDim(<span class="hljs-number"><span class="hljs-number">4</span></span>)] Color: TVector; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TMovementScheme = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FMovement: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TMovement; [TDim(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)] FOrientation: TMatrix; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Below is the code that initializes objects of type TVector and TMatrix based on information taken from attributes. <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Obj, TypeInfoOfObj: Pointer; Offset: Integer = 0)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DefaultRowCount = <span class="hljs-number"><span class="hljs-number">3</span></span>; DefaultColCount = <span class="hljs-number"><span class="hljs-number">3</span></span>; VectorTypeName = <span class="hljs-string"><span class="hljs-string">'TVector'</span></span>; MatrixTypeName = <span class="hljs-string"><span class="hljs-string">'TMatrix'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> RTTIContext: TRttiContext; Field : TRttiField; ArrFld: TRttiArrayType; I: Integer; Dim: TCustomAttribute; RowCount, ColCount: Integer; OffsetFromArray: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> RTTIContext.GetType(TypeInfoOfObj).GetFields <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Field.FieldType &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RowCount := DefaultRowCount; ColCount := DefaultColCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Dim <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Field.GetAttributes <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RowCount := (Dim <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TDim).RowCount; ColCount := (Dim <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TDim).ColCount; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Field.FieldType.TypeKind = tkArray <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ArrFld := TRttiArrayType(Field.FieldType); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ArrFld.ElementType.TypeKind = tkRecord <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> I := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ArrFld.TotalElementCount - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> OffsetFromArray := I * ArrFld.ElementType.TypeSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ArrFld.ElementType.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> = VectorTypeName <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PVector(Integer(Obj) + Field.Offset + OffsetFromArray + Offset)^ := TVector.Create(RowCount) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ArrFld.ElementType.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> = MatrixTypeName <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PMatrix(Integer(Obj) + Field.Offset + OffsetFromArray + Offset)^ := TMatrix.Create(RowCount, ColCount) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Init(Obj, ArrFld.ElementType.Handle, Field.Offset + OffsetFromArray); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Field.FieldType.TypeKind = tkRecord <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Field.FieldType.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> = VectorTypeName <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PVector(Integer(Obj) + Field.Offset + Offset)^ := TVector.Create(RowCount) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Field.FieldType.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> = MatrixTypeName <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> PMatrix(Integer(Obj) + Field.Offset + Offset)^ := TMatrix.Create(RowCount, ColCount) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Init(Obj, Field.FieldType.Handle, Field.Offset) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The Init () procedure receives as input the address of the container object and its RTTI data.  Further, a recursive traversal of all container fields occurs, and for all counter fields with the names of the types ‚ÄúTVector‚Äù and ‚ÄúTMatrix‚Äù their constructors will be explicitly called. <br>  Let's modify the TMovementScheme class using the Init () procedure: <br><br><pre> <code class="delphi hljs">TMovementScheme = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMovementScheme</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Init(Self, Self.ClassInfo); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Init () call option for arbitrary writing: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Movement: TMovement; . . . Init(@Movement, TypeInfo(TMovement));</code> </pre> <br>  By default, Init () creates vectors with three elements, and 3x3 matrices, so in the declaration of the types TMovement and TMovementScheme, the attributes [TDim (3)] and [TDim (3, 3)] can be omitted, leaving only [TDim (4) ]. <br><br>  Attached to the article is a <a href="https://yadi.sk/d/1SVzhNeM3QKBEU">file</a> in which the implementation of the described ideas is given in full. </div><p>Source: <a href="https://habr.com/ru/post/340612/">https://habr.com/ru/post/340612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340592/index.html">How does mobx work from the inside and compare it with redux</a></li>
<li><a href="../340600/index.html">In search of perfect architecture</a></li>
<li><a href="../340602/index.html">How I stopped selling food on the street and started working in top technology companies</a></li>
<li><a href="../340604/index.html">Your own std :: code_error</a></li>
<li><a href="../340610/index.html">UI design in games on the example of NieR: Automata</a></li>
<li><a href="../340616/index.html">OSX / Proton backdoor distributed with Trojanized Elmedia Player</a></li>
<li><a href="../340618/index.html">Security Week 42: KRACK WiFi, a hole in Intel processors, 250 Oracle patches</a></li>
<li><a href="../340620/index.html">A bug in finding emails on Mail.Ru</a></li>
<li><a href="../340626/index.html">The world in which IPv6 is well invented</a></li>
<li><a href="../340630/index.html">Work with Arduino's COM port from a Java application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>