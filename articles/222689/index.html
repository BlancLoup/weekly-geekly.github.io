<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Inverse kinematics: simple and fast algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is Inverse Kinematics? 

 The task of inverse kinematics is the search for such a set of articulation configurations that would ensure the most g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Inverse kinematics: simple and fast algorithm</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/df9/f20/725/df9f2072581cead5a43e9d81d81f0391.png" align="left" width="300">  What is Inverse Kinematics? <br><br>  The task of inverse kinematics is the search for such a set of articulation configurations that would ensure the most gentle, fast and accurate movement to the specified points.  However, many methods currently existing suffer from such disadvantages as high computational complexity and unnaturalness of the resulting postures.  This article describes a new ( <i>probably, at the time of writing the article - 2010</i> ) heuristic method called <i>Forward and Backward</i> Reverse Method ( <i>Forward and Backward Reaching Inverse Kinematics</i> , hereinafter simply FABRIK), <br>  FABRIK avoids the use of rotations and matrices in favor of directly obtaining a point on a straight line.  Due to this, the matter costs only a few iterations, has a low computation cost and a visually natural posture as a result.  FABRIK also cope with the imposition of restrictions as well as the use of multiple chains and / or end points.  It is about this method of this post. <br><a name="habracut"></a><br><br>  <i>I ask you to treat this squeeze with understanding, because the original is quite large, has a lot of water, relevant and inappropriate repetitions and separations from the topic, as well as comparisons with other algorithms.</i>  <i>I decided to nevertheless neglect this, therefore, here there is only a small part of the text, which, however, reflects the essence - approx.</i>  <i>trans.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  1. Artificial body model </h3>  A system of many solids consists of a set of solids, called nodes, connected together by edges.  All edges are components associated with motion: they restrict movement within a certain angle relative to adjacent edges.  Virtual body modeling is important for calculating a person‚Äôs posture.  A model with properly placed restrictions will allow you to get a set of correct poses, which will give you the opportunity to get a more realistic movement.  Most models imply the hardness of body parts, although this is just an approximate approximation to reality. <br>  The skeleton is usually modeled as a hierarchy of solid segments connected by edges, each of which is given by such properties as length, shape, volume and mass.  The manipulator, in the manner of a robo-arm or an animated character, is modeled as a chain, assembled from solid knots, conjugated with each other by edges.  Each movement and / or rotation of the bone with the index i affects all subsequent elements of the chain.  A chain can be formalized as follows: every node without children should be the end point;  for each end point, the chain can be formed backward in the skeleton, from parent to parent, until the root node of the chain (the beginning of the chain) is encountered.  By definition, the IK problem assumes that the root node is static.  However, methods usually cope with the movement of the root. <br><br><div class="spoiler">  <b class="spoiler_title">The algorithm of the full cycle algorithm FABRIK (pseudocode, the first element of the array under the index 1)</b> <div class="spoiler_text"><pre><code class="cs hljs"> :    p[i]  i = <span class="hljs-number"><span class="hljs-number">1.</span></span>..n,   t      . d[i] = | p[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] - p[i] | <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, ... , n<span class="hljs-number"><span class="hljs-number">-1</span></span>  :   p[i], i = <span class="hljs-number"><span class="hljs-number">1.</span></span>..n <span class="hljs-comment"><span class="hljs-comment">//     dist = | p[1] - t | //   if dist &gt; d[1] + d[2] + ... + d[n-1] { //  for i = 1, ..., n-1 do { //  r[i]   t   p[i] r[i] = | t - p[i] | lambda[i] = d[i] / r[i] //    p[i] p[i+1] = (1 - lambda[i]) * p[i] + lambda[i] * t } } else { // ; .. b     p[1] b = p[1] //,        p[n]  //  t   (tolerance) DIFa = | p[n] - t | while DIFa &gt; tol do { // 1 :   //   p[n]    (,   "   " - . .) p[n] = t for i=n -1 , ..., 1 do { //  r[i]   p[i]    p[i+1] r[i] = | p[i+1] - p[i] | lambda[i] = d[i] / r[i] //    p[i] p[i] = ( 1 - lambda[i]) * p[i+1] + lambda[i] * p[i] } // 2:   //   p[1]   p[i] = b for i=1 ,..., n - 1 do { //  r[i]   p[i+1]   p[i] r[i] = | p[i+1] - p[i] | lambda[i] = d[i] / r[i] //   p[i] p[i+1] = (1-lambda[i]) * p[i] + lambda[i] * p[i+1] } DIFa = | p[n] - t | } }</span></span></code> </pre> <br></div></div><br><br><h3>  2.FABRIK - a new heuristic solution of the IK problem </h3><img src="https://habrastorage.org/getpro/habr/post_images/cbb/a07/478/cbba07478260189141a1de4b70de9ce2.jpg" align="left">  This section provides the essence of the FABRIK method.  It uses positions already calculated in forward and reverse modes.  FABRIK minimizes the error by adjusting the angle of each node once.  Those.  the whole chain is traversed, starting from the last node, with adjustment of the angle of each bypass node, after which the chain is already traversed in the opposite direction.  This method, in contrast to the transformation of rotations, turns the problem of finding the position of a node into the problem of finding a point on a line;  therefore, you can save time and reduce the number of calculations.  Suppose that the set <nobr><b>p [1], ..., p [n]</b></nobr> is the set of positions of the nodes of the manipulator.  Also, suppose that <b>p [1]</b> is a root node and <b>p [n]</b> is an end node, so  for simplicity, leave one end node.  The target is represented by the position <b>t</b> and the initial base position <b>b</b> .  The FABRIK method is shown in the listing above and in the graphical interpretation of the complete cycle in the figure to the left, with one target point and four nodes in the circuit.  Consider the full cycle of the algorithm in the figure: <br><ul><li>  <b>a</b> - The initial positions of the manipulator and the target. <br></li><li>  <b>b</b> - Move end node <b>p [4]</b> to the target. <br></li><li>  <b>c</b> - We find the position of <b>p '[3]</b> , lying on the line between the positions of <b>p' [4]</b> and <b>p [3]</b> , at a distance <b>d [3]</b> from point <b>p '[4]</b> . <br></li><li>  <b>d</b> - Repeat for all nodes. <br></li><li>  <b>e</b> - The second stage of the algorithm: move the root element from the position <b>p '[1]</b> to its initial position. <br></li><li>  <b>f</b> - Repeat for all nodes, but this time we start from the base and move to the end node.  The algorithm is repeated until the position of the final element is close to the target for a sufficient distance. <br></li></ul><br><br>  In details: <br>  First, the positions between the nodes are considered (array <b>d</b> ), after which it is checked whether the target point is reachable;  the distance between the root node and the target ( <b>dist</b> ) is considered, and if this distance is less than the total sum of the distances between the nodes, then the goal is achievable, otherwise there is no.  If the goal is attainable, the full cycle is limited to two stages.  At the first stage, the algorithm estimates the initial position of each node, starting from the final element <b>p [n]</b> moving to the base of the manipulator <b>p [1]</b> .  Thus, let the target position be the position of the end node, <b>p '[n]</b> = <b>t</b> .  We obtain the line <b>l [n-1]</b> lying on the points <b>p [n-1]</b> and <b>p '[n]</b> .  The new position of the node with the index <b>n-1</b> , <b>p '[n-1]</b> , lies on this line at a distance <b>d [n-1]</b> from <b>p' [n]</b> .  Similarly, the new position of the node with the index <b>n-2</b> , <b>p '[n-2]</b> , can be calculated using the straight line <b>l [n-2]</b> lying on the points <b>p [n-2]</b> and <b>p' [n-1]</b> at a distance <b>d [n-2]</b> from <b>p '[n-1]</b> .  The algorithm is repeated until all new positions are calculated for all nodes, including the final one.  In cases where the root element moves to the desired position, FABRIK operates as described, with the only difference that the new position <b>p '' [1] of the</b> root node will be the desired position, not the initial one. <br>  After one complete iteration, in almost all cases (as observed), the end node will approach the target.  The procedure will be repeated as many times as necessary, until the end node lies on the target position or approaches it at the allowable distance.  Implementation of the FABRIK method without introducing limiters will converge at any target point / chain if the goal is attainable.  However, if the target is further than the reach to which the chain can stretch, an interrupting condition is needed that compares the past and current position of the end node, and which terminates the algorithm if the end node offset is less than a certain value (epsilon).  Also, in special cases, the algorithm is interrupted after a certain number of iterations (however, such a situation has not yet been encountered). <br>  For faster results and solutions in several iterations, optimization with the use of Conformal Geometric Algebra (hereinafter CGA) is possible;  CGA has an advantage on basic shapes, such as spheres, straight lines, planes and circles, which are fairly simply displayed by algebraic objects.  Therefore, the search for the position of a node located between two known nodes can be expressed by the intersection of two spheres with the centers at the corresponding positions of these nodes, and a radius equal to the distance between the positions of the desired node and the existing ones;  The new position of the node will lie on the nearest point of the circle formed by the intersection of the two spheres.  Another simple optimization is the direct construction of a straight line in the direction of the goal, when the latter is not available. <br><br><h3>  3. Model with multiple end nodes </h3><img src="https://habrastorage.org/getpro/habr/post_images/ed2/29f/2a5/ed229f2a51ea1ce9bf10a743ca779bb0.jpg" align="right" width="400">  As in the case of a single end node, the algorithm is divided into two stages: <br><ul><li>  The first stage is exactly the same, only this time it starts from each end node with movement inwards along the chain from this node, up to the sub-base (probably the sub-base is a node with several adjacent edges - approx. Transl.) .  Thus, we will get as many different positions for a subbase as we have end nodes connected to it.  The total position can be taken as a centroid (tobish, just the arithmetic mean - approx. Transl.) From these positions.  After that, the execution of the algorithm continues in the normal mode, moving from the sub-base to the root.  If sub-bases have their own sub-bases, then similar actions are performed on them - a list of possible positions is also compiled, after which this sub-base is set to a centroid from the entire list of positions. <br></li><li>  At the second stage, the usual algorithm is applied to each node, moving further away from the root node.  At the same time, each chain must be processed separately up to the end node: the more sub-bases, the more repetitions for each of them.  The process is repeated until the end nodes reach their goal or until the interrupt condition is triggered. <br></li></ul><br><br><h3>  4. Limiters </h3>  And finally, the most tasty part of this article is calculations using limiters.  They are needed, as it was worth guessing, for greater similarity with real organisms.  The node itself is usually characterized by three degrees of freedom.  Rotation of a node can be characterized as ‚Äúsimple rotation‚Äù (2 degrees of freedom), which reflects its final position, and rotation around its own axis (1 degree of freedom).  Thus, by dividing the movement of a node into two such phases, and applying constraints to them, you can control the position of the node.  The restrictions themselves can be imposed in a similar way:  the algorithm is iterative, it is possible to apply rotation restrictions at each iteration of the algorithm.  Limiters, however, will not affect the convergence of the algorithm.  The main idea of ‚Äã‚Äãusing limiters is to reposition and reorient nodes within limits. <br><img src="https://habrastorage.org/getpro/habr/post_images/a80/7ad/78d/a807ad78dd5ae257e52a5445b3a2ba5b.jpg" align="left"><ul><li>  <b>a</b> - Initial manipulator and target configurations. <br></li><li>  <b>b</b> - Move the end node <b>p [4]</b> to the target and orient it to it. <br></li><li>  <b>c</b> - We find the position of <b>p '[3]</b> , lying on the line between the positions of <b>p' [4]</b> and <b>p [3]</b> , at a distance <b>d [3]</b> from point <b>p '[4]</b> . <br></li><li>  <b>d</b> - Reorient the node at position <b>p '[3]</b> so that it looks along the edge connecting <b>p' [3]</b> and <b>p '[4]</b> . <br></li><li>  <b>e</b> - Calculate bounding ellipse: the allowed positions are in the shaded area.  None of the vertices at this stage moves anywhere. <br></li><li>  <b>f</b> - The node <b>p [2]</b> moves to the position <b>p ^ [2]</b> , which is the closest position on the shaded ellipse, thus making sure that the new position <b>p ^ [2]</b> will lie within acceptable limits. <br></li><li>  <b>g</b> - Move the node <b>p ^ [2]</b> to the point <b>p '[2]</b> in order to maintain the length of the edge. <br></li><li>  <b>h</b> - Reorient <b>p '[2]</b> to satisfy constraint orientation. <br></li></ul><br>  This procedure is repeated for all nodes, in the direct and reverse order, in the same way as in the unrestricted version of the movement.  <i>At the same time, the ‚Äúellipse‚Äù constraint is probably a characteristic of an edge, not a node, that is,</i>  <i>in the second phase, the <b>p [3]</b> node should move into an ellipse - approx.</i>  <i>trans.</i> </div><p>Source: <a href="https://habr.com/ru/post/222689/">https://habr.com/ru/post/222689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../222673/index.html">How to add help desk to your YouTrack tracker</a></li>
<li><a href="../222675/index.html">Machine learning for the intellectualization of your applications</a></li>
<li><a href="../222679/index.html">Programming-by-Contract in Java</a></li>
<li><a href="../222681/index.html">Work environment for SMM specialist</a></li>
<li><a href="../222687/index.html">Stroking the brain ASMR</a></li>
<li><a href="../222691/index.html">Wheel with integrated suspension for bicycle or wheelchair</a></li>
<li><a href="../222693/index.html">We had the Kotlin Challenge: what is the final?</a></li>
<li><a href="../222695/index.html">ProfitTask - a platform for creating custom activities</a></li>
<li><a href="../222699/index.html">Super speed star will help to study the dark matter</a></li>
<li><a href="../222703/index.html">Empty Active Directory Recycle Bin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>