<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We finish HTTP caching in Django</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post focuses on HTTP caching ( translation ) and its use in conjunction with the Django framework. Few would argue with the statement that using ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We finish HTTP caching in Django</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/redmadrobot/blog/305774/"><img src="https://habrastorage.org/files/ea8/e35/828/ea8e3582889040839d40c1ba58b738a9.png" alt="image" align="right"></a> <br>  This post focuses on <a href="https://www.mnot.net/cache_docs/">HTTP caching</a> ( <a href="https://habrahabr.ru/post/203548/">translation</a> ) and its use in conjunction with the Django framework.  Few would argue with the statement that using HTTP caching is a very correct and reasonable practice of developing web applications.  However, it is in this functional that Django contains a number of errors and inaccuracies that severely limit the practical benefits of this approach.  For example, the bug <a href="https://code.djangoproject.com/ticket/15855"># 15855</a> , instituted in April 2011, is still relevant, which can lead to very unpleasant errors in the operation of the web application. <br><br><h2>  Middleware vs.  explicit decorator </h2><br>  There are two standard ways to enable HTTP caching in Django: by activating <strong>UpdateCacheMiddleware</strong> / <strong>FetchFromCacheMiddleware</strong> , or by decorating the presentation function using the <strong>cache_page</strong> decorator.  The first method has one major drawback - it includes HTTP caching for all project views (view) without exception, but the second one contains the same # 15855 bug.  If it were not for this bug, the option using cache_page would be preferable.  Plus, this option is in good agreement with the most important of the postulates of <a href="https://www.python.org/dev/peps/pep-0020/">The Zen of Python</a> , which is ‚Äúobvious better than implicit‚Äù. <a name="habracut"></a><br><br>  The reason for the appearance of # 15855 lies in the mechanism for processing Django requests using so-called middleware.  Schematically, this mechanism is shown in the figure below. <br><div style="text-align:center;"><img src="https://docs.djangoproject.com/en/1.9/_images/middleware.svg" alt="image"></div><br>  Decorators for the views on the diagram are located along with the views themselves (view function), that is, after they have been worked out, each middleware has the opportunity to additionally affect the final result (HttpResponse).  For example, SessionMiddleware does this by adding a Vary header with the value ‚ÄúCookie‚Äù to the response if inside the view function there was an access to the session (a normal case when working with authorized users).  Disregarding the Vary header values ‚Äã‚Äãwhile maintaining the cache may cause the application user to retrieve data from another user's cache.  By the way, in the comments to the described bug there are examples of its solution specifically for the case of SessionMiddleware, but the problem is also relevant when using other middleware, for example, LocaleMiddleware, which expands the Vary header with the ‚ÄúAccept-Language‚Äù value. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Fix bug </h2><br>  For a complete fix # 15855, you must update the HttpResponse cache after all middleware have been processed.  Now it is clear why in the case of UpdateCacheMiddleware / FetchFromCacheMiddleware this error does not exist, because if we put UpdateCacheMiddleware above all other middleware, then it is executed last and takes into account all the response headers.  The only non-middleware way to implement a similar solution is to process the <strong>request_finished</strong> signal.  But in this method there are two problems that need to be solved: first, the signal handler does not receive information about the current request / response, and second, the signal is sent after the response has been sent to the client.  To update the cache, the second item is in general irrelevant (we can update the cache after sending the answer), but we need to add our own headers - <strong>Expires</strong> and <strong>Cache-Control</strong> (the most important!) To the response, which we cannot do if The request has already been processed. <br><br>  Before proceeding, you should familiarize <a href="https://github.com/django/django/blob/stable/1.10.x/django/views/decorators/cache.py">yourself</a> with the source code of the original <a href="https://github.com/django/django/blob/stable/1.10.x/django/views/decorators/cache.py">cache_page</a> decorator.  As you can see, it is based on the same UpdateCacheMiddleware and FetchFromCacheMiddleware, which in general is not surprising, because the tasks they solve are the same.  We can do the same and write our own decorator, who will use the slightly modified versions of the mentioned middleware: <br><div class="spoiler">  <b class="spoiler_title">cache_page.py</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.utils <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> decorators <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> .middleware <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CacheMiddleware <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cache_page</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(**kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    django.views.decorators.cache.cache_page """</span></span> cache_timeout = kwargs.get(<span class="hljs-string"><span class="hljs-string">'cache_timeout'</span></span>) cache_alias = kwargs.get(<span class="hljs-string"><span class="hljs-string">'cache_alias'</span></span>) key_prefix = kwargs.get(<span class="hljs-string"><span class="hljs-string">'key_prefix'</span></span>) decorator = decorators.decorator_from_middleware_with_args(CacheMiddleware)( cache_timeout=cache_timeout, cache_alias=cache_alias, key_prefix=key_prefix, ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> decorator</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">middleware.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.middleware <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cache <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> cache_middleware <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheMiddleware</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(cache_middleware.CacheMiddleware)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-comment"><span class="hljs-comment">#   middleware,      </span></span></code> </pre><br></div></div><br>  First, let's solve two existing problems with request_finished, which I mentioned earlier.  We know for sure that only one request is processed at the same time in one thread, which means that the current response can be saved to the user, correctly, in <strong>threading.local</strong> .  We do this at the moment when the management is still at the decorator's place in order to subsequently use it in the request_finished handler.  Thus, we can ‚Äúkill two birds with one stone‚Äù: adding Expires and Cache-Control headers before sending a response to the client and deferred saving to the cache with all possible changes: <br><div class="spoiler">  <b class="spoiler_title">middleware.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> signals <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.middleware <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cache <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> cache_middleware response_handle = threading.local() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheMiddleware</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(cache_middleware.CacheMiddleware)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super(CacheMiddleware, self).__init__(*args, **kwargs) signals.request_finished.connect(update_response_cache) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, response)</span></span></span><span class="hljs-function">:</span></span> response_handle.response = response <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> super(CacheMiddleware, self).process_response(request, response) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_response_cache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   request_finished """</span></span> response = getattr(response_handle, <span class="hljs-string"><span class="hljs-string">'response'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  response if response: try: pass #  response   finally: response_handle.__dict__.clear()</span></span></code> </pre><br></div></div><br>  But in this simplest case, saving to the cache will occur twice, and for the first time without taking into account all values ‚Äã‚Äãof Vary.  Technically, this problem can be solved.  Who cares, under the spoiler below set out such a solution. <br><div class="spoiler">  <b class="spoiler_title">middleware.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> contextlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> signals <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.core.cache.backends.dummy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DummyCache <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.middleware <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cache <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> cache_middleware <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.utils <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> http, cache response_handle = threading.local() dummy_cache = DummyCache(<span class="hljs-string"><span class="hljs-string">'dummy_host'</span></span>, {}) @contextlib.contextmanager <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">patch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj, attr, value, default=None)</span></span></span><span class="hljs-function">:</span></span> original = getattr(obj, attr, default) setattr(obj, attr, value) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> setattr(obj, attr, original) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheMiddleware</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(cache_middleware.CacheMiddleware)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super(CacheMiddleware, self).__init__(*args, **kwargs) signals.request_finished.connect(update_response_cache) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, response)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._should_update_cache(request, response): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> super(CacheMiddleware, self).process_response(request, response) response_handle.response = response response_handle.request = request response_handle.middleware = self <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> patch(cache_middleware, <span class="hljs-string"><span class="hljs-string">'learn_cache_key'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> *_, **__: <span class="hljs-string"><span class="hljs-string">''</span></span>): <span class="hljs-comment"><span class="hljs-comment">#        ( ) with patch(self, 'cache', dummy_cache): #       ,  #   response     , #       Vary, # . https://code.djangoproject.com/ticket/15855 return super(CacheMiddleware, self).process_response(request, response) def update_cache(self, request, response): with patch(cache_middleware, 'patch_response_headers', lambda *_: None): #      response  super(CacheMiddleware, self).process_response(request, response) def update_response_cache(*args, **kwargs): middleware = getattr(response_handle, 'middleware', None) request = getattr(response_handle, 'request', None) response = getattr(response_handle, 'response', None) if middleware and request and response: try: CacheMiddleware.update_cache(middleware, request, response) finally: response_handle.__dict__.clear()</span></span></code> </pre><br></div></div><br><h2>  Eliminate other inaccuracies </h2><br>  At the beginning I mentioned that Django contains several errors in the HTTP caching mechanism, and it is.  And the bug solved above is not the only one, although the most critical one.  Another inaccuracy of Django is that when reading a saved query from the cache, the value of the max-age parameter of the Cache-Control header is returned as it was when the response was saved in the cache, that is, the max-age may not correspond to the Expires header value due to the difference in time between these two events.  And since browsers prefer to use Cache-Control instead of Expires, we get another error.  Let's solve it.  To do this, our middleware needs to override the ‚Äúprocess_request‚Äù method: <br><div class="spoiler">  <b class="spoiler_title">process_request</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> response = super(CacheMiddleware, self).process_request(request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> response <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'Expires'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response: <span class="hljs-comment"><span class="hljs-comment">#  'max-age'  'Cache-Control' # ,    'Expires' expires = http.parse_http_date(response['Expires']) timeout = expires - int(time.time()) cache.patch_cache_control(response, max_age=timeout) return response</span></span></code> </pre><br></div></div><br>  If there is no urgent need to save all HTTP responses in the cache (and only HTTP caching headers are needed), then instead of everything described above in the project settings, you can replace the main cache driver with the fake one (this solution also protects against the consequences # 15855 ): <br><pre> <code class="python hljs">CACHES = { <span class="hljs-string"><span class="hljs-string">'default'</span></span>: { <span class="hljs-string"><span class="hljs-string">'BACKEND'</span></span>: <span class="hljs-string"><span class="hljs-string">'django.core.cache.backends.dummy.DummyCache'</span></span>, }, }</code> </pre><br>  Further, it is not clear why, but UpdateCacheMiddleware, in addition to the standard Expires and Cache-Control, also adds the Last-Modified and ETag headers.  And this is despite the fact that FetchFromCacheMiddleware does not process the corresponding requests in any way (with the headers of If-Modified-Since, If-None-Match, etc.).  There is a violation of the fundamental <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D0%25B1%25D1%258F%25D0%25B7%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">principle of a single duty</a> .  I suppose the calculation was that the developer would not forget to include ConditionalGetMiddleware or at least CommonMiddleware, the benefits of which are in fact very doubtful, and I never turn them on in my projects.  Moreover, if something still returns 304 Not Modified (this happens, for example, when using last_modified or etag decorators), then such a response will not get caching headers (Expires and Cache-Control), which will cause the browser to return again and again (and get 304 Not Modified), despite the fact that we seemingly enabled HTTP caching, which should tell the browser that there is no point in going back in time for the specified time.  We eliminate this inaccuracy in the ‚Äúprocess_response‚Äù: <br><div class="spoiler">  <b class="spoiler_title">process_response</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request, response)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._should_update_cache(request, response): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> super(CacheMiddleware, self).process_response(request, response) last_modified = <span class="hljs-string"><span class="hljs-string">'Last-Modified'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response etag = <span class="hljs-string"><span class="hljs-string">'ETag'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> response <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> response.status_code == <span class="hljs-number"><span class="hljs-number">304</span></span>: <span class="hljs-comment"><span class="hljs-comment">#    Not Modified  Expires  Cache-Control cache.patch_response_headers(response, cache_timeout) else: response_handle.response = response response_handle.request = request response_handle.middleware = self with patch(cache_middleware, 'learn_cache_key', lambda *_, **__: ''): #        ( ) with patch(self, 'cache', dummy_cache): #       ,  #   response     , #       Vary, # . https://code.djangoproject.com/ticket/15855 response = super(CacheMiddleware, self).process_response(request, response) if not last_modified: #   Last-Modified,        del response['Last-Modified'] if not etag: #   ETag,        del response['ETag'] return response</span></span></code> </pre><br></div></div><br>  It is worth explaining a little here that if we want Expires and Cache-Control headers to be added to the 304 Not Modified response, then the last_modified and etag decorators should go after the cache_page, otherwise the latter will not have the chance to process these type of responses: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@cache_page(cache_timeout=3600) @etag(lambda request: 'etag') def view(request): pass</span></span></code> </pre><br><h2>  Adding useful features </h2><br>  Having eliminated all the shortcomings, you suddenly realize that in the resulting solution, well, there is very little opportunity to set a calculated (on-demand) value of the caching time, especially if you look at the last_modified decorators and etag, where such an opportunity exists. <br><br>  And that is not all.  I would also like to somehow cleverly invalidate the cache, for example, when changing the returned entity.  It is most convenient to do this by automatically changing the key for the cache, that is, you also want to set the key not statically, but calculate on-demand. <br><br>  The simplest and most elegant way to realize both of these needs is to set the necessary parameters in the form of a lazy expression: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> django.utils.functional <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lazy @cache_page( cache_timeout=lazy(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: <span class="hljs-number"><span class="hljs-number">3600</span></span>, int)(), key_prefix=lazy(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span>: <span class="hljs-string"><span class="hljs-string">'key_prefix'</span></span>, str)(), ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  In this case, the function passed as an argument to lazy will only be executed (and always) when an attempt is made to refer to the expression in the context of the types specified by the subsequent arguments. <br><br>  Another more flexible way is the ability to pass ordinary values ‚Äã‚Äãfor the cache_timeout and key_prefix values ‚Äã‚Äãwith the signature corresponding to the presentation function: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@cache_page( cache_timeout=lambda request, foo: 3600, key_prefix=lambda request, foo: 'key_prefix', ) def view(request, foo): pass</span></span></code> </pre><br>  This option would allow to calculate cache_timeout and key_prefix based on the request itself and its parameters, but it requires one more refinement.  In order not to bore the reader with large chunks of source code, I will simply give a link to the component, where this and everything mentioned above is already implemented as a separate Python module: <a href="https://github.com/renskiy/django-cache">django-cache</a> . <br><br><h2>  Conclusion </h2><br>  I did not mention one more useful feature that it would be nice to have, about the client‚Äôs ability to force the server to skip the cache, so that the latter would give the most recent data to the client‚Äôs request.  This is done using the Cache-Control request header: max-age = 0.  In django-cache, there is no such possibility yet, but perhaps in the future such an option will appear. <br><br>  <b>UPD</b> : the mentioned option still <a href="https://github.com/renskiy/django-cache/pull/7">appeared</a> . <br><br>  Anticipating questions on the topic of why all fixes and new features should not be immediately attributed to Django, I will answer that I plan to do this in the near future.  But the new features will only get into the next version of Django, most likely already in 1.11, and django-cache can already work with all the latest versions (starting with 1.8).  Although bug fixes are added, as a rule, in all currently supported branches. <br><br><h2>  Another bug </h2><br>  When the note was already being prepared for publication, on one of the projects I found another inaccuracy in the Django query caching functionality.  Its essence is that the so-called conditional requests (containing If-Modified-Since headers, etc.), the cache_page always tries to get the result from the cache and, if successful, returns a response with the code 200. This behavior is undesirable in cases where the handler request may return 304 Not Modified.  Fix code <a href="https://github.com/renskiy/django-cache/pull/5">here</a> . <br><br>  <b>UPD</b> : in fact, you can do <a href="https://github.com/renskiy/django-cache/pull/8">without threading.local and signals</a> if you add a special ‚Äúcallback‚Äù to the <b>response._closable_objects</b> list, which will save the response to the cache after all the middleware have been processed. </div><p>Source: <a href="https://habr.com/ru/post/305774/">https://habr.com/ru/post/305774/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305754/index.html">Security Week 28: Pok√©mon Privacy, Critical Online Infrastructure, Post-Quantum Cryptography in Chrome</a></li>
<li><a href="../305756/index.html">Path to React</a></li>
<li><a href="../305760/index.html">Internet advertising trends: from video to virtual reality</a></li>
<li><a href="../305766/index.html">Russian schoolchildren took four gold medals at the International Mathematics Olympiad in Hong Kong</a></li>
<li><a href="../305768/index.html">Thin client Win2008 R2 (AD + TFTP) + thinkstation + Win2008 R2 (RDP)</a></li>
<li><a href="../305776/index.html">How to approach the creation of a complex product: 3 tips for developers</a></li>
<li><a href="../305778/index.html">Intensive product design from the Mail.Ru Group team in the British</a></li>
<li><a href="../305780/index.html">New Tropical Data Center (TDC) Initiative</a></li>
<li><a href="../305782/index.html">Easter eggs in Mr Robot S02E01</a></li>
<li><a href="../305784/index.html">From design to development: 10 tools to help improve and optimize workflow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>