<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fastware</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Andrei Alexandrescu is a real living legend. This is a person who has made a significant contribution to the history of modern programming languages ‚Äã...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fastware</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://en.wikipedia.org/wiki/Andrei_Alexandrescu">Andrei Alexandrescu</a> is a real living legend.  This is a person who has made a significant contribution to the history of modern programming languages ‚Äã‚Äãand techniques of generalized and metaprogramming.  How many copies were broken in the discussions of <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25B2%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BD%25D0%25B0_%25D0%25A1%252B%252B:_%25D0%259E%25D0%25B1%25D0%25BE%25D0%25B1%25D1%2589%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B8_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BA%25D0%25BB%25D0%25B0%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D1%258B_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">"Modern Design in C ++"</a> and <a href="https://www.oreilly.com/library/view/c-coding-standards/0321113586/">"Coding Standards 101"</a> (written with the Exceptional C ++ Emblem Satter), and other <a href="http://erdani.com/index.php/articles">books and articles</a> .  Being a co-author <a href="https://ru.wikipedia.org/wiki/D_(%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">of D</a> , he had the opportunity not only to theorize, but also to make the dream a reality - and, characteristically, he <a href="https://dlang.org/overview.html">embodied it</a> . <br><br>  Now you are holding in your hands his <a href="https://dotnext-piter.ru/2018/spb/talks/2qatbxw8hsucaikiosmoem/">report</a> from the DotNext 2018 Piter conference, which tells about modern optimization technologies.  What does it have .NET?  This is a fundamental report from a person who has been optimizing all his life.  If performance is important to you, you need to watch it (or read this article).  Welcome under the cut! <br><br><img width="100%" src="https://habrastorage.org/webt/9_/mg/9m/9_mg9mjeeamxyknlbdqeg4ukoa4.jpeg"><br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZazBhE1IQd0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  The art of benchmarking </h1><br>  I would like to discuss a few benchmarking topics with you.  First, let's repeat some basic things.  <b>Amdal's law</b> is part of the computer science classic, it is mainly used in parallel computing, but it works in any complex system.  If we want to improve the performance of a certain system, then we must begin where the main problems of this system are concentrated.  The law itself is obvious: if a component is 20% of the system, then the maximum improvement in system performance, which can be achieved by optimizing the work of only this component, is 20%.  I too often have to meet with people (our readers, of course, do not belong to them) doing things like optimizing command-line parsing.  These operations take the first 10 microseconds of the work of your program, and people analyze their algorithmic complexity and are terrified if the time turns out to be quadratic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As you probably know, before starting the optimization, it is necessary to profile the application, select hot spots in it.  Here it should be said about the <b>law of Ladma</b> (this is not the real last name, but Amdal, read backwards).  You need to focus your efforts on the component that leads to the most time consuming.  It needs to be taken out of the application, carry out the necessary work, return it back and test it again.  The reason for doing this is that, very often, a 20% performance improvement is the result of ten improvements of 2% each.  And within the framework of a large system, it is impossible to measure such a small improvement.  To do this, the component must be tested in a test suite.  Improving the performance of one of the main components of the system by 20% can mean an improvement of 5% for the system as a whole, and for some areas this is an excellent result.  Do not forget that optimizations can have a whole range of global effects, so, based on the results of selective benchmarking, it is worth making very careful conclusions about the operation of the system as a whole. <br><br>  A mistake that, I am sure, our readers do not allow, but which in general is quite common: people measure the speed of the debug build.  This should never be done.  This is similar to getting upset because of the low speed of the snail at the races: it is not intended for such a competition, it has other goals in life.  Another error, somewhat less obvious: people first measure the basic indicators of the system, and immediately after that perform benchmarking.  But after collecting basic indicators, many resources are heated.  For example, open files are buffered and remain in memory (at least under Linux).  Thus, the second test will pass faster only because it is launched after the first.  This happens even with calls to malloc.  After these calls, the system does not return to its original state even if memory free calls are made.  The internal configuration, caching, and capabilities used by the memory allocator allow the following malloc calls to run much faster.  Even without taking into account the effect of the cache, malloc remembers that, for example, a certain function allocated memory for objects with a size of 4 kilobytes many times - this means that it is necessary to have a free list with an element size of 4 kilobytes.  Or another example: a DNS lookup is cached for reuse after the first request.  If possible, with benchmarking, you need to re-run the entire process from beginning to end. <br><br>  For example, in order to completely return the system to its original state, in the case of files, they need to be opened on a separate disk, which after the end of the test must be unmounted (as I understand it, this can be done under Windows).  The operation is not easy, but in most cases necessary. <br><br>  Continuing to talk about errors in optimization, I had to deal with such cases when the cost of printf is included in the test results.  There are also procedural errors when changing more than one thing before each measurement, which violates the most basic principles of a scientific experiment, since it turns out to be unclear what effect of which change you are measuring.  Another serious mistake is when some rare cases are optimized, which leads to pessimization in other situations. <br><br><img src="https://habrastorage.org/webt/rs/fj/lf/rsfjlfl8ndtxzczw96ur5jyeijo.jpeg"><br><br>  Here is an example from Stack Overflow.  The author often sorts already sorted data and is surprised, because the `is_sorted 'function is obviously much faster than` sort.  Why then in `sort the first line is not` if is_sorted return?  You are optimizing an extremely rare case, a completely sorted data, and everyone else who has at least one non-sorted element will have to bear the costs for this optimization.  So do not. <br><br>  I think I don‚Äôt have to prove for a long time that today's competing architectures are extremely complex: dynamic frequency changes, interruption by other processes, virtualization, etc.  Therefore, to get the same time when measuring is almost impossible, your indicators will always tremble.  Therefore, do not rely on things that seem obvious.  Say, it may seem obvious to us that a smaller number of instructions means a faster code, and this is not always true.  It may also appear that using stored data will always be faster than re-performing calculations, so if you cache the results, you will be fine.  As in the previous case, it cannot be unequivocally asserted, just as the opposite cannot be said unconditionally - it all depends on the context.  Obviously you should have only one thing: everything needs to be measured.  If you measure everything, you will get better results than experts with knowledge that do not measure. <br><br>  There are a number of fairly reliable practices, the discussion of which can push you into interesting thoughts.  You need to start with the fact that mathematics will not let you down.  It makes it possible to show that systems of different speeds can be equivalent.  Mathematics gives the rules to show the equivalence of certain things and to identify certain properties, and at the same time she is not biased, she does not care what things are interesting and which are not.  Many people think that optimization is based on knowledge of machine code and work with bits, but in fact there is a lot of math in it, because you prove that a faster system is equivalent to a slower one. <br><br>  Another general rule is that computers like to have everything boring.  Do you need to multiply two vectors, with a billion elements each?  This is an ideal task for a computer, all the equipment in it is specially sharpened for this kind of tasks.  I don‚Äôt want to do this to analyze this data, build a regular expression based on it.  Computers don't like things like branching, dependencies, indirect calls, in short - they don't like smart code, they like boring code.  Computers do not like indirect recording - a difficult problem that people involved in iron, have been fighting for a long time and can not solve. <br><br>  Another rule is that one should give preference to the least powerful operations, in other words, to prefer addition to multiplication, and multiplication to elevation.  Again, math is useful here. <br><br>  Finally, the last rule - the smaller, the more beautiful.  Small sizes allow computers to best realize their advantages, as they prefer that data, and especially instructions, be close to each other.  The results of several measurements of the speed of the application will always differ, you will have some distribution of results.  Usually we just take the average of these several results.  But the problem is that due to the specifics of computers, the average will involve a lot of noise.  When Bill Gates rides a bus, on average, every bus passenger turns out to be a billionaire.  It sounds great, but it is a poor consolation for a homeless person traveling on the same bus.  A similar situation arises with interruptions: the multiplication operation takes nanoseconds, but when you perform many measurements of such operations, one of them will inevitably have an interruption of two milliseconds.  The difference is in three orders, and yet, the developers do not always take this circumstance into account. <br><br>  So, I repeat: the noise in computers is always additive;  It may seem insignificant to people, but it is essential for microbenchmarking, and the arithmetic average will include a lot of noise.  Instead of the average, you need an indicator that will measure only the time that you can influence in any way.  If we approach this question from the point of view of mathematics, we will see that we need to find a value that will correspond to the greatest number of measurements we have made.  In other words, we need a mod.  This immediately brings us to the problem: what will happen if we take quicksort fashion?  If the algorithm is probabilistic or if the data is random, then there will almost never be a mod.  The density of values ‚Äã‚Äãwill be almost the same throughout the spectrum.  In this case, we simply discard the 5% of the largest measurements and then take the average value - or maximum, in the latter case we will have a ceiling that will not be exceeded in 95% of cases.  Almost always there will be some single subject sitting in the old basement with a slow modem, in which each page will load by the hour.  Purely human, we, of course, sympathize with him, but we cannot technically help everyone - so the remaining 5% of cases have to be neglected.  In general, when solving network problems, we often focus on the 95th percentile, because it is impossible to focus on the 100th.  The one-hundredth percentile will mean the slowest result from all collected measurements - this is not informative. <br><br><h1>  Replace branches with arithmetic </h1><br>  As I hope it became clear, measurement is not an easy problem.  Let's look at some examples and start by trying to replace branching with arithmetic.  We are talking about cases when we need an if statement, but at the same time its too frequent use is undesirable.  Instead, we will integrate the result of the branch as the value 0/1.  The code will look linear, the computer will just need to go through it from beginning to end, without thinking about exactly what step to take next. <br><br>  Let's try to solve the following problem: move the minima of each quartile of the array to the first quartile.  In other words, the array should be divided into four parts and the minimum value of each part should be placed at the beginning of the array. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = p.Length; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; n / <span class="hljs-number"><span class="hljs-number">4</span></span>; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  The above is the basic version of the code.  By the way, I can proudly announce that I translated these examples into C #, and they are successfully compiled.  The code itself is quite simple: `m is assigned the index of the smallest of the two values ‚Äã‚Äãlocated on the indices` i and `j, and then the same assignment is repeated two more times, depending on the other two indices.  Finally, the value at the index `m changes places in the array with the value at the index` i.  As you can see, we go around the array with the help of four inductive variables. <br><br>  The problem of testing such an algorithm will be interesting and not obvious.  We will need to test it not on a single set of data, but on data that might arise in various cases.  For example, on data that looks like pipes of an organ: first increase, then decrease;  on random data with a uniform distribution;  on a random set of zeros and ones - from just random data, the difference here is that there will be many duplicate values;  on already sorted data;  finally, on the data obtained by real measurements of some physical phenomenon.  This will be a serious approach to measuring the speed of an algorithm, and it is generally accepted among people who study algorithms. <br><br>  Let's try to improve the code that we have just met. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = n / <span class="hljs-number"><span class="hljs-number">4</span></span>, k = n / <span class="hljs-number"><span class="hljs-number">2</span></span>, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * n / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[k] &lt; p[m]) m = k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[l] &lt; p[m]) m = l; Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  As the first optimization, we will try to avoid excessive repetition of operations, for this we take out several division operations from the cycle - dividing `n into 2 and 4 and dividing 3 *` n into 4. But, having carried out this optimization, we find out that the calculations were not for We are the main problem: the code will not become faster, although it will be more compact.  At best, we will achieve an improvement of half a percent. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = q, k = <span class="hljs-number"><span class="hljs-number">2</span></span> * q, l = <span class="hljs-number"><span class="hljs-number">3</span></span> * q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i &lt; q; ++i, ++j, ++k, ++l) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[j] ? i : j; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[k] &lt;= p[l] ? k : l; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  The second change we make to the code will be to reduce dependencies.  In the previous version of the algorithm, the assignment of `m value` k or `l depends on the value assigned to` m line above.  To reduce the number of dependencies `m, we separately calculate` m0 and `m1, and then compare them.  When I performed this optimization, I hoped for a significant improvement in the speed of the algorithm, but in the end it turned out to be zero.  But, in my opinion, it is important to keep the number of dependencies minimal, so I saved the code. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i] &lt;= p[i + q] ? i : i + q; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q] &lt;= p[i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q] ? i + <span class="hljs-number"><span class="hljs-number">2</span></span> * q : i + <span class="hljs-number"><span class="hljs-number">3</span></span> * q; Swap(ref p[i], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  Let us now try to reduce the number of inductive variables from four to one, and the remaining three will be calculated arithmetically, since they are in constant relation to each other.  It is quite simple: instead of `k, we will have` i + q, instead of two other variables - `i + 2 * q and` i + 3 * q.  I also had high hopes for this optimization, but, like the previous one, it did not give any results in time.  This again proves the importance of measurement: without them, I could boast that I had significantly improved the performance of the algorithm, and I would have very substantial arguments. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2: ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = p[i - q] &lt; p[i] ? i - q : i; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = p[i + q2] &lt; p[i + q] ? i + q2 ? i + q; Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  As a fourth attempt, we restructure the cycle in order to eliminate multiplication by 3. This will give us an improvement of 3%.  The result is still not impressive.  Next, try to get rid of ternary operators. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: value if flag is true, 0 otherwise static int optional(bool flag, int value) { return -Convert.ToInt329flag) &amp; value; }</span></span></code> </pre> <br>  For this, I would like to introduce you to a new function - `static int optional (bool flag, int value).  It converts the input boolean value to Int32, multiplies by -1, and passes it to the bitwise AND operator along with the second input value.  If the input flag was false, then in int32 it will be 0, and after all conversions on the output, we still get 0. If the input flag was true, in int32 it will be 1, when multiplied by -1, we get FFFFFFFF, which is after the bit "And" with any number will give this second number.  Please note that there is no if statement anywhere, a code without branches, for a computer it is boring (although it just seems convoluted to us). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = q; i &lt; q2; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m0 = i - optional(p[i - q] &lt;= p[i], q); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m1 = i + q + optional(p[i + q2] &lt; p[i + q], q); Swap(ref p[i - q], ref p[p[m0] &lt;= p[m1] ? m0 : m1]); } }</code> </pre> <br>  We will replace the ternary operators with this optional function, we will integrate it inside the calculation.  Apply it twice, and in the third case, leave a question mark.  Thus, instead of four checks in this cycle, I will have only one. <br><br><img src="https://habrastorage.org/webt/qo/wp/--/qowp---fgvtqsgddipqokwb_k3o.jpeg"><br><br>  From the measurement results that you see on the slide, it is clear how important it was to check the algorithm on several different data sets.  On one set, we would not understand anything.  On random and real data, we have more than twice the acceleration, on the pipes of the organ and sorted data, we have a slight slowdown.  This is due to the fact that in the case of the sorted data for the predictor of transitions there will be no surprises, it will predict with 100% accuracy.  In the case of organ pipes, we will have one misprediction in the middle of the data set ‚Äî again, very high accuracy.  In contrast, with random data, the difference between our two approaches will be huge.  We have replaced all unpredictable checks with simple logic.  Here we return again to the simple truth: computers are created for computing, as the name implies (computer - computing).  Branching, displaying pictures on the screen - they all do much worse.  It is much easier to execute the bit "AND" for them than to pass an if statement. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q = p.Length / <span class="hljs-number"><span class="hljs-number">4</span></span>, q2 = q + q; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; q; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m = i + optional(p[i + q] &lt; p[i], q); m += optional(p[i + q2] &lt; p[m], q); m += optional(p[i + q2 + q] &lt; p[m], q); Swap(ref p[i], ref p[m]); } }</code> </pre> <br>  Having finally achieved a positive result from optimization, we will try to replace the last ternary operator with our `optional. Function.  This time the speed gain will be small.  To understand why this happens, you need to look at the generated code.  In the previous version of the code, where the question mark was still present, the compiler has already found a way to execute the code without branching.  And when he gets to the ternary operator, he could already predict it.  Replacing this last piece with `optional will give some worse code.  Therefore, I repeat, it is important to measure each time. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns: v1 if flag is true, v2 otherwise static int ifelse(bool flag, int v1, int v2) { return (-Convert.ToInt32(flag) &amp; v1) | ((Convert.ToInt32(flag) - 1) &amp; v2); }</span></span></code> </pre><br>  Another function I would like to recommend to you is the ifelse without branches, which you now see on the screen.  True, I was not able to achieve with it the performance improvements in our example.  If 0 is passed as a flag, the first line will be 0;  in the second, we subtract 1 from 0 in Int32 and get FFFFFFFF, after which this value is passed to the bit "AND" along with the argument of the `v2 function, which will give us this argument unchanged;  Finally, the first and second lines are transmitted to the bit "OR", which, again, will give us `v2.  If the flag is 1, then the first line will be `v1;  in the second, we subtract 1 from 1 and get 0, with the result that the entire line will be 0, and 0 and `v1 in the bit" OR "will give` v1. <br><br>  I hope that such a function `ifelse without branching will interest the people involved in the backend - for now, for some reason, modern compilers do not use this approach.  Having such functions, you can reorganize the algorithms so that compilers understand them for you, because you are smarter and more creative than your compiler. <br><br><h1>  Large set intersection </h1><br>  Let's change the topic of our conversation a bit and move on to the intersection of large sets.  So far, we have been talking about individual operators, but now we will create new algorithms, so we will need to distract from the details and open our consciousness to a larger perspective.  I assume that you are familiar with the algorithms for merge sort, multiplying two vectors and searching for common elements of two sorted vectors.  Two sorted sets are traversed, and when equal elements are found in them, this is considered a match.  If one of the two matched elements turns out to be smaller, it is shifted.  This algorithm is fairly simple, but very common - most likely the most used in the world.  It is used in all queries of several words, each such query is the intersection of two sets.  This algorithm, in particular, uses Google, and it should also be used in all database queries. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> || a2.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a1[i1] &lt; a2[i2]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a2[i2] &lt; a1[i1]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { t[i++] = a1[i1]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++i1 == a1.Length || ++i2 == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>: } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Take a look at the basic implementation of this algorithm.  If both input sets are empty, then obviously we return 0. Next, we start an infinite loop, in which, if a match is met, we increase the result by 1 and check if the loop needs to be completed.  Instead of an infinite loop, you could use the for operator and specify the end condition of the loop in it.  But that would mean extra work.  In the implementation that you see on the slide, in the first branch we have `if (a1 [i1] &lt;a2 [i2]), after which there is an increase in` i1 by 1, and all we need to do is to check `i1.  Similarly, in the second branch we only need to check `i2.  Both values ‚Äã‚Äãneed to be checked only in the third branch.  If this check were at the beginning of the cycle, then we would do the extra work. <br><br>  We will try to improve this implementation.  At the moment, its algorithmic complexity is linear, with dependence on two input arguments.  In machine learning, quite often you have to find the intersection of sets that are very different from each other in size or in statistics.  For example, you have a long input vector and a short vector of features (feature vector) against which you are checking.  In our code there can be a million entries in `a1, and in` a2 - a thousand.  In this case, we are not ready to go a million steps to complete this algorithm.  The greatest load here will be on the following line of code: `if (++ i1 == a1.length) break.  Immediately before this, a comparison occurs, and then in this line - the increment of the value;  this is essentially a linear search.  We iterate over a long vector in search of short elements.  In the worst case, we will carry out many such searches, slowly moving along the vector. <br><br>  Let's try to improve this algorithm.  Binary search is better than linear search, so let's turn to it.  Its advantage is that it gives the index of the largest of the smaller elements. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == a2.Length) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; --m; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m] &lt; a1[i1])) t[i++] = a1[i1]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre><br>  The code above is the implementation of our binary search algorithm.  It is not very effective.  The worst situation is when the binary search fails every time.  It will occur in some fairly important scenarios - for example, with identical elements of the set.  Here the binary search will be slower than the classic linear search.  How to make the algorithm work equally well on identical and different data?  Check all the data will be too expensive for resources.  I‚Äôll make a reservation that this is not about completely identical data, but about very similar, with similar statistics, dimensions may also differ.  You can check the following several items.  The obvious solution is to reduce the search area.  When we perform a binary search, then finding a certain element, we are no longer interested in elements smaller than it, since the second vector is also sorted.  Thus, we can reduce our search area every time, discarding all the elements less from the found element. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; i1 != a1.Length; ++i1) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = Bsearch(a2, i2, a2.Length, a1[i1]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m == i2) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(a2[m - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; a1[i1])) t[i++] = a1[i1]; i2 = m + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  Here is the implementation of this approach.  You see that we perform a binary search every time in a part of the original array starting with `i2 and ending with` a2.length.  Since  ªI2 will increase with each search, the search area will be reduced. <br><br>  The next optimization that I would like to implement here is connected with the Galloping Search algorithm.  In essence, this is a binary search with a different step.  In the case of a binary search, we start every time from the middle - but let's think about it, when we look for the name in the phone book, do we not open it in the middle itself?  If the person‚Äôs last name begins, say, in ‚ÄúB‚Äù, we will open the book closer to the beginning.  This principle is implemented in a galloping search: we begin to crawl data in an ascending direction with a step that increases exponentially after each check: first 1, then 2, then 4. This gives us a good algorithmic complexity.  If the step grew linearly, the complexity would be quadratic.  When we "skip" the desired element, we perform the usual binary search on the remaining segment, which will be small and will not significantly affect the execution time of the algorithm.  Thus, we combine all the advantages of both approaches.  The implementation of this algorithm: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GBsearch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> step = <span class="hljs-number"><span class="hljs-number">1</span></span>;; step *= <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i + step &gt;= j) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, J, v); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i + step] &gt; v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Bsearch(a, i + <span class="hljs-number"><span class="hljs-number">1</span></span>, i + step, v); i += step + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i; }</code> </pre> <br>  We now discuss the scaling, that is, we try to find an intersection with more than two sets.  For each search of several words, we will need to find the intersection of several sets.  To do this, we can, for example, compare the first two sets, then their intersection with the third, and so on.  But this is not the optimal solution.  We need to take the first elements of all the sets and find the smallest of them, which will then need to be moved.  We need a data structure that would allow us to find the smallest of many elements and would have constant complexity.  Such a data structure is a bunch.  But it will be a strange heap, it will not be based on a physical array.  She will be imaginary, we will organize in her only the first elements of our sets.  Having found the smallest item in the heap, we can still search all other sets. <br><br>  The work on the topics that we are discussing now has, in practice, a rather amateur form.  In practice, we will often have several sets, not just two, and quite a lot of work has been written on this topic.  The classic algorithm here is SVS, in which we group the sets, take the two smallest ones and choose the shortest one as a candidate.  Under the <a href="http://www.cs.utoronto.ca/~tl/papers/fiats.pdf">link</a> you can find a good overview on this topic.  The problems associated with the intersection of sets, the scalar product of sparse vectors, sorting by merging, any form of comparison with the image over time turn out to be more and more interesting.  The algorithm that I showed you proved to be very useful.  Thank you for your attention. <br><br><blockquote>  Andrei Alexandrescu will not come to DotNext 2018 Moscow, but there will be Jeffrey Richter, Greg Young, Pavel Yosifovich and others there.  The names of the speakers and the topics of the reports can be viewed <a href="https://dotnext-moscow.ru/">here</a> , and the tickets - <a href="https://dotnext-moscow.ru/registration/">here</a> .  Join now! </blockquote></div><p>Source: <a href="https://habr.com/ru/post/425191/">https://habr.com/ru/post/425191/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425175/index.html">A little bit about sound cards with OPL2 / 3 FM synthesizers for PC ...</a></li>
<li><a href="../425177/index.html">We study Adversarial Tactics, Techniques & Common Knowledge (ATT @ CK). Enterprise Tactics. Part 3</a></li>
<li><a href="../425179/index.html">YouTube stars are starting to burn at work: "the attractiveness of the most interesting of the works faded"</a></li>
<li><a href="../425181/index.html">Frankie Zapata for The Verge: ‚ÄúTurbo-jet fuel will help melt reinforced concrete skepticism‚Äù</a></li>
<li><a href="../425187/index.html">Intel PAC with FPGA Stratix 10 SX - an accelerator for large tasks</a></li>
<li><a href="../425195/index.html">Black, white and gray lists on guard of enterprise security</a></li>
<li><a href="../425197/index.html">Costing an IdM implementation project - how to anticipate surprises</a></li>
<li><a href="../425199/index.html">What protects buyers from fraud with contactless payments</a></li>
<li><a href="../425201/index.html">‚ÄúI‚Äôve been struggling with impostor syndrome for three years‚Äù - 10 questions for a programmer, issue 7</a></li>
<li><a href="../425205/index.html">Soft Skills in Project Management: Concept, Goals and Tips for Successful Business Applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>