<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Construction of minimal convex hulls</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Having conducted a small scientific study (in other words, by performing a search on the site), I found out that there are only two articles with the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Construction of minimal convex hulls</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/storage2/af8/aae/6d7/af8aae6d7f6fae976e4fd49fcba8e247.png"><br>  Having conducted a small scientific study (in other words, by performing a search on the site), I found out that there are only two articles with the tag ‚Äú <u>computational geometry</u> ,‚Äù and one of them turned out to be mine.  Because  Recently, I have become somewhat interested in this topic, I decided to continue the topic of algorithmic geometry with the consideration of the problem of constructing the so-called <i>minimal convex hulls</i> .  Although the figure on the right gives an insightful hackleader an exhaustive explanation of what it is, nevertheless, a bit more formal definitions will be given under the cut and two classical algorithms for constructing minimal convex hulls will be described. <br><a name="habracut"></a><br><br><h1>  The concept of a minimal convex hull </h1><br>  Let a finite set of points A be given on a <i>plane.</i> A <i>shell of</i> this set is any closed line H without self-intersections such that all points of A lie inside this curve.  If the curve H is convex (for example, any tangent to this curve does not intersect it at any other point), then the corresponding envelope is also called <i>convex</i> .  Finally, the <i>minimal convex hull</i> (hereinafter briefly MBO) is the convex hull of minimal length (minimal perimeter).  I did not check (it seems that this can be proved by contradiction), but it seems obvious that the minimal hull simply must be convex.  All introduced concepts are illustrated by the following figure. <br><img src="https://habrastorage.org/storage2/b4a/ef3/db1/b4aef3db1d109ec10d88eb6ab03ba6cc.png"><br>  The main feature of the MVO of the set of points A is that this shell is a convex polygon whose vertices are some points of A. Therefore, the task of finding the MVO ultimately reduces to selecting and ordering the necessary points from A. Ordering is necessary for the reason that the output of the algorithm should be a polygon, i.e.  sequence of vertices.  We additionally impose a condition on the order of the vertices - the direction of the polygon traversal must be positive (I remind you that a counterclockwise figure traversal is called positive). <br><br>  The task of building an MVO is considered one of the simplest tasks of computational geometry, for it there are many different algorithms.  Below we consider two such algorithms - Graham scan and Jarvis march.  Their description is illustrated with a Python code.  Both algorithms will need the rotate function, described in detail in my previous <a href="http://habrahabr.ru/post/144571/" title="Localization of a point in a convex polygon">post</a> .  Recall that this function determines which side of the vector AB is the point C (positive return value corresponds to the left side, negative - the right side). <br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A,B,C)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (B[<span class="hljs-number"><span class="hljs-number">0</span></span>]-A[<span class="hljs-number"><span class="hljs-number">0</span></span>])*(C[<span class="hljs-number"><span class="hljs-number">1</span></span>]-B[<span class="hljs-number"><span class="hljs-number">1</span></span>])-(B[<span class="hljs-number"><span class="hljs-number">1</span></span>]-A[<span class="hljs-number"><span class="hljs-number">1</span></span>])*(C[<span class="hljs-number"><span class="hljs-number">0</span></span>]-B[<span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Graham scan algorithm </h1><br>  This algorithm is a three-step.  At the first step, any point in A that is guaranteed to be included in the MBO is searched.  It is easy to figure out that such a point will be, for example, a point with the smallest x-coordinate (the leftmost point in A).  This point (we will call it the starting point) is moved to the top of the list, all further work will be done with the remaining points.  For some reasons, we will not change the initial array of points A, for all manipulations with points we will use indirect addressing: we will get a list of P in which <i>numbers of</i> points will be stored (their positions in array A).  So, the first step of the algorithm is that the first point in P should be the point with the smallest x-coordinate.  Code: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grahamscan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span><span class="hljs-function">:</span></span> n = len(A) <span class="hljs-comment"><span class="hljs-comment">#   P = range(n) #    for i in range(1,n): if A[P[i]][0]&lt;A[P[0]][0]: #  P[i]-    P[0]-  P[i], P[0] = P[0], P[i] #     </span></span></code> </pre><br>  The second step in Graham‚Äôs algorithm is the sorting of all points (except P [0] -th), according to the degree of their <i>left-handedness</i> relative to the starting point R = A <sub>P [0]</sub> .  We say that B &lt;C if the point C is on the left side of the RB vector. <br><img src="http://habrastorage.org/storage2/f68/08d/33a/f6808d33a47a4e89ecff0c15dd9c3246.png"><br>  To perform such ordering, you can use any sorting algorithm based on pairwise comparison of elements, for example, quick sorting.  For some reason (the main one is clumsiness of hands), I will use sorting by inserts. <br>  <font color="grey">* <sub>I will be very grateful to those who can explain to me how to apply in this case the built-in Python sorting ...</sub></font> <br>  So, sorting by inserts (do not forget about indirect addressing and the fact that the zero point is not sorted): <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>,n): j = i <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> j&gt;<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (rotate(A[P[<span class="hljs-number"><span class="hljs-number">0</span></span>]],A[P[j<span class="hljs-number"><span class="hljs-number">-1</span></span>]],A[P[j]])&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>): P[j], P[j<span class="hljs-number"><span class="hljs-number">-1</span></span>] = P[j<span class="hljs-number"><span class="hljs-number">-1</span></span>], P[j] j -= <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  The result of sorting can be illustrated by the following figure. <br><img src="http://habrastorage.org/storage2/1c9/209/7d3/1c92097d35a201d7b89fd9342d38f4e2.png"><br>  If we now connect the points in the order obtained, we obtain a polygon, which, however, is not convex. <br><img src="http://habrastorage.org/storage2/3da/dc0/133/3dadc013341a8b53bff9457f8b4ba0ca.png"><br>  Moving on to the third action.  All we have to do is cut the corners.  To do this, go through all the vertices and remove those of them in which the right turn is performed (the angle at such a vertex turns out to be more unfolded).  We get the stack S (really a list) and put the first two vertices into it (again, they are guaranteed to be included in the MBO). <br><pre> <code class="python hljs"> S = [P[<span class="hljs-number"><span class="hljs-number">0</span></span>],P[<span class="hljs-number"><span class="hljs-number">1</span></span>]]</code> </pre><br>  Then we look through all the other vertices, and track the direction of rotation in them from the point of view of the last two vertices in the S stack: if this direction is negative, then we can cut off the angle by removing the last vertex from the stack.  As soon as the turn turns out to be positive, the cutting of the corners is completed, the current vertex is pushed onto the stack. <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>,n): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> rotate(A[S[<span class="hljs-number"><span class="hljs-number">-2</span></span>]],A[S[<span class="hljs-number"><span class="hljs-number">-1</span></span>]],A[P[i]])&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> S[<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-comment"><span class="hljs-comment"># pop(S) S.append(P[i]) # push(S,P[i])</span></span></code> </pre><br>  As a result, the required sequence of vertices appears in the stack S (which can now be considered as a list), and in the orientation we need, defining the MBO of a given set of points A. <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> S</code> </pre><br><img src="http://habrastorage.org/storage2/250/253/036/25025303603cad0f561224ed1e065412.gif"><br>  The complexity of the first and last steps of the algorithm is linear in n (although in the latter case there is an embedded loop, however, each vertex inside this cycle is pushed onto the stack exactly once, and not more than once removed from there), therefore, the complexity of the entire algorithm is determined by the second step - sorting, which is why insertion sorting is not the best option for large n.  If we replace it with a quick sort, we obtain the total complexity of the algorithm O (nlogn).  Is it possible to improve this time?  If the algorithm is based on pairwise comparison of points (like ours), then it is proved that this estimate is generally not improved.  From this point of view, Graham‚Äôs algorithm is optimal.  Nevertheless, it does not have a very good feature - it is not adaptive in the sense that it does not matter how many vertices will eventually go into the MBO (three, five, ten, or n), all the same time will be linear logarithmic.  Jarvis has such adaptability, to the consideration of which we smoothly proceed. <br><div class="spoiler">  <b class="spoiler_title">Graham's Full Code Algorithm</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grahamscan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span><span class="hljs-function">:</span></span> n = len(A) <span class="hljs-comment"><span class="hljs-comment">#   P = range(n) #    for i in range(1,n): if A[P[i]][0]&lt;A[P[0]][0]: #  P[i]-    P[0]-  P[i], P[0] = P[0], P[i] #      for i in range(2,n): #   j = i while j&gt;1 and (rotate(A[P[0]],A[P[j-1]],A[P[j]])&lt;0): P[j], P[j-1] = P[j-1], P[j] j -= 1 S = [P[0],P[1]] #   for i in range(2,n): while rotate(A[S[-2]],A[S[-1]],A[P[i]])&lt;0: del S[-1] # pop(S) S.append(P[i]) # push(S,P[i]) return S</span></span></code> </pre></div></div><br><br><h1>  Jarvis Algorithm </h1><br>  The Jarvis algorithm (another name is the gift wrapping algorithm) is conceptually simpler than the Graham algorithm.  It is a two-step and does not require sorting.  The first step is exactly the same - we need a starting point, which is guaranteed to enter the MBO, take the leftmost point of A. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jarvismarch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span><span class="hljs-function">:</span></span> n = len(A) P = range(n) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,n): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A[P[i]][<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;A[P[<span class="hljs-number"><span class="hljs-number">0</span></span>]][<span class="hljs-number"><span class="hljs-number">0</span></span>]: P[i], P[<span class="hljs-number"><span class="hljs-number">0</span></span>] = P[<span class="hljs-number"><span class="hljs-number">0</span></span>], P[i]</code> </pre><br>  In the second step of the algorithm, an MBO is built.  Idea: make the starting vertex current, look for the rightmost point in A relative to the current vertex, make it current, etc.  The process ends when the starting vertex is current again.  As soon as the dot hit the MVO, it can no longer be taken into account.  Therefore, we will create another H list, in which the vertices of the MBO will be stored in the correct order.  We immediately add the starting vertex to this list, and in the list P we transfer this vertex to the end (where we finally find it and complete the algorithm). <br><pre> <code class="python hljs"> H = [P[<span class="hljs-number"><span class="hljs-number">0</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> P[<span class="hljs-number"><span class="hljs-number">0</span></span>] P.append(H[<span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre><br>  Now we organize an infinite loop, at each iteration of which we look for the leftmost point from P with respect to the last vertex in H. If this vertex is the starting one, then we interrupt the cycle, if not, then we transfer the found vertex from P to H. After the completion of the cycle, the desired shell is in H which we return as a result. <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: right = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,len(P)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rotate(A[H[<span class="hljs-number"><span class="hljs-number">-1</span></span>]],A[P[right]],A[P[i]])&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>: right = i <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> P[right]==H[<span class="hljs-number"><span class="hljs-number">0</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: H.append(P[right]) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> P[right] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> H</code> </pre><br>  Hmmm, I was able to talk about the Jarvis algorithm without using pictures.  The following figure illustrates everything! <br><img src="http://habrastorage.org/storage2/eaa/867/45b/eaa86745b1ff7b24a2daba41bf479fa4.gif"><br>  Estimate the complexity of the Jarvis algorithm.  The first step is linear in n.  With the second all the more interesting.  We have a nested loop, the number of external iterations is equal to the number of vertices h in the MVO, the number of internal iterations does not exceed n.  Therefore, the complexity of the entire algorithm is O (hn).  Unusual in this formula is that the complexity is determined not only by the length of the input data, but also by the length of the output (output-sensitive algorithm).  And then how the point <s>cards</s> will fall.  In the worst case, all points from A enter the MBO (that is, A is a convex polygon by itself), then h = n and the complexity jumps to a quadratic one.  At best (provided that the points of A do not lie on one straight line) h = 3 and the complexity becomes linear.  It remains to understand in advance what our case is, what is not so easy to do (if you do not have a time machine <sup>**</sup> ), you can only proceed from the nature of the task - if there are a lot of points and they evenly fill a certain area, then Jarvis will be faster ( if the data is collected at the border area, then Graham will be faster, something like that ... <br>  ** <sub>The time machine is generally a useful thing from the point of view of algorithms, any task requiring a trillion years of computation can be solved almost instantly with its help - we start the program, sit in the time machine, ‚Äúfly‚Äù to the future, read the result, go back.</sub>  <sub>It remains to figure out how to ensure the uninterrupted operation of a computer for a couple of trillions of years ...</sub> <br><br><div class="spoiler">  <b class="spoiler_title">Full Jarvis Algorithm Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jarvismarch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A)</span></span></span><span class="hljs-function">:</span></span> n = len(A) P = range(n) <span class="hljs-comment"><span class="hljs-comment"># start point for i in range(1,n): if A[P[i]][0]&lt;A[P[0]][0]: P[i], P[0] = P[0], P[i] H = [P[0]] del P[0] P.append(H[0]) while True: right = 0 for i in range(1,len(P)): if rotate(A[H[-1]],A[P[right]],A[P[i]])&lt;0: right = i if P[right]==H[0]: break else: H.append(P[right]) del P[right] return H</span></span></code> </pre></div></div><br><br><h1>  Instead of conclusion </h1><br>  In my opinion, the task of constructing minimal convex hulls is a good way to get into the topic of computational geometry, it is easy enough to invent your own algorithm (however, it will most likely be a variation of the Jarvis algorithm).  It is argued that there are many applications for this task, most of them are associated with pattern recognition, clustering, etc.  In addition, the task of constructing an MVO is used as an aid in solving more complex problems of computational geometry.  Yes, it is worth noting that this problem has a very interesting three-dimensional generalization. <br><br>  Thank you all for your attention! </div><p>Source: <a href="https://habr.com/ru/post/144921/">https://habr.com/ru/post/144921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144913/index.html">Dirty programming with a pure soul: the development of heuristic systems (part 2)</a></li>
<li><a href="../144914/index.html">IPO Vkontakte postponed indefinitely due to the failure of Facebook</a></li>
<li><a href="../144915/index.html">WebAPI: auto-generated REST API web documentation</a></li>
<li><a href="../144917/index.html">Instant porridge - do CRUD in Cach√© using jqGrid</a></li>
<li><a href="../144918/index.html">Asynchronous requests to MySQL on the API (libmysqlclient)</a></li>
<li><a href="../144922/index.html">Thematic subscriptions in social networks</a></li>
<li><a href="../144923/index.html">Startup franchise</a></li>
<li><a href="../144925/index.html">Please come back to me in Casablanca</a></li>
<li><a href="../144926/index.html">Notebook keyboard to work with the text, or what is wrong Lenovo</a></li>
<li><a href="../144927/index.html">AimTask, or how we did the task scheduler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>