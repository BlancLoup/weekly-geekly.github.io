<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>NVRAM device in UEFI-compatible firmware, part three</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Here is the third part of my narration about the NVRAM formats used by UEFI-compatible firmware from various manufacturers. In the first part, I talke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>NVRAM device in UEFI-compatible firmware, part three</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/ade/3d4/5c9/ade3d45c9c10475b8dd5ea869159a30e.jpg">  Here is the third part of my narration about the NVRAM formats used by UEFI-compatible firmware from various manufacturers.  <a href="https://habrahabr.ru/post/281242/">In the first part,</a> I talked about NVRAM in general and about the ‚Äústandard‚Äù VSS format, <a href="https://habrahabr.ru/post/281412/">in the second</a> - about interesting blocks that can be found next to NVRAM in this format, and this one will focus on a whole placer of various formats used in firmware on Phoenix platform <abbr title="Securecore tiano">SCT</abbr> : FlashMap, EVSA, Intel uCode, CMDB, SLIC pubkey and SLIC marker. <br>  If you are wondering what the developers from Phoenix managed to make up for replacing VSS - welcome to the cat, but I‚Äôm warning you right away that the article was quite long. <br><a name="habracut"></a><br><h4>  <b>Disclaimer # 3</b> </h4><br>  I don‚Äôt even know what to write here after the first two ‚Äúfailures‚Äù, except that the author once again disclaims any and all responsibility for the loss of performance of your NVRAM, firmware, system, and everything else.  Use the information at your own risk, behave well, and everything will be fine. <br>  If you accidentally stumbled upon this article and it is not clear to you what is happening here, why the author dives into some formats with a head, without explaining anything, and how dare he at all - the <a href="https://habrahabr.ru/post/281242/">first</a> and <a href="https://habrahabr.ru/post/281412/">second</a> parts are waiting for you.  The rest - for me! <br><br><h4>  <b>Phoenix Flash Map</b> </h4><br>  When I first opened the contents of the main NVRAM volume from the firmware of my old Dell Vostro 3360 on Ivy Bridge, I was very surprised.  What is there to just find - first a whole set of Intel microcodes, after it some block with lines, half of which are copies of the <i>NoLongerUsed</i> line, then vaguely familiar blocks with RSA signatures, about five EVSA repositories, and under the curtain - a structure with a speaker signature _FLASH_MAP.  In short, the guys from Phoenix managed to dump NVRAM in such a heap of everything that it was impossible to figure out without a card.  Let's start with it. <br>  The card header is 16 bytes and looks like this: <pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PHOENIX_FLASH_MAP_HEADER</span></span></span><span class="hljs-class"> {</span></span> UINT8 Signature[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  _FLASH_MAP UINT16 NumEntries; //   UINT32 : 32; //   };</span></span></code> </pre> <br>  Immediately after the heading without additional alignment close to each other, the following entries follow: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PHOENIX_FLASH_MAP_ENTRY</span></span></span><span class="hljs-class"> {</span></span> EFI_GUID Guid; <span class="hljs-comment"><span class="hljs-comment">// GUID ,    ,      UINT16 DataType; //  ,    -  (0)     (1) UINT16 EntryType; //  ,   ,       UINT64 PhysicalAddress; //   ,     UINT32 Size; //  ,     UINT32 Offset; //  ,    ,  ,      };</span></span></code> </pre> <br>  The maximum size of the map is determined by its position, and since  it is located at 0x1000 bytes from the end of the main volume of NVRAM, as much as possible there can be exactly 113 entries, which is enough with a huge margin. <br><br>  In the screenshot, the map looks like this: <br><img src="https://habrastorage.org/files/ba4/609/8e1/ba46098e1d2d4872a0874c5b1a9d6c61.png"><br>  Immediately visible is the header with the <font color="darkred">signature</font> and the <font color="red">number of records</font> , immediately followed by a record with zero <font color="green">GUID</font> , <font color="lightblue">data type</font> 0 (that is, this is a volume), <font color="blue">record type</font> 6, <font color="purple">physical address</font> 0xFF980000, <font color="brown">data size</font> 0x20000, and zero <font color="pink">offset</font> ( , relative to itself, the first volume is not shifted anywhere, otherwise something is very wrong with either the file or the space metric). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You could still give all the values ‚Äã‚Äãof the GUIDs that I managed to find in different images and match the data type, but this can be done literally with one screenshot from <a href="https://github.com/LongSoft/UEFITool/tree/new_engine">UEFITool NE</a> , here it is: <br><img src="https://habrastorage.org/files/955/158/e53/955158e5309b4d70abe46bf94f32ae80.png"><br>  In addition to GUIDs, there are also a couple of spoilers: vaguely familiar blocks with RSA turned out to be a public key and a marker for the <abbr title="Microsoft System Licensing">SLIC</abbr> table, and for some reason, the block with lines was called CMDB.  We will come back to all these things, but everything is clear with the card, it remains to learn how to parse the formats of all these blocks, and we can more or less understand the structure of NVRAM in the firmware based on Phoenix SCT.  Go! <br><br><h4>  <b>Intel microcode</b> </h4><br>  First on the list we have a block with microcodes.  I, unfortunately, do not have an image with AMD microcodes in NVRAM, so we will consider only Intel's ones.  Despite the fact that there were as many as 12 free bytes in the header of the microcode, there was no space even for any seedy signature, and therefore searching for such a block of data among the contents of the NVRAM volume is still a task.  You will develop your processor - think about the signature for its microcode, please!  In any case, the main header of the Intel microcode is documented and has not changed, in my memory, never.  Here he is: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INTEL_MICROCODE_HEADER</span></span></span><span class="hljs-class"> {</span></span> UINT32 Version; <span class="hljs-comment"><span class="hljs-comment">//   (1) UINT32 Revision; //   UINT32 Date; //   UINT32 CpuSignature; //   UINT32 Checksum; //  ,           0 UINT32 LoaderRevision; //   ,     UINT32 CpuFlags; //   UINT32 DataSize; //     UINT32 TotalSize; //      UINT8 Reserved[12]; //    };</span></span></code> </pre><br>  In theory, there is still an extended header, but we have already received the most important information for further analysis, the total size.  Let's look at the header of the first microcode in the volume: <br><img src="https://habrastorage.org/files/bf7/727/42c/bf772742ca204a3bba078a34c1bd9a79.png"><br>  <font color="red">Version is</font> valid 1, <font color="orange">revision</font> - 0x28, <font color="green">release date</font> - 04.24.2012, <font color="lightblue">processor type</font> - 0x206A7, <font color="blue">checksum</font> - 0xF3E9935D, <font color="purple">bootloader revision</font> - 1, <font color="brown">processor flags</font> - 0x12, <font color="pink">data size</font> - 0x23D0, <font color="gold">total size</font> - 0x2400. <br><br>  The same microcode in UEFITool NE, it is clear that there were 5 such units with a microde: <br><img src="https://habrastorage.org/files/a57/2a5/b71/a572a5b7189c40eb9052e90a1ca7b1d3.png"><br><br><h4>  <b>CMDB</b> </h4><br>  The next block to which the map refers is <abbr title="Configuration Manager Database">CMDB</abbr> .  Its purpose is not very clear to me, most likely it was used to select the appropriate configuration in the firmware, suitable for several boards at once, or to populate SMBIOS tables, but at the moment it is no longer used.  This block has a format that I cannot call anything other than ‚Äúdrug addict‚Äù, what its developers thought - this is a great mystery.  See for yourself: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PHOENIX_CMDB_HEADER</span></span></span><span class="hljs-class"> {</span></span> UINT32 Signature; <span class="hljs-comment"><span class="hljs-comment">//  CMDB UINT32 HeaderSize; //   UINT32 TotalSize; //      };</span></span></code> </pre><br>  The title does not look very strange, well, there‚Äôs no general size, well, okay, the end of the block can be found on parsing, the fun begins with chunks, which are easier to show in the screenshot right away: <br><img src="https://habrastorage.org/files/48c/edc/18b/48cedc18b3fd4d03b2e4bb3998187897.png"><br>  After the header with a CMDB <font color="red">signature</font> , 0x0C and a <font color="green">total size of</font> 0x23, there is a zero chunk of three bytes: the <font color="lightblue">start byte is</font> 0x42 (I still struggle with the desire to call it <i>TheAnswer</i> ), the <font color="blue">offset of the first line</font> after the header (which is always 0) and the <font color="purple">offset of the beginning of the block</font> with strings (which is always TotalSize - HeaderSize).  Total - three of the three fields are not used at all, why this chunk is needed is absolutely incomprehensible.  The rest of the chunk follows, these already consist of five bytes: the <font color="lightblue">starting</font> 0x42 that we are familiar with, the <font color="blue">offset of the key string</font> , the incomprehensible <font color="brown">two-byte field</font> , which is always 0x205 and the <font color="pink">offset of the string value</font> .  The lengths of both lines are not stored anywhere, and, apparently, are not even calculated.  In the block with strings, the <i>BiosInfo</i> <font color="lightgreen">header line</font> is separately stored, referenced by the null chunk, and then all the remaining strings referenced by the remaining chunks.  The total block size is always 0x100, so it is not stored anywhere.  I would like to ask that the person who invented it smoked? <br>  Since  the structure has not been used for a long time, and at the same time, with my eyes, it is sorted out instantly; I did not add support for its analysis in UEFITool NE  If suddenly you need it - write me in the comments or <a href="https://github.com/LongSoft/UEFITool/issues/43">here</a> . <br><br><h4>  <b>SLIC Pubkey and Marker</b> </h4><br>  Right after CMDB, one after another, Pubkey and Marker blocks necessary for OEM activation of Windows Vista / 7/2008 follow, which are then transferred to the ACPI table SLIC by a special driver.  I will not describe the format of these blocks in order to prevent the possible DMCA takedown of this article, but it was disassembled a long time ago, the description of all fields is shown by the <a href="http://rweverything.com/">RW Everything</a> utility, plus UEFITool NE supports them, so if you still need the formats of these blocks, look at them in <a href="">nvram.h</a> . <br><br><h4>  <b>EVSA</b> </h4><br>  The latest format in our map, which ( <i>finally!</i> ) <i>Is</i> used to store NVRAM variables.  Compared to VSS, the format uses space in NVRAM a bit more efficiently due to deduplication of variable names and their GUIDs, but it‚Äôs much easier to damage the EVSA storage, and almost all of my manual data recovery from NVRAM falls on it despite massive use. this checksum format.  The data (including the header of the repository itself) is stored as records with a common header and different additional fields, like so: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EVSA_ENTRY_HEADER</span></span></span><span class="hljs-class"> {</span></span> UINT8 Type; <span class="hljs-comment"><span class="hljs-comment">//   UINT8 Checksum; //   UINT16 Size; //  ,      }; struct EVSA_STORE_ENTRY { EVSA_ENTRY_HEADER Header; //   UINT32 Signature; //  EVSA UINT32 Attributes; //   UINT32 StoreSize; //      UINT32 : 32; //   }; struct EVSA_GUID_ENTRY { EVSA_ENTRY_HEADER Header; //   UINT16 GuidId; //  GUID // EFI_GUID Guid //  GUID    ,     };</span></span></code> </pre><br>  Screenshot: <br><img src="https://habrastorage.org/files/ff3/c4e/ee6/ff3c4eee637c49168d01a03d8da09624.png"><br>  Here we have a repository header with the <font color="red">type</font> 0xEC (‚Äúrepository header‚Äù), single-byte <font color="orange">checksum</font> 0x2C, <font color="green">size</font> 0x14 with the correct EVSA <font color="lightblue">signature</font> , <font color="blue">attributes</font> 0x01 (‚Äúdefault values ‚Äã‚Äãhere‚Äù) and <font color="purple">storage size</font> 0x2B65.  Immediately after the header, two entries of <font color="red">type</font> 0xED (‚ÄúGUID‚Äù) go without any alignment, with <font color="orange">checksums</font> 0x35 and 0xB3, respectively, of <font color="green">size</font> 0x16, <font color="brown">identifiers</font> 0 and 1, and <font color="pink">GUIDs</font> 4FEE3D67-18F4-4217-BA7B-BC538148382A and 1E1F1797-2CCE -49D6-A6CE-4012F338A76E respectively. <br>  In UEFITool NE, the same storage looks like this: <br><img src="https://habrastorage.org/files/019/f3c/c8e/019f3cc8e01d4a20a2db2a42d23c37f8.png"><br><br>  In addition to the types 0xEC (‚Äústorage‚Äù) and 0xEC (sometimes 0xE1, ‚ÄúGUID‚Äù) discussed above, there are three more - 0xEE (sometimes 0xE2, ‚Äúvariable name‚Äù), 0xEF (sometimes 0xE3, ‚Äúdata‚Äù) and 0x83 ("Deleted data").  As I understand it, deleting records of the type ‚ÄúGUID‚Äù and ‚Äúvariable name‚Äù is possible only with a complete reassembly of the repository by the driver performing garbage collection in it. <br>  An entry with the type ‚Äúvariable name‚Äù looks like this: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EVSA_NAME_ENTRY</span></span></span><span class="hljs-class"> {</span></span> EVSA_ENTRY_HEADER Header; <span class="hljs-comment"><span class="hljs-comment">//   UINT16 VarId; //    //CHAR16 Name[]; //     UCS2 };</span></span></code> </pre><br>  Picture: <br><img src="https://habrastorage.org/files/e2a/709/0d5/e2a7090d529a494fbbd7e5450c0917ea.png"><br>  An entry of <font color="red">type</font> 0xEE, with <font color="orange">a checksum of</font> 0x39, a <font color="green">length of</font> 0x20, and an <font color="lightblue">identifier of</font> 0, which contains the <font color="blue">string</font> <i>DellVariable</i> in UCS2.  It makes no sense to show in UEFITool NE - and so everything is clear. <br><br>  It remains to consider the last record type - data.  In fact, there are two formats, like this: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EVSA_DATA_ENTRY</span></span></span><span class="hljs-class"> {</span></span> EVSA_ENTRY_HEADER Header; <span class="hljs-comment"><span class="hljs-comment">//   UINT16 GuidId; //  GUID UINT16 VarId; //   UINT32 Attributes; //  // UINT8 Data[]; //  } EVSA_DATA_ENTRY; struct EVSA_DATA_ENTRY_EXTENDED { EVSA_ENTRY_HEADER Header; //   UINT16 GuidId; //  GUID UINT16 VarId; //   UINT32 Attributes; // ,   0x10000000      UINT32 DataSize; //   ,  ,    // UINT8 Data[]; //  };</span></span></code> </pre><br>  I will show only the first in the screenshot, because the second is quite rare, and there is just another additional field: <br><img src="https://habrastorage.org/files/7bb/3b2/d0e/7bb3b2d0e0d44988a7e56f7936830d03.png"><br>  Here we have two entries of <font color="red">type</font> 0xEF, the first of which has a <font color="orange">checksum of</font> 0x84, <font color="green">size</font> 0x5F, <font color="lightblue">GUID identifier</font> 0, <font color="blue">identifier of the name</font> 0 and <font color="purple">attributes</font> 0x03 ( <abbr title="Non-volatile">NV</abbr> + <abbr title="BootServices-accessible">BS</abbr> ), and the second - 0xEA, 0x11, 1, 1 and 0x03, respectively.  In the first, it turns out that the data of the very aforementioned Dell variable is stored with the GUID 4FEE3D67-18F4-4217-BA7B-BC538148382A. <br><br>  In UEFITool NE: <br><img src="https://habrastorage.org/files/33e/2e5/c8a/33e2e5c8a62c44c195596e0962e8a0d9.png"><br><br><h4>  <b>Conclusion</b> </h4><br>  Well, now the format of the data, which can be stored on the Phoenix SCT code base in NVRAM volumes, has become a little clearer.  It remains to talk about the format of NVAR, which is used in AMI Aptio, I will talk about it in the next, final part of this article. <br>  Thank you very much for your attention, send the occluded spots to L / C, and let randomly save you from recovering NVRAM at least manually, even if you like. </div><p>Source: <a href="https://habr.com/ru/post/281469/">https://habr.com/ru/post/281469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281457/index.html">DataPro Data Center: cooling and fire suppression systems</a></li>
<li><a href="../281459/index.html">Hello, Bot! Chat bots - the next generation of applications?</a></li>
<li><a href="../281461/index.html">Humor in programming: P, NP and Turing machines</a></li>
<li><a href="../281463/index.html">BYOD - convenience versus security</a></li>
<li><a href="../281467/index.html">Darudar - a cloud as a gift from Microsoft</a></li>
<li><a href="../281471/index.html">Bye, Habrahabr</a></li>
<li><a href="../281473/index.html">Large JVM Survey: Java Versions, Alternative JVM Languages, Java EE Versions</a></li>
<li><a href="../281479/index.html">Quick start at easla.com (master class)</a></li>
<li><a href="../281481/index.html">Microsoft has added another exploit protection feature in Windows 10</a></li>
<li><a href="../281483/index.html">Cloud-as-a-Tier, or How to build an IT infrastructure using a hybrid cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>