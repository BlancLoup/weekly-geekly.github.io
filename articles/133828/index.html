<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using OpenGL Shaders in QML</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post participates in the competition "Smart phones for smart posts" 

 This post focuses on the use of OpenGL shaders along with elements of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using OpenGL Shaders in QML</h1><div class="post__text post__text-html js-mediator-article"> This post participates in the competition <a href="http://habrahabr.ru/company/Nokia/blog/132522/">"Smart phones for smart posts"</a> <br><br>  This post focuses on the use of OpenGL shaders along with elements of the declarative QML language.  The theme, in my opinion, is relevant, as in the future version of QML 2.0 it is planned to use OpenGL extensively as a backend for drawing graphical interface elements.  Writing shaders is not an easy topic, and the purpose of this post is that, first of all, a person, after reading it, can immediately try to do something interesting for himself and experiment, having received, for example, the following examples: <br><br><img src="https://habrastorage.org/storage1/939ca890/4143fb1e/3940bbbd/5e51fb24.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the end, I will provide useful links where you can see the material for further, more in-depth study of this topic, if it will certainly interest you, and implement even more interesting shaders by applying them together with elements of the QML language.  Work with shaders can be seen on the example of various QML elements: <a href="http://doc.qt.nokia.com/4.8/qml-shadereffectitem.html">ShaderEffectItem</a> , multiple <a href="http://doc.qt.nokia.com/qt3d-snapshot/">Qt3D</a> classes that also use OpenGL, etc.  In this post I will demonstrate some examples using the <code>ShaderEffectItem</code> element together with the <a href="http://doc.qt.nokia.com/4.7-snapshot/qml-shadereffectsource.html">ShaderEffectSource</a> . <br><a name="habracut"></a><br>  The following is an outline of this article as a whole: <br>  <a href="https://habr.com/ru/post/133828/">Setting the ShaderEffectItem and ShaderEffectSource</a> <br>  <a href="https://habr.com/ru/post/133828/">Some shader theory</a> <br>  <a href="https://habr.com/ru/post/133828/">Linking QML elements with shaders</a> <br>  <a href="https://habr.com/ru/post/133828/">Example 1. Gradient implementation with shaders</a> <br>  <a href="https://habr.com/ru/post/133828/">Example 2.1 The simplest animation</a> <br>  <a href="https://habr.com/ru/post/133828/">Example 2.2 Creating a menu with animation</a> <br>  <a href="https://habr.com/ru/post/133828/">Example 3. Select some area of ‚Äã‚Äãthe texture depending on the mouse pointer.</a> <br>  <a href="https://habr.com/ru/post/133828/">Example 4. Mixing two images</a> <br>  <a href="https://habr.com/ru/post/133828/">Conclusion</a> <br>  <a href="https://habr.com/ru/post/133828/">useful links</a> <br><br>  Let's start with its installation of the necessary elements. <br><br><a name="Installation"></a><h5>  Install the necessary plugins </h5><br>  First you need to check whether you have installed all the components of OpenGL. <br>  1) Follow the <a href="https://qt.gitorious.org/qt-labs/qml1-shadersplugin">link</a> and you will see the address in the git repository where the shadersplugin lies.  If nothing has changed, then it is: <br> <code>git://gitorious.org/qt-labs/qml1-shadersplugin.git</code> <br>  2) Making <code>git clone git://gitorious.org/qt-labs/qml1-shadersplugin.git</code> <br>  3) Go to the folder and do make install (as I do under Linux, see how similar elements are installed under your OS).  If there are no OpenGL components, then there will be installation problems.  If you have any problems with this check, simply create an empty Qt application and add a line to the project file (* .pro): <code>QT += declarative opengl</code> .  If everything compiles, there should be no problems during the installation. <br><br><a name="Theory"></a><h5>  Some shader theory </h5><br>  Familiar with the concept of shaders can skip this small chapter.  In it, I will give a brief overview of this topic.  Why do we need shaders?  In simple terms, shaders allow the programmer to ‚Äúintervene‚Äù in the primitive rendering process, i.e.  make changes to the stages of the pipeline (which will be discussed below), by writing the actual code.  For writing shaders, there is a GLSL (OpenGL Shading Language) language created by the OpenGL committee.  Its syntax is based on the programming language C. GLSL was designed specifically for programmers to have control over the programmed points of the OpenGL pipeline, which is a sequence of stages through which OpenGL commands pass).  As one and variants of the conveyor shown in the figure below: <br><br><img src="https://habrastorage.org/storage1/d2eb8527/5a180f97/474e8725/4d3c42a2.gif"><br><br>  The vertex of any object is passed to the pipeline.  First, the coordinate transformation (Vertex Transformation) is performed - the application of the world, species and projection matrices of the incoming vertex.  This refers to the work of the vertex shader.  After these operations are completed, the primitive layout (Assembly) occurs: at this stage, the spatial coordinates (x, y, z) are transformed using matrices of dimension (4 x 4).  The main task is to obtain screen, two-dimensional coordinates from three-dimensional (world) coordinates.  In this part of the pipeline, the vertices are grouped into triangles and fed into the rasterization (Rasterization).  The rasterizer divides a triangle into fragments (pixels) for which texture coordinates and color are interpolated.  Then comes the work of the fragment shader.  He is responsible for determining the color of each pixel of the screen inside the area bounded by a contour projected onto the screen of the surface being drawn.  After processing all these methods, the resulting fragment is placed in the frame buffer, which is subsequently displayed on the screen (Pixel updates). <br>  As you already understood, shaders are of two types: vertex and fragment (or they are also called pixel).  The vertex shader is executed earlier and processes each vertex, while the fragment shader is executed for each pixel to which some set of attributes are associated, such as color ( <code>.r, .g, .b, .a</code> ), depth, <a href="http://www.intuit.ru/department/graphics/direct3dhlsl/3/">texture coordinates</a> ( <code>.x, .y, .z, .w</code> or <code>.s, .t, .p, .q</code> ).  The entry point to the shader is the <code>void main()</code> function.  If the program uses both types of shaders, then there are two entry points main.  Before entering the <code>main</code> function, global variables are initialized.  Special types of variables are defined in GLSL: <br>  <code>uniform</code> - shader communication with external data (in the case of QML, these will be properties of elements (property)), it should be noted that this type of variables is read only; <br>  <code>varying</code> - this type of variables is necessary to connect a fragmentary shader with a vertex shader, that is, to transfer data from a vertex shader to a fragment shader.  In the vertex shader, they can be changed, and in the fragment shader they are read-only; <br>  <code>attribute</code> - global scope variables; <br>  It is also worth mentioning some elements of the GLSL language, which will be found in the examples below: <br>  <code>sampler2D</code> is one of the GLSL types representing texture (there is also sampler1D, sampler3D, samplerCube, sampler1Dshadow, sampler2Dshadow); <br>  <code>vec4 texture2D(sampler2D s, vec2 coord)</code> is a function used to read a pixel from texture <code>s</code> , with texture coordinates <code>coord</code> . <br>  <code>gl_FrontColor</code> is a vector in which final color texture data is written and which is available only in a fragment shader. <br>  It is also worth mentioning that GLSL defines a set of built-in functions focused on calculations, in particular for working with vectors and matrices.  In the course of the analysis of the examples below, some functions will be discussed. <br><br><a name="QMLShaders"></a><h5>  Linking QML elements with shaders </h5><br>  A mandatory requirement for the operation of shaders with QML elements is the installation of OpenGL for drawing, in an object of the <a href="http://doc.qt.nokia.com/4.7-snapshot/qdeclarativeview.html">QDeclarativeView</a> class: <br><pre> <code class="cpp hljs">QmlApplicationViewer viewer; ... QGLWidget* glWidget = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGLWidget(format); ... viewer.setViewport(glWidget); ...</code> </pre><br>  This piece of code is taken from the main function of the application, <code>main</code> generated in QtCreator (Qt Quick Application Wizard), the <code>QmlApplicationViewer</code> class <code>QmlApplicationViewer</code> inherited from <code>QDeclarativeView</code> .  After each example, I will provide a link to the full source code. <br><br>  As mentioned above, to demonstrate how to work with OpenGL shaders, the <code>ShaderEffectItem</code> element will be used, which allows you to make changes to the display on the screen of various QML elements using OpenGL mechanisms.  It is available in the <code>Qt.labs.shaders 1.0</code> module (since it is under development), but now you can try using it.  For writing vertex and fragment shader code, the properties (of type <code>string</code> ) <a href="http://doc.qt.nokia.com/4.7-snapshot/qml-shadereffectitem.html">fragmentShader</a> and <a href="http://doc.qt.nokia.com/4.7-snapshot/qml-shadereffectitem.html">vertexShader are</a> defined respectively. <br><br>  <code>ShaderEffectSource</code> required to specify the QML component to be available in the shader.  It will mainly use the properties of <a href="http://doc.qt.nokia.com/4.7-snapshot/qml-shadereffectsource.html">sourceItem</a> and <a href="http://doc.qt.nokia.com/4.7-snapshot/qml-shadereffectsource.html">hideSource</a> .  The first points to a specific QML element (its identifier) ‚Äã‚Äãthat will be affected by the shaders, and <code>hideSource</code> ‚Äúsays‚Äù that the original element will be hidden when the shaders effect is applied. <br><br>  It is allowed to define one or more <code>ShaderEffectItems</code> as source (s) for other <code>ShaderEffectItems</code> , but you should not declare <code>ShaderEffectItems</code> as a child of an element defined in <code>source</code> , since this will most likely cause a redrawing loop. <br><br>  In QML, it is possible to define your properties for an element (using <code>property</code> ), and they will also be available as variables in shader programs.  This happens automatically if their names match and the variable in the shader is declared with the <code>uniform</code> qualifier already mentioned - the so-called binding.  When we get to the examples, this moment will be immediately clear. <br><br>  If we consider the whole process as abstract as possible, then the graphic representation of the QML element is transferred by the texture to the vertex and fragment shaders, and then the final result is displayed, which will be displayed on the screen.  Accordingly, it is possible to make changes in the rendering of this texture in shader programs (we are again returning to why shaders are needed at all). <br><br>  Below we will consider a few examples and give some explanations to them.  In order not to complicate the material in them, work will be shown everywhere using the example of writing fragment shaders, that is, we will work with pixels. <br><br><a name="Example1"></a><h6>  Example 1. Gradient implementation with shaders </h6><br>  Let's start with a very simple example.  In QML, there is a fairly frequently used <a href="http://doc.qt.nokia.com/4.7-snapshot/qml-rectangle.html">Rectangle</a> element and it has a <code>gradient</code> property.  In the example below, I want to show how the gradient can be achieved using the shader mechanism.  So, a <code>Rectangle</code> element with dimensions 360 by 360 will be created. It is also necessary to add a <code>ShaderEffectItem</code> element as a child to the <code>Rectangle</code> , with the <code>anchors.fill</code> property <code>anchors.fill</code> with a value of <code>parent</code> .  Thus, we say that the shader "covers" the entire parent element.  The code is presented below: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Qt.<span class="hljs-built_in"><span class="hljs-built_in">labs</span></span>.shaders <span class="hljs-number"><span class="hljs-number">1.0</span></span> Rectangle { width: <span class="hljs-number"><span class="hljs-number">360</span></span> height: <span class="hljs-number"><span class="hljs-number">360</span></span> ShaderEffectItem { anchors.fill: parent fragmentShader: <span class="hljs-string"><span class="hljs-string">" varying highp vec2 qt_TexCoord0; void main(void) { lowp vec4 c0 = vec4( 1.0, 1.0, 1.0, 1.0 ); lowp vec4 c1 = vec4( 1.0, 0.0, 0.0, 1.0 ); gl_FragColor = mix( c0, c1, qt_TexCoord0.y ); } "</span></span> } }</code> </pre><br>  Now let's pay attention to the <code>fragmentShader</code> property - it contains the text of the fragment shader program.  First, we define the variable <code>varying highp vec2 qt_TexCoord0</code> , which we get from the vertex shader, although it is not defined by us, it has a default implementation and we can get data from there.  <code>qt_TexCoord0</code> determines, as I understand it, the texture coordinates of the scene as a whole (I will be glad if someone <code>qt_TexCoord0</code> me and tells you what it is called correctly, in terms of computer graphics).  Now let's turn to the <code>main</code> function.  We define in it two vectors <code>c0</code> containing white color (the color is represented as rgba) and c1 is red, and then we assign to the output vector <code>gl_FragColor</code> value obtained for each pixel using the <code>mix</code> function, a linear interpolation function between two values: <br><br>  <code>mix (vec4 x, vec4 y, float a)</code> - is expressed by the formula: <code>x * ( 1.0 - a )+y * a</code> <br><br>  The changing parameter <code>a</code> here will be the <code>.y</code> value of the texture vector corresponding to the vector coordinate along the y axis.  Accordingly, the output will be as follows: <br><img src="https://habrastorage.org/storage1/5b738a77/b3d8ca46/30ba585e/859c4c11.png"><br><br>  Since <code>qt_TexCoord0.y</code> represents the vector coordinate along the <code>y</code> axis, the gradient will be from top to bottom, if, for example, we want a gradient from left to right, we need to replace the line: <br><pre> <code class="cpp hljs">gl_FragColor = mix( c0, c1, qt_TexCoord0.y );</code> </pre><br>  on <br><pre> <code class="cpp hljs">gl_FragColor = mix( c0, c1, qt_TexCoord0.x );</code> </pre><br>  <code>.x</code> means the vector coordinate of <code>x</code> .  And if we want to just paint over everything in red, without any gradient, then there will be such a code (here absolutely all pixels are painted in red): <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ gl_FragColor = vec4 ( <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span> ); }</code> </pre><br>  Instead of the vector coordinates <code>x</code> and <code>y</code> , you can use texture <code>s</code> and <code>t</code> respectively.  The result will be the same.  Source code is available <a href="https://gitorious.org/examplesofgoran/qmlshaders/trees/master/Examples/Example1">here.</a> <br>  Let's try to make some kind of animation using the shader mechanism. <br><br><a name="Example2_1"></a><h6>  Example 2.1 The simplest animation </h6>  Let's apply shaders to work with the image of the planet: <br><img src="https://habrastorage.org/storage1/8132ec0d/2c7b13ce/6e573d52/9f12be8e.jpg"><br><br>  We will do a little bit of a silly effect, but still ... As if the planet beats like a heart.  First you need to use <code>ShaderEffectSource</code> to define a property in the <code>Item</code> element, for example, under the name <code>source</code> .  In the same shader, we specify <code>uniform lowp sampler2D source;</code>  thereby making the binding of our texture (the image of the planet) to the shader code and the ability to make changes to its rendering.  To create any animation you need to change some data in time.  For this, I will use the QML <a href="http://doc.qt.nokia.com/latest/qml-propertyanimation.html">PropertyAnimation</a> element.  And what kind of data we need to change?  Here I want to show an example of how to replace the data of one pixel with the data of another and thereby get the effect of animation.  Those.  for example, we have a pixel with x, y texture coordinates (as well as color data), and we substitute some neighboring pixel (with our own color data) instead, and we will choose it as some increment obtained for some functions, let it be a <code>sin</code> function.  Therefore, as variable data, it is desirable to have an angle from 0 to 360 degrees.  Thus, if you look at the code below in <code>PropertyAnimation</code> angle property is set to change from <code>0.0</code> to <code>360.0</code> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Qt.<span class="hljs-built_in"><span class="hljs-built_in">labs</span></span>.shaders <span class="hljs-number"><span class="hljs-number">1.0</span></span> Item { width: img.width height: img.height Image { id: img source: <span class="hljs-string"><span class="hljs-string">"images/space.jpg"</span></span> } ShaderEffectItem { property variant source: ShaderEffectSource { sourceItem: img; hideSource: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } anchors.fill: img fragmentShader: <span class="hljs-string"><span class="hljs-string">" varying highp vec2 qt_TexCoord0; uniform lowp sampler2D source; uniform highp float angle; void main() { highp float wave = 0.01; highp float wave_x = qt_TexCoord0.x + wave * sin( radians( angle + qt_TexCoord0.x * 360.0 ) ); highp float wave_y = qt_TexCoord0.y + wave * sin( radians( angle + qt_TexCoord0.y * 360.0 ) ); highp vec4 texpixel = texture2D( source, vec2( wave_x, wave_y ) ); gl_FragColor = texpixel; }"</span></span> property real angle : <span class="hljs-number"><span class="hljs-number">0.0</span></span> PropertyAnimation on angle { to: <span class="hljs-number"><span class="hljs-number">360.0</span></span> duration: <span class="hljs-number"><span class="hljs-number">800</span></span> loops: Animation.Infinite } } }</code> </pre><br>  The amplitude of oscillations is set using <code>highp float wave = 0.01</code> .  Why do I need the function of <code>radians</code> I think no need to explain.  But if we substitute just the value of the angle <code>angle</code> picture will simply move different sides, and we also need something more spectacular - a ‚Äúbeating‚Äù.  Texture coordinates vary from 0 to 1, respectively, for each pixel there will be a ‚Äúmultiplication in the sin function by an angle of 360‚Äù.  In <code>wave_x</code> and <code>wave_y</code> I will record the coordinates of a pixel from some neighboring neighborhood, taken along the <code>x</code> axis and along the <code>y</code> axis <code>y</code> respectively.  With <code>texture2D( source, vec2( wave_x, wave_y ) );</code>  we take the values ‚Äã‚Äãof this new pixel and write them into the <code>gl_FragColor</code> we already know. <br>  Here is a video of the result of using such a fragment shader for the image of the planet: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/sPdVM35Jl8U%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhiA4yPuj4Ia9Y8s1GicIZks23aAPA" frameborder="0" allowfullscreen=""></iframe><br>  Source code is available <a href="https://gitorious.org/examplesofgoran/qmlshaders/trees/master/Examples/Example2_1">here.</a> <br><br><a name="Example2_2"></a><h6>  Example 2.2 Creating a menu with animation </h6><br>  It looks pretty nice and I decided to try the same effect for the menu buttons.  So that when you hover on a button, there is an effect similar to the planet.  This description presents an example of creating a menu in QML, from here in <a href="http://doc.qt.nokia.com/latest/qdeclarativedocuments.html">this</a> manual.  Each button is described in <code>Button.qml</code> .  I added a bit to her description of work with shaders.  The fragment shader code is almost the same as the example above, only I slightly increased the oscillation amplitude <code>wave = 0.02</code> : <br>  File Button.qml: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Qt.<span class="hljs-built_in"><span class="hljs-built_in">labs</span></span>.shaders <span class="hljs-number"><span class="hljs-number">1.0</span></span> Item { width: but.width height: but.height property alias text: textItem.text Rectangle { id: but width: <span class="hljs-number"><span class="hljs-number">130</span></span>; height: <span class="hljs-number"><span class="hljs-number">40</span></span> border.width: <span class="hljs-number"><span class="hljs-number">1</span></span> radius: <span class="hljs-number"><span class="hljs-number">5</span></span> smooth: <span class="hljs-literal"><span class="hljs-literal">true</span></span> gradient: Gradient { GradientStop { position: <span class="hljs-number"><span class="hljs-number">0.0</span></span>; color: <span class="hljs-string"><span class="hljs-string">"darkGray"</span></span> } GradientStop { position: <span class="hljs-number"><span class="hljs-number">0.5</span></span>; color: <span class="hljs-string"><span class="hljs-string">"black"</span></span> } GradientStop { position: <span class="hljs-number"><span class="hljs-number">1.0</span></span>; color: <span class="hljs-string"><span class="hljs-string">"darkGray"</span></span> } } Text { id: textItem anchors.centerIn: parent font.pointSize: <span class="hljs-number"><span class="hljs-number">20</span></span> color: <span class="hljs-string"><span class="hljs-string">"white"</span></span> } MouseArea { property <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ent: <span class="hljs-literal"><span class="hljs-literal">false</span></span> id: moousearea anchors.fill: parent onEntered: { ent = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } onExited: { ent = <span class="hljs-literal"><span class="hljs-literal">false</span></span> effect.angle = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } hoverEnabled: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ShaderEffectItem { id: effect property variant source: ShaderEffectSource { sourceItem: but; hideSource: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } anchors.fill: but property real angle : <span class="hljs-number"><span class="hljs-number">0.0</span></span> PropertyAnimation on angle { id: prop1 to: <span class="hljs-number"><span class="hljs-number">360.0</span></span> duration: <span class="hljs-number"><span class="hljs-number">800</span></span> loops: Animation.Infinite running: moousearea.ent } fragmentShader: <span class="hljs-string"><span class="hljs-string">" varying highp vec2 qt_TexCoord0; uniform lowp sampler2D source; uniform highp float angle; void main() { highp float wave = 0.02; highp float wave_x = qt_TexCoord0.x + wave * sin( radians( angle + qt_TexCoord0.x * 360.0 ) ); highp float wave_y = qt_TexCoord0.y + wave * sin( radians( angle + qt_TexCoord0.y * 360.0 ) ); highp vec4 texpixel = texture2D( source, vec2( wave_x, wave_y ) ); gl_FragColor = texpixel; }"</span></span> } }</code> </pre><br><br>  Well, the menu.qml file itself <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Qt.<span class="hljs-built_in"><span class="hljs-built_in">labs</span></span>.shaders <span class="hljs-number"><span class="hljs-number">1.0</span></span> Item { width: <span class="hljs-number"><span class="hljs-number">150</span></span> height: <span class="hljs-number"><span class="hljs-number">190</span></span> Column { anchors.horizontalCenter: parent.horizontalCenter Button { text: <span class="hljs-string"><span class="hljs-string">"Apple"</span></span> } Button { text: <span class="hljs-string"><span class="hljs-string">"Red"</span></span> } Button { text: <span class="hljs-string"><span class="hljs-string">"Green"</span></span> } Button { text: <span class="hljs-string"><span class="hljs-string">"Blue"</span></span> } } }</code> </pre><br>  I want to draw attention to the fact that in the <code>onExited</code> event, <code>onExited</code> necessary to reset the angle property of the <code>effect</code> element element to 0.0, otherwise the angle substituted into the calculation of the neighboring pixel will begin to be calculated not from 0, but from the last value, and not exactly what we expect.  The result is this effect: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/E8yudYV0kf4%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhirynXGYcS_uY8mP52RO2jtxGY_iw" frameborder="0" allowfullscreen=""></iframe><br><br>  Source code is available <a href="https://gitorious.org/examplesofgoran/qmlshaders/trees/master/Examples/Example2_2">here.</a> <br><br><a name="Example3"></a><h6>  Example 3. Select some area of ‚Äã‚Äãthe texture depending on the mouse pointer. </h6><br>  Next, I want to give an example of changing the color of pixels in some part of the image.  The area will be determined by the position of the mouse pointer, which will be the center of a circle with a radius of 50 pixels.  And this circle will have colors of pixels different from the original. <br>  First, in this example, you need to define 3 properties in the <code>ShaderEffectItem</code> element: <br> <code>property real xPos: 65.0</code> <br> <code>property real yPos: 65.0</code> <br> <code>property real radius: 50</code> <br>  They will determine, respectively, the coordinates of the mouse, passed into the shader code and the radius of the circle.  The <code>MouseArea</code> element and handling of the <code>onPositionChanged</code> event are defined to track the mouse movement.  Below is the source code and further explanation: <br><pre> <code class="cpp hljs">Rectangle { width: img.width height: img.height Image { id: img source: <span class="hljs-string"><span class="hljs-string">"images/nature.jpg"</span></span> } ShaderEffectItem { id: effect anchors.fill: parent MouseArea { id: coords anchors.fill: parent onPositionChanged: { effect.xPos = mouse.x effect.yPos = coords.height - mouse.y } } property real xPos: <span class="hljs-number"><span class="hljs-number">65.0</span></span> property real yPos: <span class="hljs-number"><span class="hljs-number">65.0</span></span> property real radius: <span class="hljs-number"><span class="hljs-number">50</span></span> property <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> widthImage: img.width property <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> heightImage: img.height property variant source: ShaderEffectSource { sourceItem: img; hideSource: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } fragmentShader: <span class="hljs-string"><span class="hljs-string">"varying highp vec2 qt_TexCoord0; uniform highp float xPos; uniform highp float yPos; uniform highp float radius; uniform highp int widthImage; uniform highp int heightImage; highp vec2 pixcoords = qt_TexCoord0.st * vec2( widthImage, heightImage ); uniform sampler2D source; void main(void) { lowp vec4 texColor = texture2D(source, qt_TexCoord0.st); lowp float gray = dot( texColor, vec4( 0.6, 0.5, 0.1, 0.0 ) ); if ( ( pow( ( xPos - pixcoords.x ), 2 ) + pow( ( yPos - pixcoords.y ), 2 ) ) &lt; pow( radius, 2 ) ) { gl_FragColor = vec4( gray, gray, gray, texColor.a) ; } else { gl_FragColor = texture2D( source, qt_TexCoord0 ); } }"</span></span> } }</code> </pre><br>  You can see that the pow squaring function is used (it works similarly to the function with the same name in C / C ++ from the math library) to determine whether a point of a given pixel with a coordinate ( <code>pixcoords.x; pixcoords.y</code> ) <code>pixcoords.x; pixcoords.y</code> into a circle with center at <code>xPos</code> and <code>yPos</code> and <code>radius</code> . <br>  Accordingly, if the pixel coordinate falls into our circle, then the result is a pixel scalarly multiplied by a vector that defines gray color (the <code>dot</code> function performs the scalar product).  If not, then the specific pixel does not change.  Again, you can see how the intermittent QML of an element is associated with shader program variables ‚Äî they have the same name and equivalent types: <code>real</code> equivalent to <code>highp float</code> . <br>  The output of the following: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/2Rn4drRN2dw%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhi2yGoz2zB-3PcA9mISxYexTwES8A" frameborder="0" allowfullscreen=""></iframe><br><br>  It is worth noting that here we apply conditional operators (exactly the same as in C), which are available in GLSL. <br>  Source code is available <a href="https://gitorious.org/examplesofgoran/qmlshaders/trees/master/Examples/Example3">here.</a> <br><br><a name="Example4"></a><h6>  Example 4. Mixing two images (textures) </h6><br>  Suppose we have two pictures: <br>  Coffee mug <br><img src="http://habrastorage.org/storage1/3618ec33/fb580a74/2a3f7e07/fe59f7c1.jpg"><br>  and coffee beans: <br><img src="http://habrastorage.org/storage1/eec98ba5/a6d7dc99/7837b957/eb5f1e55.jpg"><br>  We want to make a background in the form of coffee beans and a coffee mug on it.  To solve this problem, we will again need to work with texture coordinates.  In <code>ShaderEffectItem</code> two images <code>texture0</code> and <code>ShaderEffectItem</code> will be defined as elements of <code>ShaderEffectSource</code> .  In the fragment shader code, these two images will be stored as two textures in a <code>uniform sampler2D texture0</code> and a <code>uniform sampler2D texture1</code> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the variables </font></font><code>s1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>s2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we get the texture coordinates of each pixel of the first image and the second, respectively, as shown in the code below:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Qt.<span class="hljs-built_in"><span class="hljs-built_in">labs</span></span>.shaders <span class="hljs-number"><span class="hljs-number">1.0</span></span> Rectangle { width: coffee.width height: coffee.height Image { id: coffee source: <span class="hljs-string"><span class="hljs-string">"images/coffee.jpg"</span></span> } Image { id: granules source: <span class="hljs-string"><span class="hljs-string">"images/granules.jpg"</span></span> } ShaderEffectItem { anchors.fill: parent id: effect property variant texture0: ShaderEffectSource { sourceItem: coffee; hideSource: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } property variant texture1: ShaderEffectSource { sourceItem: granules; hideSource: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } fragmentShader: <span class="hljs-string"><span class="hljs-string">" varying highp vec2 qt_TexCoord0; uniform sampler2D texture0; uniform sampler2D texture1; void main(void) { vec4 s1 = texture2D( texture0, qt_TexCoord0.st ); vec4 s2 = texture2D( texture1, qt_TexCoord0.st ) ; gl_FragColor = mix( vec4( s1.r, s1.g, s1.b, 1.0 ), vec4( s2.r * 0.6, s2.g * 0.6, s2.b * 0.6, 0.4 ), 0.35 ); }"</span></span> } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result vector </font></font><code>gl_FrontColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be recorded already familiar to us (during the creation of the gradient) the result of linear interpolation of two vectors containing the pixel color parameters. </font><font style="vertical-align: inherit;">Moreover, each channel of color in the texture s2 (coffee beans will be multiplied by 0.6, since we need it as a background). </font><font style="vertical-align: inherit;">As a result, we have the following result: </font></font><br><br><img src="http://habrastorage.org/storage1/6ce2b719/cfd81a4e/4f59ebb5/5f250d52.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can make a lot of experimental options with the parameters of the mix function and vector values ‚Äã‚Äã(for example, the fourth element of the vector responsible for transparency, 1.0 and 0.4 in the example above) and get different, interestingly mixed textures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source code is available </font></font><a href="https://gitorious.org/examplesofgoran/qmlshaders/trees/master/Examples/Example4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here.</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, I want to say that I think the examples given are fairly simple and trivial, but on the other hand, they can be useful to those who are not at all familiar with this topic and want to try to do something similar.</font></font><br><br><a name="Conclusion"></a><h5>  Conclusion </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summing up, we can say that thanks to the possibility of writing shader programs, we get very flexible mechanisms for working with the most important stages of processing OpenGL graphics when rendering QML elements. It is also worth noting that the GLSL language, as already mentioned, is very similar to C, but as stated in the official specification there are differences. For example, there are no pointers (data is passed to a function by value), recursion cannot be used in any way, etc. It should be remembered that a badly or incorrectly written shader program can have a dramatic effect on performance. The operation of these plug-ins has been tested on platforms: Symbian ^ 3, Maemo 5, Mac OS X, Windows 7 and Ubuntu. The platform requirements themselves are the Qt SDK version 4.7.x and QtOpenGL support.A future version of QML - QML2 in its Scene Graph will support the API combining GL / GLES shaders with QML code. You can consider the element in Qt 5.0</font></font><a href="http://doc.qt.nokia.com/qt5/qml-qtquick2-shadereffect.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShaderEffect</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If I correctly understood this and there is some semblance of what I wrote above.</font></font><br><br><a name="Links"></a><h5>  useful links </h5><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I recommend to get acquainted with the official </font></font><a href="http://www.opengl.org/documentation/glsl/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specification of OpenGL ES</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="http://labs.qt.nokia.com/2011/05/03/qml-shadereffectitem-on-qgraphicsview/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QML ShaderEffectItem on QGraphicsView</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - here you can see examples of videos, shaders work on Nokia N8.</font></font></li><li> <a href="http://www.lighthouse3d.com/tutorials/glsl-tutorial/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLSL guide</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the theory of shaders work is described very well (sometimes the site lies with them, so don't be scared :))</font></font></li><li> <a href="http://doc.qt.nokia.com/latest/declarative-shadereffects.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 interesting shader implementations</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt Quick 2 QML Scene Graph GLSL fragment shader </font></font><a href="http://ilkka.github.com/blog/2011/03/04/qtquick_2_scenegraph_glsl_fragment_shader_tutorial/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tutorial</font></font></a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/133828/">https://habr.com/ru/post/133828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133823/index.html">How to become a successful freelancer</a></li>
<li><a href="../133824/index.html">Person rating of the Russian market of customized web development Tagline-2011</a></li>
<li><a href="../133825/index.html">Wikileaks will publish documents about companies that create technology to spy on people</a></li>
<li><a href="../133826/index.html">Viola-Jones method (Viola-Jones) as a basis for facial recognition</a></li>
<li><a href="../133827/index.html">Network game in NES (Dendy) implemented on Flash P2P</a></li>
<li><a href="../133830/index.html">Wireless Joys: Samsung CA750 Monitor Review</a></li>
<li><a href="../133835/index.html">We remove the Store button in the music player iOS 5</a></li>
<li><a href="../133836/index.html">Replacing the menu of calls in iOS with an alternative one</a></li>
<li><a href="../133839/index.html">The state search took place: an e-government or state search bot began walking on Runet</a></li>
<li><a href="../133841/index.html">Technology company implements the policy ‚Äúwork without Email‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>