<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linux kernel boot. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From bootloader to kernel 

 If you read the previous articles , you know about my new hobby for low-level programming. I have written several article...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linux kernel boot. Part 1</h1><div class="post__text post__text-html js-mediator-article"> <b>From bootloader to kernel</b> <br><br>  If you read the previous <a href="https://0xax.github.io/categories/assembler/">articles</a> , you know about my new hobby for low-level programming.  I have written several articles on programming in assembler for <code>x86_64</code> Linux and at the same time began to dive into the source code of the Linux kernel. <br><br>  I am very interested in understanding how low-level things work: how programs run on my computer, how they are located in memory, how the kernel manages processes and memory, how the network stack works at a low level and much more.  So, I decided to write another series of articles on the Linux kernel for the <b>x86_64 architecture</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Please note that I am not a professional kernel developer and do not write kernel code at work.  This is just a hobby.  I just like low-level things and it's interesting to dig into them.  Therefore, if you notice any confusion or have any questions / comments, contact me <a href="https://twitter.com/0xAX">on twitter</a> , by <a href="">mail,</a> or simply create a <a href="https://github.com/0xAX/linux-insides/issues/new">ticket</a> .  I will be grateful. <br><a name="habracut"></a><br>  All articles are published in <a href="https://github.com/0xAX/linux-insides">the GitHub repository</a> , and if something is wrong with my English or article content, feel free to send a pull-request. <br><br>  <i>Please note that this is not official documentation, but simply training and knowledge sharing.</i> <br><br>  <b>Required knowledge</b> <br><br><ul><li>  Understanding C Code </li><li>  Understanding assembly code (AT &amp; T syntax) </li></ul><br>  Anyway, if you are just starting to learn such tools, I will try to explain something in this and the following articles.  Okay, with the introduction finished, it's time to dive into the Linux kernel and low-level stuff. <br><br>  I started writing this book in the days of the Linux 3.18 kernel, and a lot could have changed since then.  If there are changes, I will update the articles accordingly. <br><br><h1>  Magic power button, what's next? </h1><br>  Although these are articles on the Linux kernel, we have not yet reached it - at least in this paragraph.  As soon as you press the magic power button on your laptop or desktop computer, it starts working.  The motherboard sends a signal to the <a href="https://en.wikipedia.org/wiki/Power_supply">power supply</a> .  After receiving the signal, it provides the computer with the necessary amount of electricity.  As soon as the motherboard receives a <a href="https://en.wikipedia.org/wiki/Power_good_signal">‚ÄúPower OK‚Äù signal</a> , it tries to start the CPU.  He drops all the remaining data in his registers and sets the predefined values ‚Äã‚Äãfor each of them. <br><br>  Processors <a href="https://en.wikipedia.org/wiki/Intel_80386">80386</a> and later should have the following values ‚Äã‚Äãin the CPU registers after a reboot: <br><br><pre>  IP 0xfff0
 CS selector 0xf000
 CS base 0xffff0000 </pre><br>  The processor starts to work in <a href="https://en.wikipedia.org/wiki/Real_mode">real mode</a> .  Let's go back a little and try to understand <a href="https://en.wikipedia.org/wiki/Memory_segmentation">the memory segmentation</a> in this mode.  Real mode is supported on all x86-compatible processors: from <a href="https://en.wikipedia.org/wiki/Intel_8086">8086</a> to modern 64-bit Intel processors.  The 8086 processor uses a 20-bit address bus, that is, it can work with an address space of <code>0-0xFFFFF</code> or <code>1 </code> .  But it has only 16-bit registers with a maximum address of <code>2^16-1</code> or <code>0xffff</code> (64 kilobytes). <br><br>  <a href="https://en.wikipedia.org/wiki/Memory_segmentation">Memory segmentation is</a> needed to use the entire available address space.  All memory is divided into small fixed-size segments of <code>65536</code> bytes (64 KB).  Since with 16-bit registers we cannot access memory above 64 KB, an alternative method was developed. <br><br>  The address consists of two parts: 1) a segment selector with a base address;  2) offset from the base address.  In real mode, the base address of the segment <code>  * 16</code> .  Thus, to get a physical address in memory, multiply the segment selector by 16 and add an offset to it: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  For example, if the <code>CS:IP</code> register has the value <code>0x2000:0x0010</code> , then the corresponding physical address would be: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0x2000</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0x0010</span></span>) <span class="hljs-string"><span class="hljs-string">'0x20010'</span></span></code> </pre> <br>  But if we take the selector of the largest segment and the offset <code>0xffff:0xffff</code> , we get the address: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  that is, <code>65520</code> bytes after the first megabyte.  Since only one megabyte is available in real mode, <code>0x10ffef</code> becomes <code>0x00ffef</code> with <a href="https://en.wikipedia.org/wiki/A20_line">the A20 line</a> disabled. <br><br>  Well, now we know a little about real mode and memory addressing in this mode.  Returning to the discussion of register values ‚Äã‚Äãafter a reset. <br><br>  The <code>CS</code> register consists of two parts: a visible segment selector and a hidden base address.  Although the base address is usually formed by multiplying the value of the segment selector by 16, but during a hardware reset, the segment selector in the CS register is set to <code>0xf000</code> , and the base address is <code>0xffff0000</code> .  The processor uses this special base address until the CS changes. <br><br>  The starting address is formed by adding the base address to the value in the EIP register: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span> + <span class="hljs-number"><span class="hljs-number">0xfff0</span></span> <span class="hljs-string"><span class="hljs-string">'0xfffffff0'</span></span></code> </pre> <br>  We get <code>0xfffffff0</code> , which is 16 bytes below 4 GB.  This point is called the <a href="https://en.wikipedia.org/wiki/Reset_vector">reset vector</a> .  This is the memory location where the CPU waits for the first instruction to be executed after a reset: a jump operation ( <a href="https://en.wikipedia.org/wiki/JMP_%2528x86_instruction%2529">jmp</a> ), which usually points to the BIOS entry point.  For example, if you look at the <a href="https://www.coreboot.org/">coreboot</a> source code ( <code>src/cpu/x86/16bit/reset16.inc</code> ), we will see: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.section</span></span> "<span class="hljs-selector-class"><span class="hljs-selector-class">.reset</span></span>", "<span class="hljs-selector-tag"><span class="hljs-selector-tag">ax</span></span>", %<span class="hljs-selector-tag"><span class="hljs-selector-tag">progbits</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.code16</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xe9</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.int</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">start16bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> ( . + 2 ) ...</code> </pre> <br>  Here we see the <a href="http://ref.x86asm.net/coder32.html">opcode</a> ( <a href="http://ref.x86asm.net/coder32.html">opcode</a> ) <code>jmp</code> , namely <code>0xe9</code> , and the destination address <code>_start16bit - ( . + 2)</code> . <br><br>  We also see that the <code>reset</code> section is 16 bytes, and it is compiled to run from <code>0xfffff0</code> ( <code>src/cpu/x86/16bit/reset16.ld</code> ): <br><br><pre> <code class="hljs pgsql">SECTIONS { <span class="hljs-comment"><span class="hljs-comment">/* Trigger an error if I have an unuseable start address */</span></span> _bogus = <span class="hljs-keyword"><span class="hljs-keyword">ASSERT</span></span>(_start16bit &gt;= <span class="hljs-number"><span class="hljs-number">0xffff0000</span></span>, "_start16bit too low. Please report."); _ROMTOP = <span class="hljs-number"><span class="hljs-number">0xfffffff0</span></span>; . = _ROMTOP; .<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span> . : { *(.<span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>); . = <span class="hljs-number"><span class="hljs-number">15</span></span>; BYTE(<span class="hljs-number"><span class="hljs-number">0x00</span></span>); } }</code> </pre> <br>  Now the BIOS is running;  After initializing and checking the BIOS hardware, you need to find the boot device.  The boot order is stored in the BIOS configuration.  When trying to boot from the hard disk BIOS tries to find the boot sector.  On disks with <a href="https://en.wikipedia.org/wiki/Master_boot_record">partitioning MBR, the</a> boot sector is stored in the first 446 bytes of the first sector, where each sector is 512 bytes.  The last two bytes of the first sector are <code>0x55</code> and <code>0xaa</code> .  They show the BIOS that it is a bootable device. <br><br>  For example: <br><br><pre> <code class="hljs mel">; ; :       Intel x86 ; [BITS <span class="hljs-number"><span class="hljs-number">16</span></span>] boot: mov al, <span class="hljs-string"><span class="hljs-string">'!'</span></span> mov ah, <span class="hljs-number"><span class="hljs-number">0x0e</span></span> mov bh, <span class="hljs-number"><span class="hljs-number">0x00</span></span> mov bl, <span class="hljs-number"><span class="hljs-number">0x07</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x10</span></span> jmp $ times <span class="hljs-number"><span class="hljs-number">510</span></span>-($-$$) db <span class="hljs-number"><span class="hljs-number">0</span></span> db <span class="hljs-number"><span class="hljs-number">0x55</span></span> db <span class="hljs-number"><span class="hljs-number">0xaa</span></span></code> </pre> <br>  We collect and run: <br><br> <code>nasm -f bin boot.nasm &amp;&amp; qemu-system-x86_64 boot</code> <br> <br>  <a href="http://qemu.org/">QEMU</a> receives a command to use the binary <code>boot</code> file, which we have just created as a disk image.  Since the binary file generated above satisfies the requirements of the boot sector (start at <code>0x7c00</code> and completion with a magic sequence), QEMU will treat the binary file as the master boot record (MBR) of the disk image. <br><br>  You will see: <br><br><img src="https://habrastorage.org/webt/e1/rk/nw/e1rknwgwcuouazuhzrmco1b8szg.png"><br><br>  In this example, we see that the code runs in a 16-bit real mode and starts at address <code>0x7c00</code> in memory.  After launching, it causes a <a href="http://www.ctyme.com/intr/rb-0106.htm">0x10</a> interrupt, which simply prints the character <code>!</code>  ;  fills the remaining 510 bytes with zeros and ends with two magic bytes <code>0xaa</code> and <code>0x55</code> . <br><br>  A binary dump can be viewed with the <code>objdump</code> utility: <br><br> <code>nasm -f bin boot.nasm <br> objdump -D -b binary -mi386 -Maddr16,data16,intel boot</code> <br> <br>  Of course, in the real boot sector - the code to continue the boot process and the partition table instead of a heap of zeros and an exclamation mark :).  From this moment on, the BIOS transfers control to the loader. <br><br>  <i>Note</i> : As explained above, the CPU is in real mode;  where the calculation of the physical address in memory is as follows: <br><br><pre> <code class="hljs">  =   * 16 + </code> </pre> <br>  We have only 16-bit general-purpose registers, and the maximum value of the 16-bit register is <code>0xffff</code> , so for the largest values ‚Äã‚Äãthe result will be: <br><br><pre> <code class="hljs ruby"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;</span></span>&gt; hex((<span class="hljs-number"><span class="hljs-number">0xffff</span></span> * <span class="hljs-number"><span class="hljs-number">16</span></span>) + <span class="hljs-number"><span class="hljs-number">0xffff</span></span>) <span class="hljs-string"><span class="hljs-string">'0x10ffef'</span></span></code> </pre> <br>  where <code>0x10ffef</code> is <code>1  + 64  - 16 </code> .  In the processor <a href="https://en.wikipedia.org/wiki/Intel_8086">8086</a> (the first processor with real mode) 20-bit address line.  Since <code>2^20 = 1048576</code> , the actual available memory is 1 MB. <br><br>  In general, real-mode memory addressing is as follows: <br><br><pre>  0x00000000 - 0x000003FF - table of real-mode interrupt vectors
 0x00000400 - 0x000004FF - BIOS data area
 0x00000500 - 0x00007BFF - not used
 0x00007C00 - 0x00007DFF - our bootloader
 0x00007E00 - 0x0009FFFF - not used
 0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory 
 0x000B0000 - 0x000B7777 - monochrome video memory
 0x000B8000 - 0x000BFFFF - color mode video memory
 0x000C0000 - 0x000C7FFF - Video ROM BIOS
 0x000C8000 - 0x000EFFFF - shadow area (BIOS Shadow)
 0x000F0000 - 0x000FFFFF - system BIOS </pre><br>  At the beginning of the article it is written that the first instruction for the processor is located at <code>0xFFFFFFF0</code> , which is much more than <code>0xFFFFF</code> (1 MB).  How does the CPU access this address in real mode?  Answer in <a href="https://www.coreboot.org/Developer_Manual/Memory_map">coreboot</a> documentation: <br><br> <code>0xFFFE_0000 - 0xFFFF_FFFF: 128  ROM    </code> <br> <br>  At the beginning of the execution of the BIOS is not in RAM, but in ROM. <br><br><h1>  Loader </h1><br>  The Linux kernel can be loaded with different boot loaders, such as <a href="https://www.gnu.org/software/grub/">GRUB 2</a> and <a href="http://www.syslinux.org/wiki/index.php/The_Syslinux_Project">syslinux</a> .  The kernel has a boot protocol that defines boot requirements for implementing Linux support.  In this example, we are working with GRUB 2. <br><br>  Continuing the boot process, the BIOS chose the boot device and transferred control to the boot sector, execution begins with <a href="http://git.savannah.gnu.org/gitweb/%3Fp%3Dgrub.git%3Ba%3Dblob%3Bf%3Dgrub-core/boot/i386/pc/boot.S%3Bhb%3DHEAD">boot.img</a> .  Due to the limited size, this is a very simple code.  It contains a pointer to go to the main GRUB 2 image. It starts with <a href="http://git.savannah.gnu.org/gitweb/%3Fp%3Dgrub.git%3Ba%3Dblob%3Bf%3Dgrub-core/boot/i386/pc/diskboot.S%3Bhb%3DHEAD">diskboot.img</a> and is usually stored immediately after the first sector in the unused space before the first partition.  The above code loads into memory the rest of the image that contains the GRUB 2 kernel and the drivers for processing file systems.  After that, the <a href="http://git.savannah.gnu.org/gitweb/%3Fp%3Dgrub.git%3Ba%3Dblob%3Bf%3Dgrub-core/kern/main.c">grub_main</a> function is <a href="http://git.savannah.gnu.org/gitweb/%3Fp%3Dgrub.git%3Ba%3Dblob%3Bf%3Dgrub-core/kern/main.c">executed</a> . <br><br>  The <code>grub_main</code> function initializes the console, returns the base address for the modules, sets the root device, loads / parses the grub configuration file, loads the modules, etc.  At the end of the execution, it puts grub into normal mode.  The <code>grub_normal_execute</code> function (from the <code>grub-core/normal/main.c</code> source file) completes the final preparations and shows the menu for selecting the operating system.  When we select one of the grub menu items, the <code>grub_menu_execute_entry</code> function <code>grub_menu_execute_entry</code> , which executes the grub <code>boot</code> command and loads the selected OS. <br><br>  As stated in the kernel boot protocol, the bootloader must read and fill in some of the kernel installation header fields, which start at offset <code>0x01f1</code> from the kernel installation code.  This offset is specified in the <a href="">linker script</a> .  The <a href="">arch / x86 / boot / header.S kernel header</a> begins with: <br><br><pre> <code class="hljs css"> <span class="hljs-selector-class"><span class="hljs-selector-class">.globl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hdr</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">setup_sects</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_flags</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ROOT_RDONLY</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">syssize</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">ram_size</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">vid_mode</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SVGA_MODE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">root_dev</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">boot_flag</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xAA55</span></span></code> </pre> <br>  The loader must fill this and other headers (which are marked only as type <code>write</code> in the Linux boot protocol, as in this example) with values ‚Äã‚Äãthat were received from the command line or calculated at boot time.  Now we will not dwell on the descriptions and explanations for all the header fields.  We'll discuss later how the kernel uses them.  For a description of all the fields, see <a href="https://github.com/torvalds/linux/blob/v4.16/Documentation/x86/boot.txt">the download protocol</a> . <br><br>  As you can see in the kernel boot protocol, the memory will be displayed as follows: <br><br><pre>  |  Kernel protected mode |
 100,000 + ------------------------ +
          |  I / O mapping |
 0A0000 + ------------------------ +
          |  Reserved.  for BIOS |  Leave as much as possible free
          ~ ~
          |  Command Line |  (may also be behind the X + 10000 mark)
 X + 10,000 + ------------------------ +
          |  Stack / pile |  To use real kernel mode code
 X + 08000 + ------------------------ +
          |  Kernel installation |  Real kernel mode code
          |  Kernel boot sector |  Legacy kernel boot sector
        X + ------------------------ +
          |  Bootloader |  &lt;- Entry point 0x7C00 boot sector
 001000 + ------------------------ +
          |  Reserved.  for MBR / BIOS |
 000800 + ------------------------ +
          |  Usually used  MBR |
 000600 + ------------------------ +
          |  Use  BIOS only |
 000000 + ------------------------ +
</pre><br>  So, when the loader transfers control to the kernel, it starts with the address: <br><br><pre> <code class="hljs lisp">X + sizeof (<span class="hljs-name"><span class="hljs-name">KernelBootSector</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  where <code>X</code> is the address of the kernel boot sector.  In our case, <code>X</code> is <code>0x10000</code> , as seen in the memory dump: <br><br><img src="https://habrastorage.org/webt/ot/1u/ep/ot1uepwbgvghzktwcbwwskwwjbs.png"><br><br>  The loader transferred the Linux kernel to memory, filled in the header fields, and then moved to the appropriate memory address.  Now we can go directly to the kernel installation code. <br><br><h1>  Starting the kernel installation phase </h1><br>  We are finally at the core!  Although technically it is not yet running.  First, the kernel installation part has to adjust something, including the decompressor and some things with memory management.  After all this, she will unpack the real core and go to it.  The installation starts at <a href="">arch / x86 / boot / header.S</a> with the <a href="">_start</a> symbol. <br><br>  At first glance, this may seem a little strange, since there are several instructions in front of it.  But a long time ago, the Linux kernel had its own loader.  Now, if you run, for example, <br><br> <code>qemu-system-x86_64 vmlinuz-3.18-generic</code> <br> <br>  you will see: <br><br><img src="https://habrastorage.org/webt/4r/5f/xg/4r5fxgpwl4l2vwlw9muscl3ygie.png"><br><br>  Actually, the file <code>header.S</code> starts with the magic number <a href="https://en.wikipedia.org/wiki/DOS_MZ_executable">MZ</a> (see screenshot of the dump above), the text of the error message and the <a href="https://en.wikipedia.org/wiki/Portable_Executable">PE</a> header: <br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#ifdef</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CONFIG_EFI_STUB</span></span> # "<span class="hljs-selector-tag"><span class="hljs-selector-tag">MZ</span></span>", <span class="hljs-selector-tag"><span class="hljs-selector-tag">MS-DOS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">header</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x4d</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x5a</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#endif</span></span> ... ... ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">pe_header</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.ascii</span></span> "<span class="hljs-selector-tag"><span class="hljs-selector-tag">PE</span></span>" <span class="hljs-selector-class"><span class="hljs-selector-class">.word</span></span> 0</code> </pre> <br>  It is needed to load the operating system with <a href="https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface">UEFI</a> support.  His device will consider in the following chapters. <br><br>  The actual entry point for the kernel installation: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// header.S line 292 .globl _start _start:</span></span></code> </pre> <br>  The loader (grub2 and others) knows about this point (offset <code>0x200</code> from <code>MZ</code> ) and goes straight to it, although <code>header.S</code> begins with the <code>.bstext</code> section, where the text of the error message is: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ arch/x</span></span>86/boot/setup.ld /<span class="hljs-regexp"><span class="hljs-regexp">/ . = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ current position .bstext : { *(.bstext) } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ put .bstext section to position 0 .bsdata : { *(.bsdata) }</span></span></code> </pre> <br>  Kernel installation entry point: <br><br><pre> <code class="hljs go"> .globl _start _start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// // rest of the header //</span></span></code> </pre> <br>  Here we see the operation code <code>jmp</code> ( <code>0xeb</code> ), which goes to the point <code>start_of_setup-1f</code> .  In the <code>Nf</code> notation, for example, <code>2f</code> refers to the local label <code>2:</code>  In our case, this is label <code>1</code> , which is present immediately after the transition, and it contains the rest of the setup header.  Immediately after the installation header, we see the <code>.entrytext</code> section, which starts with the <code>start_of_setup</code> tag. <br><br>  This is the first actually executed code (except for the previous transition instructions, of course).  After part of the kernel installation gets control from the loader, the first <code>jmp</code> instruction is at offset <code>0x200</code> from the beginning of the real kernel mode, that is, after the first 512 bytes.  This can be seen both in the Linux kernel boot protocol and in the grub2 source code: <br><br><pre> <code class="hljs ruby">segment = grub_linux_real_target <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">4</span></span>; state.gs = state.fs = state.es = state.ds = state.ss = segment; state.cs = segment + <span class="hljs-number"><span class="hljs-number">0x20</span></span>;</code> </pre> <br>  In our case, the kernel is loaded at <code>0x10000</code> .  This means that after starting the kernel installation, the registers of the segments will have the following values: <br><br> <code>gs = fs = es = ds = ss = 0x10000 <br> cs = 0x10200</code> <br> <br>  After moving to <code>start_of_setup</code> kernel should do the following: <br><br><ul><li>  Ensure all segment register values ‚Äã‚Äãare the same. </li><li>  If necessary, adjust the correct stack </li><li>  Configure <a href="https://en.wikipedia.org/wiki/.bss">bss</a> </li><li>  Go to code C in <a href="">arch / x86 / boot / main.c</a> </li></ul><br>  Let's see how this is implemented. <br><br><h1>  Alignment of segment registers </h1><br>  First of all, the kernel checks that the registers of the <code>ds</code> and <code>es</code> segments point to the same address.  Then clears the direction flag using the <code>cld</code> instruction: <br><br><pre> <code class="hljs perl"> movw %ds, %ax movw %ax, %es cld</code> </pre> <br>  As I wrote earlier, grub2 by default loads the kernel installation code at <code>0x10000</code> , and <code>cs</code> at <code>0x10200</code> , because execution does not start from the beginning of the file, but from going here: <br><br><pre> <code class="hljs go">_start: .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-number"><span class="hljs-number">0xeb</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> start_of_setup<span class="hljs-number"><span class="hljs-number">-1f</span></span></code> </pre> <br>  This offset is <code>512</code> bytes from <a href="">4d 5a</a> .  It is also necessary to align the <code>cs</code> from <code>0x10200</code> to <code>0x10000</code> , as well as all the other segment registers.  After that install the stack: <br><br><pre> <code class="hljs perl"> pushw %ds pushw $6f lretw</code> </pre> <br>  This instruction pushes the value of <code>ds</code> onto the stack, followed by the address of label <a href="">6</a> and the instruction <code>lretw</code> , which loads the address of label <code>6</code> into the <a href="https://en.wikipedia.org/wiki/Program_counter">command counter</a> register and loads <code>cs</code> with the value <code>ds</code> .  After that, <code>ds</code> and <code>cs</code> will have the same values. <br><br><h1>  Stack Setup </h1><br>  Almost all of this code is part of the process of preparing the environment for the C language in real mode.  The next step is to check the value of the <code>ss</code> register and create the correct stack if the <code>ss</code> value is incorrect: <br><br><pre> <code class="hljs perl"> movw %ss, %dx cmpw %ax, %dx movw %sp, %dx je <span class="hljs-number"><span class="hljs-number">2</span></span>f</code> </pre> <br>  This can trigger three different scenarios: <br><br><ul><li>  <code>ss</code> valid value of <code>0x1000</code> (like all other registers except <code>cs</code> ) </li><li>  <code>ss</code> not a valid value, and the <code>CAN_USE_HEAP</code> flag <code>CAN_USE_HEAP</code> set (see below) </li><li>  <code>ss</code> not a valid value, and the <code>CAN_USE_HEAP</code> flag <code>CAN_USE_HEAP</code> not set (see below) </li></ul><br>  Consider all the scenarios in order: <br><br><ul><li>  <code>ss</code> valid value ( <code>0x1000</code> ).  In this case, we go to label 2: </li></ul><br><pre> <code class="hljs mel"><span class="hljs-number"><span class="hljs-number">2</span></span>: andw $~<span class="hljs-number"><span class="hljs-number">3</span></span>, %dx jnz <span class="hljs-number"><span class="hljs-number">3</span></span>f movw $0xfffc, %dx <span class="hljs-number"><span class="hljs-number">3</span></span>: movw %ax, %ss movzwl %dx, %esp sti</code> </pre> <br>  Here we set the <code>dx</code> register alignment (which contains the <code>sp</code> value specified by the loader) by <code>4</code> bytes and check for zero.  If it is equal to zero, then we put in <code>dx</code> value <code>0xfffc</code> (the address aligned by <code>4</code> bytes before the maximum segment size of 64 KB).  If it is not equal to zero, then we continue to use the <code>sp</code> value specified by the loader ( <code>0xf7f4</code> in our case).  Then we put the value of <code>ax</code> in <code>ss</code> , which keeps the correct address of the segment <code>0x1000</code> and sets the correct <code>sp</code> .  Now we have the right stack: <br><br><img src="https://habrastorage.org/webt/wf/dp/bl/wfdpblqpiltzdrprytvnoj3kygo.png"><br><br><ul><li>  In the second scenario, <code>ss != ds</code> .  First we put the <a href="">_end</a> value (the end address of the installation code) into <code>dx</code> and check the <code>loadflags</code> header field using the <code>testb</code> instruction to check if the heap can be used.  <a href="">loadflags</a> is a bitmask header, which is defined as follows: </li></ul><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LOADED_HIGH (1&lt;&lt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUIET_FLAG (1&lt;&lt;5) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KEEP_SEGMENTS (1&lt;&lt;6) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CAN_USE_HEAP (1&lt;&lt;7)</span></span></code> </pre> <br>  and as indicated in the download protocol: <br><br> <code> : loadflags <br> <br>     . <br> <br>  7 (): CAN_USE_HEAP <br>     1,  ,   <br> heap_end_ptr .    ,   <br>   .</code> <br> <br>  If the <code>CAN_USE_HEAP</code> bit is <code>CAN_USE_HEAP</code> , then in <code>dx</code> we set the value of <code>heap_end_ptr</code> (which indicates <code>_end</code> ) and add to it <code>STACK_SIZE</code> (the minimum stack size is <code>1024</code> bytes).  After that, go to label <code>2</code> (as in the previous case) and make the correct stack. <br><br><img src="https://habrastorage.org/webt/1n/be/nw/1nbenww3ncnipvbi1g-jqdvsmok.png"><br><br><ul><li>  If <code>CAN_USE_HEAP</code> not set, simply use the minimum stack from <code>_end</code> to <code>_end + STACK_SIZE</code> : </li></ul><br><img src="https://habrastorage.org/webt/5x/xg/fi/5xxgfikk1iskr_6pgjzvmcwhpjy.png"><br><br><h1>  BSS Setup </h1><br>  Two more steps are needed before moving on to the main C code: this is setting up the <a href="https://en.wikipedia.org/wiki/.bss">BSS area</a> and checking the ‚Äúmagic‚Äù signature.  First check signature: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">cmpl</span></span> <span class="hljs-variable"><span class="hljs-variable">$0</span></span>x5a5aaa55, setup_sig jne setup_bad</code> </pre> <br>  The instruction simply compares <a href="">setup_sig</a> with the magic number 0x5a5aaa55.  If they are not equal, a fatal error is reported. <br><br>  If the magic number is the same and we have a set of correct segment registers and a stack, then it remains only to configure the BSS section before proceeding to code C. <br><br>  The BSS section is used to store statically allocated uninitialized data.  Linux carefully checks that this area of ‚Äã‚Äãmemory has zeroed out: <br><br><pre> <code class="hljs perl"> movw $__bss_start, %di movw $_end+<span class="hljs-number"><span class="hljs-number">3</span></span>, %cx xorl %eax, %eax subw %di, %cx shrw $2, %cx rep; stosl</code> </pre> <br>  First, the starting address of <a href="">__bss_start is</a> moved to <code>di</code> .  Then the address <code>_end + 3</code> (+3 for alignment by 4 bytes) is moved to <code>cx</code> .  The <code>eax</code> register is cleared (using the <code>xor</code> instruction), the size of the bss ( <code>cx-di</code> ) section is calculated and it is placed in <code>cx</code> .  Then <code>cx</code> is divided by four (the size of the ‚Äúword‚Äù) and the instruction <code>stosl</code> used <code>stosl</code> , keeping the value <code></code> (zero) in the address pointing to <code>di</code> , automatically increasing <code>di</code> by four and repeating it until <code></code> reaches zero).  The net effect of this code is that zeros are written to all words in memory from <code>__bss_start</code> to <code>_end</code> : <br><br><img src="https://habrastorage.org/webt/2s/bw/ym/2sbwymhai1qislpkru0btkrolcy.png"><br><br><h1>  Move to main </h1><br>  That's it: we have a stack and a BSS, so we can go to the <code>main()</code> C function: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">calll</span></span> main</code> </pre> <br>  The <code>main()</code> function is in <a href="">arch / x86 / boot / main.c.</a>  We will talk about it in the next part. <br><br><h1>  Conclusion </h1><br>  This is the end of the first part about the Linux kernel device.       ,    <a href="https://twitter.com/0xAX"> </a> ,  <a href=""></a>    <a href="https://github.com/0xAX/linux-insides/issues/new"></a> .         C,      Linux,   ,   <code>memset</code> , <code>memcpy</code> , <code>earlyprintk</code> ,        . <br><br><h1>  Links </h1><br><ul><li> <a href="http://css.csail.mit.edu/6.858/2014/readings/i386.pdf">Intel 80386,  , 1986 .</a> </li><li> <a href="https://www.cs.cmu.edu/~410/doc/minimal_boot.pdf">    Intel</a> </li><li> <a href="https://en.wikipedia.org/wiki/Intel_8086">8086</a> </li><li> <a href="https://en.wikipedia.org/wiki/Intel_80386">80386</a> </li><li> <a href="https://en.wikipedia.org/wiki/Reset_vector"> </a> </li><li> <a href="https://en.wikipedia.org/wiki/Real_mode"> </a> </li><li> <a href="https://www.kernel.org/doc/Documentation/x86/boot.txt">   Linux</a> </li><li> <a href="https://www.coreboot.org/Developer_Manual">Coreboot,  </a> </li><li> <a href="http://www.ctyme.com/intr/int.htm">   </a> </li><li> <a href="https://en.wikipedia.org/wiki/Power_supply"> </a> </li><li> <a href="https://en.wikipedia.org/wiki/Power_good_signal"> ¬´  ¬ª</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/428664/">https://habr.com/ru/post/428664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428654/index.html">MIT course "Computer Systems Security". Lecture 15: "Medical software", part 2</a></li>
<li><a href="../428656/index.html">MIT course "Computer Systems Security". Lecture 15: "Medical Software", part 3</a></li>
<li><a href="../428658/index.html">Free educational workshops at the Mail.Ru Group office</a></li>
<li><a href="../428660/index.html">Apply Extensible Pull Request Policies to VSTS to Support the Development Process</a></li>
<li><a href="../428662/index.html">Retail Programming Challenge</a></li>
<li><a href="../428666/index.html">How I created a mood-changing animation using CSS masks</a></li>
<li><a href="../428668/index.html">Blizzard announced the release of a reissue of WarCraft III in 2019. Pre-order open</a></li>
<li><a href="../428672/index.html">QuietOn Active Squelch Review</a></li>
<li><a href="../428674/index.html">Building client routing / semantic search at Profi.ru</a></li>
<li><a href="../428676/index.html">Breaking down the fundamentals of C #: allocating memory for a reference type on the stack</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>