<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Assistant program for mastering blind typing on a keyboard in Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to show and tell about a small program that has benefited. 

 Once at work a friend wrote to me. Our dialogue took about the following: 
 - Hi,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Assistant program for mastering blind typing on a keyboard in Linux</h1><div class="post__text post__text-html js-mediator-article">  I want to show and tell about a small program that has benefited. <br><br>  Once at work a friend wrote to me.  Our dialogue took about the following: <br>  - Hi, I'm learning blind typing.  The fact is that on Linux there is no program that could help me.  In general, maybe you can quickly write this? <br><br>  So how to help a friend is a holy thing, and the task looked interesting, I agreed to help. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The result is this: <br><br><img src="https://habrastorage.org/files/900/306/b38/900306b38ad24f1fb501c5971fe1c04c.gif"><br><br>  Who cares, details below <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">A warning</b> <div class="spoiler_text">  I don‚Äôt claim to be a python guru, so the code (and I‚Äôm pretty sure of it) has a microscope nailing and other absurdities. <br></div></div><br>  Together with a friend, we set the task: <br><br>  The principle of its operation of the program is the following - after launching a window appears on the desktop with a schematic image of the keyboard.  When pressing buttons on a real keyboard, on a schematic diagram, pressed buttons are pressed. <br><br>  It helps to develop a reflex to look at the monitor while typing on the keyboard. <br><br>  Main program requirements: <br><ol><li>  Implement it very quickly; </li><li>  Show keystrokes in real time; </li><li>  "Switch layouts" in the window when switching the keyboard language; </li><li>  To configure the program through a text configuration file. </li></ol><br>  In the process of writing also added: <br><ol><li>  The "sticking" mode of the last key pressed (it helps to figure out where to press with your fingers further); </li><li>  Work with shift key; </li><li>  The ability to mark the color of positions for the fingers on the keyboard; </li><li>  The ability to customize the font; </li><li>  Ability to customize the width of the buttons; </li><li>  Automatic hiding the contents of the window when you hover the mouse. </li></ol><br>  At the time of the program's appearance, there was already experience with Tkinter, working with several threads.  Plus, by the nature of the activity you have to be a sysadmin, so working with the command line was not alien. <br><br>  General description of the program internals: <br><br>  To read the keys, use the bash line found in google, which allows you to read the keys pressed on the keyboard via the xinput utility.  This method is selected for the sake of clause 1 of the requirements.  The process of reading characters starts in a separate thread.  Reading of the layout language is also implemented (again point 1).  Information on the pressed buttons is issued in a queue.  Working with the queue in the main window of the program is done by periodically calling the function periodicCall.  Thus two streams are written to the queue, one stream is reading. <br>  Program termination is performed in a peculiar way - through status variables in the streams. <br><br><h2>  Work with program settings </h2><br>  Program settings are loaded and stored in an instance of the ConfigManager class.  Reading from the main text file settings is done using <a href="https://docs.python.org/2/library/configparser.html">ConfigParser</a> .  This module allows you to use a format similar to INI configuration files.  The class constructor checks the existence of the configuration file located along the path "~ / .key_trainer / program.conf".  If not, the program reads the program.conf file located in the current program folder. <br><br><div class="spoiler">  <b class="spoiler_title">Some code</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os ... filename=<span class="hljs-string"><span class="hljs-string">'program.conf'</span></span> home = os.path.expanduser(<span class="hljs-string"><span class="hljs-string">"~"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.path.isfile(home+<span class="hljs-string"><span class="hljs-string">'/.key_trainer/'</span></span>+filename): filename=home+<span class="hljs-string"><span class="hljs-string">'/.key_trainer/'</span></span>+filename ...</code> </pre> <br></div></div><br>  <a href="https://docs.python.org/2/library/configparser.html">ConfigParser</a> is a great module.  You can consider the names of all sections, and also consider the keys with their values ‚Äã‚Äãinside the sections as tuples.  So, for example, the reading of section names, and keys in the section ‚ÄúKEYBOARD SETTINGS‚Äù is implemented. <br><br><div class="spoiler">  <b class="spoiler_title">Some more code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ConfigParser <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RawParser ... myParser=RawConfigParser(allow_no_value=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) myParser.read(path_to_file) <span class="hljs-comment"><span class="hljs-comment">#   self.sections = myParser.sections() #     ,    KEYBOARD SETTINGS keyboard_settings_keys=[x[0] for x in myParser.items("KEYBOARD SETTINGS")]</span></span></code> </pre><br></div></div><br>  In addition to the main configuration file, there is a second equally important one - ‚Äúkeyboard.conf‚Äù.  It is used to customize the displayed buttons, namely the button code, the text on the button (with shifta and layouts), the position of the button.  By removing / adding entries to this file, you can change the quantity and quality of buttons (and lines with buttons) in the main program window. <br><div class="spoiler">  <b class="spoiler_title">Format of entries in keyboard.conf</b> <div class="spoiler_text">  The file contains entries in the form: <br><br>  [button code]: "[lowercase character in English layout], [uppercase character in English layout], [lowercase character in Russian layout], [uppercase character in Russian layout]": [button line number], [button column number] <br><br>  Here are a few entries for example: <br><br>  24: ‚Äúq, Q, D, Y‚Äù: 3.2 <br>  25: "W, W, C, C": 3.3 <br>  26: "e, E, Y, Y": 3.4 <br>  27: "r, r, k, k": 3.5 <br></div></div><br><h2>  Reading characters from the keyboard </h2><br>  To read characters, the KeyboardStatus class is written, which takes the configuration class as an input parameter (see above).  Inside this class is encapsulated a thread-safe queue <a href="https://docs.python.org/2/library/queue.html">queue</a> . <br><br>  Reading characters from the keyboard is produced in two streams.  Why two - because in practice it turned out to be easier.  One stream reads the keyboard layout, the second one is pressed.  Both threads are generated through <a href="https://docs.python.org/2/library/threading.html">Thread</a> , in each thread then the corresponding process of reading keys or layouts will be started through the <a href="https://docs.python.org/2/library/subprocess.html">subprocess Popen</a> .  To read the process output stream, <a href="https://docs.python.org/2/library/subprocess.html">subprocess.PIPE is</a> used.  As soon as the text arrives at the exit stream of the process, it is read, processed, and, if necessary, queued: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> subprocess <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Popen <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> subprocess <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PIPE <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doReadingKeys</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.myProcess=Popen(<span class="hljs-string"><span class="hljs-string">'xinput list '</span></span>+<span class="hljs-string"><span class="hljs-string">'|'</span></span>+<span class="hljs-string"><span class="hljs-string">' grep -Po \'id=\K\d+(?=.*slave\s*keyboard)\' '</span></span>+<span class="hljs-string"><span class="hljs-string">'|'</span></span>+<span class="hljs-string"><span class="hljs-string">' xargs -P0 -n1 xinput test'</span></span>,shell=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>,stdout=PIPE) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.proc_started: symbol=self.myProcess.stdout.read(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> symbol <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> press_release_dict: symbol_pressed=press_release_dict[symbol] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> symbol!=<span class="hljs-string"><span class="hljs-string">'\n'</span></span>: symbol=self.myProcess.stdout.read(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> symbol.isdigit(): symbol_index=symbol_index*<span class="hljs-number"><span class="hljs-number">10</span></span>+int(symbol) self.myQueue.put((symbol_index,symbol_pressed)) symbol_index=<span class="hljs-number"><span class="hljs-number">0</span></span> ... keysThread=threading.Thread(target=self.doReadingKeys) keysThread.start() ...</code> </pre><br></div></div><br>  To terminate the thread, use the proc_started class variable.  When the main program window is closed, it is set to False, the reading cycle is terminated, the key reading process is terminate through terminate, and then wait ‚Äî to wait until the process has completed. <br><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text">  This approach has one drawback - unlocking (and hence further termination of the thread and process) of the read method, which will not occur inside the loop until something is considered from the output flow of the myProcess process.  But in practice, problems did not arise because of this, since we often press buttons. <br></div></div><br><h2>  Graphical interface </h2><br>  In order to quickly make a graphical interface used <a href="https://docs.python.org/2/library/tkinter.html">Tkinter</a> .  This module makes it easy to work with simple graphical interfaces (windows, buttons, checkboxes, etc.).  The GuiManager window class at the input, among other parameters, accepts a configuration class.  From it, the settings of the buttons are taken, then these buttons are created and added to the main program window. <br><br><div class="spoiler">  <b class="spoiler_title">Button add code</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Tkinter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tkFont ... self.buttonFont=tkFont.Font(family=config.font_name,size=config.font_size) self.boldUnderscoredButtonFont=tkFont.Font(family=config.font_name,size=config.font_size,weight=<span class="hljs-string"><span class="hljs-string">'bold'</span></span>,underline=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">1</span></span>,config.getNumOfRows()+<span class="hljs-number"><span class="hljs-number">1</span></span>): self.gui_rows[int(row_index)]=Frame(master) self.gui_row_buttons[int(row_index)]=[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> button_num <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">1</span></span>,config.getNumOfKeysInRow(row_index)+<span class="hljs-number"><span class="hljs-number">1</span></span>): newButton=Button(self.gui_rows[int(row_index)]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.config.padx!=<span class="hljs-number"><span class="hljs-number">-1</span></span>: newButton.config(padx=self.config.padx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.config.pady!=<span class="hljs-number"><span class="hljs-number">-1</span></span>: newButton.config(pady=self.config.pady) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row_index,int(button_num)) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> config.key_pos_to_index: self.gui_all_buttons[config.key_pos_to_index[(row_index,int(button_num))]] = newButton self.gui_row_buttons[int(row_index)].append(newButton) newButton.pack(side=LEFT) self.gui_rows[int(row_index)].pack() self.reconfigure_text_on_buttons(config,shift_pressed=<span class="hljs-number"><span class="hljs-number">0</span></span>,lang=<span class="hljs-number"><span class="hljs-number">0</span></span>) ...</code> </pre><br></div></div><br>  When adding buttons to a form, dictionaries are created along the way with keys of the line number and values ‚Äã‚Äã‚Äî a <a href="http://effbot.org/tkinterbook/frame.htm">Frame</a> object in each of which buttons are placed.  As can be seen from the code, the buttons are formed line by line, upon completion of the formation of the line the widget is put into the window using the pack () method. <br><br>  Among other things, the processQueue function has been added to the class, which from the flow of the graphical interface gets tuples from the queue with events of pressed buttons and changes the appearance of the buttons - ‚Äúpresses‚Äù them, ‚Äúswitches layouts‚Äù and ‚Äúpresses‚Äù the shift button: <br><br><div class="spoiler">  <b class="spoiler_title">Processing the queue by the GUI</b> <div class="spoiler_text"><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processQueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.queue.empty(): msg = self.queue.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment"># -1 message is for changing language self.currentLang=int(msg[1]) if self.config.debug: print "Changed lang!" self.reconfigure_text_on_buttons(self.config,0,msg[1]) if msg[0] in self.gui_all_buttons: if msg[0] in self.shift_key_codes: self.reconfigure_text_on_buttons(self.config,msg[1],self.currentLang) if msg[1]==1: self.gui_all_buttons[msg[0]].config(relief=SUNKEN) if self.sticky_key_behaviour: if self.last_sticky_button!=msg[0]: self.gui_all_buttons[self.last_sticky_button].config(relief=RAISED) self.last_sticky_button=msg[0] else: if not self.sticky_key_behaviour: self.gui_all_buttons[msg[0]].config(relief=RAISED) if self.config.debug: print msg</span></span></code> </pre><br></div></div><br>  The GuiManager class is encapsulated inside the ThreadedClient class, which accepts the Tkinter main thread as input and places a call to the queue parsing function every 20 milliseconds: <br><br><div class="spoiler">  <b class="spoiler_title">GuiManager Encapsulating Class</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreadedClient</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, master)</span></span></span><span class="hljs-function">:</span></span> self.master = master self.config=ConfigManager() self.keyTrainer=keyboardStatus(self.config) keyTrainer=self.keyTrainer master.protocol(<span class="hljs-string"><span class="hljs-string">'WM_DELETE_WINDOW'</span></span>, self.kill_and_destroy) self.guiManager=GuiManager(master,self.config,keyTrainer.myQueue,keyTrainer) keyTrainer.begin_scan() self.running = <span class="hljs-number"><span class="hljs-number">1</span></span> self.periodicCall() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kill_and_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.running = <span class="hljs-number"><span class="hljs-number">0</span></span> self.keyTrainer.stop_scan() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.config.debug: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Stopping scan..."</span></span> self.master.destroy() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">periodicCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.guiManager.processQueue() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.running: <span class="hljs-comment"><span class="hljs-comment"># import sys # sys.exit(1) self.kill_and_destroy() self.master.after(20, self.periodicCall)</span></span></code> </pre><br></div></div><br><h2>  Some pictures </h2><br>  General view of the program window: <br><br><img src="https://habrastorage.org/files/1e4/618/c82/1e4618c827fa469fadf2512e68d9c8a7.png"><br><br>  Left Alt key pressed: <br><br><img src="https://habrastorage.org/files/850/25b/2bb/85025b2bb5e140dea1bf8c09a539669a.png"><br><br>  Program window after reconfiguration: <br><br><img src="https://habrastorage.org/files/0bf/f38/2af/0bff382af5784ac895305503b4434769.png"><br><br>  When you hover the mouse cursor, the program window ‚Äúleaves‚Äù under the title (colors that remain on a white background are video compression artifacts): <br><br><img src="https://habrastorage.org/files/070/73e/bdb/07073ebdbbd94be8a297d08f4cc0e8aa.gif"><br><br>  Pressing the shift key and switching the language: <br><br><img src="https://habrastorage.org/files/d0d/bb9/69e/d0dbb969e0084b648f9632f9a105e0ad.gif"><br><br><h2>  Conclusion </h2><br>  What was the result?  And it turned out a good program to help people learn to type blindly on the keyboard.  Yes, she has flaws and inefficiencies, namely: <br><ul><li>  Running processes from the side with bash commands for reading characters; </li><li>  Hard-coded languages ‚Äã‚Äã(only Russian and English); </li><li>  Square interface; </li><li>  Works on Ubuntu and Linux Mint (MATE), has not been tested on other distributions; </li></ul><br>  The code can be downloaded / viewed here: <a href="https://bitbucket.org/alien713cea/key_trainer/downloads">Link to bitbucket</a> <br>  The program requires python 2.7 and Tkinter.  To install the latter, run the command: <br><br><pre> <code class="bash hljs">sudo apt-get install python-tk</code> </pre><br>  The program is launched using the Start.sh script from the program directory. <br><br>  Thanks for attention! <br><br>  PS Received the question: how long did it take to write the program?  Time was spent in the total amount of 6-8 hours, after the first three there was active testing and all details were finished. <br><br>  UPD: removed try / except from queue processing by the GUI </div><p>Source: <a href="https://habr.com/ru/post/266441/">https://habr.com/ru/post/266441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266429/index.html">Joint editing. Part 2</a></li>
<li><a href="../266431/index.html">Extortionist Android / Lockerpin.A attacks US users</a></li>
<li><a href="../266433/index.html">Developing a metamodel using the Eclipse Modeling Framework (and a little about data modeling)</a></li>
<li><a href="../266435/index.html">How to learn to make games: useful resources</a></li>
<li><a href="../266437/index.html">Says Gartner: Overheated IoT and Practical Clouds</a></li>
<li><a href="../266443/index.html">How do closures (under the hood) in JavaScript</a></li>
<li><a href="../266447/index.html">LinkedIn's brief history of scaling</a></li>
<li><a href="../266449/index.html">A little about the implementation of the puzzle "Soma Cubes" (Swift & SceneKit)</a></li>
<li><a href="../266453/index.html">As I wrote the rainy map</a></li>
<li><a href="../266455/index.html">Backstage at CyberSoft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>