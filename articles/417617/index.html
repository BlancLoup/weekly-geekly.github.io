<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cassandra for storing metadata: successes and failures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What requirements must be met by a metadata repository for a cloud service? But not the most usual, but for an enterprise with support for geographica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cassandra for storing metadata: successes and failures</h1><div class="post__text post__text-html js-mediator-article">  What requirements must be met by a metadata repository for a cloud service?  But not the most usual, but for an enterprise with support for geographically distributed data centers and Active-Active.  Obviously, the system should scale well, be <strong>fault tolerant and would like to be able to implement custom consistency of operations.</strong> <br><br>  Under all these requirements only Cassandra fits, and nothing else fits.  It should be noted, Cassandra is really cool, but working with it resembles a roller coaster. <br><img src="https://habrastorage.org/webt/zs/tw/jb/zstwjb6bvwlg43rmuphw91_jtrm.jpeg"><br><br>  In a report on Highload ++ 2017, <strong>Andrey Smirnov</strong> ( <a href="https://habr.com/users/smira/" class="user_link">smira</a> ) decided that it was not interesting to talk about good things, but he told in detail about every problem that he had to deal with: about data loss and corruption, about zombies and performance loss.  These stories really resemble a roller coaster ride, but for all the problems there is a solution, for which you are welcome to the cat. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong><em>About the speaker:</em></strong> Andrey Smirnov works in the company Virtustream, which implements cloud storage for the enterprise.  The idea is that Amazon conventionally makes the cloud for everyone, and Virtustream does the specific things that a big company needs. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SAyClLjN6Sk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h1>  Couple of words on virtustream </h1><br>  We work in a completely remote small team, and we are working on one of the cloud solutions of Virtustream.  This is a cloud data storage. <br><img src="https://habrastorage.org/webt/bo/rc/jh/borcjhczgtiycqzx8dz0bnh9zim.jpeg"><br><br>  Speaking very simply, it is an S3-compatible API in which you can store objects.  For those who don‚Äôt know what S3 is, it‚Äôs just the HTTP API that allows you to upload objects to the cloud somewhere, get them back, delete them, get a list of objects, etc.  Further - already more complex features based on these simple operations. <br><br>  We have some distinctive features that Amazon doesn't have.  One of them is the so-called geo-regions.  In a normal situation, when you create a repository and say that you will be storing objects in the cloud, you must select a region.  A region is essentially a data center, and your objects will never leave this data center.  If something happens to it, your objects will no longer be available. <br><br>  We offer geo-regions in which data is located simultaneously in several data centers (DC), at least in two, as in the picture.  The client can contact any data center, for him it is transparent.  The data between them is replicated, that is, we are working in the ‚ÄúActive-Active‚Äù mode, and all the time.  This provides the customer with additional features, including: <br><br><ol><li>  high reliability of storage, reading and writing in case of DC failure or loss of connectivity; <br></li><li>  availability of data even if one of the DCs fails; <br></li><li>  redirection of operations to the "nearest" DC. <br></li></ol><br>  This is an interesting opportunity - even if these DCs are far from each other geographically, then one of them may be closer to the client at different times.  And to access the data in the nearest DC just faster. <br><img src="https://habrastorage.org/webt/k-/ry/dl/k-rydl_mt74-eybwakpv1dpqjum.jpeg"><br><br>  In order for the construction, which we will talk about, to be divided into parts, I will present those objects that are stored in the cloud as two large pieces: <br><br>  1. The first simple piece of an object is <strong>data</strong> .  They are the same, they were downloaded once and that's it.  The only thing that can happen to them later is that we can remove them if they are no longer needed. <br><br>  The previous project was related to the storage of the data exabyte, so we did not have any problems with the data storage.  This for us was already a solved problem. <br><br>  2. <strong>Metadata</strong> .  All business logic, all the most interesting, related to competitiveness: circulation, writing, rewriting - in the metadata area. <br><br>  Metadata about the object takes away the greatest complexity of the project, the metadata stores a pointer to the block of saved data of the object. <br><br>  From the user's point of view, this is a single object, but we can divide it into two parts.  Today I will <strong>only</strong> talk <strong>about metadata</strong> . <br><br><h2>  Numbers <br></h2><br><ul><li>  <strong>Data</strong> : 4 PB. </li><li>  <strong>Metadata clusters</strong> : 3. </li><li>  <strong>Objects</strong> : 40 billion. </li><li>  <strong>The volume of metadata</strong> : 160 TB (including replication). </li><li>  <strong>Rate of change (metadata):</strong> 3000 objects / s. </li></ul><br>  If you look at these indicators carefully, the first thing that catches your eye is the very small average size of the stored object.  We have a lot of metadata per unit volume of basic data.  For us, this was no less surprise than, perhaps, for you now. <br><br>  We planned that we would have at least an order of magnitude, if not 2, more than metadata.  That is, each object will be much larger, and the volume of metadata will be less.  Because data is cheaper to store, there are fewer operations with them, and metadata is much more expensive both in terms of hardware and in terms of maintaining and performing various operations on them. <br><br>  At the same time, these data change with a fairly high speed.  I gave here the peak value, non-peak is not much less, but, nevertheless, quite a large load can be obtained at specific points in time. <br><br>  These figures were obtained from the operating system, but let's go back a bit, by the time the cloud storage is designed. <br><br><h1>  Metadata storage selection </h1><br>  When we faced the challenge that we want to have geo-regions, Active-Active, and we need to store metadata somewhere, we thought it could be? <br><br>  Obviously, the storage (database) must have the following properties: <br><br><ul><li>  <strong>Active-Active support</strong> ; </li><li>  <strong>Scalable.</strong> </li></ul><br>  We would very much like our product to be wildly popular, and we don‚Äôt know how it will grow in this case, so the system must scale. <br><br><ul><li>  <strong>Balance failover and reliability of storage.</strong> </li></ul><br>  Metadata must be stored securely, because if we lose them, and there is a link to the data, we will lose the entire object. <br><br><ul><li>  <strong>Configurable consistency of operations.</strong> </li></ul><br>  Due to the fact that we work in several DCs and admit the possibility that DCs may be unavailable, moreover, DCs are far from each other, we cannot during the execution of most operations through the API require that this operation be performed simultaneously in two DCs.  It will be just too slow and impossible if the second DC is unavailable.  Therefore, part of the operations should work locally in one DC. <br><br>  But, obviously, some convergence must occur sometime, and after the resolution of all conflicts, the data should be visible in both data centers.  Therefore, the consistency of operations must be adjusted. <br><br>  From my point of view, Cassandra fits these requirements. <br><br><h1>  Cassandra </h1><br>  I would be very happy if we didn‚Äôt have to use Cassandra, because for us it was a new experience.  But nothing else fits.  It seems to me that the saddest situation on the market for such storage systems is that there is no <strong>alternative</strong> . <br><br><img src="https://habrastorage.org/webt/ge/l-/xo/gel-xoykdx5yx1-sb36hjinlsas.jpeg"><br><br><h3>  What is Cassandra? <br></h3><br>  This is a distributed key-value database.  From the point of view of architecture and the ideas that are embedded in it, it seems to me, everything is cool.  If I did, I would do the same.  When we first started, we thought about writing our own metadata storage system.  But the farther we went, the more and more we understood that we would have to do something very similar to Cassandra, and the efforts we would put into it were not worth it.  For the whole development <strong>we had only one and a half months</strong> .  It would be strange to spend them on writing your database. <br><br>  If Cassandra is divided into layers, like a layer cake, I would select 3 layers: <br><br>  1. <strong>Local KV storage at each node.</strong> <br>  This is a cluster of nodes, each of which is able to store key-value data locally. <br><br>  2. <strong>Sharding data on nodes (consistent hashing).</strong> <br>  Cassandra is able to distribute data across cluster nodes, including replication, and does this in such a way that the cluster can grow or shrink in size, and the data will be redistributed. <br><br>  3. <strong>Coordinator for redirecting requests to other nodes.</strong> <br>  When we access data from some requests from our application, Cassandra can distribute our request among nodes so that we get the data we want and with the level of consistency we need - we want to read them just quorum, or we want quorum with two DCs, etc. <br><img src="https://habrastorage.org/webt/zs/tw/jb/zstwjb6bvwlg43rmuphw91_jtrm.jpeg"><br><br>  For us, two years with Cassandra are roller coasters or roller coasters - whatever you want to call it.  It all started deep down, we had zero experience with Cassandra.  We were scared.  We started and everything was fine.  But then there are constant ups and downs: the problem, everything is bad, we don‚Äôt know what to do, we have mistakes, then we solve the problem, etc. <br><br>  These roller coasters, in principle, do not end to this day. <br><br><h1>  Good </h1><br>  The first and last chapter, where I will say that Cassandra is cool.  It is really cool, a great system, but if I continue to say how good it is, I think you will not be interested.  Therefore, the bad pay more attention, but later. <br><br>  Cassandra is really good. <br><br><ul><li> This is one of the systems that allows us to have <strong>a response time in milliseconds</strong> , that is, obviously less than 10 ms.  This is good for us because the response time in general is important for us.  The metadata operation for us is only a part of any operation related to the storage of an object, be it a receipt or a record. </li><li>  From a recording point of view, <strong>high scalability is</strong> achieved.  In Cassandra, you can write at a crazy speed, and in some situations this is necessary, for example, when we move large amounts of data between records. </li><li>  Cassandra is really <strong>fault tolerant</strong> .  The fall of a single node does not lead to problems at the same second, although sooner or later they will begin.  Cassandra declares that there is no single point of failure in it, but, in fact, there are points of failure everywhere.  In fact, the one who worked with the database, knows that even the fall of the node is not something that usually suffers until the morning.  Usually, this situation needs to be fixed faster. </li><li>  <strong>Simplicity.</strong>  Still, compared to other standard relational databases, Cassandra is easier to understand what is happening.  Very often something goes wrong, and we need to understand what is happening.  With Cassandra, there are more chances to figure out how to get to the smallest screw, probably, than from another database. </li></ul><br><h1>  Five stories about bad </h1><br>  Again, Cassandra is good, it works for us, but I will tell five stories about the bad.  I think this is what you read it for.  I will cite stories in chronological order, although they are not very connected with each other. <br><img src="https://habrastorage.org/webt/ao/15/oa/ao15oaiwdhwvl4w4u5pvcgwolrq.jpeg"><br><br>  This story was the saddest for us.  Since we store user data, the worst possible thing is to lose them, and <strong>lose them irretrievably</strong> , as happened in this situation.  We had ways to recover data if we lost it in Cassandra, but we lost it so that we really could not recover it. <br><br>  In order to explain how this happens, I have a little bit to tell you about how everything is arranged inside us. <br><img src="https://habrastorage.org/webt/6i/vf/gk/6ivfgkdspndo3kzyy153iveq4xq.jpeg"><br><br>  From the point of view of S3, there are a few basic things: <br><br><ul><li>  Bucket - it can be thought of as a huge directory into which the user uploads an object (hereinafter referred to as bakt). </li><li>  Each object has a name (key) and associated metadata: size, content type, and a pointer to the object data.  At the same time, the size of the bake is not limited by anything.  That is, it may be 10 keys, maybe 100 billion keys - there is no difference. </li><li>  Any competitive operations are possible, that is, there may be several competitive fills in the same key, there may be competitive deletion, etc. </li></ul><br>  In our situation, active-active, operations can occur, including competitively in different DC, not only in one.  Therefore, we need some kind of preservation scheme that will allow to implement such logic.  In the end, we chose a simple policy: the latest recorded version wins.  Sometimes there are several competitive operations, but it is not necessary that our clients specifically do this.  It might just be a request that started, but the client did not wait for an answer, something else happened, tried again, etc. <br><br>  Therefore, we have two base tables: <br><br><ol><li>  <strong>Object table</strong>  In it, the pair ‚Äî the name of the bake and the name of the key ‚Äî is associated with its current version.  If the object is deleted, then there is nothing in this version.  If the object exists, there is its current version.  In fact, in this table we only change the field of the current version. <br></li><li>  <strong>Object version table</strong> .  In this table we just insert new versions.  Every time a new object is loaded, we insert a new version into the version table, give it a unique number, save all the information about it, and at the end update the link to it in the object table. <br></li></ol><br>  The figure is an example of how object tables and object versions are related. <br><img src="https://habrastorage.org/webt/rv/jm/3y/rvjm3y1ohf-9yiehp1ajlm4zjik.jpeg"><br><br>  Here there is an object that has two versions - one current and one old, there is an object that has already been deleted, and its version is still there.  We need to clean up unnecessary versions from time to time, that is, to delete something that nobody already refers to.  Moreover, we do not need to delete immediately, we can do it in the deferred mode.  This is our internal cleaning, we simply remove what is no longer needed. <br><br>  There was a problem. <br><img src="https://habrastorage.org/webt/md/rc/xy/mdrcxyc9ojwdjuwchg7gsgkspio.jpeg"><br><br>  The problem was this: we have an active-active, two DCs.  In each DC, the metadata is stored in three copies, that is, we have 3 + 3 - only 6 replicas.  When customers come to us, we perform operations with consistency (from the point of view of Cassandra is called LOCAL_QUORUM).  That is, it is guaranteed that the write (or read) occurred in 2 replicas in the local DC.  This is a guarantee - otherwise the operation will fail. <br><br>  Cassandra will always try to write in all 6 replicas - 99% of the time everything will be fine.  In fact, all 6 replicas will be the same, but guaranteed to us 2. <br><br>  We had a difficult situation, although it was not even a geo-region.  Even for ordinary regions, which are in one DC, we still kept a second copy of the metadata in another DC.  This is a long story, I will not give all the details.  But ultimately we had a cleaning process that removed unnecessary versions. <br><br>  And then that problem arose.  The cleaning process also worked with the consistency of the local quorum in the same data center, because there is no two ways to run it - they will fight with each other. <br><br>  Everything was good, until it turned out that our users still sometimes write to another data center, which we did not suspect.  Everything was set up just in case for a faylover, but it turned out that they were already using it. <br><img src="https://habrastorage.org/webt/sa/cs/6q/sacs6qjj7og_ay7jbmkhfkjh9ei.jpeg"><br><br>  Most of the time, everything was fine, until one day a situation arose, when a record in the version table was replicated in both DCs, but the entry in the table of objects was only in one DC, and the second did not hit.  Accordingly, the cleaning procedure launched in the first (upper) DC, saw that there is a version to which no one refers, and deleted it.  Moreover, it deleted not only the version, but, of course, the data - all completely, because it is just an unnecessary object.  And this removal is irrevocable. <br><br>  Of course, the ‚Äúboom‚Äù happens further, because we have a record in the object table that refers to a version that no longer exists. <br><br>  So the first time we lost the data, and lost them really irrevocably - good, a little. <br><br><h3>  Decision </h3><br>  What to do?  In our situation, everything is simple. <br><br>  Since our data is stored in two business centers, the cleaning process is a process of some kind of convergence and synchronization.  We must read the data from both DCs.  This process will work only when both DCs are available.  Since I said that this is a delayed process that does not occur during the processing of the API, it is not a problem. <br><br>  <strong>ALL consistency</strong> is a feature of Cassandra 2. In Cassandra 3, everything is a little better - there is a level of consistency, which is called quorum in each DC.  But in any case, there is the problem of the fact that it is <strong>slow</strong> , because we, first, have to contact a remote DC.  Secondly, in the case of the consistency of all 6 nodes, this means that it operates at the speed of the worst of these 6 nodes. <br><br>  But at the same time there is a process of the so-called <strong>read-repair</strong> , when not all replicas are synchronous.  That is, when somewhere the recording failed, this process repairs them at the same time.  That's the way Cassandra is. <br><br>  When this happened, we received a complaint from the client that the object was unavailable.  We figured out, understood why, and the first thing we wanted to do was find out how many such objects we still have.  We ran a script that tried to find a construct similar to this one when there is a record in one table, but there is no record in another. <br><br>  Suddenly, we discovered that we have <strong>10% of such records</strong> .  Nothing worse, probably, could not be, if we had not guessed that this was not the case.  The problem was different. <br><br><img src="https://habrastorage.org/webt/kc/jt/_d/kcjt_dh03wmb-6szvtrgxqz-hme.jpeg"><br><br>  Zombies sneaked into our database.  This is the semi-official title of the problem.  In order to understand what it is, you need to talk about how removal works in Cassandra. <br><img src="https://habrastorage.org/webt/k2/sd/2j/k2sd2jvngn9ouhiv6b3yre0s8vs.jpeg"><br><br>  For example, we have some kind of data <strong><em>x</em></strong> , which is recorded and perfectly replicated to all 6 replicas.  If we want to delete it, deletion, like any operation in Cassandra, may not be performed on all nodes. <br><br>  For example, we wanted to guarantee the consistency of 2 of 3 in one DC.  Let the delete operation be performed on five nodes, and one record remained, for example, because the node was unavailable at that moment. <br><img src="https://habrastorage.org/webt/lu/d5/ot/lud5otv1dguftzwinkrb2wpeaaq.jpeg"><br><br>  If we delete this way and then try to read ‚ÄúI want 2 of 3‚Äù with the same consistency, then Cassandra, seeing the value and its absence, interprets this as the availability of data.  That is, when reading back, she will say: ‚ÄúOh, there is data!‚Äù, Although we deleted them.  Therefore, it cannot be deleted in this way. <br><img src="https://habrastorage.org/webt/m6/li/ol/m6liolpvsglhmd_9wjg1gvkascw.jpeg"><br><br>  Cassandra removes differently.  <strong>Deletion is actually a record</strong> .  When we delete the data, Cassandra writes down some small size marker called the <strong>Tombstone</strong> (tombstone).  It marks that the data has been deleted.  Thus, if we read both the deletion marker and the data at the same time, Cassandra always prefers the deletion marker in this situation and says that there really is no data.  This is what you need. <br><br>  Although <strong>Tombstone is a small marker</strong> , it is clear that if we delete and delete data, we should also delete these markers, otherwise they will accumulate endlessly.  Therefore, Tombstone has some configurable lifetime.  That is, <strong>Tombstone is removed in gc_grace_period seconds</strong> .  When there is no marker, the situation is equivalent to the situation when there is no data. <br><br>  What can happen? <br><br><h2>  Repair <br></h2><br>  Cassandra has a process called Repair.  His task - to make sure that all the replicas were synchronous.  We may have different operations in the cluster, maybe not all the nodes have executed them, or we have changed the cluster size, added / reduced replicas, maybe some node once fell, hard drives, etc.  Replicas may not be consistent.  Repair makes them consistent. <br><img src="https://habrastorage.org/webt/hj/td/x0/hjtdx0thzgak5uhzjd_ejn09s1m.jpeg"><br><br>  We deleted the data, somewhere there were deletion markers, somewhere the data itself remained.  But we have not done Repair yet, and it is able, as in the picture above.  Some time passed, and the deletion markers disappeared - their lifespan just went out.  Instead, they left an empty space, as if there is no data. <br><img src="https://habrastorage.org/webt/qe/ee/kj/qeeekjf-dzxokqp6c4zi1aylljm.jpeg"><br><br>  If Repair is started after that, which should bring the replicas to a consistent state, it will see that there is data on some nodes, there is no data on others - it means that they need to be restored.  Accordingly, all 6 nodes will again be with data.  These are the same Zombies - the data that we deleted, but which returned to the cluster. <br><img src="https://habrastorage.org/webt/c7/qo/o2/c7qoo2bykcraic_gbj8fxbxrmoo.jpeg"><br><br>  Usually we don‚Äôt see them, if we don‚Äôt access them - perhaps these are some random keys.  If nothing refers to it, we will not see it.  But if we try to scan the entire database, trying to find something, as we were then looking for, how many records we have with deleted objects, these Zombies are very disturbing. <br><br><h3>  Decision <br></h3><br>  The solution is very simple, but rather important: <br><br><ul><li>  <strong>Repair in a cluster needs to be done anyway</strong> . </li></ul><br>  But there are different situations when we do not have time to do repair.  It takes a very long time, because it is one of the most difficult operations for a cluster, which is related to comparing data on nodes. <br><br><ul><li>  <strong>But in any case, the period after which Tombstones are removed must be longer than the repair interval.</strong> </li></ul><br>  The repair interval is the time for repair.  For example, we know that we have time to repair this cluster in 10-20 days, a week, 3 days.  But the period of Tombstone removal should be above this value, which is comprehended only from practice.  If we repress too aggressively, it turns out that the cluster responds poorly to front-end requests. <br><img src="https://habrastorage.org/webt/18/yp/cc/18ypccovl1xcoxairec6nf3ssx0.jpeg"><br><br>  Another classic problem for Cassandra that developers often come across.  In fact, this is difficult to fight. <br><br>  In S3 there is a bakt.  As I said, it can be any size - 10 keys, 100 billion keys.  One of the APIs we need to support is to give the list of keys in the bucket.  Moreover, the list should be sorted, given, of course, page by page, it can be scrolled through, and it should always be consistent with current operations.  That is, if I wrote down an object, deleted an object, take a list of keys - and it is the same as after my operation.  I can not defer rebuilt it. <br><br>  How to implement such an API? <br><img src="https://habrastorage.org/webt/1l/tl/hd/1ltlhdhdtgnwgxezzz8jsnavvky.jpeg"><br><br>  There is a table of objects that I showed earlier - bake, key, the current version seems to be the one that is needed in order to build a list of keys.  But there is a small problem.  I absolutely correctly selected a pair of bucket - key for this table as a primary key.  The primary key determines where this string will be located, on which node.  This is the very thing why an object is hashed when it is stored in Cassandra.  But at the same time it means that the keys of one bake are stored on different nodes - generally speaking, at all, if there are enough of them, because they are all evenly spread. <br><br>  From the point of view of storing this table, this is cool, because my buckets can be completely different sizes, and I cannot guess in advance how big and how small.  If the data of one batch were stored on one node, then there would be a problem with scaling.  But, on the other hand, I cannot in any way build a list of objects in a cluster from such a table.  So, we need some other way by which this very list of objects could be obtained. <br><br>  Cassandra says that she has more complex structures.  You can create another table specifically for the list of keys in the bucket, which will store exactly the information that is needed, namely, the bucket, the key and the minimum amount of metadata about the object, in order to build a response to the query. <br><img src="https://habrastorage.org/webt/fk/os/a3/fkosa3zozy2gk_dzpgjvxdwm4k8.jpeg"><br><br>  Here I use what's called a <strong>composite key</strong> in Cassandra.  If I build a query to this table that I need - select data from the batch, starting with some key, and so that they are sorted - the query works.  He does exactly what I need.  Am i happy  Yes, I'm glad of course, everything worked out for me! <br><br>  But if you carefully read what was said earlier, then remember that if the primary key is from the baketa, this means that all data is put on the same node. <br><br>  In fact, the problem is worse.  There is some schizophrenia in Cassandra, because <strong>different layers of Cassandra essentially speak different languages</strong> .  The layer with which we interact today most often represents Cassandra as something remotely similar to a relational database: with tables, with queries similar to SQL, etc.  It seems to be all right! <br><img src="https://habrastorage.org/webt/8o/_s/ka/8o_ska-swgmzixxiztlblopuze0.jpeg"><br><br>  But there is also an internal data layer.  How does Cassandra really keep it?  Historically, it was primary, and to it was its own, completely different API.  This construction, which I described, is actually stored inside, as a long line, in which each key (in this situation, the key in the bucket) is a separate column.  <strong>The larger the bucket size, the larger the columns</strong> in this table. <br><br>  When I make a request, I don‚Äôt see it and can‚Äôt find out about it.  If I try to climb a level or read how it works, yes, I can find out.  This means that the width of such a line ‚Äî the number of columns ‚Äî is equal in my situation to the size of my baketa.  This, by the way, works well because the columns at the physical level are stored sorted by name. <br><br>  But in Cassandra there are a lot of operations in which it operates with the entire value of a string.  Even if I ask: ‚ÄúGive me 100 keys‚Äù, and there are a million stored, depending on the version, in order to build the answer to my question, she has to literally read the entire line of a million, from there choose 100, and throw everything else away. <br><br>  Imagine that this data is still distributed across several nodes (the same multiple replicas), and any request is not really a request to a specific replica, but essentially a request that tries to build a consistent representation across several nodes at the same time.  If I have a million columns in one node, a million in another, a million in the third, formally in order to build an answer to a query, it is impossible to do something simple.  If I ask you to give 100 keys that are greater than such a value, and all nodes match perfectly, it is simple.  If the nodes do not quite coincide, then this query with a limit from the point of view of SQL becomes not trivial at all. <br><br>  Cassandra is trying to extend such a broad line into memory, and when it does it, and it is written in Java, it becomes very bad.  This design, called the <strong>Large Partition</strong> , arises imperceptibly.  So far there is little data - tens, hundreds, thousands, tens of thousands, even hundreds of thousands of keys - all is well.  But then an exponential crash begins in terms of performance, nodes begin to fall, garbage collection fails, etc.  The result is a cascade effect. <br><br>  Plus, the wide string is replicated, and <strong>not only one node drops, but many at once</strong> , because they all have the same problem. <br><br>  Of course, we immediately knew about this problem and thought that we need to do something in advance. <br><img src="https://habrastorage.org/webt/qg/o9/oo/qgo9ooa3pgv_zqkv8iyby4ppq9g.jpeg"><br><br>  Therefore, in the table that is used for listing objects, we have foreseen the possibility of scattering the data of one baket across several columns.  I will call them conditionally partitions.  That is, partition the table so that we do not have a Large Partition. <br><br>  We have two requirements: <br><br><ol><li>  so that each partition is limited in size (no more than some keys); <br></li><li>  even though we distribute the data, we want to get a sorted list of keys quickly.  This was our initial task, for the sake of it everything was started. <br></li></ol><br>  When we started, we never figured out how to distribute the data, and always used 0 as the key_hash column. As always, <strong>features go in front of any improvements that do not bring direct profit in terms of the product</strong> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, of course, we missed the moment when the partitions became large. We had some very fun months when we screwed the solution to a system that was almost in a state of agony. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's discuss how this could be done. </font></font><br><img src="https://habrastorage.org/webt/zr/aw/xn/zrawxn-n6hr1huoqkenbqcgpeoo.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We immediately thought - well, we have a bake, he has a bunch of keys, let's run all the keys through some hash function and thus distribute them into partitions.</font></font><br><br>   ‚Äî      ,   N ?    ,  Large Partition,   ‚Äî     .  ,        .   :   .  ,    ,  ,    ,       -  .    ,           .    , ,     . <br><img src="https://habrastorage.org/webt/og/um/4y/ogum4yxqpvbvrdadna7r8adomwm.jpeg"><br><br>     ‚Äî   ,    ,   -  .    -  ,       ,       .    ,    ,    .   ,    ,        .. <br><br>         ‚Äî  ,    ?    ,   .    ? -     md5- ‚Äî      ,   -  30  ‚Äî     ,  - .    .     ,     ,   . <br><img src="https://habrastorage.org/webt/yp/ik/vy/ypikvyolprsxdju5hawmlm6_epq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we came to the scheme, when we dynamically guess, more precisely, we analyze how the keys are distributed. </font><font style="vertical-align: inherit;">This distribution may change over time - the bakery may grow, the key structure may change. </font><font style="vertical-align: inherit;">We adapt to this, and dynamically distribute them using a table. </font><font style="vertical-align: inherit;">The table indicates that the keys from such and such for such and such lie in such and such a partition, with such and such for such and such - in such. </font><font style="vertical-align: inherit;">This is a conditional solution with a prefix, only the prefix is ‚Äã‚Äãcomplex and dynamic. </font><font style="vertical-align: inherit;">Yes, and not quite a prefix.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic hash </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To make dynamic hashing, we had to tinker a lot, because there are many interesting, quite scientific tasks. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic distribution table. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Genetic algorithm for finding the perfect distribution and perfect redistribution. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Counting the size of a patrician outside of Cassandra. </font></font></li><li> Online- (     ). </li></ul><br>   -   ,  -    .   ,  -      .     , ,   ,  ,        -  ,    - .             . ,        ,      ,  . <br><br>    . , ,    ,      ,        .   , ,     ,     -      ,       . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, we assumed that the bakt would grow more or less evenly. That is, we picked up some distribution, and hoped that all the partitions will grow according to this distribution. But we had a client who always writes to the end, in the sense that he always has the keys in a sorted order. He always hits the most recent partition, which is growing at such a rate that in a minute it can be 100 thousand keys. And 100 thousand is approximately the value that fits into one partition.</font></font><br><br>           ,          .    ,    ,   ,   ,          ,      ,         ,      . <br><br>        ,     .    , ,       .    ,       . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is quite interesting, and it works out with Cassandra. </font><font style="vertical-align: inherit;">Here you can play with tricks related to the fact that Cassandra is able to resolve conflicts. </font><font style="vertical-align: inherit;">If we in the same line recorded two different values, then wins the value, which has more timestamp. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually the timestamp is the current timestamp, but you can pass it manually. </font><font style="vertical-align: inherit;">For example, we want to write a value in a string, which in any case must be ground, if the client writes something himself. </font><font style="vertical-align: inherit;">That is, we copy some data, but we want the client, if suddenly he writes with us at the same time, to overwrite them. </font><font style="vertical-align: inherit;">Then we can just copy our data from the timestamp a little bit from the past. </font><font style="vertical-align: inherit;">Then any current recording will deliberately grind them, regardless of the order in which the recording was made.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Such tricks allow you to do it online. </font></font><br><br><h2>  Decision </h2><br><ul><li> ,  <strong>   large partition</strong> . </li><li> <strong>   primary key</strong>    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If something similar to a large partition is planned in the data scheme, you should immediately try to do something with it - think of how to break it and how to get away from it. Sooner or later it arises, because any inverted index sooner or later arises in almost any task. I have already told you about this story - we have a bake key to the object, and we need to get a list of keys from the baket - in fact, this is an index. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, the partition can be large not only from the data, but also from the Tombstones (deletion markers). The deletion markers, in the same way from the point of view of Cassandra internals (we never see them from the outside) are data, and the partition can be large if it deletes a lot of things, because the deletion is a record. This is also not to be forgotten.</font></font><br><img src="https://habrastorage.org/webt/-s/tw/la/-stwlarb11mcy5nlqaqrpxfc-ky.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another story that is actually constant ‚Äî something goes wrong from beginning to end. For example, you see that the response time from Cassandra has grown, it responds slowly. How to understand and understand what the problem is? There is never an external signal that the problem is there. </font></font><br><img src="https://habrastorage.org/webt/c0/lr/5r/c0lr5rwf9w5zi-nx1ddd5k5blgk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, here is a graph - this is the average response time of the cluster as a whole. It shows that we have a problem - the maximum response time rested on 12 s - this is the internal timeout of Cassandra. This means that it time out by itself. If the timeout is longer than 12 seconds, it most likely means that the garbage collector is working, and Cassandra does not even have time to respond at the right time. It answers itself on timeout, but the response time to most requests, as I said, should be on average within 10 ms.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the graph, the average has already exceeded hundreds of milliseconds - something went wrong. But looking at this picture, it is impossible to understand the reason. </font></font><br><br><img src="https://habrastorage.org/webt/e6/t6/qk/e6t6qkz3yw6k80sjw7smsycclrc.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if the same statistics are deployed over the Cassandra nodes, then it is clear that in principle all the nodes are more or less nothing, but at one node the response time differs by orders of magnitude. Most likely, with him some kind of problem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statistics on nodes changes the image completely. This statistic is from the side of the app. But here too, in fact, it is often difficult to understand what the problem is. When an application accesses Cassandra, it accesses a node, using it as a coordinator. That is, the application gives a request, and the coordinator redirects it to the replicas with data. Those already answer, and the coordinator forms the final answer back.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But why does the coordinator respond slowly? </font><font style="vertical-align: inherit;">Maybe the problem is with him, as with such, that is, he slows down and responds slowly? </font><font style="vertical-align: inherit;">Or maybe he slows down, because replicas respond slowly to him? </font><font style="vertical-align: inherit;">If the replicas respond slowly, from the point of view of the application it will look like a slow response from the coordinator, although he has nothing to do with it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a happy situation - it is clear that only one node responds slowly, and most likely the problem lies in it.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Difficulty interpreting </font></font></h3><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The response time of the coordinator (the node itself vs. the replicas). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Specific table or entire node? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GC Pause? </font><font style="vertical-align: inherit;">Not enough thread pool?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Too many uncompacted sstables? </font></font></li></ul><br>   ,   .  <strong>    </strong> ,    ,    Cassandra,  ,    ,   Cassandra   .       ,     ,    . <br><br>  , , ,     ,    Cassandra SSTables ( )  .   Cassandra ,  ,   SSTables.    ,         ,    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The solution is compaction, which reduces the number of these SSTables, but it should be noted that it can only be on one node for one particular table. Since Cassandra is, unfortunately, written in Java and works on the JVM, it may be that the garbage collector has paused so much that it simply does not have time to respond. When the garbage collector pauses, not only do your queries slow down, but the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interaction within the Cassandra cluster between the nodes begins to slow down</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The nodes of each other begin to be considered gone down, that is, fallen, dead.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An even more fun situation begins, because when a node considers that another node is down, it, firstly, does not send requests to it, secondly, it starts trying to save data that it would need to replicate to another node himself locally, so he starts killing himself, and so on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are situations where this problem can be solved simply by using the correct settings. For example, there may be enough resources, everything is fine and good, but just the Thread Pool, the number of which is of a fixed size, should be increased.</font></font><br><br> ,  ,       .  ,      ,     , Cassandra         ,     ,         . <br><br><h3>   </h3><br>   -    ‚Äî    ,    Repair,   ,   key spaces,   . <br><br>  , ,      .  ,     .  ,     ,   BIOS      .  -        ,    50%       . <br><br>       ,   .   ‚Äî     compaction,    .     ,  ,      Cassandra. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, monitoring is mandatory and it needs a lot. The more complex the feature in Cassandra, the farther away from simple writing and reading, the more problems with it, and the faster it can kill the database with a sufficient number of queries. Therefore, if there is an opportunity, do not look at some "tasty" chips and try to use them, it is better to avoid them as far as possible. Not always possible - of course, sooner or later you have to. </font></font><br><img src="https://habrastorage.org/webt/mx/m8/lx/mxm8lxirhudrxrdlcq26jpstvle.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last story is about how Cassandra corrupted the data. In this situation, it happened inside Cassandra. It was interesting.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We saw that about dozens of broken lines appear in our database about once a week - they are literally littered with garbage. And Cassandra validates the data that comes to her at the entrance. For example, if it is a string, then it must be in utf8. But in these lines there was garbage, not utf8, and Cassandra did not even do anything with it. When I try to delete (or do something else), I cannot delete a value that is not utf8, because, in particular, I cannot enter in WHERE, because the key must be utf8. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corrupted lines appear as a flash, at some point, and then they are not there again in a few days or weeks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We started looking for a problem. </font><font style="vertical-align: inherit;">We thought there might be a problem in a certain node with which we were busy, doing something with the data, SSTables copied. </font><font style="vertical-align: inherit;">Perhaps, after all this data can see their replicas? </font><font style="vertical-align: inherit;">Perhaps these replicas have a common node, the least common divisor? </font><font style="vertical-align: inherit;">Maybe some node fails? </font><font style="vertical-align: inherit;">No, nothing like that. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maybe something with a disk? </font><font style="vertical-align: inherit;">Is the data corrupted on the disk? </font><font style="vertical-align: inherit;">Again, no. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maybe a memory?</font></font> Not!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scattered across the cluster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maybe this is some kind of replication problem? </font><font style="vertical-align: inherit;">Did one node spoil everything and then replicate a bad value?</font></font> - Not. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, maybe this is an application problem? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And at some point the broken lines began to appear in two clusters of Cassandra. </font><font style="vertical-align: inherit;">One worked on version 2.1, the second on the third. </font><font style="vertical-align: inherit;">It seems that Cassandra is different, but the problem is the same. </font><font style="vertical-align: inherit;">Maybe our service sends bad data? </font><font style="vertical-align: inherit;">But it was hard to believe. </font><font style="vertical-align: inherit;">Cassandra validates input data, she could not write garbage. </font><font style="vertical-align: inherit;">But suddenly? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nothing fits.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Needle found! </font></font></h3><br>     ,     :       - crash dump  JVM,       ?  -    stack trace garbage collector‚Ä¶  -  stack trace   . <br><br>     ‚Äî , <strong> -  JVM   2015 </strong> .    ,    Cassandra    Cassandra. <br><br>      ,    ,     - JVM     .     ,    .         ,   - ,        JVM  . <br><br><h3>  Data recovery </h3><br>      : <br><br> ‚óè Backup . <br> ,   ,     ,    .  ,     ,    . <br><br> ‚óè     . <br> -    ,     ,  . <br><br> ‚óè          . <br>    backup   ,    .     ,     .. <br><br> ‚óè  ‚Äî  ! <br>     ,   ,         ,        -    . <br><br><h3>  Decision </h3><br><ul><li>  JVM   . </li><li>  JVM crash. </li><li>    Cassandra  . </li></ul><br><blockquote> <strong>As a tip:</strong> Try to have some kind of data independent of Cassandra, from which you can recover if necessary.  This may be the last level solution.  Let it take a lot of time, resources, but that was some option that will allow you to return the data. </blockquote><br><h1>  Bugs </h1><br>  ‚óè <strong>Low quality release testing</strong> <br>  When you start working with Cassandra, there is a constant feeling (especially if you switch, relatively speaking, from ‚Äúgood‚Äù databases, for example, PostgreSQL), that if you fixed the previous bug in the release, you will definitely add a new one.  Moreover, a bug is not some nonsense, it is usually corrupted data or other incorrect behavior. <br><br>  ‚óè <strong>Persistent problems with complex features.</strong> <br>  The more complex the feature, the more problems with it, bugs, etc. <br><br>  ‚óè <strong>Do not use incremental repair in 2.1</strong> <br>  The famous repair, which I talked about, which fixes the consistency of data, in standard mode, when it polls all nodes, works well.  But not in the so-called incremental mode (when repair skips data that has not changed since the previous repair, which is quite logical).  It was announced long ago, formally, as a feature exists, but everyone says: ‚ÄúNo, in version 2.1, do not use it ever!  He will definitely miss something.  In 3 we correct <br><br>  ‚óè <strong>But do not use incremental repair and in 3.x</strong> <br>  When the third version came out, a few days later they said: ‚ÄúNo, in the 3rd one it cannot be used.  There is a list of 15 bugs, so do not use incremental repair.  In the 4th we will do better! ‚Äù <br><br>  I do not believe them.  And this is a big problem, especially with increasing cluster size.  Therefore, you need to constantly monitor their bugtracker and watch what happens.  Without this, unfortunately, it is impossible to live with them. <br><br>  ‚óè <strong>Must follow JIRA</strong> <br><img src="https://habrastorage.org/webt/g0/1k/el/g01kela-ibcrrsorr1pjxo-pmdc.jpeg"><br><br><blockquote>  If you scatter all the databases on the predictability spectrum, for me Cassandra is on the left in the red area.  This does not mean that it is bad, you just have to be prepared for the fact that Cassandra is unpredictable in any sense of the word: both in the way it works and in that something can happen. </blockquote><br><img src="https://habrastorage.org/webt/je/_1/w0/je_1w0808rlhzxo1bakk0zjj9ee.jpeg"><br><br>  I wish you to find other rakes and attack them, because, from my point of view, in spite of everything, assandra is good and undoubtedly boring.  Just remember the bumps on the road! <br><br><blockquote>  <strong>Open meeting of HighLoad ++ activists</strong> <br><br>  A <a href="http://www.highload.ru/moscow/2018/news/802">meeting of</a> speakers, the Program Committee and activists of the HighLoad ++ 2018 High Load Systems Developers Conference will be <a href="http://www.highload.ru/moscow/2018/news/802">held</a> on July 31 in Moscow at 19:00.  The meeting is open, but you need to <a href="http://conf.ontico.ru/event/join/openhl2018.html">register</a> . <br><br>  <strong>Call for Papers</strong> <br><br>  Actively <a href="https://conf.ontico.ru/lectures/propose%3Fconference%3Dhl2018">accepting applications</a> for reports on Highload ++ 2018. The program committee is waiting for your abstract until the end of the summer. <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/417617/">https://habr.com/ru/post/417617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417607/index.html">A / V tests do not work. Check what you are doing wrong</a></li>
<li><a href="../417609/index.html">Specialization in sports programming on Curser</a></li>
<li><a href="../417611/index.html">We start service of an assessment of employers on "My circle"</a></li>
<li><a href="../417613/index.html">Ceph as a connected storage: 5 practical conclusions from a large project</a></li>
<li><a href="../417615/index.html">Confessions of a burglar drives for Apple II: Secrets 4am</a></li>
<li><a href="../417619/index.html">Win32 / Glupteba is no longer associated with the operation of Windigo</a></li>
<li><a href="../417621/index.html">What happened when we hacked the show?</a></li>
<li><a href="../417627/index.html">Hyper CRM or mini ERP? Business is confused</a></li>
<li><a href="../417629/index.html">Delphi and C ++ Builder Community Edition</a></li>
<li><a href="../417631/index.html">CSS Grid Video Tutorial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>