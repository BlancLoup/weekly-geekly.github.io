<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Shadow on the fence, or 25 trees for Adam Jensen</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The story of how I tried to build beautiful three-dimensional shadows without going beyond the framework of a cozy two-dimensional game-development, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Shadow on the fence, or 25 trees for Adam Jensen</h1><div class="post__text post__text-html js-mediator-article">  The story of how I tried to build beautiful three-dimensional shadows without going beyond the framework of a cozy two-dimensional game-development, and what came of it. <br><br><img src="https://habrastorage.org/files/7c9/903/6ab/7c99036ab6864078b2a2437404178b06.png"><br><a name="habracut"></a><br><h3>  Prehistory </h3><br>  In preparation for the next Ludum Dare, I decided to try to sketch a few games of different genres.  I generally have no experience in game development, so I considered only 2D games and only the <a href="http://phaser.io/">Phaser.js</a> engine.  One of the ideas was the 2D stealth.  And where stealth is, there is work with light and shadow.  Googling a bit and finding, by the way, such good articles on Habr√© ( <a href="https://habrahabr.ru/post/272427/">one</a> and <a href="https://habrahabr.ru/post/272233/">two</a> <a href="https://habrahabr.ru/post/272427/">times</a> ), I took the <a href="">Illuminated.js</a> library, a <a href="http://opengameart.org/content/roguelikerpg-pack-1700-tiles">random collection of assets from OpenGameArt.org,</a> and soon I got this picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/af8/d3a/b8b/af8d3ab8b7fd4187a8bcfb0133000c94.png"></div><br>  I liked the picture.  Thanks to the light and the shadows, a certain mood, some depth appeared at once.  It was frustrating that the shadows did not look quite natural.  And no wonder, after all, illuminated.js works with a purely 2D environment (read, top view or side view), and here I have pseudo-3D (front view / top view).  And you want and the final shadows instead of endless (if the light source is high), and that the light passed through the slots in the fence.  In general, that was beautiful. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, the statement of the problem looked like this: <br><br><ul><li>  there is a drawn set of sprites (this is important, since I myself am not particularly able to draw and it is easier for me to generate images from raw materials) </li><li>  perspective - top / front, pseudo-3D.  If it's just top / side, then illuminated.js and the methods mentioned above are also suitable. </li><li>  at the same time 2D engine.  Still, the logic is easier to do in two dimensions, the levels are easier to make, the tools are there - for ludum dare this is all quite important. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Note to readers</b> <div class="spoiler_text">  Experienced game developers and 3D applications are unlikely to find something new for themselves.  If you just care about the result and / or closer development on Unity, then such a scene is easier to compose in it - both light and shadows will work out of the box.  This article can be viewed as an experiment, as well as a small piece of advice for those who, like me, are not friends with pencils and photoshop: even without drawing skills, it can be done beautifully by other means. <br></div></div><br><h3>  Solution 1. Naive raycasting </h3><br>  ( <a href="https://alexeygrishin.github.io/ld-prepare/game2/index3.html">link to example</a> ) <br><br>  The first method that came to mind was raycasting.  That is, we take and from each pixel of the scene draw a line to the light source.  If there is an obstacle on the way, it means that the pixel is in the shadow. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2cd/7ce/ac1/2cd7ceac12824febb69b21322d9eca5b.png"></div><br>  Obviously it was not worth making such a javascript, so the WebGL fragment shaders came to the rescue.  Fragment Shader is performed by a video card for each pixel inside a drawn polygon (in our case, a rectangle the size of a canvas game), which exactly coincides with our goals.  It remains to pass to the shader information about the light sources and obstacles. <br><br><div class="spoiler">  <b class="spoiler_title">If you are interested in how to work with shaders in Phaser.js</b> <div class="spoiler_text">  Here you can see a simple example: <a href="http://phaser.io/examples/v2/filters/basic">http://phaser.io/examples/v2/filters/basic</a> <br></div></div><br>  If the light sources are more or less clear, then the obstacles need to be moved in three dimensions.  Let's say the 16x16 tree should become something like a cone with a base radius of 8 and a height of 16. Such a cone can be obtained by rotating the original sprite.  A fence is enough to add a thickness of 2-3 pixels. <br><br>  As a result, all used sprites turned into 3D models made in the form of a texture - 16 images per 1 sprite, sections for each height.  You can call it a voxel model, but at that time I did not know such a word yet :) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0cf/ae7/ced/0cfae7cedd1f43df8e17a7689d93002d.png"></div><br>  The shader received this texture as an input, as well as a scene map with marks where what sprite is drawn (the sprite number is color coded).  As a result, the algorithm was as follows: <br><table><tbody><tr><td width="400"><img src="https://habrastorage.org/files/b46/80e/874/b4680e8744a74a9bb1c33a9b844a88d4.png"><br></td><td><ol><li>  take the current point (x, y, z), where z == 0 (ground) </li><li>  determine the direction to the light source.  we normalize this vector in order to move no more than 1 pixel in any direction in 1 step. </li><li>  perform N steps towards the light source.  For each step: <ol><li>  look at the texture with marks.  If the current (x, y) coordinates indicate that there is a sprite, take its number.  Otherwise the point is empty, we continue the movement. </li><li>  Look at the voxel model for this sprite.  If for our current (x, y, z) there is an opaque pixel, then we stop and note that the pixel is shaded. </li></ol><br></li></ol><br></td></tr></tbody></table>  Oddly enough, it all started almost immediately, giving this picture: <br><table><tbody><tr><td><img src="https://habrastorage.org/files/7d5/2db/498/7d52db4986614e3197b9cafee8fa87f4.png" align="right"><br></td><td><img src="https://habrastorage.org/files/cc2/203/cd3/cc2203cd3cd84f9aadc9f85856985849.png" align="left"><br></td></tr></tbody></table><br>  Overall, not bad.  But clearly not enough light / shading of the objects themselves.  Let's say the trees ‚Äúbelow‚Äù the light source are actually closer to us and should be shaded.  The Christmas tree on the right should be lit half.  And the gravestone in the screenshot on the right should be partially obscured by a fence. <br><br>  Let's try to solve both problems at once.  In the shader, we always throw a ray from the ground.  However, we have 3D-models of sprites, and we know what point of the sprite at what height is located.  Take advantage of this knowledge. <br><table><tbody><tr><td><img src="https://habrastorage.org/files/972/445/660/9724456603b24ba1bfe16802c550a0bd.png" align="right"><br></td><td><img src="https://habrastorage.org/files/23e/0f5/e05/23e0f5e05f7f436787686a0460efa479.png" align="left"><br></td></tr></tbody></table>  It is quite another matter. <br><br>  You can see that our shadows are quite sharp - what‚Äôs on the ground, what‚Äôs on the objects themselves due to their ‚Äúpixelation‚Äù.  I also paid attention to this and already began to think how to solve this problem, until I ran into a problem of another kind: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/126/fcb/a80/126fcba80f354bcf9c1d45b5bb852925.png"></div><br>  I think those who have already looked <a href="">at the shader code</a> , immediately saw a bunch of problems: <br><br><ul><li>  nested loops (first by light sources, then by ‚Äústeps‚Äù with raycasting) </li><li>  cascading texture calls (first to one to check if there is a sprite at this point, then to another - to check if there is a pixel at the desired point) </li><li>  many conditional statements (if) </li></ul><br>  So there was a second solution. <br><br><h3>  Solution 2: Improved Reykasting </h3><br>  ( <a href="https://alexeygrishin.github.io/ld-prepare/game2/index5.html">link to example</a> ) <br><br>  To eliminate the cascade appeal to textures, it was decided to make one texture with a 3D map of the whole world.  Models we have low, from 16 to 32 pixels.  The solution to the forehead would be to build 32 "slices" of the world and put them one after the other into one picture-texture.  But this will not work: with a world size of 640x640, we get the size of the texture 32 times larger, and WebGL does not digest so much.  Rather, as I suspect, it can digest depending on the combination of OS / Browser / Video card, but it‚Äôs better not to count on it. <br><br>  Well, you need to think about how to shrink it all.  In general, we do not need information about the color of the pixel, only its presence / absence at a given point. <br><br>  In WebGL, when loading a texture, we can specify its format (integer color components, or floating point, the presence / absence of an alpha channel).  But since  we work through Phaser, which by default uses single-byte color components.  We have 3 color bytes per pixel, you can fit in them information about 24 pixels.  If we package ‚Äúheight‚Äù in this way, then we will need a texture 2 times larger than the world - half for heights from 0 to 23 and half for heights from 24 to 31. Or, for simplicity, it is better to break exactly in half - below 16 and above 16 respectively. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c87/e77/d66/c87e77d667ba411f9493e366e8f0ed7d.png"></div><br><div class="spoiler">  <b class="spoiler_title">What about the alpha channel?</b> <div class="spoiler_text">  In general, in addition to color components, we also have an alpha channel - a whole byte.  However, it all rests on the presence / absence of "pre-multiplication" (premultiplied alpha).  If this mode is enabled (it is enabled by default, besides, it is impossible to disable it in IE), then the color components cannot be greater than the alpha channel value, this color is considered incorrect and, apparently, is forced to the necessary form.  This leads to a distortion of the three color bytes for some values ‚Äã‚Äãof the alpha byte.  So just in case, I do not use the alpha channel. <br></div></div><br>  Creating such a map in javascript is not difficult, since there are bitwise operations.  But in the shader waiting for an ambush. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2a0/73c/0d9/2a073c0d9aba447d92f7460a9ece53bc.png"></div><br>  There is nothing to do - will have to do calculations.  In fact, I need only one operation - checking that the bit is set in the correct position (position = z coordinate).  With bitwise operations, this would be AND by mask, and so I had to write the following function: <br><br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> checkBitF(<span class="hljs-type"><span class="hljs-type">float</span></span> val, <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span>) { <span class="hljs-type"><span class="hljs-type">float</span></span> f = pow(<span class="hljs-number"><span class="hljs-number">2.</span></span>, floor(mod(<span class="hljs-type"><span class="hljs-type">bit</span></span>, <span class="hljs-number"><span class="hljs-number">16.</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> step(<span class="hljs-number"><span class="hljs-number">1.</span></span>, mod(floor(val/f),<span class="hljs-number"><span class="hljs-number">2.</span></span>)); }</code> </pre> <br>  If you translate into human language (or at least js), you get this: <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkBitF</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val, bit</span></span></span><span class="hljs-function">) </span></span>{ f = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">2</span></span>, bit % <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  f = 1 &lt;&lt; bit; f1 = Math.floor(val / f); //   , f1 = val &gt;&gt; bit if (f1 % 2 &lt; 1) return 0; else return 1; //  ,  1.  0. }</span></span></code> </pre> <br>  By the way, if suddenly you think that mod in shaders always returns an integer - it is not. <br><br>  You can get rid of the conditional statements using the built-in functions - mix, step, clamp.  Using them allows the GPU to better optimize the code. <br><br><div class="spoiler">  <b class="spoiler_title">Small example</b> <div class="spoiler_text">  Look at this shader: <a href="https://www.shadertoy.com/view/llyXD1">www.shadertoy.com/view/llyXD1</a> . <br>  Above you will see the following lines: <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_STEPS 1500 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STEP_DIV MAX_STEPS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> raycast raycastMath</span></span></code> </pre> <br>  To begin, set the MAX_STEPS number so that you have an average fps just below 60 (note that values ‚Äã‚Äãabove 60 are not shown).  After that, change the third line to <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> raycast raycastIf</span></span></code> </pre> <br>  I have fps 40 with raycastMath and 32 with raycastIf.  The difference, in essence, is in the following lines: <br><br>  Conditional operator: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBlack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vec4 color</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color.r + color.b + color.g &lt; <span class="hljs-number"><span class="hljs-number">20.</span></span>/<span class="hljs-number"><span class="hljs-number">255.</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Calculation: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> getBlackness(vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> step(<span class="hljs-number"><span class="hljs-number">20.</span></span>/<span class="hljs-number"><span class="hljs-number">255.</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>.r + <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>.b + <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>.g); }</code> </pre><br></div></div><br>  The resulting picture was not very different from the previous solution, but fps was already 1.5 to 2 times larger (more detailed calculations are at the end of the article). <br><br><img src="https://habrastorage.org/files/0b3/b55/27c/0b3b5527ce844937980f55a162af2e0d.png"><br><br>  By this time, I had already read a lot about the shadows and found out that in the 3D world most people use a method called <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">shadow mapping</a> .  The essence of it is as follows: <br><br><ul><li>  we first build the scene from the point of view of the light source and for each pixel of each triangle we remember the distance from it to the light source. </li><li>  Further, the obtained shadow map (shadow map) is used when constructing the scene from the point of view of the observer.  For each pixel of each triangle, check with the corresponding point on the shadow map.  If there is a pixel located closer to the light source, then our pixel is in the shadow. </li></ul><br>  In order for this to work as it should, you need to build models with honest three-dimensional polygons; you can't get by with pixel texture.  Phaser, being engine sharpened under 2D, does not give opportunities to steer vertex shaders.  But it makes it possible to draw an arbitrary canvas on itself.  Therefore, we can build a 3D scene separately, make only shadows be drawn and then draw it over our 2D scene. <br><br><h3>  Solution 3: 3D shadows </h3><br>  ( <a href="https://alexeygrishin.github.io/ld-prepare/game2/index8.html%3FLightsAmount%3D4%26DoubleScene%3Dfalse%26ShadowShader%3Dfalse%26RotateModels%3Dtrue%26ConvertViaVox%3Dfalse">link to example</a> ) <br><br>  To work with three-dimensional objects, I took <a href="https://threejs.org/">three.js</a> , judging that working with webgl directly, I spend much longer. <br><br>  First we had to turn sprites into 3D meshes.  At that time I got acquainted with the tool <a href="https://ephtracy.github.io/">MagicaVoxel</a> (a good tool for working with voxels, by the way), looked exactly how it exports into the obj-file and first decided to repeat the transformation.  The algorithm was as follows: <br><br><ul><li>  we take a voxel model (and I already knew how to build it) </li><li>  for each voxel, we determine the faces that are visible, i.e.  do not border with other voxels </li><li>  write 2 triangles for each face + color information.  In three.js THREE.BufferGeometry is well suited for its custom geometries.  For the sake of experiment, I tried to add all voxels to the scene as single-pixel cubes (THREE.BoxGeometry) ... well, don't do that. </li></ul><br>  For the sake of interest, I converted the Christmas tree and counted the number of triangles.  It turned out that for one small 16x16x16 pixel tree it took about 1000 triangles.  Then a friend gave me this link - <a href="http://www.leadwerks.com/werkspace/topic/8435-rule-of-the-thumb-polygons-for-modelscharacter/">http://www.leadwerks.com/werkspace/topic/8435-rule-of-the-thumb-polygons-for-modelscharacter/</a> - where the sizes of models of some of the characters in popular games are shown.  There I found this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4a3/b7c/f50/4a3b7cf503f94123a6a6689fcbbd3722.png"></div><br>  Well, from 25 of my trees, you can assemble a whole Adam Jensen! <br><br>  In the end, I redid the conversion of sprites, skipping the stage with the "voxels".  The figures of rotation (like Christmas trees) turned out to be more round and were lit a little more naturally (or unnaturally - depending on your views on the cone-shaped Christmas trees).  To reduce the number of polygons, I stopped storing information about the color of each of them (so I was able to merge adjacent polygons into one), instead I added the original sprite as a material texture and referred to points on this texture in polygons (so-called .vv-mapping). <br><br>  All this led to a two-fold decrease in the number of triangles, but, interestingly, it had no effect on performance.  Very different things influenced the performance in this decision. <br><br>  The solution works, and even draws shadows, no worse than my raycasting. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/082/c06/cb8/082c06cb886647a380965341770a4db6.png"></div><br>  Of course, now the trees are drawn ‚Äúfrom above‚Äù, since  to build shadows, this is their correct position, and we partially lost the ‚Äúmagic‚Äù of the two-dimensional version ... But this problem can be solved. <br><br>  three.js (or maybe any 3D engine at all, I‚Äôm not strong yet) to draw a single object (mesh) requires 2 things: <br><br><ul><li>  Geometry - information about the form (read - a set of triangles with different attributes - the vector of normals, uv-coordinates of the texture, color, etc.) </li><li>  Material - information about the material (read - a set of vertex / fragment shaders that draw the shape, applying shadows, lighting, drawing reflections, etc. based on the material properties).  In three.js there are several available materials, they differ in appearance, support of certain functions (for example, shadows can not all draw) and performance. </li></ul><br>  Thus, the material, or rather its shaders, is responsible for the specific rendering.  We can easily take the material and correct the vertex shader so that the model is drawn rotated, but all the calculations (shadows, illumination) were applied to it as if there was no rotation. <br><br>  As a result, I took all the objects of the scene and at the very end of the vertex shader, each one added the following lines: <br><br><pre> <code class="hljs matlab">gl_Position.z = gl_Position.y; gl_Position.y += -position.y/${<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>}. + position.z/${<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>}.;</code> </pre> <br>  Where <br><br><ul><li>  size - the size of the world (gl_Position should contain coordinates from -1 to 1, where the point (0,0,0) is the center of the scene) </li><li>  position - the relative position of the point inside the figure, the vertix attribute. </li></ul><br>  At the same time, I did not touch the varying variables that are passed on to the fragment shader.  Therefore, the fragment shader will apply lighting and shadows in the old way, as if the object were not rotated, but it will be displayed rotated. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f9a/749/1b5/f9a7491b55544369a8a57ca575fe04d6.png"></div><br><h3>  Results </h3><br>  Let's see how all three options look like: <br><table><tbody><tr><th>  Naive raycasting </th><th>  Raycasting </th><th>  3D </th></tr><tr><td><div style="text-align:center;"><img src="https://habrastorage.org/files/cba/7bf/e5b/cba7bfe5b16b4ca3a3792cbe97890009.png"></div><br></td><td><div style="text-align:center;"><img src="https://habrastorage.org/files/928/503/742/9285037425f945ec85f2530ca7d1c429.png"></div><br></td><td><div style="text-align:center;"><img src="https://habrastorage.org/files/fbe/f84/ae6/fbef84ae69c4426f8a188427b0ee3612.png"></div><br></td></tr></tbody></table>  And compare the performance of different options. <br><br>  To evaluate the performance, I used the FPS indicator, which is considered in Phaser.js.  When reading the results, it is necessary to take into account that Phaser.js does not display FPS above 60. I honestly tried to find how to fix it, but did not succeed and decided to score. <br><br><div class="spoiler">  <b class="spoiler_title">Workstation Legend</b> <div class="spoiler_text"><ul><li>  <b>Mac</b> - Macbook Pro <br>  Chrome was not considered, because  FPS 60 is almost everywhere in it </li><li>  <b>MSI</b> - Laptop with GeForce GTX 760M, Win8. <br>  FF was not considered.  many examples did not work on it at all </li><li>  <b>IG1 / IG2</b> - workstations with an integrated graphics card (Intel HD Graphics), Win7 </li></ul><br></div></div><br><img src="https://habrastorage.org/files/66d/cbd/074/66dcbd0740224971ad74ea466c8be7c3.png"><br><img src="https://habrastorage.org/files/da1/e16/792/da1e167926944861b47ff556401f61cb.png"><br><img src="https://habrastorage.org/files/a20/2b3/31c/a202b331c866477e96fe312cdf28ed24.png"><br>  What catches your eye: in the FF, the 3D version shows itself as a rule worse than the RC version.  Apparently, the problem is this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0d0/974/b3c/0d0974b3c47b4c52a6048ed59819edf0.png"></div><br>  And the result is, it seems, here is a bug in FF: <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D1246410">Low performance of texImage2D with canvas</a> . <br><br>  Unfortunately, this is exactly the scenario I use: first, the three.js scene draws onto the canvas, and then this canvas is used as a phaser texture.  Alas, I have not yet invented any workaround.  (Unless to build the whole scene, and indeed the whole game, in three.js, but this contradicts the set conditions). <br><br>  In chrome, the 3D version wins raycasting 2 times on average.  However, it should be understood that the speed of raycasting depends largely on the size of the scene (or rather, on the size of the displayed part of it).  For example, you can build shadows on a smaller texture (say, 2 times less - then you have to let 4 times less rays), and blur will hide blemishes from reducing the quality of shadows.  In turn, for the 3D version, you can change the size of the shadow map texture - by default it is 512x512. <br><br><h3>  findings </h3><br><ul><li>  "Naive" raycasting gave a good FPS only on top machines, hellishly warming up the video card </li><li>  "Improved" raycasting and 3D - gave at least 40 FPS for Chrome on all tested machines under the following conditions: <br><ul><li>  - one light source </li><li>  - four light sources + decrease texture / shadow map by 2 times </li></ul><br></li><li>  In the FF, everything is sad </li><li>  In the case of raycasting, we get problems when the shadows have to drop moving objects - for this, we have to redraw the 3D map every frame and send it to the shader. </li><li>  In the case of a 3D solution in three.js, we are quite dependent on the capabilities of the library.  Let's say we can't make the shadows blue (I don‚Äôt know why, really).  And I did not manage to remove the glare from the light source on the "floor" (bright spot under GG). </li></ul><br>  That's all.  Hope it was helpful. <br><br>  <i>Thanks to my colleagues in LD Ruslan and Tole for their help in testing.</i> </div><p>Source: <a href="https://habr.com/ru/post/319530/">https://habr.com/ru/post/319530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319518/index.html">Neurogrid plays dota</a></li>
<li><a href="../319520/index.html">Uncontrolled components in React</a></li>
<li><a href="../319524/index.html">Sound generation for Unity projects using Chuck and OSC</a></li>
<li><a href="../319526/index.html">Horizontal scaling. What, why, when and how?</a></li>
<li><a href="../319528/index.html">A person. Commander Norton</a></li>
<li><a href="../319532/index.html">Indecently simple implementation of indecently simple maze generation algorithm</a></li>
<li><a href="../319534/index.html">Registration is open or NeoQUEST, you are just a space</a></li>
<li><a href="../319536/index.html">Performance Optimization in React</a></li>
<li><a href="../319542/index.html">How I did the fastest site in Thailand</a></li>
<li><a href="../319544/index.html">How well do Assassin's Creed II missions use the open world?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>