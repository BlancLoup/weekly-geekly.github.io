<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Break me down completely (ZeroNights 2013)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all Habrovchanam! My name is Darwin and today I will tell you about how I solved the quacks from ZeroNights 2013 and Kaspersky Lab for the r0...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Break me down completely (ZeroNights 2013)</h1><div class="post__text post__text-html js-mediator-article">  Hello to all Habrovchanam!  My name is Darwin and today I will tell you about how I solved the quacks from ZeroNights 2013 and Kaspersky Lab for the r0 Crew forum and its semi-private Kiev meeting. <br><br>  Some information about quacks: <br><ul><li>  <b>File:</b> ZeroNightsCrackME.exe </li><li>  <b>Platform:</b> Windows 7 (64 bit) </li><li>  <b>Packer:</b> None </li><li>  <b>Anitotladka:</b> Do not stumble </li><li>  <b>Solution:</b> Valid Mail / Serial Pair </li></ul><br>  Instruments: <br><ul><li>  OllyDbg SnD 2.2 </li><li>  IDA Pro 6.1 </li><li>  Some gray matter </li></ul><br>  Let's get down to solving ... <br><br><a name="habracut"></a><h4>  Analysis </h4><br>  Hacking an application always begins with a launch and a superficial investigation of its behavior.  Let's run our cracks and see how it responds to data entry: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/3b3/83d/f93/3b383df93c258244314542d09ae9c7f1.png" alt="image"><br>  <b>Fig.</b>  <b>one</b> <br><br>  As might be expected, we are informed about the incorrectly entered serial code. <br><br>  Now let's open it in IDA Pro, search through the rows and try to find a place in which this tablet is displayed. <br><br>  Go to the tab "Strings windows" (if you do not have it, then open it) and look for the line "Fail, Serial is invalid !!!": <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de3/b60/6f7/de3b606f7b90ff8f799ddaae0145c275.png" alt="image"><br>  <b>Fig.</b>  <b>2</b> <br><br>  Under the line of interest to us we see another equally interesting.  Click on any of the lines and go to the referring code.  As a result, we get here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/405/6b3/f44/4056b3f443ddeebd034752b67e844523.png" alt="image"><br>  <b>Fig.</b>  <b>3</b> <br><br>  From which it becomes clear - the check takes place in the <b>sub_4012D0</b> function.  If you scroll up a bit (literally on the floor of the screen), you will see another interesting point: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c14/896/142/c14896142265871fd8749873a3823b52.png" alt="image"><br>  <b>Fig.</b>  <b>four</b> <br><br>  Here we see two calls to the <b>GetWindowTextA</b> function.  Considering the previous figure, it becomes obvious that both functions are used to retrieve data from the fields of the <b>Email / Serial</b> form. <br><br>  Based on the data obtained, there are two scenarios for further development: <br><br><ol><li>  Start from the beginning.  Put breakpoints on the <b>GetWindowTextA</b> functions and continue to monitor data changes.  The method is long and you can get lost. </li><li>  Start from the end.  Find the code that influences the result (in our case, show the success / failure window) and spin it in the opposite direction.  The method is fast, hardcore and interesting. </li></ol><br>  When I decided to quack, I chose the second way and not only because it is faster (IMHO), but also because I wanted to cheat and spy on a valid pair.  In some cracks, this works, but where it works it is usually asked to restore the algorithm itself, and not just to provide one valid pair.  Looking ahead to say that with a valid pair under review (as expected), I turned around =) <br><br>  But let's take it in order ... <br><br><h4>  Looking for key details </h4><br>  Since we decided to go from the end, the first thing to do is to determine what influences the result of the success or failure of the entered serial? <br><br><h5>  Validation table </h5><br>  To answer the question, let's first look at the lines of code immediately following the call to sub_4012D0.  Based on Fig.  3 it is visible that there is a check of the register EAX.  If it is zero, then go to "Fail", if not then to "Good". <br><br>  Okay, then to call a positive result, the <b>sub_4012D0</b> function in the EAX register should return a non-zero result. <br><br>  Knowing this, let's go into the sub_4012D0 function itself, find its end and try to determine what affects the non-zero value setting in EAX.  No sooner said than done: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/502/019/157/502019157831e67f395121bfaeb487d0.png" alt="image"><br>  <b>Fig.</b>  <b>five</b> <br><br>  Ida does not give a two-digit meaning that the function has at least <b>two outputs</b> (highlighted with a blue frame).  Moreover, the output in the green frame <b>clears the</b> EAX register, and the output in the red frame, on the contrary, <b>sets</b> the unit to one. <br><br>  Determine this, now let's figure out what code precedes the block in the red frame?  For this we use Olka (OllyDbg).  Why is Olya, firstly: because she gives a clearer idea (specifically in our task) than Ida (various gaps and cross-references are distracting in her), and secondly: we will gradually proceed to debugging quacks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c0/a9f/e25/3c0a9fe25dda3d4d08df40bd2f9bf9e7.png" alt="image"><br>  <b>Fig.</b>  <b>6</b> <br><br>  <i><b>Note:</b> Before opening OllyDbg, it is advisable to disable ASLR, the protection mechanism that is responsible for randomizing the address space.</i>  <i>This is done in the registry, in the branch: "HKLM \ SYSTEM \ CurrentControlSet \ Control \ Session Manager \ Memory Management", create the key "MoveImages" (DWORD) with the value "0", and then restart the OS.</i>  <i>If this is not done, after each application restart, the addresses will change ...</i> <br><br>  So, in Fig.  6 that the installation of the register EAX = 1 is preceded by a kind of double cycle (addresses 0x401440-0x401464).  This is our first key element and a starting point to resolve the quack. <br><br>  If you put a bryak on the address 0x401440 and go through to the first check: <br><br>  <i><b>Note:</b> It is worth saying that if in the input field you use a line other than "111122223333444455", you will have to face two more problems.</i>  <i>The first is <b>in length</b> , and the second is <b>in valid characters</b> that can be used in the serial code.</i>  <i>The definition of the code responsible for these restrictions, I will leave for you.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb8/232/b19/fb8232b1990784a3ed58e451efb09033.png" alt="image"><br>  <b>Fig.</b>  <b>7</b> <br><br>  You will see that in line 0x401449 the unit is checked with some value that is located at the address (in my case) 0x18FB28.  Further, if you successfully go through the entire cycle (by manipulating the branches or values ‚Äã‚Äãat the required addresses; otherwise, you understand, you will understand) you will find that there are a total of 9 elements (each 4 bytes in size): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b9/410/a5d/7b9410a5db2dcaba7f0ce8fbc2b29620.png" alt="image"><br>  <b>Fig.</b>  <b>eight</b> <br><br>  I gave these 9 elements the name "Validation Table".  If you, like me, customized the values ‚Äã‚Äãof the elements (during their testing in the cycle), you and I should have got this result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb9/62f/5ef/fb962f5efee24648b41f69e6ad5aacd5.png" alt="image"><br>  <b>Fig.</b>  <b>9</b> <br><br>  That is, in the end (abbreviated form) we should have something like: 100010001. <br><br>  We continue the definition of key elements and try to determine: <br><br>  Who writes at 0x18FB28-0x18FB48? <br><br><h5>  Code responsible for completing the "Validation Table" </h5><br>  To detect this code, do the following: <br><ul><li>  We continue the implementation of quacks (click F9 in Olka); </li><li>  We put the bryak on the sub_4012D0 call (or he should already be there); </li><li>  Switch to quacks and in the pop-up window (indicating success or non-success), click "OK" (thus continuing the work of the quacks); </li><li>  Next, click on the "Check" button to start the recalculation of the serial, after which you should stop at the call to sub_4012D0; </li><li>  Standing on the call sub_4012D0, put bryak on the record, at the address 0x18FB28; </li><li>  And again press F9. </li></ul><br>  If you did everything right, you will find yourself here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/16f/757/e2c/16f757e2c3581e86e686437aeb7076dd.png" alt="image"><br>  <b>Fig.</b>  <b>ten</b> <br><br>  Here, the calculation and saving of the first element of the ‚ÄúValidation Table‚Äù is highlighted with a red frame, the continuation of the calculation of the remaining eight elements is highlighted with a blue frame. <br><br>  The code itself occupies the region of addresses 0x4011D4 - 0x4012BB and is a loop with three iterations.  At each iteration, the values ‚Äã‚Äãof the three elements of the table are calculated and stored.  The presentation of this code on Python is as follows: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> out_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inner_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>): quotient, remainder = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>): x, y = index + (out_index*<span class="hljs-number"><span class="hljs-number">3</span></span>), index + (inner_index*<span class="hljs-number"><span class="hljs-number">3</span></span>) byte = first_serial[x] * second_serial[y] quotient = int(byte / <span class="hljs-number"><span class="hljs-number">7</span></span>) remainder += byte % <span class="hljs-number"><span class="hljs-number">7</span></span> remainder = remainder % <span class="hljs-number"><span class="hljs-number">7</span></span> result_table.append(remainder)</code> </pre> <br><br>  What mean first_serial and second_serial will become clear a little later.  Now we will continue to analyze Fig.  ten. <br><br>  What we have: <br><ul><li>  Address 0x657020 (with incomprehensible data); </li><li>  Address 0x18fadc (with incomprehensible data); </li><li>  Address 0x18faec (with a value of 0x7); </li><li>  Address 0x18fae8 (with a value of 0x18fb30). </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/683/08d/ba8/68308dba84b9dde47cb435174170a497.png" alt="image"><br>  <b>Fig.</b>  <b>eleven</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d38/059/078/d3805907860f11f5ad4ca90590398188.png" alt="image"><br>  <b>Fig.</b>  <b>12</b> <br><br>  Carefully reviewing the code, it turns out that: <br><ul><li>  By calculating the table of the assignment, the address 0x18fae8 has nothing to do; </li><li>  Arrays with 9 elements are located at addresses 0x657020 and 0x18fadc.  At array 0x657020, each element is 1 byte, and at array 0x18fadc, four bytes; </li><li>  The value 0x7 from the address 0x18faec is quite actively used when calculating each of the elements of the validation table. </li></ul><br>  Having this data, let us try to determine what arrays represent at addresses 0x657020 and 0x18fadc.  The most attentive probably already noticed that if you add 9 + 9 = 18. The size of the serial is also equal to 18. Therefore, we can assume that this is it.  But it clearly does not correspond to the one we introduced initially.  Although the most attentive could additionally notice that the elements from the array 0x657020, albeit vaguely, but somehow still resemble the first half of the sequence of elements from the serial number entered by us (111122223). <br><br>  Looking ahead, I‚Äôll say that the entered serial code is converted into an internal representation, so that it is a little more difficult to determine at a glance or by searching for a dump. <br><br><h5>  What is behind the address 0x657020? </h5><br>  We continue our analysis and try to determine what is all the same contained in the array 0x657020? <br><br>  For this: <br><ul><li>  We remove all the breakpoints that were installed on the memory: </li><li>  We continue the implementation of quacks (click F9 in Olka); </li><li>  On the sub_4012D0 call there should be a breakpoint; </li><li>  Switch to quacks and in the pop-up window (indicating success or non-success), click "OK" (thus continuing the work of the quacks); </li><li>  Next, click on the "Check" button to start the recalculation of the serial, after which you should stop at the call to sub_4012D0; </li><li>  Standing on the call sub_4012D0, put bryak on the record, at the address 0x657020; </li><li>  Next, click on F9 2 times (the first time you will find yourself somewhere in the library code, and the second in the right place). </li></ul><br>  If everything is done correctly, we find ourselves here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b7/1dd/54d/7b71dd54d4af6504c1d222fc5e48f440.png" alt="image"><br>  <b>Fig.</b>  <b>13</b> <br><br>  Having traced the code highlighted in red, find out the following: <br><ul><li>  At the address 0x657020, the first 9 bytes of our serial code (111122223) are written; </li><li>  The serial code is taken from the address 0x18FBC4 (in my case). </li></ul><br>  Our suspicions about the array 0x657020 are beginning to be confirmed slowly.  Regarding the address 0x18FBC4 (which stores all the serials entered by us), then you should have got to know him at the very beginning, here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d64/ed7/3a4/d64ed73a4a778c3c6a0aaaa9a52a5a77.png" alt="image"><br>  <b>Fig.</b>  <b>14</b> <br><br>  Here, the red frame highlighted information relating to the serial, blue, the place where the e-mail is stored. <br><br>  However, let's go back to our serial, otherwise we are a little distracted.  After we have traced the instructions from pic.  13, at 0x657020, we have half of our serial number stored: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/421/b36/865/421b368659cb867669d1730d5f56216c.png" alt="image"><br>  <b>Fig.</b>  <b>15</b> <br><br>  But, as we know, slightly different bytes should be stored here.  It means that, most likely, some manipulations will be carried out over this half of the serial.  To find out which, press F9 again.  After which we find ourselves here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ce/0ce/c52/1ce0cec52b101ea0214fe5928198301e.png" alt="image"><br>  <b>Fig.</b>  <b>sixteen</b> <br><br>  Here, the red frame highlights the calculation and storage of the new value for the first element of the array 0x657020, the blue frame highlights the continuation of the calculations of the remaining eight elements. <br><br>  The code itself occupies the region of addresses 0x401070 - 0x401165.  The same calculations are performed for each element.  The equivalent code for these calculations on Python is presented below: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte)</span></span></span><span class="hljs-function">:</span></span> byte_1 = byte &gt;&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> byte_2 = byte_1 &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span> res = (byte - byte_2) res = res &amp; <span class="hljs-number"><span class="hljs-number">0x0f</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-comment"><span class="hljs-comment">#       0x657020 # byte = 0x657020[0] = 0x31 # index = find_index(byte) # 0x657020[0] = 0x40CB28[index]</span></span></code> </pre> <br><br>  If you look closely at Pic.  16, notice some address 0x40CB28.  To its contents, we will return later. <br><br>  After performing all the transformations, we get a result very similar to what we had in Fig.  eleven. <br><br><img src="http://www.reverse4you.org/web_files/Darwin/23.13.2013/Kasper/17.png" alt="image"><br>  <b>Fig.</b>  <b>17</b> <br><br>  If compare Fig.  11 with Fig.  17, you will notice that the bytes are slightly mixed ... For clarity, I will duplicate the eleventh figure below: <br><br><img src="http://www.reverse4you.org/web_files/Darwin/23.13.2013/Kasper/11.png" alt="image"><br>  <b>Fig.</b>  <b>18</b> <br><br>  To find the code that is engaged in mixing bytes, press F9 again. <br>  After that, we will get to Fig.  13th place: <br><br><img src="http://www.reverse4you.org/web_files/Darwin/23.13.2013/Kasper/18.png" alt="image"><br>  <b>Fig.</b>  <b>nineteen</b> <br><br>  After analyzing the code, it becomes clear that new values ‚Äã‚Äãare taken from the address 0x656EC8: <br><br><img src="http://www.reverse4you.org/web_files/Darwin/23.13.2013/Kasper/19.png" alt="image"><br>  <b>Fig.</b>  <b>20</b> <br><br>  The code responsible for populating the 0x656EC8 array is shown below.  How I found it, I think you will figure it out.  The article is still not a rubber ... <br><br><img src="http://www.reverse4you.org/web_files/Darwin/23.13.2013/Kasper/20.png" alt="image"><br>  <b>Fig.</b>  <b>21</b> <br><br>  What's going on here? <br><br>  The EBX register contains the address 0x657020 from which the direct copying of elements into the array 0x656EC8 takes place.  Looking to copy, you can see that some elements are mixed. <br><br>  <b>0x657020:</b> 0, 1, 2, 3, 4, 5, 6, 7, 8 <br>  <b>0x656EC8:</b> 0, 1, 2, 4, 5, 3, 8, 6, 7 <br><br>  Now that we have answered our question ‚ÄúWhat is behind the address 0x657020?‚Äù, We can continue the study and answer other questions: <br><ul><li>  What lies behind the address 0x40CB28 (was just discovered when analyzing the array 0x657020); </li><li>  What is hidden behind the address 0x18FADC (an array that stores 9 elements of 4 bytes each). </li></ul><br><h5>  Derivative ASCII table </h5><br>  Parsing the data hiding behind the 0x18FADC array will be left to independent exploration.  We need to act by analogy with the array 0x657020.  I can only say that the array 0x18FADC stores the second half of the serial code. <br><br>  Immediately we will analyze what the address 0x40B28 is.  To do this, carry out the following manipulations: <br><ul><li>  Turning off all the breakpoints set for memory; </li><li>  We continue the implementation of quacks (click F9 in Olka); </li><li>  On the sub_4012D0 call there should be a breakpoint; </li><li>  Switch to quacks and in the pop-up window (indicating success or non-success), click "OK" (thus continuing the work of the quacks); </li><li>  Next, click on the "Check" button to start the recalculation of the serial, after which you should stop at the call to sub_4012D0; </li><li>  Standing on the call sub_4012D0, put bryak on the record, at the address 0x40B28; </li><li>  Next, click on F9. </li></ul><br>  If everything is done correctly, we find ourselves here: <br><br><img src="http://www.reverse4you.org/web_files/Darwin/23.13.2013/Kasper/21.png" alt="image"><br>  <b>Fig.</b>  <b>22</b> <br><br>  The code in the red frame creates an ASCII table, which is stored at 0x40B28.  In the blue frame, on the basis of your mail, the created table is converted.  I called the end result of this conversion the "Table of Substitutions." <br><br>  The presentation of this code on Python is as follows: <br><br><pre> <code class="python hljs">mail = <span class="hljs-string"><span class="hljs-string">"support@reverse4you.org"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_table</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mail)</span></span></span><span class="hljs-function">:</span></span> ascii_table = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">256</span></span>): ascii_table.append(index) mail = list(mail) len_mail = len(mail) index = <span class="hljs-number"><span class="hljs-number">0</span></span> accumulate_index = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(index &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>): mail_index = index % len_mail byte_ascii = ascii_table[index] byte_mail = ord(mail[mail_index]) accumulate_index += byte_mail accumulate_index += byte_ascii accumulate_index = accumulate_index &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span> byte = ascii_table[accumulate_index] ascii_table[accumulate_index] = byte_ascii ascii_table[index] = byte index += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ascii_table</code> </pre> <br><br>  I am glad to congratulate you, having reached this point, we revealed all the moments unknown to us and found all the key elements necessary for creating our own mail / serial pair. <br><br><h4>  Putting it all together </h4><br><h5>  What we have? </h5><br><ol><li>  Valid range.  The serial code should be equal to 18 characters, which in turn should consist of the characters [0-9], [az], [AZ]; </li><li>  Conversion table  Used to convert the entered serial code to an internal representation; </li><li>  Algorithm for turning the serial code into an internal representation; </li><li>  Algorithm for filling the validation table; </li><li>  Validation table: 100010001. </li></ol><br><h5>  What do you need? </h5><br>  Create a serial code so that after passing through all the transformations, we get the required "Validation Table" (100010001). <br><br><h5>  How did I do? </h5><br>  I have to admit that I had to turn a little down ... Instead of manipulating the "zeros" and "ones" (I came to this a few hours later), I began to pick up the password based on the internal representation of the serial code,  I tried to select the zeros and ones I needed using such values ‚Äã‚Äãas, for example, 0xc0, 0x28, ..., 0xff (i.e. the first 16 characters of the "Replacement Tables").  Which of course was a mistake.  I must say that I was looking for a complex task, which simply did not exist.  Plus, I also threw out a few very important bytes, which constantly interfered with me (when dividing by any number, they gave ‚Äúzero‚Äù) ... In general, for a long time to tell ... <br><br>  Initially, I tried to determine the dependence of the effects of one byte on another, which you eventually led me to similar tables (the initial version, later it was painted in all the colors of the rainbow, unfortunately I deleted it, but this one remained): <br><br><img src="http://www.reverse4you.org/web_files/Darwin/23.13.2013/Kasper/22.gif" alt="image"><br>  <b>Fig.</b>  <b>23</b> <br><br>  Later, at the end of the evening (right after dinner), I was visited by several sensible thoughts, which ultimately led me to use ‚Äúzeros‚Äù and ‚Äúones‚Äù, and not the raw bytes ‚Äú0xc0, 0x28, ..., 0xff.  As soon as this idea occurred to me, I immediately remembered those unfortunate bytes that constantly annoyed me and disturbed me (those who, when interacting with any number, gave me a ‚Äúzero‚Äù).  Having understood this, I instantly found myself at the computer and literally in 1-2 minutes I gathered for myself a valid pair. <br><br>  During my failed attempts, I wrote several functions that allowed me to quickly test various theories about what bytes I needed to be.  Thanks to them, I was able to make a valid pair in 1-2 minutes and I used them to write my keygen.  It should be said that I did not try to somehow optimize or shorten the code, so it turned out to be rather cumbersome (and I honestly did not immediately understand that I was there on the second day after writing it).  Therefore, if that is not much swear. <br><br>  <a href="http://forum.reverse4you.org/showthread.php%3Ft%3D1575">The following link</a> can be found three keygen <b>Pashkin</b> 'a, <b>BoRoV</b> ' a and my favorite <b>Darwin</b> 'a (the keygen of BoRoV'a I liked the most). <br><br>  Passwords from archives: <br><ul><li>  <b>Pashkin:</b> reverse4you.org_4_r00t </li><li>  <b>Darwin:</b> AggGgAgaGcGGggCGCG </li><li>  <b>BoRoV:</b> available in its pure form without an archive </li></ul><br>  That's all, thank you all for your attention. <br><br>  *** <br><br>  The continuation of the article can be found <a href="http://habrahabr.ru/post/215225/"><b>here</b></a> . </div><p>Source: <a href="https://habr.com/ru/post/204432/">https://habr.com/ru/post/204432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204420/index.html">Amazon announced the delivery of goods by robots (video)</a></li>
<li><a href="../204422/index.html">The Neo900 project completed the first phase of development</a></li>
<li><a href="../204424/index.html">Ruslan Sinitsky: "Do not be afraid to destroy standards"</a></li>
<li><a href="../204428/index.html">SMS vulnerability in all Nexus</a></li>
<li><a href="../204430/index.html">Multiple javascript hacks for hipsters</a></li>
<li><a href="../204434/index.html">Graph500 (supercomputers rating 2013)</a></li>
<li><a href="../204436/index.html">Aggregator Architecture: Web Services Patterns (Part 1)</a></li>
<li><a href="../204438/index.html">Tuning SQLite for PHP</a></li>
<li><a href="../204440/index.html">Scroller for video and understanding of the time representation in Objective-C</a></li>
<li><a href="../204442/index.html">"Lisp in Small Pieces" in Russian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>