<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From Objective-C to Swift. Recommendations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Swift is a new programming language from Apple, which it presented this year at WWDC. Together with the programming language, Apple has released an ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From Objective-C to Swift. Recommendations</h1><div class="post__text post__text-html js-mediator-article">  Swift is a new programming language from Apple, which it presented this year at WWDC.  Together with the programming language, Apple has released an excellent guide to the Swift language, which I recommend reading or reading it.  However, reading a book is a very long time!  So if you do not have much time and you just want to learn about the new Swift language, then this article is for you. <br><br>  In this article I would like to share some thoughts about the transition from Objective-C to Swift.  I will try to give you some tips and point out the shortcomings with a different approach to both languages.  Therefore, without further ado, let's move on to the article itself. <br><a name="habracut"></a><br><h4>  Single file vs. interface implementation file </h4><br>  The first, most significant change worth mentioning is the abandonment of the interface.h / implementation.m structure. <br><br>  I must admit that I am a supporter of this model.  Retrieving and sharing information about a class simply by using an interface file is safe and fast. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In Swift, the interface and implementation are not divided into two files.  We simply implement our class (and at the time of writing it is not even possible to add visibility modifiers). <br><br>  If it is really difficult to cope with this change, then you can use the following: common sense. <br><br>  We can easily increase the readability of our classes by good documentation.  For example, you can move items that you want to make ‚Äúpublic‚Äù at the top of our file using extensions to delimit data that is accessible to everyone and personal information. <br>  Another very common technique is to put an underscore "_" for private methods and variables. <br><br>  Here is a small example of their mixing: <br><br><pre><code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// Public extension DataReader { var data { } func readData(){ var data = _webserviceInteraction() } } // Private implementation class DataReader: NSObject { let _wsURL = NSURL(string: "http://theurl.com") func _webserviceInteraction()-&gt;String{ // ... } }</span></span></code> </pre> <br><br>  Although we cannot change the visibility of the elements of our classes, we can try to make access to some of the ‚Äúmore difficult‚Äù ones. <br>  A non-standard solution is to use a nested class that partially hides personal data (at least in auto-complete) <br><br>  Example: <br><br><pre> <code class="objectivec hljs">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DataReader: <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Public *********************** var data:String?{ get{return private.internalData} } init(){ private = DataReaderPrivate() } func publicFunction(){ private.privateFunc() } // Private ********************** var private:DataReaderPrivate class DataReaderPrivate { var internalData:String? init(){ internalData = "Private data!" } func privateFunc (){} } }</span></span></code> </pre><br><br>  We put the private implementation in a private persistent case and use the ‚Äúregular‚Äù implementation in a class as a public interface.  Private elements, in fact, are not hidden, but to access them, we must pass through "private" constants. <br><br><pre> <code class="objectivec hljs">let reader = DataReader() reader.private.privateFunc()</code> </pre><br><br>  The question arises: is it worth the ultimate goal, partial concealment of personal elements? <br>  My suggestion is to wait for visibility modifiers (Apple is working on this), but for now use good documentation with or without extensions. <br><br><h4>  Constants and variables </h4><br>  In Objective-C, I rarely used constant keywords, even when I knew that some data would never change.  In Swift, Apple developers suggest using a constant (let) instead of a variable (var).  So just follow it and try to figure out the role of your variables.  Ultimately, you will use more constants than you expect. <br><br><h4>  Write only what you need to write </h4><br>  Look at 2 lines of codes and find the difference: <br><br><pre> <code class="objectivec hljs">let wsURL:<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string:<span class="hljs-string"><span class="hljs-string">"http://wsurl.com"</span></span>); vs let wsURL = <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string:<span class="hljs-string"><span class="hljs-string">"http://wsurl.com"</span></span>)</code> </pre><br><br>  During the first two weeks of working with Swift, I forced myself to remove the semicolon from each row of code.  It's easier now (and I already forgot what it is in Objective-C). <br><br>  Type inference allows you to assign a type to a variable, deriving it directly from its definition.  This is another benefit that is a bit difficult to master when it comes out using the detailed language Objective-C. <br><br>  We should try to use the methods of sequential naming, otherwise it would be difficult for another developer (and for you) to determine the type derived from the unsuccessful choice of naming: <br><br><pre> <code class="objectivec hljs">let a = something()</code> </pre><br><br>  A better name makes it easier to work: <br><br><pre> <code class="objectivec hljs">let a = anInt()</code> </pre><br><br>  The following major change is the use of parentheses, which are no longer needed: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; b){} vs <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &gt; b {}</code> </pre><br><br>  Remember, what you write in parentheses is evaluated as an expression and is not always allowed to record in this way.  When linking variables, for example, we cannot use brackets: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (let x = data){} <span class="hljs-comment"><span class="hljs-comment">// Error! if let x = data {} // OK!</span></span></code> </pre><br><br>  You do not need to select an interface or delete a semicolon and parentheses, but you can consider these options as one of the ways to write code in Swift.  Ultimately, we increase readability and save time on typing and characters. <br><br><h4>  Optional </h4><br>  When working with functions that return ‚Äúvalue‚Äù (value) or ‚Äúnothing‚Äù (nothing), have you ever wondered which is the best way to determine ‚Äúnothing‚Äù?  I used NSNotFound, -1, 0, custom return values. <br><br>  Thanks to Optionals (Optional) we have ‚Äúnothing-value‚Äù, which is completely defined, we just need to add a question mark after the data type. <br><br>  We can write: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person{ let name:String let car:Car? <span class="hljs-comment"><span class="hljs-comment">// Optional value init(name:String){ self.name = name } } // ACCESSING THE OPTIONAL VALUE *********** var Mark = Person(name:"mark") // use optional binding if let car = Mark.car { car.accelerate() } // unwrap the value Mark.car?.accelerate()</span></span></code> </pre><br><br>  In this example, the Man-owned vehicle relationship is defined as Optional.  This means that the property "car" can be zero, and the person could not have a car. <br><br>  Then we address this value using an additional binding (if you allow (let) a car =) or with the help of the expanded phrase (car?).  If we do not define a property as optional, we must set a value for this property, otherwise the initialization function will make an error. <br>  The last possibility is to determine a non-additional property value - within the initialization function. <br><br>  Thus, we must determine how the properties of the class will interact with the rest of the class, and how they will behave during the existence of class instances. <br><br>  These improvements completely change the way we present our classes. <br><br><h4>  Additional unpacking </h4><br>  If you find it difficult to work with options, because you cannot understand why the compiler will ask you to give a detailed value before using it ... <br><br><pre> <code class="objectivec hljs">Mark.car?</code> </pre><br><br>  ... I propose to think of the option additionally as a structure (it is a structure, so it should not be too difficult), which does not contain the value directly, but adds a layer around it (envelops, fragments-wrap).  If the internal value is determined, you delete the layer (expand-unwrap), and get the desired value, otherwise you get zero. <br><br>  Forced unwrapping through the ‚Äú!‚Äù Sign is simply a way to remove a layer without worrying about the inner size.  You risk trying to access value by layer.  If this value is zero, the application simply fails. <br><br><h4>  Delegation Template </h4><br>  After several years of programming on Objective-C and Cocoa, we are dependent on the delegate pattern.  However, we still use this scheme.  Here is a super simple example of using a delegate: <br><br><pre> <code class="objectivec hljs">@objc protocol DataReaderDelegate{ <span class="hljs-keyword"><span class="hljs-keyword">@optional</span></span> func DataWillRead() func DataDidRead() } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DataReader: <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span> { var delegate:DataReaderDelegate? var data:<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>? func buildData(){ delegate?.DataWillRead?() <span class="hljs-comment"><span class="hljs-comment">// Optional method check data = _createData() delegate?.DataDidRead() // Required method check } }</span></span></code> </pre><br><br>  We replace the delegate existence check and use respondToSelector with an extra chain. <br><br><pre> <code class="objectivec hljs">delegate?.DataWillRead?()</code> </pre><br><br>  Notice that we have to add the protocol using the @obj keyword, because we used @optional.  By the way, the compiler warns us with a message in case we forget to do it. <br><br>  To implement this delegate, we implement the protocol in another class, and assign it, as well as in Objective-C: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewController: <span class="hljs-built_in"><span class="hljs-built_in">UIViewController</span></span>, DataReaderDelegate { override func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() let reader = DataReader() reader.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> } func DataWillRead() {...} func DataDidRead() {...} }</code> </pre><br><br><h4>  Programming Template - Target-action </h4><br>  Another common method that we use in Swift is the interactive element (target-action), and in this case we apply it as in Objective-C. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ViewController: <span class="hljs-built_in"><span class="hljs-built_in">UIViewController</span></span> { @IBOutlet var button:<span class="hljs-built_in"><span class="hljs-built_in">UIButton</span></span> override func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() button.addTarget(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, action: <span class="hljs-string"><span class="hljs-string">"buttonPressed:"</span></span>, forControlEvents: <span class="hljs-built_in"><span class="hljs-built_in">UIControlEvents</span></span>.TouchUpInside) } func buttonPressed(sender:<span class="hljs-built_in"><span class="hljs-built_in">UIButton</span></span>){...} }</code> </pre><br><br>  The small difference is in how we determine the address of a segment (selector).  We simply write the prototype method using a string that will automatically be modified to: <br><br><pre> <code class="objectivec hljs">Selector(<span class="hljs-string"><span class="hljs-string">"buttonPressed:"</span></span>)</code> </pre><br><br><h4>  Singleton Programming Template </h4><br>  Love it or hate it, Singleton is still one of the most accepted programming models. <br><br>  Whether you like it or not, the Singleton pattern is one of the most applicable patterns.  We can implement it using GDC and dispatch_once or rely on the precision-safe nature of the let keyword. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DataReader: <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> var sharedReader:DataReader { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Static{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> let _instance = DataReader() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Static._instance } ... }</code> </pre><br><br>  Let's look at this code: <br>  1. SharedReader is a static component (we can replace it with a function). <br>  2. Static (non-constituent) properties are not yet resolved in the class implementation.  So, thanks to nested types, we add a nested structure to the class.  The structure supports static properties, so we simply add a static property here. <br>  3. The _instance property is a constant.  It cannot be replaced with another value, and is thread safe. <br><br>  We can access a single DataReader instance using: <br><br>  DataReader.sharedReader <br><br><h4>  Structures and calculations </h4><br>  In Swift, structure and computation have many characteristics that you hardly apply in other languages. <br><br>  They support: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> User{ <span class="hljs-comment"><span class="hljs-comment">// Struct properties let name:String let ID:Int // Method!!! func sayHello(){ println("I'm " + self.name + " my ID is: \(self.ID)") } } let pamela = User(name: "Pamela", ID: 123456) pamela.sayHello()</span></span></code> </pre><br><br>  As you can see, the structure uses an initialization function, which in this case is automatically created by Swift (we can add other input parameters for clients). <br><br>  The enum syntax is slightly different from the one we used.  It is defined by the case keyword: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Fruit { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> orange <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> apple }</code> </pre><br><br>  Enum is not limited to its properties: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Fruit:String { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .orange = <span class="hljs-string"><span class="hljs-string">"Orange"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .apple = <span class="hljs-string"><span class="hljs-string">"Apple"</span></span> }</code> </pre><br><br>  We can also build an enum with more complex characteristics: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Fruit{ <span class="hljs-comment"><span class="hljs-comment">// Available Fruits case orange case apple // Nested type struct Vitamin{ var name:String } // Compound property var mainVitamin:Vitamin { switch self{ case .orange: return Vitamin(name: "C") case .apple: return Vitamin(name: "B") } } } let Apple = Fruit.apple var Vitamin = Apple.mainVitamin</span></span></code> </pre><br><br>  In the previous code, we added a nested type (vitamin) and an additional property (mainVitamin), which assigns the initial values ‚Äã‚Äãof the elements for this structure depending on the value of enum. <br><br><h4>  Changeable and unchangeable </h4><br>  With Objective-C, we are accustomed to unchanging and mutable versions of any class.  Some examples are NSArray and NSDictionary. <br><br>  With Swift, we don‚Äôt need different types of data, we just use a constant or variable value in a new way. <br><br>  A variable array is mutable, while with an array constant we cannot change our saved values.  So just keep in mind, the rule ‚Äúlet = immutable, var = variable‚Äù (Bug fixed: you can change an immutable array before Beta 3). <br><br><h4>  Blocks vs Closure </h4><br>  I like the syntax of blocks, it is so clear and easy to remember! <br><br><pre> <code class="objectivec hljs">&lt;/IronicMode&gt;</code> </pre><br><br>  By the way, after several years of Cocoa development, we are used to this syntax, and sometimes I prefer to replace light delegation tasks with blocks.  They are filled with meaning, quick and well applicable. <br><br>  In Swift, similar block elements are closure elements.  They have many properties, and Apple has done a great job trying to simplify the way they are written.  An example on official Swift documentation deprives me of speech.  It begins with the following definition: <br><br><pre> <code class="objectivec hljs">reversed = sort(names, { (s1: String, s2: String) -&gt; Bool <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1 &gt; s2 })</code> </pre><br><br>  and redesigned to: <br><br><pre> <code class="objectivec hljs">reversed = sort(names, &gt;)</code> </pre><br><br>  Thus, there are various ways to implement closures due to type inference, abbreviations ($ 0, $ 1), and direct functions (&gt;). <br><br>  In this article, I do not describe the syntax of a closed expression, but I want to say a few words about the values ‚Äã‚Äãof data collection within a closed expression. <br><br>  In Objective-C, we define a variable as __block when we intend to change its value through Block.  The use of closures, in this case, becomes unnecessary. <br><br>  We can access and modify any value of the surrounding area.  In fact, closed expressions are reasonable enough to capture external elements.  The item is entered as a copy or link.  If the closing changes the value of the element, it creates a link, if not, it creates a copy. <br><br>  If a closure refers to an entry that contains or uses it, we may encounter a circulation cycle. <br><br>  Let's see an example: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person{ var age:Int = <span class="hljs-number"><span class="hljs-number">0</span></span> @lazy var agePotion: (Int) -&gt; Void = { (agex:Int)-&gt;Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.age += agex } func modifyAge(agex:Int, modifier:(Int)-&gt;Void){ modifier(agex) } } var Mark:Person? = Person() Mark!.modifyAge(<span class="hljs-number"><span class="hljs-number">50</span></span>, Mark!.agePotion) Mark = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">// Memory Leak</span></span></code> </pre><br><br>  The agePotion enclosed expression is used by keeping a reference to the current instance.  At the same time, this instance contains a link to the closing - and here the circulation cycle occurs. <br><br>  To avoid this problem, we use the Capture list.  This list links the weak link to the instance that we want to use in the Close.  The syntax is very simple - add a weak link before the definition of Close and the instance will get a weak link instead of a strong one. <br><br><pre> <code class="objectivec hljs">@lazy var agePotion: (Int) -&gt; Void = { [unowned <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>](agex:Int)-&gt;Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.age += agex }</code> </pre><br><br><h4>  Unowned and Weak Links </h4><br>  We already know how a weak link works in Objective-C.  Similarly, it works in Swift, there are no changes. <br><br>  I really appreciated the introduction of this keyword because it is a good hint for determining the relationship between classes. <br><br>  We describe a simple relationship between a person and his bank account: <br><br>  1. A person may have a bank account (optional) <br>  2. The bank account must belong to the person (required) <br><br><pre> <code class="objectivec hljs">We can describe <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> relation with code: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Person{ let name:String let account:BankAccount! init(name:String){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.account = BankAccount(owner: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> BankAccount{ let owner:Person init(owner:Person){ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.owner = owner } }</code> </pre><br><br>  These relationships are going to create a cycle.  The first solution will be the addition of a weak link to the ‚ÄúBank Account.owner‚Äù property.  However, with the help of a weak link, we define another useful limitation: a property must always have a value, it cannot be zero (thus, we satisfy clause 2 from the previous list). <br><br>  In fact, there is nothing more to say about a weak link.  It works just like a weak reference without increasing the register to which it points and provides a nonzero value. <br><br><h4>  Conclusion </h4><br>  I have to admit: sometimes I still work on compiler errors.  The more I use Swift, the clearer it becomes that I do not waste my time experimenting and studying.  There are many interesting changes and things compared to Objective-C that did not exist before and that motivate me to practice more. <br><br>  This is a welcome new development in iOS / OSX and I‚Äôm sure you will love it! <br><br>  ps Translation does not claim to be the most correct and the best translation in Habr√©, if you have any comments, write in a personal, I will rule.  Thank you for understanding. </div><p>Source: <a href="https://habr.com/ru/post/233607/">https://habr.com/ru/post/233607/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../233593/index.html">From Google CardBoard to automatically launch cards in the car</a></li>
<li><a href="../233595/index.html">Ahaha, HotSpot, what are you doing, stop it!</a></li>
<li><a href="../233599/index.html">New Images of Comet Churyumov-Gerasimenko</a></li>
<li><a href="../233603/index.html">Microsoft releases hotfix for MS14-051 update</a></li>
<li><a href="../233605/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ120 (August 11 - 17, 2014)</a></li>
<li><a href="../233617/index.html">Personal storage of html-fragments for amateurs and professionals</a></li>
<li><a href="../233621/index.html">Rust on examples. Part 2</a></li>
<li><a href="../233623/index.html">How we went to the project [#tceh] for 5 years and what, apart from the brain, is not enough for Russian IT startups</a></li>
<li><a href="../233625/index.html">Madrobots goes to war: how do we open a point in "Mega"</a></li>
<li><a href="../233627/index.html">Smart Watch Moto360 lit up in BestBuy prices with a price of $ 249.99</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>