<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JVM TI: how to make a plugin for a virtual machine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Would you like to add some useful feature to the JVM? Theoretically, each developer can contribute to OpenJDK, however, in practice, any non-trivial c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JVM TI: how to make a plugin for a virtual machine</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/dk/iw/hm/dkiwhmwayxse8--tbyxqszp0xeg.jpeg"><br><br>  Would you like to add some useful feature to the JVM?  Theoretically, each developer can contribute to OpenJDK, however, in practice, any non-trivial changes in HotSpot are not very readily accepted from the side, and even with the current shortened release cycle, it may take years before JDK users see your feature. <br><br>  However, in some cases it is possible to expand the functionality of a virtual machine without even touching its code.  The JVM Tool Interface, the standard API for interacting with the JVM, helps in this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, I will show you with concrete examples what can be done with it, tell you what has changed in Java 9 and 11, and honestly warn you about difficulties (spoiler: you have to deal with C ++). <br><br>  I also told this material at the JPoint.  If you prefer video, you can watch the <a href="https://www.youtube.com/watch%3Fv%3DaiuKiE5-0g4">video</a> report. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  The Odnoklassniki social network, where I work as a lead engineer, is almost entirely written in Java.  But today I will tell just about the other part, which is not entirely in Java. <br><br>  As you know, the most popular problem with Java developers is NullPointerException.  Once, while on duty on the portal, I also stumbled upon NPE in production.  The error was accompanied by something like this stack-trace: <br><br><img src="https://habrastorage.org/webt/j6/lb/4t/j6lb4tmh3wmmti8tebobo7znwsu.jpeg"><br><br>  Of course, by the stack-trace you can trace the place of occurrence of an exception up to a specific line in the code.  Only in this case it didn‚Äôt make me feel better, because here the NPE can meet a lot of places: <br><br><img src="https://habrastorage.org/webt/xt/kt/pq/xtktpq4cozo4xvjvllvgtk9cibe.jpeg"><br><br>  It would be great if the JVM suggested exactly where this error was, like this: <br> <code>java.lang.NullPointerException: Called 'getUsers()' method on null object</code> <br> <br>  But, unfortunately, now NPE does not contain anything like this.  Although they have been asking for this for a long time, at least with Java 1.4: <a href="https://bugs.openjdk.java.net/browse/JDK-4834738">this bug is</a> already 16 years old.  Periodically, more and more new bugs on this topic were opened, but they were invariably closed as ‚ÄúWon't Fix‚Äù: <br><br><img src="https://habrastorage.org/webt/5l/tc/xg/5ltcxgloqnkiiudcadczatl6_ne.jpeg"><br><br>  This is not happening everywhere.  Volker Simonis from SAP <a href="https://www.youtube.com/watch%3Fv%3DIsERHnGn7Vs">told</a> how this feature was implemented in SAP JVM long ago and helped out more than once.  Another SAP employee once again <a href="https://bugs.openjdk.java.net/browse/JDK-8218628">found a</a> bug in OpenJDK and volunteered to implement a mechanism similar to that in SAP JVM.  And, about a miracle, this time the bug was not closed - there is a chance that this feature will be included in JDK 14. <br><br>  But when will JDK 14 come out yet, and when will we go to it?  What to do if you want to explore the problem here and now? <br><br>  You can, of course, support your fork OpenJDK.  The very feature of the NPE report is not so difficult, we could well implement it.  But at the same time there will be all the problems of maintaining your own build  It would be great to implement the feature once, and then just connect it to any version of the JVM like a plugin.  And this is really possible!  The JVM has a special API (originally developed for various debuggers and profilers): the JVM Tool Interface. <br><br>  Most importantly, this API is standard.  It has a strict <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">specification</a> , and when implementing a feature in accordance with it, you can be sure that it will work in new versions of the JVM. <br><br>  To use this interface, you need to write a small (or large, depending on what tasks you have) program.  Native: usually written in C or C ++.  In the standard JDK <code>jdk/include/jvmti.h</code> , there is a <code>jdk/include/jvmti.h</code> header file that needs to be <code>jdk/include/jvmti.h</code> . <br><br>  The program is compiled into a dynamic library, and is connected with the <code>-agentpath</code> parameter during the start of the JVM.  It is important not to confuse it with another similar parameter: <code>-javaagent</code> .  In fact, Java agents are a special case of TI agent JVMs.  Further in the text, the word "agent" refers to the native agent. <br><br><h2>  Where to begin </h2><br>  Let's take a practical look at how to spell the simplest JVM TI-agent, a kind of ‚Äúhello world‚Äù. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;jvmti.h&gt; #include &lt;stdio.h&gt; JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* vm, char* options, void* reserved) { jvmtiEnv* jvmti; vm-&gt;GetEnv((void**) &amp;jvmti, JVMTI_VERSION_1_0); char* vm_name = NULL; jvmti-&gt;GetSystemProperty("java.vm.name", &amp;vm_name); printf("Agent loaded. JVM name = %s\n", vm_name); fflush(stdout); return 0; }</span></span></span></span></code> </pre><br>  The first line I connect the same header file.  Next comes the main function that you need to implement in the agent: <code>Agent_OnLoad()</code> .  It is caused by the virtual machine itself when the agent is loaded, passing a pointer to a <code>JavaVM*</code> object <code>JavaVM*</code> . <br><br>  Using it, you can get a pointer to the JVM TI environment: <code>jvmtiEnv*</code> .  And through him, in turn, already call JVM TI-functions.  For example, using <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">GetSystemProperty</a> to read the value of a system property. <br><br>  If now I run this ‚Äúhello world‚Äù by passing the compiled dll file to <code>-agentpath</code> , then the line printed by our agent will appear in the console before the Java program starts to run: <br><br><img src="https://habrastorage.org/webt/rl/cq/eu/rlcqeul7gpb8mahabl0ehgckro8.png"><br><br><h2>  NPE enrichment </h2><br>  Since ‚Äúhello world‚Äù is not the most interesting example, let's return to our exceptions.  The full code of the agent supplementing NPE reports is <a href="https://github.com/odnoklassniki/jvmti-tools/blob/master/richNPE">on GitHub</a> . <br><br>  This is what <code>Agent_OnLoad()</code> looks like if I want to ask the virtual machine to notify us about all exceptions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jint JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Agent_OnLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JavaVM* vm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* options, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* reserved)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiEnv* jvmti; vm-&gt;GetEnv((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>**) &amp;jvmti, JVMTI_VERSION_1_0); jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities); jvmtiEventCallbacks callbacks = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; callbacks.Exception = ExceptionCallback; jvmti-&gt;SetEventCallbacks(&amp;callbacks, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(callbacks)); jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  First, I request the appropriate capability (can_generate_exception_events) from the JVM TI.  We'll talk more about capability separately. <br><br>  The next step is to subscribe to the Exception event.  Whenever a JVM throws exceptions (whether caught or not), our <code>ExceptionCallback()</code> function will be called. <br><br>  The final step is to call <code>SetEventNotificationMode()</code> to turn on notification delivery. <br><br><div class="spoiler">  <b class="spoiler_title">The ExceptionCallback JVM passes everything we need to handle exceptions.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExceptionCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(jvmtiEnv* jvmti, JNIEnv* env, jthread thread, jmethodID method, jlocation location, jobject exception, jmethodID catch_method, jlocation catch_location)</span></span></span><span class="hljs-function"> </span></span>{ jclass NullPointerException = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/NullPointerException"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env-&gt;IsInstanceOf(exception, NullPointerException)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } jclass Throwable = env-&gt;FindClass(<span class="hljs-string"><span class="hljs-string">"java/lang/Throwable"</span></span>); jfieldID detailMessage = env-&gt;GetFieldID(Throwable, <span class="hljs-string"><span class="hljs-string">"detailMessage"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ljava/lang/String;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (env-&gt;GetObjectField(exception, detailMessage) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">32</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buf, <span class="hljs-string"><span class="hljs-string">"at location %id"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) location); env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); }</code> </pre><br></div></div><br>  Here there is both the thread object that threw the exception (thread), and the place where it happened (method, location), and the exception object itself (exception), and even that place in the code that will catch this exception (catch_method, catch_location). <br><br>  What is important: in this callback, in addition to the pointer to the JVM TI environment, the JNI environment (env) is also transmitted.  This means that we can use all JNI functions in it.  That is, JVM TI and JNI perfectly coexist, complementing each other. <br><br>  In my agent, I use both.  In particular, through JNI I check that my exception is of type <code>NullPointerException</code> , and then I substitute the <code>detailMessage</code> field <code>detailMessage</code> an error message. <br><br>  Since the JVM itself sends the location to us - the bytecode index on which the exception occurred, I‚Äôm just here and added this location to the message: <br><br><img src="https://habrastorage.org/webt/ix/h8/pc/ixh8pcrtxcg4rcdwwlg83_gfuam.png"><br><br>  The number 66 indicates the bytecode index where this exception occurred.  But it‚Äôs hard to analyze bytecode manually: you need to decompile the class file, look for the 66th instruction, try to understand what it did ... It would be great if our agent could show something more human-readable. <br><br>  However, in the JVM TI and in this case there is everything that is needed.  True, you have to request additional features of the JVM TI: get bytecode and constant pool method. <br><br><pre> <code class="cpp hljs">jvmtiCapabilities capabilities = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; capabilities.can_generate_exception_events = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_bytecodes = <span class="hljs-number"><span class="hljs-number">1</span></span>; capabilities.can_get_constant_pool = <span class="hljs-number"><span class="hljs-number">1</span></span>; jvmti-&gt;AddCapabilities(&amp;capabilities);</code> </pre><br>  Now I‚Äôll extend the ExceptionCallback: via the JVM TI function <code>GetBytecodes()</code> I get the method body to check what is in it by the location index.  Next comes a big switch on bytecode instructions: if this is a call to an array, there will be one error message, if the call to a field is another message, if the method call is third, and so on. <br><br><div class="spoiler">  <b class="spoiler_title">ExceptionCallback Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">jint bytecode_count; u1* bytecodes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetBytecodes(method, &amp;bytecode_count, &amp;bytecodes) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; location &lt; bytecode_count) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* message = get_exception_message(bytecodes[location]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { ... env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf)); } } jvmti-&gt;Deallocate(bytecodes);</code> </pre><br></div></div><br>  It remains only to substitute the name of the field or method.  You can get it from the <a href="https://habr.com/ru/post/222519/">constant pool</a> , which is available again thanks to the JVM TI. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jvmti-&gt;GetConstantPool(holder, &amp;cpool_count, &amp;cpool_bytes, &amp;cpool) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strdup(<span class="hljs-string"><span class="hljs-string">"&lt;unknown&gt;"</span></span>); }</code> </pre><br>  Next comes a bit of magic, but in reality, nothing tricky, just in accordance with the <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html">specification of the</a> file class file, we analyze the constant pool and from there isolate the line - the name of the method. <br><br><div class="spoiler">  <b class="spoiler_title">Analysis of the constant pool</b> <div class="spoiler_text"><pre> <code class="cpp hljs">u1* ref = get_cpool_at(cpool, get_u2(bytecodes + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// CONSTANT_Fieldref u1* name_and_type = get_cpool_at(cpool, get_u2(ref + 3)); // CONSTANT_NameAndType u1* name = get_cpool_at(cpool, get_u2(name_and_type + 1)); // CONSTANT_Utf8 size_t name_length = get_u2(name + 1); char* result = (char*) malloc(name_length + 1); memcpy(result, name + 3, name_length); result[name_length] = 0;</span></span></code> </pre><br></div></div><br>  Another important point: some JVM TI functions, for example, <code>GetConstantPool()</code> or <code>GetBytecodes()</code> , allocate a certain structure in the native memory that needs to be released after working with it. <br><br><pre> <code class="cpp hljs">jvmti-&gt;Deallocate(cpool);</code> </pre><br>  Let's run the source program with our extended agent, and now a completely different description of the exception: it reports that we called the longValue () method on the null object. <br><br><img src="https://habrastorage.org/webt/8d/ge/-d/8dge-d_mtmqpdesbk6vm4nwolna.png"><br><br><h2>  Other uses </h2><br>  Generally speaking, developers often want to handle exceptions in their own way.  For example, automatically restart the JVM if a <code>StackOverflowError</code> occurred. <br><br>  This desire can be understood, since <code>StackOverflowError</code> is the same fatal error as <code>OutOfMemoryError</code> , after its occurrence, the correct operation of the program can no longer be guaranteed.  Or, for example, sometimes to analyze a problem, I want to receive a thread dump or heap dump when an exception occurs. <br><br><img src="https://habrastorage.org/webt/hh/8b/zy/hh8bzys2bji12vte4g_fsmlfaky.jpeg"><br><br>  In fairness, IBM JDK has such an opportunity out of the box.  But now we already know that using a TI agent JVM, you can implement the same thing in HotSpot.  Just subscribe to exception callback and analyze the exception.  But how to remove a thread dump or heap dump from our agent?  The JVM TI has everything you need in this case: <br><br><img src="https://habrastorage.org/webt/yp/jj/5o/ypjj5o9xn9m7tmhdzmh-z8bo2tk.jpeg"><br><br>  It‚Äôs not very convenient to implement the whole hip bypass and dumping mechanism.  But I will share the secret of how to make it easier and faster.  True, it is no longer included in the standard JVM TI, but is a private extension of Hotspot. <br><br>  You need to connect the header file <a href="">jmm.h</a> from the HotSpot sources and call the <code>JVM_GetManagement()</code> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"jmm.h"</span></span></span><span class="hljs-meta"> JNIEXPORT void* JNICALL JVM_GetManagement(jint version); void JNICALL ExceptionCallback(jvmtiEnv* jvmti, JNIEnv* env, ...) { JmmInterface* jmm = (JmmInterface*) JVM_GetManagement(JMM_VERSION_1_0); jmm-&gt;DumpHeap0(env, env-&gt;NewStringUTF(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dump.hprof"</span></span></span><span class="hljs-meta">), JNI_FALSE); }</span></span></code> </pre><br>  It will return a pointer to the HotSpot Management Interface, which in one call will generate a Heap Dump or Thread Dump.  The complete example code can be viewed in <a href="https://stackoverflow.com/a/23640439/6265477">my response</a> to Stack Overflow. <br><br>  Naturally, you can handle not only exceptions, but also a bunch of other various events related to JVM operation: starting / stopping threads, loading classes, garbage collection, compiling methods, entering / exiting methods, even accessing or modifying specific fields of Java objects. <br><br>  I have an example of another <a href="">vmtrace</a> agent that subscribes to many standard JVM TI events and logs them.  If I start a simple program with this agent, I will receive a detailed log of what was done with timestamps: <br><br><img src="https://habrastorage.org/webt/wu/he/ci/wuhecifrgrrkleshnnkqx6hd9ew.jpeg"><br><br>  As you can see, to simply print hello world, hundreds of classes are loaded, tens and hundreds of methods are generated and compiled.  It becomes clear why Java runs so long.  All about everything took more than two hundred milliseconds. <br><br><h2>  What can JVM TI </h2><br>  In addition to event handling in the JVM TI there are a bunch of other features.  They can be divided into two groups. <br><br>  One is a must-have that any JVM supporting TI JVM must implement.  These include the analysis of methods, fields, streams, the ability to add new classes to the classpath, and so on. <br><br>  There are optional features that require prior request for capabilities.  The JVM is not required to support them all, however HotSpot implements the entire specification completely.  Optional features are further divided into two subgroups: those that can only be connected at the start of the JVM (for example, the ability to set a breakpoint or analysis of local variables), and those that can be connected at any time (in particular, receiving bytecode or constant pool, which I used above). <br><br><img src="https://habrastorage.org/webt/ee/9e/oo/ee9eooqcrrdowlrc1rvqmfuhjs0.jpeg"><br><br>  You may notice that the feature list is very similar to the debugger features.  In fact, a Java debugger is nothing more than a special case of a TI agent JVM that takes advantage of all these capabilities and requests all of its capabilities. <br><br>  The division of capabilities into those that can be enabled at any time, and those that are only at boot, is done on purpose.  Not all features are free, some carry overhead. <br><br>  If with direct overheads that accompany the use of the feature, everything is clear, that is, even less obvious indirect ones that manifest themselves, even if you do not use the feature, but simply, through the capabilities, state that you will need it in the future.  This is due to the fact that the virtual machine can compile the code in a different way or add additional checks at runtime. <br><br>  For example, the already considered capability of subscribing to exceptions (can_generate_exception_events) leads to the fact that all throwing exceptions will go on a slow path.  In principle, this is not so bad, because exceptions are rare in a good Java program. <br><br>  A little worse is the case with local variables.  For can_access_local_variables, which allows you to get local variable values ‚Äã‚Äãat any time, you need to disable some important optimizations.  In particular, Escape Analysis stops working completely, which can give a tangible overhead: depending on the application, 5-10%. <br><br>  Hence the conclusion: if you run Java with the debug agent enabled, even without using it, applications will run slower.  Anyway, turning on a debugging agent in production is not a good idea. <br><br>  And a number of features, for example, setting a breakpoint or tracing all the inputs / outputs from a method, incur much more serious overhead.  In particular, some JVM TI events (FieldAccess, MethodEntry / Exit) work only in the interpreter. <br><br><h2>  One agent is good and two is better. </h2><br>  You can connect multiple agents to the same process by simply specifying several <code>-agentpath</code> parameters.  Everyone will have their own JVM TI environment.  This means that everyone can subscribe to their capabilities and intercept their events independently. <br><br>  And if two agents have subscribed to a Breakpoint event, and one has put a breakpoint in some method, will the second agent receive the event when this method is executed? <br><br>  In reality, this situation cannot arise (at least in the HotSpot JVM).  Because there are some capabilities that only one of the agents can own at any one time.  These include breakpoint_events in particular.  Therefore, if the second agent requests the same capability, it will receive an error in response. <br><br>  From here an important conclusion: in the agent you should always check the results of the query of capabilities, even if you run on HotSpot and know that they are all available.  The TI JVM specification does not say anything about exclusive capabilities, but HotSpot has this implementation feature. <br><br>  True, the isolation of agents does not always work perfectly.  During the development of the <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler,</a> I came across such a problem: when we have two agents and one requests the generation of method compilation events, all agents receive these events.  I, of course, filed a <a href="https://bugs.openjdk.java.net/browse/JDK-8222072">bug</a> , but it should be borne in mind that there may be events in your agent that you do not expect. <br><br><h2>  Use in a regular program </h2><br>  The JVM TI may seem like a very specific thing for debuggers and profilers, but it can also be used in a regular Java program.  Consider an example. <br><br>  The paradigm of reactive programming is now common, when everything is asynchronous, but there is a problem with this paradigm. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TaskRunner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">good</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(GOOD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CompletableFuture.runAsync(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncTask(BAD)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ good(); bad(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">200</span></span>); } }</code> </pre><br>  I run two asynchronous tasks that differ only in parameters.  And if something goes wrong, an exception occurs: <br><br><img src="https://habrastorage.org/webt/ds/me/wx/dsmewxe5rd4lzgq8fgjxn42zh0e.png"><br><br>  From the stack-trace it is completely incomprehensible which of these tasks caused the problem.  Because an exception occurs in a completely different stream, where we have no context.  How to understand exactly which task? <br><br>  As one of the solutions, you can add to the constructor of our asynchronous task information about where we created it: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg = arg; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location = getLocation(); }</code> </pre><br>  That is, to remember the location - a specific place in the code, up to the line from where the constructor was called.  And in the case of an exception, to secure it: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = Integer.parseInt(arg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { System.err.println(<span class="hljs-string"><span class="hljs-string">"ParseTask failed at "</span></span> + location); e.printStackTrace(); }</code> </pre><br>  Now, when an exception occurs, we will see that it happened on line 14 in TaskRunner (where the task with the BAD parameter is created): <br><br><img src="https://habrastorage.org/webt/v-/tq/0q/v-tq0qa-bnlkakz8dnzxhrjfqvo.png"><br><br>  But how to get that place in the code where the constructor is called from?  Before Java 9, there was the only legal way to do this: get the stack trace, skip a few irrelevant frames, and just below the stack will be the place that caused our code. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackTraceElement caller = Thread.currentThread().getStackTrace()[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> caller.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + caller.getLineNumber(); }</code> </pre><br>  But there is a problem.  Getting the full StackTrace is pretty slow.  I have a whole <a href="https://www.youtube.com/watch%3Fv%3D0pyZERLBZvQ">report on this</a> . <br><br>  It would not be such a big problem if it happened rarely.  But, for example, we have a web service, a frontend that accepts HTTP requests.  This is a great application, millions of lines of code.  And to catch rendering errors, we use a similar mechanism: in the components for rendering, we remember the place where they are created.  We have millions of such components, so getting all the stack traces takes considerable time at the start of the application, not one minute.  Therefore, earlier this feature was disabled in production, although it is necessary in production to analyze problems. <br><br>  In Java 9, a new way to bypass stream stacks has appeared: StackWalker, which through the Stream API can do all this lazily, upon request.  That is, we can skip the required number of frames and get only one of our interest. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StackWalker.getInstance().walk(s -&gt; { StackWalker.StackFrame frame = s.skip(<span class="hljs-number"><span class="hljs-number">3</span></span>).findFirst().get(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> frame.getFileName() + <span class="hljs-string"><span class="hljs-string">':'</span></span> + frame.getLineNumber(); }); }</code> </pre><br>  It works a little better than getting a full stack of the stack, but not by an order of magnitude, and not even at times.  In our case, it was faster about half as much: <br><br><img src="https://habrastorage.org/webt/v8/bz/rk/v8bzrkf8szriwvghilzvhrddtzo.jpeg"><br><br>  There is a <a href="https://bugs.openjdk.java.net/browse/JDK-8151751">known problem</a> related to the non-optimal implementation of StackWalker, and, most likely, it will even be fixed in JDK 13. But again, what do we do right now in Java 8, where StackWalker is not even slow? <br><br>  JVM TI comes to the rescue again.  There is a <code>GetStackTrace()</code> function that can do everything it needs: get a fragment of a setraice of a given length, starting from the specified frame, and not do anything extra. <br><br><pre> <code class="cpp hljs">GetStackTrace(jthread thread, jint start_depth, jint max_frame_count, jvmtiFrameInfo* frame_buffer, jint* count_ptr)</code> </pre><br>  There is only one question left: how can we call the JVM TI function from our Java program?  Just like any other native method: use <code>System.loadLibrary()</code> load the native library, where the JNI implementation of our method will be. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackFrame</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> depth)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { System.loadLibrary(<span class="hljs-string"><span class="hljs-string">"stackframe"</span></span>); } }</code> </pre><br>  A pointer to the JVM TI environment <a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html">can be obtained</a> not only from Agent_OnLoad (), but also while the program is running, and continue to use it from the usual native JNI methods: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">JNIEXPORT jstring JNICALL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Java_StackFrame_getLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JNIEnv* env, jclass unused, jint depth)</span></span></span><span class="hljs-function"> </span></span>{ jvmtiFrameInfo frame; jint count; jvmti-&gt;GetStackTrace(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, depth, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;frame, &amp;count);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This approach works several times faster and allowed us to save a few minutes of launching the application: </font></font><br><br><img src="https://habrastorage.org/webt/ia/-u/au/ia-uauyvrmwlvh84rh84rqqwu1s.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">True, with the next update of the JDK, a surprise was waiting for us: the application suddenly began to start very, very slowly. The investigation led to the very native library for getting stack-traces. Understanding, we came to the conclusion that the bug did not appear in our country, but in the JDK. Starting with JDK 8u112, all JVM TI functions that work with methods (GetMethodName, GetMethodDeclaringClass, and so on) have become terribly slow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I started a </font></font><a href="https://bugs.openjdk.java.net/browse/JDK-8185348"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bug</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , looked around a bit, and found a funny story: some JVM TI-functions added debug checks, but did not notice that they are called from the production code as well. This usage scenario was not found, because it was not in the C ++ source code, but in the file</font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jvmtiEnter.xsl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine: during the compilation of HotSpot, part of the source code is generated on the fly through XSLT transformation. </font><font style="vertical-align: inherit;">This is how the enterprise struck back HotSpot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What solution can there be? </font><font style="vertical-align: inherit;">Just do not call these functions too often, try to cache the results. </font><font style="vertical-align: inherit;">That is, if for some jmethodID received information, remember it locally in your agent. </font><font style="vertical-align: inherit;">Applying this caching at the agent level, we returned the performance to the previous level.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic connection </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the previous example, I showed that you can use TI JVM directly from Java code using normal native methods using </font></font><code>System.loadLibrary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, we have already seen how you can connect JVM TI-agents through </font></font><code>-agentpath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when you start the JVM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And there is a third way: dynamic attach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the idea? If you launched into the application and did not think that you would need some feature in the future, or you suddenly needed to investigate a production bug, you can download the JVM TI agent right during execution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting with JDK 9, this became possible directly from the command line using the jcmd utility:</font></font><br><br><pre> <code class="bash hljs">jcmd &lt;pid&gt; JVMTI.agent_load /path/to/agent.so [arguments]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And for older versions of JDK, you can use my </font></font><a href="https://github.com/apangin/jattach"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jattach</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utility </font><font style="vertical-align: inherit;">. For example, </font></font><a href="https://github.com/jvm-profiling-tools/async-profiler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-profiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can connect to applications running without any additional JVM arguments on the fly, thanks to jattach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to take advantage of the possibility of dynamic connection in your JVM TI-agent, you need, in addition </font></font><code>Agent_OnLoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to implement a similar function </font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The only difference is: </font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you cannot use those capabilities that are available only during agent loading. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to remember that you can dynamically connect the same library several times, so that it </font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be called again.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will demonstrate with an example. </font><font style="vertical-align: inherit;">In the role of production will be IntelliJ IDEA: this is also a Java application, which means that we can also connect to it on the fly and do something. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Find the process ID of our IDEA, then use the jattach utility to connect the patcher.dll TI library to this process: </font></font><br> <code>jattach 8648 load patcher.dll true</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And on the fly, it changed the menu color to red: </font></font><br><br><img src="https://habrastorage.org/webt/rv/j7/wm/rvj7wmnfdbo26tjkcsqaix96k74.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does this agent do? </font><font style="vertical-align: inherit;">Finds all Java objects of the specified class ( </font></font><code>javax.swing.AbstractButton</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and calls through the JNI method </font></font><code>setBackground()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fully code can be seen </font></font><a href="https://gist.github.com/apangin/a1ffa97c8b5d448dc84a3bdd7eebb24e"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What's new in java 9 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVM TI has been around for a long time, and, despite existing bugs, there is already a well-established debugged API, which has not changed for a long time. The first significant innovations appeared in Java 9. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you know, Java 9 brought developers pain and suffering associated with modules. First of all, it has become difficult to use the ‚Äúsecrets‚Äù of the JDK, which sometimes can‚Äôt be done without. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, in the JDK there is no legal way to clear the Direct ByteBuffer. Only through a private API: </font></font><br><br><img src="https://habrastorage.org/webt/wj/qb/ue/wjqbuel-1g3j1qis_bihg0lpn_8.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Say, Cassandra without this feature is nowhere, because all the DBMS work is built on working with MappedByteBuffer, and if they are not manually cleared, the JVM will quickly fall. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if you try to run the same code on JDK 9, you will get IllegalAccessError:</font></font><br><br><img src="https://habrastorage.org/webt/co/z-/49/coz-496tvv3ogo7kw44viuqtpwq.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Approximately the same is true with Reflection: it has become difficult to reach private fields. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, in Java, not all file operations from Linux are available. </font><font style="vertical-align: inherit;">Therefore, for Linux-specific capabilities, programmers took a </font></font><code>java.io.FileDescriptor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">system file descriptor </font><font style="vertical-align: inherit;">from a reflex from an object </font><font style="vertical-align: inherit;">and, using JNI, called some system functions on it. </font><font style="vertical-align: inherit;">And now, if you run it on JDK 9, you will see abuse in the logs: </font></font><br><br><img src="https://habrastorage.org/webt/he/xc/6p/hexc6pnrkv0ehoablvlfy11imt0.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, there are JVM checkboxes that open the necessary private modules and allow you to use private classes and reflection. </font><font style="vertical-align: inherit;">But you need to manually register all the packages that are going to use. </font><font style="vertical-align: inherit;">For example, to just run Cassandra on Java 11, you need to prescribe </font></font><a href="https://github.com/apache/cassandra/blob/trunk/conf/jvm11-server.options"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">such a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> panel:</font></font><br><br><pre> <code class="plaintext hljs">--add-exports java.base/jdk.internal.misc=ALL-UNNAMED --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-exports java.base/sun.nio.ch=ALL-UNNAMED --add-exports java.management.rmi/com.sun.jmx.remote.internal.rmi=ALL-UNNAMED --add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED --add-exports java.rmi/sun.rmi.server=ALL-UNNAMED --add-exports java.sql/java.sql=ALL-UNNAMED --add-opens java.base/java.lang.module=ALL-UNNAMED --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/jdk.internal.reflect=ALL-UNNAMED --add-opens java.base/jdk.internal.math=ALL-UNNAMED --add-opens java.base/jdk.internal.module=ALL-UNNAMED --add-opens java.base/jdk.internal.util.jar=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, along with the modules, </font><font style="vertical-align: inherit;">JVM TI </font></font><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jvmti.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">functions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> appeared </font><font style="vertical-align: inherit;">to work with them:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetAllModules </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AddModuleExports </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AddModuleOpens </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etc. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looking at this list, the decision suggests itself: you can wait for the JVM to load, get a list of all the modules, run through all the packages, open everything for everyone, and rejoice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the very example with Direct ByteBuffer:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ ByteBuffer buf = ByteBuffer.allocateDirect(<span class="hljs-number"><span class="hljs-number">1024</span></span>); ((sun.nio.ch.DirectBuffer) buf).cleaner().clean(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Buffer cleaned"</span></span>); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we run it without agents, we expect to receive an IllegalAccessError. </font><font style="vertical-align: inherit;">And if I add an </font></font><a href="https://github.com/odnoklassniki/jvmti-tools/tree/master/antimodule"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">antimodule</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> agent to </font><a href="https://github.com/odnoklassniki/jvmti-tools/tree/master/antimodule"><font style="vertical-align: inherit;">my agentpath</font></a><font style="vertical-align: inherit;"> , the example will work without errors. </font><font style="vertical-align: inherit;">The same with reflexion.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What's new in java 11 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another innovation appeared in Java 11. It is only one, but what a! The possibility of lightweight profiling of allocations has appeared: a new event has been added </font></font><code>SampledObjectAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to which you can subscribe, so that selective notifications about allocations come. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything that is needed for further analysis will be transferred to the callback: the stream that allocates, the selected object itself, its class, size. Another method </font></font><code>SetHeapSampingInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is to change the frequency, how often these notifications will arrive. </font></font><br><br><img src="https://habrastorage.org/webt/5f/e1/8_/5fe18_nwt5i-zbm4e-vyn4roavm.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why do you need it? Allocation profiling was done earlier in all popular profilers, but it worked through instrumentation, which is fraught with large overheads. The only profiling tool with a low overhead was Java Flight Recorder.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idea of ‚Äã‚Äãa new method is not to instrument all allocations, but only some of them, in other words, to sample. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the fastest and most frequent case, allocation occurs inside the Thread Local Allocation Buffer by simply increasing the pointer. And with the inclusion of sampling in TLAB is added to the virtual boundary corresponding to the sampling frequency. As soon as the next location crosses this boundary, an event about the selection of the object is sent. </font></font><br><br><img src="https://habrastorage.org/webt/v0/lm/di/v0lmdimdyk8uvasl3z9gkjlrfqe.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some cases, large objects that do not fit into a TLAB are allocated directly in the heap. Such objects also pass through a slow allocation path through the JVM runtime and are also sampled.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to the fact that now sampling is performed only for some objects, overhead costs are already acceptable for production - in most cases less than 5%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interestingly, this opportunity was a long time ago, since the days of JDK 7, made specifically for Flight Recorder. But through the private API of Hotspot, this was also used by async-profiler. And now, starting with JDK 11, this API has become public, entered into the JVM TI, and other profilers can use it. In particular, YourKit already knows how. And how to use this API, you can see in the </font></font><a href="https://github.com/odnoklassniki/jvmti-tools/tree/master/heapsampler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> laid out in our repository. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the help of this profiler you can build beautiful allocation diagrams. Look at what objects stand out, how many of them stand out and, most importantly, from where.</font></font><br><br><img src="https://habrastorage.org/webt/qi/t1/lw/qit1lwwqv3p7vxhhl-fbcfh5bos.jpeg"><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVM TI is a great way to interact with a virtual machine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plug-ins written in C or C ++ can be launched when the JVM is started, or it can be connected dynamically while the application is running. </font><font style="vertical-align: inherit;">In addition, the application itself can use JVM TI functions through native methods. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All demonstrated examples are posted in our repository </font></font><a href="https://github.com/odnoklassniki/jvmti-tools"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Use, study and ask questions.</font></font></div><p>Source: <a href="https://habr.com/ru/post/458812/">https://habr.com/ru/post/458812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45880/index.html">Problem solved. But is the code good?</a></li>
<li><a href="../458800/index.html">Deep learning. Federated learning</a></li>
<li><a href="../458804/index.html">Digest of machine learning and artificial intelligence articles</a></li>
<li><a href="../458808/index.html">Habr postmortem report: fell on the newspaper</a></li>
<li><a href="../458810/index.html">Corel and Parallels sold to US investment group KKR</a></li>
<li><a href="../458814/index.html">Launching a site for a product with unformed demand</a></li>
<li><a href="../45882/index.html">Grand Theft Auto IV PC Edition</a></li>
<li><a href="../458820/index.html">On the implementation of the famous genre on the Minecraft platform</a></li>
<li><a href="../458826/index.html">How to eliminate old articles so that they grow dramatically in organics: + 104% of traffic in six months</a></li>
<li><a href="../458828/index.html">Why, why, and when you need to use ValueTask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>