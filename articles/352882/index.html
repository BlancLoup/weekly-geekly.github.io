<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why do you have to give another chance to closure</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to you the translation of the article ‚ÄúWhy you should give the Closure function another chance‚Äù by Cristi Salcescu. 



 In JavaSc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why do you have to give another chance to closure</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to you the translation of the article <a href="https://medium.freecodecamp.org/why-you-should-give-the-closure-function-another-chance-31253e44cfa0">‚ÄúWhy you should give the Closure function another chance‚Äù</a> by Cristi Salcescu. <br><br><p>  In JavaScript, functions can be nested inside other functions. </p><blockquote>  A closure is when an internal function has access to the variables of the parent function, even after the parent function is executed. </blockquote><p>  As you can see, it becomes interesting when the internal function continues to exist in the call to the parent function.  This will happen in the following situations: <br><br></p><ul><li>  an internal function is used as a call for an asynchronous task, such as a timer, an event, or AJAX. </li><li>  the parent function returns an internal function or an object that stores the internal function. </li></ul><a name="habracut"></a><br><h2>  Closing and Timers </h2><br><p>  In the following example, we expect that the local variable <i>x</i> will be immediately destroyed after executing the <i>autorun ()</i> function, but it will be alive for 10 minutes.  This is due to the fact that the variable <i>x is</i> used by the internal <i>log ()</i> function.  The <i>log ()</i> function is a closure. </p><br><pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">autorun</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); }, <span class="hljs-number"><span class="hljs-number">6000</span></span>); })();</code> </pre> <br><p>  When <i>setInterval () is used</i> , the variable referenced by the closure function will only be destroyed after calling <i>clearInterval ()</i> . </p><br><h2>  Closure and events </h2><br><p>  We create closures every time variables from external functions are used in event handlers.  The event handler <i>increment ()</i> is a closure in the following example. </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initEvents</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; $(<span class="hljs-string"><span class="hljs-string">"#add"</span></span>).on(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ state += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(state); }); })();</code> </pre> <cut></cut><br><h2>  Closing and asynchronous tasks </h2><br><p>  When variables from an external function are used in an asynchronous call, the call becomes a closure, and the variables will remain active until the asynchronous task is completed. </p><br><p>  Timers, events, and AJAX calls are probably the most common asynchronous tasks, but there are other examples: HTML5 Geolocation API, WebSockets API, and requestAnimationFrame (). </p><br><p>  In the following example, the AJAX call <i>updateList ()</i> is a closure. </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list; $.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">"https://jsonplaceholder.typicode.com/users"</span></span>}) .done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ list = data; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(list); }) })();</code> </pre> <br><h2>  Closure and Encapsulation </h2><br><p>  Another way to see a closure is a private state function.  A closure encapsulates a state. </p><br><p>  For example, let's create a <i>count ()</i> function with a private state.  Each time she is called, she remembers her previous state and returns the next consecutive number.  The <i>state</i> variable is private, there is no access to it from outside. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCount</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ state += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = createCount(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(count()); <span class="hljs-comment"><span class="hljs-comment">//1 console.log(count()); //2</span></span></code> </pre> <br><p>  We can create multiple closures that share the same private state.  In the following example, <i>increment ()</i> and <i>decrement ()</i> are two closures separating the same private state variable.  Thus, we can create objects with private state. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ state += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ state -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { increment, decrement } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = Counter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(counter.increment());<span class="hljs-comment"><span class="hljs-comment">//1 console.log(counter.decrement());//0</span></span></code> </pre> <br><h2>  Short circuit vs pure functions </h2><br><p>  <b>The closure uses variables from outer scope.</b> </p><br><p>  <b>Pure functions do not use variables from outer scope.</b>  Pure functions must return a value calculated using only the values ‚Äã‚Äãpassed to it, and there can be no side effects. </p><br><h2>  Asynchronous tasks: closure and cycles </h2><br><p>  In the following example, I will create five closures for five asynchronous tasks, all using the same variable <i>i</i> .  Since the variable <i>i</i> changes during the loop, all <i>console.log ()</i> display the same value ‚Äî the last. </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++){ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">//5 }, 100); } })();</span></span></code> </pre> <br><p>  One way to fix this problem is to use IIFE (Immediately Invoked Function Expression).  In the following example, there are five more closures, but more than five different variables <i>i</i> . </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>; i++){ (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">autorunInANewContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">i</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">//0 1 2 3 4 }, 100); })(i); } })();</span></span></code> </pre><br><p>  Another option is to use a new way of declaring variables: via <i>let</i> , available as part of ECMAScript 6. This will create a variable locally for the block scope at each iteration. </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>; i++){ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); <span class="hljs-comment"><span class="hljs-comment">//0 1 2 3 4 }, 100); } })();</span></span></code> </pre> <br><p>  I think this is the best option for this problem in terms of readability. </p><br><h2>  Closure and Garbage Collector </h2><br><p>  In JavaScript, local variables of a function will be destroyed after the function returns if there are no references to them.  The private state of the closure becomes suitable for garbage collection after the closure itself has been removed.  To make this possible, the closure should not have any more references to it. </p><br><p>  In the following example, I first create an <i>add ()</i> closure </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAddClosure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">)</span></span>{ arr.push(obj); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> add = createAddClosure();</code> </pre> <br><p>  Then I define two functions: one to add a large number of <i>addALotOfObjects ()</i> objects and another <i>clearAllObjects ()</i> to set the reference to <i>null</i> .  Then both functions are used as event handlers. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addALotOfObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">50000</span></span>;i++) { add({<span class="hljs-attr"><span class="hljs-attr">fname</span></span> : i, <span class="hljs-attr"><span class="hljs-attr">lname</span></span> : i}); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clearAllObjects</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(add){ add = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } $(<span class="hljs-string"><span class="hljs-string">"#add"</span></span>).click(addALotOfObjects); $(<span class="hljs-string"><span class="hljs-string">"#clear"</span></span>).click(clearAllObjects);</code> </pre> <br><p>  Clicking <i>"Add"</i> will add 50,000 items to the private state of the circuit. </p><br><img src="https://habrastorage.org/webt/9k/5p/a-/9k5pa-vkzkp_bcxk5you26ykvso.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  I clicked <i>‚ÄúAdd‚Äù</i> three times and then clicked <i>‚ÄúClear‚Äù</i> to set the link to <i>null</i> .  After that, the private state is cleared. </p><br><img src="https://habrastorage.org/webt/he/90/rh/he90rhntgwxpygw_gpcm3stthim.png"><br><h2>  Conclusion </h2><br><p>  Closure is the best tool in our encapsulation toolbox.  It also simplifies our work with calls for asynchronous tasks.  We just use the variables we want, and they will come to life by the time of the call. </p><br><p>  On the other hand, it is very helpful to understand how closures work to make sure that closures are removed when garbage is collected when we no longer need them. </p><br><blockquote>  <i>This is probably the best feature ever put into a programming language.</i> <i><br><br></i>  <i>Douglas Crockford on closure.</i> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/352882/">https://habr.com/ru/post/352882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352872/index.html">The art of winning or what is quantum pseudo telepathy</a></li>
<li><a href="../352874/index.html">Is there any powder in the old dog? Hackathon Radio Canada 2018 (Part two - combat readiness)</a></li>
<li><a href="../352876/index.html">Requiem for a Dream</a></li>
<li><a href="../352878/index.html">How I turned from a neophyte to a software developer in nine months without interrupting my main job</a></li>
<li><a href="../352880/index.html">Project Manager vs Product Manager: Who is heavier on his shoulders?</a></li>
<li><a href="../352884/index.html">The manager needs to be able to think, not program</a></li>
<li><a href="../352886/index.html">Unity (Unet) - integration with social networks and secure WebSockets</a></li>
<li><a href="../352888/index.html">RealWorld Project: Front End Framework Comparison</a></li>
<li><a href="../352890/index.html">"Unicorns" is small, but should be even less</a></li>
<li><a href="../352892/index.html">JPoint 2018 open java conference open</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>