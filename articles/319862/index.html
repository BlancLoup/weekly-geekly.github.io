<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bitcoin in a nutshell - Protocol</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Transactions are almost the most "main" object in the Bitcoin network, and in other blockchains too. So I decided that if I wrote a whole chapter abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bitcoin in a nutshell - Protocol</h1><div class="post__text post__text-html js-mediator-article"><p>  Transactions are almost the most "main" object in the Bitcoin network, and in other blockchains too.  So I decided that if I wrote a whole chapter about them, then I had to tell and show everything that was possible.  In particular, how they are built and work at the protocol level. </p><br><p>  Below I will explain how a transaction is formed, show how it is signed and demonstrate the mechanism of communication between nodes. </p><br><p><img src="https://cdn.meme.am/cache/instances/folder64/500x/63102064.jpg" alt="meme"></p><a name="habracut"></a><br><h2 id="book">  Book </h2><br><ul><li>  <a href="https://habrahabr.ru/post/319868/">Bitcoin in a nutshell - Cryptography</a> </li><li>  <a href="https://habrahabr.ru/post/319860/">Bitcoin in a nutshell - Transaction</a> </li><li>  Bitcoin in a nutshell - Protocol </li><li>  <a href="https://habrahabr.ru/post/320176/">Bitcoin in a nutshell - Blockchain</a> </li><li>  <a href="https://habrahabr.ru/post/320178/">Bitcoin in a nutshell - Mining</a> </li></ul><br><h3 id="table-of-content">  Table of content </h3><br><ol><li>  Keys and address </li><li>  Searching for nodes </li><li>  Version handshake </li><li>  Setting up a connection </li><li>  Making transaction </li><li>  Signing transaction </li><li>  Sniff &amp; spoof </li><li>  Sending transaction </li><li>  Links </li></ol><br><h3 id="keys-and-address">  Keys and address </h3><br><p>  First, create a new key pair and address.  How this is done, I told in the chapter <a href="https://habrahabr.ru/post/319868/">Bitcoin in a nutshell - Cryptography</a> , so here everything should be clear.  To speed up the process, let's take this <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D1%2583%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D0%25BD,_%25D0%2592%25D0%25B8%25D1%2582%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25BA">bitcoin toolkit</a> , written by <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D1%2583%25D1%2582%25D0%25B5%25D1%2580%25D0%25B8%25D0%25BD,_%25D0%2592%25D0%25B8%25D1%2582%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25BA">Vitalik Buterin himself</a> , although if you wish, you can use already written <a href="https://habrahabr.ru/post/319868/">code snippets</a> . </p><br><pre><code class="python hljs">$ git clone https://github.com/vbuterin/pybitcointools $ cd pybitcointools $ sudo python setup.py install $ python Python <span class="hljs-number"><span class="hljs-number">2.7</span></span><span class="hljs-number"><span class="hljs-number">.12</span></span> (default, Jul <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2016</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">12</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span>) [GCC <span class="hljs-number"><span class="hljs-number">5.4</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> <span class="hljs-number"><span class="hljs-number">20160609</span></span>] on linux2 Type <span class="hljs-string"><span class="hljs-string">"help"</span></span>, <span class="hljs-string"><span class="hljs-string">"copyright"</span></span>, <span class="hljs-string"><span class="hljs-string">"credits"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"license"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bitcoin <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * &gt;&gt;&gt; private_key = <span class="hljs-string"><span class="hljs-string">"28da5896199b85a7d49b0736597dd8c0d0c0293f130bf3e3e1d102e0041b1293"</span></span> &gt;&gt;&gt; public_key = privtopub(private_key) &gt;&gt;&gt; public_key <span class="hljs-string"><span class="hljs-string">'0497e922cac2c9065a0cac998c0735d9995ff42fb6641d29300e8c0071277eb5b4e770fcc086f322339bdefef4d5b51a23d88755969d28e965dacaaa5d0d2a0e09'</span></span> &gt;&gt;&gt; address = pubtoaddr(public_key) &gt;&gt;&gt; address <span class="hljs-string"><span class="hljs-string">'1LwPhYQi4BRBuuyWSGVeb6kPrTqpSVmoYz'</span></span></code> </pre> <br><p>  I <a href="https://blockchain.info/tx/60ee91bc1563e44866c66937b141e9ef4615a272fa9d764b9468c2a673c55e01">dropped</a> to the address <code>1LwPhYQi4BRBuuyWSGVeb6kPrTqpSVmoYz</code> 0.00012 BTC, so now you can experiment with the full program. </p><br><h3 id="searching-for-nodes">  Searching for nodes </h3><br><p>  Generally speaking, this is a good task to think about: <em>how to find other members of the network, while the network is decentralized?</em>  You can read more about this <a href="http://bitcoin.stackexchange.com/questions/3536/how-do-bitcoin-clients-find-each-other">here</a> , I will say in advance, there is no decentralized solution yet. </p><br><p>  I will show two ways.  The first is <em>DNS seeding</em> .  The bottom line is that there are some <em>trusted</em> addresses, such as: </p><br><ul><li>  bitseed.xf2.org </li><li>  dnsseed.bluematt.me </li><li>  seed.bitcoin.sipa.be </li><li>  dnsseed.bitcoin.dashjr.org </li><li>  seed.bitcoinstats.com </li></ul><br><p>  They are hardcovered in <a href="">chainparams.cpp</a> and the <code>nslookup</code> command can get node addresses from them. </p><br><pre> <code class="bash hljs">$ nslookup bitseed.xf2.org Non-authoritative answer: Name: bitseed.xf2.org Address: 76.111.96.126 Name: bitseed.xf2.org Address: 85.214.90.1 Name: bitseed.xf2.org Address: 94.226.111.26 Name: bitseed.xf2.org Address: 96.2.103.25 ...</code> </pre> <br><p>  The other method is not so clever and is not used in practice, but for educational purposes it is even better suited.  Go to <a href="https://shodan.io/">Shodan</a> , register, log in, and in the search bar, write <code>port:8333</code> .  This is the standard port for <code>bitcoind</code> , in my case there were about 9.000 nodes: </p><br><p><img src="https://habrastorage.org/files/fb7/90e/2b8/fb790e2b891341909733064c9a232456.png" alt="shodan"></p><br><h3 id="version-handshake">  Version handshake </h3><br><p>  Establishing a connection between nodes begins with the exchange of two messages.  The <a href="https://en.bitcoin.it/wiki/Protocol_documentation">version message is</a> sent first, and the <a href="https://en.bitcoin.it/wiki/Protocol_specification">verack message is</a> used as the response.  Here is an illustration of the <em>version handshake</em> process from the <a href="https://en.bitcoin.it/wiki/Version_Handshake">Bitcoin wiki</a> : </p><br><blockquote>  If you are on a remote peer, you will receive a message. <br><ul><li>  <strong>L -&gt; R</strong> Send version message with the local peer's version </li><li>  <strong>R -&gt; L</strong> Send version message back </li><li>  <strong>R</strong> Sets version to the minimum of the 2 versions </li><li>  <strong>R -&gt; L</strong> Send verack message </li><li>  <strong>L</strong> Sets version to the minimum of the 2 versions </li></ul><br></blockquote><p>  This is done primarily to ensure that nodes know which version of the protocol their ‚Äúinterlocutor‚Äù uses and can communicate in the same language. </p><br><h3 id="setting-up-a-connection">  Setting up a connection </h3><br><p><img src="https://qph.ec.quoracdn.net/main-qimg-a935c19e12363041547f4c402b9c80af-c?convert_to_webp=true"></p><br><p>  Each message on the network <a href="https://en.bitcoin.it/wiki/Protocol_documentation">should be represented</a> as <code>magic + command + lenght + checksum + payload</code> , the <code>makeMessage</code> function is responsible for this.  We still will use this function when we send transaction. </p><br><p>  The code will constantly use the <a href="https://docs.python.org/2/library/struct.html">struct</a> library.  It is responsible for presenting the parameters in the correct format.  For example, <code>struct.pack("q", timestamp)</code> writes the current UNIX time to a <code>long long int</code> , as required by the protocol. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cmd, payload)</span></span></span><span class="hljs-function">:</span></span> magic = <span class="hljs-string"><span class="hljs-string">"F9BEB4D9"</span></span>.decode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Main network ID command = cmd + (12 - len(cmd)) * "\00" length = struct.pack("I", len(payload)) check = hashlib.sha256(hashlib.sha256(payload).digest()).digest()[:4] return magic + command + length + check + payload def versionMessage(): version = struct.pack("i", 60002) services = struct.pack("Q", 0) timestamp = struct.pack("q", time.time()) addr_recv = struct.pack("Q", 0) addr_recv += struct.pack("&gt;16s", "127.0.0.1") addr_recv += struct.pack("&gt;H", 8333) addr_from = struct.pack("Q", 0) addr_from += struct.pack("&gt;16s", "127.0.0.1") addr_from += struct.pack("&gt;H", 8333) nonce = struct.pack("Q", random.getrandbits(64)) user_agent = struct.pack("B", 0) # Anything height = struct.pack("i", 0) # Block number, doesn't matter payload = version + services + timestamp + addr_recv + addr_from + nonce + user_agent + height return payload if __name__ == "__main__": sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect(("93.170.187.9", 8333)) sock.send(makeMessage("version", versionMessage())) sock.recv(1024) # receive version message sock.recv(1024) # receive verack message</span></span></code> </pre> <br><p>  Now open Wireshark, set a <code>bitcoin</code> filter or <code>tcp.port == 8333</code> and look at the resulting packets.  If everything is done correctly, then, first of all, the protocol, <em>user-agent</em> , <em>block start height</em> and so on will be correctly defined.  Secondly, as promised, you will <em>receive a</em> response in the form of <em>version</em> and <em>verack messages</em> .  Now that the connection is established, you can begin work. </p><br><p><img src="https://habrastorage.org/files/8a6/476/c95/8a6476c9570b4164bc547e094ddce279.jpg" alt="wireshark"></p><br><h3 id="making-transaction">  Making transaction </h3><br><p>  Before creating a transaction, open the <a href="https://en.bitcoin.it/wiki/Protocol_specification">specification</a> again and follow it closely.  Deviation by 1 byte already makes the transaction invalid, so you need to be extremely careful. </p><br><p>  To begin with, let's set addresses, private key and <a href="https://blockchain.info/tx/60ee91bc1563e44866c66937b141e9ef4615a272fa9d764b9468c2a673c55e01">transaction</a> hash, to which we will refer: </p><br><pre> <code class="python hljs">previous_output = <span class="hljs-string"><span class="hljs-string">"60ee91bc1563e44866c66937b141e9ef4615a272fa9d764b9468c2a673c55e01"</span></span> receiver_address = <span class="hljs-string"><span class="hljs-string">"1C29gpF5MkEPrECiGtkVXwWdAmNiQ4PBMH"</span></span> my_address = <span class="hljs-string"><span class="hljs-string">"1LwPhYQi4BRBuuyWSGVeb6kPrTqpSVmoYz"</span></span> private_key = <span class="hljs-string"><span class="hljs-string">"28da5896199b85a7d49b0736597dd8c0d0c0293f130bf3e3e1d102e0041b1293"</span></span></code> </pre> <br><p>  Next, create a transaction in <em>raw</em> form, that is, unsigned so far.  To do this, simply follow the specifications: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">txnMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(previous_output, receiver_address, my_address, private_key)</span></span></span><span class="hljs-function">:</span></span> receiver_hashed_pubkey= base58.b58decode_check(receiver_address)[<span class="hljs-number"><span class="hljs-number">1</span></span>:].encode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>) my_hashed_pubkey = base58.b58decode_check(my_address)[<span class="hljs-number"><span class="hljs-number">1</span></span>:].encode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Transaction stuff version = struct.pack("&lt;L", 1) lock_time = struct.pack("&lt;L", 0) hash_code = struct.pack("&lt;L", 1) # Transactions input tx_in_count = struct.pack("&lt;B", 1) tx_in = {} tx_in["outpoint_hash"] = previous_output.decode('hex')[::-1] tx_in["outpoint_index"] = struct.pack("&lt;L", 0) tx_in["script"] = ("76a914%s88ac" % my_hashed_pubkey).decode("hex") tx_in["script_bytes"] = struct.pack("&lt;B", (len(tx_in["script"]))) tx_in["sequence"] = "ffffffff".decode("hex") # Transaction output tx_out_count = struct.pack("&lt;B", 1) tx_out = {} tx_out["value"]= struct.pack("&lt;Q", 1000) # Send 1000 satoshis tx_out["pk_script"]= ("76a914%s88ac" % receiver_hashed_pubkey).decode("hex") tx_out["pk_script_bytes"]= struct.pack("&lt;B", (len(tx_out["pk_script"]))) tx_to_sign = (version + tx_in_count + tx_in["outpoint_hash"] + tx_in["outpoint_index"] + tx_in["script_bytes"] + tx_in["script"] + tx_in["sequence"] + tx_out_count + tx_out["value"] + tx_out["pk_script_bytes"] + tx_out["pk_script"] + lock_time + hash_code)</span></span></code> </pre> <br><p>  Note that in the <code>tx_in["script"]</code> field it is not written as <code>&lt;Sig&gt; &lt;PubKey&gt;</code> , as you probably expected.  Instead, a <strong>blocking exit script</strong> is specified <strong>, which we refer to</strong> , in our case it is <code>OP_DUP OP_HASH160 dab3cccc50d7ff2d1d2926ec85ca186e61aef105 OP_EQUALVERIFY OP_CHECKSIG</code> . </p><br><p>  <strong>BTW,</strong> there is no difference between the usual <code>OP_DUP OP_HASH160 dab3cccc50d7ff2d1d2926ec85ca186e61aef105 OP_EQUALVERIFY OP_CHECKSIG</code> </p><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0</span></span>x76 = OP_DUP <span class="hljs-number"><span class="hljs-number">0</span></span>xa9 = OP_HASH160 <span class="hljs-number"><span class="hljs-number">0</span></span>x14 = <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">14</span></span>   dab3cccc50d7ff2d1d2926ec85ca186e61aef105s88ac ...</code> </pre> <br><h3 id="signing-transaction">  Signing transaction </h3><br><p>  Now it's time to sign the transaction, everything is pretty simple here: </p><br><pre> <code class="python hljs">hashed_raw_tx = hashlib.sha256(hashlib.sha256(tx_to_sign).digest()).digest() sk = ecdsa.SigningKey.from_string(private_key.decode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>), curve = ecdsa.SECP256k1) vk = sk.verifying_key public_key = (<span class="hljs-string"><span class="hljs-string">'\04'</span></span> + vk.to_string()).encode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>) sign = sk.sign_digest(hashed_raw_tx, sigencode=ecdsa.util.sigencode_der)</code> </pre> <br><p>  After the <em>raw transaction</em> signature is obtained, you can replace the unlocking script with the real one and bring the transaction to its final form: </p><br><pre> <code class="python hljs">sigscript = sign + <span class="hljs-string"><span class="hljs-string">"\01"</span></span> + struct.pack(<span class="hljs-string"><span class="hljs-string">"&lt;B"</span></span>, len(public_key.decode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>))) + public_key.decode(<span class="hljs-string"><span class="hljs-string">"hex"</span></span>) real_tx = (version + tx_in_count + tx_in[<span class="hljs-string"><span class="hljs-string">"outpoint_hash"</span></span>] + tx_in[<span class="hljs-string"><span class="hljs-string">"outpoint_index"</span></span>] + struct.pack(<span class="hljs-string"><span class="hljs-string">"&lt;B"</span></span>, (len(sigscript) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) + struct.pack(<span class="hljs-string"><span class="hljs-string">"&lt;B"</span></span>, len(sign) + <span class="hljs-number"><span class="hljs-number">1</span></span>) + sigscript + tx_in[<span class="hljs-string"><span class="hljs-string">"sequence"</span></span>] + tx_out_count + tx_out[<span class="hljs-string"><span class="hljs-string">"value"</span></span>] + tx_out[<span class="hljs-string"><span class="hljs-string">"pk_script_bytes"</span></span>] + tx_out[<span class="hljs-string"><span class="hljs-string">"pk_script"</span></span>] + lock_time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> real_tx</code> </pre> <br><h3 id="sniff--spoof">  Sniff &amp; spoof </h3><br><p>  Here we need to clarify one detail.  I think you understand why we generally sign transactions.  This is done so that no one can change our message and send it further through the network, because the message signature will change, and so on. </p><br><p>  But if you carefully read, remember that we are signing a false transaction, which will eventually be sent to other nodes, and its modification, where the unlocking script indicates the locking script from the output that we refer to.  In principle, it is clear why this happens: this signature must be written into a real unlocking script, and a vicious circle is obtained: a correct unlocking script is needed for a correct signature, a correct signature is needed for a correct unlocking script.  So Satoshi compromised and allowed the use of not quite ‚Äúreal‚Äù signatures. </p><br><p>  Therefore, it may happen that someone on the network catches our message, changes the unlocking script and sends the edited message further.  None of the nodes will be able to verify this, because the signature does not "protect" the unlocking script.  This vulnerability is called <strong>Transaction malleability</strong> , you can read more about it <a href="https://en.bitcoin.it/wiki/Transaction_Malleability">here</a> or watch the report from Black Hat USA 2014 - <a href="https://www.youtube.com/channel/UCbbgnifxfH-nqx6z9XQ963Q">Bitcoin Transaction Malleability Theory in Practice</a> . </p><br><p>  <strong>TL; DR</strong> If you use standard scripts like P2PKH, then nothing threatens you.  Otherwise it is worth being careful. </p><br><h3 id="sending-transaction">  Sending transaction </h3><br><p>  Sending a transaction to the network is done in the same way as in the case of the <em>version message</em> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((<span class="hljs-string"><span class="hljs-string">"70.68.73.137"</span></span>, <span class="hljs-number"><span class="hljs-number">8333</span></span>)) sock.send(makeMessage(<span class="hljs-string"><span class="hljs-string">"version"</span></span>, versionMessage())) sock.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-comment"><span class="hljs-comment"># version sock.recv(1024) # verack # Transaction options previous_output = "60ee91bc1563e44866c66937b141e9ef4615a272fa9d764b9468c2a673c55e01" receiver_address = "1C29gpF5MkEPrECiGtkVXwWdAmNiQ4PBMH" my_address = "1LwPhYQi4BRBuuyWSGVeb6kPrTqpSVmoYz" private_key = "28da5896199b85a7d49b0736597dd8c0d0c0293f130bf3e3e1d102e0041b1293" txn = txnMessage(previous_output, receiver_address, my_address, private_key) print "Signed txn:", txn sock.send(makeMessage("tx", txn)) sock.recv(1024)</span></span></code> </pre> <br><p>  Run the resulting code and run to look at the packages.  If everything is done correctly, then an <a href="https://en.bitcoin.it/wiki/Protocol_documentation">inv message</a> will come to your <a href="https://en.bitcoin.it/wiki/Protocol_documentation">message</a> (otherwise there would be a <a href="https://en.bitcoin.it/wiki/Protocol_documentation">reject message</a> ).  An interesting fact is that every node, when it receives a fresh transaction, checks it for validity (the process is described in <a href="https://habrahabr.ru/post/320178/">Bitcoin in a nutshell - Mining</a> ), so if you make a mistake somewhere, then you will be instantly notified about this: </p><br><p><img src="https://habrastorage.org/files/47b/d8b/84c/47bd8b84c38c46a2bdd0d173b1334d67.png" alt="success"></p><br><p>  Within a few seconds after the transaction is sent to the network, it will be possible to <a href="https://blockchain.info/ru/address/1LwPhYQi4BRBuuyWSGVeb6kPrTqpSVmoYz">track it</a> , though at first it will be listed as unconfirmed.  Then, after some time (up to several hours), the transaction will be included in the block. </p><br><p>  If by that time you do not close Wireshark plus, in the <em>version</em> message you will indicate the current height of the blockchain, then you will receive a notification about the new block in the form of the same <em>inv message</em> , but this time with <code>TYPE = MSG_BLOCK</code> (I closed it, so the screenshot below is from the blog <a href="http://www.righto.com/">Ken Shirriff</a> ): </p><br><p><img src="http://static.righto.com/images/bitcoin/bitcoin_wireshark_inv.png" alt="msg_block"></p><br><p>  In <code>Data hash</code> you can see a long line, which is actually the title of a new block in <em>little endian</em> form.  In this case, this is block <a href="https://blockchain.info/ru/block-height/279068"># 279068</a> with the title <em>0000000000000001a27b1d6eb8c405410398ece796e742da3b3e35363c2219ee</em> .  A bunch of leading zeros is not an accident, but the result of mining, which I will discuss separately. </p><br><p>  But before that you need to deal with the blockchain itself, the blocks, their titles, and so on.  Therefore the next chapter: <a href="https://habrahabr.ru/post/320176/">Bitcoin in a nutshell - Blockchain</a> </p><br><h3 id="links">  Links </h3><br><ul><li>  <a href="http://www.righto.com/2014/02/bitcoins-hard-way-using-raw-bitcoin.html">Bitcoins the hard way: Using the raw Bitcoin protocol</a> </li><li>  <a href="https://www.samkear.com/networking/analyzing-bitcoin-network-traffic-wireshark">Analyzing Bitcoin Network Traffic Using Wireshark</a> </li><li>  <a href="http://www.michaelnielsen.org/ddi/how-the-bitcoin-protocol-actually-works/">How the bitcoin protocol actually works</a> </li><li>  <a href="https://www.quora.com/Bitcoin-How-does-a-Bitcoin-node-find-its-peers">How does a bitcoin node find its peers?</a> </li><li>  <a href="https://bitcoin.org/en/developer-reference">Bitcoin Developer Reference.</a>  <a href="https://bitcoin.org/en/developer-reference">P2P network</a> </li><li>  <a href="http://bitcoin.stackexchange.com/questions/32628/redeeming-a-raw-transaction-step-by-step-example-required">Redeeming a raw transaction step by step</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/319862/">https://habr.com/ru/post/319862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319852/index.html">Java examples from books and documentation</a></li>
<li><a href="../319854/index.html">"I learned something - try to explain it until you understand it yourself"</a></li>
<li><a href="../319856/index.html">Trucks and refrigerators in the cloud</a></li>
<li><a href="../319858/index.html">dock: a simple library of unit testing C ++ code</a></li>
<li><a href="../319860/index.html">Bitcoin in a nutshell - Transaction</a></li>
<li><a href="../319864/index.html">One of the easiest ways to improve your programming skills is to read someone else's code.</a></li>
<li><a href="../319866/index.html">Interesting in March: DevOpsDays in Moscow</a></li>
<li><a href="../319868/index.html">Bitcoin in a nutshell - Cryptography</a></li>
<li><a href="../319872/index.html">Bored Powershell</a></li>
<li><a href="../319876/index.html">Python: collections, part 3/4: combining collections, adding and removing items</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>