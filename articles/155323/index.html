<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write the Gameboy emulator, part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 In the previous part of this series of articles, we looked at the DMG processor and memory. The next logical step is to emulate how the DMG ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write the Gameboy emulator, part 2</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  In the previous part of this series of articles, we looked at the DMG processor and memory.  The next logical step is to emulate how the DMG displays the image. <br><br>  <a href="http://habrahabr.ru/post/154901/">We write the Gameboy emulator, part 1</a> <br>  We write the Gameboy emulator, part 2 <br>  <a href="http://habrahabr.ru/post/156647/">We write the Gameboy emulator, part 3</a> <br><a name="habracut"></a><br><h4>  Table of contents </h4>  <a href="https://habr.com/ru/post/155323/">Display</a> <br><ul><li>  <a href="https://habr.com/ru/post/155323/">LCD controller.</a>  <a href="https://habr.com/ru/post/155323/">Theory</a> </li><li>  <a href="https://habr.com/ru/post/155323/">LCD controller.</a>  <a href="https://habr.com/ru/post/155323/">Implementation</a> </li><li>  <a href="https://habr.com/ru/post/155323/">Graphics.</a>  <a href="https://habr.com/ru/post/155323/">Theory</a> <br><ul><li>  <a href="https://habr.com/ru/post/155323/">Background</a> </li><li>  <a href="https://habr.com/ru/post/155323/">Window</a> </li><li>  <a href="https://habr.com/ru/post/155323/">Sprites</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/155323/">Graphics.</a>  <a href="https://habr.com/ru/post/155323/">Implementation</a> </li></ul>  <a href="https://habr.com/ru/post/155323/">Timers</a> <br>  <a href="https://habr.com/ru/post/155323/">Control</a> <br>  <a href="https://habr.com/ru/post/155323/">Putting it all together</a> <br>  <a href="https://habr.com/ru/post/155323/">Testing</a> <br>  <a href="https://habr.com/ru/post/155323/">Conclusion</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="LCD"></a><h4>  Display </h4>  At this stage, we need to emulate how the DMG displays the image on the screen.  Everything will be in the class Cookieboy :: GPU ( <a href="https://github.com/creker/Cookieboy">link</a> to the source code Cookieboy).  The task can be divided into two large parts - emulation of the specifics of how the DMG draws a picture;  emulation of logic that controls the screen. <br><br><a name="LCDC_theory"></a><h5>  LCD controller.  Theory </h5>  Let's start with logic, because it is she who will dictate when and what to draw.  As always, before implementation we need to understand how the component works. <br><br>  DMG displays the image on the screen line by line and emulates the states characteristic of CRT screens.  Each state lasts a strictly defined number of cycles.  It is necessary to provide access to the memory.  To draw graphics, access to video memory and OAM is needed in two places at once - the LCD controller, which displays everything on the screen;  game (CPU), which modifies the memory to display the frame that she needs.  To solve this problem, the entire graphics output task was divided into intervals (each corresponds to a certain state), which determine the time during which the logic of the screen or the game can access the memory.  There are four states in total (the numbers are not random, but strictly defined for the DMG): <br><ul><li>  0. H-blank.  For CRT screens, it means that at this moment the scanning beam goes to the beginning of the next line.  In DMG, of course, there are no rays.  This state means two things.  First, one line was output.  Secondly, the video memory and OAM are not used by the LCD controller and are accessible by the CPU. </li><li>  1. V-blank.  Another state from the world of CRT, which means the moment when the beam reached the end of the last line and goes to the beginning of the first line.  For us, it means two things.  First, all 144 visible lines were displayed.  Secondly, the video memory and OAM are not used by the LCD controller and are accessible by the CPU. </li><li>  2. OAM.  This status means that the LCD controller uses OAM memory.  CPU is not available, but video memory is still available. </li><li>  3. OAMRAM.  This status means that the LCD controller uses OAM and video memory.  CPU they are not available. </li></ul><br>  When each line is drawn, the LCD controller goes through the states in this order - 2, 3, 0. After the last line is drawn, it goes to state 1. Then everything starts anew from the first line. <br><br>  Drawing one line lasts exactly 456 cycles.  This time is made up of the duration of states 2, 3, 0 and is always equal to 456 cycles, but the duration of the states themselves may vary.  Since the screen has 144 lines, their output takes 65,664 cycles.  Another 4560 cycles exactly lasts state 1. From the figure it is clear that this time is equal to 10 lines.  This is true - in state 1, there are, as it were, drawing 10 more lines.  The line counter (LY register) does not stop at 143, but reaches 153. As a result, a full screen update takes 70,224 cycles or 154 lines of 456 cycles. <br><br>  The transition between states is accompanied by interrupt requests, if enabled.  The transition to each of the four states, except the third, is accompanied by a request to interrupt the LCDC.  In addition, this interrupt is requested if LY and LYC are equal.  The request is carried out only if the LCDC interrupt for this state is enabled in the STAT register.  Its structure is as follows: <br><table><tbody><tr><td>  Bits </td><td>  Purpose </td></tr><tr><td>  6 </td><td>  Allow LCDC interrupt in case of equality of registers LY and LYC </td></tr><tr><td>  five </td><td>  Allow LCDC interrupt on going to state 2 </td></tr><tr><td>  four </td><td>  Allow LCDC interrupt on going to state 1 </td></tr><tr><td>  3 </td><td>  Allow LCDC interrupt on going to state 0 </td></tr><tr><td>  2 </td><td>  A bit is set if LY and LYC are equal.  Reset otherwise </td></tr><tr><td>  0-1 </td><td>  Current state </td></tr></tbody></table><br>  An important detail - the LCDC interrupt can only be requested once per line. <br><br>  A lot of this could be learned from the CPU Manual, but there is one thing here - not all you need to know about the operation of the LCD controller for its emulation.  I did not go into all the details (in fact, I did not find them), but only stopped at what allows you to correctly display the graphics in the games I tested, and at the same time pass the test of the LCD controller. <br><br>  In order to at least approximately emulate the controller, we will have to enter another set of states ‚Äî internal, accessible only to our emulator.  There are 8 of them: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> InternalLCDModes { LCDMODE_LY00_HBLANK, LCDMODE_LYXX_HBLANK, LCDMODE_LYXX_HBLANK_INC, LCDMODE_LY00_VBLANK, LCDMODE_LY9X_VBLANK, LCDMODE_LY9X_VBLANK_INC, LCDMODE_LYXX_OAM, LCDMODE_LYXX_OAMRAM };</code> </pre> <br>  From the names it is clear that they correspond to real states.  They pass in the following order: <br><table><tbody><tr><td>  Line </td><td>  States </td></tr><tr><td>  0 </td><td>  LYXX_OAM -&gt; LYXX_OAMRAM -&gt; LYXX_HBLANK -&gt; LYXX_HBLANK_INC </td></tr><tr><td>  one </td><td>  LYXX_OAM -&gt; LYXX_OAMRAM -&gt; LYXX_HBLANK -&gt; LYXX_HBLANK_INC </td></tr><tr><td>  ... </td><td>  ... </td></tr><tr><td>  143 </td><td>  LYXX_OAM -&gt; LYXX_OAMRAM -&gt; LYXX_HBLANK -&gt; LYXX_HBLANK_INC </td></tr><tr><td>  144 </td><td>  LY9X_VBLANK -&gt; LY9X_VBLANK_INC </td></tr><tr><td>  ... </td><td>  ... </td></tr><tr><td>  152 </td><td>  LY9X_VBLANK -&gt; LY9X_VBLANK_INC </td></tr><tr><td>  153 </td><td>  LY00_VBLANK -&gt; LY00_HBLANK </td></tr></tbody></table><br>  Intermediate states are needed for more accurate synchronization of various events.  Consider each state in more detail. <br><br>  <strong>LCDMODE_LYXX_OAM</strong> .  When we switch to this state, we change the state in the STAT register to 2 (OAM read).  Check if LCDC interrupt is enabled.  If successful, we request it and mark somewhere that the LCDC interrupt can no longer be requested. <br><br>  In this state, we take into account one feature of the DMG.  If the SCX register is set to bit 2 (for example, the register is 4), then right now we need to note somewhere that the following states should change their duration to 4 clock cycles.  This condition lasts exactly 80 cycles. <br><br>  <strong>LCDMODE_LYXX_OAMRAM</strong> .  Change the STAT state to 3. LCDC no interrupt.  So far we have not dealt with the topic of sprites, but this is where the function call will be, which is the queue of sprites that will be later displayed on this line. <br><br>  This is another DMG feature.  Spriting output changes the duration of the states.  The more of them, the longer the state 3 lasts and the shorter the state 0 (we need to keep within 456 cycles, so everything is proportional).  DMG can display a maximum of 10 sprites in one line, so we have enough of an array of 11 elements with values ‚Äã‚Äãthat indicate a change in the duration of the states.  It should contain the following values: <br><table><tbody><tr><td>  Number of sprites </td><td>  0 </td><td>  one </td><td>  2 </td><td>  3 </td><td>  four </td><td>  five </td><td>  6 </td><td>  7 </td><td>  eight </td><td>  9 </td><td>  ten </td></tr><tr><td>  So you </td><td>  0 </td><td>  eight </td><td>  20 </td><td>  32 </td><td>  44 </td><td>  52 </td><td>  64 </td><td>  76 </td><td>  88 </td><td>  96 </td><td>  108 </td></tr></tbody></table><br>  This state lasts 172 cycles + number of cycles due to the SCX register + number of cycles due to sprites.  For example, if the SCX register in the previous state was equal to 4, and the sprites are displayed 6, then the duration of the state will be equal to 172 + 4 + 64 cycles. <br><br>  <strong>LCDMODE_LYXX_HBLANK</strong> .  Here we draw the current line, which can be learned from the LY register.  We note the state 0 in the STAT register. We request the LCDC interrupt if it has not yet been requested. <br><br>  The length of the clock is calculated as follows: 200 clocks - clocks due to SCX - clocks due to sprites.  Thus, here we compensate for the shift in duration that occurred in the LCDMODE_LYXX_OAMRAM state. <br><br>  <strong>LCDMODE_LYXX_HBLANK_INC</strong> .  Here we increase the register LY by one - it is a row counter.  Reset the flag, which indicates that the LCDC interrupt has already been requested (we are moving to the next line).  Here we need to check for equality registers LY and LYC.  Here is the approximate pseudocode: <br><pre> <code class="hljs 1c"><span class="hljs-keyword"><span class="hljs-keyword"></span></span> LY == LYC <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-number"><span class="hljs-number">2</span></span>   STAT    <span class="hljs-number"><span class="hljs-number">2</span></span>   STAT  LCDC , <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>   STAT</code> </pre><br><br>  The LYC register is used by games to track when LY reaches a certain value.  He has no other appointments. <br><br>  This state lasts 4 bars.  Which state the transition will take is dependent on the value of LY.  Everything is indicated in the table above. <br><br>  <strong>LY9X_VBLANK</strong> .  If we have passed to this state and LY is equal to 144, then we need to somehow cancel, that we have passed into the V-blank state.  Set the state in STAT 1. We request an interrupt V-blank.  Here you must again request the LCDC interrupt, if allowed.  Thus, two interrupts may be requested here.  If LY is not equal to 144, then nothing needs to be done, because  we are already in V-blank. <br><br>  This state lasts exactly 452 cycles. <br><br>  <strong>LY9X_VBLANK_INC</strong> .  Here we need to increment LY and check for equality of LY and LYC, as we did before.  Here we must take into account that with LY equal to 153, we move to another state, and do not start anew with LY9X_VBLANK - see the table. <br><br>  This state lasts 4 cycles. <br><br>  <strong>LY00_VBLANK</strong> .  Here we need to reset LY. <br><br>  This state lasts 452 cycles. <br><br>  <strong>LCDMODE_LY00_HBLANK</strong> .  This is the last in the frame and rather strange condition.  It lasts only 4 cycles and sets the STAT state to state 0. After it, everything starts anew. <br><br>  Everything, with a cycle of states is over.  Now a small, but very important detail.  If you read the description of the register LCDC, then you might notice that bit 7 is responsible for on / off display.  We need to somehow reflect this in our states. <br><br>  If the game has turned off the display, then we need to reset the LY register, and set the state to STAT in the STAT register. If the game has turned on the display (a prerequisite - before that it had to be turned off), then we need to return the controller to its very initial state - all clock counters set to zero, LY is zero, state 2 is current.  we start the whole cycle of states from the very beginning.  Many games refuse to work without these manipulations.  An example of such a game is Bomb Jack.  She refuses to reach even the initial menu. <br><br>  I do not accidentally give examples of games.  Test ROMs are good, but passing them does not guarantee the correct operation of games, and not all of them check.  Where possible, I will give the name of the games that are recommended to check on my emulator.  Bomb Jack is a must-check - many games do such tricks with turning off the screen. <br><br><a name="LCDC_impl"></a><h5>  LCD controller.  Implementation </h5>  Finally, we can proceed to the implementation of the considered theory.  As I said, in our emulator we need to synchronize all the other components with the processor - the LCD controller is not an exception.  To do this, we will create a function in the class Cookieboy :: GPU, which takes as input the number of cycles that have passed.  Here we will implement everything related to the change of states. <br><br>  In all components, the synchronization will look roughly the same.  We get the clock counter, to which we will add the last bars.  As soon as the value has reached the necessary, we subtract this number from it (we do not reset it, because more cycles could take place than we need) and we do what is needed. <br><br>  This is what our synchronization function in Cookieboy :: GPU will look like: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Cookieboy::GPU::Step(DWORD clockDelta, Interrupts &amp;INT) { ClockCounter += clockDelta; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ClockCounter &gt;= ClocksToNextState) { ClockCounter -= ClocksToNextState; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LCD_ON()) { LY = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ClocksToNextState = 70224; continue; } switch (LCDMode) { case LCDMODE_LY00_VBLANK: LY = 0; LCDMode = LCDMODE_LY00_HBLANK; ClocksToNextState = 452; break; } } }</span></span></code> </pre><br>  Naturally this is only a part, but it is enough.  And so, ClockCounter serves as a counter.  Next we have a while construct that checks whether the counter has reached the desired value.  The variable ClocksToNextState is used to store the number of ticks that must pass before the onset of the new state.  We subtract them from the counter so that it continues to count to the next state. <br><br>  Why here while?  It is important.  Some states last only 4 bars and it is quite possible that this state can occur immediately.  Those.  we set ClocksToNextState equal to 4, and in our counter there are already 4 clocks.  In order not to wait for an extra call to the synchronization function, we will process the new event right there, at the next iteration of the cycle.  This approach should be taken as a rule where the intervals between states (events) are too small and may be less than the duration of a single processor instruction. <br><br>  Next we see the condition with the macro LCD_ON ().  Here we check if the display is turned off.  If so, then we do not go through the entire cycle of states.  We are only clearing the screen and are waiting for 70224 bars for the one full screen update. <br><br>  If the display is turned on, then using the switch construction, we perform the necessary actions for the current state.  The specificity of my implementation is that we store in the LCDMode not so much the current, as the next state.  After completing the necessary actions, we set the following state in LCDMode and show how many clock cycles it should go through.  Yes, LCDMode is only an auxiliary variable, it does not exist for games.  Real states are stored in the STAT register, where they should. <br><br><a name="Render_theory"></a><h5>  Graphics.  Theory </h5>  DMG does not handle pixels, but tiles.  Naturally, the graphics are displayed pixel by pixel, but the unit for the programmer is exactly the tile, the size of which is 8x8 pixels.  Thus, it is not the pixel colors that are stored in the memory, but tile numbers.  These numbers refer to another area of ‚Äã‚Äãmemory where information about tiles is located - what color pixels do they consist of.  The obvious goal of this approach is to save memory.  It looks like the implementation of indexed colors. <br><br>  The graphics output is carried out in three stages in the following order: <br><ol><li>  Background </li><li>  The so-called "window" (window) </li><li>  Sprites </li></ol><br><a name="Background"></a><h6>  Background </h6>  The background of a DMG is 32x32 tiles or 256x256 pixels, which is obviously larger than the DMG screen.  Using the SCX and SCY registers, we can specify which part to display, as shown in the figure below. <br><img src="https://habrastorage.org/storage2/319/c03/3fb/319c033fb2fe1674d23fa72e81289af7.png"><br>  As you can see, if we go beyond the boundaries of the background, then we find ourselves at its opposite end.  Background zaylen, as they often say. <br><br>  All information about the tiles and their content is in the video memory.  Here is its structure: <br><table><tbody><tr><td>  Section </td><td>  Purpose </td></tr><tr><td>  0x8000-0x87FF </td><td>  A set of tiles number 1: tiles [0, 127] </td></tr><tr><td>  0x8800-0x8FFF </td><td>  A set of tiles number 1: tiles [128, 255] <br>  A set of tiles number 0: tiles [-128, -1] </td></tr><tr><td>  0x9000-0x97FF </td><td>  A set of tiles number 0: tiles [0, 127] </td></tr><tr><td>  0x9800-0x9BFF </td><td>  Tile map number 0 </td></tr><tr><td>  0x9C00-0x9FFF </td><td>  Tile map number 1 </td></tr></tbody></table><br>  Tiles are stored first.  DMG can store up to 384 tiles divided into two sets of 256 tiles each, so that half of them are common.  One set uses numbers from 0 to 255 to designate tiles. The numbers from -128 to 127 use the other. The background itself is drawn according to the selected tile map.  They are also two.  They are 1024 bytes in size - one byte per tile number. <br><br>  Selecting a set of tiles and tile maps is carried out using the register LCDC.  There is also a flag on / off displaying the background.  Here, by the way, its structure: <br><table><tbody><tr><td>  Bits </td><td>  Purpose </td></tr><tr><td>  7 </td><td>  LCD controller control: <br>  0: off (screen is blank) <br>  1: on </td></tr><tr><td>  6 </td><td>  Select a tile map for the "window": <br>  0: Tile map number 0 (0x9800-0x9BFF) <br>  1: Tile map number 1 (0x9C00-0x9FFF) </td></tr><tr><td>  five </td><td>  Flag display "window": <br>  0: off <br>  1: on </td></tr><tr><td>  four </td><td>  Select a set of tiles for the background and "window": <br>  0: Tile Set No. 0 (0x8800-0x97FF) <br>  1: Number 1 tile set (0x8000-0x8FFF) </td></tr><tr><td>  3 </td><td>  Selecting a tile map for the background: <br>  0: Tile map number 0 (0x9800-0x9BFF) <br>  1: Tile map number 1 (0x9C00-0x9FFF) </td></tr><tr><td>  2 </td><td>  Sprites size: <br>  0: 8x8 <br>  1: 8:16 </td></tr><tr><td>  one </td><td>  Flag display sprites: <br>  0: off <br>  1: on </td></tr><tr><td>  0 </td><td>  Background display flag: <br>  0: off <br>  1: on </td></tr></tbody></table><br>  Tiles themselves occupy 16 bytes in memory.  Every 2 bytes are responsible for one line, thus giving us 8x8 tiles.  The organization of tiles in memory is rather strange, as shown below: <br><img src="https://habrastorage.org/storage2/a99/53c/8fe/a9953c8fecb3451f3b591b407addd184.png"><br>  The color of a pixel is composed of two bits, where the low bit is taken from the first byte, and the high bit from the second.  As a result, color indices are obtained, which can have 4 values: from 0 to 3. These indices are used to select a color from the palette in the BGP register.  Here is its structure: <br><table><tbody><tr><td>  Bits </td><td>  Color index </td></tr><tr><td>  7-6 </td><td>  3 </td></tr><tr><td>  5-4 </td><td>  2 </td></tr><tr><td>  3-2 </td><td>  one </td></tr><tr><td>  1-0 </td><td>  0 </td></tr></tbody></table><br>  That is, having a pixel color equal to 2, we look at the BGP register value of bits 5-4, which give us a color that can also have 4 values ‚Äã‚Äãfrom 0 to 3. This leads us to the need to have another palette to translate colors from the DMG palette to real RGB colors for later output.  This applies to the entire graph as a whole. <br><br>  You can use a black and white palette, which gives us the following colors: <br><table><tbody><tr><td>  Color in the palette </td><td>  RGB channel value </td></tr><tr><td>  0 </td><td>  0xFF, 0xFF, 0xFF </td></tr><tr><td>  one </td><td>  0xAA, 0xAA, 0xAA </td></tr><tr><td>  2 </td><td>  0x55, 0x55, 0x55 </td></tr><tr><td>  3 </td><td>  0x00, 0x00, 0x00 </td></tr></tbody></table><br>  Or use colors that are closer to those on the screen of this DMG: <br><table><tbody><tr><td>  Color in the palette </td><td>  RGB channel value </td></tr><tr><td>  0 </td><td>  0xE1, 0xF7, 0xD1 </td></tr><tr><td>  one </td><td>  0x87, 0xC3, 0x72 </td></tr><tr><td>  2 </td><td>  0x33, 0x70, 0x53 </td></tr><tr><td>  3 </td><td>  0x09, 0x20, 0x21 </td></tr></tbody></table><br>  A color with a value of 0 (the brightest) is used to clear the screen.  Accordingly, if the screen needs to be cleared or the background is turned off, then simply fill it with color with the index 0. <br><br><a name="Window"></a><h6>  Window </h6>  After displaying the background, you must display the "window".  It is displayed almost the same as the background - from the LCDC we will find out which card and tile set to use.  There is also a flag on / off output.  It is displayed according to the coordinates specified in the registers WY and WX.  But in order to display the ‚Äúwindow‚Äù in the upper left corner of the screen, you must specify the coordinates WX = 7 and WY = 0. Ie  The X and Y coordinates of the upper left corner of the ‚Äúwindow‚Äù are WX-7 and WY, respectively. <br><br>  The figure below shows an example of a ‚Äúwindow‚Äù output at WX = 87 and WY = 70. <br><img src="https://habrastorage.org/storage2/af0/aa7/5d7/af0aa75d710059103d9cc67a61d94a76.png"><br><br>  Before outputting, you need to check not only the ‚Äúwindow‚Äù output flag in the LCDC, but also the coordinates: <br><ul><li>  if WX is greater than 166, then the ‚Äúwindow‚Äù is hidden outside the screen; </li><li>  if WY is greater than 143, then the ‚Äúwindow‚Äù is also hidden. </li></ul><br>  An important detail.  WX and WY are subject to change during the withdrawal process.  WX changes will take effect when the next line is displayed, but WY changes will take effect only on the next screen update. <br><br>  As I said, in many ways the output of the ‚Äúwindow‚Äù is identical to the background output, but there is one major difference. <br><br>  To display it, use the hidden pointer of the current row of the "window", which is incremented after the output of the next row.  If the ‚Äúwindow‚Äù is disabled or hidden due to the WX / WY coordinates, then its row counter is not incremented.  Thus, if the ‚Äúwindow‚Äù output was turned off halfway, then when the output is turned on, the output will continue from the place where it stopped.  This is valid for one screen refresh.  At the end of the V-blank, the row counter of the ‚Äúwindow‚Äù is reset. <br><br>  In addition, the counter value changes when the LCDC is modified.  If the "window" was turned off, and now turned on by means of LCDC, then its output will begin only on the next screen update from the first line. <br><br>  At least one game uses this DMG feature - Ant Soldiers.  Immediately after launching, game authors should be displayed at the bottom of the screen.  If the above-mentioned features do not take into account the mentioned features, then at the bottom of the screen it will be empty.  But even worse is that the game interface will also not be visible, which is why a normal game is no longer possible. <br><br><a name="Sprites"></a><h6>  Sprites </h6>  Now came the turn of the sprites.  They also consist of tiles, but are displayed completely differently. <br><br>  Sprites can be 8x8 or 8x16, i.e.  one or two tiles controlled by a flag in the LCDC register.  Sprite information is in the OAM area.  There are 4 bytes per sprite, which allows you to store up to 40 sprites in OAM.  These bytes contain the following information: <br><table><tbody><tr><td>  Byte </td><td>  Purpose </td></tr><tr><td>  0 </td><td>  Y coordinate </td></tr><tr><td>  one </td><td>  X coordinate </td></tr><tr><td>  2 </td><td>  Tile number (0-255) </td></tr><tr><td>  3 </td><td>  Bit 7: priority <br>  Bit 6: Vertical Mirror Image, if 1 <br>  Bit 5: mirror image horizontally, if 1 <br>  Bit 4: if 1, use the OBJ1 palette, otherwise - OBJ0 </td></tr></tbody></table><br>  Sprite coordinates are for the lower right corner.  The coordinates of the upper left corner are X-8 and Y-16.  The size of the sprite here does not matter. <br><br>  For a tile number it is very important to consider the size of the sprite.  If it is set as 8x16, then the least significant bit in the tile number must be cleared, otherwise the graphics output in some games will be incorrect. <br><br>  If the priority is set to 1, then the sprite is drawn as if behind the background and the ‚Äúwindow‚Äù.  Sprite pixels are drawn only on top of colors that have a value of zero.  To do this, you need to display the background and the "window", and then check the color of the pixel, where we are going to display the sprite.  Sprite as it "appears through" through the pixels with zero color.  If the priority is set to 0, then the sprite is drawn over the background and the ‚Äúwindow‚Äù. <br><br>  With reflection everything is clear.  There are two palettes for sprites (OBP0 and OBP1), they play the same role with the exception that the color index 0 (bits 0-1 in the palette) means a transparent pixel and its color in the palette does not matter. <br><br>  Before you render sprites, you need to know exactly what should be displayed and in what order.  Sprites have a priority that dictates the order in which they are displayed on the screen.  It is calculated this way - the sprites are displayed in the order of their X coordinates, from large to smaller.  Those.  Sprites with a smaller value of the X coordinate are displayed on top of those with a large X value. If the X coordinates are equal, then the priority is calculated according to the order in OAM ‚Äî sprites with a smaller address in OAM will be higher. <br><br>  To determine whether to render a sprite, you need to check the Y coordinate of the OAM.  It should be such that the sprite falls on the current line: <br><img src="https://habrastorage.org/storage2/566/c09/515/566c09515ef41febee5dec6c7e17307f.png"><br>  where LY is the current line of the screen, and SpriteHeight is the height of the sprite (8 or 16).  This is a very important formula - improperly forming a sprite queue will lead to subtle bugs in some games (many games can work fine, as I did).  First we transfer the Y coordinate - as already mentioned, the coordinates of the sprites point to their lower right corner.  Again, the height of the sprite does not affect these calculations specifically, but to form an interval in which the value of the current line may lie, we already need to take into account the height of the sprite. <br><br>  X coordinate can be any, even if it leads to the fact that the sprite will not be visible on the screen - it still falls into the list. <br><br>  Sprites are displayed according to their priority, but no more than 10 pieces on one line.  Thus, invisible because of the X coordinate sprites fall into the list and thereby limit the possible number of sprites on a given line of the screen.  Accordingly, when displaying sprites on the screen, you need to be prepared for the fact that they may lie outside of it. <br><br>  As for the limit of 10 pieces - I have not found reliable information on how to consider this limitation.  There may be two logical solutions: <br><ul><li>  Queuing (passage through the OAM content) from all sprites that are visible according to the Y coordinate - now there can be more than 10. Then sorting and only after that discarding the extra sprites.  It is logical to throw out sprites with a lower priority. </li><li>  Queuing stops when 10 sprites are cast.  Thus, it may turn out that there are visible higher-priority sprites in OAM, but we have not reached them. </li></ul><br>  I chose the second option, since other emulators use it.  Testing in games did not help with the solution - there were no visible bugs of any of the implementations. <br><br><a name="Render_impl"></a><h5>  Graphics.  Implementation </h5>  Here we come to another crucial stage in the creation of an emulator.  The slightest mistake here can lead to terrible consequences on the screen.  Some errors I found only in the process of writing these articles.  Before that, we had to observe complete chaos on the screen in some games. <br><br>  Most of all the problems I probably delivered the game Gameboy Wars Turbo.  I was able to achieve the right picture in it only at the time of writing this series of articles.  There are other good test games.  Ant Soldiers I have already mentioned.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kirbys Pinball Land is well suited for testing sprite output - an introductory video uses sprites of various sizes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As usual, we declare all the registers we need, we give access to them from outside (specifically, for the class Cookieboy :: Memory). With video memory and OAM a bit more complicated.</font></font><br><br>  ,   ,               STAT.   ‚Äì    (      )    (  ).     ,        .       ,         ,    .        ‚Äì        .       LCD-   (     Gameboy CPU Manual),         .     ,   . <br><br>      ,    ,    .        ‚Äì   ,            .     ,     ,      RGB      . <br><br>        .      (LY)  ,   , ¬´¬ª   ‚Äî void Cookieboy::GPU::RenderScanline().         ‚Äî void Cookieboy::GPU::PrepareSpriteQueue().     LCD-   ,      . <br><br> ,       ‚Äì       (,  , ),    .       ‚Äì        .         .        ‚Äì    ,            . <br><br>  Let's sum up.              .   ,         ROM'    .    ,          DMG ‚Äì . <br><br><a name="Timers"></a><h4>  Timers </h4>      ,    . <br><br>  ,     DIV,    16384  (..    256  ).  ,      .         DIV. DIV   0  255. ..     255,        0.     DIV - ,     . <br><br>  , TIMA,      .        : <br><ul><li> TIMA    .    ,    255   ,   DIV.      ,     TIMA   0,     TMA. </li><li> TMA     TIMA   255. </li><li> TAC   .    . </li></ul><table><tbody><tr><td>  </td><td>  Purpose </td></tr><tr><td>  2 </td><td>  : <br> 0 ‚Äì   <br> 1 ‚Äì   </td></tr><tr><td> 0-1 </td><td>  : <br> 00 ‚Äì 4096  <br> 01 ‚Äì 262144  <br> 10 ‚Äì 65536  <br> 11 ‚Äì 16384  </td></tr></tbody></table><br>    ,   DIV,     .       while (,            )      LCD-.   262144     16 ,     ,         .        ,       , -     .        . <br><br>  ,               ROM'.         ‚Äì . <br><br><a name="Gamepad"></a><h4>  Control </h4><img src="https://habrastorage.org/storage2/037/321/ced/037321cedd6d335de9a8fb502320fc5c.jpg"><br>     , DMG  8 : 4- ,  A  B,  Start  Select.    ,      , DMG      P1.   : <br><table><tbody><tr><td>  Bit </td><td>  Purpose </td></tr><tr><td>  five </td><td> P15 </td></tr><tr><td>  four </td><td> P14 </td></tr><tr><td>  3 </td><td> P13 </td></tr><tr><td>  2 </td><td> P12 </td></tr><tr><td>  one </td><td> P11 </td></tr><tr><td>  0 </td><td> P10 </td></tr></tbody></table><br>   ,   ,        .  ,      P13, P12, P11, P10.  P15  P14  ROM'   ,  ,          P1.   : <br><table><tbody><tr><td> P15 </td><td> P14 </td><td> P13 </td><td> P12 </td><td> P11 </td><td> P10 </td></tr><tr><td>  one </td><td>  0 </td><td>  Way down </td><td>  Up </td><td>  </td><td>  </td></tr><tr><td>  0 </td><td>  one </td><td>  Start </td><td>  Select </td><td>  B </td><td>  A </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this register, a bit with a value of 0 means that the key is pressed. If the key is pressed, the corresponding interrupt is requested. It is this interrupt that brings DMG out of stop due to the execution of the STOP instruction. In this state, the main components do not work, and interrupts are not requested. Only clicking on a button can request it. In my emulator, the STOP instruction is ignored - the games work fine, and test ROMs do not check it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation comes down to querying the state of the keys that emulate the DMG buttons, and setting the corresponding bits according to the values ‚Äã‚Äãin P15 and P14. But there are some nuances.</font></font><br><br>    (, ,  )  ,  ,   ‚Äì    . ,    .              .  Which one  ,       ‚Äì 70224 .     .        ,     P1     . <br><br><a name="Sync"></a><h4>    </h4>   ‚Äì     .       70224 ,     4194304 , DMG      59.73 ,      60 . <br><br>       ,        70224 .    ,           .       ,         .  ,        ¬´¬ª    ,        1000/60 .      . <br><br>         ,         . <br><br>  ,   .        ,    .     ,    .          ROM'. <br><br><a name="Testing"></a><h4>  Testing </h4>  DMG    ROM',     DMG: , , , LCD.       ROM   .         .            ,    ,     ,  LCD. <br><br>    <a href="http://slack.net/~ant/old/gb-tests/"></a>   <a href="https://docs.google.com/open%3Fid%3D0B5AIo-k6FLqVaFJiWHpadGowdEU"> </a>   ,       ,     .          .      ‚Äî  ,    ,      .       ,               . <br><br>          .          .      11    .    ,     .  ,         ,     .       POP AF, DAA  HALT.   POP AF    ‚Äì           ,         .         ,  -        F. DAA             - . HALT       .   CPU Manual      ‚Ä¶ <br><br>        ‚Äì   ROM    -      .            DMG,        ,          . <br><br>     ,   .          ,   ,        .  Readme      . <br><br>  ,       255.       ,          ,           ‚Äì  ROM           .      .       Readme,       ,      .       ,     . <br><br>              .         ,    .     ,   ,         .  ,       .     ,   .      ,    .         ,    (  )    .      . <br><br> ,  LCD.  ,      LCD-,      (,    LY).           ,      OAM   .      /   7    LCDC.   ,   ROM'         . <br><br><a name="Conclusion"></a><h4>  Conclusion </h4>    ‚Äî    .      ,      ‚Äî      . <br><br>  ,        .         .   ,      ,     . </div><p>Source: <a href="https://habr.com/ru/post/155323/">https://habr.com/ru/post/155323/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155303/index.html">Group artificial intelligence for Oracle SQL XE stacker robots</a></li>
<li><a href="../155309/index.html">Google introduced Samsung Chromebook for 249 dollars</a></li>
<li><a href="../155317/index.html">Konstantin Kalinov, founder of Aviasales: we went to develop horizontally</a></li>
<li><a href="../155319/index.html">Oracle Certified JAVA Associate Exam Preparation</a></li>
<li><a href="../155321/index.html">Setting SMS notifications in zabbix</a></li>
<li><a href="../155325/index.html">Mobile Applications: HTML5 vs. Native Code</a></li>
<li><a href="../155329/index.html">Cisco CCNA Short Notes (part ICND1)</a></li>
<li><a href="../155335/index.html">Results of the 21st IOCCC competition</a></li>
<li><a href="../155337/index.html">IDCEE 2012 - the first day</a></li>
<li><a href="../155339/index.html">GOG.com Interplay Bundle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>