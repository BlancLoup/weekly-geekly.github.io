<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Comparison of compression programs as applied to transferring large amounts of data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It all started with a simple task: download a large amount of data on a 100-megabit network using rsync . The question arose whether this process coul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Comparison of compression programs as applied to transferring large amounts of data</h1><div class="post__text post__text-html js-mediator-article"> It all started with a simple task: download a large amount of data on a 100-megabit network using <code>rsync</code> .  The question arose whether this process could be accelerated.  The top utility showed that on the source server, encryption takes up no more than 10 percent of the processor, so it was decided that you could try data compression.  At that time, it was unclear to me whether processor performance would be enough to pack data at the required speed, so the smallest compression ratio was set, namely the <code>--compress-level=1</code> flag was used for <code>rsync</code> .  It turned out that the processor load did not exceed 65%, that is, the processor performance was enough, while the speed of downloading the data somewhat increased. <br><br>  After that, there was a question about the analysis of the applicability of common compression programs. <br>  for data transmission over the network. <br><a name="habracut"></a><br><br><h1>  Source Data Collection </h1><br>  The first task was to collect baseline data for analysis.  Experimental choices fell on common compression programs in the * nix world.  All programs were installed from standard Ubuntu 11.10 repositories: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre>  Program Version Test Keys Default
 lzop 1.03 1, 3, 7-9 3
 gzip 1.3.12 1-9 6
 bzip2 1.0.5 1-9 9
 xz 5.0.0 0-9 7 </pre><br><br>  Official sites: <a href="http://www.lzop.org/">lzop</a> , <a href="http://www.gzip.org/">gzip</a> , <a href="http://www.bzip.org/">bzip2</a> , <a href="http://tukaani.org/xz/">xz</a> . <br><br>  bzip2 is based on the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%2591%25D0%25B0%25D1%2580%25D1%2580%25D0%25BE%25D1%2583%25D0%25B7%25D0%25B0_%25E2%2580%2594_%25D0%25A3%25D0%25B8%25D0%25BB%25D0%25B5%25D1%2580%25D0%25B0">BWT</a> algorithm ( <a href="http://en.wikipedia.org/wiki/BWT">English</a> ), the rest are based on the <a href="http://ru.wikipedia.org/wiki/LZ77">LZ77</a> algorithm ( <a href="http://en.wikipedia.org/wiki/LZ77">English</a> ) and its modifications. <br><br>  For lzop, compression ratios of 2-6 are identical and therefore not tested. <br><br>  The test system was a laptop on the Intel P8600 (Core 2 Duo, 2.4 GHz) <br>  c 4 GB of RAM, running under Ubuntu 11.10 64-bit. <br><br>  For testing used several different data sets: <br><ul><li>  The source code of a large C ++ project <a href="http://www.openfoam.com/">openfoam.com</a> , packaged in a tar.  It contains source code, documentation in pdf, and a certain amount of poorly compressible scientific data. <br><br>  Uncompressed volume: 127641600 bytes = 122 <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BA%25D0%25B8">MiB</a> <br></li><li>  The binary distribution of a large project <a href="http://www.paraview.org/">paraview.org</a> , packaged in a tar.  Consists mainly of .so library files. <br><br>  Uncompressed volume: 392028160 bytes = 374 MiB <br></li><li>  Binary scientific data set. <br><br>  Uncompressed volume: 151367680 bytes = 145 MiB <br></li></ul><br><br>  Well, more "classic" sets: <br><ul><li>  Linux kernel headers, packaged in tar. <br><br>  Uncompressed volume: 56657920 bytes = 55 MiB <br></li><li>  The gcc compiler source code, packaged in tar. <br><br>  Uncompressed volume: 490035200 bytes = 468 MiB <br></li></ul><br><br>  The measurement technique was as follows: for each program, the compression ratio, and the source file, compression was performed into an intermediate file with time measurement, then the size of the compressed file was remembered, <br>  then unpacking was performed with time measurement.  Just in case, the unpacked file was compared with the original one, then the intermediate and unpacked files were deleted. <br><br>  To eliminate the effect of disk I / O on the results, all files were placed in <code>/run/shm</code> (this is shared memory in linux, with which you can work as with the file system). <br><br>  Each measurement was carried out 3 times.  As a result, a minimum time of three was used. <br><br><h1>  Measurement results </h1><br>  The results are shown in charts in the coordinates of the packing time - the size of the packaged file. <br><br>  Fig.  1: Graph of results for gcc compiler source codes: <br><br><img src="https://habrastorage.org/storage2/445/4ee/6e6/4454ee6e6bec4c8753893f3ef35b3c99.png"><br><br>  Fig.  2: Graph of the results for a binary distribution of ParaView: <br><br><img src="https://habrastorage.org/storage2/7c1/d29/cea/7c1d29ceaeb4912dfa0aecbe6bd7835a.png"><br><br>  Fig.  3: Graph of results for a binary scientific data set: <br><br><img src="https://habrastorage.org/storage2/76e/e79/e79/76ee79e790f244d0bf5dcbda8a3e1638.png"><br><br>  Also graphics for: <a href="">kernel headers</a> and <a href="">OpenFoam source code</a> . <br><br><h5>  Observations: </h5><br><ol><li>  With compression rates of 7-9, lzop becomes very slow without a large reduction in file size, and loses much more than gzip.  These lzop compression ratios are completely useless. <br><br>  With the default compression level, lzop is, as expected, very fast.  The compression ratio -1 does not give a big time gain, giving a larger file size. <br></li><li>  gzip behaves as expected.  "Correct" form of the graph when changing the degree of compression. <br></li><li>  bzip2 was not very competitive.  In most cases, it loses both in compression ratio and speed in low compression ratios xz.  The exceptions are the kernel headers and gcc source code (that is, purely textual information) on which they compete.  In this light, it is rather strange that bzip2 on the Internet is much more popular than xz.  This is probably due to the fact that the second is rather young and has not yet become an ‚Äústandard‚Äù one. <br><br>  It is also worth noting that different keys change the compression ratio and the bzip2 operation time is very small. <br></li><li>  xz at large values ‚Äã‚Äãof the parameter shows a high degree of compression, but at the same time it works very slowly and requires a very large amount of memory for compression (approximately 690 MB at -9, the required memory size is indicated in man).  The size of the memory for unpacking is significantly less, but it can still be <br>  restriction for some applications. <br><br>  Small compression ratios closely approach gzip -9 in runtime, providing a better compression ratio. <br><br>  In general, you can see that xz gives a fairly large selection of ratios of compression ratio and time. <br></li><li>  Unpacking of LZ-77-based programs occurs fairly quickly, and with an increase in the compression ratio (within the same program), the unpacking time decreases slightly. <br><br>  With bzip2, unpacking is slower, and the unpacking time increases with increasing compression. </li></ol><br><br><h1>  Analysis: Scenario 1 ‚Äî Sequential Operations </h1><br>  Consider this scenario of data transmission over the network: first, the data is packaged, then transmitted over the network, then unpacked.  Then the total time will be: <br><br><pre>  t = t_c + s / bw + t_d
</pre><br><br>  where <code>t_c</code> is the packing time, <code>s</code> is the packed file size in bytes, <code>bw</code> is the network bandwidth in bytes / s, <code>t_d</code> is the unpacking time. <br><br>  This equation defines a constant time curve in the graphs shown, the slope of which is determined by the network bandwidth.  To determine the optimal packing algorithm for a given bandwidth, you need to find the lowest straight line with the desired slope passing through any point of the graph. <br><br>  That is, the optimal methods of compression and the speed of their ‚Äúswitching‚Äù are determined by the lines tangent to our set of points on the graph.  It remains only to determine them. <br><br>  What we are looking for is nothing more than a <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D0%25BF%25D1%2583%25D0%25BA%25D0%25BB%25D0%25B0%25D1%258F_%25D0%25BE%25D0%25B1%25D0%25BE%25D0%25BB%25D0%25BE%25D1%2587%25D0%25BA%25D0%25B0">convex hull</a> ( <em>born</em> convex hull).  Numerous <a href="http://en.wikipedia.org/wiki/Convex_hull_algorithms">algorithms have been</a> developed for constructing the convex hull of a set of points.  I used implementation on python <a href="http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain">from here</a> . <br><br>  After constructing the convex hull, the points belonging to it will be our optimal algorithms, and the slopes of the edges connecting them will be the boundary capacities. <br><br>  Thus we obtain the following optimal algorithms for our files: <br><br><img src="https://habrastorage.org/storage2/584/71a/cdb/58471acdb73f62ba911c97d1067dcfad.png"><br><br><h1>  Analysis: Scenario 2 - Stream Compression </h1><br>  Now consider another scenario: the data is packed, and immediately as it is sent, it is sent over the network, and on the receiving side it is immediately unpacked. <br><br>  Then the total data transfer time is determined not by the sum, but by the maximum of three times: packaging, unpacking, and transmission over the network. <br><br>  The constant time curve for the selected network bandwidth will then look like an angle with apex on a straight line <br><br><pre>  t = s / bw
</pre><br><br>  and two rays going down and to the left from the top. <br><br>  Algorithm that allows you to find all the best methods of compression and boundary bandwidths, in this case is much easier.  First we sort the points by time, then we select the first optimal point (this will be a point without compression, with zero time. The absence of compression is optimal for a network of infinite capacity.) Now we are going through the points in the order of increasing compression time.  If the file size is smaller than the file size of the previous optimal method, then the current method becomes the new optimal one.  In this case, the boundary bandwidth will be equal to the file size of the previous method divided by the compression time of the new method. <br><br>  Here are the results for this use case: <br><br><img src="https://habrastorage.org/storage2/9fe/1ae/5b1/9fe1ae5b1e99e9d62a3917b54b30344a.png"><br><br><h1>  Final notes </h1><br><ol><li>  Everything written concerns only scenarios with the transmission of large amounts of data, and does not apply to other scenarios, for example, with the transmission of many small messages. <br></li><li>  This study had a model character and does not pretend to fully take into account all the features arising in real life.  Here are some of them: <br><br><ul><li>  Disk I / O is not considered. </li><li>  The presence and possibility of using multiple processor cores is not taken into account. </li><li>  It does not take into account that in a server application, there may be another load on the processor at the same time, leaving less resources for compression. </li></ul><br></li><li>  This study does not include <a href="http://code.google.com/p/snappy">snappy</a> from google.  It happened for several reasons. <br><br><ul><li>  First of all, it does not have a native command line utility (in fact, there is a third-party <a href="https://github.com/kubo/snzip">snzip</a> , but I do not think that it can be considered any standard). </li><li>  Secondly, it is intended for other applications. </li><li>  Thirdly, it promises to be even faster than lzop, which means that it can be very difficult to correctly measure its operation time. </li></ul><br></li></ol><br><br><h1>  Practical examples </h1><br>  It is known that one of the fastest channels for delivering large amounts of information over short distances is a cycle courier with hard drives. <br><br>  <em>Count.</em>  <em>Let the distance be 10 kilometers.</em>  <em>The cyclist will make a round-trip flight in an hour and a half (at a normal pace and taking into account any delays, loading and unloading) Let it give 6 flights per 8-hour working day.</em>  <em>Let him take with him 10 drives of 1 TB.</em>  <em>Then he will transport 60 TB per day.</em>  <em>This is equivalent to round-the-clock operation of a line with a throughput of 60 TB / (24 * 3600) with = 662 MiB / s, which is approximately 5 Gbit / s.</em>  <em>Not bad.</em> <br><br>  The results show that if you try to compress the data for such a communication line on one core, similar to the cores of my laptop, then the absence of compression is optimal. <br><br>  And if we consider the case of transferring data on a single USB 2.0 hard drive, then this is similar to scenario 2 with a speed of approximately 30 MB / s, if we consider the time costs only on the transmitting side. <br><br>  Looking at our graph, we get: <code>lzop -3</code> is optimal for transferring data on an external USB hard drive for our test datasets. <br><br>  If we first compress and then copy to an external disk, then this is scenario 1, and then <code>lzop -1</code> turns out to be optimal in terms of total time consumption for source codes and binary distribution, and for poorly compressible binary data - no compression. <br><br><h1>  Additional links </h1><br><ol><li>  Similar comparison: <a href="http://stephane.lesimple.fr/wiki/blog/lzop_vs_compress_vs_gzip_vs_bzip2_vs_lzma_vs_lzma2-xz_benchmark_reloaded">http://stephane.lesimple.fr/wiki/blog/lzop_vs_compress_vs_gzip_vs_bzip2_vs_lzma_vs_lzma2-xz_benchmark_reloaded</a> </li><li>  Another comparison: <a href="http://www.linuxjournal.com/node/8051/">http://www.linuxjournal.com/node/8051/</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/139012/">https://habr.com/ru/post/139012/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../139005/index.html">April 3, Samara. WebProfessionals - Microsoft web conferencing. the entrance is free</a></li>
<li><a href="../139006/index.html">Election Observation Cameras</a></li>
<li><a href="../139007/index.html">Content Interaction Tracking with Google Analytics</a></li>
<li><a href="../139008/index.html">Live wallpaper on Android without native code or the story of writing Two Hearts Live Wallpaper</a></li>
<li><a href="../139010/index.html">New mobile applications "Rambler News"</a></li>
<li><a href="../139016/index.html">A simple and secure way to transfer user data to a non-system disk.</a></li>
<li><a href="../139017/index.html">Performance comparison of IoC containers under Windows Phone</a></li>
<li><a href="../139021/index.html">Why sql?</a></li>
<li><a href="../139022/index.html">Recommender systems: problem statement</a></li>
<li><a href="../139023/index.html">The second long-awaited Dropquest 2012 from Dropbox.com</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>