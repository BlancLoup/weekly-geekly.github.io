<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An example of solving a typical OOP problem in the Haskell language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Consider a typical task, from those that are usually considered "OOP-Eshnymi." There is a list of data (objects) having not identical structures (acco...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An example of solving a typical OOP problem in the Haskell language</h1><div class="post__text post__text-html js-mediator-article"> Consider a typical task, from those that are usually considered "OOP-Eshnymi."  There is a list of data (objects) having not identical structures (according to scientific, heterogeneous list), with that, on each one you need to perform the same actions - simply, each can be transferred to a certain function. <a name="habracut"></a>  The first thing that comes to mind is GUI elements, but for example they don‚Äôt work, you need to plug in large packets and the code takes too much space, which has no relation to the essence of OOP in Haskell. <br><br>  You can simplify to graphic primitives - a rectangle and a circle.  But, displaying graphics will also distract attention.  Perhaps even simplified.  Let the final action be the output of messages to the terminal, for example <br><br> <code>paint rectangle, Rect {left = 10, top = 20, right = 600, bottom = 400}</code> <br> <code>paint circle, radius=150 and centre=(50,300)</code> <br> <br>  A dear reader connects the imagination. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And so, we define two types of data describing figures ( <i><b>Note: there are many ways to solve the problem. Some alternatives are given in the comments to this article</b></i> ). <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rect</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rect</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">left</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">top</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">right</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bottom</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Circle</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Circle</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">radius</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  Now we need to decide how to combine them into a non-uniform list.  Integration through Algebraic Data Type (ADT) <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Figures</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RectFigure</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rect</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CircleFigure</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Circle</span></span></span></span></code> </pre><br>  undesirable.  In addition to the need to search for designers with each treatment, the ADT will require a change in it with each addition of a new shape.  Does the base class C ++, the OOP hierarchy, require changes when adding a child?  A properly designed is not required.  Well, in Haskell it should be better, not worse! <br><br>  Haskell already has inheritance of type classes and instantiation of type classes, which can also be considered as inheritance. <br>  Here is a base class with the "twists" I came up with for example. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Paint</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> paint:: a -&gt; <span class="hljs-type"><span class="hljs-type">Handle</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () paint o handle = hPutStrLn handle $ <span class="hljs-string"><span class="hljs-string">"paint "</span></span> ++ say o ++ <span class="hljs-string"><span class="hljs-string">" S="</span></span> ++ show ( circumSquare o ) say:: a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-comment"><span class="hljs-comment">--     circumSquare:: a -&gt; Int --   .   </span></span></code> </pre><br>  The external function, for each instance of our types, will call <b>paint :: a -&gt; Handle -&gt; IO ()</b> , which is implemented directly in this class.  Instead of a pointer to a graphics context, or whatever the outline, the simplified ‚Äúdrawing‚Äù function accepts a file handle.  It displays the string ‚Äúpaint‚Äù, a description of the output object that it receives from the <b>say</b> function (we imitate the mechanism of virtual functions), as well as the area of ‚Äã‚Äãthe described rectangle.  Why square?  Further it will be clear why I needed it. <br><br>  We connect the convenient <b>RecordWildCards</b> extension and describe the base class instances for our types. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Paint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rect</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> say r = <span class="hljs-string"><span class="hljs-string">"rectangle, "</span></span> ++ show r circumSquare (<span class="hljs-type"><span class="hljs-type">Rect</span></span> {..}) = ( right - left ) * ( bottom - top ) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Paint</span></span> <span class="hljs-type"><span class="hljs-type">Circle</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> say (<span class="hljs-type"><span class="hljs-type">Circle</span></span> {..}) = <span class="hljs-string"><span class="hljs-string">"circle, radius="</span></span> ++ show radius ++ <span class="hljs-string"><span class="hljs-string">" and centre=("</span></span> ++ show x ++ <span class="hljs-string"><span class="hljs-string">","</span></span> ++ show y ++ <span class="hljs-string"><span class="hljs-string">")"</span></span> circumSquare (<span class="hljs-type"><span class="hljs-type">Circle</span></span> {..}) = (<span class="hljs-number"><span class="hljs-number">2</span></span>*radius)^<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  So far, everything is simple.  For <b>Circle,</b> I did not use <b>deriving Show</b> , I formed a ‚Äústring manually‚Äù, I really wanted to.  The rest is nothing special.  It remains to combine different types into one list.  To do this, I will use the <b>ExistentialQuantification</b> extension, which allows you to combine, together with data, functions from instances (instances) of specific types.  To do this, you need to create a simple auxiliary type. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Figure</span></span></span><span class="hljs-class"> = forall a. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Paint</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Figure</span></span></span><span class="hljs-class"> a</span></span></code> </pre><br>  "Spell" <b>forall a.</b>  <b>Paint a</b> means that along with data of a certain type a, the functions of the Paint class for this type will also be wrapped (Of course, the compiler will require that the type of the argument of the Figure constructor be an instance of the Paint class). <br><div class="spoiler">  <b class="spoiler_title">Together</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE ExistentialQuantification, RecordWildCards #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.IO <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad class Paint a where paint:: a -&gt; Handle -&gt; IO () paint o handle = hPutStrLn handle $ "paint " ++ say o ++ " S=" ++ show ( <span class="hljs-title"><span class="hljs-title">circumSquare</span></span> <span class="hljs-title"><span class="hljs-title">o</span></span> ) say:: a -&gt; String <span class="hljs-comment"><span class="hljs-comment">--     circumSquare:: a -&gt; Int --   .    data Rect = Rect { left :: Int , top :: Int , right :: Int , bottom :: Int } deriving Show instance Paint Rect where say r = "rectangle, " ++ show r circumSquare (Rect {..}) = ( right - left ) * ( bottom - top ) data Circle = Circle { x :: Int , y :: Int , radius :: Int } instance Paint Circle where say (Circle {..}) = "circle, radius=" ++ show radius ++ " and centre=(" ++ show x ++ "," ++ show y ++ ")" circumSquare (Circle {..}) = (2*radius)^2 data Figure = forall a. Paint a =&gt; Figure a lst :: [Figure] lst = [Figure (Rect 10 20 600 400), Figure (Circle 50 300 150)] main = forM_ lst $ \ (Figure obj) -&gt; paint obj stdout</span></span></code> </pre><br></div></div><br>  Adding, say, a triangle is trivial.  It is interesting to add something that is very similar, its implementation will lead to duplication of code, and try to eliminate duplicate code. <br><br>  Take a rounded rectangle.  Duplicate code in the example is the calculation of the area of ‚Äã‚Äãthe described rectangle. <br>  Haskell (unlike OOP languages) does not allow to increase, expand (by OOP-effective inherit) data types, including the structure.  We'll have to nest the structure describing the rectangle into the new structure. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Roundrect</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Roundrect</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">baseRect</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rect</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">roundR</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> } instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Paint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Roundrect</span></span></span><span class="hljs-class"> where say (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Roundrect</span></span></span><span class="hljs-class"> {..}) = "round rectangle, " ++ show baseRect ++ " and roundR=" ++ show roundR circumSquare (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Roundrect</span></span></span><span class="hljs-class"> {..}) = circumSquare baseRect</span></span></code> </pre><br>  It would seem that everything is great, we use the code from the <b>instance Paint Rect</b> to implement new functions in the <b>instance Paint Roundrect</b> .  But, imagine that in a real project we have 42 inheritances from <b>Rect</b> , and 28 functions were defined for <b>Rect</b> , which should do the same for both the <b>Rect</b> type and for inheritances from it.  I would have to write functions many times, like <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">circumSquare</span></span> (<span class="hljs-type"><span class="hljs-type">Roundrect</span></span> {..}) = circumSquare baseRect <span class="hljs-comment"><span class="hljs-comment">-- ‚Ä¶. funN (TypeM {..}) = funN baseRect</span></span></code> </pre><br>  which is boring.  This suggests the creation of an intermediate instance of the <b>Paint</b> class, in which the code common to all inheritances will be implemented, and unique, albeit implemented in a separate class.  I am going to link both classes using the <b>data family</b> , which is enabled using <b>{- # LANGUAGE TypeFamilies # -}</b> (of course, the <b>type family</b> is also enabled). <br>  We define the family of all rectangles. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">family</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RectFamily</span></span></span><span class="hljs-class"> a</span></span></code> </pre><br>  And a class using this family <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PaintRect</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> getRect :: <span class="hljs-type"><span class="hljs-type">RectFamily</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Rect</span></span> rectSay :: <span class="hljs-type"><span class="hljs-type">RectFamily</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre><br>  In the class, as I promised, the unique features of each rectangle will be implemented.  <b>getRect</b> will return the coordinates of the rectangle wherever they are hidden in the type.  And <b>rectSay</b> is just the previously defined say for rectangles. <br><br>  Now an instance of the <b>Paint</b> class for the family in which, on the contrary, the functions are implemented are the same for all rectangles. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PaintRect</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Paint</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RectFamily</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> say = rectSay circumSquare w = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> (<span class="hljs-type"><span class="hljs-type">Rect</span></span> {..}) = getRect w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ( right - left ) * ( bottom - top )</code> </pre><br>  As you can see, <b>say</b> just calls <b>rectSay</b> , described above.  And the area of ‚Äã‚Äãthe described rectangle is calculated equally for all rectangles (at least, let it be so for example). <br><br>  For each type of shape you will have to come up with the name of a new constructor (in this case, RectWrap). <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RectFamily</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rect</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RectWrap</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rect</span></span></span><span class="hljs-class"> instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PaintRect</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Rect</span></span></span><span class="hljs-class"> where getRect (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RectWrap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) = r rectSay (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RectWrap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) = "rectangle, " ++ show r</span></span></code> </pre><br>  For <b>Rect</b> everything is easy.  <b>getRect</b> returns the <b>Rect</b> itself expanded from a <b>RectWrap</b> .  The <b>rectSay</b> function <b>is</b> also trivial.  By the way, it can be written as <br><pre> <code class="haskell hljs"> rectSay w = <span class="hljs-string"><span class="hljs-string">"rectangle, "</span></span> ++ show (getRect w)</code> </pre><br>  Roundrect is a bit more complicated. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RectFamily</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Roundrect</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoundrectWrap</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Roundrect</span></span></span><span class="hljs-class"> instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PaintRect</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Roundrect</span></span></span><span class="hljs-class"> where getRect (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoundrectWrap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) = baseRect r rectSay (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoundrectWrap</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Roundrect</span></span></span><span class="hljs-class"> {..})) = "round rectangle, " ++ show baseRect ++ " and roundR=" ++ show roundR</span></span></code> </pre><br>  Finally, all together, a little combed.  For example, added functions - constructors for shape types. <br><div class="spoiler">  <b class="spoiler_title">Complete, final code</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE ExistentialQuantification, RecordWildCards #-}</span></span> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE TypeFamilies #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.IO <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad class Paint a where paint:: a -&gt; Handle -&gt; IO () paint o handle = hPutStrLn handle $ "paint " ++ say o ++ " S=" ++ show ( <span class="hljs-title"><span class="hljs-title">circumSquare</span></span> <span class="hljs-title"><span class="hljs-title">o</span></span> ) say:: a -&gt; String <span class="hljs-comment"><span class="hljs-comment">--     circumSquare:: a -&gt; Int --   .    data Figure = forall a. Paint a =&gt; Figure a data Rect = Rect { left :: Int , top :: Int , right :: Int , bottom :: Int } deriving Show data family RectFamily a class PaintRect a where getRect :: RectFamily a -&gt; Rect rectSay :: RectFamily a -&gt; String instance PaintRect a =&gt; Paint (RectFamily a) where say = rectSay circumSquare w = let (Rect {..}) = getRect w in ( right - left ) * ( bottom - top ) data instance RectFamily Rect = RectWrap Rect instance PaintRect Rect where getRect (RectWrap r) = r rectSay w = "rectangle, " ++ show (getRect w) mkRect:: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Figure mkRect ltrb = Figure $ RectWrap (Rect ltrb) data Circle = Circle { x :: Int , y :: Int , radius :: Int } instance Paint Circle where say (Circle {..}) = "circle, radius=" ++ show radius ++ " and centre=(" ++ show x ++ "," ++ show y ++ ")" circumSquare (Circle {..}) = (2*radius)^2 mkCircle:: Int -&gt; Int -&gt; Int -&gt; Figure mkCircle xyr = Figure $ Circle xyr --       .  .  data Roundrect = Roundrect { baseRect :: Rect , roundR :: Int } data instance RectFamily Roundrect = RoundrectWrap Roundrect instance PaintRect Roundrect where getRect (RoundrectWrap r) = baseRect r rectSay (RoundrectWrap (Roundrect {..})) = "round rectangle, " ++ show baseRect ++ " and roundR=" ++ show roundR mkRoundrect:: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int -&gt; Figure mkRoundrect ltrb rr = Figure $ RoundrectWrap $ Roundrect (Rect ltrb) rr --    . lst :: [Figure] lst = [ mkRect 10 20 600 400, mkCircle 50 300 150, mkRoundrect 30 40 500 200 5 ] --    . main = forM_ lst $ \ (Figure obj) -&gt; paint obj stdout</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/263575/">https://habr.com/ru/post/263575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263551/index.html">Quick start with PHPixie 3</a></li>
<li><a href="../263555/index.html">Qucs project news: release candidate available with circuit simulation support in SPICE</a></li>
<li><a href="../263565/index.html">Magic of tensor algebra: Part 13 - SKA Maxima in problems of transforming tensor expressions. Angular velocity and acceleration in the parameters of Rodrigues-Hamilton</a></li>
<li><a href="../263569/index.html">With LINQ on "Life"</a></li>
<li><a href="../263571/index.html">SoC: we write framebuffer implementation for controller in FPGA</a></li>
<li><a href="../263577/index.html">Competition of the user design from the Roketbank or how to order a bank card with the Habr logo</a></li>
<li><a href="../263581/index.html">Welcome to FPConf.ru</a></li>
<li><a href="../263591/index.html">Review and video of reports on information security from the conference SECR-2014</a></li>
<li><a href="../263595/index.html">When Chef and Puppet are not the solution. Part 1</a></li>
<li><a href="../263597/index.html">The finite element method on the example of the Poisson equation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>