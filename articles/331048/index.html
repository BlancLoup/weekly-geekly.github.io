<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Go without global variables</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article by Dave Cheni - the answer to the previous post of Peter Burgon, "The Theory of the Modern Go" - with an attempt to conduct...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Go without global variables</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Translation of the article by Dave Cheni - the answer to the previous post of Peter Burgon, "The Theory of the Modern Go" - with an attempt to conduct a thought experiment, what would look like Go without variables in the global scope at all.</em>  <em>Although in some paragraphs you can break the language, but the post is quite interesting.</em> </p><br><p>  Let's do a thought experiment, what Go would look like if we got rid of the variables in the global packet scope.  What would be the implications and what can we learn about the design of Go programs from this experiment? </p><br><p> I will only talk about crossing out <code>var</code> , the other five top-level definitions remain resolved in our experiment, since they are essentially constants at the compilation stage.  And, of course, you can continue to define variables in functions and any blocks. </p><a name="habracut"></a><br><h2 id="pochemu-globalnye-peremennye-v-paketah-eto-ploho">  Why are global variables in packages bad? </h2><br><p>  But first, let's answer the question: why are global variables in packages bad?  Leaving aside the obvious problem of a global visible state in a concurrency language, global variables in packages are essentially singletones used to implicitly change states between weakly not very connected things, creating a strong dependency and making code difficult to test. </p><br><p>  As Peter Burgon <a href="https://habrahabr.ru/post/330786/">recently wrote</a> : </p><br><blockquote>  tl; dr magic is bad;  global state is magic ‚Üí global variables in packages is bad;  The init () function is not needed. </blockquote><br><h2 id="izbavlyaemsya-ot-globalnyh-peremennyh-na-praktike">  Getting rid of global variables in practice </h2><br><p>  To test this idea, I studied in detail the most popular code base on Go ‚Äî the standard library, to see how it uses global variables in packages, and tried to evaluate the effect of our experiment. </p><br><h3 id="oshibki">  Errors </h3><br><p>  One of the most common uses of global <code>var</code> in public packages is errors - <code>io.EOF</code> , <code>sql.ErrNoRows</code> , <code>crypto/x509.ErrUnsupportedAlgorithm</code> , etc.  Without these variables, we will not be able to compare errors with predefined values.  But can we replace them with something? </p><br><p>  I wrote earlier that you should <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">try to look at the behavior and not at the type</a> when analyzing errors.  If this is not possible, the definition of <a href="https://dave.cheney.net/2016/04/07/constant-errors">error constants</a> eliminates possible error modification and preserves their semantics. </p><br><p>  The remaining error variables will be private and simply give the symbolic name of the error message.  These variables are not exported, so they cannot be used for comparison from outside the package.  Defining them at the top level of the package, and not at the place where they occur, makes it impossible for us to add any additional context to the error.  Instead, I recommend using something like <a href="https://godoc.org/github.com/pkg/errors">pkg / errors</a> to save the frame to an error at the time of its origin. </p><br><h3 id="registraciya">  check in </h3><br><p>  The registration pattern is used in several packages of the standard library, such as <code>net/http</code> , <code>database/sql</code> , <code>flag</code> and some also in the <code>log</code> .  It usually consists of a global variable of type map or a structure that is modified by a certain public function ‚Äî the classic singleton. </p><br><p>  The inability to create such a dummy variable that must be initialized from outside makes it impossible for <code>image</code> , <code>database/sql</code> and <code>crypto</code> packages to register decoders, database drivers and cryptographic schemes.  But this is exactly the magic that Peter talks about in his article - importing a package, in order for it to implicitly change the global state of another package and it really looks ominous from the outside. </p><br><p>  Registration also encourages repetition of business logic.  For example, the <code>net/http/pprof</code> registers itself and, as a side effect, <code>net/http.DefaultServeMux</code> , which is not entirely safe - the other code can no longer use the default multiplexer without the information that pprof gives out and registering it with another multiplexer is not so trivial. </p><br><p>  If there were no global variables in the packages, such packages as <code>net/http/pprof</code> could <a href="https://dave.cheney.net/2016/08/20/solid-go-design">provide a function</a> that would register URL paths for the specified <code>http.ServeMux</code> , and not depend on the implicit change in the global state of another package. </p><br><p>  Getting rid of the possibility to use the registration pattern could also help solve the problem with <a href="http://talks.godoc.org/github.com/davecheney/presentations/reproducible-builds.slide">multiple copies of the same package</a> , which, when imported, try to register everything together during the launch. </p><br><h3 id="proverka-udovletvoreniya-interfeysa">  Interface Satisfaction Check </h3><br><p>  There is such an idiom for checking whether the interface is of a type: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _ SomeInterface = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(SomeType)</code> </pre> <br><p>  It is found at least 19 times in the standard library.  In my opinion, such tests are, in fact, tests.  They should not compile at all, so that they can be removed when building the package.  They need to be <code>_test.go</code> to the appropriate <code>_test.go</code> files.  But if we prohibit global variables in batches, this also applies to tests, so how can we keep this check? </p><br><p>  One solution would be to remove this definition of the variable from the global scope to the scope of the function, which will still stop compiling if SomeType suddenly ceases to satisfy the interface <code>SomeInterface</code> </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestSomeTypeImplementsSomeInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// won't compile if SomeType does not implement SomeInterface var _ SomeInterface = new(SomeType) }</span></span></code> </pre> <br><p>  But, since it is, in fact, just a test, we can rewrite this idiom in the form of a regular test: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestSomeTypeImplementsSomeInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{} = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(SomeType) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, ok := i.(SomeInterface); !ok { t.Fatalf(<span class="hljs-string"><span class="hljs-string">"expected %t to implement SomeInterface"</span></span>, i) } }</code> </pre> <br><p>  As a remark, since the Go specification says that assigning an empty identifier (_) means a full evaluation of the expression on the right side of the assignment sign, a pair of suspicious initializations are probably hidden in the global scope. </p><br><h2 id="no-ne-vsyo-tak-prosto">  But not so simple </h2><br><p>  In the previous section, so far everything went smoothly and the experiment with getting rid of global variables seems to be a success, but there are several places in the standard library where everything is not so simple. </p><br><h3 id="realnye-singltony">  Real Singles </h3><br><p>  Although I believe that the singleton pattern as a whole is often used where it is not needed, especially as a registration, there will always be a <em>real singleton</em> in each program.  A good example of this is <code>os.Stdout</code> and company. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( Stdin = NewFile(<span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span>(syscall.Stdin), <span class="hljs-string"><span class="hljs-string">"/dev/stdin"</span></span>) Stdout = NewFile(<span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span>(syscall.Stdout), <span class="hljs-string"><span class="hljs-string">"/dev/stdout"</span></span>) Stderr = NewFile(<span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span>(syscall.Stderr), <span class="hljs-string"><span class="hljs-string">"/dev/stderr"</span></span>) )</code> </pre> <br><p>  There are several problems with this definition.  First, <code>Stdin</code> , <code>Stdout</code> and <code>Stderr</code> are variables of type <code>*os.File</code> , not <code>io.Reader</code> or <code>io.Writer</code> interfaces.  This makes replacing them with alternatives <a href="https://github.com/golang/go/issues/13473">rather problematic</a> .  But even the very idea of ‚Äã‚Äãreplacing them is just the magic that our experiment is trying to get rid of. </p><br><p>  As the previous example with constant errors showed, we can leave the singleton entity for standard IO descriptors so that packages like <code>log</code> and <code>fmt</code> can use them directly, but not declare them as mutable global variables.  Something like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"syscall"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> readfd <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r readfd)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syscall.Read(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(r), buf) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> writefd <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w writefd)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> syscall.Write(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(w), buf) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( Stdin = readfd(<span class="hljs-number"><span class="hljs-number">0</span></span>) Stdout = writefd(<span class="hljs-number"><span class="hljs-number">1</span></span>) Stderr = writefd(<span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Fprintf(Stdout, <span class="hljs-string"><span class="hljs-string">"Hello world"</span></span>) }</code> </pre> <br><h3 id="keshi">  Keshi </h3><br><p>  The second most popular way to use non-exported global variables in packages is caches.  They are of two types - real caches, consisting of objects of type map (see the registration pattern above) or <code>sync.Pool</code> , and quasi- <code>sync.Pool</code> variables that improve the cost of compilation (note translator - "shta?") </p><br><p>  An example is the <code>crypto/ecsda</code> , in which there is a <code>zr</code> type, whose Read () method resets any buffer that it passes to the input.  The package contains a single variable of type zr, because it is built into other structures like io.Reader, potentially running off into a heap each time it is declared. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ecdsa <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> zr <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { io.Reader } <span class="hljs-comment"><span class="hljs-comment">// Read replaces the contents of dst with zeros. func (z *zr) Read(dst []byte) (n int, err error) { for i := range dst { dst[i] = 0 } return len(dst), nil } var zeroReader = &amp;zr{}</span></span></code> </pre> <br><p>  But at the same time, the <code>zr</code> type does not contain an embedded <code>io.Reader</code> ‚Äî it implements <code>io.Reader</code> ‚Äî so we can remove the unused <code>zr.Reader</code> field, thus making <code>zr</code> an empty structure.  In my tests, this modified type can be initialized explicitly without any loss in performance: \ </p><br><pre> <code class="go hljs">csprng := cipher.StreamReader{ R: zr{}, S: cipher.NewCTR(block, []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(aesIV)), }</code> </pre> <br><p>  It may be worthwhile to revise some solutions for caches, since inlining and escape analysis have greatly improved since the writing of the standard library. </p><br><h3 id="tablicy">  Tables </h3><br><p>  And the final most frequent use of private global variables in packages is tables ‚Äî for example, in <code>unicode</code> , <code>crypto/*</code> and <code>math</code> packages.  These tables usually encode constant data in the form of integer arrays or, more rarely, simple structures or objects of type map. </p><br><p>  Replacing global variables with constants will require changes in the language, something like the <a href="https://github.com/golang/go/issues/20443">one described here</a> .  So, if we assume that there is no way to change these tables during the work of the program, they may be an exception to this proposal (proposal). </p><br><h3 id="slishkom-daleko-zashli">  Too far gone </h3><br><p>  Despite the fact that this post was just a thought experiment, it is already clear that the prohibition of all global variables in packages is too draconian to be real in language.  Bypassing the problems with the ban can be very impractical in terms of performance, and it will be like hanging a poster "hit me" on the back and invite all Go haters to have fun. </p><br><p>  But at the same time, it seems to me there are some very specific tips that can be drawn from this mental experiment without having to go to extremes and change the language specification: </p><br><ul><li>  First, the use of public <code>var</code> definitions is better to refuse.  This is not a controversial topic, and it is definitely not unique to Go.  The singleton pattern is better not to use, and a muddy public variable, which can be changed at any time by anyone who knows its name, is automatically a ‚Äústop‚Äù signal. </li><li>  Secondly, if somewhere the public variable is determined, then you need to be extremely attentive to its type and try to make it as simple as possible.  There should not be such that the type, in theory, is used on per instance basis (commentator - I do not know how to interpret it correctly), and we assign it to a variable in the global scope of the package. </li></ul><br><p>  Private definitions of global variables are more specific, but some patterns can be extracted: </p><br><ul><li>  Private variables with public setters (functions Set ()), which I call "registries" in fact have the same effect as their public counterparts.  Instead of registering dependencies in the global scope, they should be passed during creation using constructor functions, literals, configuration structures, or <a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis">options functions</a> . </li><li>  Caches in the form of variables of type [] byte can often be defined as constants without loss of performance.  Do not forget that the compiler very well optimizes calls like <code>string([]byte)</code> where they do not go beyond the scope of the function. </li><li>  Private variables containing tables, such as in the <code>unicode</code> package, are an inevitable consequence of the absence of the type of a constant array in Go.  As long as they are private, and do not provide any way to change them, they can actually be considered as constants in the framework of this discussion. </li></ul><br><p>  Summarizing, think twice and three times before adding global variables to the package that can change the value while the program is running.  This may be a sign that you have added a magical global state. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331048/">https://habr.com/ru/post/331048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331034/index.html">We program in the world of Minecraft</a></li>
<li><a href="../331036/index.html">Why open data is not needed by anyone</a></li>
<li><a href="../331042/index.html">Life hacking editor Unity 3D. Part 1: Attributes</a></li>
<li><a href="../331044/index.html">Fight for build-in iOS applications</a></li>
<li><a href="../331046/index.html">Android Excellence on Google Play</a></li>
<li><a href="../331050/index.html">The easiest guide to iconography</a></li>
<li><a href="../331052/index.html">From b2b applications to mass service around the world</a></li>
<li><a href="../331054/index.html">Data Science meetup at Avito office June 24</a></li>
<li><a href="../331056/index.html">Fear and Loathing in MiddleWare</a></li>
<li><a href="../331058/index.html">First, Storiframes, Then Wireframes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>