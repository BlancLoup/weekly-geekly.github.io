<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accuracy through inaccuracy: Improving Time-objects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When creating a value object for storing time, I recommend choosing with the experts in and around the subject area with what accuracy it will be stor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accuracy through inaccuracy: Improving Time-objects</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  When creating a value object for storing time, I recommend choosing with the experts in and around the subject area with what accuracy it will be stored. </blockquote><p>  Modeling work with numbers is considered good form to indicate accuracy.  It does not matter what is at stake - about money, size or weight;  round to the specified decimal point.  The presence of rounding makes the data more predictable for processing and storage, even if this number is only for display to the user. </p><br><p>  Unfortunately, this is not often done, and when the moment comes, the problem makes itself felt.  Consider the following code: </p><br><pre><code class="php hljs">$estimatedDeliveryDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2017-06-21'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,    2017-06-21 $now = new DateTimeImmutable('now'); if ($now &gt; $estimatedDeliveryDate) { echo 'Package is late!'; } else { echo 'Package is on the way.'; }</span></span></code> </pre> <br><p>  It is expected that on June 21 this code will print <code>Package is on the way.</code>  Because the day is not over yet, for example, the package will be delivered in the evening. </p><br><p>  Despite this, the code does not.  Since the part with the time is not specified, PHP carefully submits the zero values ‚Äã‚Äãand results in the <code>$estimatedDeliveryDate</code> by <code>2017-06-21 00:00:00</code> . <br>  On the other hand, <code>$now</code> calculated as ... now.  <code>Now</code> includes the current moment in time, which is most likely not midnight, so it will be <code>2017-06-21 15:33:34</code> or something like that will be later than <code>2017-06-21 00:00:00</code> . </p><a name="habracut"></a><br><h2 id="reshenie-1">  Solution 1 </h2><br><p>  ‚ÄúOh, it's easy to fix.‚Äù Many will say, and update the necessary part of the code. </p><br><pre> <code class="php hljs">$estimatedDeliveryDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2017-06-21'</span></span>); $estimatedDeliveryDate = $estimatedDeliveryDate-&gt;setTime(<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>);</code> </pre> <br><p>  Cool, we changed the time until midnight.  But now the time is completed by <code>23:59:00</code> , so if you run the code in the last 59 seconds of the day, you will get the same problems. </p><br><p>  ‚ÄúBrr, okay.‚Äù - the answer will follow. </p><br><pre> <code class="php hljs">$estimatedDeliveryDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2017-06-21'</span></span>); $estimatedDeliveryDate = $estimatedDeliveryDate-&gt;setTime(<span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>);</code> </pre> <br><p>  Great, now it's fixed. </p><br><p>  ... until you upgrade to PHP 7.1, which adds microseconds to <code>DateTime</code> objects.  So now the problem will arise in the last second of the day.  Perhaps I have become too biased when working with high traffic systems, but the user or process will definitely come across this.  Good luck in finding this bug.  : - / </p><br><p>  OK, let's add microseconds. </p><br><pre> <code class="php hljs">$estimatedDeliveryDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2017-06-21'</span></span>) $estimatedDeliveryDate = $estimatedDeliveryDate-&gt;modify(<span class="hljs-string"><span class="hljs-string">'23:59:59.999999'</span></span>);</code> </pre> <br><p>  And now it works. </p><br><p>  Until we get nanoseconds. </p><br><p>  In PHP 7.2. </p><br><p>  Okay, okay, we CAN reduce the error further and further to the moment when the appearance of an error becomes unrealistic.  At this moment it is clear that this approach is wrong: <a href="https://en.wikipedia.org/wiki/Zeno%2527s_paradoxes">we are chasing an infinitely divisible value and are getting closer and closer to a point that we cannot reach</a> .  Let's try a different approach. </p><br><h2 id="reshenie-2">  Solution 2 </h2><br><p>  Instead of calculating the last moment before our boundary, let's check the comparison of the boundaries instead. </p><br><pre> <code class="php hljs">$estimatedDeliveryDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2017-06-21'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    ,   ,       $startOfWhenPackageIsLate = $estimatedDeliveryDate-&gt;modify('+1 day'); $now = new DateTimeImmutable('now'); //    &gt;  &gt;= if ($now &gt;= $startOfWhenPackageIsLate) { echo 'Package is late!'; } else { echo 'Package is on the way'; }</span></span></code> </pre> <br><p>  This option works and will work throughout the day.  Such code looks more complicated.  If you do not encapsulate this logic in a value object or something similar, you will definitely miss it somewhere in your application. </p><br><p>  Even if you do this, only one type of operation (&gt; =) will be logical and consistent, for the rest it does not work.  If we implement support for equality checking, we will have to make another data type, and then juggle them to work correctly.  Heh. </p><br><p>  Finally (perhaps only for me) this solution has unpleasant moments in the form of a potentially missed domain concept.  "Is there a LatePeriodRange? A DeliveryDeadline?"  could you ask.  ‚ÄúThe package was late and ... there will be something? The expert didn‚Äôt talk about deadlines, it seems there is no deadline. How does this differ from EstimatedDeliveryDate? What then?‚Äù  The package is not going anywhere.  This is just a strange feature of the constructed logic, which is now stuck in the head. </p><br><p>  This is the best solution in providing the right answer ... but it is not a very good solution.  Let's see what else you can do. </p><br><h2 id="reshenie-3">  Solution 3 </h2><br><p>  Our goal is to compare two days.  Imagine a <code>DateTime</code> object with <code>now</code> as a set of numbers (year, month, day, hour, minute, second, etc.), then the part before the day will work fine.  Problems begin due to additional indicators: hour, minute, second.  One can argue about tricky ways to solve a problem, but the fact remains that a component of time harms our checks. </p><br><p>  If only the part with the day is important to us, then why put up with these additional values?  additional hours or minutes should not change the logic of business rules if only the transition to the next day is important. </p><br><p>  Just throw out the trash away. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,   $estimatedDeliveryDate = day(new DateTimeImmutable('2017-06-21')); $now = day(new DateTimeImmutable('now')); //     if ($now &gt; $estimatedDeliveryDate) { echo 'Package is late!'; } else { echo 'Package is on the way.'; } // ,      //   , PHP      function day(DateTimeImmutable $date) { return DateTimeImmutable::createFromFormat( 'Ym-d', $date-&gt;format('Ym-d') ); }</span></span></code> </pre> <br><p>  This simplifies the comparison or calculation of what is in solution 1, with an accuracy from solution 2. But ... this is the ugliest option, plus, with such an implementation it is very easy to forget to call <code>day()</code> . </p><br><p>  This code is easy to turn into an abstraction.  Now that the situation with the subject area has cleared up, it is clear: when we talk about the delivery time, we are talking about the day, not the time.  Both of these things make the code a good candidate for encapsulation inside the type. </p><br><h2 id="inkapsulyaciya">  Encapsulation </h2><br><p>  In other words, let's make this value object. </p><br><pre> <code class="php hljs">$estimatedDeliveryDate = EstimatedDeliveryDate::fromString(<span class="hljs-string"><span class="hljs-string">'2017-06-21'</span></span>); $today = EstimatedDeliveryDate::today(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($estimatedDeliveryDate-&gt;wasBefore($today)) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Package is late!'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Package is on the way.'</span></span>; }</code> </pre> <br><p>  See how the code reads.  Now we implement the value object: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EstimatedDeliveryDate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $day; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DateTimeInterface $date)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;day = DateTimeImmutable::createFromFormat( <span class="hljs-string"><span class="hljs-string">'Ym-d'</span></span>, $date-&gt;format(<span class="hljs-string"><span class="hljs-string">'Ym-d'</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $date)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">self</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    YYYY-MM-DD   .. return new static(new DateTimeImmutable($date)); } public static function today(): self { return new static(new DateTimeImmutable('now')); } public function wasBefore(EstimatedDeliveryDate $otherDate): bool { return $this-&gt;day &lt; $otherDate-&gt;day; } }</span></span></code> </pre> <br><p>  Having the class available, we automatically get a useful limitation: the comparison of <code>EstimatedDeliveryDate</code> goes only with another <code>EstimatedDeliveryDate</code> , now the accuracy will converge. </p><br><p>  Processing with the necessary accuracy is located in one place.  Consumer code does not apply to this work. </p><br><p>  It is easy to test. </p><br><p>  And you have a great place for the centralized storage of processing time zones (not discussed in the article, but important). </p><br><p>  One tip: I used the <code>today()</code> method to show that it is possible to create several constructors.  In practice, I would recommend adding a system clock class and getting instances of <code>now</code> from there.  So much easier to write unit tests.  The "real" version will look like this: </p><br><pre> <code class="php hljs">$today = EstimatedDeliveryDate::fromDateTime(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;clock-&gt;now());</code> </pre> <br><h1 id="tochnost-cherez-netochnost">  Accuracy through inaccuracy </h1><br><p>  It is important to understand, we managed to remove several different types of errors by reducing the accuracy of <code>DateTime</code> , which we were processing.  If we didn‚Äôt do this, we would have to handle all the problematic sides and, most likely, in some case everything would have gone wrong. </p><br><p>  Reducing the quality of the data to get the right result may seem illogical, but in fact it‚Äôs a more realistic look at the system we are trying to model.  Our computers can run in picoseconds, but our business is (most likely) not.  Plus, the <a href="https://blogs.msdn.microsoft.com/ericlippert/2010/04/08/precision-and-accuracy-of-datetime/">computer probably lies</a> . </p><br><p>  Perhaps as developers, we feel.  It is better to be more flexible and promising, while retaining all possible information.  In the end, who are you to decide what information to throw out?  The truth is that information can <em>potentially</em> cost money in the future, in the present it is <em>certainly</em> worth the cost of maintaining it before a possible future.  This is not only the cost of hard disk space, it is the cost of problems, people, time, and, in case of error, reputation.  Sometimes working with the data in its most complete form will justify itself, but sometimes blindly saving everything you can, just because you can, is not worth it. </p><br><p>  To make it clearer: I do not recommend that you just thoughtlessly delete the available time information. </p><br><p>  <strong>I recommend</strong> : Clearly choose the accuracy for your time stamps along with subject matter experts.  If you can get more accuracy than you expect, this can lead to errors and additional complexity.  If you get less than the required accuracy - it will also cause problems and the failure of business logic.  It is important that we determine the expected and necessary level of accuracy. </p><br><p>  Also, choose accuracy separately for each use case.  Rounding is usually implemented within the value-object, and not at the level of the system clock.  In some places, nanosecond accuracy is needed, but someone may need only a year.  Proper accuracy will make your code more clear. </p><br><h2 id="ono-vezde">  It is everywhere </h2><br><p>  It is worth noting that we talked about only one specific type of error: the discrepancy between the required accuracy for checks.  But this advice applies to a much wider range of errors.  I will not go into all of them, but I still want to mention my favorite, ‚Äúresidual‚Äù error. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// ,   21 ,       28  $oneWeekFromNow = new DateTimeImmutable('+7 days'); //  28     $explicitDate = new DateTimeImmutable('2017-06-28'); // ,    ? var_dump($oneWeekFromNow == $explicitDate);</span></span></code> </pre> <br><p>  No, they are not the same, because <code>$oneWeekFromNow</code> also stores the current time, while <code>$explicitDate</code> is <code>00:00:00</code> .  Delightful. </p><br><p>  The above examples talked about accuracy, in the first place, when comparing time versus date, but precision modeling extends to any unit of time.  Imagine how many applications for planning need only time, and how many financial applications need precision support by quarter. </p><br><p>  As soon as you begin to look at the problem, you understand how many errors over time can be explained by uncertainty.  They may look like incorrect checks or poorly designed logical frames, but when you dive into this, you will begin to see how the picture emerges. </p><br><p>  My experience shows that this class of errors is often overlooked when testing.  Objects with a system clock are not familiar things (yet), so testing code that uses the current time is a bit more complicated.  Data for tests is often not provided in the format that is obtained in the system, which leads to errors. </p><br><p>  And this is not the problem of a specific <code>DateTime</code> library in PHP.  When I wrote about this last week, Anthony Ferrara mentioned that the accuracy of time in Ruby varies depending on the operating system, but the database library has a fixed level.  It's fun to debug </p><br><p>  Work with time is difficult.  Compare the time - doubly. </p><br><h2 id="vybor-urovnya-tochnosti">  Accuracy level selection </h2><br><p>  Saying that the choice of the accuracy level is important, we did not talk about how to choose the right one.  As a rule, you need to have sufficient accuracy of time stamps for technical needs and at the same time set the level of accuracy for domain objects. </p><br><p>  For logs, event markers, metrics, select a drilldown as desired.  Such data is primarily necessary for technicians, for them additional accuracy is often necessary when debugging.  It is also likely that high accuracy will be required for system or serial data. </p><br><p>  In the case of business problems, talk to subject matter experts about the accuracy of the information you need.  They can help balance what is being used now and what is needed in the future.  Business logic is often an area where you have to operate with borrowed knowledge, so reducing complexity will be a smart move.  Remember, you are not building a model right-as-in-real-life, you are building a utility model. </p><br><p>  In life, this leads to the need for varying degrees of accuracy, even within the same class.  Consider this application class: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderShipped</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   - (),     private $estimatedDeliveryDate; //   - (),     private $shippedAt; // Event sourcing ,     private $eventRecordedAt; }</span></span></code> </pre> <br><p>  If the presence of several levels of accuracy seems strange, I remind you that these time stamps are used differently.  Even <code>$shippedAt</code> and <code>$eventRecordedAt</code> point to the same "time", but they relate to completely different parts of the code. </p><br><p>  You may come across a business that works with blocks of time that you may not expect: quarters, financial calendars, shifts, division by morning, afternoon, or evening.  A lot of interesting experience will work when working with these additional units. </p><br><h1 id="izmenenie-trebovaniy">  Changing requirements </h1><br><p>  Another good part of the discussion is that if business rules change in the future, more accuracy is needed than initially agreed, this will be a joint decision and it will become clear what to do with the data already accumulated.  Ideally, this will save the business from technical problems. </p><br><p>  It's easy: "Initially, it only required the registration date, but now it takes time to see the registration before the office closes time."  A simple solution would be to set the time until the next business day, perhaps a small number of accounts would be incorrect, but acceptable for most.  Or just zeros.  Or the company has additional business rules, when after 18-00 the subscription end date is set to <code>tomorrow +1 year</code> instead of <code>today +1 year</code> .  Discuss this with them.  People are more active and loyal to change, if they are included in the discussion from the very beginning. </p><br><p>  In more complex cases, refer to data recovery based on other data in the system.  Perhaps the registration time is stored in logs or metrics.  In some cases, it will be impossible to do this and you will have to create new logic to transfer legacy cases.  But it is impossible to plan everything, and, most likely, you do not know what will change.  That's life. </p><br><p>  My conclusion about the accuracy of time: use what you need, no more. </p><br><h2 id="prilozhenie-idealnoe-reshenie">  Appendix: The Perfect Solution </h2><br><p>  Moving forward, I feel that there is a practical benefit from the choice of fixed precision and the use of classes.  My ideal PHP library for working with time would look like this: a set of abstract classes denoting accuracy, from which I inherit in my value-objects and use it when comparing. </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpectedDeliveryDate</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PointPreciseToDate</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderShippedAt</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PointPreciseToMinute</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventGenerationTime</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PointPreciseToMicrosecond</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Moving the question of accuracy to the class, we take responsibility for the decision.  You can limit the methods, such as <code>setTime()</code> to the required accuracy, round <code>DateInterval</code> , do everything that makes sense when working with time.  We encapsulate most methods of value-objects and expose only the ones necessary for the domain.  In addition, in this way we will encourage people to create value-objects themselves.  Highly.  Lot.  Value objects.  Daaaaaa. </p><br><p>  The bonus will be if the library allows you to easily define custom time units. </p><br><p>  Has anyone done this?  Does anyone have no time? </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/335494/">https://habr.com/ru/post/335494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335480/index.html">Learn App Shortcuts on Android Nougat 7.1</a></li>
<li><a href="../335484/index.html">Create a checklist for helpdesk implementation</a></li>
<li><a href="../335488/index.html">Rethinking PID 1. Part 2</a></li>
<li><a href="../335490/index.html">Developing a telegram bot using Spring</a></li>
<li><a href="../335492/index.html">Information economy: why the cost of technology companies is so high</a></li>
<li><a href="../335498/index.html">Cursed Earths - We improve running and experience with teammates</a></li>
<li><a href="../335504/index.html">Getting root access to LG smart TVs on webOS</a></li>
<li><a href="../335506/index.html">‚ÄúOne of the daily processes accelerates from 3 hours to 15 minutes‚Äù: Andrei Bogoslovsky about in-memory computing at SberTech</a></li>
<li><a href="../335508/index.html">Emulator in the emulator for playing chip-tunes on YM2149F</a></li>
<li><a href="../335512/index.html">Using ImGui with SFML to create game development tools</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>