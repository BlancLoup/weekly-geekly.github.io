<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Objects of zero size</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is the difference between the following pairs of lengths and pointers? 



size_t len1 = 0; char *ptr1 = NULL; size_t len2 = 0; char *ptr2 = mall...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Objects of zero size</h1><div class="post__text post__text-html js-mediator-article">  What is the difference between the following pairs of lengths and pointers? <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr1 = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr2 = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len3 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr3 = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">4096</span></span>) + <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len4 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ptr4[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len5 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ptr5[];</code> </pre> <br><br>  In many cases, all five expressions will produce the same result.  In others, their behavior may be completely different.  One of the obvious differences is the ability to pass a pointer to release it, but we will not consider it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first case is interesting, but it is too different from the others, so we will postpone it for now. <br><br><h4>  malloc (0) </h4><br>  The behavior of malloc (0) is defined by standards.  You can return a null or unique pointer.  The second option in many implementations is performed by an internal increase in length by one (which is then usually rounded to 16).  According to the rules, such a pointer cannot be dereferenced, but usually several bytes are still allocated, and therefore such a program will not fall. <br><br>  Returning NULL leads to the possibility of an interesting bug.  Often, returning NULL from malloc is considered an error. <br><a name="habracut"></a><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ptr = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(len)) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) err(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"out of memory"</span></span>);</code> </pre><br><br>  If len is zero, it will lead to an illegal error message - if you do not add an additional check &amp;&amp; len! = 0. You can also join the sect of adherents of "not checking malloc". <br><br>  In OpenBSD, malloc handles zero differently.  Placing data of zero size returns pieces of pages that were protected via mprotect () with the PROT_NONE key.  Attempting to dereference such a pointer will result in a fall. <br><br>  Note that the requirements for unique signs prohibit ‚Äúcheating‚Äù when using them. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> thezero; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;thezero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == &amp;thezero) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br><br>  Such an implementation does not comply with the rules, since successive calls will return the same value.  Therefore, the second case is similar to both the first and the third, depending on the implementation. <br><br><h4>  Other cases </h4><br>  If malloc does not generate an error, then options 3, 4, and 5 in most cases work identically.  The main difference will be in the use of sizeof (ptr) / sizeof (ptr [0]), for example in a loop.  This will lead to an incorrect answer, the correct answer, or nothing at all, breaking off at the compilation stage.  The 4th version is not allowed by the standard, but the compilers will most likely swallow it. <br><br>  The biggest difference between these options and the first one is that they are tested for null.  It will be like the difference between an empty array and a missing array.  And in the same way, an empty string is not equal to a null string, although it occupies one byte in memory. <br><br><h4>  null objects </h4><br>  Let's return to the first variant and zero objects.  Consider the following challenge: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(ptr, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br><br>  0 bytes ptr assign 0. Which of the five pointers listed will make such a call?  3, 4 and 5. 2nd - if this is a unique pointer.  But what if ptr is NULL? <br><br>  Standard C in the section "Using Library Functions" says: <br><blockquote>  If the function argument has an invalid value (the value is outside the domain of the function, the pointer points to memory outside the scope of the available program, or the pointer is zero), then the behavior will not be determined. </blockquote><br>  The section "Agreements on the functions of working with strings" specifies: <br><blockquote>  If the argument declared as size_t n determines the length of the array in the function, the value of n can be zero when calling this function.  Unless the description of a particular function specifies the opposite, the values ‚Äã‚Äãof the pointer arguments must be valid. </blockquote><br>  Apparently, the result of memset'a 0 bytes to NULL will be undefined.  The documentation for memset, memcpy and memmove does not indicate that they can accept null pointers.  As a counterexample, a description of snprintf can be given, which says: "If n is zero, nothing is written, and s can be a null pointer."  POSIX's read function documentation describes in a similar way that a zero-length read is not considered an error, but an implementation can check other parameters for an error ‚Äî for example, invalid buffer pointers. <br><br>  And what in practice?  The easiest way to handle zero length in memset or memcpy functions is to not go into a loop and do nothing.  Usually, in C, an undefined behavior causes some kind of reaction, but in this case it is already determined that nothing happens with normal pointers.  Checking for pointer abnormalities would be redundant. <br><br>  Checking for non-zero, but invalid pointers is quite complicated.  memcpy doesn't do that at all, letting the program just drop.  The read call also does not check anything.  It delegates a check to the copyout function, which gets the handler to detect errors.  And although you can add a check for null, such pointers are no more invalid for these functions than 0x1 or 0xffffffff, for which there is no special processing. <br><br><h4>  Bummer </h4><br>  In practice, this means that there is a large amount of code that implies (either intentionally or accidentally) that null pointers and zero length are valid.  I decided to conduct an experiment by adding error output and output to memcpy, in case the pointer turns out to be NULL, and installed a new libc. <br><br><pre> <code class="bash hljs">Feb 11 01:52:47 carbolite xsetroot: memcpy with NULL Feb 11 01:53:18 carbolite last message repeated 15 <span class="hljs-built_in"><span class="hljs-built_in">times</span></span></code> </pre><br><br>  Yeah, it didn't take long.  I wonder what he does there: <br><br><pre> <code class="bash hljs">Feb 11 01:53:18 carbolite gdb: memcpy with NULL Feb 11 01:53:19 carbolite gdb: memcpy with NULL</code> </pre><br><br>  Clearly understood.  These messages seem to get tired very quickly.  We return everything as it was. <br><br><h4>  Effects </h4><br>  I dealt with this question, since at the intersection of the fields it is ‚Äúnot determined, but it should work‚Äù and the optimization of the C compilers does nothing good.  A smart compiler can see the memcpy call, mark both pointers as valid, and remove null checks. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> backup; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptr) len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;backup, ptr, len); }</code> </pre><br><br>  But the code above will obviously not work as it should, if the compiler removes the check for zero and a null pointer will be passed. <br><br>  This question worries me because in the past I have come across cases when such optimization of dereferencing and checking has led to security gaps.  For software that is not ready for such a high level of compliance with standards, this is quite sad news. <br><br>  At first, I was unable to convince the compiler to remove the check for zero after memcpy ‚Äúdereferencing‚Äù, but this does not mean that this cannot happen.  gcc 4.9 says that this check will be removed by optimization.  In OpenBSD, the gcc 4.9 package (containing many patches) does not delete the default check, even if ‚ÄìO3, but if you enable "-fdelete-null-pointer-checks", this deletes the checks.  I do not know what about the clang - the first tests show that it does not remove, but there are no guarantees.  In theory, he will also be able to carry out such optimization. </div><p>Source: <a href="https://habr.com/ru/post/268989/">https://habr.com/ru/post/268989/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268977/index.html">Mental Labor and Physical Education</a></li>
<li><a href="../268979/index.html">Visualization of static and dynamic networks on R, part 7, the last</a></li>
<li><a href="../268981/index.html">Adobe has released an emergency update for Flash Player.</a></li>
<li><a href="../268983/index.html">How to calculate everything in the world by a single SQL query. PostgreSQL window functions</a></li>
<li><a href="../268987/index.html">Accelerate Android code</a></li>
<li><a href="../268991/index.html">Pagination of lists in Android with RxJava. Part I</a></li>
<li><a href="../268993/index.html">Remote execution of system commands on request via sockets in Python 3 or how I downloaded the sites</a></li>
<li><a href="../268995/index.html">FlexPod DataCenter: Direct-Attached Storage</a></li>
<li><a href="../268997/index.html">Frida-node or a little bit strange code</a></li>
<li><a href="../268999/index.html">How did Cisco Security Ninja teach 20,000 employees to secure programming?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>