<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 22. Mailboxes: ancillary services and data structures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article continues the review of mailboxes that was started in the previous article in the series The Entire Truth About RTOS. 

 Previous article...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 22. Mailboxes: ancillary services and data structures</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/j-/7m/ne/j-7mne20kyhq0wia5-mxp4lotsq.jpeg"><br><br>  This article continues the review of mailboxes that was started in the previous article in the series The Entire Truth About RTOS. <br><a name="habracut"></a><br>  Previous articles in the series: <br><br>  <a href="https://habr.com/post/430856/">Article # 21.</a>  <a href="https://habr.com/post/430856/">Mailboxes: Introduction and Basic Services</a> <br>  <a href="https://habr.com/post/429588/">Article # 20.</a>  <a href="https://habr.com/post/429588/">Semaphores: helper services and data structures</a> <br>  <a href="https://habr.com/post/429156/">Article # 19.</a>  <a href="https://habr.com/post/429156/">Semaphores: introduction and basic services</a> <br>  <a href="https://habr.com/post/428890/">Article # 18.</a>  <a href="https://habr.com/post/428890/">Event flag groups: helper services and data structures</a> <br>  <a href="https://habr.com/post/428131/">Article # 17.</a>  <a href="https://habr.com/post/428131/">Event flag groups: introduction and basic services</a> <br>  <a href="https://habr.com/post/427439/">Article # 16.</a>  <a href="https://habr.com/post/427439/">Signals</a> <br>  <a href="https://habr.com/post/426477/">Article # 15.</a>  <a href="https://habr.com/post/426477/">Memory sections: services and data structures</a> <br>  <a href="https://habr.com/post/426425/">Article # 14.</a>  <a href="https://habr.com/post/426425/">Memory sections: introduction and basic services</a> <br>  <a href="https://habr.com/post/425353/">Article # 13.</a>  <a href="https://habr.com/post/425353/">Task data structures and unsupported API calls</a> <br>  <a href="https://habr.com/post/424713/">Article # 12.</a>  <a href="https://habr.com/post/424713/">Task Services</a> <br>  <a href="https://habr.com/post/424481/">Article # 11.</a>  <a href="https://habr.com/post/424481/">Tasks: configuration and introduction to the API</a> <br>  <a href="https://habr.com/post/423967/">Article # 10.</a>  <a href="https://habr.com/post/423967/">Scheduler: additional features and context preservation</a> <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <a href="https://habr.com/post/414093/"><br></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Mailbox Support Services </h2><br>  Nucleus RTOS has four API calls that provide helper functions related to mailboxes: reset the mailbox, get information about the mailbox, get the number of mailboxes in the application, and get pointers to all the mailboxes in the application.  The first three of these functions are implemented in the Nucleus SE. <br><br><h3>  Mailbox reset </h3><br>  This API service call resets the mailbox to its initial, unused state.  The message stored in the mailbox will be lost.  Any tasks suspended on the mailbox will resume with the return code <b>NUSE_MAILBOX_WAS_RESET</b> . <br><br>  <b><i>Call to reset the mailbox in the Nucleus RTOS</i></b> <br>  Service Call Prototype: <br>  <b>STATUS NU_Reset_Mailbox (NU_MAILBOX * mailbox);</b> <br><br>  Options: <br>  <b>mailbox</b> - a pointer to the mailbox control block. <br><br>  Return value: <br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_MAILBOX</b> - invalid mailbox pointer. <br><br>  <b><i>Call to reset a mailbox in Nucleus SE</i></b> <br>  This API service call supports the core functionality of the Nucleus RTOS API. <br><br>  Service Call Prototype: <br>  <b>STATUS NUSE_Mailbox_Reset (NUSE_MAILBOX mailbox);</b> <br><br>  Options: <br>  <b>mailbox</b> - the index of the <b>mailbox to</b> be reset. <br><br>  <b>Return value:</b> <br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_MAILBOX</b> - invalid mailbox index. <br><br>  <b><i>Implementing a mailbox reset in Nucleus SE</i></b> <br>  The option code for the <b>NUSE_Mailbox_Reset</b> function (after checking the parameters) is selected using conditional compilation, depending on whether support for blocking (suspending) tasks is activated or not.  We will consider both of these options. <br><br>  If the lock is not activated, the code for this API function is quite simple.  A mailbox is marked as unused by setting the <b>NUSE_Mailbox_Status []</b> parameter to <b>FALSE</b> . <br><br>  If the lock is activated, the code becomes more complex: <br><br><pre><code class="plaintext hljs">while (NUSE_Mailbox_Blocking_Count[mailbox] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this mailbox */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_MAILBOX_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == mailbox)) { NUSE_Task_Blocking_Return[index] = NUSE_MAILBOX_WAS_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Mailbox_Blocking_Count[mailbox]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  The mailbox is reset to the ‚ÄúEmpty‚Äù state. <br><br>  Each suspended task on the mailbox is assigned the status ‚Äúready‚Äù with the return code <b>NUSE_MAILBOX_WAS_RESET</b> .  After this process is completed, if the Priority scheduler is used, the service call <b>NUSE_Reschedule ()</b> is executed, since one or more tasks with higher priority could become ready and wait for execution permission. <br><br><h3>  Retrieving Mailbox Information </h3><br>  This service call provides a set of mailbox information.  The implementation of this call in the Nucleus SE differs from the Nucleus RTOS in that it returns less information, since the naming of objects and the pause order are not supported, and the pause of tasks can be disabled. <br><br>  <b><i>Call for information about the mailbox in the Nucleus RTOS</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br>  <b>STATUS NU_Mailbox_Information (NU_MAILBOX * mailbox, CHAR * name, OPTION * suspend_type, DATA_ELEMENT * message_present, UNSIGNED * tasks_waiting, NU_TASK ** first_task);</b> <br><br>  Options: <br><br>  <b>mailbox</b> - a pointer to the mailbox control unit; <br>  <b>name</b> - pointer to the 8-character field for the mailbox name.  The terminating zero byte is included in this area; <br>  <b>suspend_type</b> - pointer to the variable that stores the type of task suspension.  It can be <b>NU_FIFO</b> and <b>NU_PRIORITY</b> ; <br>  <b>message_present</b> - a pointer to a variable that will take the value <b>NU_TRUE</b> or <b>NU_FALSE</b> , depending on whether the mailbox is full or not; <br>  <b>tasks_waiting</b> - pointer to a variable that will receive the number of tasks suspended on this mailbox; <br>  <b>first_task</b> is a pointer to a task pointer that will take a pointer to the first suspended task. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_MAILBOX</b> - invalid mailbox pointer. <br><br>  <b><i>Call for information about the Nucleus SE mailbox</i></b> <br>  This API service call supports the core functionality of the Nucleus RTOS API. <br><br>  Service Call Prototype: <br><br>  <b>STATUS NUSE_Mailbox_Information (NUSE_MAILBOX mailbox, U8 * message_present, U8 * tasks_waiting, NUSE_TASK * first_task);</b> <br><br>  Options: <br><br>  <b>mailbox</b> - <b>mailbox</b> index for which information is requested; <br>  <b>message_present</b> - a pointer to a variable that will take the value <b>TRUE</b> or <b>FALSE</b> , depending on whether the mailbox is full or not; <br>  <b>tasks_waiting</b> - pointer to a variable that will accept the number of tasks suspended on this mailbox (nothing is returned if task suspension is disabled); <br>  <b>first_task</b> - a pointer to a variable of type <b>NUSE_TASK</b> , which will accept the index of the first suspended task (nothing is returned if the suspension of tasks is disabled). <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_MAILBOX</b> - invalid mailbox index; <br>  <b>NUSE_INVALID_POINTER</b> - one or more pointer parameters is incorrect. <br><br>  <b><i>Implementing Mailbox Information in Nucleus SE</i></b> <br><br>  The implementation of this API call is quite simple: <br><br><pre> <code class="plaintext hljs">*message_present = NUSE_Mailbox_Status[mailbox]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Mailbox_Blocking_Count[mailbox]; if (NUSE_Mailbox_Blocking_Count[mailbox] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_MAILBOX_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == mailbox)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif return NUSE_SUCCESS;</code> </pre><br>  The function returns the status of the mailbox.  Then, if service calls for blocking tasks are activated, the number of suspended tasks and the index of the first one are returned (otherwise, these parameters are assigned the value 0). <br><br><h3>  Getting the number of mailboxes </h3><br>  This service call returns the number of mailboxes in the application.  While in Nucleus RTOS, their number may change over time, and the return value will show the current number of mailboxes, in Nucleus SE, the number of mailboxes is set at the build stage and cannot be changed. <br><br>  <b><i>Call to Mailbox Counter in Nucleus RTOS</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br>  <b>UNSIGNED NU_Established_Mailboxes (VOID);</b> <br><br>  Options: <br>  None. <br><br>  Return value: <br>  The number of mailboxes created in the application. <br><br>  <b><i>Call to Mailbox Counter in Nucleus SE</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br>  <b>U8 NUSE_Mailbox_Count (void);</b> <br><br>  Options: <br>  None. <br><br>  Return value: <br>  The number of configured mailboxes in the application. <br><br>  <b><i>Implementing a Mailbox Counter in Nucleus SE</i></b> <br>  The implementation of this API call is extremely simple: the value of the <b>#define</b> <b>NUSE_MAILBOX_NUMBER</b> directive is <b>returned</b> . <br><br><h2>  Data structures </h2><br>  Mailboxes use two or three arrays of data structures (all of them are in RAM), which, like other objects of Nucleus SE, are sets of tables whose size depends on the number of configured mailboxes and their parameters. <br><br>  I strongly recommend that the application code does not use direct access to these data structures, but access them through the provided API functions.  This avoids incompatibility with future versions of the Nucleus SE and unwanted side effects, and also simplifies porting the application to the Nucleus RTOS.  Below is a detailed overview of the data structures for a better understanding of how the service call code works and for debugging. <br><br><h3>  Data in ram </h3><br>  This data has the following structure: <br><br>  <b>NUSE_Mailbox_Data []</b> is an array of type <b>ADDR</b> that has one entry for each configured mailbox, it stores mailbox data. <br>  <b>NUSE_Mailbox_Status []</b> is an array of type <b>U8</b> , having one entry for each configured mailbox, it tracks mailbox usage.  A non-zero value ( <b>TRUE</b> ) indicates that the mailbox is full. <br>  <b>NUSE_Mailbox_Blocking_Count []</b> is an array of type <b>U8</b> , it contains a counter of blocked tasks for each mailbox.  This array is created only if support for API call blocking functionality is activated. <br><br>  These data structures are initialized with zeros in the <b>NUSE_Init_Mailbox ()</b> function when Nucleus SE is started.  This is logical, since each mailbox is created empty (unused). <br><br>  The following are the definitions of these data structures from the <b>nuse_init.c</b> file. <br><br><pre> <code class="plaintext hljs">RAM ADDR NUSE_Mailbox_Data[NUSE_MAILBOX_NUMBER]; RAM U8 NUSE_Mailbox_Status[NUSE_MAILBOX_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Mailbox_Blocking_Count[NUSE_MAILBOX_NUMBER]; #endif</code> </pre><br><h3>  ROM data </h3><br>  For the implementation of mailboxes are not used data in the ROM. <br><br><h3>  Mailbox Memory Capacity </h3><br>  As with all Nucleus SE core objects, the amount of memory required for mailboxes is known in advance. <br><br>  The amount of memory for data in the ROM for all mailboxes in the application is 0. <br><br>  The amount of data in RAM for all mailboxes in the application (in bytes) with activated API calls to block tasks can be calculated as follows: <br>  <b>NUSE_MAILBOX_NUMBER * (sizeof (ADDR) +2)</b> <br><br>  Otherwise: <br>  <b>NUSE_MAILBOX_NUMBER * (sizeof (ADDR) +1)</b> <br><br><h2>  Unrealized API calls </h2><br>  The four service calls that can be found in the Nucleus RTOS are not implemented in the Nucleus SE. <br><br><h3>  Create mailbox </h3><br>  This API service call creates a mailbox.  In the Nucleus SE, it is not necessary, since mailboxes are created statically. <br><br>  Service Call Prototype: <br>  <b>STATUS NU_Create_Mailbox (NU_MAILBOX * mailbox, CHAR * name, UNSIGNED OPTION suspend_type);</b> <br><br>  Options: <br><br>  <b>mailbox</b> - pointer to the mailbox control unit provided by the user;  used to manage mailboxes in other API calls; <br>  <b>name</b> - pointer to the 7-character mailbox name with zero terminating byte; <br>  <b>suspend_type</b> - indicates the principle of suspending the task on the mailbox.  It can take the values <b>NU_FIFO</b> and <b>NU_PRIORITY</b> , which means the principle of FIFO (First-In-First-Out) or the principle of priority of task suspension, respectively. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_MAILBOX</b> - null pointer to the mailbox control block ( <b>NULL</b> ), or the pointer is already in use; <br>  <b>NU_INVALID_SUSPEND</b> is an invalid <b>suspend_type</b> parameter. <br><br><h3>  Deleting a mailbox </h3><br>  This API service call deletes a previously created mailbox.  This is not necessary in the Nucleus SE, since mailboxes are created statically and cannot be deleted. <br><br>  Service Call Prototype: <br><br>  <b>STATUS NU_Delete_Mailbox (NU_MAILBOX * mailbox);</b> <br><br>  Options: <br><br>  <b>mailbox</b> - a pointer to the mailbox control block. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_MAILBOX</b> - invalid mailbox pointer. <br><br><h3>  Mailbox Pointers </h3><br>  This API call makes a sequential list of pointers to all mailboxes in the system.  In the Nucleus SE, it is not necessary, since the mailboxes are identified using a simple index, not a pointer. <br><br>  Service Call Prototype: <br><br>  <b>UNSIGNED NU_Mailbox_Pointers (NU_MAILBOX ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Options: <br><br>  <b>pointer_list</b> - pointer to the array of pointers <b>NU_MAILBOX</b> ;  this array will be filled with pointers to the mailboxes created in the system; <br>  <b>maximum_pointers</b> - the maximum number of pointers in the array. <br><br>  Return value: <br><br>  The number of <b>NU_MAILBOX</b> pointers in the array. <br><br><h3>  Write a message to the mailbox for delivery to all recipients </h3><br>  This service call sends a message to all tasks waiting for messages from a specific mailbox.  In Nucleus SE, this service call is not implemented, as it would add unnecessary complexity. <br><br>  Service Call Prototype: <br><br>  <b>STATUS NU_Broadcast_To_Mailbox (NU_MAILBOX * mailbox, VOID * message, UNSIGNED suspend);</b> <br><br>  Options: <br><br>  <b>mailbox</b> - a pointer to the mailbox control unit; <br>  <b>message</b> - pointer to the message being sent; <br>  <b>suspend</b> - indicates whether the calling task should be suspended if the mailbox already contains a message;  can be <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND,</b> or timeout value. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_MAILBOX</b> - invalid mailbox pointer; <br>  <b>NU_INVALID_POINTER</b> - null pointer to the message ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> - an attempt to pause from a <b>thread that</b> is not associated with the task; <br>  <b>NU_MAILBOX_FULL</b> - the mailbox already contains the message; <br>  <b>NU_TIMEOUT</b> - after the timeout expires, the mailbox is still full; <br>  <b>NU_MAILBOX_DELETED</b> - the mailbox was deleted while the task was suspended. <br>  <b>NU_MAILBOX_RESET</b> - the mailbox was reset while the task was suspended. <br><br><h2>  Nucleus RTOS Compatibility </h2><br>  As with all other Nucleus SE objects, my goal was to ensure maximum compatibility of application code with Nucleus RTOS.  Mailboxes are no exception and, from the user's point of view, they are implemented in the same way as in the Nucleus RTOS.  There is a certain incompatibility, which I considered acceptable, given that as a result, the code will become more understandable and more efficient in terms of the amount of memory required.  Otherwise, Nucleus RTOS API calls can be almost directly transferred to the Nucleus SE. <br><br><h3>  Object IDs </h3><br>  In Nucleus RTOS, all objects are described by data structures (control units) of a particular type.  A pointer to this control unit serves as a mailbox identifier.  I decided that in the Nucleus SE, a different approach is needed for effective memory use: all kernel objects are described by a set of tables in RAM and / or ROM.  The size of these tables is determined by the number of configured objects of each type.  The identifier of a particular object is the index in this table.  Thus, I have defined the <b>NUSE_MAILBOX</b> as equivalent to <b>U8</b> , the variable (and not the pointer) of this type serves as the mailbox identifier.  This small incompatibility is easy to handle if the code is ported from the Nucleus SE to the Nucleus RTOS and vice versa.  Usually no operations are performed on object identifiers, except for moving and storing. <br><br>  Nucleus RTOS also supports mailbox naming.  These names are used only when debugging.  I excluded them from the Nucleus SE to save memory. <br><br><h3>  Message size and type </h3><br>  In the Nucleus RTOS, a mailbox message consists of four 32-bit words.  In Nucleus SE, I decided to reduce this value to one variable of type <b>ADDR</b> .  This change leads to significant memory savings and reduced task execution time.  It also says that the usual use of the mailbox is to send information from one task to another.  This incompatibility will not cause major problems when porting applications to the Nucleus RTOS.  Nucleus SE can be modified if a different message format is needed. <br><br><h3>  Unrealized API calls </h3><br>  Nucleus RTOS supports nine mailbox service calls.  Of these, four are not implemented in the Nucleus SE.  The details of these calls, as well as the reasons why they were excluded from the Nucleus SE, are described above. <br><br>  The next article will be considered queues. <br><br>  <b>About the author:</b> Colin Walls has been working in the electronics industry for more than thirty years, spending a significant amount of time on embedded software.  He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics).  Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software.  Lives in the UK.  <a href="http://blogs.mentor.com/colinwalls">Colin's</a> professional <a href="http://blogs.mentor.com/colinwalls">blog</a> , e-mail: colin_walls@mentor.com. </div><p>Source: <a href="https://habr.com/ru/post/431118/">https://habr.com/ru/post/431118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431108/index.html">How to turn satellite images into maps. Computer vision in Yandex</a></li>
<li><a href="../431110/index.html">Stop feeding publishers. EU develops rules for compulsory free access to research</a></li>
<li><a href="../431112/index.html">How to use least squares methods for resource assessment and monitoring of Oracle databases</a></li>
<li><a href="../431114/index.html">Facebook for the first time closed access to some publications for Russian IP-addresses.</a></li>
<li><a href="../431116/index.html">Want strange: a review of the upcoming conference DartUP in St. Petersburg</a></li>
<li><a href="../431120/index.html">Suffering at work is not necessary</a></li>
<li><a href="../431122/index.html">Grafana as another tool for technical monitoring of the software products we create.</a></li>
<li><a href="../431124/index.html">"Data Science, like mathematics and physics, is another way to learn about the world around you"</a></li>
<li><a href="../431126/index.html">Why you should not save on a professional PM</a></li>
<li><a href="../431128/index.html">Hackay DDR3 SPD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>