<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Immersion in Robolectric</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the Android world, development is increasingly using unit testing. Checking the correct operation of individual modules of the application helps to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Immersion in Robolectric</h1><div class="post__text post__text-html js-mediator-article"><p>  In the Android world, development is increasingly using unit testing.  Checking the correct operation of individual modules of the application helps to identify and eliminate errors in the code at an early stage.  Coupled with assembly automation, component and integration tests, unit tests allow you to make a quality product, regardless of the size of your development team. </p><br><p>  Under the cut, I‚Äôll tell you about the internal device framework for unit-testing Android applications - Robolectric. </p><br><img src="https://habrastorage.org/files/205/1fc/321/2051fc321af846acbefcc97e93482efe.png"><br><a name="habracut"></a><br><h1 id="zachem-testirovat-android-specifichnyy-kod">  Why test Android-specific code? </h1><br><p>  First we will try to answer the question - why test the code in the field of integration with the Android framework? </p><br><ul><li><p>  Resources - it is worth testing the correctness of using certain string or any other application resources, since  they are an integral part of business requirements. </p><br></li><li><p>  Parcelable - regardless of whether you use the automatic generation of Parcelable or write the implementation manually, you should test the correctness of restoring objects from their serialized representation. </p><br></li><li><p>  SQLite - data migration testing, schema changes, adding new tables, query execution correctness. </p><br></li><li><p>  Intent / Bundle - for some scenarios it is important to check the correctness of filling the Intent, flags with which the next Activity or Service will be launched. </p><br></li><li>  Non-UI system components, such as Camera, MediaPlayer, MediaRecorder, various managers, etc. </li></ul><br><p>  This is only part of the scenarios in which code testing in the field of integration with Android becomes an urgent task. </p><br><h1 id="problemy-testirovaniya-koda-ispolzuyuschego-android">  Problems testing code using Android </h1><br><p>  When trying to solve this problem head on you may encounter the following problems: </p><br><p> <code>RuntimeException</code> with the cause - <code>method not mocked</code> when trying to run a test code of a framework calling some method.  And if you use the following option in Gradle - </p><br><pre> <code class="hljs objectivec">testOptions { unitTests.returnDefaultValues = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  then, <code>RuntimeException</code> will not be thrown.  This behavior can lead to heavily detectable errors in the tests. </p><br><p>  Another problem of testing are <code>final</code> classes and a great many <code>static</code> methods of the framework, which further complicates testing the code that uses it. </p><br><h1 id="puti-resheniya">  Solutions </h1><br><p>  For all the above problems, there are certain solutions: </p><br><ul><li><p>  Use primitive testable wrappers over the places where your code integrates with the framework.  In your tests, you wash the wrapper and test its interaction with your code.  Testing the wrapper in mind its simple implementation omit.  Although in reality this wrapper should be tested, but it will remain primitive for a short time.  In the end, you‚Äôll get tired of duplicating the implementation of the Android framework for testing.  Do not forget about the increase in the number of methods in your APK, to which this approach will lead. </p><br></li><li><p>  Instrumented unit tests - the most accurate test option.  Tests are performed on a real device or emulator in a real environment.  But you will have to pay for this by a long compilation, packaging the APK, and slow execution of the tests. </p><br></li><li>  PowerMock + Mockito - PowerMock allows you to get <code>static</code> methods and <code>final</code> classes.  In this case, you will have to partially repeat the behavior of some Android classes, which can lead to swelling of the code responsible for preparing mocks in your tests and complicate their support in the future. </li></ul><br><h1 id="robolectric">  Robolectric </h1><br><p>  There is another solution to the problem of Unit-testing Android applications - Robolectrics.  Robolectric is a framework developed by PivotalLabs in 2010.  He is in an intermediate position between the ‚Äúbare‚Äù JUnit tests and instrumented tests run on the device, simulating the real Android environment.  The framework is a compiled <strong>android.jar</strong> with a bundle of utilities for running tests and simplifying testing.  It supports resource loading, a primitive view blowing implementation, provides local SQLite ( <em>sqlite4java</em> ), easily customizable and extensible. </p><br><h1 id="ispolzuem-androidutillog">  Use android.util.Log </h1><br><p>  Suppose we are developing a library for third-party developers and want to make sure that our library prints some important information in Logcat. </p><br><p>  Implement the following interface - <code>Logger</code> , with one method for displaying messages of the ‚ÄúInfo‚Äù level. </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tag: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, throwable: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">? = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br><p>  Let's write the <code>AndroidLogger</code> implementation - which will use <code>android.util.Log</code> . </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AndroidLogger</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> { override fun info(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tag</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">throwable</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Throwable</span></span></span><span class="hljs-class">?) { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Log</span></span></span><span class="hljs-class">.i(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tag</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">throwable</span></span></span><span class="hljs-class">) } }</span></span></code> </pre> <br><h1 id="testiruem-androidutillog">  We are testing <code>android.util.Log</code> </h1><br><p>  Let's write a Junit test using Robolectric and make sure that the <code>info</code> method of our <code>AndroidLogger</code> implementation actually prints the messages in Logcat with the info level. <br></p><br><pre> <code class="hljs pgsql">@RunWith(RobolectricTestRunner::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) @Config(constants = BuildConfig::<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, sdk = intArrayOf(<span class="hljs-number"><span class="hljs-number">23</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RobolectricAndroidLoggerTest { private val logger: Logger = AndroidLogger() @Test fun `<span class="hljs-keyword"><span class="hljs-keyword">info</span></span> - should <span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> logcat <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-keyword"><span class="hljs-keyword">info</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>`() { val throwable = Throwable() logger.<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>("Tag", "Message", throwable) val logInfo: LogInfo = ShadowLog.getLogs().last() assertThat(logInfo.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Is</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Log</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span>)) assertThat(logInfo.tag, <span class="hljs-keyword"><span class="hljs-keyword">Is</span></span>("Tag")) assertThat(logInfo.msg, <span class="hljs-keyword"><span class="hljs-keyword">Is</span></span>("Message")) assertThat(logInfo.throwable, <span class="hljs-keyword"><span class="hljs-keyword">Is</span></span>(throwable)) } }</code> </pre> <br><p>  Annotation <code>@RunWith</code> we indicate that we will run the test using <code>RobolectricTestRunner</code> .  In the parameters for the <code>@Config</code> annotation, we pass the <code>BuildConfig</code> class and specify the version of the Android SDK that Robolectric will simulate. </p><br><p>  In the test, we call the <code>info</code> method on the <code>AndroidLogger</code> object.  With the help of the <code>ShadowLog</code> class, <code>ShadowLog</code> retrieve the last message recorded in the log and make assert by its contents. </p><br><h1 id="vnutrennee-ustroystvo">  Internal organization </h1><br><p>  The internal structure of the Robolectric can be divided into 3 parts: Shadow classes, <code>RobolectricTestRunner</code> and <code>InstrumentingClassLoader</code> . </p><br><h2 id="shadow-klassy">  Shadow classes </h2><br><p>  The creators of Robolectric introduce a new type of ‚Äútest twins‚Äù (test double) - Shadow.  According to the official website, the Shadows are ‚Äú... not quite Proxies, not quite Fakes, not quite Mocks or Stubs." </p><br><p>  A shadow object exists parallel to a real object and can intercept calls to methods and constructors, thereby changing the behavior of the real object. </p><br><h2 id="svyaz-shadow-c-robolectric">  Shadow connection with Robolectric </h2><br><p>  The <code>@Implements</code> indicates the class for which a particular Shadow class is intended. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Implements</span></span>(className = ContextImpl.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShadowContextImpl</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><p>  In the annotation of the <code>@Config</code> test, you can specify Shadow-classes that are not included in the standard Robolectric package. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Config</span></span>(..., shadows = {CustomShadow.class}, ...) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTest</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br><h2 id="pereopredelenie-metodov">  Redefinition of methods </h2><br><p>  The overridden method in the Shadow class is annotated with @Implementation, it is important to preserve the signature of the original method. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSystemService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  When overriding the native method, the native code word is omitted. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nativeReadLong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nativePtr)</span></span></span></span>;</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Implementation</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nativeReadLong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nativePtr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ... }</code> </pre> <br><h2 id="pereopredelenie-konstruktorov">  Constructor overrides </h2><br><p>  To override the constructor in the Shadow class, the <code>__constructor__</code> constructor <code>__constructor__</code> method is implemented with the same arguments. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Canvas</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Bitmap bitmap)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__constructor__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bitmap bitmap)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetBitmap = bitmap; }</code> </pre> <br><h2 id="vyzov-nastoyaschego-obekta">  Call this object </h2><br><p>  To get a reference to a real object in the Shadow class, it is enough to declare a field with the type of ‚Äúshaded‚Äù object marked with the <code>@RealObject</code> annotation: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RealObject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Context realObject;</code> </pre> <br><p>  Robolectric provides the ability to call a real implementation of the method, bypassing the Shadow implementation, using <code>Shadow.directlyOn</code> . </p><br><pre> <code class="java hljs">Shadow.directlyOn(realObject, <span class="hljs-string"><span class="hljs-string">"android.app.ContextImpl"</span></span>, <span class="hljs-string"><span class="hljs-string">"getDatabasesDir"</span></span>);</code> </pre> <br><h1 id="sobstvennyy-shadow">  Own Shadow </h1><br><p>  Writing your own Shadow-class is not a big problem, even for a third-party library that is not included in the standard distribution with Android. </p><br><p>  Let's write a class that gets a user's token using <code>GoogleAuthUtil</code> . </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleAuthInteractor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">, account: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Account</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GoogleAuthUtil.getToken(context, account, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) } }</code> </pre> <br><p>  Implement the Shadow class for <code>GoogleAuthUtil</code> that allows you to override the <code>token</code> for a specific <code>Account</code> : </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@Implements(GoogleAuthUtil::class)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> ShadowGoogleAuthUtil { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tokens = ArrayMap&lt;Account, String&gt;() <span class="hljs-meta"><span class="hljs-meta">@Implementation</span></span> <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Context</span></span></span></span><span class="hljs-function"><span class="hljs-params">, account: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Account</span></span></span></span><span class="hljs-function"><span class="hljs-params">, scope: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tokens[account].orEmpty() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(account: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Account</span></span></span></span><span class="hljs-function"><span class="hljs-params">, token: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { tokens.put(account, token) } }</code> </pre> <br><p>  Let's write a test for <code>GoogleAuthInteractor</code> using Robolectric.  In the configuration for the test, we indicate that we want to use <code>ShadowGoogleAuthUtil</code> and <code>ShadowGoogleAuthUtil</code> classes from the <code>com.google.android.gms.auth</code> package. </p><br><pre> <code class="hljs kotlin"><span class="hljs-meta"><span class="hljs-meta">@RunWith(RobolectricTestRunner::class)</span></span> <span class="hljs-meta"><span class="hljs-meta">@Config(shadows = arrayOf(ShadowGoogleAuthUtil::class)</span></span>, instrumentedPackages = arrayOf(<span class="hljs-string"><span class="hljs-string">"com.google.android.gms.auth"</span></span>)) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoogleAuthInteractorTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> context = RuntimeEnvironment.application <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> interactor = GoogleAuthInteractor() <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> `provide token - provides token </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> correct account`</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> account = Account(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"type"</span></span>) ShadowGoogleAuthUtil.setToken(account, <span class="hljs-string"><span class="hljs-string">"token"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> token = interactor.getToken(context, account) assertThat(token, Is(<span class="hljs-string"><span class="hljs-string">"token"</span></span>)) } }</code> </pre> <br><h1 id="robolectrictestrunner">  RobolectricTestRunner </h1><br><p>  From the Shadow classes, let's move on to <code>RobolectricTestRunner</code> - this is the first part of the Robolectric that your tests communicate with.  Runner is responsible for dynamic dependency loading (Shadow-classes and <strong>android.jar</strong> for the specified SDK version) during the execution of tests. </p><br><p>  Robolectric is configured by the <code>@Config</code> annotation, with which you can change the parameters of the simulated environment for the test class and for each test separately.  The configuration for running tests will be collected sequentially across the entire hierarchy of the test class from parent to heir, and finally to the method being tested itself.  Configuration allows you to configure: </p><br><ul><li>  Android version </li><li>  path to manifest and resources </li><li>  list of current qualifiers </li><li>  third-party shadow </li><li>  additional package names for instrumentation </li></ul><br><h1 id="instrumentingclassloader">  InstrumentingClassLoader </h1><br><p>  Before running the tests, the <code>RobolectricTestRunner</code> replaces the system <code>ClassLoader</code> with the <code>InstrumentingClassLoader</code> . </p><br><p>  <code>InstrumentingClassLoader</code> provides the connection of real objects with Shadow-classes, the substitution of certain classes for fake classes and the proxying of calls to certain methods to Shadow-classes directly. </p><br><p>  Robolectric does not tool classes from the <code>java.*</code> Package, so method calls that are missing in an ordinary JVM, but added to the Android SDK, are proxied directly to Shadow at the call site. </p><br><p>  In the framework, there are two options for instructing loadable classes.  The original implementation generates a bytecode that uses the internal interface of the <code>ClassHandler</code> and implements its <code>ShadowWrangler</code> class, which essentially wraps each method call through a Shadow class into a separate <code>Runnable</code> similar object and calls it.  In April 2015, <a href="https://github.com/robolectric/robolectric/commit/1021315c11e619e0735bea1349e04023178c4067">a second version of the bytecode modification was added</a> to the project, using the JVM instruction <code>invokeDynamic</code> . </p><br><p>  During the instrumentation, Robolectric adds a <code>ShadowedObject</code> interface to each class loaded with one single method, <code>$$robo$getData()</code> , in which the real object returns its Shadow. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShadowedObject</span></span></span><span class="hljs-class"> </span></span>{ Object $$robo$getData(); }</code> </pre> <br><p>  For each constructor, the <code>InstrumentingClassLoader</code> creates a private <code>$$robo$$__constructor__</code> method with preserving its signature and instructions (except for calling <code>super</code> ). </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(width, height); ... }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> $$robo$$__constructor__(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height) { mWidth = width; mHeight = height; }</code> </pre> <br><p>  In turn, the body of the original constructor will consist of: </p><br><ul><li>  Call <code>super</code> (if the class is an heir) </li><li>  <code>$$robo$init</code> private method, which initializes the <code>__robo_data__</code> private field <code>__robo_data__</code> corresponding Shadow object </li><li>  Call the overridden constructor ( <code>$$robo$$__constructor__</code> ) on the Shadow object, if the Shadow object exists and the corresponding constructor is redefined, otherwise the real implementation will be called ( <code>$$robo$$__constructor__</code> ). </li></ul><br><p>  Constructor modified using <code>invokeDynamic</code> instructions: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$$robo$init(); InvokeDynamicSupport.bootstrap($$robo$$__constructor__(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, width, height); }</code> </pre> <br><p>  Constructor modified using ClassHandler: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$$robo$init(); ClassHandler.Plan plan = RobolectricInternals.methodInvoked(<span class="hljs-string"><span class="hljs-string">"android/util/Size/__constructor__(II)V"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, Size.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (plan != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { plan.run(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, $$robo$getData(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(width), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(height)}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable throwable) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RobolectricInternals.cleanStackTrace(throwable); } } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$$robo$$__constructor__(width, height); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable throwable) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RobolectricInternals.cleanStackTrace(throwable); } }</code> </pre> <br><p>  To instrument the methods, Robolectric uses a similar mechanism, the present method code is allocated to a private method with the <code>$$robo$$</code> prefix and the method call is delegated to the Shadow object. </p><br><p>  Method modified using <code>invokeDynamic</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)InvokeDynamicSupport.bootstrap($$robo$$getWidth(),<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><p>  For <code>native</code> methods, Robolectric omits the corresponding modifier and returns the default value if this method is not overridden in the Shadow class. </p><br><h1 id="proizvoditelnost">  Performance </h1><br><p>  Robolectric is far from the most productive framework.  Running an empty test on the <code>RobolectricTestRunner</code> takes about 2 seconds.  Compared to ‚Äúclean‚Äù JUnit tests, 2 seconds is a significant delay. </p><br><p>  Profiling tests on Robolectric shows that the framework spends most of the time instructing loadable classes. <br>  Below are the results of Robolectric profiling and the PowerMock + Mockito bundles for the <code>android.util.Log</code> test described above. </p><br><p>  Robolectric ~ 2400 ms.: </p><br><table><thead><tr><th>  Method </th><th>  ms </th></tr></thead><tbody><tr><td> <code>java.lang.ClassLoader.loadClass(String)</code> </td> <td>  913 </td></tr><tr><td> <code>org.robolectric.internal.bytecode.InstrumentingClassLoader. <br> getInstrumentedBytes(ClassNode, boolean)</code> </td> <td>  767 </td></tr><tr><td> <code>org.objectweb.asm.tree.ClassNode.accept(ClassVisitor)</code> </td> <td>  407 </td></tr><tr><td> <code>org.objectweb.asm.tree.MethodNode.accept(ClassVisitor)</code> </td> <td>  367 </td></tr><tr><td> <code>org.robolectric.internal.bytecode.InstrumentingClassLoader <br> $ClassInstrumentor.instrument()</code> </td> <td>  298 </td></tr><tr><td> <code>org.objectweb.asm.ClassReader.accept(ClassVisitor, Attribute[], int)</code> </td> <td>  277 </td></tr><tr><td> <code>org.robolectric.shadows.ShadowResources.getSystem()</code> </td> <td>  268 </td></tr></tbody></table><br><p>  PowerMock + Mockito ~ 200 ms: </p><br><table><thead><tr><th>  Method </th><th>  ms </th></tr></thead><tbody><tr><td> <code>org.powermock.api.extension.proxyframework.ProxyFrameworkImpl.isProxy(Class)</code> </td> <td>  304 </td></tr><tr><td> <code>org.powermock.api.mockito.repackaged.cglib.core.KeyFactory$Generator <br> .generateClass(ClassVisitor)</code> </td> <td>  131 </td></tr><tr><td> <code>sun.launcher.LauncherHelper.checkAndLoadMain(boolean, int, String)</code> </td> <td>  103 </td></tr><tr><td> <code>javassist.bytecode.MethodInfo.rebuildStackMap(ClassPool)</code> </td> <td>  85 </td></tr><tr><td> <code>java.lang.Class.getResource(String)</code> </td> <td>  84 </td></tr><tr><td> <code>org.mockito.internal.MockitoCore.&lt;init&gt;()</code> </td> <td>  67 </td></tr></tbody></table><br><h1 id="opyt-ispolzovaniya">  Experience of use </h1><br><p>  Currently, there are more than 3000 Unit tests in our project, about half of which use Robolectric. </p><br><p>  Faced with the performance issues of the framework, it was decided to use the Robolectric only to test a limited set of cases: </p><br><ul><li>  Parcelable </li><li>  Formatting strings in resources </li><li>  Non-UI components (Camera) </li></ul><br><p>  For all other cases, we wrap Android dependencies in easily tested wrappers, or use <a href="https://github.com/bjoernQ/unmock-plugin">unmock-plugin</a> for Gradle. </p><br><p>  Video with my report on the same topic at the MBLTdev 16 conference </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OHxogE49b1Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/320898/">https://habr.com/ru/post/320898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320886/index.html">FlexPod - from theory to practice: the word to engineers (webinar)</a></li>
<li><a href="../320888/index.html">Cloudless mobile app - life without Google Play</a></li>
<li><a href="../320890/index.html">NooLite: kill two birds of ergonomics at the same time (installation, opinion, development)</a></li>
<li><a href="../320892/index.html">Testing untestable JS with Babel and snarejs</a></li>
<li><a href="../320894/index.html">Experience using Samsung Pay</a></li>
<li><a href="../320900/index.html">Configuring the DNS server for North Korean security standards</a></li>
<li><a href="../320902/index.html">How we prepared the redis cluster</a></li>
<li><a href="../320904/index.html">Petersburg IT exports underestimated by a large amount</a></li>
<li><a href="../320906/index.html">Yii 2.0.11</a></li>
<li><a href="../320908/index.html">Trends 2016 and 2017 in the Japanese mobile industry</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>