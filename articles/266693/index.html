<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Under the hood rendering navigation data in MAPS.ME</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Navigation in the application MAPS.ME is one of the main features that we focus on. We recently told you about pedestrian navigation . Today I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Under the hood rendering navigation data in MAPS.ME</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d1e/470/fed/d1e470fed878447db884f67311fd1fce.png"><br><br>  Hello!  Navigation in the application MAPS.ME is one of the main features that we focus on.  We recently told you about <a href="http://habrahabr.ru/company/mailru/blog/265249/">pedestrian navigation</a> .  Today I want to tell you about how we display navigation data in MAPS.ME.  By navigation data, I mean route lines, arrows to display maneuvers and the user's position on the route.  This post will not affect the algorithms for constructing routes based on OSM data, nor algorithms for extracting maneuvers, but only rendering.  Interested please under the cat. <br><a name="habracut"></a><br>  We begin our conversation by defining the requirements for displaying the above navigation data. <br><ol><li>  The route line should have a variable thickness depending on the scale of the map.  Obviously, on a small scale, this line should be sufficiently thin so as not to overlap important cartographic reference points, while being thick enough to be visible.  On a large scale, the width of the route line ideally should not exceed the width of the road. </li><li>  The completed part of the route should be hidden. </li><li>  On the route should be displayed maneuvers.  At the moment, our maneuvers are limited to turns and should be displayed in the form of arrows indicating the direction of turn. </li><li>  The route line can be of any color (including translucency).  Now the color is uniform throughout the route. </li><li>  The user's position is displayed as an arrow in the direction of movement. </li><li>  The end of the route is also marked with a special icon. </li></ol><br>  Now let's see what we have in place to display all this.  From the route construction system we get: <br><ul><li>  a polyline, which defines the central axis of the route line; </li><li>  points on the polyline that determine the maneuver (turning) point; </li><li>  A point on the polyline that defines the user's position. </li></ul><br>  In addition, we have: <br><ul><li>  color of the route line in RGBA format; </li><li>  texture with skin maps. </li></ul><br>  The points on the polyline are logical, i.e.  not part of this polyline, and are defined as the distance from the beginning of the line.  For example, 0.0 indicates the first point of the polyline, and a value equal to the length of the polyline indicates the last point. <br><br>  Now that we have decided on all the input conditions, let's proceed to the analysis of the rendering process. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Forming the geometry of the route line </h2><br>  The geometry of the route line we form as a list of triangles.  Since in the requirements we have a variable width, and we can‚Äôt afford to reorganize the geometry every frame, the width of the line is taken out in a uniform variable.  In the initial state, all points are grouped along the central axis.  For each vertex, we save the vector, in the direction of which we will displace this vertex in the vertex shader (let's call this vector the normal).  As a result, we get something similar to the picture below. <br><br><img src="https://habrastorage.org/files/719/49f/909/71949f909187450296ac99ab4572f8e6.png"><br><br>  The figure shows that at point 3 2 pairs of normals coexist.  The normals, marked in the figure in one color, are parallel to each other and in different directions, and if one of them is known, the second is calculated by inverting the vector. <br><br>  In order to contain 2 multidirectional non-parallel normals at a point, the point must be duplicated, which occurs naturally during the formation of polygons.  It can also be seen that in the place of fracture the formed polygons will overlap on the one hand, and on the other hand, on the contrary, form a gap.  At first glance it seems that overlapping polygons do not pose a problem.  That is, as long as the route line is completely opaque.  In the case of a semitransparent line, the intersection of polygons will be darker, therefore, we must get rid of them.  The gap is much easier to overcome; a polygonal insert is formed in its place. <br><br>  To eliminate overlapping polygons, we modify the normals so that the formed polygons do not overlap.  To do this, calculate the average for two adjacent normals and shift both points along the new vector. <br><br><img src="https://habrastorage.org/files/7d8/853/d2b/7d8853d2b48741748997ca0c17d3654a.png" height="50%" width="50%"><br><br>  With this approach, one subtlety appears.  Normals are no longer normalized, since we may need to significantly displace vertices at acute angles.  As already mentioned, we eliminate the gaps in the route line using polygonal inserts.  We support 3 ways to form these inserts. <br><br><img src="https://habrastorage.org/files/edb/e30/607/edbe30607f264c36889f8196fc469e2c.png" height="80%" width="80%"><br><br>  In the first case, the polygonal insertion is formed by the triangulation of a part of the circle inscribed in the junction of the route line segments.  In the second case, an acute angle is formed; in the third, exactly one triangle is inserted.  The geometry generation algorithm estimates the size of the discontinuity, the degree of divergence of the normals, and selects one of the methods for forming the polygonal insert.  Among other things, at the ends of the route line are added rounding.  They are formed in the same way as inserts of the 1st type.  As a result, we got the inseparable geometry of the route line, which we can draw with any color, including semi-transparent. <br><br><img src="https://habrastorage.org/files/924/ab2/3c2/924ab23c286a4b3592de9f149fa74f91.png"><br><br><h2>  Display of the covered part of the route </h2><br>  To cut off the traversed part of the route, the most obvious solution is to regenerate the geometry as the route passes.  Obviously, this method will be costly in terms of performance, and the point here is not so much the complexity of the geometry generation algorithm as the cost of sending new vertex and index buffers to the GPU.  In order not to regenerate the geometry for each update of the GPS-coordinates, we came up with the following approach.  At each vertex of the generated geometry, we add a value equal to the length from the beginning of the route line to the projection of this vertex onto the route line. <br><br><img src="https://habrastorage.org/files/090/aa0/c7e/090aa0c7ee384de9b26115f64853f59c.png"><br><br>  Due to the interpolation of the values ‚Äã‚Äãbetween the vertices for each fragment, we will have a value equal to the distance from the beginning of the route line to this fragment along the route line (DISTANCE_FROM_START).  And with the help of the following simple pseudocode shader part of the route line will be cut off. <br><br><pre><code class="hljs mel">vec4 mainFragment() { vec4 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = ROUTE_LINE_COLOR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DISTANCE_FROM_START &lt; CURRENT_CLIP_DISTANCE) <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>.a = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">color</span></span>; }</code> </pre> <br>  Here <i>ROUTE_LINE_COLOR</i> is the color of the route line, <i>CURRENT_CLIP_DISTANCE</i> is the current distance traveled along the route.  In this approach, there is one small drawback: all the vertices of the polygonal insert will give a projection into one point. <br><br><img src="https://habrastorage.org/files/dfb/c09/d90/dfbc09d9083941fcb6f042ed2c9f8cfa.png"><br><br>  In the above example, points 1, 2 and 3 that are included in a polygon of type 2 are projected onto the central axis of the route line with a value of 7.4.  In practice, this will be expressed in the formation of an uneven cut of the line at the border of two segments.  But, in fact, for us, this behavior is not a problem, since the slice (flat or uneven) will in the overwhelming majority of cases be under the icon indicating the user's position. <br><br><h2>  Maneuvering </h2><br>  Maneuvers, as I have already said, are now limited to arrows with the designation of a turn.  The main problem here is that at different levels of scale several arrows must merge into one in order not to be too small and unreadable. <br><br><img src="https://habrastorage.org/files/1e1/0b2/84a/1e10b284a9b24316ba3abfb3b55fa081.png"><br><br>  It is clear that this time we wanted to do without the geometry regeneration for each frame.  We implemented the following algorithm: <br><ol><li>  Staging stage.  At this stage, the main CPU is loaded.  The line that comes from the system of building a route is divided into segments.  Initially, we operated on one indivisible line, but in the process we encountered one serious problem when building a long route.  Unfortunately, at length interpolation at large distances, we rested against the accuracy of float numbers.  In the application, we use the Mercator coordinates, which causes a sufficiently large number of significant decimal places, and in shaders in OpenGL ES, the accuracy of float numbers is inferior to the accuracy of float numbers in the code for CPU (2-16 at highp against 2-24).  As a result, in the course of real arithmetic in shaders, we lost accuracy, which led to the appearance of graphic artifacts.  All our attempts to achieve the required accuracy, firstly, greatly complicated the fragmentary shader, and, secondly, there was always such a length of the route line, at which it did not work.  Therefore, we decided to split the route line into such segments so that their length does not exceed a certain distance in the Mercator coordinate system.  Now the values ‚Äã‚Äãwere interpolated independently for each segment, which saved us from problems with accuracy.  To avoid breaks at the junction of the segments, the incision site was chosen in a special way.  The broken line segment was cut closest to the desired place, and at the same time long enough so that the maneuver arrow could not reach the cut point.  As a result of this stage, we obtain a set of vertex and index buffers with a triangulated route line geometry. </li><li>  The stage of updating the geometric data.  The code related to this stage is executed for each frame immediately before rendering.  The first task of this stage is to find out which segments of the route line are visible on the screen.  Then, for each visible segment, the maneuvers are projected onto it.  The fact is that for drawing arrows we use the same geometry as for drawing the route line itself, and it is necessary to pass an array of coordinates of the beginning and end of arrows to the shader.  To calculate this array, we perform the following actions: <br><ol><li>  We project the arrows onto the segment of the route line as it is (the original array comes from the route construction system). </li><li>  We merge the intersecting arrows into one (the arrows have certain restrictions on their length, both in the Mercator coordinates and in pixels, and therefore they can intersect). </li><li>  Shift the head of the arrow so that it lies completely on the flat part of the route (this is necessary to avoid distortion when sampling from the texture). </li></ol><br>  As a result of this stage, we determine what kind of geometry we should draw in the current frame, and also calculate an array with the coordinates of the beginning and end of the maneuver arrows. </li><li>  Stage rendering.  Here, of course, we load the GPU.  We use the route line geometry for rendering (we determined the necessary vertex and index buffers at the previous stage).  In the fragment shader, we pass an array of borders and a texture with the image of an arrow.  Each element of the boundary array contains a one-dimensional coordinate of the beginning and end of the arrow, where the coordinate is the distance from the beginning of the current route line segment.  According to these coordinates, in the fragment shader, texture coordinates are calculated for such a texture overlay on the geometry of the route line so that the arrows formed are in the specified areas.  So that the arrow could protrude beyond the route line, a special line width is set (remember, we set it as a uniform variable).  In addition, the texture of the arrow is divided into 3 parts: tail, head and center.  The central part can stretch along the route without distortion, the tail and the head always retain their proportions.  Pseudocode fragment shader for drawing arrows below. <br><br><pre> <code class="hljs pgsql">struct Arrow { <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; }; Arrow arrows[MAX_ARROWS_COUNT]; sampler2D arrowTexture; vec4 mainFragment(<span class="hljs-type"><span class="hljs-type">float</span></span> distanceFromStart, <span class="hljs-type"><span class="hljs-type">float</span></span> v) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_ARROWS_COUNT; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distanceFromStart &lt;= arrows[i].<span class="hljs-keyword"><span class="hljs-keyword">start</span></span> &amp;&amp; distanceFromStart &lt; arrows[i].<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) { <span class="hljs-type"><span class="hljs-type">float</span></span> u = (distanceFromStart - arrows[i].<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>) / (arrows[i].<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - arrows[i].<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> texture(arrowTexture, vec2(u, v)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre></li></ol><br><h2>  Conclusion </h2><br>  Today we reviewed the process of rendering navigation data in MAPS.ME.  Our solutions do not pretend to be universal, however, I hope that you have found here something useful for yourself and your projects.  Much more can be said about rendering in MAPS.ME, but we would like to understand what is interesting for our readers.  Write in the comments about what you would be interested to read and, perhaps, the next post will be on the topic proposed by you. </div><p>Source: <a href="https://habr.com/ru/post/266693/">https://habr.com/ru/post/266693/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266681/index.html">Correct work with date and time in Ruby on Rails</a></li>
<li><a href="../266683/index.html">React v0.14 release candidate overview</a></li>
<li><a href="../266685/index.html">Accelerate vectorization and memory accesses in DL_MESO: optimization examples with Vectorization Advisor on a large project</a></li>
<li><a href="../266687/index.html">Memory Profiling with Intel¬Æ VTune ‚Ñ¢ Amplifier XE</a></li>
<li><a href="../266689/index.html">Rating of data center operators in Russia by the degree of readiness to interact with foreign customers</a></li>
<li><a href="../266695/index.html">VAD (Voice Application Designer). Part 2 components (Call Related)</a></li>
<li><a href="../266699/index.html">Why the SoundCloud team switched to microservices</a></li>
<li><a href="../266701/index.html">Notes from Intel System Studio Developer: Debugging Android Linux Core with Intel JTAG Debugger and MinnowBoard MAX</a></li>
<li><a href="../266703/index.html">Microservices without servers (cloud version)</a></li>
<li><a href="../266705/index.html">Basics of preparing applications for deployment (Application packaging)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>