<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Jetpack Compose dive</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Before leaving for the weekend, we are in a hurry to share with you another translation prepared specifically for students of the course ‚ÄúAndro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Jetpack Compose dive</h1><div class="post__text post__text-html js-mediator-article">  Hello.  Before leaving for the weekend, we are in a hurry to share with you another translation prepared specifically for students of the course <a href="https://otus.pw/SHk1/">‚ÄúAndroid Developer.</a>  <a href="https://otus.pw/SHk1/">Advanced course</a> . <br><br><img src="https://habrastorage.org/webt/z6/qg/xa/z6qgxa6dlio2hf4bnnpwbvlk2j4.png"><br><br><h2>  We are trying a new UI-framework for Android applications </h2><br>  Over the past few years, participating in many mobile projects, I have had to use various technologies, such as Android, ReactNative and Flutter.  Switching from ReactNative back to classic Android made me have mixed feelings.  The return to Kotlin went well, but I really missed the React UI framework.  The small reusable components that create the user interface are great and provide more flexibility and speed of development. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Returning to classic Android, I had to worry about keeping the View hierarchy as uniform as possible.  Because of this, it is difficult to truly devote yourself to the component approach.  This makes copy-paste more tempting, which leads to more complex and less supported code.  Ultimately, we keep ourselves from experimenting with the user interface that could improve the UX. <br><br><img src="https://habrastorage.org/webt/9w/qc/oy/9wqcoytvuj4zccl4dbkrmpgx-v8.png"><br>  <i>Android reveals Jetpack Compose.</i>  <i>Illustration: Emanuel Bagilla</i> <br><br><h3>  Jetpack Compose to the rescue </h3><br>  So after watching <a href="https://www.youtube.com/watch%3Fv%3Dtd3Kd7fOROw">What's new in Android</a> from the Google I / O 2019 conference, I immediately started to figure out Compose and tried to learn more about it.  Compose is a reactive user interface toolkit, fully developed by Kotlin.  Compose looks very similar to existing user interface frameworks such as React, Litho, or Flutter. <br><br>  The current structure of the Android UI framework has been around since 2008, and over time it became more complex and rather hard to maintain.  Jetpack Compose seeks to start all over again with the philosophy of modern components.  The framework is written with the following main objectives in mind: <br><br><ul><li>  <b>Unrelated to platform releases:</b> This allows you to quickly fix bugs, since Compose does not depend on new Android releases. </li><li>  <b>Smaller technology stack:</b> The framework does not force you to use a View or Fragment when creating a user interface.  All elements are components and can be freely put together. </li><li>  <b>Transparent state management and event handling:</b> One of the most important and complex things that need to be addressed in large applications is the handling of data flow and state in your user interface.  Compose clarifies who is responsible for the state and how events should be handled, just as React handles it. </li><li>  <b>Writing less code:</b> Writing the user interface in Android usually requires a lot of code, especially when creating more complex layouts, for example, using RecyclerView.  Compose is designed to greatly simplify the way you create a user interface. </li></ul><br>  This makes it easy to create isolated and reusable components, making it easy to create a new screen with existing elements.  Helping you, as a developer, focus on creating a user-friendly user interface, instead of trying to control the View hierarchy and tame View and Fragment. <br><br><h2>  Simple application with Compose: Hello World </h2><br>  Let's look at the code for a simple ‚ÄúHello World‚Äù application with Jetpack Compose. <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComposeActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) setContent { CraneWrapper { MyApp() } } } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { MaterialTheme { Text(text = <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>, style = +themeTextStyle { h3 }) } } }</code> </pre> <br>  In the <code>onCreate</code> method <code>onCreate</code> we set the contents of our application by calling <code>setContent</code> .  This is a method that initializes a composite tree of widgets and wraps it in <code>FrameLayout</code> . <br><br>  To make it work, we need to wrap our application in <code>CraneWrapper</code> and <code>MaterialTheme</code> .  <code>CraneWrapper</code> is responsible for configuring providers for <code>Context</code> , <code>FocusManager</code> and <code>TextInputService</code> .  <code>MaterialTheme</code> required to provide the colors, styles, and fonts of your widgets.  With this in mind, we can add a <code>Text</code> component that will display our text on the screen in a specific style. <br><br><h2>  State introduction </h2><br>  Managing data flow and states can be a daunting task.  To illustrate how easy it is with Compose, let's create a simple counter application. <br>  To work with states, Jetpack Compose uses ideas from other modern UI frameworks, such as Flutter and React.  There is a unidirectional and reactive data stream that causes your widget to be updated or "reassembled". <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { MaterialTheme { Counter() } } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount = +state { <span class="hljs-number"><span class="hljs-number">0</span></span> } Column { Text(text = <span class="hljs-string"><span class="hljs-string">"Counter demo"</span></span>) Button(text = <span class="hljs-string"><span class="hljs-string">"Add"</span></span>, onClick = { amount.value++ }) Button(text = <span class="hljs-string"><span class="hljs-string">"Subtract"</span></span>, onClick = { amount.value-- }) Text(text = <span class="hljs-string"><span class="hljs-string">"Clicks: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${amount.value}</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre> <br><br>  In the example above, we add the ‚ÄúAdd‚Äù and ‚ÄúSubtract‚Äù buttons along with a label that displays the current number of clicks.  As you can see in the example below, by updating the ‚Äúamount‚Äù state, widgets are intelligently recomposed when the state changes. <br><br><img src="https://habrastorage.org/webt/ks/_y/ko/ks_ykoqxzmr24t-woc8o854dl_o.gif"><br>  <i>Launch demo application</i> <br><br>  The <code>amount</code> state is initialized using <code>+state { 0 }</code> .  Trying to figure out what kind of witchcraft, I climbed into the source code.  This is my opinion, although I am still not sure that I understand everything. <br><br>  <code>state {...}</code> creates an <code><code>Effect&lt;</code> State <code>&lt;</code> T <code>&lt;</code> code&gt;&gt;</code> .  The <code>Effect</code> class is a fuzzy class that contains a block of executable code that is executed positionally in the context of the composition.  The <code>State</code> class contains one value with the <code>Model</code> type, essentially making this value observable.  The + operator is a temporary operator that resolves the <code>State</code> from <code>Effect</code> . <br><br><h3>  Custom state models </h3><br>  Instead of using <code>+state {}</code> to create a single value model, we can also create a custom model using the @Model annotation.  We can improve our application counter by dividing it into smaller widgets and passing the model to other widgets that update and display the status of this model. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Model</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> header = <span class="hljs-string"><span class="hljs-string">"Counter demo"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { counter++ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subtract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { counter-- } }</code> </pre> <br><br>  Using the <code>@Model</code> annotation, the Compose Compiler plugin makes all the variables in your model observable so that they can be used to rebuild widgets.  Let's update our widget to use <code>CounterModel</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Column { CounterHeader(counterModel) AddSubtractButtons(counterModel) CounterLabel(counterModel) } } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CounterHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Text(text = counterModel.header) } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSubtractButtons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Button( text = <span class="hljs-string"><span class="hljs-string">"Add"</span></span>, onClick = { counterModel.add() }) Button( text = <span class="hljs-string"><span class="hljs-string">"Subtract"</span></span>, onClick = { counterModel.subtract() }) } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CounterLabel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Text(text = <span class="hljs-string"><span class="hljs-string">"Clicks: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${counterModel.counter}</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br><br>  The only widget that makes up the counter application is now divided into several smaller composable widgets.  <code>CounterModel</code> is passed to various widgets, either to display the state of the model, or to change the state of the model using the <code>add()</code> or <code>subtract()</code> functions. <br><br><h2>  No more view </h2><br>  It is important to understand that Jetpack Compose widgets do not use a view or fragment under the hood, these are just functions that are painted on the canvas.  The Compose Compiler plugin handles all functions annotated with <code>@Composable</code> and automatically updates the UI hierarchy. <br><br>  For example, the <code>Divider</code> widget consists of a <code>Padding</code> widget that contains a <code>DrawFillRect</code> widget.  Looking at the source code of <code>DrawFillRect</code> , it becomes clear that he draws lines right on the canvas.  All other widgets are implemented in the same way. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawFillRect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(brush: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Brush</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Draw { canvas, parentSize -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paint = Paint() brush.applyBrush(paint) canvas.drawRect(parentSize.toRect(), paint) } }</code> </pre> <br><br>  DrawFillRect source code that is used inside the Divider widget <br>  If we look at the Layout Inspector by running one of the sample applications from Google, we‚Äôll clearly see that there is no <code>View</code> or <code>ViewGroups</code> when launching the Android application from Compose.  We see a <code>FrameLayout</code> containing the <code>CraneWrapper</code> that we created in the code, from there the Compose UI hierarchy is displayed on the screen. <br><br><img src="https://habrastorage.org/webt/fc/oa/bb/fcoabbcltglyqbogmtcywdxiums.png"><br>  <i>Layout Inspector inspects the Jetpack Compose application.</i> <br><br>  The absence of views also means that Jetpack Compose cannot use the currently available view, such as <code>android.widget.Button</code> , and must create all widgets from scratch.  If you look, for example, at Flutter, which uses the same approach, you can see that this is hard work.  This is one of the reasons why the Jetpack Compose will take time before it is ready for use in production. <br><br><h2>  All elements are widgets. </h2><br>  Just like Flutter, in Compose, all elements are widgets.  More complex widgets were broken down into elementary widgets with clear responsibilities.  Therefore, even padding, spacers, and so on are widgets.  For example, if you want to add an indent around a button, simply wrap it in the padding widget: <br><br><pre> <code class="kotlin hljs">Padding(padding = <span class="hljs-number"><span class="hljs-number">16</span></span>.dp) { Button(text = <span class="hljs-string"><span class="hljs-string">"Say hello"</span></span>, onClick = { ... }) }</code> </pre> <br><br><h2>  Linking code to user interface </h2><br>  Connecting Kotlin code with UI widgets is very easy.  For example, if you want to show a user interface that repeats or depends on some conditions.  So, you can easily display a list of names, as shown below. <br><br><pre> <code class="kotlin hljs">Column { listOf(<span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"Julia"</span></span>, <span class="hljs-string"><span class="hljs-string">"Alice"</span></span>, <span class="hljs-string"><span class="hljs-string">"Mark"</span></span>).forEach { Text(text = it) } }</code> </pre> <br><br>  This is a really powerful feature, but you must be careful not to program too much logic at the user interface level. <br><br><h2>  Compatible with your Android applications </h2><br>  Compose is designed in such a way that you can add it to an existing application and gradually transfer some parts of your UI to a new framework.  The examples above add a Jetpack Compose UI to a single activity.  You can also embed Compose widgets into an existing XML layout using the <code>GenerateView</code> annotation: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-meta"><span class="hljs-meta">@GenerateView</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  -  layout.xml &lt;GreetingView app:name=‚ÄùJohn‚Äù /&gt;</span></span></code> </pre> <br><h2>  Conclusion </h2><br>  I am delighted with Compose, because it reduces the growing suffering that I experience when developing for Android.  It helps to be more flexible, focus on creating a user-friendly user interface, and clear responsibility also helps to avoid mistakes. <br><br>  Compose has a long way to go, in my opinion, it can be used in production not earlier than in a year or two.  However, I think that now is the right moment to take a look at the Jetpack Compose.  The creators are actively looking for feedback, at this stage you can still make changes.  All feedback will help improve this new framework. <br><br>  Read my article <a href="https://medium.com/q42-engineering/try-jetpack-compose-today-a12bda50aed2">‚ÄúTry Jetpack Compose today‚Äù</a> to learn how to connect Compose pre-alpha.  Also, I think it will be very interesting for you to watch the <a href="https://youtu.be/VsStyq4Lzxo">video on the templates of the declarative interface</a> with Google I / O. <br>  I look forward to when I can use Compose in real Android applications! <br><br>  That's all.  We are looking forward to your comments and a great weekend! </div><p>Source: <a href="https://habr.com/ru/post/458106/">https://habr.com/ru/post/458106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458096/index.html">What is the MERN stack and how to work with it?</a></li>
<li><a href="../458098/index.html">Pitfalls GDPR</a></li>
<li><a href="../4581/index.html">IE7 and CSS support: expert comments</a></li>
<li><a href="../458102/index.html">Effective web development workflow: Confluence, Airtable and other tools</a></li>
<li><a href="../458104/index.html">RDMA inside the data center in the implementation of Huawei</a></li>
<li><a href="../45811/index.html">Black Triangle Dock in Leopard</a></li>
<li><a href="../458110/index.html">Dynamic programming in the real world: cutting seams</a></li>
<li><a href="../458112/index.html">Sony's Xperia 10 Review</a></li>
<li><a href="../458116/index.html">SwiftUI and auto-renewable subscriptions</a></li>
<li><a href="../458118/index.html">React Native Guide for Beginner Android Developers (with an example application)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>