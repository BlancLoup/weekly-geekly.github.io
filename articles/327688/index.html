<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Structural Classification: Examples and Misconceptions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the final article from the model classification cycle. In this article, I classify designs. Must apologize for the lack of illustrations, but ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Structural Classification: Examples and Misconceptions</h1><div class="post__text post__text-html js-mediator-article">  This is the final article from the model classification cycle.  In this article, I classify designs.  Must apologize for the lack of illustrations, but it happened.  Therefore, today is just a text.  I must warn you that this article is based on my previous articles, in which it is described in detail that the object, operation, and function are objects that have only a different interpretation. <br><br><h2>  Terms </h2><br>  Let's start with the term "there is a part."  In everyday life, we meet the following statements: elephants - there is a part of mammals.  The idea is that the set of elephants is a subset of the set of mammals.  In this article, the term "there is a part" will be used in a different sense.  We will use this term only in relation to specific objects.  For example, a specific branch of a tree is a part of a specific tree.  You do not need to think that we are talking about any branch of a tree, as when we define the concept: a branch of a tree is a part of a tree.  In terms of mathematics, this statement reads as follows: for any branch of a tree there is such a tree that this branch is part of that tree.  Such a statement is no longer related to a specific object, but to a concept that defines objects.  If the article needs to say this, I will say clearly.  Otherwise, I will talk about specific objects. <br><br>  The following term "includes."  If I say that a tree includes a branch, then this means that a particular branch is part of a particular tree.  And we are still talking about specific objects, not about sets or concepts. <br><a name="habracut"></a><br>  Another term to deal with will be a little more difficult.  This term "consists of" It seems that it is close to the term "includes", but we will distinguish them.  We say that a tree consists of branches, a trunk and roots.  In this case, we assume that the parts of the tree are listed in full to give us a complete picture of the structure of the tree.  That is, the term "consists of" is used in relation to the buildings (structures) of objects.  If we take a part of these objects, then we say that the super-object consists of these sub-objects is no longer possible (something is missing).  Therefore, the following hierarchy is correct: an over-object, a construction of an over-object whose elements are sub-objects and of which it consists, a sub-object that is part of an over-object and is an element of the construction of an above-object. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Constructed Paradigms </h2><br>  One over-object can be represented in the form of different designs.  An over-object can be divided into parts according to different principles of division (different bases).  There is a principle of division, preserving the compactness of spatial parts - spatial division.  Example: a building consists of rooms.  Let me remind you that the thesis ‚Äúa building consists of rooms‚Äù is tantamount to a statement: there is a building, there is a building design, made within the framework of the spatial paradigm, the elements of which (the designs) are premises.  Another base is functional.  Example: a building consists of enclosing structures, roofing and engineering subsystems.  In other words, it can be said that the basis for the division of the super-object is the paradigm of the structure. <br><br>  Constructions of the human body are often considered in two paradigms: one is called the external structure of the person, the second is the internal structure.  The external structure describes the parts of the human body: arms, legs, head, torso.  The internal structure describes the subsystems of man: the bloodstream, digestive, nervous, and so on.  The external structure is equivalent to the spatial division of the building into rooms.  The internal structure is equivalent to the functional division of the building by subsystem. <br><br><h2>  Construction Classification </h2><br>  Usually we consider the construction simply: here is the over-object, here are the sub-objects, here are the connections between the sub-objects that explain the properties of the over-object to us.  We will classify structures through the classification of structural elements. <br><br><h3>  Structural elements belong to the same class as the object. </h3><br>  Consider a construction in which the elements belong to the same class as the over-object.  For example, water consists of parts, each of which is also water.  Or a pile of sand, elements of which are also heaps of sand.  If an object is divided in this way, then it is often possible to enter a measure for it.  This is a feature of this kind of structures.  For example, the mass of an object is equal to the sum of the masses of its parts, the area of ‚Äã‚Äãa figure is equal to the sum of the areas of its parts, the volume of matter is equal to the sum of the volumes of its parts and so on.  Consider a less obvious example.  Let there be an operation and its parts - sub-operations.  Then the measure can be its four-dimensional volume.  Example: a person performed an operation for 4 hours.  The volume of operations - 4 man-hours.  Suppose we divided the operation into 4 sub-operations.  Each sub-operation has a volume of 1 man-hour.  Thus, the sum of the volumes of sub-operations is equal to the volume of over-operations. <br><br><h4>  Delusion </h4><br>  I note that many here will make a mistake and think that I spoke about the concept of operation.  No, in this context it was a question of a specific operation performed by Vasilyev from 12-00 to 16-00 on April 12, 2016.  If we talk about the concept of an operation, then we cannot say that the concept lasts 4 hours.  It can be said that operations of this type last an average of 4 hours.  I often (even from leading analysts) hear erroneous statements on this topic.  They say that the operation, which they designated in BPMN notation as a rectangle, lasts 4 hours.  But the BPMN notation does not model operations, it models the concept of operation.  Therefore, in this notation, it is impossible to say how long a specific operation lasts.  In the properties of an object created in BPMN notation, there may be an attribute: the average duration of operations of this type, but there can be no attribute the duration of the operation.  This is what <a href="http://www.businessstudio.ru/">Businessstudio</a> has done.  In the properties of an object created in EPC notation or in notation, you can specify the distribution of the durations of operations of a certain type.  And this is true. <br><br><h4>  Examples of constructions of the first type </h4><br>  Examples of such structures: the operation to build a house is presented in the form of a structure consisting of operations that we observe on the network schedule of building a house.  The diagram in IDEF0 notation models the structure of a function consisting of functions. <br><br>  An erroneous example: some might think that in a BPMN diagram, a subprocess is an operation construct, but it is not.  There are no operation models on the BPMN diagram.  There are conceptual models of operations.  Very similar to the definition of a concept, and so it is.  The square in BPMN does not model the operation, but the concept of the operation.  The diagram in BPMN notation is a conceptual model, not an object model. <br><br><h3>  Construction class in which elements belong to the same class </h3><br>  A construction of this kind consists of elements belonging to one class, while the over-object belongs to another class. <br><br>  For example, a specific booth consists of four specific boards.  It is clear that the volume of the booth is not equal to the sum of the volumes of the boards, so it will not be possible to introduce the measure.  An example of a description of the activity: the operation consists of participants.  We perceive participants as material or as functional objects, but we do not perceive them as operations.  In this case, I again want to emphasize that we are not talking about concepts of operations, the model of which can be found in BPMN notations, but about operations, models of which can be found on Gantt diagrams.  For example, the participants in the ‚Äúnail in‚Äù operation that took place at 9-00 on May 13, 2011 were: Sidorov, a hammer, a nail, two boards, a stool, a lamp, a table, a room. <br><br>  If someone tries to say something similar about objects created in BPMN notation, then it should sound like this: every operation of a given type, whose model (type) we see in BPMN notation, has participants of the following types: ... For example, Each type of ‚Äúhammer nail‚Äù operation will include objects of the following types: ‚Äúperformer‚Äù, ‚Äúnail‚Äù and ‚Äúhammer‚Äù.  True, there are exceptions.  For example, sometimes in the definition of the type of operation you can find a link not to the type of participant, but to the model of a specific resource.  Then we are talking about the fact that in any operation of this type the participant will be a specific object, and not an object of some type, for example, in each operation of the class ‚Äúobtain approval for the building construction‚Äù the participant is indicated: the administration of the city of Moscow (the object). <br><br><h3>  All construction objects belong to different classes. </h3><br>  The following case is most common: the objects above and under belong to different classes.  For example, a transformer consists of a core and two windings.  As applied to the description of the activity, we can consider the previous example in the context of the fact that the performers belong to different classes.  Sidorov - to the people, a hammer - to the tools, and a nail - to the materials.  It all depends on how we classify objects. <br><br><h3>  Description of the structure without listing its elements </h3><br>  The next case is more complicated.  We are talking about a structure in which there is no listing of its elements, but there is a mention of the types of objects that make up the structure.  For example, a building consists of bricks.  A concrete building consists of brick-like objects.  There is no listing of specific bricks, but there is an indication of the type to which these objects belong.  Modeling of such constructions is rather difficult in modern modeling languages.  The fact is that in order to model such statements, second-order predicates are needed.  But there are no languages ‚Äã‚Äãthat would be sharpened for modeling second-order predicates.  The reason for this is that if a model created in first-order predicates is computable, then a model in second-order predicates is not.  That is, on the basis of the facts written in the predicates of the first order, it is possible to build unambiguous conclusions.  If the model is built in second-order predicates, then conclusions can be only with some probability.  For example, if we say that a forest consists of aspen by 60 percent and from birch trees by 30 percent (other trees belong to other species), then it will be possible to say for sure about the species of an arbitrarily taken tree in this forest only with a certain degree of probability. <br><br>  The creation of an information system sets itself the task of automating certain operations.  Most often, these are deterministic operations, in which there is no place for probabilistic outcomes.  Programmers for the most part solve exactly such problems.  Therefore, all their tools are sharpened by modeling first-order predicates, the PLO in particular.  Therefore, where it is necessary to model second-order predicates, OOP cannot cope. <br><br><h4>  Examples </h4><br>  One might think that such a case is really rare, however, the modeling of an enterprise‚Äôs activity is directly related to the modeling of this kind of relationship between objects.  For example, we model the construction of a business function.  There are three common ways to represent its construction (construction paradigms).  The first method was mentioned above - the over-function is represented as a construction consisting of sub-functions (IDEF0 notation).  The second way is the construction of a function consists of a set of its participants (for example, a sales function consists of a seller, a potential buyer and a product).  This type of construction is modeled in IDEF0 notation with the help of the arrows in the square ‚Äúbottom‚Äù.  The third type of structure corresponds to the current case: the function consists of operations of a certain type.  For example, the sales function consists of the sale of goods.  The function is an object, the operation is an object.  Sales operations are objects of the same type.  That is, the thesis that the building consists of bricks is similar to the thesis: a function consists of operations of a certain type.  There is no language for modeling this kind of statements.  As I have already said, the reason is that this statement is in second-order predicates.  Another example of such statements is: a crystal consists of atoms.  Through the analogy with the crystal, we move on to the most difficult to understand case, associated with the description of structures. <br><br><h3>  Construction of cells with objects of different types </h3><br>  Let there be a crystal.  Until now, we have not considered the connection between the elements of the structure as part of the structure.  From this point on we will need communication.  It is clear that the division of an object into parts requires a description of the connections between the elements.  When divided into enumerated elements, we can enumerate all the connections between the elements.  However, when dividing into objects of the same type without listing all the elements, the question arises of how to describe the connections between the elements of a structure?  For example, in a building, most bricks have connections with other bricks through masonry mortar.  Then we say that the building consists of bricks, each brick has connections with neighboring bricks.  At the same time, 60 percent of bricks have 5 neighbors, 30 percent - 4 neighbors, 5 percent - 3 neighbors, and 5 percent - 2 neighbors.  Thus, for any selected brick from the first group there are five, which are also part of the building and are associated with the selected brick through the masonry mortar.  Now we will write the same statement regarding the business function.  The sales function consists of sales operations.  Suppose that operations follow one after another.  Then we can say that for any operation there is a previous operation of the same type and there is a subsequent operation of the same type.  So we modeled the type of connection in the construction, which is described by types of objects, but not objects.  Now imagine a crystal of a more complex structure, in which atoms of different elements participate and are located in a complex crystal lattice.  How to describe the structure of such a crystal?  Those who are engaged in the description and classification of crystals know that there are infinitely many ways to describe this kind of lattice.  For example, suppose there is a one-dimensional chain of atoms of two different types A and B alternating with each other in increments of one angstrom.  It can be said that the crystal consists of cells, each of which consists of atoms of type A and B, located after 1 angstrom, the shift between cells is 2 angstroms.  (The statement that the crystal consists of cells, each of which consists of type A and B atoms located through 3 angstroms will also be true. The shift between cells is 2 angstroms and the cells intersect in space. Each such regular structure is visible on the X-ray diffraction pattern of the crystal . To limit the number of options usually take the most closely spaced atoms).  On the other hand, it can be said that a crystal consists of two types of atoms: A and B. This statement is similar to the previous one, but differs from it in that in the first case the design of the crystal consists of cells, and the design of cells, in turn, of atoms.  In the second case, the crystal design directly consists of atoms.  Another example: let the sales function perform two types of operations: the coordination of conditions and the shipment of goods.  It can be said that a function consists of cells, each of which has an operation for coordinating conditions and an operation for shipping goods.  And you can say: the function consists of operations to harmonize the conditions and operations for the shipment of goods.  These are two different statements. <br><br><h4>  Selection of a sequence of elements in a typical cell </h4><br>  Let's look at the sequence of operations: AVAVAVAV ... We see that the chain is infinite and it is possible to begin the selection of cells from any place.  For example, first the Phoenix bird was born from the ashes, then it burned down, then it was born from the ashes, then it burned down.  Or: first, the Phoenix bird burned, then was born from the ashes, then burned again.  The cell can start anywhere.  Therefore, in order to have a basis for a start, choose some condition that is fulfilled for all operations of the cell.  For example, all transactions relate to a single transaction.  Conditions can be any, and in general the cell can begin with an operation of any type.  Analysts usually do not know this and, in order to somehow justify the choice of the initial operation in the cell, they hypnotize themselves with the thought that the chain should have a mystical goal.  Instead of saying that operations in a chain can be combined into a group on some (generally arbitrary) basis, analysts come up with alchemical formulas.  Moreover, this alchemy is present in the process definition. <br><br><h2>  Modeling second-order predicates using OWL </h2><br>  The OWL Full standard allows you to simulate second-order utterances due to the fact that both objects, classes (sets of objects) and even types of relationships that can exist between objects (predicates) can act as objects of an utterance in it.  All these kinds of entities for OWL are nodes of the graph, the edges in which are concrete statements. <br>  Statements of the second order, written in the form of OWL, as a rule, do not provide computability (the possibility of obtaining conclusions by means of logic inference machines).  However, this should not be considered an obstacle to the implementation of automated systems.  In most cases, work with OWL-models occurs in the application code and takes into account the features and limitations of a specific task, and does not pretend to "calculate everything".<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In practice, it is impossible to fully rely on standard logical inference even when working with even first-order statements ‚Äî with a large amount and variety of data, such tasks require too much computational resources. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are several ways to model statements about classes in the OWL language. </font><font style="vertical-align: inherit;">One of the most practical methods is to introduce special classes whose objects are statements about classes or predicates. </font><font style="vertical-align: inherit;">Let us give an example (for those not familiar with the standard, we write it in natural language):</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a class "building" </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a class "Brick" </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a class "Requirement to the composition of the object" </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a link "Refers to class objects" between objects of the class "Requirement to the composition of the object" and classes </font></font></li><li>   ¬´   ¬ª    ¬´   ¬ª   </li><li>   A,    ¬´   ¬ª,   : </li><li>   ‚Äì    ‚Äì  ¬´¬ª (     :    ( ,  ¬´¬ª) ). </li><li>   ‚Äì     ‚Äì  ¬´¬ª </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is possible to summarize the requirements functional - remove from the class name the words "... to the composition of the object", and include the indication of the predicate to which it belongs ("Consists of", "Located in") in the number of class connections "Requirement". In the same way, the modality (‚Äúmust‚Äù, ‚Äúmay‚Äù, etc.) can be excluded from the class name. Then the class will not even be called ‚ÄúRequirement‚Äù, but ‚ÄúApproval‚Äù or ‚ÄúAxiom‚Äù. This will add a full second level to the structure of the model, presented in the form of a graph. The choice of the level of formalism depends solely on the applied problem being solved.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The automated system reads and interprets the above statements, for example, in the following way: at least one object of the class ‚ÄúBrick‚Äù must be present in the composition of each object of the ‚ÄúBuilding‚Äù class. You can not fall to the level of concrete bricks, interpreting the statement differently - as a statement that the building basically consists of the objects of the class "Brick" (which exactly is not known). In this case, other statements about the ‚ÄúBrick‚Äù class can be used - for example, that bricks (that is, all objects of the ‚ÄúBrick‚Äù class) have a certain density, mass, thermal conductivity, etc. From this, the program can make a conclusion about the properties of the building.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In any case, this logic ‚Äî the ability to interpret objects of the class ‚ÄúRequirements to an object composition‚Äù as requirements ‚Äî must be laid down in the code, which is permissible in the context of solving specific applied problems. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can go a little different way - to put the classes not only on the second position in the predicate, but also on the first, that is, to make statements about the classes as such:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a class "building" </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a class "Brick" </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a relationship (predicate) "Must include objects that have only class objects" between classes and classes </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúBuilding‚Äù class - must include objects that have only class objects in their composition - ‚ÄúBrick‚Äù class </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpretation of statements of this kind, of course, also remains on the application software. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that some statements about classes can be made in the framework of the more rigorous OWL formalism, without losing the computability of the model using standard inference machines. </font><font style="vertical-align: inherit;">This is achieved by using the constraints of the values ‚Äã‚Äãof properties (cardinality) with quantifiers: some, only, exactly, and others. Another way to write our example is:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a class "building" </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a class "Brick" </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is a link "Consists of" </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The "Building" class is a subclass of anonymous class, for whose objects the value of the "Consists of" relationship is the objects of the "Brick" class. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When such statements are saved, so-called ‚Äúempty nodes‚Äù are formed in the graph. </font><font style="vertical-align: inherit;">In this case, the empty node will be an anonymous class for which the restriction is set. </font><font style="vertical-align: inherit;">In accordance with the concept of the OWL standard, empty nodes represent assertions with a quantifier of existence ‚Äî that is, in our case, the statement that there are such objects that consist of bricks. </font><font style="vertical-align: inherit;">A subclass of such objects are buildings. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a design is rather cumbersome, and the rules of logical inference are slow and capricious in application, therefore in practice it is usually easier to do with the first or second method. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that all this time we have been discussing the statement ‚ÄúThe building consists of bricks‚Äù, the meaning of which is not very precise from a logical point of view. </font><font style="vertical-align: inherit;">It is not clear what we wanted to say:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> That all that consists of bricks is a building </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> That the building should consist only of bricks, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> That the building consists of bricks, </font></font></li></ul><br>  and so on.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When implementing an automated system, such semantic "backlash" must be eliminated. </font><font style="vertical-align: inherit;">That is why at the beginning of the article I immediately gave the definitions of the terms that will be used in the current article.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mixed designs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us return to the structure of the tree and look at the thesis: the tree consists of branches, trunk and roots. </font><font style="vertical-align: inherit;">This thesis says that the construction of a tree consists of an object - a trunk and objects of two different types - branches and roots.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pseudo-example </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the frequent case when a chart is constructed in IDEF0 notation. </font><font style="vertical-align: inherit;">Then, one of the functions on this diagram is often said to be ‚Äúdecomposed‚Äù into a diagram in BPMN notation. </font><font style="vertical-align: inherit;">This can be found in the Businessstudio program I mentioned earlier. </font><font style="vertical-align: inherit;">Since a function is an object in the domain, and the diagram in BPMN notation is a model of a concept, we see that an error occurs: the function is divided into a concept. </font><font style="vertical-align: inherit;">It can not be. </font><font style="vertical-align: inherit;">The function can be divided into cells with operations. </font><font style="vertical-align: inherit;">In each cell there are several operations related to each other by temporal connections. </font><font style="vertical-align: inherit;">For all cells, the concept of a cell of this type is introduced. </font><font style="vertical-align: inherit;">This concept is modeled in BPMN notation. </font><font style="vertical-align: inherit;">So it will be right.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Correlation of structures in two different paradigms </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A frequently encountered way of describing an object is as follows: consider the construction of an object in two different paradigms, for example, in the paradigm of the ‚Äúexternal‚Äù and ‚Äúinternal‚Äù structures. Then we will go to divide the object into parts in two completely different ways. For example, we will divide the building from one side into premises, and from the other into technical subsystems. And here it is a very important factor that we, as a rule, do not notice, but it works at the level of intuition. We divide an object into parts in two different paradigms in such a way that it is also possible to establish a correspondence between structural elements in two different paradigms. For example, after dividing a building into rooms and subsystems, we can say that rooms can be divided into parts ‚Äî parts of those subsystems that are located in these rooms. I.e,the division into parts in two different paradigms is intuitively made dependent on each other. And this is by no means obvious. Modern engineering design standards are based on such a division of the object, although I am sure that they do not have a prescribed requirement for such a restriction on modeling.</font></font></div><p>Source: <a href="https://habr.com/ru/post/327688/">https://habr.com/ru/post/327688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327678/index.html">Linus Torvalds introduced the Linux kernel 4.11</a></li>
<li><a href="../327680/index.html">Crowd Marketing: Top 10 Popular Questions</a></li>
<li><a href="../327682/index.html">Encryption in EXT4. How it works?</a></li>
<li><a href="../327684/index.html">How to raise your i2p-site (eepsite) on VDS (VPS) under Ubuntu (LAMP). Briefing for beginners</a></li>
<li><a href="../327686/index.html">Structure and execution model of .NET Core applications</a></li>
<li><a href="../327690/index.html">Carousel on Vanilla.JS. Part 2</a></li>
<li><a href="../327692/index.html">Java, first cup</a></li>
<li><a href="../327694/index.html">Search in the Django REST Framework using Elasticsearch</a></li>
<li><a href="../327698/index.html">How to share the environment for building and running a service in Docker today and how to do it tomorrow</a></li>
<li><a href="../327700/index.html">SVG sprite with webpack in one line</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>