<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Quantum computing: annealing with switches and other fun</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, we started a story about quantum computing and compared them with ordinary ones. Today we dive deeper into their technical fe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Quantum computing: annealing with switches and other fun</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="https://habrahabr.ru/company/sberbank/blog/343308/">previous article,</a> we started a story about quantum computing and compared them with ordinary ones.  Today we dive deeper into their technical features and tell you how it is used for the benefit of humanity. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/099/ee4/c3e/099ee4c3e545394ed46e847114227137.png"><br><a name="habracut"></a><br><h2>  Quantum parallelism </h2><br>  According to the laws of quantum mechanics, a particle can be in all its states at the same time.  This qubit state is called superposition.  In the superposition, the amplitudes of the basis states take nonzero values ‚Äã‚Äã- a | 0‚ü© + b | 1‚ü© and the normalization requirement is preserved. <br><br>  A quantum particle can be in superposition only until the moment of measurement.  After measurement, it collapses into one of its basic states, 0 or 1. If we have a register of qubits that are in superposition, then the state of the register itself can be defined as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      (a <sub>0</sub> | 0‚ü© + b <sub>0</sub> | 1‚ü©) (a <sub>1</sub> | 0‚ü© + b <sub>1</sub> | 1‚ü©) ... (a <sub>n</sub> | 0‚ü© + b <sub>n</sub> | 1‚ü©) = <br>  a <sub>0</sub> √ó a <sub>1</sub> √ó‚Ä¶ √ó a <sub>n</sub> | 00..0‚ü© + a <sub>0</sub> √ó a <sub>1</sub> √ó ... √ó b <sub>n</sub> | 00 ... 1‚ü© + ... + b <sub>0</sub> √ó b <sub>1</sub> √ó ... √ó b <sub>n</sub> | 11 ... 1‚ü© <br><br>  It is important to understand that the factors that face states are not a probability.  Otherwise, we would get a classical system with a restriction ‚Äî it is not known what state it is in.  And the quantum bit is in both states at the same time.  We have the ability to process all 2 <sup>n</sup> possible combinations at once! <br><br>  In order to translate a qubit into a superposition state, you need to apply a special transformation to it - the Hadamard Gate.  Another use of Hadamard's gate will return the qubit to one of the basic states.  This is the Hadamard gate matrix and an example of its use: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f45/89c/ded/f4589cdedce7e94a271c54d2c103ccb7.png"><br>  H √ó | 0‚ü© = H √ó (1 | 0‚ü© + 0 | 1‚ü©) = 1 / sqr (2) | 0‚ü© + 1 / sqr (2) | 1‚ü© <br>  H √ó (1 / sqr (2) | 0‚ü© + 1 / sqr (2) | 1‚ü©) = 1 | 0‚ü© + 0 | 1‚ü© = | 0‚ü© <br><br>  The action of the CNOT two-qubit gate with a controlling qubit in superposition is interesting: the CNOT confuses qubits.  The entangled state is a phenomenon in which qubits cannot be considered separately, since their state is now common. <br><br>  Let's give an example.  Suppose we have a register of two qubits in the initial state ‚Äî in the basic state | 0‚ü©).  Apply Hadamard's gate to the first qubit - we get the following register state: <br><br>  H √ó I √ó | 00‚ü© = H √ó (1 | 0‚ü© + 0 | 1‚ü©) √ó I √ó (1 | 0‚ü© + 0 | 1‚ü©) = (1 / sqr (2) | 0‚ü© + 1 / sqr (2) | 1‚ü©) √ó (1 | 0‚ü© + 0 | 1‚ü©) = <br>  1 / sqr (2) | 00‚ü© + 1 / sqr (2) | 10‚ü© <br><br>  The first and second qubits in this register are independent of each other.  The second qubit is still in the state | 0‚ü© and if we measure it, we still will not get information on the state of the first one - it can be either in the state 0 or in state 1. We use the two-qubit gate CNOT: <br><br>  CNot √ó (1 / sqr (2) | 00‚ü© + 1 / sqr (2) | 10‚ü©) = CNot √ó (1 / sqr (2) | 00‚ü© + 0 | 01‚ü© + 1 / sqr (2) | 10 ‚ü© + 0 | 11‚ü©) = <br>  1 / sqr (2) | 00‚ü© + 0 | 01‚ü© + 0 | 10‚ü© + 1 / sqr (2) | 11‚ü© = 1 / sqr (2) | 00‚ü© + 1 / sqr (2) | 11‚ü© <br><br>  Now the qubits are in a confused state, and the measurement of any of them will immediately cause the other to collapse!  The state of the register shows that both qubits are in the same state - 0 or 1. So by measuring one, we will know exactly the state of the other. <br><br>  After we have confused the qubits, it is impossible to just collapse one of them into a basic state - they must first be unraveled.  Try creating this scheme yourself using <a href="https://quantumexperience.ng.bluemix.net/">IBM's quantum editor</a> and evaluate the result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/21b/00e/257/21b00e25744dcd132e40005f919d6e6e.png"><br><h2>  Collapse and the amount of information received </h2><br>  Making calculations on a quantum register of n qubits, we have the ability to simultaneously process all 2 <sup>n</sup> possible states.  However, when measuring, each qubit collapses into one of its basic states, which means that after measuring the result, we have no opportunity to get more information than in the classical case - we only get one of the possible states with the corresponding probability. <br><br>  Quantum algorithms take into account this property and offer many approaches to solve a particular class of problems.  For example, in one of the approaches there are many such transformations that increase the amplitude of the desired solution and reduce the amplitudes of the others. <br><br><h2>  Grover's algorithm </h2><br>  The algorithm representing the set of such transformations is called the Grover algorithm.  It allows quadratically speed up searches in unstructured databases.  Usually, the complexity of the search in an unstructured data set is O (n), that is, in the worst case, we need to look through all the records.  The quantum algorithm allows solving this problem in O (‚àön). <br><br>  For example, we have 40 bits and we need to find one of all possible combinations that satisfies some condition.  In the classic case, we will need to process about 1,000,000,000,000 different combinations.  The quantum algorithm will allow to get the result for 1,000,000. <br><br>  Consider an example.  We have a register of n qubits in superposition.  Thus, we have 2 <sup>n of</sup> all possible states, and the amplitude of each is 1 / ‚àö 2 <sup>n</sup> (with this value the sum of the squares of the modules will be 1).  Imagine this in the form of a diagram: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ec/2a5/bec/9ec2a5bececa7a3492d4f7dad168fc37.png"></div><br>  We also have one extra qubit, which we will call functional, and an oracle function.  The Oracle translates the functional qubit from the base state | 0‚ü© to the state | 1‚ü© exactly on the set we are looking for. <br><br>  In order to get exactly the state that corresponds to the oracle function during the measurement, we perform the following actions: <br><br><ul><li>  Change the amplitude of the desired value to negative.  To do this, we translate the functional qubit to the state | 1‚ü© on all sets, then apply the Hadamard gate to it and then the oracle function to the entire register.  After this action, the picture will look like this: <br></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50f/468/162/50f4681624c0b7146496d54b44c2c519.png"></div>  <i>The dashed line in the figures indicates the average amplitude.</i>  <i>After the sign of the target amplitude has changed, the average has fallen below.</i> <br><br><ul><li>  Since we process all states in the same way, we cannot change any one amplitude.  But we can make an inversion with respect to the mean ‚Äî display the amplitude value, taking the mean value by the axis: <br></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2aa/245/e25/2aa245e251c675821b368907634eebf7.png"></div><br><ul><li>  As we can see, the value of the desired amplitude has grown relative to the rest.  According to the results of performing this set of actions of order Pi √ó 0.25 √ó ‚àö2 <sup>n</sup> times, the sought amplitude will be almost equal to one. <br></li></ul><br>  Imagine, for example, that we need to find a number in the range from 0 to 7, which after a cyclic bit shift to the left will give a number less than 2. On a classical calculator, this class of problems is solved only by brute force.  We would need to calculate our function (bit shift) on all arguments and then apply a condition to each result.  The quantum algorithm allows you to do this instantly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f38/feb/cea/f38febcea6cc7b27ed6a13232b2ff9a8.png"><br><br><h2>  Quantum optimization </h2><br>  All the algorithms and techniques discussed earlier are valid for the so-called universal quantum computer - a computer capable of performing elementary transformations and actually solving any problem (in the simplest case, simulating a classical algorithm). <br><br>  But there is a whole layer of mathematical problems in which, as such, calculations are not required, but it is necessary to find a combination of arguments in which a certain type of function will take the minimum value.  This class of tasks ‚Äî optimization problems ‚Äî will be discussed in more detail below. <br><br><h2>  Quantum annealing </h2><br>  Annealing is a process of gradual cooling of a substance, in which the molecules gather against the background of slowing down of thermal motion in the most energetically favorable configurations.  The term "annealing" came from metallurgy.  In a more energetically favorable state, the metal becomes both harder and stronger: more external action is required, more mechanical work on the piece of metal to break the advantageous configuration of molecules, to ‚Äúlift‚Äù this configuration over the very bottom of the energy well. <br><br>  Like classical annealing, when the interparticle interaction is slowly turned on, the quantum system ‚Äúlooks for‚Äù the energetically most favorable configuration through the effects of quantum mechanics.  Quantum computing based on quantum annealing can solve certain problems that are difficult to solve using classic computers. <br><br>  Consider a math problem known as ‚Äúplaying with light switches‚Äù.  Its goal is to find the best on and off configurations for a variety of switches.  Here is how it looks graphically: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/f4e/7c2/973f4e7c2f768766885e404d9cd0c0b2.png"></div><br>  Imagine that each switch has a weight that we cannot change.  We can enable (ON) or disable (OFF) each switch.  ON stands for multiplication by 1, and OFF for -1.  Then we add all the switch weights multiplied by their ON / OFF values.  The goal of the game is to set the switches to get the lowest amount.  The weight of the i-th switch is denoted by h <sub>i</sub> , and the switch state by s <sub>i</sub> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9db/a7e/d0c/9dba7ed0ccfec268d21e5591fb3bc515.png"></div><br>  Depending on which switches are set to ON or OFF, we get different totals.  Finding the minimum amount will be easy, because there is a simple rule for the guaranteed minimum: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/a7b/823/098a7b8238afc0ecc15f0a1ee90bdf9e.png"></div><br>  If we set all switches with positive indicators to the OFF position, and all switches with negative indicators - to the ON position, then in total we get the lowest total value. <br><br>  Now let's complicate the task: add a new weight J. It will change in accordance with the ON / OFF states of adjacent switches.  And then it is included in the total amount we received earlier. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8be/9de/82f/8be9de82f50ae4011e0efd85e7adaf81.png"></div><br>  It is much more difficult now to decide whether the switch should be on or off because its neighbors influence it.  Even in a simple example with two switches, we cannot simply set the ON / OFF parameter to the position opposite to the sign of the body weight of the switches.  With a complex network of switches, the task becomes practically unsolvable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/593/c92/bc6/593c92bc6c4de678666c72d62e653403.png"></div><br>  With a few switches, we can simply try each combination ON and OFF; there are only four possibilities: [ON ON], [ON OFF], [OFF ON] or [OFF OFF].  But as we add more and more switches, the number of possible ways to install switches increases exponentially: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68d/48e/5ec/68d48e5ec35fb53caf0492ee3eb02b23.png"></div><br>  How will quantum mechanics help?  We start with the system in its quantum superposition, then use the quantum computer (DWave), which, using quantum optimization, finds for the switches the state in which the sum value will be the lowest. <br><br><h2>  "The task of the collector" </h2><br>  Let's formulate a test problem and try to solve it using the DWave quantum computer.  The task sounds like this - the bank has a collection service and a lot of ATMs in the city, from where you need to take money.  The shorter the route, the less chance of getting into an unpleasant situation.  Accordingly, we need to find the optimal route in a weighted directed graph with N vertices.  This task is better known as the ‚ÄúTraveling Salesman Task‚Äù and does not have a better solution than full brute force. <br><br>  In order to solve this problem, you must first understand how to solve problems on DWave.  First we need to develop an input configuration file.  It has the following format: <br><br>  c <br>  c This is a sample .qubo file <br>  c with 4 nodes and 6 couplers <br>  c <br>  p qubo 0 4 4 6 <br>  c - 0 0 3.4 <br>  1 1 4.5 <br>  2 2 2.1 <br>  3 3 -2.4 <br>  c - 0 1 2.2 <br>  0 2 3.4 <br>  1 2 4.5 <br>  0 3 -2 <br>  0 2 3.4 <br>  1 2 4.5 <br>  0 3 -2 <br>  1 3 4.5678 <br>  2 3 -3.22 <br><br>  The lines with comments are marked with ‚Äúc‚Äù, then we set the program parameters in the line beginning with the ‚Äúp‚Äù character.  In this line, we define the topology (so far it is always 0), the number of qubits (in terms of playing with light, these are ‚Äúswitches‚Äù) and the connections between pairs (‚ÄúJ‚Äù scales).  Next is a block with a description of the weights of each qubit.  In this block, the first two numbers must be the same, and they correspond to the qubit number.  The next block is a block of link weights between pairs.  The number of the first qubit should always be less than the second. <br><br>  So, having understood the format, let's proceed to the solution of our problem. <br><br>  First, we highlight the concept of a step of a path ‚Äî this is the set of all possible vertices of the graph in which we can be at the current time.  Each vertex is represented by a qubit.  And we will have N such steps, where N is the number of vertices in our graph. <br><br>  Suppose we have only 4 vertices, at each step we can be in one of 4 vertices, respectively, the entire set of qubits is divided into blocks of 4 qubits.  In our case, from 4 vertices, we will need a register of 16 qubits, we number them - a <sub>0</sub> ... a <sub>16</sub> .  Accordingly, in the first block there will be qubits with numbers a <sub>0</sub> ..a <sub>3</sub> - they correspond to being in one of the vertices in the first step. <br><br>  Now we need to place the weights of the qubits and their connections inside one block so that only one qubit in each block in the final solution is in state 1, and the others in 0. This is due to the fact that in the end we can only be in one of vertices at every step.  It is quite simple to do this - we set the weight of each qubit to -1, and the connections between them to 2. Indeed, if we look at the formula Œ£h <sub>i</sub> s <sub>i</sub> + Œ£J <sub>ij</sub> s <sub>i</sub> s <sub>j</sub> , then we will see that it will be minimal if the second The term will be zero.  And this will happen only in two cases - if all qubits are equal to 0 or if one of them is in 1 and the others in 0. But at the same time, the first term will give a minimum in the second case. <br><br>  So, we expose in this way the weights at all steps (blocks from the peaks) of our path.  Now, if we send our program for execution, we will receive a response of the form (0001 0100 1000 1000).  For convenience, we have divided them into blocks of 4 quits by spaces.  We see that in each block there is only one unit, and its number in the block corresponds to the number of the vertex.  In our solution there are blocks with the same number of vertices - 1000. We need to exclude such solutions, since  we cannot return to the already completed peaks.  In order to do this, we will consider new blocks - combining the same vertex at different steps. <br><br>  Consider the block a <sub>0</sub> , a <sub>4</sub> , a <sub>8</sub> , a <sub>12</sub> .  These qubits correspond to being in the first vertex at the corresponding step.  Similar to the previous paragraph, only one of them must be equal to one - then we will be in the first vertex only once for the entire path.  We set the link weights for all such blocks and send the program for execution.  We receive the answer of a type (0001 0100 1000 0001 0010).  Well, we have already got a path that matches the definition, now we need to find the optimal path according to the weights of the edges of the graph.  To do this, we take the values ‚Äã‚Äãfrom the adjacency matrix of the graph and transfer these values ‚Äã‚Äãto our configuration.  After that we get the result. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b9/b9e/741/3b9b9e741eeea7ad666fdb3ac8c55f66.png"><br>  <i>Solution before parsing</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/954/d91/09c/954d9109c8fde3c7d81761110a6c965d.png"><br>  <i>Solution after parsing</i> <br><br>  In fact, programming on a DWave quantum computer is a bit more complicated, since it is necessary to take into account the physical partition of the entire register into blocks of 8 qubits, etc.  Without this, some of the combinations may not be considered, and as a result we will get some local minimum instead of a global one, but even such a simple program gives excellent results compared to classical methods. <br><br>  We conducted a test run on 14 vertices on a specific graph.  The search algorithm found the shortest path with a length of 91, the work took about 10 minutes.  The Little method worked almost instantly and gave the result 104. The quantum algorithm also worked almost instantly and gave the result 97. At the same time, if the program on a quantum computer is built taking into account the physical connections, then we will get a result similar to the search. <br><br>  The maximum graph, which at the moment we can process using a quantum calculator, contains 44 vertices.  On a classical calculator, in general, it will take a disproportionately longer amount of time, since  complexity grows by the formula n! .. <br><br>  A quantum computer built on the principles of annealing, has more power than the existing universal computers, but it is limited to the class of tasks.  We do not have the opportunity to set the initial states of the qubits or to perform any unitary transformations on them - we have only one possibility - to find a combination in which the value of the function Œ£h <sub>i</sub> s <sub>i</sub> + Œ£J <sub>ij</sub> s <sub>i</sub> s <sub>j</sub> with a given configuration will be minimal.  However, even with this limitation, quantum computers show significant performance gains and can be effectively used in optimization problems. <br><br><h2>  Quantum computers today </h2><br>  At the moment there are the following main areas of implementation of quantum computers: <br><br><ul><li>  On ions in a one-dimensional ionic crystal trapped in Paul. <br></li><li>  In semiconductor crystals of a spinless monoisotopic silicon crystal <br></li><li>  Qubits on electrons in semiconductor quantum dots. <br></li><li>  Qubits on superconducting mesostructures. <br></li><li>  On single atoms in microresonators. <br></li><li>  With the help of linear optical elements (optical quantum computer). <br></li></ul><br>  The most developed to date are the quantum computers DWave and IBM Q <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eae/f6e/18a/eaef6e18a015bba6bc527af824d9d6e4.png"><br><br>  DWave has the status of an ‚Äúanalog quantum computer‚Äù, as it is capable of solving only a narrow circle of quantum annealing problems.  But at the same time, its declared capacity is 2,000 qubits. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc4/9ec/20c/dc49ec20c93a53991be00571de71dc7f.png"><br><br>  IBM Q is a program for developing universal quantum computers on which arbitrary quantum algorithms can be executed.  Currently, there are 20 qubit systems in operation (commercial use), and Q Experience open systems for 16 and 5 qubits.  Q Experience now, perhaps, the only open platform that allows you to develop quantum algorithms.  It is a set of atomic gates that can be applied to qubits. <br><br><h2>  Using quantum computing </h2><br>  In addition to the scenarios described earlier, quantum computing may work fine in other areas. <br><br>  Quantum cryptography.  Information security is based on the fact that the decryption task is not solvable.  Quantum cryptography is based on the impossibility of breaking the laws of physics.  One example is the exchange of BB84 secret keys.  Vasya gives Masha a set of quantum particles.  Jealous attacker Petya listens on the communication channel and can intercept particles.  But for this Petya will have to measure them.  He will inevitably destroy their original state, which Vasya and Masha will know. <br><br>  Blockchain protection.  In principle, it is based on the fact that miners need a large amount of time in order to use the search to find the number at which the block hash is less than a certain threshold.  This does not allow to replace the block - until the new hash is calculated, the chain will go far ahead.  Due to parallelism, a quantum blockchain can instantly find a number at which the block hash will be unattainably small for classical computers.  Thus, it will be possible to attack the network only if 51% of quantum miners are captured.  And this brings trust to a new level - collusion of more than half of players with such opportunities is unlikely. <br><br>  It is known that in 2014, Chinese researchers first implemented handwriting recognition using quantum computing. <br><br>  Finally, instant processing of a colossal amount of data and solving optimization problems make quantum technologies one of the most promising tools in the field of artificial intelligence and machine learning.  For this reason, in 2013, Google and NASA created a joint research laboratory in this area. <br><br>  <i>Based on the materials of <a href="https://habrahabr.ru/users/dsapaev/">Dmitry Sapaev</a> , senior director of IT systems development in the development department of Sberbank Technologies TIC, and Dmitry Bulychkov, project director at the Center for Technological Innovations of Sberbank.</i> <i><br></i> </div><p>Source: <a href="https://habr.com/ru/post/344830/">https://habr.com/ru/post/344830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344816/index.html">Challenges with ZeroNights 2017: Become the king of captcha</a></li>
<li><a href="../344818/index.html">Load testing on the Gatling framework</a></li>
<li><a href="../344822/index.html">Dirty tricks and RAM</a></li>
<li><a href="../344824/index.html">Deep Learning with Spark and Hadoop: Meet Deeplearning4j</a></li>
<li><a href="../344826/index.html">Microkernel vs. monolith and the "triumph" of MINIX</a></li>
<li><a href="../344832/index.html">Stay lazy with angular / cli</a></li>
<li><a href="../344834/index.html">In France, bitcoins are not money</a></li>
<li><a href="../344836/index.html">Lack of RAM in Linux on a working PC: optimization and actions when it hangs</a></li>
<li><a href="../344840/index.html">Tutorial on the Unreal Engine. Part 6: Animation</a></li>
<li><a href="../344842/index.html">Description of business processes. Use caution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>