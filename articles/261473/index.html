<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We teach Raspberry Pi to accept telegrams with the help of Bot API and Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long wanted to fasten a convenient ‚Äúcommunication‚Äù interface to my home Raspberry Pi, which would satisfy the main requirement - simplicity and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We teach Raspberry Pi to accept telegrams with the help of Bot API and Python</h1><div class="post__text post__text-html js-mediator-article">  I have long wanted to fasten a convenient ‚Äúcommunication‚Äù interface to my home Raspberry Pi, which would satisfy the main requirement - simplicity and ease, with access from anywhere in the world and using any equipment (but first of all from a smartphone). <br><br>  Due to the lack of a dedicated IP at home and the presence of harsh and incorruptible NAT, options with SSH clients and web interfaces disappeared immediately.  For small needs, the solution should also be simple, fast and, as a bonus, reliable.  So the idea of ‚Äã‚Äãusing the protocol of one of the common messengers seemed to me very attractive.  Jabber, Telegram and WhatsApp got under the scope. <br><br>  Jabber played against the reluctance to install an extra client.  Well, since Telegram is, IMHO, the same WhatsApp, only better and more convenient (and even a bit safer), it was there that I decided to make my choice.  In addition, the opportunity recently appeared in Telegram to create their <s>slave</s> bots and interact with them using a very simple API allows you to get rid of the need to register a new account, as well as provides some very useful and convenient features. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In fact, everything is really so simple that even 30 minutes are enough for experienced people to figure out, raise and set up their bot.  To the rest: Welcome! <br><a name="habracut"></a><br>  The search result in Runet on the phrase "Telegram &amp; Raspberry" was rich only in the article with Habr <a href="http://habrahabr.ru/post/249265/">"Raspberry and Telegram: prerequisites for creating a smart home"</a> , which describes the basic manipulations with the Telegram client.  By the way, I didn‚Äôt manage to get enough raw product and make it work normally (out of the blue the same commands refuse to parse one time).  But, fortunately, I don‚Äôt need it anymore. <br><br>  So, we need to create a bot, for which in any Telegram client (preferably the latest version) we find a contact with the name BotFather and ask it for / help.  To which he will respond with sufficiently detailed instructions and will only have to follow it.  Commands for absolutely lazy people: <br><br><pre><code class="hljs xml">/newbot <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"></span></span></span><span class="hljs-tag">   &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">username</span></span></span><span class="hljs-tag">  &gt;</span></span></code> </pre> <br>  Done!  Now BotFather will offer us to remember / save the token for access to the bot via the HTTP API, which will come in handy soon. <br><br>  As a programmer, I am very beginner, I know only Python well, which, nevertheless, is perfect for this task.  Let's start. <br><br>  To make life easier and shorten the code, I suggest installing a library to simplify requests for HTTP <a href="http://habrahabr.ru/post/126262/">requests</a> using the command: <br><br><pre> <code class="bash hljs">pip install requests</code> </pre><br>  Now the whole task is reduced to writing a simple script that, after a specified period of time, will request updates from the server.  If there are any and the message is sent by a predetermined user, and also contains a specified command in the text, then the action corresponding to this command will be performed.  Such a script I bring to your attention.  So far this is just a template that can be adapted to your needs, but over time I plan to make something more decent from it. <br><br><div class="spoiler">  <b class="spoiler_title">telegram.py (python2.7) - updated</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- import requests import time import subprocess import os #import mailchecker requests.packages.urllib3.disable_warnings() #  InsecureRequestWarning,        #           Telegram   @BotFather # ADMIN_ID -   (  ),    #    ID,         ()    #         GET  #          ,  &lt;token&gt;   : # https://api.telegram.org/bot&lt;token&gt;/getUpdates # ,     "from":{"id":01234567,"first_name":"Name","username":"username"} #   ,     #   ,     "id" -      #  ADMIN_ID  TOKEN      INTERVAL = 3 #      ()     ADMIN_ID = 12345678 # ID .        URL = 'https://api.telegram.org/bot' #  HTTP Bot API TOKEN = '123456789:???????????????????????????????????' #      offset = 0 # ID    def check_updates(): """      ,    """ global offset data = {'offset': offset + 1, 'limit': 5, 'timeout': 0} #    try: request = requests.post(URL + TOKEN + '/getUpdates', data=data) #    except: log_event('Error getting updates') #   return False #   if not request.status_code == 200: return False #    if not request.json()['ok']: return False #     API for update in request.json()['result']: #     offset = update['update_id'] #  ID  # ,      'message' #     'message'   'text',  if not 'message' in update or not 'text' in update['message']: log_event('Unknown update: %s' % update) #      continue #      from_id = update['message']['chat']['id'] #  ID  () name = update['message']['chat']['username'] #  username  if from_id &lt;&gt; ADMIN_ID: #     ,  send_text("You're not autorized to use me!", from_id) #     log_event('Unautorized: %s' % update) #     continue #       message = update['message']['text'] #    parameters = (offset, name, from_id, message) log_event('Message (id%s) from %s (id%s): "%s"' % parameters) #    ID    #    ,    run_command(*parameters) def run_command(offset, name, from_id, cmd): if cmd == '/ping': #   ping send_text(from_id, 'pong') #   elif cmd == '/help': #   help send_text(from_id, 'No help today. Sorry.') #  elif cmd == '/photo': #     Web- #   If .     -  ,  ,      #     ,     #  ,             if make_photo(offset) or make_photo(offset): # ,       requests.post(URL + TOKEN + '/sendChatAction', data={'chat_id': from_id, 'action': 'upload_photo'}) send_photo(from_id, offset) #     else: send_text(from_id, 'Error occured') # ,    elif cmd == '/mail': check_mail() #     else: send_text(from_id, 'Got it.') #   def log_event(text): """   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">ToDo:</span></span></span><span class="hljs-comment"> 1)     """ event = '%s &gt;&gt; %s' % (time.ctime(), text) print event def send_text(chat_id, text): """    chat_id </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">ToDo:</span></span></span><span class="hljs-comment">    """ log_event('Sending to %s: %s' % (chat_id, text)) #     data = {'chat_id': chat_id, 'text': text} #   request = requests.post(URL + TOKEN + '/sendMessage', data=data) # HTTP  if not request.status_code == 200: #    return False #    return request.json()['ok'] #     API def make_photo(photo_id): """   fswebcam     Web-""" photo_name = 'photo/%s.jpg' % photo_id #     subprocess.call('fswebcam -q -r 1280x720 %s' % photo_name, shell=True) #  shell- return os.path.exists(photo_name) # ,       def send_photo(chat_id, photo_id): """      """ data = {'chat_id': chat_id} #    photo_name = 'photo/%s.jpg' % photo_id #     if not os.path.exists(photo_name): return False #    files = {'photo': open(photo_name, 'rb')} #     request = requests.post(URL + TOKEN + '/sendPhoto', data=data, files=files) #   return request.json()['ok'] #  True  False,    ,     def check_mail(): """      """ print "     " return False try: log_event('Checking mail...') #    respond = mailchecker.check_all() #      except: log_event('Mail check failed.') #    return False #     if not respond: respond = 'No new mail.' #   ,       send_text(ADMIN_ID, respond) #     return True if __name__ == "__main__": while True: try: check_updates() time.sleep(INTERVAL) except KeyboardInterrupt: print ' ..' break</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Tips</b> <div class="spoiler_text">  To run this script in the background on the Raspberry Pi, you can use two methods: <br>  1) Using screen.  Instructions for use <a href="http://s.arboreus.com/2008/01/screen.html">here</a> . <br>  2) Teams: <br><br><pre> <code class="bash hljs">python telegram.py CTRL+Z <span class="hljs-built_in"><span class="hljs-built_in">bg</span></span></code> </pre><br>  If you want to put this script into autorun, you need to add to the /etc/rc.local file, before the line 'exit 0',: <br><pre> <code class="bash hljs">python &lt;  &gt;/telegram.py</code> </pre><br>  For example: <pre> <code class="bash hljs">nano /etc/rc.local ... python /home/pi/telegram.py <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 0</code> </pre><br><br>  And of course, python2.7 should be installed on your Raspberry. <br></div></div><br>  This, of course, is just the beginning, the outline.  A little later I will screw some interesting features.  For example, taking a snapshot from a camera on a team and some more difficult, such as managing a garland on WS2801 and others. <br><br>  I would be very happy with any comments, suggestions and suggestions. <br><br>  Also, as you have already noticed, the script checks messages with a certain period of time.  Implementing a WebHook reception without an intermediary is not possible.  It was played with ‚Äútimeout‚Äù values ‚Äã‚Äãin the ‚ÄúgetUpdates‚Äù method, to no avail.  I would be grateful for any ideas on this matter. <br><br>  [ <a href="https://core.telegram.org/bots/api">Telegram Bot API</a> ] <br><br>  UPD (03.07).  Code updated. </div><p>Source: <a href="https://habr.com/ru/post/261473/">https://habr.com/ru/post/261473/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261461/index.html">Automate routine operations between Excel and AutoCAD using VBA</a></li>
<li><a href="../261463/index.html">Comparing the speed of .NET providers for working with Oracle DB</a></li>
<li><a href="../261467/index.html">Rapid development on 1C-Bitrix or how I met gulp</a></li>
<li><a href="../261469/index.html">Love and mathematics. Heart of hidden reality</a></li>
<li><a href="../261471/index.html">Started Golden Site 2015</a></li>
<li><a href="../261475/index.html">Alternative to callback</a></li>
<li><a href="../261477/index.html">OpenCV and the illusion of circles on the water</a></li>
<li><a href="../261479/index.html">Static build dll-library with QtQuick modules</a></li>
<li><a href="../261481/index.html">Backing up physical machines with Veeam Endpoint Backup FREE</a></li>
<li><a href="../261483/index.html">Tame JMeter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>