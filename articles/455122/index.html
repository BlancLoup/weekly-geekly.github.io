<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Faster alternative to Java Reflection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Today we want to share with you a translation of an article prepared specifically for students of the Java Developer course. 

 In my article, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Faster alternative to Java Reflection</h1><div class="post__text post__text-html js-mediator-article"> Hello.  Today we want to share with you a translation of an article prepared specifically for students of <a href="https://otus.pw/Xxm3/">the Java Developer</a> course. <br><br>  In my article, <a href="https://medium.com/%40carlosraphael/specification-design-pattern-in-java-8-bac6f5f943bc">Specification Pattern</a> (Pattern Specification), I did not specifically mention the underlying component, which greatly helped in implementation.  Here I will talk more about the <a href="">JavaBeanUtil</a> class that I used to get the value of an object field.  In that example, it was <a href="">FxTransaction</a> . <br><br>  Of course, you say that you can use <a href="http://commons.apache.org/proper/commons-beanutils/">Apache Commons BeanUtils</a> or one of its alternatives to get the same result.  But it was interesting for me to delve into it and what I learned works much faster than any library built on the basis of the well-known <a href="https://www.oracle.com/technetwork/articles/java/javareflection-1536171.html">Java Reflection</a> . <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The technology to avoid very slow reflection is the <code>invokedynamic</code> bytecode <code>invokedynamic</code> .  In short, <code>invokedynamic</code> (or "indy") was the most serious innovation in Java 7, which allowed us to pave the way for implementing dynamic languages ‚Äã‚Äãon top of the JVM using dynamic method invocation.  Later, in Java 8, it also allowed for <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">lambda expressions</a> and method reference references, as well as improved string concatenation in Java 9. <br><br>  In a nutshell, the technique I am going to describe below uses the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html">LambdaMetafactory</a> and <a href="https://docs.oracle.com/javase/8/docs/api/index.html%3Fjava/lang/invoke/MethodHandles.html">MethodHandle</a> to dynamically create the implementation of the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html">Function</a> interface.  In Function, there is a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html">single method</a> that delegates the call to the actual target method with the code defined inside the lambda. <br><br>  In this case, the target method is the getter, which has direct access to the field that we want to read.  Also, I have to say that if you are familiar with the innovations that have appeared in Java 8, then you will find the code snippets below rather simple.  Otherwise, the code may seem complicated at first glance. <br><br><h2>  Let's take a look at self-made JavaBeanUtil </h2><br>  The <code>getFieldValue</code> method <code>getFieldValue</code> is a utility method used to read values ‚Äã‚Äãfrom a JavaBean field.  It accepts a JavaBean object and a field name.  The field name can be simple (for example, <code>fieldA</code> ) or nested, separated by dots (for example, <code>nestedJavaBean.nestestJavaBean.fieldA</code> ). <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Pattern FIELD_SEPARATOR = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"\\."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MethodHandles.Lookup LOOKUP = MethodHandles.lookup(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ClassValue&lt;Map&lt;String, Function&gt;&gt; CACHE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassValue&lt;Map&lt;String, Function&gt;&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Map&lt;String, Function&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;?&gt; type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentHashMap&lt;&gt;(); } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFieldValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object javaBean, String fieldName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) getCachedFunction(javaBean.getClass(), fieldName).apply(javaBean); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCachedFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;?&gt; javaBeanClass, String fieldName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Function function = CACHE.get(javaBeanClass).get(fieldName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (function != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> function; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> createAndCacheFunction(javaBeanClass, fieldName); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAndCacheFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;?&gt; javaBeanClass, String path)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cacheAndGetFunction(path, javaBeanClass, createFunctions(javaBeanClass, path) .stream() .reduce(Function::andThen) .orElseThrow(IllegalStateException::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>) ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheAndGetFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String path, Class&lt;?&gt; javaBeanClass, Function functionToBeCached)</span></span></span><span class="hljs-function"> </span></span>{ Function cachedFunction = CACHE.get(javaBeanClass).putIfAbsent(path, functionToBeCached); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedFunction != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? cachedFunction : functionToBeCached; }</code> </pre> <br><br>  To improve performance, I cache a function created dynamically, which in fact will read the value from the field named <code>fieldName</code> .  In the <code>getCachedFunction</code> method, as you can see, there is a ‚Äúfast‚Äù path using <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassValue.html">ClassValue</a> for caching, and a ‚Äúslow‚Äù path <code>createAndCacheFunction</code> , which is executed if the value in the cache is not found. <br><br>  The <code>createFunctions</code> method calls a method that returns a list of functions that will be chained using <code>Function::andThen</code> .  Linking functions to each other in a chain can be represented as nested calls, similar to <code>getNestedJavaBean().getNestJavaBean().getNestJavaBean().getFieldA()</code> .  After that, we simply put the function in the cache by calling the <code>cacheAndGetFunction</code> method. <br>  If you look more closely at the creation of a function, we need to go through the fields in the <code>path</code> as follows: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Function&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createFunctions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;?&gt; javaBeanClass, String path)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;Function&gt; functions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Stream.of(FIELD_SEPARATOR.split(path)) .reduce(javaBeanClass, (nestedJavaBeanClass, fieldName) -&gt; { Tuple2&lt;? extends Class, Function&gt; getFunction = createFunction(fieldName, nestedJavaBeanClass); functions.add(getFunction._2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getFunction._1; }, (previousClass, nextClass) -&gt; nextClass); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> functions; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Tuple2&lt;? extends Class, Function&gt; createFunction(String fieldName, Class&lt;?&gt; javaBeanClass) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Stream.of(javaBeanClass.getDeclaredMethods()) .filter(JavaBeanUtil::isGetterMethod) .filter(method -&gt; StringUtils.endsWithIgnoreCase(method.getName(), fieldName)) .map(JavaBeanUtil::createTupleWithReturnTypeAndGetter) .findFirst() .orElseThrow(IllegalStateException::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); }</code> </pre> <br><br>  The above <code>createFunctions</code> method for each <code>fieldName</code> field and the class in which it is declared calls the <code>createFunction</code> method, which searches for the desired getter, using <code>javaBeanClass.getDeclaredMethods()</code> .  Once the getter is found, it is converted to a Tuple tuple (Tuple from the <a href="http://www.vavr.io/">Vavr</a> library), which contains the type returned by the getter, and a dynamically created function that will behave as if it were itself a getter. <br>  Creating a tuple is done with the <code>createTupleWithReturnTypeAndGetter</code> method in combination with the <code>createCallSite</code> method as follows: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Tuple2&lt;? extends Class, Function&gt; createTupleWithReturnTypeAndGetter(Method getterMethod) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Tuple.of( getterMethod.getReturnType(), (Function) createCallSite(LOOKUP.unreflect(getterMethod)).getTarget().invokeExact() ); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Lambda creation failed for getterMethod ("</span></span> + getterMethod.getName() + <span class="hljs-string"><span class="hljs-string">")."</span></span>, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CallSite </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCallSite</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MethodHandle getterMethodHandle)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> LambdaConversionException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LambdaMetafactory.metafactory(LOOKUP, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(Function.class), MethodType.methodType(Object.class, Object.class), getterMethodHandle, getterMethodHandle.type()); }</code> </pre> <br><br>  In the above two methods, I use a constant called <code>LOOKUP</code> , which is simply a reference to <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandles.Lookup.html">MethodHandles.Lookup</a> .  With its help I can create a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandleInfo.html">direct link to the method</a> (direct method handle), based on the previously found getter.  And finally, the created <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html">MethodHandle</a> is passed to the <code>createCallSite</code> method, in which the body of the lambda is created for the function using the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html">LambdaMetafactory</a> .  From there, ultimately, we can get an instance of <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html">CallSite</a> , which is the ‚Äúkeeper‚Äù of the function. <br>  Note that you can use a similar approach for setters using <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html">BiFunction</a> instead of <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html">Function</a> . <br><br><h2>  Benchmark </h2><br>  To measure performance, I used a great <a href="https://openjdk.java.net/projects/code-tools/jmh/">Java Microbenchmark Harness JMH tool</a> , which will probably be part of JDK 12 ( <i>Translator‚Äôs Note: yes, jmh entered java 9</i> ).  As you may know, the result depends on the platform, so for reference: I will use <code>1x6 i5-8600K 3,6   Linux x86_64,   Oracle JDK 8u191  GraalVM EE 1.0.0-rc9</code> . <br>  For comparison, I chose the <a href="http://commons.apache.org/proper/commons-beanutils/">Apache Commons BeanUtils library</a> , widely known by most Java developers, and one of its alternatives called <a href="https://jodd.org/beanutil/">Jodd BeanUtil</a> , which is said to work <a href="https://jodd.org/beanutil/performance.html">almost 20% faster</a> . <br><br>  The benchmark code looks like this: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Fork</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Warmup</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Measurement</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JavaBeanUtilBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({ <span class="hljs-string"><span class="hljs-string">"fieldA"</span></span>, <span class="hljs-string"><span class="hljs-string">"nestedJavaBean.fieldA"</span></span>, <span class="hljs-string"><span class="hljs-string">"nestedJavaBean.nestedJavaBean.fieldA"</span></span>, <span class="hljs-string"><span class="hljs-string">"nestedJavaBean.nestedJavaBean.nestedJavaBean.fieldA"</span></span> }) String fieldName; JavaBean javaBean; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ NestedJavaBean nestedJavaBean3 = NestedJavaBean.builder().fieldA(<span class="hljs-string"><span class="hljs-string">"nested-3"</span></span>).build(); NestedJavaBean nestedJavaBean2 = NestedJavaBean.builder().fieldA(<span class="hljs-string"><span class="hljs-string">"nested-2"</span></span>).nestedJavaBean(nestedJavaBean3).build(); NestedJavaBean nestedJavaBean1 = NestedJavaBean.builder().fieldA(<span class="hljs-string"><span class="hljs-string">"nested-1"</span></span>).nestedJavaBean(nestedJavaBean2).build(); javaBean = JavaBean.builder().fieldA(<span class="hljs-string"><span class="hljs-string">"fieldA"</span></span>).nestedJavaBean(nestedJavaBean1).build(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invokeDynamic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JavaBeanUtil.getFieldValue(javaBean, fieldName); } <span class="hljs-comment"><span class="hljs-comment">/** * Reference: http://commons.apache.org/proper/commons-beanutils/ */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apacheBeanUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PropertyUtils.getNestedProperty(javaBean, fieldName); } <span class="hljs-comment"><span class="hljs-comment">/** * Reference: https://jodd.org/beanutil/ */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">joddBean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BeanUtil.declared.getProperty(javaBean, fieldName); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException, RunnerException </span></span>{ Main.main(args); } }</code> </pre> <br><br>  The benchmark defines four scenarios for different levels of nesting fields.  For each field, the JMH will perform 5 iterations of 3 seconds to warm up, and then 5 iterations of 1 second to actually measure.  Each scenario will be repeated 3 times to get better measurements. <br><br><h2>  results </h2><br>  Let's start with the results compiled for JDK <code>8u191</code> : <br><br><img src="https://habrastorage.org/webt/h9/hc/ue/h9hcuethoke9prgfx9oahiwz0ge.png"><br>  <i>Oracle JDK 8u191</i> <br><br>  The worst scenario using the <code>invokedynamic</code> approach is much faster than the fastest of the other two libraries.  This is a huge difference, and if you doubt the results, you can always download the <a href="https://github.com/carlosraphael/javabeanutil-benchmark">source code</a> and play with it as you like. <br><br>  Now let's see how the same test works with <code>GraalVM EE 1.0.0-rc9.</code> <br><br><img src="https://habrastorage.org/webt/hd/fk/ld/hdfkldnwbbhhz7f-gpbtziookgq.png"><br>  <i>GraalVM EE 1.0.0-rc9</i> <br><br>  Full results can be viewed <a href="https://gist.githubusercontent.com/carlosraphael/27723493d2161ea078e29a1f7fc15dd2/raw/5975d3b609e1c0cb14c47f7ab76e38c053be64b3/JavaBeanUtilBenchmark_result.json">here</a> with the beautiful JMH Visualizer. <br><br><h2>  Observations </h2><br>  Such a big difference is due to the fact that the JIT compiler knows <code>CallSite</code> and <code>MethodHandle</code> well and can inline them (inline), unlike the approach with reflection.  In addition, you can see how promising <a href="https://www.graalvm.org/">GraalVM is</a> .  His compiler does a really awesome job that can significantly increase the performance of reflection. <br><br>  If you are interested and you want to delve deeper, I urge you to take the code from my repository on <a href="https://github.com/carlosraphael/javabeanutil-benchmark">Github</a> .  Keep in mind, I do not advise you to make a custom <code>JavaBeanUtil</code> to use in production.  My goal is simply to show my experiment and the possibilities that we can get from <code>invokedynamic</code> . <br><br>  This is the end of the translation, and we invite everyone to join the <a href="https://otus.pw/gNBY/">free webinar</a> on June 13, where we will consider how the Docker can be useful for a Java developer: how to make a docker image with a java application and how to interact with it. </div><p>Source: <a href="https://habr.com/ru/post/455122/">https://habr.com/ru/post/455122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455106/index.html">Software development. Trends 2019</a></li>
<li><a href="../455110/index.html">Does the level of happiness of employees depend on interesting tasks? Tell SKB Kontur, Dodo Pizza, Staply and Alternativa Games</a></li>
<li><a href="../455112/index.html">"Bitriks24": "Quickly raised is not considered fallen"</a></li>
<li><a href="../45512/index.html">Clone</a></li>
<li><a href="../455120/index.html">Wifi is not for everyone. How to authorize foreigners online by law?</a></li>
<li><a href="../455126/index.html">Smart clothes of the future: is there potential?</a></li>
<li><a href="../455130/index.html">3 popular tools for organizing continuous deployment (Continuous Deployment)</a></li>
<li><a href="../455132/index.html">Antiquities: Philips Velo 1, tech enthusiast nightmare</a></li>
<li><a href="../455138/index.html">JetBrains Night Moscow: how it was</a></li>
<li><a href="../455148/index.html">Solve decision-making tasks based on data.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>