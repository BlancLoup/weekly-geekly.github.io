<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write a bloom filter in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A Bloom filter is a data structure that can effectively determine whether an element is a possible element of a set or is definitely not related to it...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write a bloom filter in C ++</h1><div class="post__text post__text-html js-mediator-article">  A Bloom filter is a data structure that can effectively determine whether an element is a possible element of a set or is definitely not related to it.  This article will demonstrate a simple implementation of the Bloom filter in C ++. <br><br><img src="https://habrastorage.org/files/9cd/015/375/9cd0153758b2462dabdae6fa54e5bd8e.png"><a name="habracut"></a><br><br><h4>  Interface </h4><br>  Let's first define the interface of this filter.  There are three main functions: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Constructor </li><li>  Function to add an element to bloom's filter </li><li>  The function for querying whether an element is part of the Bloom filter </li></ul><br>  Several variables involved, including a small number of vectors, also contain a filter state. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; struct BloomFilter { BloomFilter(uint64_t size, uint8_t numHashes); void add(const uint8_t *data, std::size_t len); bool possiblyContains(const uint8_t *data, std::size_t len) const; private: uint64_t m_size; uint8_t m_numHashes; std::vector&lt;bool&gt; m_bits; };</span></span></span></span></code> </pre> <br>  It should be noted that <code>std::vector&lt;bool.&gt;</code> Is a much more efficient specialization of <code>std::vector,</code> requires only one bit per element (as opposed to one byte in typical implementations). <br><br>  You can process this structure on the template, as an extension.  Instead of hard coding key types and hash functions, we can process the class with a pattern with something similar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Key</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hash</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:hash&lt;Key&gt; &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BloomFilter</span></span></span><span class="hljs-class"> {</span></span> ... };</code> </pre><br>  This will allow the Bloom filter to be generalized for more complex data types. <br><br><h4>  Bloom filter options </h4><br>  There are two options for building a Bloom filter: <br><br><ul><li>  Filter size in bits </li><li>  The number of hash functions to use </li></ul><br>  We can calculate a false positive error rate ‚Äî n, based on the size of the filter ‚Äî m, the number of hash functions ‚Äî K, and the number of nested elements ‚Äî N, using the formula: <br><br><img src="https://habrastorage.org/files/71a/9c6/8f8/71a9c68f8bdb4e279e837d2935392d99.jpg"><br><br>  This formula is not very useful in this form.  But we need to know how big the filter should be and how many hash functions it will need to use, given the estimated number of elements of the set and the error rate.  There are two equations that we can use to calculate these parameters: <br><br><img src="https://habrastorage.org/files/512/c44/a9d/512c44a9dc334b698f71f65812a41002.jpg"><br><br><h4>  Implementation </h4><br>  You may wonder how to implement kk hash functions;  double hashing can be used to generate kk hash values ‚Äã‚Äãwithout affecting the probability of a false-positive result!  This result can be obtained using the formula, where i is the ordinal, m is the size of the Bloom filter and x is the value to be hashed: <br><br><img src="https://habrastorage.org/files/460/29a/495/46029a49519140908c8677d2dfee050e.jpg"><br><br>  First you need to write a constructor.  It simply writes scaling parameters and a bitmap. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BloomFilter.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"MurmurHash3.h"</span></span></span><span class="hljs-meta"> BloomFilter::BloomFilter(uint64_t size, uint8_t numHashes) : m_size(size), m_numHashes(numHashes) { m_bits.resize(size); }</span></span></code> </pre><br>  Next, let's write a function to calculate the 128-bit hash of this element.  This implementation uses <a href="https://github.com/aappleby/smhasher">MurmurHash3</a> , a 128-bit hash function, which has good trade-offs between performance, distribution, streaming behavior, and resistance to inconsistencies.  Since this function generates 128-bit hash and we need 2x64 bit hashes, we can split the returned hash in half to get the hash <sub>a</sub> (x) hash <sub>b</sub> (x). <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>, 2&gt; hash(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *data, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>, 2&gt; hashValue; MurmurHash3_x64_128(data, len, <span class="hljs-number"><span class="hljs-number">0</span></span>, hashValue.data()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashValue; }</code> </pre><br>  Now that we have a hash value, we need to write a function to return the output n of the hash function. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint64_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nthHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hashA, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hashB, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filterSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (hashA + n * hashB) % filterSize; }</code> </pre><br>  All that remains to be done is to write functions for the set of check bits for the given elements. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BloomFilter::add(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *data, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> hashValues = hash(data, len); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; m_numHashes; n++) { m_bits[nthHash(n, hashValues[<span class="hljs-number"><span class="hljs-number">0</span></span>], hashValues[<span class="hljs-number"><span class="hljs-number">1</span></span>], m_size)] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BloomFilter::possiblyContains(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *data, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> len) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> hashValues = hash(data, len); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; m_numHashes; n++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_bits[nthHash(n, hashValues[<span class="hljs-number"><span class="hljs-number">0</span></span>], hashValues[<span class="hljs-number"><span class="hljs-number">1</span></span>], m_size)]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><h4>  results </h4><br>  Using the Bloom 4.3MB filter and 13 hash functions, inserting 1.8MB elements took about 189 nanoseconds for each element on average laptop performance. <br><br>  The original of this post can be found at the <a href="http://blog.michaelschmatz.com/2016/04/11/how-to-write-a-bloom-filter-cpp/">link</a> . </div><p>Source: <a href="https://habr.com/ru/post/281517/">https://habr.com/ru/post/281517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281505/index.html">How we implemented DevOps: infrastructure-as-code using Microsoft Azure and Azure Resource Manager</a></li>
<li><a href="../281509/index.html">5G core networks: flexibility opens up new business opportunities</a></li>
<li><a href="../281511/index.html">// BUILD / 2016: how it was</a></li>
<li><a href="../281513/index.html">What we lack in java</a></li>
<li><a href="../281515/index.html">How to determine the best time for a transaction in the stock market: Trend following algorithms</a></li>
<li><a href="../281519/index.html">More than 80 Linux system monitoring tools</a></li>
<li><a href="../281521/index.html">What's new in Vim 8</a></li>
<li><a href="../281523/index.html">Develop HTML5 games in Intel XDK. Part 3. Meet the Snake</a></li>
<li><a href="../281525/index.html">Junior FPGA Design Engineer: how to become?</a></li>
<li><a href="../281529/index.html">Microsoft fixed badlock vulnerability in Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>