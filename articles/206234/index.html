<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tasks for interviews in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are always vacancies for the position of developer in Yandex. The company is developing, and there are not enough good programmers all the time....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tasks for interviews in Yandex</h1><div class="post__text post__text-html js-mediator-article">  There are always vacancies for the position of developer in Yandex.  The company is developing, and there are not enough good programmers all the time.  And applicants for these posts, too, more than enough.  The main difficulty is to select the really suitable candidates.  And in this regard, Yandex is not much different from most large IT-companies.  So the basic principles described in this article can be applied not only to Yandex. <br><br>  However, it is worth making a reservation that the article is still about the selection of developers.  Those.  actually those eighty percent of employees on whom mass development keeps.  Often we hire people for special vacancies: for example, computer vision systems developers, linguists, machine learning experts.  In this case, the format of the interview may differ markedly. <br><br> <a href="http://habrahabr.ru/company/yandex/blog/206234/"><img src="https://habrastorage.org/getpro/habr/post_images/8db/d9b/c69/8dbd9bc695f98c2ac16fe0755f4c07f0.jpg" alt="image"></a> <br><a name="habracut"></a><br><h4>  What to expect at the interview </h4><br>  Resume and work experience allows you to make a first impression about the candidate, but there is some problem: the ability to write a good resume and the ability to program are not strongly correlated.  So there are a huge number of people who, with an excellent resume and ‚Äúexperience‚Äù, cannot write a working code, and there are a number of candidates whose resume is depressing, and the people themselves are worthwhile professionals.  Therefore, in order to truly appreciate the possibilities of a developer, one cannot do without direct communication. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Sometimes, to understand that a candidate does not fit, ten minutes is enough: if a person is embarrassed by basic questions about the syntax of the language in which he claims he wrote for several years, further conversation does not make sense.  That is why most often the first stage of a series of interviews in Yandex is usually conducted via Skype.  Still, to deny a person who got to the office an hour by traffic jams in the fifth minute of the interview is not good from the point of view of politeness, and another 2 hours to torment him, knowing that you most likely will not take it from the point of view of ethics.  Accordingly, a remote interview allows you to save time and nerves for both parties. <br><br>  With questions about syntax, the main thing is not to overdo it, intentionally trying to catch it on some little-known fact.  There are programming languages ‚Äã‚Äãwith a very long and difficult history, which have about half of their capabilities - some kind of historically complex and unnecessary crutches.  These include, for example, our favorite C ++.  If you are not a C ++ compiler developer, you can almost always find something that you don‚Äôt know in the language.  It's just not clear why you might need it. <br><br>  We usually use pre-prepared language tests that include 10-15 questions on the knowledge of syntax, language capabilities, memory management principles, etc.  Most often, to successfully complete answers to all the questions is not required, 70-80 percent is enough.  And in general, the test itself is rather not a test, but a set of topics for which you need to talk, we are more interested in not the answer itself (we already know it), and why the candidate chose it. <br><br>  An important point is the knowledge of algorithms.  Here, too, you need not to overdo it, probably very few of the people who conduct interviews themselves, remember by heart how to rotate the red-ebony tree, but to know how your favorite language containers are arranged in order to know their limitations and be able to choose the right ones - is necessary.  In fact, reading Knut in order to study this area is not necessary, in fact, you can prepare for this stage by carefully reading about 30 pages on Wikipedia. <br><br><div class="spoiler">  <b class="spoiler_title">List of articles</b> <div class="spoiler_text">  <a href="http://en.wikipedia.org/wiki/Data_structures">en.wikipedia.org/wiki/Data_structures</a> <br><ul><li>  <a href="http://en.wikipedia.org/wiki/Dynamic_array">en.wikipedia.org/wiki/Dynamic_array</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Hash_table">en.wikipedia.org/wiki/Hash_table</a> </li><li>  <a href="http://en.wikipedia.org/wiki/B-tree">en.wikipedia.org/wiki/B-tree</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Rb-tree">en.wikipedia.org/wiki/Rb-tree</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">en.wikipedia.org/wiki/Self-balancing_binary_search_tree</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Heap_(data_structure)">en.wikipedia.org/wiki/Heap_(data_structure)</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Trie">en.wikipedia.org/wiki/Trie</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Skip_list">en.wikipedia.org/wiki/Skip_list</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Graph_(abstract_data_type)">en.wikipedia.org/wiki/Graph_(abstract_data_type)</a> </li></ul><br>  <a href="http://en.wikipedia.org/wiki/Sorting_algorithm">en.wikipedia.org/wiki/Sorting_algorithm</a> <br><ul><li>  <a href="http://en.wikipedia.org/wiki/Heapsort">en.wikipedia.org/wiki/Heapsort</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Quicksort">en.wikipedia.org/wiki/Quicksort</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Radix_sort">en.wikipedia.org/wiki/Radix_sort</a> </li></ul><br></div></div><br>  In addition to reading articles from the list, it is necessary to go through all the relevant links in them, just to study them thoughtfully, and if necessary go even deeper. <br><br><h4>  Write the code </h4><br>  But the main thing for a developer is, of course, the ability to write good code.  And to hire a programmer only on the basis of his theoretical knowledge, to put it mildly, is strange.  Here you can recall an excerpt from the book The Human Factor by Tom de Marco and Timothy Lister: <br><blockquote>  <i>Manager: "How long have you been juggling?"</i> <i><br></i>  <i>Candidate: "Well, about six years old."</i> <i><br></i>  <i>Manager: ‚ÄúCan you juggle with three, four, five balls?‚Äù</i> <i><br></i>  <i>Candidate: "Yes, yes and yes."</i> <i><br></i>  <i>Manager: "Do you work with burning objects?"</i> <i><br></i>  <i>Candidate: ‚ÄúOf course.‚Äù</i> <i><br></i>  <i>Manager: "... knives, axes, open boxes with cigars, soft wide-brimmed hats?"</i> <i><br></i>  <i>Candidate: "I do not care how to juggle."</i> <i><br></i>  <i>Manager: ‚ÄúDo you know any funny patter?‚Äù</i> <i><br></i>  <i>Candidate: "Onabespodobna".</i> <i><br></i>  <i>Manager: ‚ÄúWell, I like it.</i>  <i>I think we will take you. ‚Äù</i> <i><br></i>  <i>Candidate: ‚ÄúAhhh ... You don't want to see how I juggle?‚Äù</i> <i><br></i>  <i>Manager: "Hmm, somehow it did not occur to me."</i> </blockquote><br>  Therefore, at the last stage, the candidate is invited to perform a practical task. <br><br>  Now we will give you an analysis of a task similar to the fact that they can get you on an interview.  We came up with it specifically to demonstrate the average level of complexity. <br><br>  By the condition of the problem, you have a formula with numbers, operations + - * / and brackets.  You need to write a program that calculates it.  The formula can be big.  It would be desirable, that the program could be finished easily, entering functions, parameters, etc. <br><br>  Before leaving the candidate alone with the task, we usually ask how he is going to solve it.  Not enough after 2 hours to find out that a person has no idea which side to proceed with the task.  At the time of discussion, you can send a little and prompt the algorithm. <br><br>  To check the level of complexity of the task, we gave it to two of our employees: a programmer and a manager, who was previously a programmer but has not been practicing for several years.  We asked both of them not to refresh the theory and write from memory.  The first coped with the task in two hours, and the second took four hours to solve.  The task turned out to be somewhat more complicated than the standard ones, the solution of which usually goes from half an hour to two.  For example, analyze the solution as clearly as possible.  An experienced developer is aware of all this without thinking. <br><br>  So, we parsim formula.  As a result, we want to get a syntactic tree, where there will be operations in the nodes, and constants in the leaves.  If there were no brackets, the tree would be very simple.  We have two priorities of operations, respectively, the tree turns out to be two-level: on the top is + and -, on the bottom * and /. <br><br>  But since brackets are present, the tree can have unlimited nesting.  The naive solution to the problem is as follows: we find the brackets and completely bite them out of the resulting string and replace, for example, with the names of the variables a1, a2, a3, a4 ... After parsing we get a two-level tree.  Then, in each node of the tree where the variable remains, we analyze what was in the brackets and insert the results instead of the corresponding pieces of the subtree. <br><br>  However, we have an algorithm with quadratic time complexity at worst, since  if we have, for example, 100 million nested brackets, then at each step we will have to look for a closing bracket, and then parse this line again, passing it entirely without left and right characters.  By and large, it is already possible to count it for the right decision, such a program will work. <br><br>  But the majority of programmers will mark this approach as too head-on and inefficient, going straight to the search for a linear algorithm.  For this, obviously, starting recursion with parentheses does not need to immediately look for the closing one.  Both of our test candidates went this way.  As a result, both got something similar to the <a href="http://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a> (a subspecies of the <a href="http://en.wikipedia.org/wiki/LL_parser">LL parser</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">Manager Code</b> <div class="spoiler_text"><pre><code>#include &lt;string&gt;
#include &lt;cassert&gt;
#include &lt;memory&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

struct Token {
        enum Type { value, operation, opening_bracket, closing_bracket};
        Type type;
        string text;
};

struct Tokenizer {
        //I am too lazy to write real tokenizer, it is very simple. I hope formula generator for fake tokenizer will be ok. 
public:
        Tokenizer() { content=generate(); pos=content.begin(); } ;
        const Token* peek() { return pos!=content.end() ?&amp;*pos:0; } ;
        const Token* get() { if (pos!=content.end()) { cout &lt;&lt; pos-&gt;text &lt;&lt; " "; } return pos!=content.end()?&amp;*pos++:0; } ;
private:
    vector&lt;Token&gt; generate(int level=0);
    
private:
        vector&lt;Token&gt;::iterator pos;
        vector&lt;Token&gt; content;
};

//To be honest using classes for expression parsing is a bit overkill, old style could save some code. 
class Expression;
typedef struct auto_ptr&lt;Expression&gt; ExpressionPtr;

//Represents abstract expression
class Expression {
public:
        Expression() {}
        virtual ~Expression() {}
        //actually this static parse functions should be constructor in most classes. I.e. this is violation of principle 'Resource Acquisition Is Initialization'.
        //but some functions return different classes depending on context, i.e. this is some kind of 'virtual constructor' (see Operation::parse for example)
        //so I made decision to make static construction function in all classes, just for uniformity
        static ExpressionPtr parse(Tokenizer&amp; tokens);
        virtual float calc()=0;
        virtual void debug(string prefix)=0;
};


//Represents single value: for example 3.1415
class Value: public Expression {
public:
        Value() {}
        virtual ~Value() {}
        static bool isItYou(Tokenizer&amp; tokens);
        static ExpressionPtr parse(Tokenizer&amp; tokens);
        virtual float calc() { return _value; }
        virtual void debug(string prefix) { cout &lt;&lt; prefix &lt;&lt; "Value(" &lt;&lt;  calc() &lt;&lt;"): " &lt;&lt; _value &lt;&lt; endl; } 
protected:
        float _value;
};

//Represents operation: + or -
class Operation: public Expression {
public:
        Operation() {};
        virtual ~Operation() {}
        static ExpressionPtr parse(Tokenizer&amp; tokens, ExpressionPtr&amp; l);
        virtual float calc();
        virtual void debug(string prefix) { cout &lt;&lt; prefix &lt;&lt; "Operation(" &lt;&lt;  calc() &lt;&lt;"): " &lt;&lt; _operation &lt;&lt; endl; if ( _left.get() ) _left-&gt;debug(prefix + "\t"); if ( _right.get() ) _right-&gt;debug(prefix + "\t"); } 
protected:
        std::auto_ptr&lt;Expression&gt; _left;
        std::auto_ptr&lt;Expression&gt; _right;
        string _operation;
};

//Represents operation: * or /
class PriorityOperation: public Operation {
public:
        PriorityOperation() {};
        virtual ~PriorityOperation() {}
        static ExpressionPtr parse(Tokenizer&amp; tokens, ExpressionPtr&amp; left);
        //virtual float calc(); inherit it
        virtual void debug(string prefix) { cout &lt;&lt; prefix &lt;&lt; "PriorityOperation(" &lt;&lt;  calc() &lt;&lt;"): " &lt;&lt; _operation &lt;&lt; endl; if ( _left.get() ) _left-&gt;debug(prefix + "\t"); if ( _right.get() ) _right-&gt;debug(prefix + "\t"); } 
};


//Represents bracketed expression: (expr)
class BracketExpression: public Expression {
public:
        static bool isItYou(Tokenizer&amp; tokens);
        static ExpressionPtr parse(Tokenizer&amp; tokens);
        virtual float calc() { return _internal-&gt;calc(); } ;
        virtual void debug(string prefix) { cout &lt;&lt; prefix &lt;&lt; "Brackets(" &lt;&lt;  calc() &lt;&lt;"): "  &lt;&lt; endl; _internal-&gt;debug(prefix + "\t"); } 
protected:
        std::auto_ptr&lt;Expression&gt; _internal; 
};


ExpressionPtr Expression::parse(Tokenizer&amp; tokens)
{
    //cout &lt;&lt; "Expression::parse" &lt;&lt; endl;
    
        if (!tokens.peek()) return ExpressionPtr();

        if ( BracketExpression::isItYou(tokens) )
        {
                return BracketExpression::parse(tokens);
        }
        else
        if ( Value::isItYou(tokens) )
        {        
                return Value::parse(tokens);
        }
        else
        {
                throw logic_error("(Expression) Wtf is that: " + tokens.peek()-&gt;text );
        }
}

bool Value::isItYou(Tokenizer&amp; tokens) 
{
        const Token* t = tokens.peek();
        if ( !t || t-&gt;type != Token::value ) return false; 

        char* endptr;
        strtod( t-&gt;text.c_str(), &amp;endptr);
        return *endptr == 0;
}

ExpressionPtr Value::parse(Tokenizer&amp; tokens)
{
    //cout &lt;&lt; "Value::parse" &lt;&lt; endl;
    
        std::auto_ptr&lt;Value&gt; foo( new Value );

        const Token* t=tokens.get();
        assert( t &amp;&amp; t-&gt;type == Token::value ); 

        char* endptr;
        foo-&gt;_value = strtod( t-&gt;text.c_str(), &amp;endptr);
        return ExpressionPtr(foo.release()); //lack of heterosexual auto_ptr conversions is killing me
}

bool BracketExpression::isItYou(Tokenizer&amp; tokens) 
{
        return tokens.peek() &amp;&amp; tokens.peek()-&gt;type == Token::opening_bracket;
}


ExpressionPtr BracketExpression::parse(Tokenizer&amp; tokens)
{
    //cout &lt;&lt; "BracketExpression::parse" &lt;&lt; endl;
        const Token* t=tokens.get();
        assert ( t-&gt;type == Token::opening_bracket );

        auto_ptr&lt;BracketExpression&gt; result ( new BracketExpression );
        ExpressionPtr null;
        result-&gt;_internal = Operation::parse(tokens, null);

        t = tokens.get();
        if ( t ==0 || t-&gt;type != Token::closing_bracket )
        {
                throw logic_error("(BracketExpression) mismatched brackets ");
        }

        return ExpressionPtr(result.release());
}


ExpressionPtr Operation::parse(Tokenizer&amp; tokens, ExpressionPtr&amp; l)
{
    //cout &lt;&lt; "Operation::parse:" &lt;&lt; l.get() &lt;&lt; endl;
        ExpressionPtr left;

        if (l.get()) 
        {
                left=l;
                // left is assigned for us.
        }
        else
        {
                left=Expression::parse(tokens);
        }        

        const Token *t=tokens.peek();
        if (!t || t-&gt;type == Token::closing_bracket  ) return left; //just return Value, sorry no operation guys

        if (t-&gt;type == Token::operation &amp;&amp; (t-&gt;text=="*" || t-&gt;text=="/") )
        {
                ExpressionPtr result = PriorityOperation::parse(tokens, left);                 
                //we got exit after priority operations will end, parse position will be on + or - or at end
                left = result;        

                t=tokens.peek();
                if (!t || t-&gt;type == Token::closing_bracket  ) return left; //just return Value, sorry no operation guys
        }

    //cout &lt;&lt; "Operation::parse again" &lt;&lt; endl;
        if (t-&gt;type == Token::operation &amp;&amp; (t-&gt;text=="+" || t-&gt;text=="-") )
        {
                tokens.get(); //just commit previous peek

                auto_ptr&lt;Operation&gt; result ( new Operation );
                result-&gt;_operation = t-&gt;text;
                result-&gt;_left=left; //smart ptr giveup ownership
        
        //cout &lt;&lt; "Operation::parse before token" &lt;&lt; endl;
        ExpressionPtr foo=Expression::parse(tokens);
        //cout &lt;&lt; "Operation::parse after expression" &lt;&lt; endl;
        
        const Token *t=tokens.peek();
        
        if (t != 0 &amp;&amp; (t-&gt;text=="*" || t-&gt;text=="/"))
        {
            //cout &lt;&lt; "Operation::parse to priority" &lt;&lt; endl;
            foo = PriorityOperation::parse(tokens,foo);
        }
        
        result-&gt;_right=foo;
        
        ExpressionPtr bar(result.release());
        return Operation::parse(tokens, bar);
                
        }
        else
        {
                throw logic_error("(Operation) Wtf is that: " + tokens.peek()-&gt;text);
        }
}

ExpressionPtr PriorityOperation::parse(Tokenizer&amp; tokens, ExpressionPtr&amp; left)
{
    //cout &lt;&lt; "PriorityOperation::parse" &lt;&lt; endl;
    
    // left is already assigned for priority operation
        const Token *t=tokens.peek();
        if (!t || t-&gt;type == Token::closing_bracket  ) return left; //just return Value, sorry no operation guys

        if (t-&gt;type == Token::operation &amp;&amp; (t-&gt;text=="*" || t-&gt;text=="/") )
        {
                tokens.get(); //commit previuos peek

                auto_ptr&lt;PriorityOperation&gt; result ( new PriorityOperation ); 
                result-&gt;_operation = t-&gt;text;
                result-&gt;_left=left;
                result-&gt;_right=Expression::parse(tokens);
                ExpressionPtr rs(result.release());

                return PriorityOperation::parse(tokens, rs);

        }
        else if (t-&gt;type == Token::operation &amp;&amp; (t-&gt;text=="+" || t-&gt;text=="-") )
        {
                return left;
        }
        else
        {
                throw logic_error("(PriorityOperation) Wtf is that: " + tokens.peek()-&gt;text );
        }
}


float Operation::calc()
{
        if (_operation == "+")
        {
                float l=_left.get()?_left-&gt;calc():0.0f;
                float r=_right.get()?_right-&gt;calc():0.0f;
                return l+r;
        }
        else
        if (_operation == "-")
        {
                float l=_left.get()?_left-&gt;calc():0.0f;
                float r=_right.get()?_right-&gt;calc():0.0f;
                return l-r;
        }        
        else
        if (_operation == "*")
        {
                float l=_left.get()?_left-&gt;calc():1.0f;
                float r=_right.get()?_right-&gt;calc():1.0f;
                return  l*r; 
        }        
        else
        if (_operation == "/")
        {
                float l = _left.get()?_left-&gt;calc():1.0f;
                float r = _right.get()?_right-&gt;calc():1.0f;
                return l/r;
        }
        else
        {
                throw logic_error("Wft: operation udefined");
        }                
}

//returning vector by value, will be slow( O(n*n) actually ), but it is just testing code.
vector&lt;Token&gt; Tokenizer::generate(int level)
{
    //be careful with this value - formula size is approx 2^level
    if (level &gt; 6)
    {
        Token t;
        char f[100];
        snprintf(f,100,"%d",int(rand() % 100));
        t.text=f;
        t.type=Token::value;
        return vector&lt;Token&gt;(&amp;t,&amp;t+1);
    }

    if (rand() % 10 == 0)
    {
            vector&lt;Token&gt; result;
            Token t1,t2;
            t1.type=Token::opening_bracket;
            t1.text="(";
            t2.type=Token::closing_bracket;
            t2.text=")";
            result.push_back(t1);
            vector&lt;Token&gt; r=generate(level+1);
            result.insert(result.end(),r.begin(),r.end());
            result.push_back(t2);

            return result;
    }        

    char op = "+-*/"[rand()%4];
    Token t;
    t.type=Token::operation;
    t.text=op;

    vector&lt;Token&gt; result=generate(level+1);
    result.push_back(t);
    vector&lt;Token&gt; r2=generate(level+1);
    result.insert(result.end(),r2.begin(),r2.end());

    return result;
}

int main()
{        
        try
        {
                //create fake tokenizer
                Tokenizer tk;

                //parse it
                ExpressionPtr null;
                ExpressionPtr foo = Operation::parse(tk,null);
                cout &lt;&lt; endl;
                foo-&gt;debug("");
                float result = foo-&gt;calc();        
                cout &lt;&lt; "result = " &lt;&lt; result &lt;&lt; endl;
        }
        catch(exception&amp; e)
        {
                cout &lt;&lt; e.what() &lt;&lt; endl;
                return 1;                  
        }

        return 0;
}</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"> </b><div class="spoiler_text"><pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;stdexcept&gt;

struct token {
    enum { E_UNDEF, E_NUMBER, E_OPERATOR, E_LEVEL  } type;

    union {
        double d_val;
        int i_val;
        char c_val;
    } data;

    token() {
        type = E_UNDEF;
    }

    token(double val) : type(E_NUMBER) {
        data.d_val = val;
    }
    token(int val) : type(E_LEVEL) {
        data.i_val = val;
    }
    token(char val) : type(E_OPERATOR) {
        data.c_val = val;
    }
};

typedef std::vector&lt;token&gt; tokens;

void push_level(tokens &amp;pr, int level) {
    if (pr.empty() || pr.back().type != token::E_LEVEL) {
        pr.push_back(token(level));
    } else {
        pr.back().data.i_val += level;
    }
}

void push_operator(tokens &amp;pr, char op) {
    pr.push_back(token(op));
}

void push_number(tokens &amp;pr, int num) {
    if (pr.empty() || pr.back().type == token::E_LEVEL || (pr.back().type == token::E_OPERATOR &amp;&amp; pr.size() &gt; 1 &amp;&amp; pr[pr.size() - 2].type == token::E_NUMBER) ) {
        pr.push_back(token((double)num));
    } else if (pr.back().type == token::E_OPERATOR &amp;&amp; (pr.size() == 1 || pr[pr.size() - 2].type == token::E_LEVEL) ) {
        if (pr.back().data.c_val == '*' || pr.back().data.c_val == '/') {
            throw std::domain_error("unexpected operator");
        }
        if (pr.back().data.c_val == '-') {
            num = -num;
        }
        pr.pop_back();
        pr.push_back(token((double)num));
    } else {
        throw std::domain_error("unexpected number");
    }
}

token calc3(tokens &amp;pr) {
    token s2 = pr.back(); pr.pop_back();
    token op = pr.back(); pr.pop_back();
    token s1 = pr.back(); pr.pop_back();

    if (s1.type != token::E_NUMBER || op.type != token::E_OPERATOR || s2.type != token::E_NUMBER) {
        throw std::domain_error("unexpected closing brace");
    }

    switch (op.data.c_val) {
        case '+':
            s1.data.d_val += s2.data.d_val;
            break;
        case '-':
            s1.data.d_val -= s2.data.d_val;
            break;
        case '*':
            s1.data.d_val *= s2.data.d_val;
            break;
        case '/':
            s1.data.d_val /= s2.data.d_val;
            break;
        default:
        throw std::domain_error("internal error");
    }

    return s1;
}

void pop_level(tokens &amp;pr, int level) {
    if (level == 0) {
        if (pr.size() &gt; 3) {
            pr.push_back(calc3(pr));
        }
        return;
    }
    if (pr.empty() || pr.back().type == token::E_LEVEL || pr.back().type == token::E_OPERATOR) {
        throw std::domain_error("unexpected closing brace");
    } else if (pr.size() &gt; 1 &amp;&amp; pr[pr.size() - 2].type == token::E_LEVEL) {
        if (pr[pr.size() - 2].data.i_val &gt; level) {
            pr[pr.size() - 2].data.i_val -= level;
        } else {
            int delta = level - pr[pr.size() - 2].data.i_val;
            token tmp = pr.back();
            pr.pop_back(); pr.pop_back();
            pr.push_back(tmp);
            pop_level(pr, delta);
        }
    } else if (pr.size() &gt; 3) {
        token s1 = calc3(pr);

        if (pr.back().type == token::E_LEVEL) {
            if (pr.back().data.i_val &gt; level) {
                pr.back().data.i_val -= level;
                pr.push_back(s1);
            } else {
                int delta = level - pr.back().data.i_val;
                pr.pop_back();
                pr.push_back(s1);
                pop_level(pr, delta);
            }
        } else if (pr.back().type == token::E_OPERATOR) {
            pr.push_back(s1);
            pop_level(pr, level);
        } else {
            throw std::domain_error("unexpected closing brace");
        }
    } else {
        throw std::domain_error("unexpected closing brace");
    }
}

double process(const std::string &amp;str) {
    tokens program;

    push_level(program, 3);
    for (std::string::const_iterator cit = str.begin(); cit != str.end(); ++cit) {
        switch (*cit) {
            case '(':
                push_level(program, 3);
                break;
            case ')':
                pop_level(program, 3);
                break;
            case '*':
            case '/':
                pop_level(program, 1);
                push_operator(program, *cit);
                push_level(program, 1);
                break;
            case '+':
            case '-':
                if (cit == str.begin() || strchr("(+/-*", *(cit-1))) {
                    push_operator(program, *cit);
                } else {
                    pop_level(program, 2);
                    push_operator(program, *cit);
                    push_level(program, 2);
                }
                break;
            case ' ':
                break;
            case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9':
                {
                    int curnum = 0;
                    while (cit != str.end()) {
                        curnum = 10*curnum + (*cit - '0');
                        if ((cit + 1) == str.end() || !isdigit(*(cit+1))) {
                            break;
                        }
                        ++cit;
                    }
                    push_number(program, curnum);
                }
                break;
            default:
                throw std::domain_error("unexpected symbol");
        }
    }
    pop_level(program, 3);

    if (program.size() == 0 || program.size() &gt; 1) {
        throw std::domain_error("incomplete expression");
    }

    return program.back().data.d_val;
}

int main() {
    std::string line;
    while (!std::cin.eof()) {
        std::getline(std::cin, line);

        if (line.length() &gt; 0) {
            try {
                std::cout &lt;&lt; process(line) &lt;&lt; std::endl;
            } catch (std::exception &amp;e) {
                std::cout &lt;&lt; "error: " &lt;&lt; e.what() &lt;&lt; std::endl;
            }
        }
    }

    return 0;
}
</code></pre></div></div><br>
     -     ,    .  -     .<br>
<br>
    ,    <a href="http://en.wikipedia.org/wiki/Shunting_yard_algorithm">shunting yard algorithm</a>.   Recursive descent parser   <a href="http://en.wikipedia.org/wiki/LR_parser">LR-</a>.<br>
<br>
<h4> </h4><br>
      senior-,    ,        .<br>
<br>
      .     ,  ,     ,            ,       ,     ,   ,        .<br>
<br>
   ‚Äì  ,     .  ,       .       ,         ,  ,            . <br>
<br>
  ,         .        .   ,    ,     .       ,    ‚Äì   .<br>
<br>
  ,   ,     .   ,     ,    .           ,     . <br>
<br>
 ,   -    ,       .  ,        .         . ,    ,     ,       ‚Äì   ,    .<br>
<br>
<div class="spoiler"><b class="spoiler_title">     ++</b><div class="spoiler_text"><ul>
<li>, ¬´ +   = ¬ª</li>
<li>, ,   ¬´:   ¬ª</li>
<li> ¬´   ++¬ª</li>
<li>Scott Meyers. Effective C++. More Effective C++. Effective STL</li>
<li>Herb Sutter ¬´Exceptional C++¬ª ¬´More Exceptional C++¬ª</li>
</ul></div></div><br>
<br>
<i>(,      <a href="http://company.yandex.ru/job/vacancies/"></a>.)</i></div><p>Source: <a href="https://habr.com/ru/post/206234/">https://habr.com/ru/post/206234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206218/index.html">We build in polls for users of Android applications</a></li>
<li><a href="../206220/index.html">Designing a notification system for web applications</a></li>
<li><a href="../206222/index.html">DirectWrite support added to Chrome Canary</a></li>
<li><a href="../206224/index.html">Live migration in OpenStack</a></li>
<li><a href="../206230/index.html">Filtering SharePoint lists, address bar settings</a></li>
<li><a href="../206236/index.html">Per capita e-rubbish - an interactive map shows the reality of each country</a></li>
<li><a href="../206238/index.html">Distributing servers: December contest</a></li>
<li><a href="../206242/index.html">Developers from Google have made the Amiga 500 emulator for Chrome</a></li>
<li><a href="../206244/index.html">ASLR in the latest releases of Windows</a></li>
<li><a href="../206248/index.html">Bitcoin try to integrate with torrents</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>