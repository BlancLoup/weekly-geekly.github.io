<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: Generate and reproduce sound. Part three: generate a sine wave. A simple look at DMA + first acquaintance with timers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction  In the previous article, I talked about my first encounter with DMA. In it, we did a bunch of DMA + SysTick. The article turned out to b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: Generate and reproduce sound. Part three: generate a sine wave. A simple look at DMA + first acquaintance with timers</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4>  <a href="http://habrahabr.ru/post/256091/">In the previous article,</a> I talked about my first encounter with DMA.  In it, we did a bunch of DMA + SysTick.  The article turned out to be very specific and complex, in view of the inexperienced crooked approach.  Having gained experience, in this article I will talk about a much simpler and more understandable way of working with DMA. <a name="habracut"></a><h4>  Main aspects </h4>  From the previous article, we learned that in order to run DMA, you need: <ul><li>  Send a clock signal to the DMA module. </li><li>  Fill out the DMA operation control structure. </li><li>  Set up DMA. </li><li>  To configure the channel. </li><li>  Enable transfer. </li><li>  At the end of the transfer "restore" (overwrite) the structure. </li></ul>  In order to ‚Äúgive out‚Äù the data at a strictly defined time - we used the SysTick system timer.  Because of this, we had to constantly go to the interrupt from the timer and re-run every DMA transfer there.  In addition, each time you restart the transmission, we also checked whether the entire packet of our data was transmitted or not.  Agree, a similar approach completely kills all the advantages of DMA.  It can even be said to complicate life.  As it turned out, there is a great bunch of DMA + Timer in our microcontroller.  Thus, we can once set the timer so that without entering the interrupt, he himself would tell the DMA that it was time to send the next value to the DAC.  Just remember that earlier we used the transfer mode "main".  He forced us to constantly stop and restore structure.  Our DMA has a ping-pong mode.  Its essence is as follows: using the primary structure (the one that we used in the previous article), we transfer the first part of the data (array).  At this time, we can set up an alternative (read, second) structure so that when the first one finishes, we immediately begin to transmit what is written to the second one without stopping.  During the transfer of the second structure - we can restore or change the first, which gives us the opportunity to make arbitrarily long transmission. <h4>  Setting up the structure of the DMA, the DMA itself and the channel-bundle with a timer </h4>  As we remember, each channel has its own control structure (in our case, there are as many as two).  We configure them as described in the previous article.  The resulting settings will be saved in two variables.  From these variables we will later restore our structures. <div class="spoiler">  <b class="spoiler_title">Setting up structures.</b> <div class="spoiler_text"><pre><code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------- // . //------------------------------------------------- #define dst_src (3&lt;&lt;30) // - 16  (). #define src_inc (1&lt;&lt;26) //   16    . #define src_size (1&lt;&lt;24) //  16 . #define dst_size (1&lt;&lt;28) //  16 .       . #define n_minus_1 (49&lt;&lt;4) //50  (-1) DMA. #define cycle_ctrl (3&lt;&lt;0) //-. struct DAC_ST { uint32_t Destination_end_pointer; //   . uint32_t Source_end_pointer; //    uint32_t channel_cfg; // . uint32_t NULL; // . } __align(1024) DAC_ST; //    1024 . struct DAC_ST DAC_ST_ADC[32+32]; //     . /// = 16 , / = 16 ,  , 50 , -. uint32_t DMA_DAC_InitST_PR = dst_src|src_inc|src_size|dst_size|n_minus_1|cycle_ctrl; uint32_t DMA_DAC_InitST_ALT = dst_src|src_inc|src_size|dst_size|n_minus_1|cycle_ctrl;</span></span></code> </pre> </div></div>  As you can see, I allocated memory for 32 primary and 32 alternative structures, which in total will give a kilobyte of memory in RAM.  I went to this step, so as not to suffer with offsets.  In the future, it will be easy to make an offset and leave 2 structures.  Next you need to fill these structures. <div class="spoiler">  <b class="spoiler_title">Filling structures</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  . DAC_ST_ADC[10-1].Destination_end_pointer = (uint32_t)C_4 + (sizeof(C_4))/2 - 1; //      (C_4 -      100 ). DAC_ST_ADC[10-1].Source_end_pointer = (uint32_t)&amp;(DAC-&gt;DAC2_DATA); //   ( )   (  DAC). DAC_ST_ADC[10-1].channel_cfg = (uint32_t)(DMA_DAC_InitST_PR); //   . DAC_ST_ADC[10-1].NULL = (uint32_t)0; // . //  . DAC_ST_ADC[10-1+32].Destination_end_pointer = (uint32_t)C_4 + sizeof(C_4) - 1; //     (C_4 -      100 ). DAC_ST_ADC[10-1+32].Source_end_pointer = (uint32_t)&amp;(DAC-&gt;DAC2_DATA); //   ( )   (  DAC). DAC_ST_ADC[10-1+32].channel_cfg = (uint32_t)(DMA_DAC_InitST_ALT); //   . DAC_ST_ADC[10-1+32].NULL = (uint32_t)0; // .</span></span></code> </pre> </div></div>  As you can see, the difference between these two structures is only in the final addresses of the data source.  In the primary we specify the center of the array (the transfer will be from the beginning to the middle), and the secondary end (the transfer from the middle to the end). <div class="spoiler">  <b class="spoiler_title">Now configure the DMA.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CFG_master_enable (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;0)//   . #define PCLK_EN_DMA (1&lt;&lt;5)//   DMA. //  DMA. RST_CLK-&gt;PER_CLOCK|=PCLK_EN_DMA; //  DMA. DMA-&gt;CTRL_BASE_PTR = (uint32_t)&amp;DAC_ST_ADC; //   . DMA-&gt;CFG = CFG_master_enable; //  DMA.</span></span></span></span></code> </pre> </div></div>  Well, it remains only to configure the channel.  But which one?  We can refer to the table in the previous article.  But.  After writing the previous article I was informed about my mistake.  The fact is that the table is not quite correct. <div class="spoiler">  <b class="spoiler_title">A more accurate table looks like this.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** @defgroup DMA_valid_channels DMA valid channels * @{ */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_UART1_TX ((uint8_t)(0)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_UART1_RX ((uint8_t)(1)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_UART2_TX ((uint8_t)(2)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_UART2_RX ((uint8_t)(3)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SSP1_TX ((uint8_t)(4)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SSP1_RX ((uint8_t)(5)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SSP2_TX ((uint8_t)(6)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SSP2_RX ((uint8_t)(7)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_ADC1 ((uint8_t)(8)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_ADC2 ((uint8_t)(9)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_TIM1 ((uint8_t)(10)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_TIM2 ((uint8_t)(11)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_TIM3 ((uint8_t)(12)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW1 ((uint8_t)(13)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW2 ((uint8_t)(14)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW3 ((uint8_t)(15)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW4 ((uint8_t)(16)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW5 ((uint8_t)(17)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW6 ((uint8_t)(18)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW7 ((uint8_t)(19)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW8 ((uint8_t)(20)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW9 ((uint8_t)(21)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW10 ((uint8_t)(22)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW11 ((uint8_t)(23)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW12 ((uint8_t)(24)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW13 ((uint8_t)(25)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW14 ((uint8_t)(26)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW15 ((uint8_t)(27)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW16 ((uint8_t)(28)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW17 ((uint8_t)(29)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW18 ((uint8_t)(30)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_Channel_SW19 ((uint8_t)(31)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IS_DMA_CHANNEL(CHANNEL) (CHANNEL &lt;= (DMA_Channels_Number - 1)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** @} */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* End of group DMA_valid_channels */</span></span></span></span></code> </pre> </div></div>  The table was given to me at the official forum, but it is also in the official library.  We will use timer 1. =&gt; our channel is the tenth. <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// . DMA-&gt;CHNL_ENABLE_SET = 1&lt;&lt;10; //  10 .</span></span></code> </pre> <div class="spoiler">  <b class="spoiler_title">We got the following function.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------- // DMA    DAC. //------------------------------------------------- void DMA_to_DAC_and_TIM1 (void) { //  . DAC_ST_ADC[10-1].Destination_end_pointer = (uint32_t)C_4 + (sizeof(C_4))/2 - 1; //      (C_4 -      100 ). DAC_ST_ADC[10-1].Source_end_pointer = (uint32_t)&amp;(DAC-&gt;DAC2_DATA); //   ( )   (  DAC). DAC_ST_ADC[10-1].channel_cfg = (uint32_t)(DMA_DAC_InitST_PR); //   . DAC_ST_ADC[10-1].NULL = (uint32_t)0; // . //  . DAC_ST_ADC[10-1+32].Destination_end_pointer = (uint32_t)C_4 + sizeof(C_4) - 1; //     (C_4 -      100 ). DAC_ST_ADC[10-1+32].Source_end_pointer = (uint32_t)&amp;(DAC-&gt;DAC2_DATA); //   ( )   (  DAC). DAC_ST_ADC[10-1+32].channel_cfg = (uint32_t)(DMA_DAC_InitST_ALT); //   . DAC_ST_ADC[10-1+32].NULL = (uint32_t)0; // . //  DMA. RST_CLK-&gt;PER_CLOCK|=PCLK_EN_DMA; //  DMA. DMA-&gt;CTRL_BASE_PTR = (uint32_t)&amp;DAC_ST_ADC; //   . DMA-&gt;CFG = CFG_master_enable; //  DMA. // . DMA-&gt;CHNL_ENABLE_SET = 1&lt;&lt;10; //  10 . }</span></span></code> </pre> </div></div><h4>  Introducing the timer </h4><div class="spoiler">  <b class="spoiler_title">First of all, the timer must be turned on (zakattirovat).</b> <div class="spoiler_text"><img src="//habrastorage.org/files/eee/ac2/3e0/eeeac23e0507478dbbf277ddfbb6ffb4.PNG"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PER_CLOCK_TIMER1_ONCLK (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;14) //    1. RST_CLK-&gt;PER_CLOCK |= PER_CLOCK_TIMER1_ONCLK; // .</span></span></span></span></code> </pre></div></div>  And now actually, it is worth starting to understand.  All three timers have the same features.  At least at first glance.  Each timer has a very rich functionality =&gt; many registers.  But they are very easy to understand.  I did not encounter any rake in the way of studying the work of timers.  We remember that we set up DMA so that the timer can control it.  For this purpose, it will be enough for us to just wait a certain amount of time and transmit the next portion of data.  The timer has 4 channels of "comparison" and the main counter.  It will be enough for us to use the main counter. <div class="spoiler">  <b class="spoiler_title">Take a look at the main timer register.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/bbe/206/cc7/bbe206cc76b64d5e8fb173a1534fb806.PNG"></div></div><div class="spoiler">  <b class="spoiler_title">Here we should allow the timer to work.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/625/c71/8ad/625c718adb2b432cab74527a19cba821.PNG"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNTRL_CNT_EN (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;0) //  . TIMER1-&gt;CNTRL |= CNTRL_CNT_EN; //  ,  =  .</span></span></span></span></code> </pre> </div></div>  As a test, we will consider up to 0xFFFF (later we will deal with time intervals).  By default, the account goes from 0. <pre> <code class="cpp hljs">TIMER1-&gt;ARR = <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre>  Next you need to associate our timer with DMA.  As the event for which the transmission will occur, we select CNT == ARR in timer 1. This is a simple comparison of the current value of the CNT timer with the number in the ARR register. <div class="spoiler">  <b class="spoiler_title">For this there is a register DMA_RE</b> <div class="spoiler_text"><img src="//habrastorage.org/files/c41/8ed/3e7/c418ed3e778b451d8cad6176f3200a3f.PNG">  Here we need to choose a link to achieve the desired value by the counter. <img src="//habrastorage.org/files/4ee/76b/2b3/4ee76b2b3f9d45ad92c0cfef54289f6c.PNG"></div></div>  One could say that the setup is complete, BUT.  Now our timer is clocked on the HCLK frequency, which without a divider = 8 MHz.  Our value of 0xFFFF will be reached instantly.  And we will not be able to trace our transmission.  To solve this problem, we must include a pre-divider. <div class="spoiler">  <b class="spoiler_title">For these purposes, the register RST_CLK-&gt; TIM_CLOCK in the clocking block is used.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/c60/cc4/68a/c60cc468ad724f6f9d5490c8a68fe88a.PNG"><img src="//habrastorage.org/files/f19/07c/161/f1907c161e8d49b2a9d33feef7b747e6.PNG">  For the sample, I turned on the biggest divider.  Also here it is necessary and to give a signal of clocking on the timer.  So that the timer starts counting from the HCLK through the pre divider. <img src="//habrastorage.org/files/28e/cec/6cd/28ecec6cd32a465291b69b083987dd5a.PNG"></div></div><div class="spoiler">  <b class="spoiler_title">As a result, we get such a function.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PER_CLOCK_TIMER1_ONCLK (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;14) //    1. #define TIM_CLOCK_TIM1_CLK_EN (1&lt;&lt;24) //     1. #define SHARE_HCLK_TIMER 7 //   HCLK ... (0 =  , 1 = /2, 2 = /4). #define TIM_CLOCK_TIM1_BRG (SHARE_HCLK_TIMER&lt;&lt;0) //    1  SHARE_HCLK_TIMER. #define CNTRL_CNT_EN (1&lt;&lt;0) //  . #define DMA_RE_CNT_ARR_EVENT_RE (1&lt;&lt;1) //   DMA   CNT == ARR; void Init_TIMER1_to_DMA_and_DAC2 (void) { RST_CLK-&gt;PER_CLOCK |= PER_CLOCK_TIMER1_ONCLK; // . TIMER1-&gt;CNTRL |= CNTRL_CNT_EN; //  ,  =  . TIMER1-&gt;ARR = 0xFFFF; // ... TIMER1-&gt;DMA_RE |= DMA_RE_CNT_ARR_EVENT_RE; // "" DMA. RST_CLK-&gt;TIM_CLOCK |= TIM_CLOCK_TIM1_CLK_EN|TIM_CLOCK_TIM1_BRG; //    . }</span></span></span></span></code> </pre> </div></div>  Now, if we turn on our example, we will observe how the change in the value of the voltage value register in DAC2 occurs with an interval of about a second.  Well, the first stage is over.  The truth is that the process will be interrupted in the middle of our array.  The fact is that the timer can only re-enable the transmission.  But as soon as we transferred half the array, we ‚Äúused up‚Äù the first structure.  Now it is necessary to restore it.  For this we will use the second timer.  Many will be asked, ‚ÄúWhy not interrupt the transfer from DMA or transfer half of the array?‚Äù.  The fact is that in our DMA can only generate an interrupt at the end of the transfer.  There is no possibility to cause an interruption after the passage of the middle.  But here it is not so simple.  Recall that we pass not everything, but in parts.  Our DMA does not understand this.  An interrupt is generated while the DMA is idle.  In other words, DMA does not understand that not the entire data packet is transmitted, but only one element of the array.  This fact makes the use of DMA interrupts unsuitable for our task. <h4>  We configure timers for generation of a sinusoid </h4>  As I said, in order to ‚Äúrestore‚Äù the structure, we must configure the next (second) timer to interrupt after passing half of the half of the array (1/4 of the entire array).  Why exactly one fourth - I will explain further.  But before that, reconfigure the first timer.  We need to decide on the speed of the "kicks" DMA.  We look.  The controller clocks with a frequency of 8 MHz.  Our array contains 100 elements.  The frequency of the notes to the first octave, as we remember, is 261.63 Hz.  The capacity of the account register is 0xFFFF (up to this value, the counter can read).  We divide 8,000,000 Hz / 261.63 Hz / 100 notes = once in 305 cycles to "kick" the DMA.  This is much less than the maximum value of the timer comparison register.  Thus, we do not have to use a pre divider. <div class="spoiler">  <b class="spoiler_title">Serving clocking on both timers.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">RST_CLK-&gt;PER_CLOCK |= PER_CLOCK_TIMER1_ONCLK|PER_CLOCK_TIMER2_ONCLK; <span class="hljs-comment"><span class="hljs-comment">//   1  2.</span></span></code> </pre> </div></div>  After switching on the timer clocking (total block), it sometimes happens that the timer starts its work according to previously configured parameters.  Because of this, even before their settings, there are various glitches.  To prevent this, you need to disable the clocking signal of the counting block (so that the timer does not have time to count up to any value from which it will cause, for example, an interrupt). <div class="spoiler">  <b class="spoiler_title">Disable clocking counting unit.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">RST_CLK-&gt;TIM_CLOCK = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  .</span></span></code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">Next, we specify the period of appeal to the DMA and allow it.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  8000000 /261.63/100 = 305. TIMER1-&gt;ARR = 305; // ... TIMER1-&gt;DMA_RE |= DMA_RE_CNT_ARR_EVENT_RE; //  DMA.</span></span></code> </pre> </div></div>  Now we set up timer 2. For simplicity, we will also clock it without a divider.  We also decide how often to cause an interrupt.  Due to the fact that we clock both timers from the same source, we cannot update the value of the structure at the very moment when the last element of the first structure was transmitted.  Because when the DMA makes an attempt to transfer the element that follows the last of the first structure, it will come across its end and automatically switch to the alternative one.  Thus, it is necessary to wait until the DMA decides that the primary structure is ‚Äúexhausted‚Äù and begins to transmit from the alternative.  To do this, just wait for the transfer of at least one packet from the alternative structure.  Then you can fill the primary again.  The same should be done with the alternative.  When the transmissions end in it, you need to wait until the DMA transfers at least 1 packet from the primary one, after which you can overwrite the alternative one.  We transfer 100 items.  50 in each structure.  We could cause an interruption along with the fiftieth transmission, but for the reasons described above, we need to wait for at least the 51st transmission.  In order not to suffer with offsets, let's make a check of both structure every 25 gears. <div class="spoiler">  <b class="spoiler_title">Thus, the period of our timer will be 305 * 25.</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TIMER2-&gt;ARR = <span class="hljs-number"><span class="hljs-number">305</span></span>*<span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   .</span></span></code> </pre> </div></div><h4>  Something about interruptions </h4>  In order for an interrupt to occur when the timer reaches the desired value, it is necessary. <ul><li><div class="spoiler">  <b class="spoiler_title">Enable event interruption: the counter reaches the desired value in the TIMERx-&gt; IE register</b> <div class="spoiler_text"><img src="//habrastorage.org/files/c63/071/974/c63071974e41456c90d450e8138fe03a.PNG"><img src="//habrastorage.org/files/636/ec6/b9c/636ec6b9cfe345cb8c130b062cc240d7.PNG"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TIMERx_IE_CNT_ARR_EVENT_IE (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;1) //:       CNT  ARR. TIMER2-&gt;IE = TIMERx_IE_CNT_ARR_EVENT_IE; //   .</span></span></span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Clear flag of any interrupts TIMERy-&gt; STATUS</b> <div class="spoiler_text">  The fact is that after the interrupt is enabled, its flag is automatically set.  In order not to go to the interrupt immediately after setting it is necessary to reset it. <pre> <code class="cpp hljs">TIMER2-&gt;STATUS=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  .</span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">Enable timer interrupt on the NVIC interrupt controller.</b> <div class="spoiler_text">  A separate article is worth highlighting on this controller, but in this article we will limit ourselves to the following information base: in order for the controller to ‚Äúnotice‚Äù that the timer requires an interrupt, you need to enable this interrupt itself.  This is done in the register NVIC-&gt; ISER [0]. <img src="//habrastorage.org/files/863/632/d65/863632d659054eb18389444f3bff3b1c.PNG">  We need to find out which number has a timer interrupt.  To do this, go to the startup file and look for the vector with the desired name. <pre> <code class="cpp hljs">DCD Timer2_IRQHandler ; IRQ15</code> </pre> <pre> <code class="cpp hljs">NVIC-&gt;ISER[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    2.</span></span></code> </pre> </div></div></li><li><div class="spoiler">  <b class="spoiler_title">You need to create an interrupt handler function and reset the interrupt flag in it (this is done manually).</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer2_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// . TIMER2-&gt;STATUS=0; }</span></span></span></span></code> </pre> </div></div></li></ul><h4>  We finish setting the timers. </h4><div class="spoiler">  <b class="spoiler_title">After we have specified the parameters of the timers, we must allow them to work and send a clock signal to the counter.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNTRL_CNT_EN (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;0) //  . #define TIM_CLOCK_TIM1_CLK_EN (1&lt;&lt;24) //     1. #define TIM_CLOCK_TIM2_CLK_EN (1&lt;&lt;25) //     2. TIMER1-&gt;CNTRL = CNTRL_CNT_EN; //  . TIMER2-&gt;CNTRL = CNTRL_CNT_EN; RST_CLK-&gt;TIM_CLOCK = TIM_CLOCK_TIM1_CLK_EN|TIM_CLOCK_TIM2_CLK_EN; //    .</span></span></span></span></code> </pre></div></div><div class="spoiler">  <b class="spoiler_title">The result of the configuration was the function.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PER_CLOCK_TIMER1_ONCLK (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;14) //    1. #define PER_CLOCK_TIMER2_ONCLK (1&lt;&lt;15) //    1. #define TIM_CLOCK_TIM1_CLK_EN (1&lt;&lt;24) //     1. #define SHARE_HCLK_TIMER1 7 //   HCLK ... (0 =  , 1 = /2, 2 = /4). #define TIM_CLOCK_TIM1_BRG (SHARE_HCLK_TIMER1&lt;&lt;0) //    1  SHARE_HCLK_TIMER. #define CNTRL_CNT_EN (1&lt;&lt;0) //  . #define CNTRL_EVENT_SEL (1&lt;&lt;8) //   : CNT == ARR; #define DMA_RE_CNT_ARR_EVENT_RE (1&lt;&lt;1) //   DMA   CNT == ARR; #define IE_CNT_ARR_EVENT_IE (1&lt;&lt;1) //     CNT == ARR; #define TIM_CLOCK_TIM2_CLK_EN (1&lt;&lt;25) //     2. #define SHARE_HCLK_TIMER2 7 //   HCLK ... (0 =  , 1 = /2, 2 = /4). #define TIM_CLOCK_TIM2_BRG (SHARE_HCLK_TIMER2&lt;&lt;8)//    1  SHARE_HCLK_TIMER. #define CH1_CNTRL_CAP_nPWM_Z (1&lt;&lt;15) //:    "". #define CH1_CNTRL_CHPSC_8 (3&lt;&lt;6) //:      8. #define CHy_CNTRL2_CCR1_EN (1&lt;&lt;2) //:   1. #define TIMERx_IE_CNT_ARR_EVENT_IE (1&lt;&lt;1) //:       CNT  ARR. void Init_TIMER1_to_DMA_and_DAC2 (void) { RST_CLK-&gt;PER_CLOCK |= PER_CLOCK_TIMER1_ONCLK|PER_CLOCK_TIMER2_ONCLK; //   1  2. RST_CLK-&gt;TIM_CLOCK = 0; //  . //  8000000 /261.63/100 = 305. TIMER1-&gt;ARR = 305; // ... TIMER1-&gt;DMA_RE |= DMA_RE_CNT_ARR_EVENT_RE; //  DMA. TIMER2-&gt;ARR = 305*25; //   . TIMER2-&gt;IE = TIMERx_IE_CNT_ARR_EVENT_IE; //   . TIMER2-&gt;STATUS=0; //  . NVIC-&gt;ISER[0] = 1&lt;&lt;15; //    2. TIMER1-&gt;CNTRL = CNTRL_CNT_EN; //  . TIMER2-&gt;CNTRL = CNTRL_CNT_EN; RST_CLK-&gt;TIM_CLOCK = TIM_CLOCK_TIM1_CLK_EN|TIM_CLOCK_TIM2_CLK_EN; //    . }</span></span></span></span></code> </pre> </div></div><h4>  We write the function of changing structures. </h4>  We described the interrupt.  It remains only to check in it: if the primary structure has ended and at least 1 block from the alternative structure has been transferred, overwrite the primary one.  Same with the secondary.  Do not forget also that after the transfer of the first structure - DMA blocks the channel.  It is necessary to again allow his work so that the ‚Äúkicks‚Äù from timer 1 continue to pass. <div class="spoiler">  <b class="spoiler_title">Interrupt</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ST_Play_P (DAC_ST_ADC[10-1].channel_cfg &amp; (1023</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;4)) //       . #define ST_Play_ALT (DAC_ST_ADC[10-1+32].channel_cfg &amp; (1023&lt;&lt;4)) //       . void Timer2_IRQHandler (void) // . { if ((ST_Play_P == 0) &amp;&amp; (ST_Play_ALT &lt;= (48&lt;&lt;4))) //         -   2-. DAC_ST_ADC[10-1].channel_cfg = (uint32_t)(DMA_DAC_InitST_PR); if ((ST_Play_ALT == 0) &amp;&amp; (ST_Play_P &lt;= (48&lt;&lt;4))) DAC_ST_ADC[10-1+32].channel_cfg = (uint32_t)(DMA_DAC_InitST_ALT); DMA-&gt;CHNL_ENABLE_SET = 1&lt;&lt;10; TIMER2-&gt;STATUS=0; }</span></span></span></span></code> </pre> </div></div>  The code of the main function from the last example is changed only by turning on a new function and turning off SysTick. <div class="spoiler">  <b class="spoiler_title">Here he is.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ HSE_Clock_ON(); <span class="hljs-comment"><span class="hljs-comment">//  HSE . HSE_Clock_OffPLL(); // ""      HSE . Buzzer_out_DAC_init(); //   . DAC_Init(); // . DMA_to_DAC_and_TIM1(); // DMA    DAC2   1. Init_TIMER1_to_DMA_and_DAC2(); //  1. while (1) { } }</span></span></code> </pre> </div></div>  Running the program, we get the following picture at the output. <img src="//habrastorage.org/files/ed4/aaf/15a/ed4aaf15afa8492e8ca1c2edda82b409.PNG">  Download the sound <a href="">here</a> .  Download the example code <a href="">here</a> . <h4>  About errors </h4><div class="spoiler">  <b class="spoiler_title">Long tormented with the selection of the moment for the change of structures.</b>  <b class="spoiler_title">All the time, something like this came out.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/13c/8b6/29d/13c8b629d5e541a292b9fe6058bc9ba5.PNG"></div></div><h4>  Summarize </h4>  We managed to take another look at DMA, start enjoying its benefits.  In the next article we will consolidate our skills and create a semblance of a music box, and after - the player. <div class="spoiler">  <b class="spoiler_title">List of previous articles.</b> <div class="spoiler_text"><ul><li>  1. <a href="http://habrahabr.ru/post/255199/">We turn from STM32F103 to K1986BE92QI.</a>  <a href="http://habrahabr.ru/post/255199/">Or the first acquaintance with the Russian microcontroller.</a> </li><li>  2. <a href="http://habrahabr.ru/post/255323/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255323/">Setup project in keil and flashing LED.</a> </li><li>  3. <a href="http://habrahabr.ru/post/255415/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255415/">System Timer (SysTick).</a> </li><li>  4. <a href="http://habrahabr.ru/post/255479/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255479/">Setting the clock frequency.</a> </li><li>  5. <a href="http://habrahabr.ru/post/255513/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255513/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/255513/">Part one: we generate a square and sinusoidal signal.</a>  <a href="http://habrahabr.ru/post/255513/">Mastering the DAC (DAC).</a> </li><li>  6. <a href="http://habrahabr.ru/post/256091/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/256091/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/256091/">Part two: generate a sinusoidal signal.</a>  <a href="http://habrahabr.ru/post/256091/">Mastering DMA.</a> </li></ul></div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/256577/">https://habr.com/ru/post/256577/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256565/index.html">Light streams in Embox</a></li>
<li><a href="../256567/index.html">DataTalks # 2: Data Visualization</a></li>
<li><a href="../256571/index.html">Programmer == creativity || programmer! = creativity</a></li>
<li><a href="../256573/index.html">CTB-Locker. We decided to pay</a></li>
<li><a href="../256575/index.html">Seven principles of the effectiveness of a data center from Microsoft</a></li>
<li><a href="../256579/index.html">Two-step browser authentication with a U2F USB token</a></li>
<li><a href="../256581/index.html">Krovi: Big Data - as dream. 7th series. Big Jobs for Big Data</a></li>
<li><a href="../256585/index.html">10 useful frameworks that a developer needs to know</a></li>
<li><a href="../256587/index.html">3 CSS CSS Issues</a></li>
<li><a href="../256589/index.html">A story about how to write your own CSS preprocessor for 9 months</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>