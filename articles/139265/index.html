<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Synchronous and asynchronous download images from the network with subsequent processing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good to all habradnya! 

 Today I want to talk about one of the methods of synchronous and asynchronous image download from the network. To prevent th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Synchronous and asynchronous download images from the network with subsequent processing</h1><div class="post__text post__text-html js-mediator-article">  Good to all habradnya! <br><br>  Today I want to talk about one of the methods of synchronous and asynchronous image download from the network.  To prevent the article from being boring, we will try to process the downloaded images in some way using Qt. <br><img src="https://habrastorage.org/storage2/116/44d/277/11644d27707d9678ec51e48fdff1fddd.png"><br><br><h1>  How are we going to upload? </h1><br>  To upload images, we will use <code>QNetworkAccessManager</code> and <code>QEventLoop</code> , as well as some meta objects.  We will upload an HTTP image in any format supported by Qt.  Well, we will still handle redirects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  How we will process? </h1><br>  There is a wonderful QGraphicsEffect class with subclasses.  But we will not work with them in this article, accept!  And I will even explain why.  For example, in Qt 4.8.0, these effects lead to crashing of the application in Mac OS X 10.7. +, And in Qt 4.7.4 they do not work at all on the same system.  I don‚Äôt know how it happened, but I <a href="https://bugreports.qt-project.org/browse/QTBUG-23205">put the</a> bug in the Qt bug tracker. <br><br>  So, we will create our own class for image processing.  He will be able to do the following: <br><ul><li>  Convert image to grayscale </li><li>  To colorize (how can I say this in Russian?) </li><li>  Add shadow </li><li>  Change transparency </li><li>  Rotate around the center </li><li>  Square </li><li>  Square with rounding corners </li><li>  As a bonus, learn to read custom colors in the format #RRGGBBAA </li></ul><br>  Immediately, I note that the full code of the test project can be downloaded on a githab, a link at the end of the article. <br><a name="habracut"></a><br><h1>  So, loading image </h1><br>  To begin, we define what we want.  And we want this: we call a certain method of a certain class, transfer the image URL to it, as well as to what object to transfer the received image and to which method.  And when the image is loaded, our class should call the desired method of the desired object and transfer the downloaded image to it.  And all this is asynchronous.  Sounds good? <br><br>  For the cause!  We create the <code>Networking</code> class (I made it static, but it does not play a big role), and we create the <code>NetworkingPrivate</code> class - for real work. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// networking.h class Networking { public: static QImage httpGetImage(const QUrl&amp; src); static void httpGetImageAsync(const QUrl&amp; src, QObject * receiver, const char * slot); private: static NetworkingPrivate * networkingPrivate; static void init(); } // networking_p.h class NetworkingPrivate : public QObject { Q_OBJECT public: NetworkingPrivate(); ~NetworkingPrivate(); QImage httpGetImage(const QUrl&amp; src) const; void httpGetImageAsync(const QUrl&amp; src, QObject * receiver, const char * slot); public slots: void onFinished(QNetworkReply* reply); private: QNetworkAccessManager * nam; QEventLoop * loop; QMap&lt;QNetworkReply*, QPair&lt;QObject*, QPair&lt;QUrl, const char *&gt; &gt; &gt; requests; };</span></span></code> </pre><br>  Actually, our class will be able to load pictures both synchronously and asynchronously.  So there is a choice. <br><br>  Example of use: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// myclass.h class MyClass: public QObject { // ... public slots: void loadImage(const QString &amp; urlString); void onImageReady(const QUrl&amp; url, const QImage &amp; image); } // myclass.cpp void MyClass::loadImage(const QString &amp; urlString) { Networking::httpGetImageAsync(QUrl(urlString), this, "onImageRead"); }</span></span></code> </pre><br>  A few explanations about the insane private class.  <code>QNetworkAccessManager</code> we need to send http-requests, <code>QEventLoop</code> - to wait for a response in the case of synchronous requests, and <s>this horror</s> <code>QMap&lt;QNetworkReply*, QPair&lt;QObject*, QPair&lt;QUrl, const char *&gt; &gt; &gt; requests</code> - to store all requests to know which picture to which object should be delivered after loading. <br><br>  Now the most interesting thing is the implementation of private class functions (the <code>Networking</code> class, as you guessed, only redirects calls to its private class). <br><br><pre> <code class="cpp hljs">NetworkingPrivate::NetworkingPrivate() { nam = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QNetworkAccessManager(); loop = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QEventLoop(); connect(nam, SIGNAL(finished(QNetworkReply*)), loop, SLOT(quit())); connect(nam, SIGNAL(finished(QNetworkReply*)), SLOT(onFinished(QNetworkReply*))); } NetworkingPrivate::~NetworkingPrivate() { nam-&gt;deleteLater(); loop-&gt;deleteLater(); } QImage NetworkingPrivate::httpGetImage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QUrl&amp; src) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { QNetworkRequest request; request.setUrl(src); QNetworkReply * reply = nam-&gt;get(request); loop-&gt;exec(); QVariant redirectedUrl = reply-&gt;attribute(QNetworkRequest::RedirectionTargetAttribute); QUrl redirectedTo = redirectedUrl.toUrl(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (redirectedTo.isValid()) { <span class="hljs-comment"><span class="hljs-comment">// guard from infinite redirect loop if (redirectedTo != reply-&gt;request().url()) { return httpGetImage(redirectedTo); } else { qWarning() &lt;&lt; "[NetworkingPrivate] Infinite redirect loop at " + redirectedTo.toString(); return QImage(); } } else { QImage img; QImageReader reader(reply); if (reply-&gt;error() == QNetworkReply::NoError) reader.read(&amp;img); else qWarning() &lt;&lt; QString("[NetworkingPrivate] Reply error: %1").arg(reply-&gt;error()); reply-&gt;deleteLater(); return img; } } void NetworkingPrivate::httpGetImageAsync(const QUrl&amp; src, QObject * receiver, const char * slot) { QNetworkRequest request; request.setUrl(src); QPair&lt;QObject*, QPair&lt;QUrl, const char *&gt; &gt; obj; obj.first = receiver; obj.second.first = src; obj.second.second = slot; QNetworkReply * reply = nam-&gt;get(request); requests.insert(reply, obj); } void NetworkingPrivate::onFinished(QNetworkReply* reply) { if (requests.contains(reply)) { QPair&lt;QObject*, QPair&lt;QUrl, const char *&gt; &gt; obj = requests.value(reply); QVariant redirectedUrl = reply-&gt;attribute(QNetworkRequest::RedirectionTargetAttribute); QUrl redirectedTo = redirectedUrl.toUrl(); if (redirectedTo.isValid()) { // guard from infinite redirect loop if (redirectedTo != reply-&gt;request().url()) { httpGetImageAsync(redirectedTo, obj.first, obj.second.second); } else { qWarning() &lt;&lt; "[NetworkingPrivate] Infinite redirect loop at " + redirectedTo.toString(); } } else { QImage img; QImageReader reader(reply); if (reply-&gt;error() == QNetworkReply::NoError) reader.read(&amp;img); else qWarning() &lt;&lt; QString("[NetworkingPrivate] Reply error: %1").arg(reply-&gt;error()); if (obj.first &amp;&amp; obj.second.second) QMetaObject::invokeMethod(obj.first, obj.second.second, Qt::DirectConnection, Q_ARG(QUrl, obj.second.first), Q_ARG(QImage, img)); } requests.remove(reply); reply-&gt;deleteLater(); } }</span></span></code> </pre><br>  We now analyze these functions.  In the constructor, we create a <code>QEventLoop</code> , a <code>QNetworkAccessManager</code> and connect the signal to complete the request with <code>QEventLoop::quit()</code> and our <code>onFinished</code> method. <br><br>  For synchronous download, we execute the request and run the Event Loop, which will be completed at the end of the download.  At the same time, we still check the redirect and its obsession, so that the user can enter any links to the images, including those passed through the link shortening. <br><br>  Well, when we got our picture, we launch the <code>QImageReader</code> and read the data into the final <code>QImage</code> , which we return. <br><br>  With asynchronous loading, everything is trickier.  We save the request (more precisely, the link to the answer), the target object and its method in our terrible <code>QMap</code> , and then run the request.  And at the end of the request, we do the same thing as with a synchronous request (checking for redirect, its cyclicality and reading the picture), but the resulting <code>QImage</code> passed to the target object using <code>QMetaObject::invokeMethod</code> .  As parameters - URL request and image. <br><br>  Well, you can make a simple form in which you can drive a URL, click on the button and get an image from the network.  Synchronously or asynchronously.  And rejoice. <br><br>  But we will go further, and the resulting image will change. <br><br><h1>  Image processing class </h1><br>  We create another class (I have it again static, although for no reason at all), let's call it <code>ImageManager</code> .  And we will have the following methods in it: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normallyResized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QImage &amp; image, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maximumSideSize)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grayscaled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QImage &amp; image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">squared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QImage &amp; image, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">roundSquared</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QImage &amp; image, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addShadow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QImage &amp; image, QColor color, QPoint offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> canResize = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">colorized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QImage &amp; image, QColor color)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opacitized</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QImage &amp; image, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> opacity = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addSpace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QImage &amp; image, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> top, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bottom)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotatedImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QImage &amp; image, qreal angle)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> QColor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp; name)</span></span></span></span>; };</code> </pre><br>  It will allow us to get something like this (see the test project at the end of the article): <br><br><img src="https://habrastorage.org/storage2/a7d/f8b/b36/a7df8bb3622f03a56ae19f3e76922e9f.png"><br><br>  Let's go in order.  The first method is the least interesting, it only normalizes the image size on the maximum side.  The third method is also not particularly interesting - it makes the image square (adjusting the size and cutting off the excess).  I will not even include their sources in the article. <br><br>  Next will go quite interesting. <br><img src="https://habrastorage.org/storage2/ed8/11f/883/ed811f883273a9591adac2c630bc10ca.png" align="right"><br><h2>  Grayscale. </h2><br>  I found even two ways to do it, but I haven‚Äôt bothered to test both for speed yet.  So I bring two to choose from. <br><br>  The first way is to convert the image to the QImage :: Format_Indexed8 format, which means converting the image into an 8-bit indexable color.  To do this, you need to create a "color map" of 256 elements - from white to black. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image.size(), QImage::Format_ARGB32)</span></span></span></span>; gray.fill(Qt::transparent); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> QVector&lt;QRgb&gt; monoTable; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (monoTable.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">255</span></span>; i++) monoTable.append(qRgb(i, i, i)); } <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;gray)</span></span></span></span>; p.drawImage(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, image.convertToFormat(QImage::Format_Indexed8, monoTable)); p.end(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gray;</code> </pre><br>  The second method is based on direct work with image bits.  Pass through all the pixels and set them to the value of gray. <br><br><pre> <code class="cpp hljs">QImage img = image; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!image.isNull()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pixels = img.width() * img.height(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pixels*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(QRgb) &lt;= img.byteCount()) { QRgb *data = (QRgb *)img.bits(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pixels; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = qGray(data[i]); data[i] = qRgba(val, val, val, qAlpha(data[i])); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> img;</code> </pre><br>  The second method, in my opinion, should work faster, since no additional image is created.  In addition, it is also suitable for images with transparency, which is also very good.  That is why it is used in the finals. <br><img src="http://habrastorage.org/storage2/f3f/f69/877/f3ff698776346133b4e553e0bbcbff54.png" align="left"><br><h2>  Corner rounding </h2><br>  Here the algorithm is quite interesting.  My first thought was to create a mask and crop an image on it.  But after long unsuccessful attempts to correctly draw this very mask with QPainter :: draw [Ellipse | Arc | RoundedRect | Path], I abandoned this idea.  For some reason, this approach gives a good result only for some rounding radii.  In addition, the result may be different in different operating systems, which also does not honor this method.  This, apparently, is due to the inability to make antialiasing for the bit mask - it should have only two colors, black and white.  The new method laughs at these problems, and gives an additional bun in the form of smooth rounding with anti-aliasing. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shapeImg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QSize(size, size), QImage::Format_ARGB32_Premultiplied)</span></span></span></span>; shapeImg.fill(Qt::transparent); <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;shapeImg)</span></span></span></span>; sp.setRenderHint(QPainter::Antialiasing); sp.setPen(QPen(Qt::color1)); sp.setBrush(QBrush(Qt::color1)); sp.drawRoundedRect(QRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, size, size), radius + <span class="hljs-number"><span class="hljs-number">1</span></span>, radius + <span class="hljs-number"><span class="hljs-number">1</span></span>); sp.end(); <span class="hljs-function"><span class="hljs-function">QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">roundSquaredImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size, size, QImage::Format_ARGB32_Premultiplied)</span></span></span></span>; roundSquaredImage.fill(Qt::transparent); <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;roundSquaredImage)</span></span></span></span>; p.drawImage(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, shapeImg); p.setCompositionMode(QPainter::CompositionMode_SourceIn); p.drawImage(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, squared(image, size)); p.end(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> roundSquaredImage;</code> </pre><br>  The essence is almost the same as the image masking.  Create a rounded black square (with anti-aliasing), and then draw on top of it the original image with the composition mode <code>QPainter::CompositionMode_SourceIn</code> .  Simple and tasteful, as they say. <br><img src="http://habrastorage.org/storage2/718/c6f/fb6/718c6ffb6b7e06f9ec370e82c6c9569c.png" align="right"><br><h2>  Add shadow </h2><br>  Now try to add a shadow to the image.  And, taking into account transparency.  The resulting picture, of course, may have dimensions that are different from the original. <br><br><pre> <code class="cpp hljs">QSize shadowedSize = image.size(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canResize) { shadowedSize += QSize(qAbs(offset.x()), qAbs(offset.y())); } <span class="hljs-function"><span class="hljs-function">QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shadowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(shadowedSize, QImage::Format_ARGB32_Premultiplied)</span></span></span></span>; shadowed.fill(Qt::transparent); <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;shadowed)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shadowImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image.size(), QImage::Format_ARGB32_Premultiplied)</span></span></span></span>; shadowImage.fill(Qt::transparent); <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmpPainter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;shadowImage)</span></span></span></span>; tmpPainter.setCompositionMode(QPainter::CompositionMode_Source); tmpPainter.drawPixmap(QPoint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), QPixmap::fromImage(image)); tmpPainter.setCompositionMode(QPainter::CompositionMode_SourceIn); tmpPainter.fillRect(shadowImage.rect(), color); tmpPainter.end(); QPoint shadowOffset = offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canResize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset.x() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) shadowOffset.setX(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset.y() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) shadowOffset.setY(<span class="hljs-number"><span class="hljs-number">0</span></span>); } p.drawImage(shadowOffset, shadowImage); <span class="hljs-function"><span class="hljs-function">QPoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">originalOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canResize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset.x() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) originalOffset.setX(qAbs(offset.x())); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (offset.y() &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) originalOffset.setY(qAbs(offset.y())); } p.drawPixmap(originalOffset, QPixmap::fromImage(image)); p.end(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shadowed;</code> </pre><br>  Here we first create a shadow image using artful drawing with different composition modes, and then draw it and the original image over.  With the necessary shifts, of course. <br><img src="http://habrastorage.org/storage2/945/399/073/9453990736e31020f7d27fd0ed2938a0.png" align="left"><br><h2>  Colorization </h2><br>  To achieve the effect of colorization, there are many different methods.  I chose one, in my opinion, the most successful. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resultImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image.size(), QImage::Format_ARGB32_Premultiplied)</span></span></span></span>; resultImage.fill(Qt::transparent); <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">painter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;resultImage)</span></span></span></span>; painter.drawImage(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, grayscaled(image)); painter.setCompositionMode(QPainter::CompositionMode_Screen); painter.fillRect(resultImage.rect(), color); painter.end(); resultImage.setAlphaChannel(image.alphaChannel()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resultImage;</code> </pre><br>  Here we simply draw the original image in shades of gray (we already know how), and then overlay the rectangle of the desired color in the Composition mode Screen.  And do not forget about the alpha channel. <br><img src="http://habrastorage.org/storage2/ec1/e96/b4a/ec1e96b4ad5d3ecb7e58060188e25fc4.png" align="right"><br><h2>  Change transparency </h2><br>  Now we will make our image transparent.  It's very simple - done with <code>QPainter::setOpacity</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resultImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image.size(), QImage::Format_ARGB32)</span></span></span></span>; resultImage.fill(Qt::transparent); <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">painter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;resultImage)</span></span></span></span>; painter.setOpacity(opacity); painter.drawImage(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, image); painter.end(); resultImage.setAlphaChannel(image.alphaChannel()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resultImage;</code> </pre><br><img src="http://habrastorage.org/storage2/69d/469/5c3/69d4695c308802d6c35c4c569a1cf3b6.png" align="right"><br><h2>  Rotate the picture </h2><br>  Rotate around the center.  The implementation of the rotation around an arbitrary point will leave readers as homework.  Everything is also very simple here - the main thing is not to forget about smooth transformations. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QImage </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image.size(), QImage::Format_ARGB32_Premultiplied)</span></span></span></span>; rotated.fill(Qt::transparent); <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;rotated)</span></span></span></span>; p.setRenderHint(QPainter::Antialiasing); p.setRenderHint(QPainter::SmoothPixmapTransform); qreal dx = image.size().width() / <span class="hljs-number"><span class="hljs-number">2.0</span></span>, dy = image.size().height() / <span class="hljs-number"><span class="hljs-number">2.0</span></span>; p.translate(dx, dy); p.rotate(angle); p.translate(-dx, -dy); p.drawImage(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, image); p.end(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotated;</code> </pre><br><h1>  Grand final </h1><br>  Everything, now you can write a test program (or download mine from <a href="https://github.com/silvansky/HabraImageEffects">GitHub</a> 'a) and enjoy the results! <br><br>  As a bonus I will give a small function for more convenient reading of color from a string value.  Qt for some reason does not understand the color in the <code>#RRGGBBAA</code> format, which I replenished with my function: <br><pre> <code class="cpp hljs">QColor ImageManager::resolveColor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp; name) { QColor color; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (QColor::isValidColor(name)) color.setNamedColor(name); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// trying to parse "#RRGGBBAA" color if (name.length() == 9) { QString solidColor = name.left(7); if (QColor::isValidColor(solidColor)) { color.setNamedColor(solidColor); int alpha = name.right(2).toInt(0, 16); color.setAlpha(alpha); } } } if (!color.isValid()) qWarning() &lt;&lt; QString("[ImageManager::resolveColor] Can\'t parse color: %1").arg(name); return color; }</span></span></code> </pre><br>  At the same time, all standard colors (such as <code>white</code> , <code>transparent</code> , <code>#ffa0ee</code> ) are also well understood. <br><br>  <b>PS:</b> For those who doubt whether it is worth investigating the example code on a githaba, I‚Äôll leave a couple of lines here.  Firstly, the code in the article is a bit simplified - some useful checks and so on have been removed.  Secondly, the full example uses the retrieval and preservation / use of cookies when requested.  Thirdly, there are additional functions for drawing a picture consisting of nine parts (nine-part image), which can simplify the manual drawing of buttons, input fields and other similar things.  So the buns are provided! <br><br>  <b>PPS:</b> If someone knows more successful algorithms to perform all the considered tasks, welcome to express them in the comments!  The same applies to other image processing methods - I‚Äôm happy to read about them. </div><p>Source: <a href="https://habr.com/ru/post/139265/">https://habr.com/ru/post/139265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../139256/index.html">Notch gives its employees $ 3,000,000 dividends for 2011</a></li>
<li><a href="../139258/index.html">Canonical creates its own mobile platform.</a></li>
<li><a href="../139259/index.html">Run projects created in Visual Studio 2011 at Visual Studio 2010</a></li>
<li><a href="../139263/index.html">Approach to designing an internet distribution platform using templates</a></li>
<li><a href="../139264/index.html">Kanobuvosti, 133rd edition</a></li>
<li><a href="../139267/index.html">Public services are transparent, but not quality</a></li>
<li><a href="../139268/index.html">Lync and Avaya IPO integration</a></li>
<li><a href="../139270/index.html">Virtual hosting Django, model N</a></li>
<li><a href="../139271/index.html">Rent an IP PBX by model VPBX, or how to organize a modern telephone in the office</a></li>
<li><a href="../139272/index.html">My integration with 1C</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>