<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New V8 and Node.js speed: optimization techniques today and tomorrow</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Node.js, since its inception, depends on the V8 JS engine, which ensures the execution of commands of the language that we all know and love. V8 is a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New V8 and Node.js speed: optimization techniques today and tomorrow</h1><div class="post__text post__text-html js-mediator-article">  Node.js, since its inception, depends on the V8 JS engine, which ensures the execution of commands of the language that we all know and love.  V8 is a JavaScript virtual machine written by Google for the Chrome browser.  From the very beginning, V8 was created in order to make JavaScript fast, at least to provide more speed than competing engines.  For a dynamic language without strong typing, achieving high performance is not an easy task.  V8 and other engines are developing, all the better solving this problem.  However, the new engine is not just ‚Äúan increase in the speed of JS execution‚Äù.  This is also the need for new approaches to code optimization.  Not everything that was the fastest today will please us with maximum performance in the future.  Not everything that was considered slow will remain so. <br><br>  How will the characteristics of TurboFan V8 affect how the code will be optimized?  How techniques, considered the best today, show themselves in the near future?  How do V8 performance killers behave these days, and what can we expect from them?  In this article we tried to find answers to these and many other questions. <br><br>  Before you - the fruit of the joint work of <a href="https://twitter.com/davidmarkclem">David Mark Clements</a> and <a href="https://twitter.com/matteocollina">Matteo Collins</a> .  The material was checked by <a href="https://twitter.com/fhinkel">Francis Hinkelmann</a> and <a href="https://twitter.com/bmeurer">Benedict Meirer</a> from the V8 development team. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href="https://habrahabr.ru/company/ruvds/blog/334806/"><img src="https://habrastorage.org/web/d0d/665/0d6/d0d6650d6750404c8b28470502273a49.jpg"></a> <br><a name="habracut"></a><br>  The central part of the V8 engine, which allows it to execute JavaScript at high speed, is the JIT compiler (Just In Time).  This is a dynamic compiler that can optimize the code during its execution.  When the V8 was first created, the JIT compiler was called FullCodeGen, it was (as <a href="https://twitter.com/hashseed">Yang Guo</a> rightly pointed out) the first optimizing compiler for this platform.  The V8 team then created the Crankshaft compiler, which included many performance optimizations that were not implemented in FullCodeGen. <br><br>  As a person who has been watching JavaScript since the 90s and used it all the time, I noticed that often which parts of the JS code will work slowly and which quickly will be completely unobvious, no matter which engine is used.  The reasons why programs were performed more slowly than expected were often difficult to understand. <br><br>  In recent years, I and Matteo Collina have focused on figuring out how to write high-performance code for Node.js.  Naturally, this implies knowing which approaches are fast and which are slow when our code is executed by the V8 JS engine. <br><br>  Now it's time to review all our performance assumptions, as the V8 team wrote a new JIT compiler: TurboFan. <br><br>  We are going to consider well-known software constructs that lead to the abandonment of optimizing compilation.  In addition, here we will do more complex research aimed at studying the performance of different versions of the V8.  All this will be done through a series of microbenchmarks launched using different versions of Node and V8. <br><br>  Of course, before optimizing the code for V8 features, we first need to focus on the design of the API, algorithms, and data structures.  These microbench marks can be viewed as indicators of how the execution of JavaScript changes in Node.  We can use these indicators in order to change the overall style of our code and the ways in which we improve performance after applying normal optimizations. <br><br>  We review the performance of microbench marks in V8 versions 5.1, 5.8, 5.9, 6.0, and 6.1. <br><br>  To understand how V8 versions are related to Node versions, we note the following: the V8 5.1 engine is used in Node 6, the Crankshaft JIT compiler is used here, the V8 5.8 engine is used in Node versions from 8.0 to 8.2, and Crankshaft is used here, and TurboFan. <br><br>  At the moment, it is expected that in Node 8.3, or, possibly, in 8.4, there will be a V8 engine of version 5.9 or 6.0.  The most recent at the time of this writing, version V8 - 6.1.  It is integrated into Node in the <a href="https://github.com/nodejs/node-v8">node-v8</a> experimental repository.  In other words, V8 6.1, in the end, will be in some future version of Node. <br><br>  Test code and other materials used in the preparation of this article can be found <a href="https://github.com/davidmarkclements/v8-perf">here.</a> <br>  <a href="https://docs.google.com/spreadsheets/d/1mDt4jDpN_Am7uckBbnxltjROI9hSu6crf9tOa2YnSog/edit%3Fusp%3Dsharing">Here</a> is a document in which, among other things, there are unprocessed test results. <br><br>  Most microbench marks are made on Macbook Pro 2016, 3.3 GHz Intel Core i7, 16 GB 2133 MHz LPDDR3 memory.  Some of them (working with numbers, removing object properties) were performed on MacBook Pro 2014, 3 GHz Intel Core i7, 16 GB 1600 MHz DDR3 memory.  Performance measurements for different versions of Node.js were performed on the same computer.  We closely followed that other programs did not affect the test results. <br><br>  Let's take a look at our tests and talk about what the results mean for the future Node.  All tests were performed using the <a href="https://www.npmjs.com/package/benchmark">benchmark.js</a> package, the data in each of the diagrams means the number of operations per second, that is, the higher the obtained value, the better. <br><br><h2>  <font color="#3AC1EF">Try / catch problem</font> </h2><br>  One of the well-known de-optimization patterns is the use of <code>try/catch</code> blocks. <br><br>  Please note that here and hereinafter in the test description lists, in brackets, the short test names in English will be given.  These names are used to indicate results in diagrams.  In addition, they will help you navigate the code that was used during the tests. <br>  In this test, we compare four test cases: <br><br><ul><li>  The function that performs the calculations in the <code>try/catch</code> located in it (sum with tr catch). <br><br></li><li>  A function that performs calculations without <code>try/catch</code> blocks (sum without try catch). <br><br></li><li>  A function call to perform calculations inside the <code>try</code> (sum wrapped) block. <br><br></li><li>  A function call to perform calculations without using <code>try/catch</code> (sum function). <br></li></ul><br>  ‚Üí <a href="">Test code on GitHub</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/726/449/b82/726449b825635e940f6c18552ac618e4.png"><br><br>  We can see that what is already known about the negative impact of <code>try/catch</code> on performance is confirmed in Node 6 (V8 5.1), and in Node 8.0-8.2 (V8 5.8) <code>try/catch</code> has a much smaller impact on performance. <br><br>  It should also be noted that calling a function from a <code>try</code> block is much slower than calling it outside of <code>try</code> - this is true for Node 6 (V8 5.1) and for Node 8.0-8.2 (V8 5.8). <br><br>  However, in Node 8.3+ a function call from a <code>try</code> block has virtually no effect on performance. <br><br>  However, do not be complacent.  While working on some materials for the optimization workshop, we found a <a href="https://bugs.chromium.org/p/v8/issues/detail%3Fid%3D6576%26q%3Dmatteo%2520collina%26colspec%3DID%2520Type%2520Status%2520Priority%2520Owner%2520Summary%2520HW%2520OS%2520Component%2520Stars">mistake</a> when a rather specific set of circumstances could lead to an endless deoptimization / reoptimization cycle in TurboFan.  This can be considered as another template killer performance. <br><br><h2>  <font color="#3AC1EF">Removing properties from objects</font> </h2><br>  For many years, the <code>delete</code> command was avoided by anyone who wanted to write high-performance JS code (well, at least in cases where it was necessary to write the optimal code for the most loaded parts of programs). <br><br>  The problem with <code>delete</code> comes down to how V8 deals with the dynamic nature of JavaScript objects, and with prototype chains (also potentially dynamic) that make it difficult to search for properties at a low level engine implementation. <br><br>  The approach of the V8 engine to creating high-performance objects with properties is to create a class at the C ++ level, based on the "form" of the object, that is, on what keys and values ‚Äã‚Äãthe object has (including the keys and values ‚Äã‚Äãof the prototype chain).  These constructs are known as ‚Äúhidden classes‚Äù.  However, this type of optimization is performed during program execution.  If there is no certainty about the shape of the object, V8 has another property search mode: a hash table search.  This property search is much slower. <br><br>  Historically, when we <code>delete</code> key from an object with the <code>delete</code> command, subsequent property access operations will be performed by searching in the hash table.  That is why programmers try not to use the <code>delete</code> command, instead setting properties to <code>undefined</code> , which, in terms of destroying a value, leads to the same result, but adds difficulties when checking the existence of a property.  However, usually this approach is good enough, for example, when preparing objects for serialization, since <code>JSON.stringify</code> does not include <code>undefined</code> values ‚Äã‚Äãin its output ( <code>undefined</code> , according to the JSON specification, does not apply to valid values). <br><br>  Now let's find out if the new TurboFan implementation solves the problem of removing properties from objects. <br><br>  Here we compare three test cases: <br><br><ul><li>  Serialize an object after its property has been set to <code>undefined</code> (setting to undefined). <br><br></li><li>  Serialization of an object after the <code>delete</code> (delete) command was used to delete its property. <br><br></li><li>  Serializing an object after the <code>delete</code> command was used to delete a property that was added later (delete last property). <br></li></ul><br>  ‚Üí <a href="">Test code on GitHub</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a26/d93/65c/a26d9365cb1bf6d82ce2085a3d556f72.png"><br><br>  In V8 6.0 and 6.1 (they are not yet used in any of the Node releases), the removal of the last property added to the object corresponds to the optimized TurboFan program execution path, and thus it is performed even faster than setting the property to <code>undefined</code> .  This is very good, as it says that the V8 development team is working to improve the performance of the <code>delete</code> command. <br><br>  However, the use of this operator still leads to a serious drop in performance when accessing properties, if a property that was not the last one added was removed from the object.  This observation helped us to make <a href="http://disq.us/p/1kvomfk">Jacob Kummerov</a> , who pointed out the peculiarity of our tests, in which only the variant with the removal of the last added property was investigated.  Thanks to him.  In the end, no matter how we would like to say that the <code>delete</code> command can and should be used in the code written for future Node releases, we have to recommend not to do this.  The <code>delete</code> command continues to adversely affect performance. <br><br><h2>  <font color="#3AC1EF">Leakage and conversion to an array of arguments object</font> </h2><br>  A typical problem with an implicitly created <code>arguments</code> object that is available in regular functions (as opposed to them, the arrow functions of the <code>arguments</code> object have not) is that it looks like an array, but is not an array. <br><br>  In order to use the methods of arrays or features of their behavior, indexed <code>arguments</code> properties must be copied into an array.  In the past, JS developers had a tendency to equate shorter and faster code.  Although this approach, in the case of client code, allows you to achieve a reduction in the amount of data that the browser has to load, the same can lead to problems with server code, where the size of programs is much less important than the speed of their execution.  As a result, a temptingly short way to convert a <code>arguments</code> object into an array has become quite popular: <br><br>  <code>Array.prototype.slice.call(arguments)</code> .  This command calls the <code>slice</code> method of the <code>Array</code> object, passing the <code>arguments</code> object as the context for this method.  The <code>slice</code> method sees an object that looks like an array, and then does its job.  As a result, we get an array collected from the contents of the <code>arguments</code> object, similar to an array. <br><br>  However, when an implicitly created <code>arguments</code> object is passed to something outside the context of the function (for example, if it is returned from a function or passed to another function, as when calling <code>Array.prototype.slice.call(arguments)</code> ), this usually causes a performance drop.  We investigate this statement. <br><br>  The following microbenchmark aims to explore two interrelated situations in four versions of the V8.  Namely, it is the cost of the <code>arguments</code> leakage and the cost of copying the <code>arguments</code> to the array, which is then passed outside the function instead of the <code>arguments</code> object. <br><br>  Here are our test cases: <br><br><ul><li>  Passing the <code>arguments</code> object to another function without converting <code>arguments</code> to an array (leaky arguments). <br><br></li><li>  Create a copy of the <code>arguments</code> object using the <code>Array.prototype.slice</code> (Array.prototype.slice arguments) construct. <br><br></li><li>  Using <code>for</code> and copying each property (for-loop copy arguments) <br><br></li><li>  Using an extension operator from EcmaScript 2015 to assign an array of input data to a function (spread operator). <br></li></ul><br>  ‚Üí <a href="">Test code on GitHub</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/307/038/32c/30703832c8c11482e20b456f513358b9.png"><br><br>  Let's look now at the same data presented in the form of a line graph in order to highlight changes in performance characteristics. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/586/272/b30/586272b3015f1ac04aa67be2589eb205.png"><br><br>  Here are the conclusions from all of this.  If you need to write productive code that involves processing the input data of a function as an array (which I know from experience, you need quite often), then in Node 8.3 and above, you need to use an extension operator.  In Node 8.2 and below, you should use a <code>for</code> loop to copy keys from <code>arguments</code> to a new (previously created) array (for details, see the test code). <br><br>  Further, in Node 8.3+, there is no performance degradation when passing the <code>arguments</code> object to other functions, so there may be other performance advantages if we do not need a full array and can work with a structure similar to an array, but not a non-array. <br><br><h2>  <font color="#3AC1EF">Partial application (currying) and context binding functions</font> </h2><br>  Partial application (or currying) of functions allows you to save a certain state in the areas of visibility of the nested closure. <br><br>  For example: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add10 = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> add(<span class="hljs-number"><span class="hljs-number">10</span></span>, n) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add10(<span class="hljs-number"><span class="hljs-number">20</span></span>))</code> </pre> <br>  In this example, the parameter <code>a</code> function <code>add</code> partially applied as the number 10 in the function <code>add10</code> . <br><br>  A shorter form of partial use of the function has become available since EcmaScript 5 due to the <code>bind</code> method: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add10 = add.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(add10(<span class="hljs-number"><span class="hljs-number">20</span></span>))</code> </pre> <br>  However, usually the <code>bind</code> method is not used, since it is noticeably slower than the closure method described above. <br><br>  In our test, the difference between using <code>bind</code> and closure in different versions of V8 is measured.  For comparison, the direct call to the original function is used here. <br><br>  Here are four test cases. <br><br><ul><li>  A function that calls another function with a preliminary partial application of the first argument (curry). <br><br></li><li>  Arrow function that calls another function with the first argument partially applied (fat arrow curry). <br><br></li><li>  A function created using the <code>bind</code> method, which partially applies the first argument to another function (bind). <br><br></li><li>  Direct function call without using a partial application (direct call). <br></li></ul><br>  ‚Üí <a href="">Test code on GitHub</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b3/e84/e62/0b3e84e628c8b8701af491b466562560.png"><br><br>  The linear diagram of the test results clearly shows the almost complete lack of differences between the considered methods of working with functions in the latest versions of V8.  Interestingly, partial application using switch functions is much faster than using normal functions (at least in our tests).  In fact, it almost coincides with the direct function call.  In V8 5.1 (Node 6) and 5.8 (Node 8.0-8.2), <code>bind</code> very slow, and it seems obvious that using switch functions for these purposes allows you to achieve the highest speed.  However, the performance with <code>bind</code> , starting with V8 version 5.9 (Node 8.3+) is significantly increasing.  This approach turns out to be the fastest (although the difference in performance is practically indistinguishable here) in V8 6.1 (Node of future versions). <br><br>  The fastest method of currying in all versions of Node is the use of arrow functions.  In recent versions, the difference between this method and the use of <code>bind</code> insignificant, in the current conditions it is faster than using normal functions.  However, we cannot say that the results obtained are valid in all situations, since we probably need to investigate more types of partial application of functions with data structures of various sizes in order to get a more complete picture. <br><br><h2>  <font color="#3AC1EF">Function Code Size</font> </h2><br>  The size of the function, including its signature, spaces, and even comments, can affect whether V8 can make the function built-in or not.  Yes, it is: adding comments to a function can decrease performance by about 10%.  Will this change in the future? <br><br>  In this test, we explore three scenarios: <br><br><ul><li>  Call a function of small size (sum small function). <br><br></li><li>  The work of a small function, supplemented by comments, performed in the built-in mode (long all together). <br><br></li><li>  Call a large function with comments (sum long function). <br></li></ul><br>  ‚Üí <a href="">Test code on GitHub</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d5/8dd/d99/3d58ddd99669b43d4ba300dcc6be4eb5.png"><br><br>  In V8 5.1 (Node 6), the sum tests small function and long all together show the same result.  This perfectly illustrates how embedding works.  When we call a small function, this is analogous to the fact that V8 writes the contents of this function to the place from where it is called.  Therefore, when we write the text of a function (even with the addition of comments), we manually embed it in the place of the call and the performance is the same.  Again, in V8 5.1 (Node 6), you can see that calling a function, supplemented with comments, after reaching a function of a certain size, leads to a significantly slower code execution. <br><br>  In Node 8.0-8.2 (V8 5.8), the situation as a whole remains the same, except for the fact that the cost of calling a small function has increased markedly.  This is probably due to the mixing of the Crankshaft and TurboFan elements, where one function can be in Crankshaft and the other in TurboFan, which leads to a disorder of the embedding mechanisms (that is, a transition between clusters of sequentially built-in functions should occur). <br><br>  In V8 5.9 and higher (Node 8.3+), adding extraneous characters, such as spaces or comments, does not affect the performance of functions.  This is due to the fact that TurboFan uses the abstract syntax tree (AST, <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> ) to calculate the size of a function, instead of counting characters as Crankshaft.  Instead of taking the number of bytes of a function into account, TurboFan analyzes the actual instructions of a function, so starting with V8 5.9 (Node 8.3+), <b>spaces, the characters that make up variable names, function signatures and comments no longer affect whether a function can be built</b> .  In addition, it is impossible not to notice that the overall performance of the functions is reduced. <br><br>  The main conclusion here is that the functions should still be made as small as possible.  At the moment, you still need to avoid unnecessary comments (and even spaces) inside functions.  In addition, if you are aiming for maximum performance, manually embedding functions (that is, transferring the function code to the call site, which eliminates the need to call functions) stably remains the fastest approach.  Of course, there is a need to keep a balance here, because after reaching a real executable code of a certain size, the function will not be built in anyway, therefore, mindlessly copying the code of other functions into its own can cause performance problems.  In other words, manual embedding of functions is a potential ‚Äúshot in the foot.‚Äù  In most cases, embedding functions is better to entrust to the compiler. <br><br><h2>  <font color="#3AC1EF">32-bit and 64-bit integers</font> </h2><br>  It is well known that in JavaScript there is only one numeric type: <code>Number</code> . <br><br>  However, V8 is implemented in C ++, so the basic type of the JavaScript numeric value is a matter of choice. <br><br>  In the case of integers (that is, when we specify numbers in JS without a decimal point), V8 considers all numbers to be 32-bit ‚Äî as long as they stop being so.  This seems like a fair choice, since in many cases the numbers are in the range 2147483648 -2147483647.  If the JS number (in its entirety) exceeds 2147483647, the JIT compiler has to dynamically change the base type of a numeric value to a double-precision type (floating point) - this can potentially have some effect on other optimizations. <br><br>  In this test, we will look at three scenarios: <br><br><ul><li>  A function that works only with numbers that fit into a 32-bit range (sum small). <br><br></li><li>  A function that works with a combination of 32-bit numbers and numbers that require a double-precision data type (from small to big) to represent. <br><br></li><li>  A function that operates only on numbers with double precision (all big). <br></li></ul><br>  ‚Üí <a href="">Test code on GitHub</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a64/787/126/a6478712617090d51b812b4d0acc0458.png"><br><br>  The diagram suggests that whether it is a Node 6 (V8 5.1), or a Node 8 (V8 5.8), or even future versions of the Node, the above observation remains true.  Namely, it turns out that calculations using integers exceeding 2147483647, lead to the fact that functions are performed at a speed in the region of half or two thirds of the maximum.  Therefore, if you have long digital IDs, place them in strings. <br><br>  In addition, it is very noticeable that operations with numbers that fit in the 32-bit range are performed much faster in Node 6 (V8 5.1), as well as in Node 8.1 and 8.2 (V8 5.8) than in Node 8.3+ (V8 5.9+ ).  However, operations on doubles in Node 8.3+ (V8 5.9+) are faster.  This is probably due to the slowdown in processing 32-bit numbers, and does not refer to the speed of calling functions or <code>for</code> loops that are used in the test code. <br><br>  <a href="http://disq.us/p/1kvomfk">Jacob Kummerov</a> , <a href="https://twitter.com/hashseed">Yang Guo</a> and the V8 team helped us to make the results of this test more accurate and more accurate.  We thank them for it. <br><br><h2>  <font color="#3AC1EF">Enumerate object properties</font> </h2><br>  Taking the values ‚Äã‚Äãof all the properties of an object and performing actions on them is a common task.  There are many ways to solve it.  Find out which method is the fastest in the V8 and Node versions under investigation. <br><br>  Here are four tests that all V8 versions tested underwent: <br><br><ul><li>  Use a <code>for-in</code> loop using <code>hasOwnProperty</code> to determine if a property is an object property (for-in). <br><br></li><li>  Using <code>Object.keys</code> and enumerating keys using the <code>reduce</code> method of an <code>Array</code> object.  Property values ‚Äã‚Äãare accessed within the iterator function passed to <code>reduce</code> (Object.keys functional). <br><br></li><li>  Using <code>Object.keys</code> and enumerating keys using the <code>reduce</code> method of an <code>Array</code> object.  The property values ‚Äã‚Äãare accessed inside an iterator switch function passed to <code>reduce</code> (Object.keys functional with arrow). <br><br></li><li>  <code>Object.keys</code> array returned from <code>Object.keys</code> in a <code>for</code> loop.  The access to the property values ‚Äã‚Äãof the object is performed in the same loop (Object.keys with for loop). <br></li></ul><br>  In addition, we conducted three additional tests for V8 versions 5.8, 5.9, 6.0 and 6.1: <br><br><ul><li>  Using <code>Object.values</code> and <code>Object.values</code> over the property values ‚Äã‚Äãof an object using the <code>reduce</code> method of the <code>Array</code> (Object.values ‚Äã‚Äãfunctional) object. <br><br></li><li>  Using <code>Object.values</code> and enumerating values ‚Äã‚Äãusing the <code>reduce</code> method of the <code>Array</code> object, the iterator function passed to the <code>reduce</code> method was a switch function (Object.values ‚Äã‚Äãfunctional with arrow). <br><br></li><li>  <code>Object.values</code> array returned from <code>Object.values</code> in a <code>for</code> loop (Object.values ‚Äã‚Äãwith for loop). <br></li></ul><br>  We did not perform these tests in V8 5.1 (Node 6), since this version does not support the built-in method EcmaScript 2017 <code>Object.values</code> . <br><br>  ‚Üí <a href="">Test code on GitHub</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/21a/4b9/e92/21a4b9e92ab05e547e050acedf68d5d6.png"><br><br>  In Node 6 (V8 5.1) and Node 8.0-8.2 (V8 5.8), using a <code>for-in</code> loop is without a doubt the fastest way to iterate over the keys of an object, and then access its property values.     40    ,   5  ,       ,   <code>Object.keys</code> ,    8    . <br><br>  V8 6.0 (Node 8.3)   <code>for-in</code> -         ,    . ,     . <br><br>  V8 6.1 ( ,    Node),  ,  <code>Object.keys</code> , ,        <code>for-in</code> , ,        ,     <code>for-in</code>  V8 5.1  5.8 (Node 6, Node 8.0-8.2). <br><br> ,    TurboFan ‚Äî     ,      .  ,     ,    . <br><br>  <code>Object.values</code>      ,   <code>Object.keys</code>       .  ,    ,   .  ,       ,       . <br><br>  ,  ,     <code>for-in</code> -   ,       .    ,       . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>    JS ‚Äî  ,   ,       . <br><br>      : <br><br><ul><li>       (literal). <br></li><li>      EcmaScript 2015 (class). <br></li><li>     - (constructor). <br></li></ul><br> ‚Üí <a href="">   GitHub</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2d/be6/7d7/a2dbe67d78552f5accdd36ce2e4a0074.png"><br><br>  Node 6 (V8 5.1)      . <br><br>  Node 8.0-8.2 (V8 5.8),      EcmaScript 2015,     ,        -.   ,  ,       Node. <br><br>  V8 5.9           . <br><br> ,  V8 6.0 (,   Node 8.3  8.4)  6.1 (   V8        Node),      .  500    !   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/000/21f/f6c/00021ff6cf5b26eb78adc525a9d2980e.gif"></div><br>     ,         .   ,         ,    .   ,   ,    ,       (     ). <br><br>  ,     <a href="http://disq.us/p/1kvomfk"></a> ,  TurboFan       .        . <br><br><h2> <font color="#3AC1EF">   </font> </h2><br>             (,  ),  ,     .      .  ,            . ,   ,  ,   ,   -  .   ,   ,    ,     .      . <br><br>      : <br><br><ul><li>    ,    ,   (polymorphic with literal). <br><br></li><li>    ,    ,   (polymorphic with constructor). <br><br></li><li>     (monomorphic string). <br><br></li><li>    ,     (monomorphic obj literal). <br><br></li><li>    ,     (monomorphic obj with constructor). <br></li></ul><br> ‚Üí <a href="">   GitHub</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f4/f1e/79e/3f4f1e79e6366de5a24076ac58cf2eb0.png"><br><br>      ,           V8. <br><br>          V8 6.1 ( ,       Node)  ,   . ,  ,       node-v8,      ¬´ ¬ª V8,          V8 6.1. <br><br>   ,    ,  ,    ,    ,   .   ,      , ,        ,  API  . <br><br>      ,   V8    ,         ,     , <code>d8</code> . ,      Node.    ,   ,       Node (  ,  Node   V8).     .     ,      . <br><br><h2> <font color="#3AC1EF">  debugger</font> </h2><br> , ,     <code>debugger</code> . <br><br>        -.          . <br><br>      : <br><br><ul><li> ,     <code>debugger</code> (with debugger). </li><li> ,      <code>debugger</code> (without debugger). <br></li></ul><br> ‚Üí <a href="">   GitHub</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/174/193/ba5/174193ba594fb14476bb16333749d4de.png"><br><br>    .   V8         <code>debugger</code> . <br><br>      ,      without debugger        V8. <br><br><h2> <font color="#3AC1EF">   :  </font> </h2><br>    ,     ,    V8   .        Node.js,     ,   <a href="http://getpino.io/">Pino</a> . <br><br>     ,       10   (   ‚Äî  )  Node.js 6.11 (Crankshaft). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ff/d9a/c17/8ffd9ac1711f6fba74e03faa9db8193f.png"></div><br>  ‚Äî   ,     V8 6.1 (TurboFan). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/768/715/f86/768715f8643d3b1fcfb174dd6ecca3d2.png"></div><br>   ,        , Winston      JIT- TurboFan. ,         , ,  ,    .      Crankshaft     TurboFan,     ,       Crankshaft,   TurboFan  .  Winston,    , ,  ,      Crankshaft,      TurboFan.    , Pino        Crankshaft.      . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>    ,  ,     V8 5.1, 5.8  5.9,      TurboFan  V8 6.0  6.1.    , ,    ,   ,     ,         . <br><br>           TurboFan (V8 6.0  ).      TurboFan    ,    ,     ,   ¬´  V8¬ª         .        (Chrome)   (Node) . , ,      ,     . ,   .      ,      TurboFan            (,   Winston  Pino). <br><br>   -       JavaScript,    ,      ,         ,    - ,  - .       JS-, ,    V8,     . <br><br>  Dear readers!     JavaScript  ? </div><p>Source: <a href="https://habr.com/ru/post/334806/">https://habr.com/ru/post/334806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334796/index.html">How Android works, part 1</a></li>
<li><a href="../334798/index.html">1C and ETL</a></li>
<li><a href="../334800/index.html">DataGrip 2017.2: Supports Redshift and Azure, several databases in PostgreSQL, transaction control and more</a></li>
<li><a href="../334802/index.html">Music licensing for indie developers</a></li>
<li><a href="../334804/index.html">Finding the best place in the world for a windmill</a></li>
<li><a href="../334810/index.html">Self-orginizing map on TensorFlow</a></li>
<li><a href="../334812/index.html">Rotational Tag Family for Autodesk Revit Downloadable Families</a></li>
<li><a href="../334814/index.html">How the KOMPAS-3D math library turned into a C3D Toolkit for CAD developers ‚Üí part 1</a></li>
<li><a href="../334816/index.html">Voice interface for ordering a car by phone in action</a></li>
<li><a href="../334822/index.html">Case: how to organize multi-channel customer support on the example of a single hosting provider</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>