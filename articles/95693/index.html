<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SCons and Waf build systems overview</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I am a developer and have been using Python for the last couple of years as my main language. However, from time to time there are tasks when you need...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SCons and Waf build systems overview</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/429/683/d29/429683d29947656fa9a27da8cd6250f4.png" alt="image"><br><br>  I am a developer and have been using Python for the last couple of years as my main language.  However, from time to time there are tasks when you need to write in C / C ++.  There are different systems with which you can build such projects.  Classics are make and autotools.  I want to focus on alternatives such as <a href="http://www.scons.org/">SCons</a> and <a href="http://code.google.com/p/waf/">Waf</a> .  The goal of the post is not to prove that they are better or worse than make.  I just want to make a short digression so that it becomes approximately clear what it is, why it is and how to start working with it. <br><br>  To make the conversation substantive, I propose to consider the system in practice.  I decided to use a simple project, which requires typical, but not always trivial assembly tasks.  We will make a simple web-server, the purpose of which is: to produce a static page, which is prepared in a separate html file, but which eventually must be embedded in the executable file.  That is, at the assembly stage, the source code with the C code must be compiled using the html code.  As the server library, we use <a href="http://code.google.com/p/mongoose/">mongoose</a> , the source code of which we put inside the project and we will assemble them into a static library, which later we link to the executable file.  I think the task is clear. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  So why are these two systems chosen for experience?  After all, there are still <a href="http://ru.wikipedia.org/wiki/Rake">Rake</a> , <a href="http://ru.wikipedia.org/wiki/CMake">CMake</a> , Ant / NAnt and others.  The answer is in the first sentence: they are based on Python, and I know and love it well, so the threshold of entry for me should have been rather low.  Let's start ... <br><br><h4>  Training </h4><br><br>  In order for the project to be collected via SCons, it must be installed in the system, and the SConsturct script must be in the project root.  At least in Ubuntu, the SCons package is present in the standard repository and the installation does not present any difficulties: `apt-get install scons`. <br><br>  To build a project through Waf, you need Waf itself, which comes in the form of a single file and is placed directly in the project root.  That is, it is not necessary to install Waf into the system, and users of the code receive a project from the version control system already with ‚Äúbatteries‚Äù.  In addition, you need the assembly script itself, which should be called wscript. <br><br>  The tree of our project looks like this: <br><br> <code>~/devel/stupid-server$ tree <br> . <br> |-- external <br> | `-- mongoose <br> | |-- mongoose.c <br> | `-- mongoose.h <br> |-- html <br> | `-- index.html <br> |-- html2c <br> |-- SConscript <br> |-- SConstruct <br> |-- src <br> | `-- main.cpp <br> |-- waf <br> `-- wscript <br></code> <br><br>  In addition to the above, you can see two more files: html2c and sconscript.  I will tell about them further. <br><br><h4>  Compilation and linking </h4><br><br><h5>  Scons </h5><br><br>  Let's postpone the html conversion for now and build the server.  Let him give an answer for the time being, which is hard-wired in our main.cpp. <br><br>  We need the following: the system must compile mongoose into a static library, then compile src / main.cpp and link it all into one executable file.  In this case, all the artifacts would be nice to put in a separate directory, so that if something happens, it would be possible to delete it without looking back. <br><br>  Let's start with the SCons.  The SConstruct script for this looks like this: <br><br> <code>env = Environment( <br> CPPPATH = 'external/mongoose', <br> CFLAGS = '-O2', <br> ) <br> <br> mongoose = env.StaticLibrary(Glob('external/mongoose/*.c')) <br> env.Program(Glob('src/*.cpp') + [mongoose], LIBS=['dl', 'pthread']) <br></code> <br><br>  Here, the first line we define is Environment - the Centonsbolt of the SCons system, in which we set up the necessary tools.  In our case, we add the include path to mongoose and add a flag to build with optimization.  The next line we <i>define how</i> to collect mongoose.  We say that it is a static library and all .c files in the external / mongoose directory are subject to compilation.  In our case, the file is one, but if there were a lot, Glob would spare the need to list them.  Finally, in the third line, we <i>define how</i> to build the executable file.  We say that it consists of all .cpps in the src directory and a pre-defined mongoose, and in addition it is necessary to link the standard dl and pthread libraries. <br><br>  I put emphasis on what we <i>define</i> exactly <i>how</i> and what to collect.  The build in SCons does not go line by line, as described in the script.  Instead, the system uses declarations and determines the sequence itself, taking into account the dependencies between the goals and the possibility of accelerating the assembly in several streams due to the shuffling of tasks. <br><br>  In general, the description for both systems says that if you know Python, then everything will be simple, because the build scripts are written on it.  In practice, this turns out to be cunning, because syntactically it is Python, but for real work you need a clear understanding of the ideology and scheme of operation of these systems, which comes only after intensive smoking of documentation and often the sources of the systems themselves. <br><br>  Let's go back to the SCons.  Now to build the project we need to dial in the terminal `scons` and voila: the web server is assembled!  However, in the best traditions of make, build artifacts appear directly next to the source code than clutter the structure.  To solve this problem, you will have to create an additional SConscript file to which to transfer the declaration of goals.  And from the main SConstruct it is necessary to say: ‚ÄúCollect this SConscript in this directory‚Äù.  Unfortunately, this is the only way, which however is protected in the documentation as a feature.  Our scripts now look like this: <br><br> <code># SConstruct <br> <br> env = Environment( <br> CPPPATH = 'external/mongoose', <br> CFLAGS = '-O2', <br> ) <br> <br> SConscript('SConscript', variant_dir='build-scons', exports=['env']) <br> <br> # SConscript <br> <br> Import('env') <br> mongoose = env.StaticLibrary(Glob('external/mongoose/*.c')) <br> env.Program(Glob('src/*.cpp') + [mongoose], LIBS=['dl', 'pthread']) <br></code> <br><br>  Now all the guts will be neatly stored in a separate directory build-scons. <br><br>  We left the definition of Environment in the parent file, since this is good practice: there may be many child scripts, and the Environment they will have in common.  The transfer between files is carried out by a plain-curved mechanism: through the exports parameter and the Import construction, respectively. <br><br><h5>  Waf </h5><br><br>  Now the same on the waf: <br><br> <code>top = '.' <br> out = 'build-waf' <br> <br> def set_options(opt): <br> opt.tool_options('compiler_cc') <br> opt.tool_options('compiler_cxx') <br> <br> def configure(conf): <br> conf.check_tool('compiler_cc') <br> conf.check_tool('compiler_cxx') <br> conf.env.append_unique('CCFLAGS', '-O2') <br> conf.env.append_unique('CXXFLAGS', '-O2') <br> <br> def build(bld): <br> bld( <br> target = 'mongoose', <br> features = 'cc cstaticlib', <br> source = bld.path.ant_glob('external/mongoose/**/*.c'), <br> export_incdirs = 'external/mongoose', <br> ) <br> <br> bld( <br> features = 'cxx cprogram', <br> source = bld.path.ant_glob('src/**/*.cpp'), <br> target = 'stupid-server', <br> lib = ['dl', 'pthread'], <br> uselib_local = ['mongoose'], <br> ) <br></code> <br><br>  The first two lines determine what to consider as the root of the project and where to put the artifacts. <br><br>  As you can see, in Waf this is more logical.  Next comes the set_options function.  It is called Waf in order to supplement the existing standard command line parameters with user ones.  In our case, a standard set of parameters is added in order to affect the operation of the C and C ++ compilers. <br><br>  Next comes the configure function.  It is called when we say `./waf configure` and is intended to set all the environment variables and search for all the tools that will then be used when building with the` ./waf build` command.  The division into two stages: configuration and assembly is similar to that used in autotools and serves to accelerate.  For everyday use, configuration is rarely required, and the build is constant.  This saves a significant amount of time.  In our case, in the configuration, we ask you to determine if there are C and C ++ compilers on the machine, remember where they are and then add the optimization flag to their settings. <br><br>  Next comes the build function, which takes as its parameter a certain build context, the centrobolt of the Waf system.  This context can be called as a function, thereby <i>determining how</i> and what to build.  We call it twice: to build mongoose and to build the executable file itself.  In each of the calls, the source code, the name of the target and a set of features are determined.  This kit tells Waf that you need to use tools to turn source into a result.  In the first case, we use the C compiler (cc) and the archiver (cstaticlib), in the second - c ++ - the compiler (cxx) and linker (cprogram).  In addition, for the executable file with the lib argument, we specify the required standard libraries.  And with the help of the uselib_local argument we are talking about linking with our local mongoose. <br><br>  It is very strange that a bunch of crutches like uselib_local are used to link with their own artifacts in Waf instead of allowing adding target objects to the source list, as is done in SCons.  But it is as it is.  On the other hand, a nice advantage is that it includes the path to the mongoose encapsulated in the mongoose target itself, and not announced somewhere at the top level.  Only targets that depend on mongoose will receive this additional path as a directive to the compiler. <br><br>  Now, having such a script, it‚Äôs enough for the build to call `./waf configure build`.  And in consequence, when working on the source code, you can restrict to `./waf build`. <br><br><h4>  Build html </h4><br><br>  I don‚Äôt know any generally accepted ways of getting a C code from html, so I wrote a tiny html2c script that makes it out of this html: <br><br> <code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/1999/xhtml"&gt; <br> &lt;html&gt; <br> &lt;body&gt; <br> &lt;h1&gt;Hello world from stupid server!&lt;/h1&gt; <br> &lt;/body&gt; <br> &lt;/html&gt; <br></code> <br><br>  such .c: <br><br> <code>// Autogenerated by html2c. Think before edit <br> const char htmlString[] = <br> "&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/1999/xhtml\"&gt;\n" <br> "&lt;html&gt;\n" <br> "    &lt;body&gt;\n" <br> "        &lt;h1&gt;Hello world from stupid server!&lt;/h1&gt;\n" <br> "    &lt;/body&gt;\n" <br> "&lt;/html&gt;\n" <br> ; <br></code> <br><br>  To use this line from the main file, use a simple technique: <br><br> <code>extern "C" const char htmlString[]; <br></code> <br><br>  From the point of view of programming, it is not very elegant, but for our purposes it is the most. <br><br><h5>  Scons </h5><br><br>  In order for SCons to understand how to get from strange files of one type of others, it is necessary to define the so-called Builder.  Thus, our Environment will acquire an additional method like StaticLibrary or Program, but which is able to solve our problem: <br><br> <code># SConstruct <br> env['BUILDERS']['Html2c'] = Builder( <br> action = './html2c $SOURCES &gt; $TARGET', <br> src_suffix = '.html', <br> suffix = '.c', <br> ) <br></code> <br><br>  Now we have env.Html2c, which we will use in our SConscript script: <br><br> <code>html_c = env.Html2c('html/index.html') <br> mongoose = env.StaticLibrary(Glob('external/mongoose/*.c')) <br> env.Program(Glob('src/*.cpp') + [html_c, mongoose], LIBS=['dl', 'pthread']) <br></code> <br><br>  The method returns to us the declaration of the target object, which we then intuitively add to the source code of the main program. <br><br><h5>  Waf </h5><br><br>  First, at the configuration stage, we need to find the html2c utility and save the path to it in the environment variable for further use: <br><br> <code>def configure(conf): <br> # ... <br> conf.find_program('html2c', var='HTML2C', mandatory=True, path_list=[conf.srcdir]) <br></code> <br><br>  Then you need to define a new transformation, so-called.  chain, which tells Waf how to get .c from .html: <br><br> <code>import TaskGen <br> TaskGen.declare_chain(name='html2c', rule='${HTML2C} ${SRC} &gt; ${TGT}', ext_in='.html', ext_out='.c', before='cc') <br></code> <br><br>  Here we used the $ {HTML2C} variable, which was previously set in the configuration step. <br><br>  The nice thing is that Waf does not add any magic to imports, as SCons does.  It is always approximately clear where the legs grow from, in this case from the TaskGen module.  Therefore, if necessary, you can always just find the place of interest in the source code of the system. <br><br>  Now that Waf knows how to do the conversion, we can simply add html to the source program's source list: <br><br> <code>def build(bld): <br> #... <br> <br> bld( <br> features = 'cc cxx cprogram', <br> source = bld.path.ant_glob('src/**/*.cpp') + ' html/index.html', <br> # ... <br> ) <br></code> <br><br>  The observant reader might have noticed that for the new transformation we didn‚Äôt add anything to the features.  This is due to the fact that the `TaskGen.declare_chain` mechanism is a simplified, universal, high-level way to extend Waf.  This has a very unpleasant downside: after such a declaration, all the .html that waf sees in the source will be first converted to .c.  That is, even if you wish to upload html via ftp to any server for a separate purpose, the system kindly converts them into .c and it will download them. <br><br>  A complete solution that takes into account the features is surprisingly difficult and requires a deep understanding of Waf.  I decided not to bring him here in order not to put you to sleep. <br><br><h4>  Nice chips </h4><br><br>  Both systems have built-in scanners of C / C ++ source dependencies.  That is, you can forget about the declaration of dependencies on .h files. <br><br>  Both systems have built-in clean-system.  Calling `scons -c` will remove all artifacts, and` ./waf clean` and `./waf distclean` will remove assembly artifacts and configuration step caches files, respectively. <br><br>  Both systems are cross-platform. <br><br><h4>  Scons better than waf </h4><br><br>  SCons has a richer history, has more people in its community, is mentioned in more publications and is used in more projects. <br><br>  The SCons documentation is one level higher than the Waf documentation.  Both systems have e-books, but in the case of Waf, its contents become clear only from the twentieth time. <br><br>  Scons script ideology is usually more understandable and intuitive.  Often, when you are not quite sure how something is being done, you try to do it by analogy and everything turns out.  In Waf for many tasks, you need to search for your crutch and deal with its exclusive interface. <br><br>  In SCons, you can usually do the same thing in one or more similar ways.  The flexibility of Waf, which in some places turns into curvature, makes it possible to achieve something in 1000 ways, but only one of them is ‚Äúcorrect‚Äù, and all the others will come back to glove with further support and work. <br><br><h4>  Waf is better than SCons </h4><br><br>  Waf was created relatively recently by a man who stood at the origins of SCons.  Therefore, it takes into account and avoided the large conceptual failures of SCons, which in large and complex projects affected productivity, ease of maintenance, cross-platform, etc. <br><br>  Waf is much faster than SCons.  I did not check, but it is argued that on a project with several thousand source files with a large number of dependencies, it surpasses SCons 10-15 times.  Thanks to the separate configuration and assembly, as well as a more intelligent system for distributing low-level tasks.  By the way, if we compare it with the usual make, then they go nostril to the nostril: Python is slower, but make loses an advantage due to the recursive spawn of the processes of itself in the subdirectories. <br><br>  The output of Waf to the console is incomparably nicer than the noodles from under SCons and make.  It is colorful and visual, and the errors and warnings are very easy for the eyes. <br><br>  Waf mobile.  The whole system is in a single file less than 100Kb in size directly in the code, and therefore allows you to forget about the need to install yourself on the build machine.  All you need is Python, which is on most Posix systems. <br><br>  Waf allows working with source files that are outside the project root directory.  For example, with libraries installed in the system, but available only in the form of source code.  If a similar problem arises in SCons, it is much easier to go hang yourself. <br><br><h4>  Both are "good" </h4><br><br>  Documentation for both systems is not an example.  Although for both systems there are e-books that allow you to start working, the usual reference / manual is by and large only available to SCons.  And then it represents one huge footcloth, which can only be searched for via Ctrl + F.  When expanding Waf, in complex scenarios, when it comes to the aspect-oriented programming that is widespread in it, you almost certainly have to refer to the source code to find the ends.  In the documentation, as a rule, there is simply no such information. <br><br>  The fact that the build scripts are just Python: a duck.  In both cases.  In view of the specifics, the code is executed not empirically: line by line, but in arbitrary order, as the system decides.  Rather, the code, of course, is executed sequentially, but if it says `build_this_thing`, this does not mean that the build will happen now.  It only means that there is such a thing, and that's how it should be collected if anything happens.  A sort of XML on Python is obtained. <br><br>  The source code of both systems is also not a fountain.  In some places it is written in such a way that if I wrote something similar at work, I would just quit in order to at least somehow make amends to my colleagues.  Although the creators can be understood: their native environment is C / C ++ and they may not know most of the details of the Pythonic culture. <br><br><h4>  Material </h4><br><br>  All files of the project, disassembled in this post are available in the repository <a href="http://bitbucket.org/nailxx/stupid-server/src">on BitBucket</a> . </div><p>Source: <a href="https://habr.com/ru/post/95693/">https://habr.com/ru/post/95693/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../95687/index.html">Pitfalls of choosing a data center</a></li>
<li><a href="../95688/index.html">Violin</a></li>
<li><a href="../95689/index.html">Web studios, do not climb into a black hole. There is no money</a></li>
<li><a href="../95691/index.html">"Portal 2 E3 Surprise" = HL Episode 3?</a></li>
<li><a href="../95692/index.html">Worldwide Developers Conference 2010</a></li>
<li><a href="../95695/index.html">eBay without problems</a></li>
<li><a href="../95697/index.html">1C-Bitrix: Site Management 5.0 ASP.NET - Evolution</a></li>
<li><a href="../95698/index.html">Chinese touchscreen phone for 70 USD - what to expect?</a></li>
<li><a href="../95699/index.html">Infographics. Close-up</a></li>
<li><a href="../95701/index.html">Not from this galaxy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>