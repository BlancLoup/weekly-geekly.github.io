<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Arrange chaos</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As practice shows, a huge part of the problems arises not because of the decisions themselves, but because of how communication takes place between th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Arrange chaos</h1><div class="post__text post__text-html js-mediator-article"><p>  As practice shows, a huge part of the problems arises not because of the decisions themselves, but because of how communication takes place between the components of the system.  If there is a mess in the communication between the components of the system, then how not to try to write separate components well, the system as a whole will fail. </p><br><p>  Caution!  Inside the bike. </p><a name="habracut"></a><br><h1 id="problematika-ili-postanovka-zadachi">  Problematics or problem statement </h1><br><p>  Some time ago it happened to work on a project for a company that brings to the masses such charms as CRM, ERM systems and derivatives.  Moreover, the company produced a rather comprehensive product from software for cash registers to a call-center with the possibility of leasing operators in the amount of up to 200 souls. </p><br><p>  I myself worked on the front-end application for the call-center. </p><br><p>  It is easy to imagine that it is in the operator‚Äôs application that information from all system components flows.  And if we take into account the fact that the operator and the administrator are not the only operator, but also the manager and the administrator, then you can imagine how many communications and information the application should ‚Äúdigest‚Äù and connect with each other. </p><br><p>  When the project was already launched and even worked quite stably, the problem of system transparency arose to its full height. </p><br><p>  Here is the point.  There are many components and they all work with their data sources.  But almost all of these components in their time were written as independent products.  That is, not as an element of the overall system, but as separate solutions for sale.  As a result, there is no single (system) API and no common standards of communication between them. </p><br><p>  I will explain.  Some component sends JSON, ‚Äúsomeone‚Äù sends lines with key: value inside, ‚Äúsomeone‚Äù sends binary at all and do what you want with it.  But, and the final application for the call-center should have been this all to receive and somehow handle.  And most importantly, there was no link in the system that could recognize that the format / structure of the data had changed.  If a component sent JSON yesterday, and today decided to send a binary, no one will see it.  Only the final application will start to fail as expected. </p><br><p>  It soon became clear (for others, not for me, since I spoke about the problem at the design stage) that the lack of a ‚Äúsingle language of communication‚Äù between the components leads to serious problems. </p><br><p>  The easiest case is when a client has asked to change some dataset.  The task is written off by a young man that ‚Äúholds‚Äù a component for working with databases of goods / services for example.  He does his work, the new dataset introduces and he, an asshole, everything works.  But, the day after the update ... oh ... the application in the call-center suddenly starts to work not as expected of it. </p><br><p>  You probably already guessed.  Our hero has changed not only the dataset, but also the data structure that its component sends to the system.  As a result, the application for the call-center is simply not able to work more with this component, and there other dependencies are flying along the chain. </p><br><p>  We began to think about what we actually want to get at the exit.  As a result, they formulated the following requirements for a potential solution: </p><br><p>  <strong>First</strong> and foremost: any change to the data structure should immediately be displayed in the system.  If someone, somewhere has made changes and these changes are incompatible with what the system expects - the error should occur at the stage of the component tests that was changed. </p><br><p>  <strong>The second</strong> .  Data types should be checked not only at compile time, but also run-time. </p><br><p>  <strong>Third</strong> .  Since a large number of people work on components with a completely different skill level, the description ‚Äúlanguage‚Äù should be simpler. </p><br><p>  <strong>Fourth</strong> .  Whatever the solution, it should be as comfortable as possible to work with it.  If possible, the IDE should highlight as much as possible. </p><br><p>  The first thought was to implement protobuf.  Simple, readable and easy.  Strong data typing.  It seems to be what the doctor ordered.  But, alas, not all protobuf syntax seemed simple.  In addition, even the compiled protocol required an additional library, but Javascript was not supported by the authors of protobuf and was the result of the work of the community.  In general, they refused. </p><br><p>  Then there was an idea to describe the protocol in JSON.  How much easier? </p><br><p>  Well, then I quit.  And on this this post could have been completed, since after my departure, no one further dealt with the problem of particularly close engagement. </p><br><p>  However, taking into account a couple of personal projects, where the question of communication between the components again rose to its full height, I decided to start implementing the idea myself.  What are we talking about and below. </p><br><p>  So, I present to your attention the <a href="https://github.com/DmitryAstafyev/ceres">ceres</a> project, which includes: </p><br><ul><li>  protocol generator </li><li>  provider </li><li>  customer </li><li>  implementation of transports </li></ul><br><h1 id="protokol">  Protocol </h1><br><p>  The task was to do so: </p><br><ul><li>  it was easy to set the message structure in the system. </li><li>  it was easy to determine the data type of all message fields. </li><li>  it was possible to define auxiliary entities and refer to them. </li><li>  and of course, that all this is highlighted IDE </li></ul><br><p>  I think that in a completely natural way, not pure Javascript was chosen as the language into which the protocol was converted, but Typescript.  So all that the protocol generator does is turn JSON into Typescript. </p><br><p>  To describe the messages available in the system, you just need to know what JSON is.  With which, I am sure, no one has any problems. </p><br><p>  Instead of Hello World, I offer an equally hackneyed example - chat. </p><br><pre><code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"Events"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"NewMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"ChatMessage"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"UsersListUpdated"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Requests"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"GetUsers"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"AddUser"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"User"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"Responses"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"UsersList"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"users"</span></span>: <span class="hljs-string"><span class="hljs-string">"Array&lt;User&gt;"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"AddUserResult"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"error?"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"ChatMessage"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"utf8String"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"created"</span></span>: <span class="hljs-string"><span class="hljs-string">"datetime"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"User"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p>  Everything is so ugly.  We have a couple of NewMessage and UsersListUpdated events;  as well as a couple of UsersList and AddUserResult requests.  There are two other entities: ChatMessage and User. </p><br><p>  As you can see the description is quite transparent and understandable.  A little about the rules. </p><br><ul><li>  The object in JSON will become a class in the generated protocol. </li><li>  The value of the property is the definition of a data type or a reference to a class (entity). </li><li>  Nested objects from the point of view of the generated protocol will become ‚Äúnested‚Äù classes, that is, nested objects will inherit all the properties of their parents. </li></ul><br><p>  Now you just need to generate a protocol to start using it. </p><br><pre> <code class="bash hljs">npm install ceres.protocol -g ceres.protocol -s chat.protocol.json -o chat.protocol.ts -r</code> </pre> <br><p>  As a result, we get the protocol generated on Typescript.  We connect and use: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/c1b/826/96a/c1b82696aecdf2ccc5b5ededd9e7818b.gif" alt="image"><br><p>  So, the protocol already gives something to the developer: </p><br><ul><li>  IDE highlights what we have in the protocol.  Also IDE highlights all expected properties. </li><li>  Typescript, which will certainly tell us if something is wrong with the data types.  Of course, this is done at the development stage, but the protocol itself at run-time will check the data types and throw an exception if a violation is detected </li><li>  In general, you can forget about validation.  The protocol will do all the necessary checks. </li><li>  The generated protocol does not require any additional libraries.  Everything he needs for work, he already contains.  And it is very convenient. </li></ul><br><blockquote>  Yes, the size of the generated protocol can surprise you, to put it mildly.  But, do not forget about the minification, to which the generated protocol file lends itself well. </blockquote><p>  Now we can "pack" the message and send </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> packet: <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span> = message.stringify(); <span class="hljs-comment"><span class="hljs-comment">// Send packet somewhere</span></span></code> </pre> <br><p>  It is important to make a reservation, the packet will be an array of bytes, which is very good and correct in terms of traffic load, since sending the same JSON is "worth", of course, more expensive.  However, the protocol has one chip - in debug mode, it will generate readable JSON, so that the developer can ‚Äúlook‚Äù at the traffic and see what happens. </p><br><p>  This is done directly in run-time. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Protocol.ChatMessage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.ChatMessage({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'noname'</span></span>, <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello World!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">created</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() }); <span class="hljs-comment"><span class="hljs-comment">// Switch to debug mode Protocol.Protocol.state.debug(true); // Now packet will be present as JSON string const packet: string = message.stringify(); // Send packet somewhere</span></span></code> </pre> <br><p>  On the server (or any other recipient), we can easily unpack the message: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> smth = Protocol.parse(packet); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smth <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Oops. Something wrong with this packet. } if (Protocol.ChatMessage.instanceOf(smth) === true) { // This is chat message }</span></span></code> </pre> <br><p>  The protocol supports all major data types: </p><br><table><thead><tr><th>  Type of </th><th>  Meanings </th><th>  Description </th><th>  Size, byte </th></tr></thead><tbody><tr><td>  utf8String </td><td></td><td>  UTF8 encoded string </td><td>  x </td></tr><tr><td>  asciiString </td><td></td><td>  ascii string </td><td>  1 character - 1 byte </td></tr><tr><td>  int8 </td><td>  -128 to 127 </td><td></td><td>  one </td></tr><tr><td>  int16 </td><td>  -32768 to 32767 </td><td></td><td>  2 </td></tr><tr><td>  int32 </td><td>  -2147483648 to 2147483647 </td><td></td><td>  four </td></tr><tr><td>  uint8 </td><td>  0 to 255 </td><td></td><td>  one </td></tr><tr><td>  uint16 </td><td>  0 to 65535 </td><td></td><td>  2 </td></tr><tr><td>  uint32 </td><td>  0 to 4294967295 </td><td></td><td>  four </td></tr><tr><td>  float32 </td><td>  1.2x10 <sup>-38</sup> to 3.4x10 <sup>38</sup> </td><td></td><td>  four </td></tr><tr><td>  float64 </td><td>  5.0x10 <sup>-324</sup> to 1.8x10 <sup>308</sup> </td><td></td><td>  eight </td></tr><tr><td>  boolean </td><td></td><td></td><td>  one </td></tr></tbody></table><br><p>  Within the protocol, these data types are called primitive.  However, another feature of the protocol is that it allows you to add your own data types (which are called "additional data types"). </p><br><p>  For example, you probably already noticed that <strong>ChatMessage</strong> has a <strong>created</strong> field with a <strong>datetime</strong> data type.  At the application level, this type corresponds to <strong>Date</strong> , and inside the protocol is stored (and forwarded) as <strong>uint32</strong> . </p><br><p>  Adding your type to the protocol is quite simple.  For example, if we want to have an <strong>email</strong> data type, say for the following message in the protocol: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"User"</span></span>: { <span class="hljs-string"><span class="hljs-string">"nickname"</span></span>: <span class="hljs-string"><span class="hljs-string">"asciiString"</span></span>, <span class="hljs-string"><span class="hljs-string">"address"</span></span>: <span class="hljs-string"><span class="hljs-string">"email"</span></span> }, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.0.1"</span></span> }</code> </pre> <br><p>  All you need is to write a definition for the email type. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AdvancedTypes: { [key:string]: any} = { <span class="hljs-attr"><span class="hljs-attr">email</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// Binary type or primitive type binaryType : 'asciiString', // Initialization value. This value is used as default value init : '""', // Parse value. We should not do any extra decode operations with it parse : (value: string) =&gt; { return value; }, // Also we should not do any encoding operations with it serialize : (value: string) =&gt; { return value; }, // Typescript type tsType : 'string', // Validation function to valid value validate : (value: string) =&gt; { if (typeof value !== 'string'){ return false; } if (value.trim() === '') { // Initialization value is "''", so we allow use empty string. return true; } const validationRegExp = /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/gi; return validationRegExp.test(value); }, } };</span></span></code> </pre> <br><p>  That's all.  By generating a protocol, we will get support for a new <strong>email</strong> data type.  If we try to create an entity with the wrong address, we will get an error </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user: Protocol.User = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.User({ <span class="hljs-attr"><span class="hljs-attr">nickname</span></span>: <span class="hljs-string"><span class="hljs-string">'Brad'</span></span>, <span class="hljs-attr"><span class="hljs-attr">email</span></span>: <span class="hljs-string"><span class="hljs-string">'not_valid_email'</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(user);</code> </pre> <br><p>  Oh... </p><br><pre> <code class="bash hljs">Error: Cannot create class of <span class="hljs-string"><span class="hljs-string">"User"</span></span> due error(s): - Property <span class="hljs-string"><span class="hljs-string">"email"</span></span> has wrong value; validation was failed with value <span class="hljs-string"><span class="hljs-string">"not_valid_email"</span></span>.</code> </pre> <br><p>  So, the protocol simply does not allow "bad" data into the system. </p><br><p>  Note that when defining a new data type, we specified a couple of key properties: </p><br><ul><li>  <strong>binaryType</strong> is a reference to the primitive data type to be used for storing, encoding / decoding data.  In this case, we indicate that the address is an ascii string. </li><li>  <strong>tsType</strong> is a reference to the Javascript type, that is, how the data type should be represented in the Javascript environment.  In this case, we are talking about <strong>string.</strong> </li><li>  It is also worth noting that we only need to define the new data type at the time of generating the protocol.  At the output, we get a generated protocol that already contains a new data type. </li></ul><br><blockquote>  Detailed information on all protocol capabilities you can see here <a href="https://github.com/DmitryAstafyev/ceres.protocol">ceres.protocol</a> . </blockquote><br><h1 id="provayder-i-klient">  Provider and client </h1><br><p>  By and large, the protocol itself can be used to organize communication.  However, if we are talking about the browser and nodejs, then the provider and the client are available. </p><br><h2 id="klient">  Customer </h2><br><h3 id="sozdanie">  Creature </h3><br><p>  To create a client, you need the client itself and the transport. </p><br><p>  Installation </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install consumer (client) npm install ceres.consumer --save # Install transport npm install ceres.consumer.browser.ws --save</span></span></code> </pre> <br><p>  Creature </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport);</span></span></code> </pre> <br><blockquote>  The client, as well as the provider, are designed specifically for the protocol.  That is, they will work only with the protocol (ceres.protocol). </blockquote><br><h3 id="sobytiya">  Developments </h3><br><p>  After the client is created, the developer can subscribe to events. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Protocol <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../protocol/protocol.chat'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer.browser.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Consumer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.consumer'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ host: 'http://localhost', port: 3005, wsHost: 'ws://localhost', wsPort: 3005, })); // Create consumer const consumer: Consumer = new Consumer(transport); // Subscribe to event consumer.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); }).then(() =&gt; { console.log('Subscription to "NewMessage" is done'); }).catch((error: Error) =&gt; { console.log(`Fail to subscribe to "NewMessage" due error: ${error.message}`); });</span></span></code> </pre> <br><p>  Note that the client will call an event handler, only if these messages are completely correct.  In other words, our application is insured against incorrect data and the <strong>NewMessage</strong> event handler will always be called with an instance of <strong>Protocol.Events.NewMessage</strong> as an argument. </p><br><p>  Naturally, the client can generate events. </p><br><pre> <code class="javascript hljs">consumer.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> })).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p>  Notice, we do not specify event names anywhere, we simply use either a reference to a class from the protocol, or we transmit its instance. </p><br><p>  We can also send a message to a limited group of recipients, specifying a simple object of the type <code>{ [key: string]: string }</code> as the second argument.  Within ceres, this object is called <strong>query</strong> . </p><br><pre> <code class="javascript hljs">consumer.emit( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This is new message'</span></span> }), { <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> } ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`New message was sent`</span></span>); }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error: </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">Error</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Fail to send message due error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error.message}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre> <br><p>  Thus, by additionally specifying <code>{ location: "UK" }</code> , we can be sure that only those customers who have defined their position as UK will receive this message. </p><br><p>  To associate the client with a specific <strong>query</strong> , you just need to call the <strong>ref</strong> method: </p><br><pre> <code class="javascript hljs">consumer.ref({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">'12345678'</span></span>, <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">'UK'</span></span> }).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Client successfully bound with query`</span></span>); });</code> </pre> <br><p>  After we have connected the client with the <strong>query</strong> , he has the opportunity to receive "personal" or "group" messages. </p><br><h3 id="zaprosy">  Requests </h3><br><p>  We can also make requests </p><br><pre> <code class="javascript hljs">consumer.request( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Requests.GetUsers(), <span class="hljs-comment"><span class="hljs-comment">// Request Protocol.Responses.UsersList // Expected response ).then((response: Protocol.Responses.UsersList) =&gt; { console.log(`Available users: ${response.users}`); }).catch((error: Error) =&gt; { console.log(`Fail to get users list due error: ${error.message}`); });</span></span></code> </pre> <br><p>  Here it is worth noting that as the second argument we specify the expected result ( <strong>Protocol.Responses.UsersList</strong> ), which means our request will be successfully completed only if the answer is an instance of <strong>UsersList</strong> , in all other cases we will ‚Äúfall‚Äù into catch  Again, this insures us against the processing of incorrect data. </p><br><p>  The client himself can act and those who can process requests.  To do this, you only need to "identify" yourself as the "responsible" for the request. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; consumer.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers, { location: "UK" }).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p>  Note, optionally, as the third argument, we can specify a <strong>query</strong> object that can be used to identify the client.  Thus, if someone sends a query with a <strong>query</strong> , say, <code>{ location: "RU" }</code> , then our client will not receive such a query, since its query <code>{ location: "UK" }</code> . </p><br><p>  The <strong>query</strong> can include an unlimited number of properties.  For example, you can specify the following </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><p>  Then, in addition to the complete match <strong>query,</strong> we also successfully process the following queries: </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">location</span></span>: <span class="hljs-string"><span class="hljs-string">"UK"</span></span> }</code> </pre> <br><p>  or </p><br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"managers"</span></span> }</code> </pre> <br><h2 id="provayder">  Provider </h2><br><h3 id="sozdanie-1">  Creature </h3><br><p>  To create a provider (as well as create a client), the provider and the transport are needed. </p><br><p>  Installation </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Install provider npm install ceres.provider --save # Install transport npm install ceres.provider.node.ws --save</span></span></code> </pre> <br><p>  Creature </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Transport, { ConnectionParameters } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider.node.ws'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Provider <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ceres.provider'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create transport const transport:Transport = new Transport(new ConnectionParameters({ port: 3005 })); // Create provider const provider: Provider = new Provider(transport);</span></span></code> </pre> <br><p>  From the moment the provider is created, it can accept connections from clients. </p><br><h3 id="sobytiya-1">  Developments </h3><br><p>  As well as the client, the provider can "listen" to messages and generate them. </p><br><p>  Listen </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Subscribe to event provider.subscribe(Protocol.Events.NewMessage, (message: Protocol.Events.NewMessage) =&gt; { console.log(`New message came: ${message.message}`); });</span></span></code> </pre> <br><p>  We generate </p><br><pre> <code class="javascript hljs">provider.emit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Protocol.Events.NewMessage({ <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">'This message from provider'</span></span> }));</code> </pre> <br><h3 id="zaprosy-1">  Requests </h3><br><p>  Naturally, the provider can (and should) "listen" requests </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRequestGetUsers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">request: Protocol.Requests.GetUsers, clientID: string, callback: (error: Error | null, results : any </span></span></span><span class="hljs-function">) =&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Request from client </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${clientId}</span></span></span><span class="hljs-string"> was gotten.`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Get user list somehow const users: Protocol.User[] = []; // Prepare response const response = new Protocol.Responses.UsersList({ users: users }); // Send response callback(null, response); // Or send error // callback(new Error(`Something is wrong`)) }; provider.listenRequest(Protocol.Requests.GetUsers, processRequestGetUsers).then(() =&gt; { console.log(`Consumer starts listen request "GetUsers"`); });</span></span></code> </pre> <br><p>  Here there is only one difference from the client, the provider in addition to the request body will receive a unique <strong>clientId</strong> , which is automatically assigned to all connected clients. </p><br><h1 id="primer">  Example </h1><br><p>  In fact, I really do not want to bore you with excerpts from the documentation, I am sure it will be easier and more interesting for you to just see a short piece of code. </p><br><p>  Sample chat you can easily install by downloading the <a href="">source</a> and making a couple of simple steps </p><br><p>  Install and run the client </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/client npm install npm start</code> </pre> <br><p>  The client will be available at <a href="http://localhost:3000/">http: // localhost: 3000</a> .  Open at once a couple of tabs with the client to see the "communication". </p><br><p>  Installation and start of the provider (server) </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm install ts-node ./server.ts</code> </pre> <br><p>  The <strong>ts-node</strong> package is <strong>surely</strong> familiar to you, but if not, then it allows you to run TS files.  If you don‚Äôt want to install, just compile the server and then run the JS file. </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> chat/server npm run build node ./build/server/server.js</code> </pre> <br><h1 id="sho-opyat">  Shaw?  Again?! </h1><br><p>  Anticipating questions about why the hell to reinvent the next bike, because there are so many solutions already worked out, starting from protobuf and ending with hardcore joynr from BMW, I can only say that it was interesting to me.  The whole project was done solely on personal initiative, without any support, in his spare time. </p><br><p>  That is why your feedback is of <strong>particular value</strong> to me.  In an attempt to somehow motivate you, I can promise that for every star on the github, I will stroke the hamster (which I don‚Äôt like to say the least).  For fork, ufff, I'll scratch his tum to him ... brrrr. </p><br><p>  <em>Hamster is not mine, son of a hamster</em> . </p><br><p>  In addition, in a couple of weeks the project will go to testing to my former colleagues (which I mentioned at the beginning of the post and who were interested in what the alfa version turned out).  The goal is to debug and run on several components.  I really hope that it will work. </p><br><h1 id="ssylki-i-pakety">  Links and Packages </h1><br><p>  The project lodges on two repositories. </p><br><ul><li>  <a href="https://github.com/DmitryAstafyev/ceres">ceres</a> sources: ceres.provider, ceres.consumer and all transports available today. </li><li>  <a href="https://github.com/DmitryAstafyev/ceres.protocol">ceres.protocol</a> protocol generator source </li></ul><br><p>  NPM the following packages are available </p><br><ul><li>  <a href="https://www.npmjs.com/package/ceres.protocol">ceres.protocol</a> protocol generator </li><li>  <a href="https://www.npmjs.com/package/ceres.provider">ceres.provider</a> provider </li><li>  <a href="https://www.npmjs.com/package/ceres.consumer">ceres.consumer</a> client </li><li>  <a href="https://www.npmjs.com/package/ceres.provider.node.longpoll">ceres.provider.node.longpoll</a> transport for long polling based provider </li><li>  <a href="">ceres.provider.node.ws</a> transport for a provider based on a web socket </li><li>  <a href="https://www.npmjs.com/package/ceres.consumer.browser.longpoll">ceres.consumer.browser.longpoll</a> transport for a client based on long polling </li><li>  <a href="">ceres.consumer.browser.ws</a> transport for Web Socket-based client </li></ul><br><p>  Good and light. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/442380/">https://habr.com/ru/post/442380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442364/index.html">Overview of the base DECT station Snom M300 and M215 kit</a></li>
<li><a href="../442366/index.html">What are the features and objectives of sound games</a></li>
<li><a href="../442372/index.html">Reliable programming in the context of languages. Part 2 - Challengers</a></li>
<li><a href="../442376/index.html">The density of the plot in retail</a></li>
<li><a href="../442378/index.html">One click in the interface of Booking com can ruin a vacation or why a working rating system is important.</a></li>
<li><a href="../442384/index.html">Expanding the functionality of the standard audio system</a></li>
<li><a href="../442386/index.html">Thymeleaf: Layout + Spring Boot 2 Dialect</a></li>
<li><a href="../442396/index.html">Digital events in Moscow from March 4 to March 10</a></li>
<li><a href="../442402/index.html">Mattermost. Integration with external services</a></li>
<li><a href="../442404/index.html">Mattermost. Integration with external services (part 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>