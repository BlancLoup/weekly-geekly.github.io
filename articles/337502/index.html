<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL Indexes - 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have already reviewed the PostgreSQL indexing mechanism , the access methods interface, and three methods: hash index , B-tree, and GiST . In this ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL Indexes - 6</h1><div class="post__text post__text-html js-mediator-article"><br>  We have already reviewed <a href="https://habrahabr.ru/company/postgrespro/blog/326096/">the PostgreSQL indexing mechanism</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">the access methods interface,</a> and three methods: <a href="https://habrahabr.ru/company/postgrespro/blog/328280/">hash index</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/330544/">B-tree,</a> and <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">GiST</a> .  In this part, we will focus on the SP-GiST. <br><br><h1>  SP-GiST </h1><br>  First, a little about the title.  The word "GiST" hints at a certain similarity with the method of the same name.  The similarity is really there: both are generalized search trees, generalized search trees that provide a framework for building different access methods. <br><br>  "SP" stands for space partitioning, a partition of space.  The role of <em>space is</em> often exactly what we used to call space - for example, a two-dimensional plane.  But, as we will see, any <em>search space</em> is meant <em>,</em> in fact, an arbitrary range of values. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      SP-GiST is suitable for structures in which the space is recursively divided into <em>disjoint</em> regions.  This class includes quadtree trees, k-dimensional trees (kD tree), prefix trees (trie). <br><br><a name="habracut"></a><br><h2>  Device </h2><br>  So, the idea of ‚Äã‚Äãthe SP-GiST index method is to split a range of values ‚Äã‚Äãinto <em>non-overlapping</em> subregions, each of which, in turn, can also be split.  Such a partition generates <em>unbalanced</em> trees (as opposed to B-trees and regular GiST). <br><br>  The non-intersection property simplifies decision making when inserting and searching.  On the other hand, the resulting trees, as a rule, are weakly branchy.  For example, a quad tree node usually has four child nodes (as opposed to B-trees, where they are measured in hundreds) and greater depth.  Such trees are well suited for working in RAM, but the index is stored on disk, and therefore, to reduce the number of I / O operations, nodes have to be packed into pages ‚Äî and this is not easy to do effectively.  In addition, the search time for different values ‚Äã‚Äãin the index may differ due to the different depth of the branches. <br><br>  Like GiST, this access method takes care of low-level tasks (simultaneous access and locking, logging, the search algorithm itself) and allows you to add support for new data types and partitioning algorithms, providing a special simplified interface for this. <br><br>  The internal node of the SP-GiST tree stores references to child nodes;  A <em>label</em> can be set for each link <em>.</em>  In addition, the internal node can store a value called a <em>prefix.</em>  In fact, this value does not have to be a prefix;  it can be considered as an arbitrary predicate that runs for all child nodes. <br><br>  SP-GiST leaf nodes contain the value of the indexed type and a link to the table row (TID).  As the value, the indexed data itself can be used (search key), but not necessarily: the reduced value can also be stored. <br><br>  In addition, leaf nodes can be listed.  Thus, the internal node can refer not to a single value, but to the whole list. <br><br>  Note that the prefixes, labels and values ‚Äã‚Äãin the leaf nodes can all be of completely different data types. <br><br>  As in GiST, the main function to be defined for the search is <em>the consistency function.</em>  This function is called for a tree node and returns a set of child nodes, the values ‚Äã‚Äãof which are ‚Äúconsistent‚Äù with the search predicate (as usual, of the form ‚Äú <em>indexed-field operator expression</em> ‚Äù).  For a leaf node, the consistency function determines whether the indexed value in this node satisfies the search predicate. <br><br>  The search begins at the root node.  With the help of the consistency function, it becomes clear which subsidiaries it makes sense to enter;  the algorithm is repeated for each of the found nodes.  Search is made in depth. <br><br>  At the physical level, index nodes are packed into pages so that they can be efficiently handled in terms of I / O operations.  At the same time on the same page are either internal nodes, or leaf, but not both of them simultaneously. <br><br><h2>  Example: quad tree </h2><br>  A quadtree tree is used to index points on a plane.  The idea is to recursively divide a region into four parts (quadrants) with respect to the <em>central point.</em>  The depth of the branches of such a tree can vary and depends on the density of points in the corresponding quadrants. <br><br>  Here is how it looks in the pictures on the example of a <a href="https://postgrespro.ru/education/demodb">demo database</a> , supplemented by airports from the site <a href="https://openflights.org/data.html">openflights.org</a> .  By the way, we recently released a new version of the database, in which, among other things, we replaced longitude and latitude with a single field of type point. <br><br><img src="https://habrastorage.org/web/8ab/6f6/4e7/8ab6f64e7bb5484bbfc798327798ce69.png"><br>  <em>First we divide the plane into four quadrants ...</em> <br><br><img src="https://habrastorage.org/web/6b5/ce5/3e1/6b5ce53e1b57499cad2a61a86a451835.png"><br>  <em>Then divide each of the quadrants ...</em> <br><br><img src="https://habrastorage.org/web/ba5/e5d/10a/ba5e5d10a47844a2bc95e5505641e798.png"><br>  <em>And so on, until we get the final split.</em> <br><br>  Let us now consider in more detail a simple example that we have already met <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">in the part about GiST</a> .  Here‚Äôs what a plane partition might look like in this case: <br><br><img src="https://habrastorage.org/web/a98/6f1/065/a986f106505b4b0fa0b03005a2c657f3.png"><br><br>  Quadrants are numbered as shown in the first figure;  for definiteness, we will place the child nodes from left to right in exactly this sequence.  A possible index structure in this case is shown in the figure below.  Each internal node refers to a maximum of four child nodes.  Each link can be <em>labeled</em> with a quadrant number, as shown.  But there is no label implementation;  it is more convenient to store a fixed array of four references, some of which may be empty. <br><br><img src="https://habrastorage.org/web/24c/3cf/97f/24c3cf97f59b4f99acb2aa992d1825d6.png"><br><br>  The points lying on the borders belong to the quadrant with a smaller number. <br><br> <code>postgres=# create table points(p point); <br> CREATE TABLE <br> <br> postgres=# insert into points(p) values <br> (point '(1,1)'), (point '(3,2)'), (point '(6,3)'), <br> (point '(5,5)'), (point '(7,8)'), (point '(8,6)'); <br> INSERT 0 6 <br> <br> postgres=# create index points_quad_idx on points using spgist(p); <br> CREATE INDEX <br></code> <br>  In this case, the default operator class is quad_point_ops, which includes the following operators: <br><br> <code>postgres=# select amop.amopopr::regoperator, amop.amopstrategy <br> from pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <br> where opc.opcname = 'quad_point_ops' <br> and opf.oid = opc.opcfamily <br> and am.oid = opf.opfmethod <br> and amop.amopfamily = opc.opcfamily <br> and am.amname = 'spgist' <br> and amop.amoplefttype = opc.opcintype; <br> amopopr    | amopstrategy <br> -----------------+-------------- <br> &lt;&lt;(point,point) |            1    <br> &gt;&gt;(point,point) |            5    <br> ~=(point,point) |            6   <br> &lt;^(point,point) |          10    <br> &gt;^(point,point) |          11    <br> &lt;@(point,box)  |            8     <br> (6 rows) <br></code> <br>  Consider, for example, how the query <code>select * from points where p &gt;^ point '(2,7)'</code> will be executed (find all the points above the given one). <br><br><img src="https://habrastorage.org/web/5f3/194/855/5f3194855fe74166b56c1703f4bb9b07.png"><br><br>  We start with the root node and choose which child nodes to descend using the consistency function.  For the <code>&gt;^</code> operator <code>&gt;^</code> this function compares the point (2.7) with the central point of the node (4.4) and selects the quadrants at which the desired points may be located - in this case, the first and the fourth. <br><br>  In the node corresponding to the first quadrant, we again determine the child nodes using the consistency function.  The central point (6,6), and we again need to look through the first and fourth quadrants. <br><br><img src="https://habrastorage.org/web/8ac/99b/d9e/8ac99bd9e7b94f8d9683307b98ad1875.png"><br><br>  The first quadrant corresponds to the list of leaf nodes (8.6) and (7.8), of which only the point (7.8) fits the query condition.  The reference to the fourth quadrant is empty. <br><br>  At the internal node (4.4), the reference to the fourth quadrant is also empty, and the search is complete. <br><br> <code>postgres=# set enable_seqscan = off; <br> SET <br> postgres=# explain (costs off) select * from points where p &gt;^ point '(2,7)'; <br> QUERY PLAN <br> ------------------------------------------------ <br> Index Only Scan using points_quad_idx on points <br> Index Cond: (p &gt;^ '(2,7)'::point) <br> (2 rows) <br></code> <br><h3>  Inside </h3><br>  The internal structure of the SP-GiST indexes can be studied using the <a href="http://www.sai.msu.su/~megera/wiki/Gevel">gevel</a> extension, which we have already talked about earlier.  The bad news: due to an error, the extension does not work correctly on modern versions of PostgreSQL.  Good news: we are planning to transfer the gevel functionality to pageinspect ( <a href="">discussion</a> ).  And the error is already fixed there. <br><br>  For example, take the extended demo database, which was used to draw pictures with a map of the world. <br><br> <code>demo=# create index airports_coordinates_quad_idx on airports_ml using spgist(coordinates); <br> CREATE INDEX <br></code> <br>  About the index, you can, firstly, find out some statistical information: <br><br> <code>demo=# select * from spgist_stats('airports_coordinates_quad_idx'); <br> spgist_stats <br> ---------------------------------- <br> totalPages:        33          + <br> deletedPages:      0            + <br> innerPages:        3            + <br> leafPages:        30          + <br> emptyPages:        2            + <br> usedSpace:        201.53 kbytes+ <br> usedInnerSpace:    2.17 kbytes  + <br> usedLeafSpace:    199.36 kbytes+ <br> freeSpace:        61.44 kbytes + <br> fillRatio:        76.64%      + <br> leafTuples:        5993        + <br> innerTuples:      37          + <br> innerAllTheSame:  0            + <br> leafPlaceholders:  725          + <br> innerPlaceholders: 0            + <br> leafRedirects:    0            + <br> innerRedirects:    0 <br> (1 row) <br></code> <br>  And second, output the index tree itself: <br><br> <code>demo=# select tid, n, level, tid_ptr, prefix, leaf_value <br> from spgist_print('airports_coordinates_quad_idx') as t( <br> tid tid, <br> allthesame bool, <br> n int, <br> level int, <br> tid_ptr tid, <br> prefix point,    --   <br> node_label int,  --   (    ) <br> leaf_value point --    <br> ) <br> order by tid, n; <br> tid  | n | level | tid_ptr |      prefix      |    leaf_value <br> ---------+---+-------+---------+------------------+------------------ <br> (1,1)  | 0 |    1 | (5,3)  | (-10.220,53.588) | <br> (1,1)  | 1 |    1 | (5,2)  | (-10.220,53.588) | <br> (1,1)  | 2 |    1 | (5,1)  | (-10.220,53.588) | <br> (1,1)  | 3 |    1 | (5,14)  | (-10.220,53.588) | <br> (3,68)  |  |    3 |        |                  | (86.107,55.270) <br> (3,70)  |  |    3 |        |                  | (129.771,62.093) <br> (3,85)  |  |    4 |        |                  | (57.684,-20.430) <br> (3,122) |  |    4 |        |                  | (107.438,51.808) <br> (3,154) |  |    3 |        |                  | (-51.678,64.191) <br> (5,1)  | 0 |    2 | (24,27) | (-88.680,48.638) | <br> (5,1)  | 1 |    2 | (5,7)  | (-88.680,48.638) | <br> ... <br></code> <br>  But keep in mind.  that the spgist_print function does not display all leaf values, but only the first one from the list, and therefore shows the structure of the index, and not its full content. <br><br><h2>  Example: k-dimensional trees </h2><br>  For the same points on the plane, we can offer another way of splitting the space. <br><br>  Let's draw a <em>horizontal line</em> through the first point to be indexed <em>.</em>  It breaks the plane into two parts: upper and lower.  The second index point falls into one of these parts.  Through it we draw a <em>vertical line</em> that breaks this part into two: right and left.  Through the next point we again draw a horizontal line, through the next - a vertical line and so on. <br><br>  All internal nodes of a tree constructed in this way will have only two child nodes.  Each of the two links can lead either to the next internal node in the hierarchy, or to the list of leaf nodes. <br><br>  The method is easily generalized to k-dimensional spaces, therefore trees in the literature are called k-dimensional (kD tree). <br><br>  For example airports: <br><br><img src="https://habrastorage.org/web/a97/130/4d6/a971304d68c8442b86a10c0e52c3e78c.png"><br>  <em>First we divide the plane into top and bottom ...</em> <br><br><img src="https://habrastorage.org/web/035/660/8fe/0356608fea41422eb7fab9cbb2b67669.png"><br>  <em>Then each part to the left and right ...</em> <br><br><img src="https://habrastorage.org/web/bb1/26e/8db/bb126e8db6714d7bb5122f9213e5f658.png"><br>  <em>And so on, until we get the final split.</em> <br><br>  To use such a partition, you must explicitly specify the kd_point_ops operator class when creating an index: <br><br> <code>postgres=# create index points_kd_idx on points using spgist(p <strong>kd_point_ops</strong> ); <br> CREATE INDEX <br></code> <br><br>  This class includes exactly the same operators as the ‚Äúdefault‚Äù quad_point_ops. <br><br><h3>  Inside </h3><br>  When viewing the tree structure, one should take into account that the prefix in this case is not a point, but only one coordinate: <br><br> <code>demo=# select tid, n, level, tid_ptr, prefix, leaf_value <br> from spgist_print('airports_coordinates_kd_idx') as t( <br> tid tid, <br> allthesame bool, <br> n int, <br> level int, <br> tid_ptr tid, <br> prefix float,    --   <br> node_label int,  --   (    ) <br> leaf_value point --    <br> ) <br> order by tid, n; <br> tid  | n | level | tid_ptr |  prefix  |    leaf_value <br> ---------+---+-------+---------+------------+------------------ <br> (1,1)  | 0 |    1 | (5,1)  |    53.740 | <br> (1,1)  | 1 |    1 | (5,4)  |    53.740 | <br> (3,113) |  |    6 |        |            | (-7.277,62.064) <br> (3,114) |  |    6 |        |            | (-85.033,73.006) <br> (5,1)  | 0 |    2 | (5,12)  |    -65.449 | <br> (5,1)  | 1 |    2 | (5,2)  |    -65.449 | <br> (5,2)  | 0 |    3 | (5,6)  |    35.624 | <br> (5,2)  | 1 |    3 | (5,3)  |    35.624 | <br> ... <br></code> <br><br><h2>  Example: prefix tree </h2><br>  With SP-GiST, you can implement a prefix tree (radix tree) for strings.  The idea of ‚Äã‚Äãa prefix tree is that the row being indexed is not stored entirely in the leaf node, but is obtained by concatenating the values ‚Äã‚Äãstored in the nodes up from the given to the root. <br><br>  Suppose you need to index the addresses of sites: ‚Äúpostgrespro.ru‚Äù, ‚Äúpostgrespro.com‚Äù, ‚Äúpostgresql.org‚Äù and ‚Äúplanet.postgresql.org‚Äù. <br><br> <code>postgres=# create table sites(url text); <br> CREATE TABLE <br> <br> postgres=# insert into sites values ('postgrespro.ru'),('postgrespro.com'),('postgresql.org'),('planet.postgresql.org'); <br> INSERT 0 4 <br> <br> postgres=# create index on sites using spgist(url); <br> CREATE INDEX <br></code> <br>  The tree will look like this: <br><br><img src="https://habrastorage.org/web/6dd/626/8d2/6dd6268d2c304e98a78609a6bad997e1.png"><br><br>  In the internal nodes of the tree are stored prefixes that are common to all child nodes.  For example, in the daughters of the ‚Äústgres‚Äù node, the values ‚Äã‚Äãbegin with ‚Äúp‚Äù + ‚Äúo‚Äù + ‚Äústgres‚Äù. <br><br>  Each pointer to a child node, unlike the quad tree, is additionally marked with one character (in fact, two bytes, but this is not so important). <br><br>  The text_ops operator class supports b-tree operators: ‚Äúequal‚Äù, ‚Äúmore‚Äù, ‚Äúless‚Äù: <br><br> <code>postgres=# select amop.amopopr::regoperator, amop.amopstrategy <br> from pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <br> where opc.opcname = 'text_ops' <br> and opf.oid = opc.opcfamily <br> and am.oid = opf.opfmethod <br> and amop.amopfamily = opc.opcfamily <br> and am.amname = 'spgist' <br> and amop.amoplefttype = opc.opcintype; <br> amopopr    | amopstrategy <br> -----------------+-------------- <br> ~&lt;~(text,text)  |            1 <br> ~&lt;=~(text,text) |            2 <br> =(text,text)    |            3 <br> ~&gt;=~(text,text) |            4 <br> ~&gt;~(text,text)  |            5 <br> &lt;(text,text)    |          11 <br> &lt;=(text,text)  |          12 <br> &gt;=(text,text)  |          14 <br> &gt;(text,text)    |          15 <br> (9 rows) <br></code> <br>  Operators with tildes differ in that they work not with <em>characters,</em> but with <em>bytes.</em> <br><br>  In some cases, the representation in the form of a prefix tree may turn out to be much more compact than the B-tree due to the fact that the values ‚Äã‚Äãare not stored as a whole, but are reconstructed as necessary when moving along the tree. <br><br>  Consider the query: <code>select * from sites where url like 'postgresp%ru'</code> .  It can be performed using an index: <br><br> <code>postgres=# explain (costs off) select * from sites where url like 'postgresp%ru'; <br> QUERY PLAN <br> ------------------------------------------------------------------------------ <br> Index Only Scan using sites_url_idx on sites <br> Index Cond: ((url ~&gt;=~ 'postgresp'::text) AND (url ~&lt;~ 'postgresq'::text)) <br> Filter: (url ~~ 'postgresp%ru'::text) <br> (3 rows) <br></code> <br>  In fact, the index contains values ‚Äã‚Äãgreater than or equal to ‚Äúpostgresp‚Äù and at the same time smaller ‚Äúpostgresq‚Äù (Index Cond), and then the appropriate values ‚Äã‚Äãare selected from the result (Filter). <br><br>  First, the consistency function must decide which children of the root ‚Äúp‚Äù need to descend.  There are two options: "p" + "l" (does not fit, even without looking further) and "p" + "o" + "stgres" (suitable). <br><br>  The ‚Äústgres‚Äù node again requires a call to the consistency function to check for ‚Äúpostgres‚Äù + ‚Äúp‚Äù + ‚Äúro.‚Äù (Suitable) and ‚Äúpostgres‚Äù + ‚Äúq‚Äù (not suitable). <br><br>  For the ‚Äúro.‚Äù Node and all its child leaf nodes of the consistency function, the answer is ‚Äúsuitable‚Äù, so the index method returns two values: ‚Äúpostgrespro.com‚Äù and ‚Äúpostgrespro.ru‚Äù.  From them - already at the stage of filtration - one suitable value will be chosen. <br><br><img src="https://habrastorage.org/web/cec/aec/23c/cecaec23c932448098cdd360e60d3c5c.png"><br><br><h3>  Inside </h3><br>  When viewing the tree structure, you need to consider the data types: <br><br> <code>postgres=# select * from spgist_print('sites_url_idx') as t( <br> tid tid, <br> allthesame bool, <br> n int, <br> level int, <br> tid_ptr tid, <br> prefix text,        --   <br> node_label smallint, --   <br> leaf_value text      --    <br> ) <br> order by tid, n; <br></code> <br><h2>  Properties </h2><br>  Let's take a look at the properties of the spgist access method (requests <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">were given earlier</a> ): <br><br> <code>amname |    name      | pg_indexam_has_property <br> --------+---------------+------------------------- <br> spgist | can_order    | f <br> spgist | can_unique    | f <br> spgist | can_multi_col | f <br> spgist | can_exclude  | t <br></code> <br><br>  SP-GiST indices cannot be used to sort and maintain uniqueness.  In addition, such indexes cannot be built on several columns (unlike GiST).  Use to support exception restrictions is allowed. <br><br>  Index properties: <br><br> <code>name      | pg_index_has_property <br> ---------------+----------------------- <br> clusterable  | f <br> index_scan    | t <br> bitmap_scan  | t <br> backward_scan | f <br></code> <br>  Here, the difference from GiST is the lack of clustering. <br><br>  And finally, the properties of the column level: <br><br> <code>name        | pg_index_column_has_property <br> --------------------+------------------------------ <br> asc                | f <br> desc              | f <br> nulls_first        | f <br> nulls_last        | f <br> orderable          | f <br> distance_orderable | f <br> returnable        | t <br> search_array      | f <br> search_nulls      | t <br></code> <br>  There is no support for sorting, which is understandable.  Distance operators for finding nearest neighbors in SP-GiST are not yet available;  most likely such support will appear in the future. <br><br>  SP-GiST can be used exclusively for index scanning, at least for the operator classes considered.  As we have seen, in some cases, indexed values ‚Äã‚Äãare directly stored in leaf nodes, and in some cases they are restored in parts as they descend through a tree. <br><br><h3>  Undefined values </h3><br>  So far, we have not said anything about uncertain values ‚Äã‚Äãin order not to complicate the picture.  As can be seen from the properties of the index, NULL is supported.  And really: <br><br> <code>postgres=# explain (costs off) <br> select * from sites where url is null; <br> QUERY PLAN <br> ---------------------------------------------- <br> Index Only Scan using sites_url_idx on sites <br> Index Cond: (url IS NULL) <br> (2 rows) <br></code> <br>  However, the indefinite value for SP-GiST is something alien.  All operators in the spgist class of operators must be strict: for undefined parameters, they must return an undefined result.  This is provided by the method itself;  undefined values ‚Äã‚Äãare simply not passed to operators. <br><br>  But, in order for the access method to be used exclusively for index scanning, the undefined values ‚Äã‚Äãmust still be stored in the index.  They are stored, but <em>in a separate tree</em> with its own root. <br><br><h2>  Other data types </h2><br>  In addition to points and prefix trees for strings, other methods based on SP-GiST are implemented in PostgreSQL: <br><br><ul><li>  A quad tree for rectangles provides a class of box_ops operators. <br>  Each <em>rectangle</em> is represented by a <em>point in four-dimensional space,</em> so the number of quadrants is 16. Such an index can win GiST in performance, when there are many intersections among rectangles: in GiST it is impossible to draw boundaries so as to separate intersecting objects from each other, but with points albeit four-dimensional) there are no such problems. <br></li><li>  The quad tree for ranges provides the range_ops operator class. <br>  <em>The interval</em> is represented by a <em>two-dimensional point: the</em> lower bound becomes the abscissa, and the upper bound - the ordinate. <br></li></ul><br><br>  <a href="https://habrahabr.ru/company/postgrespro/blog/340978/">Continued</a> . </div><p>Source: <a href="https://habr.com/ru/post/337502/">https://habr.com/ru/post/337502/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337492/index.html">We teach webworkers good manners</a></li>
<li><a href="../337494/index.html">Using Python to process real-time information from sensors that work with Arduino</a></li>
<li><a href="../337496/index.html">How chat bots give reason for Sberbank's IT projects</a></li>
<li><a href="../337498/index.html">How to meet consumer expectations regarding the Internet of Things? (survey results)</a></li>
<li><a href="../337500/index.html">As I wrote browser 3D football. Part 1</a></li>
<li><a href="../337504/index.html">Bank card instead of travel card</a></li>
<li><a href="../337508/index.html">Era IoT: how to enter?</a></li>
<li><a href="../337512/index.html">Typical use of Observable objects in Angular 4</a></li>
<li><a href="../337516/index.html">Artificial Intelligence for Retail: Skynet level salespeople, God level reviews</a></li>
<li><a href="../337518/index.html">How to set up mailing reports from Yandex. Metrics using R (from scratch)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>