<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Project wideNES - go beyond the NES screen</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the mid-1980s, the Nintendo Entertainment System (NES) was a binding console. The best sound, the best graphics and the best games among all consol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Project wideNES - go beyond the NES screen</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif" alt="image"></div><br>  In the mid-1980s, the Nintendo Entertainment System (NES) was a binding console.  The best sound, the best graphics and the best games among all consoles of that time - the prefix expanded the boundaries of the possible.  Still projects like <em>Super Mario Bros.</em>  , <em>The Legend of Zelda</em> and <em>Metroid</em> are considered among the best games of all time. <br><br>  More than 30 years have passed since the release of the NES, and the classic games feel great, which is not the case for the hardware on which they worked.  With a resolution of only 256x240, the NES console could not provide enough space for games.  However, fearless developers managed to fit in the NES games stunning, unforgettable worlds: the labyrinth dungeons <em>The Legend of Zelda</em> , the vast spaces of the planet in <em>Metroid</em> , the bright levels of <em>Super Mario Bros.</em>  .  However, due to NES hardware limitations, players could never go beyond the resolution of 256x240 ... <br><br>  Until recently. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I present to your attention the project <strong>wideNES</strong> - a new way to play the classic NES! <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/921/157/9b0/9211579b0ba7322cf563254fcd26c9cc.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/433/ea0/dcd433ea06a9dec672c3457d76ee2181.gif"></div><br>  <strong>wideNES</strong> is a new technology for <em>automatic</em> and <em>interactive</em> marking of NES games <em>in real time</em> . <br><br>  When players move in level, wideNES records the screen, gradually building a map of the explored part of the world.  On subsequent level passes, wideNES synchronizes the gameplay on the screen with the generated map, essentially allowing players to see more, ‚Äúlooking‚Äù beyond the NES screen!  Best of all, the way of marking the wideNES games is <em>absolutely universal</em> , which allows a wide range of NES games to work with wideNES without any settings! <br><br>  But how does all this work? <br><br><hr><br>  If you want to check how wideNES works, before reading the article, then please!  <a href="https://prilik.com/ANESE">ANESE</a> is the NES emulator written by me, and currently it is the only emulator in which wideNES is implemented.  However, it is worth warning that ANESE is <em>not the</em> best NES emulator in the world, in terms of both UI and emulation accuracy.  Most features (including the inclusion of wideNES) are available only through the command line, and although many popular games work fine, some others may behave in unexpected ways. <br><br><hr><br><h2>  How wideNES works </h2><br>  Before delving into the details, it is important to briefly explain how the NES renders graphics. <br><br><h3>  Transfer pixels using PPU </h3><br>  The heart of NES is the venerable MOS 6502 processor. In the late 70s and early 80s, 6502 were used <em>everywhere</em> and worked in such legendary machines as the Commodore 64, Apple II and many others.  It was cheap, easy to program and powerful <em>enough</em> to be dangerous. <br><br>  Supplemented 6502 in the NES console is a powerful graphics co-processor called the <em>Picture Processing Unit</em> (PPU).  Compared to simple video coprocessors used in older systems based on, PPU is a huge step forward in terms of usability.  For example, five years before the release of NES, the Atari 2600 processor 6502 was used to transfer graphic commands to the coprocessor <em>for each raster line</em> , which left the processor with very little time to execute the gaming logic.  For comparison: PPU needed only a couple of teams <em>per frame</em> , and this gave 6502 enough time to create interesting and innovative gameplay. <br><br>  PPU is an amazing chip, its way of rendering graphics is almost nothing like the work of modern GPUs, and a full <a href="http://www.dustmop.io/blog/2015/04/28/nes-graphics-part-1/">series of articles will be required</a> to fully explain its functions.  Since wideNES uses only a small subset of the PPU functions, it suffices to consider them only briefly: <br><br><ul><li>  Resolution: 256x240 pixels, 60 Hz </li><li>  Works independently of the CPU <br><ul><li>  Communicates with the CPU using <em>memory mapped I / O</em> (address range 0x2000 - 0x2007) </li></ul></li><li>  2 rendering layers: a <strong>sprite</strong> layer and a <strong>background</strong> layer <ul><li>  <strong>Sprites layer</strong> <br><ul><li>  Every single sprite can be placed anywhere on the screen. </li><li>  Great for moving objects: player, enemies, shells </li><li>  Up to 64 sprites 8x8 pixels </li></ul></li><li>  <strong>Background layer</strong> <br><ul><li>  Tied to the grid </li><li>  Great for static elements: platforms, large obstacles, decorations </li><li>  Video memory is enough to store 64x30 tiles of 8x8 pixels <br><ul><li>  The current <em>internal</em> resolution is 512x240, with a 256x240 viewing window </li><li>  Supports <strong><em>hardware scrolling</em></strong> to change the viewport 256x240 <br><ul><li>  The register PPUSCROLL (address 0x2005) controls the offset of the viewport by X / Y </li></ul></li></ul></li></ul></li></ul></li></ul><br>  Having dealt with this <em>very</em> brief overview, let's move on to the fun part: how does wideNES work? <br><br><h3>  main idea </h3><br>  At the end of each frame, the CPU transmits the change information to the PPU.  These include new sprite positions, new level data and, crucially for wideNES, <em>new viewport offsets</em> .  Since wideNES works in an emulator, it is very easy for us to track the values ‚Äã‚Äãwritten to the PPUSCROLL register, which means it is incredibly easy to calculate how much the screen has moved between any two frames! <br><br>  Hmm, what will happen if, instead of drawing each new frame <em>directly on top of the</em> old frame, new frames will be drawn <em>overlaying</em> the previous frame, but shifting to the current scrolling value?  Then, over time, the greater part of the level will remain on the screen, gradually building up a complete picture of the level! <br><br>  To test whether this idea has any value, I quickly sketched the first implementation. <br><br>  Compile ... <br>  Running ... <br>  Download <em>Super Mario Bros.</em>  ... <br><br>  Voila! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ed/7cb/c7f/1ed7cbc7ff1998d1f5f19af6ca09bb54.gif"></div><br>  It worked! <br><br>  It seems to be ... <br><br><hr><br><h3>  Another approach: why not extract levels directly from ROM files? </h3><br>  Even without considering the details of the implementation, it becomes obvious that this technique has a serious limitation: a complete map of the game can be collected only when the player has independently investigated the entire game. <br><br>  What if there was some way to extract levels from <em>raw</em> NES ROM? <br><br>  Can there ever be such a technique? <br><br>  Well, most likely not. <br><br>  If you take any two games for NES, you can guarantee that they have only one thing in common - they both work for NES.  Everything else can be completely different!  Such a mismatch is a real misfortune, because NES games in fact have an infinite number of options for storing data levels! <br><br>  Some people extracted complete levels using reverse engineering of how to store data levels of a <em>couple of</em> games (sometimes with the creation of full <a href="https://www.romhacking.net/utilities/298/">-</a> featured <a href="https://www.romhacking.net/utilities/298/">map editors</a> !), But this is a difficult task that requires a lot of work, perseverance and intelligence. <br><br>  In order to extract the data from the ROM, you need to determine which parts of the ROM are code (and not data), and this is difficult to do, because <a href="https://stackoverflow.com/questions/5299576/finding-all-the-code-in-a-given-binary-is-equivalent-to-the-halting-problem-r">finding the entire code in a binary file is equivalent to the problem of stopping</a> ! <br><br>  In wideNES, a much simpler approach is used: instead of guessing how the game has packed the level data into ROM, wideNES simply starts the game and monitors the output! <br><br><hr><br><h3>  Scrolling outside 255 </h3><br>  NES is an 8-bit system, that is, the PPUSCROLL register can only receive 8-bit values.  This limits the maximum scrolling offset to 255 pixels, that is, the maximum 8-bit number.  There is no coincidence that the screen resolution of the NES is 240x256 pixels, that is, a 255-pixel offset <em>is just enough</em> to scroll the entire screen. <br><br>  But what happens when you scroll <em>on</em> 255? <br><br>  First, the games reset the PPUSCROLL register to 0. This explains why the <em>SMB is</em> shifted to the beginning when Mario moves too far to the right. <br><br>  Then, to compensate for the 8-bit limitations of PPUSCROLL, the games update another PPU register: PPUCTRL (address 0x2000).  The lower 2 bits of PPUCTRL set the ‚Äústarting point‚Äù of the current scene in full-screen increments.  For example, writing value 1 shifts the viewport to the right by 256 pixels, value 2 shifts the viewport down by 240 pixels.  The PPUCTRL offset is pushed onto the <em>stack</em> with the PPUSCROLL register, which allows the screen to be scrolled horizontally within 512 pixels or vertically within 480 pixels. <br><br>  But build, because the video memory is only enough for two level screens?  What happens when the viewport scrolls too far to the right and ‚Äúbeyond the limits‚Äù of VRAM?  To handle this case, PPU implements a convolution: all parts of the viewing window outside the selected video memory are simply minimized to the opposite edge of the video memory. <br><br>  Such a folding in combination with the smart manipulation of the registers PPUSCROLL and PPUCTRL allows NES games to create the illusion of infinitely high / wide worlds!  Due to the lazy loading of the part of the level outside the viewing window and the gradual scrolling into it, players never realize that inside VRAM they actually ‚Äúrun in a circle‚Äù! <br><br>  An excellent illustration from the nesdev wiki shows how <em>Super Mario Bros.</em>  uses these properties to create levels longer than two screens: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/68d/6f7/d6f68d6f7f1e05516af8dcae1443bcb9.gif"></div><br>  Let's return to the question we are discussing: how does wideNES handle scrolling beyond 256? <br><br>  Well, frankly, wideNES <em>completely ignores the</em> PPUCTRL register and just keeps track of the difference between the PPUSCROLL frames! <br><br>  If PPUSCROLL unexpectedly jumps to about 256, which usually means that the player‚Äôs character has moved left / up the screen, and if he suddenly jumps to about 0, then this usually means that the player has moved across the screen to the right / down. <br><br>  Although this heuristic may look simple - and it is - it actually works great! <br><br>  After implementing this heuristic for <em>Super Mario Bros.</em>  , <em>Metroid</em> and many other games have earned almost perfect! <br><br>  I was delighted, so I went ahead and downloaded another NES classic - <em>Super Mario Bros.</em>  <em>3</em> ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a21/1ee/233/a211ee233bcdea56af5b983f9b8715cf.gif"></div><br>  Hmm ... not very pretty. <br><br><h3>  Ignoring static screen elements </h3><br>  Many games have static UI elements around the edges of the screen.  In the case of <em>SMB3,</em> this is the column on the left and the status bar at the bottom of the state. <br><br>  By default, wideNES performs sampling with 16-pixel increments from the edges of the screen, that is, all static elements are sampled along the edges!  Not good! <br><br>  To get around this problem, wideNES implemented rules and heuristics that try to automatically recognize and mask static screen elements. <br><br>  In general, NES games use three different types of static screen elements: HUD, masks, and status bars. <br><br><h4>  HUD - no problem </h4><br>  If the game puts a HUD on top of the level, then there is a chance that the HUD consists of several sprites.  Example: <em>Metroid</em> HUD. <br><br>  Fortunately, such HUDs do not cause problems, because wideNES currently just ignores the sprite layer.  Fine! <br><br><h4>  Masks - nowhere easier </h4><br>  PPU has a feature that allows games to mask the leftmost 8 pixels of the background layer.  It is activated by setting the second bit of the register (address 0x2001).  Many games use this feature, but explaining <em>why</em> they do it is beyond the scope of this article. <br><br>  Recognizing the included mask is incredibly simple: wideNES simply monitors the PPUMASK value and ignores the leftmost 8 pixels when the second bit is set in the register! <br><br>  It seems that the implementation of this simple rule has eliminated the problem with <em>SMB3</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/6ce/6ce/8e56ce6ce6e3f59203422816794e21de.gif"></div><br>  ... well, or <em>almost</em> eliminated. <br><br><h4>  Status bars - the most difficult </h4><br>  Due to the limitations of PPU, at any given time on the screen there can be no more than 64 sprites;  Moreover, at any moment in <em>each raster line there</em> can be no more than 8 sprites.  This restriction does not allow developers to create complex HUDs from sprites and forces them to use to display information of a part of the background layer. <br><br>  In addition to masks, PPU does not have a simple way to separate the background layer into a game area and a status area.  Therefore, the developers went to tricks, leading to a bunch of <em>unorthodox</em> ways to create state panels ... <br><br>  To recognize different types of status bars, wideNES uses different heuristics, but to save time, I‚Äôll consider only one of the most interesting ones: Mid-Frame IRQ tracking. <br><br><h3>  Mid-Frame IRQ Tracking </h3><br>  Unlike modern GPUs with large internal frame buffers, PPU <em>has no frame buffer at all!</em>  To save space, PPU stores scenes as a grid of 64x32 tiles measuring 8x8 pixels.  Instead of pre-calculating pixel data, tiles are stored as <em>pointers</em> to a CHR Memory (Character Memory), which contains all the pixel data. <br><br>  Since NES was developed in the 80s, PPU was created without taking into account modern display technologies.  Instead of simultaneously rendering a full frame, PPU outputs the NTSC video signal, which should be displayed on a CRT screen that displays video <em>pixel by pixel</em> , <em>line by line</em> , from top to bottom, from left to right. <br><br>  Why is all this important? <br><br>  Since PPU renders frames from top to bottom, line by line, you can send PPU <em>frame-by-frame</em> instructions to create video effects that are impossible with any other approach!  These effects can be as simple (for example, changing the palette), and quite complex (for example, you guessed it, creating state panels!). <br><br>  To explain how writing to PPU in the middle of a frame can create status bars, I recorded a raw dump of PPU and CHR Memory video memory for one <em>SMB3</em> frame: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf6/565/049/cf6565049202c1a832222de6edb291c3.png"></div><br>  Everything looks fine, nothing special ... but just look at the status bar!  It is completely distorted! <br><br>  Now look at the same raw dump, but made after line 196 ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5df/8e4/be6/5df8e4be6a32dcefa00429da5fbb4755.png"></div><br>  Yes, the level looks awful, but the status bar looks great! <br><br>  What is going on here? <br><br>  <em>SMB3</em> sets a timer to start the IRQ (interrupts) exactly after rendering the raster line 195. It sends the following instructions to the IRQ handler: <br><br><ul><li>  Set PPUSCROLL values ‚Äã‚Äã(0,0) (so that the status bar stays in place) </li><li>  Replace the tile card in the CHR Memory (put in order the graphics of the status panel) </li></ul><br>  Since the rest of the level is already rendered, the PPU will not re-frame the frame.  Instead, it will continue rendering with these parameters, displaying a beautiful undistorted state panel! <br><br>  Let's go back to wideNES: watching all the IRQs in the middle of the frame and remembering the raster line on which they occurred, wideNES can ignore all subsequent raster lines in the record!  If the IRQ occurs in the raster line above 240/2, then all <em>previous</em> lines are ignored, because early interruption of the raster line means that the status bar may be <em>at the top of the</em> screen. <br><br>  After implementing this heuristic for <em>Super Mario Bros.</em>  <em>3</em> earned perfect! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/146/44a/b08/14644ab0880d7a2827bcad22d028a0be.gif"></div><br><hr><br>  I briefly considered the possibility of using a computer vision library, such as OpenCV, for recognizing state panels (or other mostly static areas of the screen), but as a result I decided to refuse it.  The use of a huge, complex and non-transparent library of computer vision contradicts the ideals of wideNES, in which I seek to use compact, simple, and transparent rules and heuristics to get results. <br><br><hr><br><h3>  Scene Recognition </h3><br>  With the exception of a few outstanding examples (for example, <em>Metroid</em> ), games for NES usually <em>do not</em> take place within one huge, inseparable level.  On the contrary, most NES games are divided into many small independent ‚Äúscenes‚Äù with doors or transition screens between them. <br><br>  Since there is no concept of ‚Äúscenes‚Äù in wideNES, bad things happen when changing scenes ... <br><br>  For example, here is the first passage from the scene of <em>Castlevania</em> , where Simon Belmont enters Dracula‚Äôs castle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f7/b5b/8e4/7f7b5b8e4edf5c31dd19682b333d75c9.gif"></div><br>  Wow, everything is bad!  wideNES completely rewrote the last part of the level with the first screen of the new level! <br><br>  Obviously, wideNES needs some way to recognize scene changes.  But which one? <br><br>  <em>Perceptual hashing!</em> <br><br>  Unlike <em>cryptographic</em> hash functions that seek to evenly distribute similar incoming data across the output space, <em>perceptual</em> hash functions try to keep similar incoming data ‚Äúclose‚Äù to each other in the output data space.  Therefore, perceptual hashes are ideal for recognizing similar images! <br><br>  Perceptual hash functions can be incredibly complex, some of them are able to recognize similar images, if one of them was rotated, scaled, stretched and colors changed in it.  Fortunately, wideNES does not require complex hash functions, because each frame is guaranteed to have the same size.  Therefore, in wideNES, the simplest perceptual hash is used: <em>summation of all pixels on the screen!</em> <br><br>  It is simple, but it works quite well! <br><br>  For example, see how the transitions between scenes stand out if you plot the change in perceptual hash over time in <em>The Legend of Zelda</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/799/5e3/f077995e3d509802139543805d7ae61b.png"></div><br>  Currently, wideNES uses a fixed threshold between perceptual hash values ‚Äã‚Äãto perform the transition between scenes, but the result is far from ideal.  Different games use different palettes, and there are many cases in which wideNES thinks that a transition has taken place, but in fact it was not.  Ideally, wideNES should use a dynamic threshold value, but for now it will come down and fixed. <br><br>  After the implementation of this new heuristic, wideNES successfully recognizes Simon's entry from <em>Castlevania</em> to the castle and accordingly creates a new canvas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/6da/e81/6446dae81018592433a99f4f50a8b4d0.gif"></div><br>  And with this decision we replaced the last large piece of the wideNES puzzle. <br><br>  Having implemented the simplest serialization, I was finally able to launch the game for NES, play several levels and automatically generate level maps! <br><br><h2>  What awaits wideNES in the future? </h2><br>  wideNES consists of two separate parts: <em>the</em> wideNES <em>core</em> , which is the technology rules / heuristics that underlie the technology, and the specific implementation of wideNES inside the ANESE emulator. <br><br><h3>  <em>Kernel</em> wideNES enhancements </h3><br>  First, wideNES tends to be too aggressive to recognize transitions between scenes.  The number of false positives can be minimized by using a more appropriate perceptual hashing algorithm or by moving to dynamic thresholds between perceptual hashes. <br><br>  Additional work is also required on recognizing static screen elements.  For example, in <em>Megaman IV</em> there is an IRQ in the middle of the frame, but there is no status bar, due to which wideNES mistakenly ignores a solid part of the playing field.  Although this particular case can be corrected manually, it is better to use smarter heuristics. <br><br>  Some NES games scrolling the screen in ‚Äúunique‚Äù ways.  One of the most notable examples is <em>The Legend of Zelda</em> , in which PPUSCROLL is used for the horizontal scroll, but for the vertical scroll, a completely different register is used - PPUADDR.  <em>Zelda</em> is a fairly popular game, so wideNES implements heuristics specifically for <em>Zelda</em> .  There are other games with similar "unique" scrolling modes, for which individual heuristics will also be needed. <br><br>  It would be useful to find some way of ‚Äústitching‚Äù identical scenes.  For example, if a user plays <em>Super Mario Bros.</em>  Level 1, but climbs into a pipe to get into an underground cave with coins, then wideNES will create two separate scenes for Level 1: Scene A, level until the moment when Mario enters the coin area, and Scene B, level, from when Mario comes out of the pipe and up to the flagpole.  If the game is then restarted and Level 1 is replayed <em>without</em> entering the tube, then wideNES will simply update scene A, which will contain a full-level map, but scene B will ‚Äúend‚Äù. <br><br>  Finally, wideNES should track transitions between scenes.  Without this data, it will be impossible to construct a transition graph between scenes for generating maps of the world of games that <em>do not</em> consist of a single large world. <br><br><h3>  Improved wideNES implementation in ANESE </h3><br>  Currently, wideNES is implemented only in the NES emulator written by me called ANESE.  ANESE is a <em>very</em> spartan emulator: most options are hidden behind CLI flags, and the only implemented UI is the simplest file selection overlay!  He is still <em>extremely</em> far from the level of "production". <br><br>  In addition to the lack of UI, ANESE and wideNES would not prevent improvements in compatibility and speed.  ANESE - the first emulator written by me, and it is noticeable! <br><br>  There are quite a few compatibility issues - many games do not work correctly or do not start at all.  Fortunately, the imperfection of ANESE does not mean that wideNES is a bad technology.  wideNES is based on proven principles that will be easy to implement in other emulators! <br><br>  In terms of speed, ANESE and wideNES are not ideal, and even on relatively powerful PCs, performance can sometimes fall below 60fps!  In ANESE and wideNES you need to implement many optimizations.  In addition to general improvements to the ANESE kernel, you need to improve in wideNES frame recording, map rendering and hash sampling. <br><br><h2>  Conclusion </h2><br>  In the article I talked about the main aspects of wideNES, but I could not describe many small features.  For example, wideNES stores a map of the true hash and scroll values ‚Äã‚Äãof each frame, which are used to enable repeated scenes.  This and many other functions are described in the widely commented wideNES source code posted on <a href="https://prilik.com/ANESE/wideNES">the wideNES project page</a> . <br><br>  Work on wideNES was a truly amazing experience, but due to the approaching new academic semester at Waterloo University, I doubt that I will be able to continue the development of wideNES soon.  At the moment, the main functions of wideNES are working, and I am glad that I was able to write this post with a description of some of its technologies! <br><br>  Try using wideNES and tell about your feelings!  Download <a href="https://prilik.com/ANESE">ANESE</a> , run <em>Super Mario Bros.</em>  , <em>The Legend of Zelda</em> or <em>Metroid</em> , and play them in new ways! </div><p>Source: <a href="https://habr.com/ru/post/421555/">https://habr.com/ru/post/421555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421545/index.html">Review of PocketBook 616 - the most affordable PocketBook 2018 with backlight function</a></li>
<li><a href="../421547/index.html">Independent Acceptance of Data Center</a></li>
<li><a href="../421549/index.html">We write technical documentation: a guide for the layman</a></li>
<li><a href="../421551/index.html">Mastering Vuex - from Zero to Hero</a></li>
<li><a href="../421553/index.html">We share technological content: collected all our materials on one site</a></li>
<li><a href="../421557/index.html">Open lesson "Asynchronous programming in Java"</a></li>
<li><a href="../421559/index.html">Component UI architecture in iOS application</a></li>
<li><a href="../421561/index.html">12 questions about scooters that are not ashamed to ask</a></li>
<li><a href="../421563/index.html">You may have to sit differently to get rid of back pain.</a></li>
<li><a href="../421565/index.html">How rude humanoid robots can fool you</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>