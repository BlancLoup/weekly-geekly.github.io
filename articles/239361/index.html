<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DSL Application Development and Code Generation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is it all about 
 In this post I want to speculate abstractedly on the topic of application development. At first, I decided to write simply abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DSL Application Development and Code Generation</h1><div class="post__text post__text-html js-mediator-article"><h2>  What is it all about </h2><br>  In this post I want to speculate abstractedly on the topic of application development.  At first, I decided to write simply about code generation, but as I thought about the topic, I had many thoughts that I also want to share.  Therefore, it turned out a little wider than just about DSL. <br><a name="habracut"></a><br><h2>  What is DSL (Domain Specific Language) and Code Generation? </h2><br>  DSL is a language specific to a particular domain domain.  Those.  it is a language that operates on the concepts of this field directly.  Usually opposed to general purpose languages.  In principle, nothing prevents the language from being just a formal syntax that cannot be interpreted by a computer, but there is not much benefit from such a language.  A computer language usually involves processing in some way, so it would be nice to have some kind of interpreter for DSL.  Accordingly, there are two standard approaches - interpretation and compilation.  The interpretation is more or less clear, and with the compilation the story is as follows.  You can, of course, translate directly into processor instructions or at worst into an assembler, but why, if you can ‚Äúwrite‚Äù normal code, in the sense of compiling into the text of a high-level language that is then converted by your compiler into something that is not started by a computer.  Therefore, they often say ‚Äúcode generation‚Äù rather than compilation, although the latter term is also correct and is used. <br><br><h2>  Labor productivity </h2><br>  If we take the development of applications, then I consider the main problem to be low productivity, i.e.  "Amount of product" on the effort expended.  In principle, a similar problem occurs in all industries, and there are both general solutions and specific ones.  We have a lot of different things to raise this very performance - high-level languages, powerful IDE, continious integration tools, scrum, canban, coffee points, coffee ladies, and much more.  Nevertheless, product development takes a lot of time.  This is especially noticeable when something that needs to be done can be easily described in words in a few minutes, and it takes weeks to do it.  There is a significant gap between ‚Äúwhat‚Äù and ‚Äúhow‚Äù.  ‚ÄúWhat to do‚Äù is simple and understandable, ‚Äúhow to do‚Äù is simple, understandable, but for a long time.  I want to do ‚Äúhow‚Äù - quickly, and ideally not to do at all.  In short, a declarative approach. <br><br><h2>  Levels of abstraction </h2><br>  There is a very useful concept - the level of abstraction.  It helps to structure the application.  Suppose we have an application for some subject area.  On the one hand (above) there are concepts from this subject area that will somehow appear in the application, on the other hand there is a general-purpose programming language (below), in which there are bytes, types, methods, and similar elements that have nothing in common with the subject area (we will not go down below to the operating system, electrical impulses, transistors, molecules, atoms, protons, quarks ...).  The job of the programmer is precisely to link these two layers or to fill the area in the picture (left picture).  If the application is large and the domain area is sufficiently ‚Äúfar‚Äù, then various intermediate levels of abstraction arise in the application, otherwise you may not be able to cope with the complexity (right picture). <br><img src="https://habrastorage.org/files/b4d/48e/624/b4d48e6247a34af9867f6863a8b190cb.jpg"><img src="https://habrastorage.org/files/414/81b/7ff/41481b7ffc854f80bfc3506a79877da2.jpg"><img src="https://habrastorage.org/files/f6f/f43/9e5/f6ff439e52c24bf6895db9855a180dba.jpg"><br>  Levels, of course, arise, but they arise logically.  And it is necessary to put some effort so that the code also supports levels.  This is especially difficult if the language is one and everything is running in the same process.  After all, nothing prevents to call a method from level 1 at level 3. And functions or classes are usually not labeled with an abstraction level.  What does DSL with a codogen suggest to us?  We still need to fill the same area.  Accordingly, the upper part is filled with our language, and the lower one with the generated code: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Unlike the previous example, the level here is impenetrable, i.e.  DSL instructions cannot be invoked from the generated code (especially if they are not there).  We will not consider cases when the generator makes the code on the same DSL ... Another important point here is that the generated code can be viewed as compiled, in the sense that it is created automatically and there is no need to look at it.  Provided that the generator is already written (and well tested).  Those.  By writing a language and a generator to it, you can significantly narrow the scope of the application.  This is especially valuable when developing multiple applications in this area or with the constant change of one. <br><br><h2>  Management "complication" </h2><br>  Let's imagine a situation that I think is quite common.  Suppose you receive an order for the development of a certain system.  You bring an ideal specification and you come up with an ideal system architecture where everything is fine, components, interfaces.  encapsulation and many other equally beautiful patterns.  Take a concrete example - an online bicycle store.  You wrote according to the specification online store and everyone is happy.  The store is thriving and thinking about expanding the business, namely, to start trading more scooters and motorcycles.  And here they come to you and ask you to modify the store.  You had a beautiful architecture, sharpened on bicycles, but now you need to peretachivat.  On the one hand, scooters and motorcycles are similar to bicycles, and those and those have parts, accessories, and related products, but there are differences. <br>  The system as a whole remains the same, but some of the functions must support still new types of objects, or separate functions must appear for new types of objects. <br>  There has been a complication of the domain area, i.e.  instead of bicycles only, bikes, scooters and motorcycles should now be supported.  Our system must also be complicated.  I think that in the general case the complexity of the software system corresponds to the complexity of the system being modeled.  At the same time, there is a minimum possible level of complexity at which the problem can still be solved.  (The top level does not exist - you can come up with an infinitely complex solution for any problem).  I think that we should strive for the minimum level of complexity, because of all the possible solutions, the simplest is the best.  In short, the code should be simple. <br>  Let's return to our online store.  Let there is a certain function which is written for the bicycle.  Now it should work for new types. <br><br> <code>public void process(Bicycle b) {</code> <br> <code>genericCode</code> <br> <code>specificForBicycle</code> <br> <code>}</code> <br> <br>  for this, there must be specificForMotobike code inside.  What are the solutions? <br><br><h4>  Copy / paste </h4><br> <code>public void process(Motobike b) {</code> <br> <code>genericCode</code> <br> <code>specificForMotobike</code> <br> <code>}</code> <br>  Copied the method, replaced the type-specific code and all.  Simple, but there is a problem.  If you need to change genericCode, then you need to change the same thing in several places, and this time, errors ... <br><br><h4>  If / else </h4><br> <code>public void process(Object b) {</code> <br> <code>genericCode</code> <br> <code>if(b instanceof Bicycle) {</code> <br> <code>specificForBicycle</code> <br> <code>} else if(b instanceof Motobike) {</code> <br> <code>specificForMotobike</code> <br> <code>}</code> <br> <code>} <br></code> <br>  Set the conditions and everything is ready.  A bit better than copy / paste, but again there is a problem.  And tomorrow they will want to sell ATVs and will have to look for such pieces throughout the code and add another one else. <br><br><h4>  Abstract method </h4><br> <code>abstract void specific()</code> <br> <code>public void process(Vehicle b) {</code> <br> <code>genericCode</code> <br> <code>b.specific()</code> <br> <code>} <br></code> <br>  At this point, an abstract method is invoked, which is implemented for each type.  In principle, this may be an acceptable option, and may significantly complicate the system.  Multi-storey inheritance hierarchies with a bunch of overridden methods, when it‚Äôs not easy to figure out which particular method is being called is not uncommon. <br><br><h4>  DSL and code generation </h4><br>  DSL is designed in such a way that all features of types can be described.  In the code generator, templates are written that are applied to the type description and the code is obtained as in copy / paste <br>  Template: <br> <code>public void process("TYPE" b) {</code> <br> <code>genericCode</code> <br> <code>"SPECIFIC CODE"</code> <br>  } <br><br>  DSL: <br><br> <code>type Bicycle:</code> <br> <code>property A, ( description, value, links ...)</code> <br> <code>type Motobile:</code> <br> <code>property B,</code> <br> <code>property C, <br></code> <br>  Further, for each type of DSL template is transformed into a specific code.  From my experience, it is difficult to immediately write a language that would support new entities without changes, but changes to the language and generator are usually small and simple.  In general, the approach is the following - a lot of simple code is generated that is easy to read and understand, and it doesn‚Äôt matter that there are a lot of files and they can be several thousand lines.  After all, it's not writing with your hands. <br><br><h2>  DSL at the beginning or formalized specification </h2><br>  Here I come to the most important thing.  (before this was the introduction :) How does the process of starting a project usually look like?  Specifications are written, diagrams are drawn, the architecture, the stages of the project are being worked out.  And when it's all done, they start writing code.  Specifications are free-form documents.  Why don't the specifications be formalized?  My main idea is to first develop a system description language in terms of the domain domain.  This will be partly both a description of the architecture, and a partly formalized specification.  At the same time, the customer will understand the language, as he directly uses the terms of the subject area, and he, too, will be able to take part in the development of the system.  The idea, of course, is not mine.  In the literature, this approach is called Domain-Driven Design (DDD).  I just say that the DDD approach works well with DSL and code generation. <br>  Formalization means the possibility of automatic processing.  You can add a variety of checks for consistency, consistency.  On the other hand, system developers have a ready-made formalized declaration of what should be.  It remains to write the converter <s>in as</s> in a working system, the same code generators. <br><br><h2>  Not so smooth </h2><br>  Of course, not everything is so simple and smooth.  Like any other approach, there are problems and shortcomings. <br><ul><li>  It is not always clear what to generate.  We must imagine the final system.  After all, not all code is generated and you need to understand what will be generated, and what is written by hand, and how it will all work together.  Sometimes it is easier to first write everything manually (keeping in mind the future generation), and then pull out part of the code into templates and generators. </li><li>  The second problem is the balance of the generated and manual code.  There is no point in putting code into a template that is not actually parameterized and is always the same.  A bad practice is to use the approaches from the examples above at the same time. </li><li>  Dependencies between manual and generated code.  Do not make the manual code break when DSL changes.  (text on DSL) </li><li>  "Damage" of brain kodogeneratsii.  Writing code generators is somewhat different from writing regular programs.  Using the ‚Äúwrong‚Äù style leads to writing ‚Äúnot very‚Äù code.  Saves review and "healthy" colleagues. </li><li>  Another point I encountered is difficult to convince the customer of the correct approach.  They say that they used to do it somehow, and we will continue to live normally, and here you are with your ideas.  And in general, where is the support of scooters, which you should have done yesterday?  Go to work. </li><li>  Have you seen a DSL developer job?  But here, probably, just like getting a Haskell programmer.  Make yourself a Java programmer (C ++, Perl, Python, etc).  Convince <s>Haskell</s> DSL to be awesome.  And here you are a DSL developer. </li></ul><br><br><h2>  Tools for developing DSL and writing code generators </h2><br>  Everything that I wrote before would have little practical meaning without normal development tools.  Fortunately, there are such funds.  The tools are different, but my choice is Eclipse Xtext.  The most important thing in xtext is integration into the Eclipse IDE, in particular, there are all the standard features - syntax highlighting, errors and warnings, content assist, quick fix.  This is what is called "out of the box."  And then what fantasy enough for that.  I think I will make a few more practical posts on the topic, if there is interest. <br><br><h2>  Conclusion </h2><br>  I think I did not discover America.  Much of what I wrote is trivial things.  But on the other hand, I think the topic of DSL and code generation is not sufficiently disclosed, so I decided to try my hand at enlightenment.  And about Eclipse Xtext is not so much heard, and even more use. </div><p>Source: <a href="https://habr.com/ru/post/239361/">https://habr.com/ru/post/239361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239347/index.html">VR helmet programming</a></li>
<li><a href="../239351/index.html">The charm of the bad guys or why girls do not like "nerds"</a></li>
<li><a href="../239355/index.html">Creating a home audio system</a></li>
<li><a href="../239357/index.html">Reviewing resumes of female techies is more profitable than men</a></li>
<li><a href="../239359/index.html">Microsoft ActiveDirectory - update user passwords in external repositories</a></li>
<li><a href="../239365/index.html">Spherical screens for UAV operators and remotely controlled vehicles</a></li>
<li><a href="../239367/index.html">Wal Commander - Far Manager replacement for OS X and Linux</a></li>
<li><a href="../239369/index.html">Dummy about Dummies and one exciting journey into the depths of Excel. Long-awaited RegExp in tables</a></li>
<li><a href="../239373/index.html">Pitfalls of responsive web design</a></li>
<li><a href="../239375/index.html">New solutions to the old problem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>