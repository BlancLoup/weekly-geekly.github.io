<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As we wrote AI for the Jackal, and why he has schizophrenia</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the situation of a complete and hopeless ass, the power in AI was immediately taken away by the military, and this sometimes saved the party. 

 Fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As we wrote AI for the Jackal, and why he has schizophrenia</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/30c/25f/bf6/30c25fbf6b2f43f2a599ce5a5bde898b.jpg"><br>  <sup>In the situation of a complete and hopeless ass, the power in AI was immediately taken away by the military, and this sometimes saved the party.</sup> <br><br>  For our AI, Jackal had to write as many as <b>4</b> different AI, each of which was responsible for their task.  And then they got together and voted for what the pirates would do on the field this turn. <br><br>  This entire complex system was needed because we did not have a single evaluation function.  Roughly speaking, AI are of two types: when it is clear how to numerically evaluate your position, and when it is completely incomprehensible.  The same game in Go at some point turns into a duel of intuitive conjectures, that is, it falls into a non-algorithmic task of complexity and uncertainty. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Long ago, my teacher, Professor Serbin, was telling a bike with a cheese-maker from Europe.  Automators came to this charming fat man and asked how he makes such delicious cheese.  They needed heuristics for temperature, density, and so on.  The cheese-maker put his finger in the soft cheese, slowly and happily drew an arc there, smiled into all the sly face and said: <font color="red"><i>‚ÄúWell, how do you not feel!‚Äù</i></font> . <br><br>  <b>Algorithmize the process of guests and could not.</b>  So, the development went like this: we drew arcs and smiled slyly, and the guys lost to us in the table Jackal.  And they dreamed that the AI ‚Äã‚Äãwould take revenge for them. <a name="habracut"></a><br><br><h3>  What you need to know about the game, to understand what the ambush with AI </h3><br>  The core of AI was written by the developer <a href="http://habrahabr.ru/users/idyury/" class="user_link">idyury</a> , who already had experience creating machine intelligence, but not for such strategies.  The situation was somewhat complicated by the fact that he initially did not know how to play "Jackal", so the tests for the first six months were simply magical. <br><br>  The principle of "Jackal" is quite simple - you play as three pirates, scouting the island and collecting treasures there.  This is how the field looks like during the game: <br><br><img src="https://habrastorage.org/files/cd6/c86/d13/cd6c86d13691454897db61e355e14380.jpeg"><br><br>  Each cell is an adventure, such as a chest of gold, a crocodile, a cannon, a herd of wild horses, or an arrow that the pirate immediately follows.  The combination of arrows and other elements creates a complex navigation graph, which in each new party determines the relief of the island and the "bottlenecks" for which the war is going. <br><br><img src="https://habrastorage.org/files/548/31b/441/54831b441ba14b559b509c04734ed679.jpg"><br>  <sup>Table cells</sup> <br><br><img src="https://habrastorage.org/files/2dc/62f/cc9/2dc62fcc9a134784911758271c1002d1.jpg"><br>  <sup>For the screen had to change the "interface" of cells</sup> <br><br>  Actually, ‚ÄúJackal‚Äù was originally created in a fairly simple form by teachers and students of Moscow State University back in the 70s.  Until 2008, it was successfully played with the help of two sheets of paper, a pencil and knowledge of graph theory, and then we substantially reworked it and published it in the form of a board game.  Devil's simplicity of development gave rise to incidents like a 12-year-old girl who took the second place in the tournament and parents writing to us how their four-year-old and five-year-old children are cut into the "island". <br><br>  When the number of boxes sold in Russia exceeded 100,000 pieces, we decided to make an application.  And here I needed AI. <br><br>  The problem was that despite the existence of some general rules of the game leading to victory, there are a lot of options for achieving superiority over opponents.  And these options for achieving excellence in different igromechanical planes lie: for example, either you have taken an advantageous position on the island, or have found a convenient treasure for carrying, or you have a balloon nearby, and so on. <br><br>  One of the key difficulties was a fairly large set of possible cells on the playing field with different actions.  The action of some cells was generally unique (for example, ‚Äúairplane‚Äù or ‚Äúaboriginal‚Äù).  However, initially the task was to build a system that would structure all game information and unify all subsystems.  I didn‚Äôt want to engage in ‚Äúdata fitting‚Äù and microtuning based on strategies - I needed a scheme that allows the game to be expanded with any type of cells. <br><br>  Therefore, the developer sat down to saw some common data model for the game. <br><br><h3>  Data model </h3><br>  The developers have played with us and learned some common patterns of action within the game.  The work began with the creation of several prototypes at once ‚Äî systems for navigating the playing field, systems for assessing the current state and decision-making, systems for finding optimal paths, and various evaluation functions.  Just at this moment we created an unpleasant legacy code, which didn‚Äôt manifest itself in half a year, and then suddenly began to interfere. <br><br><img src="https://habrastorage.org/files/746/e6c/736/746e6c73651e42fc91e94c77d8039d18.jpg"><br>  <sup>Side view of the playing field of a real game (this is the old version, where the coins were without relief).</sup>  <sup>Here the black pirates were well established, and white could not take the gold without risking being beaten.</sup>  <sup>But black also cannot take a coin.</sup> <br><br>  The fact is that in the desktop version the playing field consists of cells that must be turned over as the island is explored.  And the very first model of the island assumed the graph of just such a shape and configuration, where each cell was a node. <br><br><img src="https://habrastorage.org/files/30c/25f/bf6/30c25fbf6b2f43f2a599ce5a5bde898b.jpg"><br>  <sup>Here is a linked graph in the end, where each cell of the navigation field is divided into slots, which are the nodes of the graph.</sup> <br><br>  The problem is that some desert-type cells are traversed in, for example, 5 moves, and in one direction.  That is, in the place of one vertex there must be 5 with its own connecting vectors.  At first, to facilitate testing in this place, a crutch was hammered, which gradually became enclosed with a code and became a supporting structure.  What eventually gave rise to a number of crutches in the functions of finding the path and assessment later. <br><br>  For each node of the graph, a list of checkboxes describing its current state from the point of view of the active player is set (for example, there is a flag indicating that the current node is under attack by the enemy pirate): <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> eLocks { eLock_Prohibited = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, eLock_LandAttack = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, eLock_SeaAttack = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, eLock_TrapLock = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>, eLock_Unexplored = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>, eLock_Fortress = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>, eLock_ExcludeTrap = eLock_Prohibited | eLock_LandAttack, eLock_AllDanger = eLock_Prohibited | eLock_LandAttack | eLock_TrapLock, };</code> </pre> <br><br>  Flags are widely used for various purposes, but their main purpose is to facilitate search on the navigation network.  The navigation graph is the same for all bots, but its context is constantly recalculated for each player individually, for example, the set of checkboxes for each node of the graph is unique for each player.  If the cell on the playing field is still not explored, then in the graph it is presented as an empty cell: <br><br><img src="https://habrastorage.org/files/ff6/57e/a23/ff657ea239a84d2780efbf03f83759f4.jpg"><br>  <sup>Example graph for undiscovered cells</sup> <br><br><h3>  Evaluation function </h3><br>  When the navigation model was ready, it was necessary to obtain an evaluation function, which allows to distinguish good moves from bad ones, and ingenious ones from good ones.  Naturally, for a given variety, it was very difficult.  In the end, after much deliberation, <a href="http://habrahabr.ru/users/idyury/" class="user_link">idyury</a> identified 4 subsystems that determined your success in the game: <br><ul><li>  Exploration, that is, the assessment of the need to open new cells. </li><li>  The ‚Äúgreedy‚Äù system, that is, the direct taking of coins from explored cells and their delivery to the ship. </li><li>  The system of restoring pirates - when one of our pirates gets into trouble, it is often more rational to save him than to grab at the piastres or beat the enemy. </li><li>  And the enemy pirates' attack system.  This is the only aggressive subsystem whose task is to reduce the risks for the other three systems.  Looking ahead, I will say that it turns on as an emergency if the risks for optimal action in the first three subsystems are too great. </li></ul><br><br>  I must say that the guys have already done chess and AAA-shooters with complex enemies, but they always had a good evaluation function at hand.  It also implemented a simulation of alien moves based on its own logic of optimal actions, and then an estimate for each of the 4 subsystems.  We came to a set of heuristics for each option.  Then 4 subsystems ‚Äúvote‚Äù for their moves (the weight of the voice changes depending on the situation on the board: for example, with one capable pirate of three, we will most likely drop everything and go to save friends).  As a result of this rationing, one estimated function was obtained, which was then balanced for a long time.  By the way, this is how different "characters" of bots are made - for the greedy one, we can simply increase the weight of the voice of the coin-taking system, and for the cautious player - the recovery system.  In the current version, the balance is matched by eye after about two hundred test batches with experienced players.  Later we will use the results of real games for learning AI. <br><br>  And yes, AI itself should be simple at first, and gradually develop, corresponding to the level of the player‚Äôs training.  But let's move on to the meat about decision-making subsystems. <br><br><h3>  AI intelligence </h3><br><img src="https://habrastorage.org/files/1e1/3c5/066/1e13c5066c584b6da152ec789ceeea60.jpg" align="left" title="Sailor Nabegailo">  The logic of the cell opening system is quite simple - we choose a move (the move may not be a single move, but consist of many moves), which will increase the evaluation function.  At the same time, each cell is assigned a certain weight, which is taken into account in the evaluation function. <br><br>  The closer a cell is to the player‚Äôs base cell, the higher its weight.  As the base cell of the player, a cell is selected in the middle of its coast (landing cell), but here you can experiment. <br><br><img src="https://habrastorage.org/files/7b7/c33/213/7b7c332130bb408fa60491b7b7186176.jpg"><br>  <sup>Cell weights when opening from the point of view of a white player on the first move.</sup> <br><br>  Naturally, if between us and the chest for 5 gold coins there is one undiscovered cell, the value of its discovery increases dramatically.  From the point of view of other subsystems, I recall, it is considered as empty before the opening.  The cage with the enemy and the cells under its attack lose weight dramatically. <br><br>  With an equal (or comparable to about 5%) weight of two cells side by side (for example, at the beginning), we make a random move.  By the way, the principle of randomness with the similarity of weight coefficients introduces a completely wild drive and unpredictability of AI into the game - this is very cool for players, but completely wild for debugging - we could not always correctly repeat the game to see where AI got confused - it was, roughly speaking, write your own random number generator, and not get acquainted with the peculiarities of the work of each on separate devices. <br><br>  Next, the task is to open cells with a greater weight in a smaller number of moves.  The more gold still remains on the map, the more votes the intelligence gets when normalizing the overall evaluation function.  That is, the endgame intelligence is used by experienced pirates less and less, to the forefront of the problem of the delivery of coins and their push-ups from the enemy. <br><br><h3>  Coin collecting system </h3><br><img src="https://habrastorage.org/files/0b0/da2/64c/0b0da264c4ec4eda8a2300f4b30d1852.jpg" align="left" title="Comrade Sergeant Major Ensign Khvavaykin">  The system of collecting coins is the most difficult in terms of processor load.  Full brute force on client devices is impossible, therefore, simplifying, the branch and bound method is used, which is based on selective depth miscalculations. <br><br>  In this case, the calculations are not based on a separate move, but on an action, which may include sequences of moves of various lengths.  For example, when you need to sail a ship to any possible point, or go pirate on a cage with a coin.  Actions can be combined into more complex actions, for example, you can take a ship to a coin directly by the shortest route (not necessarily on foot, a cannon, a balloon or a horse are also counted), but you can take it to the coast, where a ship can be fitted by another pirate.  Search in depth searches available moves a few steps forward and selects the best.  The current version for iPad 2 and iPhone 4 uses a depth of 2-3 moves, depending on the situation, on top devices it can be considered to be 4 turns with a wait of less than a second.  There is much to optimize according to the logic of the algorithm, but so far there is enough depth for the bots to play well at the tactical level. <br><br>  At the same time, the pirate still avoids undesirable encounters with enemies.  And considers where they can go at a given depth of the forecast. <br><br>  Undiscovered cells are not counted in the calculation of the path when a player carries a coin to the ship in order to reduce the risks of its ‚Äúloss‚Äù.  When calculating the path in other cases, it can be laid in closed cells with the assumption that they will be empty.  After the ‚Äúintelligence‚Äù of the cell, the navigation graph is completed. <br><br><img src="https://habrastorage.org/files/11d/551/2e1/11d5512e16794e02a74f350a83200ad3.jpg"><br>  <sup>Piastrrry!</sup> <br><br><h3>  Rescue subsystem </h3><br><img src="https://habrastorage.org/files/3ac/33c/02f/3ac33c02f3284d75b672a3a3e57fb386.jpg" align="left" title="Woman on the ship!">  A pirate can fall into the water (then you need to fit the ship with another pirate to save him), can fall into a trap (need a second friend to pull him out), can be eaten by a cannibal (have to resurrect him in an aboriginal fortress) or get into an endless cycle (for example, the arrow on the crocodile), which will lead to the fact that he will go crazy and die.  For the resurrection, too, need a fortress and an aboriginal. <br><br>  So, the logic of the pirates recovery system is also not as simple as it may seem.  The system takes into account not only completely dead pirates, but operates with the concept of "inactive pirate."  At the same time, the pirate on the Roma is not considered inactive, since he is able to heal himself by the next day‚Äôs lunch. <br><br>  Assessing the need for recovery, the system takes into account not only the number of inactive pirates of the player, but also the number of inactive pirates of opponents and an ally.  In the case of deciding whether to restore, the system chooses from the possible recovery options by simply comparing the number of primitive moves, taking into account the position of the enemy. <br><br>  Simplifying, if our friend fell into a trap in the next cell, the evaluation function assigns 10 difficulty points to recovery.  And if in two cells - the complexity grows nonlinearly, for example, it already becomes 30 points.  Further, based on the primary possibility of recovery, hypotheses are discarded that are not needed in the current game situation (so as not to count the whole complex every turn when you need to do other things).  The importance of recovery grows depending on the game situation, the number of our active pirates and the ease of recovery. <br><br>  If the recovery is still with high probability, we consider the possibilities - for example, to swim up the player to the ship or be killed about someone else‚Äôs ship and occupy the fortress in N moves. <br><br><h3>  Attack subsystem </h3><br><img src="https://habrastorage.org/files/d64/a46/feb/d64a46feba854bbcb56dc1c5aa85f467.jpg" title="Captain Vorobyov.  Fedor Vorobev." align="left">  The idea of ‚Äã‚Äãan enemy pirates' attack system is similar to the classic task of calculating moves, for example, in chess.  We have a certain evaluation function that takes into account how many potential pirates can attack enemy pirates (yes, the fortress and the aboriginal here, of course, greatly change the situation).  To make a decision about the attack, the system also calculates the depth, but it does not operate with actions, but with primitive steps.  Moreover, at each level, several positions are selected with the best ratings.  The complete miscalculation includes the miscalculation of all the pirates of all players with control over the coins (how many coins are currently ‚Äúprotected‚Äù by the pirate, as well as their proximity to the ship).  As a result, we get a decision tree, on the basis of which the final decision on the attack is already made. <br><br>  Despite the miscalculation in depth and the presence of actions performed, each move is a new assessment.  As a result, the pirate can quickly change his action depending on the changing situation on the playing field.  For the miscalculation, pairs of pirates are selected according to the ‚ÄúI am alone and opponents‚Äù scheme for 2 turns deep into the minimum. <br><br>  The tactical block takes into account the players' influence on the cells of the field and their influence on the gold on the field - this is a question of the safety of our operations and the potential benefits from the fact that we rush into other people.  The main question is how much the pirate controls gold in the perspective of several moves.  Again, if our pirates directly control the gold or virtually control the gold after 2 turns, then the priority in the voice will be given to the coin-pulling system, most likely.  Because AI knows what's better tit in the hands.  Also, the expediency of including this system directly depends on the need to clear the space for security - if the enemies are not close, it does not even turn on after the fact. <br><br><h3>  Total </h3><br>  The game has a cooperative mode.  At the same time, it turned out to be very convenient with him - he does not break the logic of the work of any system, being, in its essence, just an extension and a superstructure over the main logic.  Allied pirates and ship, with a few exceptions, are considered as their own.  The only important point - the balloon sends the pirate strictly to your ship, but it was decided to evaluate it very simply. <br><br>  All systems operate practically independently of each other.  Each of them, based on the navigation system, determines the available solutions and makes an assessment.  The system of decision-making on the basis of the obtained estimates and taking into account the context chooses the best option.  It is important that the proposed solutions did not worsen the position of the player on the field.  If there are no such solutions at the moment (by analogy with hopelessness), the system will choose any option to attack the enemy, even if it worsens the position.  Yes, yes, here we recalled that AI contest about silent animals, where Russian cows ate alien grass. <br><br><img src="https://habrastorage.org/files/8dd/eec/adb/8ddeecadb6624cc3b20f97939ec18310.jpg"><br>  <sup>Screenshot debug mode.</sup>  <sup>Blue is the current position, yellow is the selected best move.</sup>  <sup>Output format: number of pirates (minus means opponents) |</sup>  <sup>difference attacking a cage of their own and others protecting it |</sup>  <sup>the prospect of cells for collecting gold |</sup>  <sup>total cell count.</sup>  <sup>On the screen you can see that the yellow one decided to go diagonally and occupy a cage with which you can attack another cage with enemy pirates and with a reserve of gold.</sup>  <sup>The position has improved from -20.61 to -12.37.</sup> <br><br><h3>  Implementation and tests </h3><br>  Here I will quote: <br><blockquote>  The first was implemented navigation system.  On many projects, this task is solved in approximately the same way; it was only necessary to take into account the specifics of the Jackal (it was necessary, for example, to refine the algorithms after it turned out that the fallen coins lay in the subslots of the ‚Äúlong‚Äù cells, and not on the cell as a whole). <br><br>  Having the navigation, an attempt was made to follow the path of least resistance and implement the usual algorithm for calculating the depth.  It quickly became clear that nothing good would come of it.  Too many possible moves for each pirate.  Plus there were difficulties with the formalization of the behavior of cells of various types.  Therefore, further development was in steps.  The system of opening cells and collecting coins was made almost in parallel.  The first, of course, was completed much earlier because of its relative simplicity.  The second developed and improved until the end of development.  After them the pirates recovery system was implemented.  The attack system of the enemy pirates was done last.  In principle, it can be said that there were no particular difficulties in the process of work, after all, the experience gained earlier had an effect.  Major alterations were associated with not quite complete or misunderstanding of the rules of the game, for example, should a pirate who came to the crocodile through ice die or go back to where he came from. <br><br>  The initial testing was carried out automatically at the design stage.  The game control system itself is built in such a way that it works universally.  It was originally laid for multiplayer game features.  Any player can be controlled by one of three types of controllers: human, computer, or remote player (remote player can also be human or computer).  At any time in a game, a controller of one type can be replaced with a controller of another type (for example, a computer can take the place of a player who has fallen off the network, but subsequently a player can reconnect and return to the game).  For testing the Jackal in general and the AI, in particular, it played a very good service.  The game started with computer players and they played with themselves.  It remained only to monitor their behavior and collect statistics.  The game now uses an SFMT random number generator, which allowed it to be replayed along the moves, if at some stage a moment arose in it that required debugging or modification.  This technique is very convenient to identify and localize many problems, for example, the eternal cycles in the navigation of pirates, illogical or incorrect actions and so on.  The second stage of testing was testing in a game with real people, which was built on similar principles, however, a specially developed system of logging game events was used to play the game session, recording and saving all the games played on the disc.  Subsequently, the game session was simply reproduced in turns. <br><br>  There are ideas and plans to create, for example, different behavioral types of pirates - cowardly, aggressive, researcher and others.  I would like to implement different levels of difficulty for players with different levels of training. </blockquote><br><br>  Actually, in the comments you can ask questions <a href="http://habrahabr.ru/users/idyury/" class="user_link">idyury</a> on the code and mathematics.  Realization of all this <a href="https://itunes.apple.com/ru/app/jackal/id541366198%3Fl%3Dru%26mt%3D8">here in Appstore</a> , only for iPad for now. <br><br>  And yes, AI is very lively lacking tactics experienced players like situations where a chest with 5 coins in two cells from the ship.  An experienced player passes by and leaves pulling at the end of the game, but in our AI the ‚Äúgreedy‚Äù gets more votes and starts pulling, sticking for at least 20 moves, which could give a huge strategic advantage.  But, of course, if we increase the depth of the situation on the field, the game will go slower, but more fun in terms of complexity. <br><br>  In general, I just wanted to say that schizophrenia is cool.  Sometimes. </div><p>Source: <a href="https://habr.com/ru/post/270529/">https://habr.com/ru/post/270529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270519/index.html">Symfony2 two-factor authentication with a certificate</a></li>
<li><a href="../270521/index.html">Docker 1.9 + Weave 1.2.1 bridge mode</a></li>
<li><a href="../270523/index.html">Colocation in theory and practice</a></li>
<li><a href="../270525/index.html">Cryptographers invent new ways to blackmail users</a></li>
<li><a href="../270527/index.html">Official Firebird 3.0 Release Candidate 1 and Beta Documentation for Firebird 3.0</a></li>
<li><a href="../270531/index.html">About Parboiled (Part 2)</a></li>
<li><a href="../270537/index.html">How I became an android developer without a core education, simultaneously hindering concrete</a></li>
<li><a href="../270541/index.html">How to calculate the range of communication equipment Ubiquiti. New version of the calculator AirLink</a></li>
<li><a href="../270543/index.html">TensorFlow: Google's machine learning, now smarter for everyone</a></li>
<li><a href="../270545/index.html">Declarative C ++ programming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>