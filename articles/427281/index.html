<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of interface classes in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Interface classes are widely used in C ++ programs. But, unfortunately, when implementing solutions based on interface classes, mistakes are often mad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of interface classes in C ++</h1><div class="post__text post__text-html js-mediator-article"><hr><p>  <i>Interface classes are widely used in C ++ programs.</i>  <i>But, unfortunately, when implementing solutions based on interface classes, mistakes are often made.</i>  <i>The article describes how to properly design the interface classes, considered several options.</i>  <i>The use of smart pointers is described in detail.</i>  <i>An example implementation of an exception class and a collection class template based on interface classes is given.</i> </p><hr><br><a name="habracut"></a><br><h1>  Table of contents </h1><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text">  <a href="https://habr.com/ru/post/427281/">Introduction</a> <br>  <a href="https://habr.com/ru/post/427281/">1. Special member functions, creating and deleting objects</a> <br>  <a href="https://habr.com/ru/post/427281/">1.1.</a>  <a href="https://habr.com/ru/post/427281/">Special member functions</a> <br>  <a href="https://habr.com/ru/post/427281/">1.2.</a>  <a href="https://habr.com/ru/post/427281/">Creating and deleting objects - basic details</a> <br>  <a href="https://habr.com/ru/post/427281/">1.3.</a>  <a href="https://habr.com/ru/post/427281/">Destructor access level</a> <br>  <a href="https://habr.com/ru/post/427281/">1.4.</a>  <a href="https://habr.com/ru/post/427281/">Creation and deletion in one module</a> <br>  <a href="https://habr.com/ru/post/427281/">1.5.</a>  <a href="https://habr.com/ru/post/427281/">Polymorphic deletion</a> <br>  <a href="https://habr.com/ru/post/427281/">1.6.</a>  <a href="https://habr.com/ru/post/427281/">Deletion on incomplete class declaration</a> <br>  <a href="https://habr.com/ru/post/427281/">2. Pure virtual functions and abstract classes</a> <br>  <a href="https://habr.com/ru/post/427281/">2.1.</a>  <a href="https://habr.com/ru/post/427281/">Pure virtual functions</a> <br>  <a href="https://habr.com/ru/post/427281/">2.2.</a>  <a href="https://habr.com/ru/post/427281/">Abstract classes</a> <br>  <a href="https://habr.com/ru/post/427281/">2.3.</a>  <a href="https://habr.com/ru/post/427281/">Pure virtual destructor</a> <br>  <a href="https://habr.com/ru/post/427281/">3. Interface classes</a> <br>  <a href="https://habr.com/ru/post/427281/">3.1.</a>  <a href="https://habr.com/ru/post/427281/">Implementations</a> <br>  <a href="https://habr.com/ru/post/427281/">3.2.</a>  <a href="https://habr.com/ru/post/427281/">Object creation</a> <br>  <a href="https://habr.com/ru/post/427281/">3.3.</a>  <a href="https://habr.com/ru/post/427281/">Deleting an object</a> <br>  <a href="https://habr.com/ru/post/427281/">3.3.1.</a>  <a href="https://habr.com/ru/post/427281/">Using the delete operator</a> <br>  <a href="https://habr.com/ru/post/427281/">3.3.2.</a>  <a href="https://habr.com/ru/post/427281/">Using a special virtual function</a> <br>  <a href="https://habr.com/ru/post/427281/">3.3.3.</a>  <a href="https://habr.com/ru/post/427281/">Using the external function</a> <br>  <a href="https://habr.com/ru/post/427281/">3.3.4.</a>  <a href="https://habr.com/ru/post/427281/">Automatic deletion using the smart pointer</a> <br>  <a href="https://habr.com/ru/post/427281/">3.4.</a>  <a href="https://habr.com/ru/post/427281/">Other options for controlling the lifetime of an instance of an implementation class</a> <br>  <a href="https://habr.com/ru/post/427281/">3.5.</a>  <a href="https://habr.com/ru/post/427281/">Copy semantics</a> <br>  <a href="https://habr.com/ru/post/427281/">3.6.</a>  <a href="https://habr.com/ru/post/427281/">Interface Class Designer</a> <br>  <a href="https://habr.com/ru/post/427281/">3.7.</a>  <a href="https://habr.com/ru/post/427281/">Bidirectional interaction</a> <br>  <a href="https://habr.com/ru/post/427281/">3.8.</a>  <a href="https://habr.com/ru/post/427281/">Smart Pointers</a> <br>  <a href="https://habr.com/ru/post/427281/">3.9.</a>  <a href="https://habr.com/ru/post/427281/">Constant member functions</a> <br>  <a href="https://habr.com/ru/post/427281/">3.10.</a>  <a href="https://habr.com/ru/post/427281/">COM interfaces</a> <br>  <a href="https://habr.com/ru/post/427281/">3.11.</a>  <a href="https://habr.com/ru/post/427281/">Interface Classes and Libraries</a> <br>  <a href="https://habr.com/ru/post/427281/">4. Example of interface class and its implementation</a> <br>  <a href="https://habr.com/ru/post/427281/">4.1.</a>  <a href="https://habr.com/ru/post/427281/">Interface class</a> <br>  <a href="https://habr.com/ru/post/427281/">4.2.</a>  <a href="https://habr.com/ru/post/427281/">Implementation class</a> <br>  <a href="https://habr.com/ru/post/427281/">4.3.</a>  <a href="https://habr.com/ru/post/427281/">Standard Smart Pointers</a> <br>  <a href="https://habr.com/ru/post/427281/">4.3.1.</a>  <a href="https://habr.com/ru/post/427281/">Client-side creation</a> <br>  <a href="https://habr.com/ru/post/427281/">4.3.2.</a>  <a href="https://habr.com/ru/post/427281/">Creation on the implementation side</a> <br>  <a href="https://habr.com/ru/post/427281/">4.4.</a>  <a href="https://habr.com/ru/post/427281/">Alternative base class implementation</a> <br>  <a href="https://habr.com/ru/post/427281/">5. Exceptions and collections implemented using interface classes</a> <br>  <a href="https://habr.com/ru/post/427281/">5.1 Exceptions</a> <br>  <a href="https://habr.com/ru/post/427281/">5.2 Collections</a> <br>  <a href="https://habr.com/ru/post/427281/">6. Interface classes and wrapper classes</a> <br>  <a href="https://habr.com/ru/post/427281/">7. Results</a> <br>  <a href="https://habr.com/ru/post/427281/">Bibliography</a> <br></div></div><br><a name="id-introdaction"></a><br><h1>  Introduction </h1><br><p>  An interface class is a class that has no data and consists mainly of pure virtual functions.  This solution allows you to completely separate the implementation from the interface ‚Äî the client uses the interface class ‚Äî a derived class is created elsewhere, in which pure virtual functions are redefined and the factory function is defined.  Implementation details are completely hidden from the client.  This way, true encapsulation is implemented, which is not possible when using a regular class.  You can read about interface classes with Scott Meyers [Meyers2].  Interface classes are also called protocol classes. </p><br><p>  The use of interface classes allows to weaken the dependencies between different parts of the project, which simplifies team development, reduces the compilation / assembly time.  Interface classes make it easier to implement flexible, dynamic solutions when modules are loaded selectively during execution.  Using interface classes as a library interface (API) (SDK) makes it easier to solve binary compatibility problems. </p><br><p>  Interface classes are used quite widely, with their help they implement the library interface (API) (SDK), the plug-in interface, and much more.  Many Gang of Four [GoF] patterns are naturally implemented using interface classes.  Interface classes include COM interfaces.  But, unfortunately, when implementing solutions based on interface classes, errors are often made.  Let's try to clarify this issue. </p><br><a name="id-1"></a><br><h1>  1. Special member functions, creating and deleting objects </h1><br><p>  This section briefly describes a number of C ++ features that you need to know in order to fully understand the solutions offered for the interface classes. </p><br><a name="id-1-1"></a><br><h2>  1.1.  Special member functions </h2><br><p>  If the programmer has not defined the class member functions from the following list ‚Äî the default constructor, the copy constructor, the copy assignment operator, the destructor ‚Äî then the compiler can do it for him.  C ++ 11 added a relocation constructor and a move assignment operator to this list.  These member functions are called special member functions.  They are generated only if they are used, and additional conditions specific to each function are fulfilled.  Note that this usage may be quite hidden (for example, when implementing inheritance).  If the requested function cannot be generated, an error is generated.  (With the exception of moving operations, they are replaced by copying ones.) The member functions generated by the compiler are public and embedded. </p><br><p>  Special member functions are not inherited, if a special member function is required in a derived class, the compiler will always try to generate it, the presence of the corresponding member function in the base class determined by the programmer does not affect this. </p><br><p> The programmer can prohibit the generation of special member functions, in C ++ 11, you must apply the construction <code>"=delete"</code> when declaring, in C ++ 98, declare the corresponding member function closed and not define it.  When inheriting classes, the prohibition of the generation of a special member function made in the base class applies to all derived classes. </p><br><p>  If the programmer is satisfied with the member functions generated by the compiler, then in C ++ 11 he can designate this explicitly, rather than simply dropping the declaration.  To do this, the declaration should use the construction <code>"=default"</code> , while the code is better readable and additional features related to access level control appear. </p><br><p>  Details about special member functions can be found in [Meyers3]. </p><br><a name="id-1-2"></a><br><h2>  1.2.  Creating and deleting objects - basic details </h2><br><p>  Creating and deleting objects using <code>new/delete</code> operators is a typical two-in-one operation.  When you call <code>new</code> , memory is first allocated for the object.  If the selection is successful, the constructor is called.  If the constructor throws an exception, the allocated memory is freed.  When you call the <code>delete</code> operator, everything happens in reverse order: first the destructor is called, then the memory is freed.  The destructor should not throw exceptions. </p><br><p>  If the <code>new</code> operator is used to create an array of objects, memory is first allocated for the entire array.  If the selection is successful, the default constructor is called for each element of the array, starting from zero.  If any constructor throws an exception, then for all created elements of the array, the destructor is called in the reverse order of the constructor call, then the allocated memory is released.  To delete an array, you must call the operator <code>delete[]</code> (called the operator <code>delete</code> for arrays), while for all elements of the array, the destructor is called in the reverse order of the constructor call, then the allocated memory is freed. </p><br><p>  Attention!  You must call the correct form of the <code>delete</code> operator, depending on whether a single object or an array is deleted.  This rule must be observed strictly, otherwise you can get an undefined behavior, that is, anything can happen: memory leaks, abnormal termination, etc.  See [Meyers2] for details. </p><br><p>  Standard memory allocation functions, when it is impossible to satisfy the request, throw an exception of the type <code>std::bad_alloc</code> . </p><br><p>  It is safe to apply any form of the <code>delete</code> operator to a null pointer. </p><br><p>  In the above description, you need to make one clarification.  For the so-called trivial types (built-in types, C-style structures), the constructor may not be called, and the destructor does not do anything in any case.  See also section 1.6. </p><br><a name="id-1-3"></a><br><h2>  1.3.  Destructor access level </h2><br><p>  When the <code>delete</code> operator is applied to a pointer to a class, the destructor of this class must be available at the point of the <code>delete</code> call.  (There is some exception to this rule, discussed in Section 1.6.) Thus, by making the destructor protected or closed, the programmer prohibits the use of the <code>delete</code> operator where the destructor is not available.  Recall that if a destructor is not defined in the class, the compiler will do it itself, and this destructor will be open (see section 1.1). </p><br><a name="id-1-4"></a><br><h2>  1.4.  Creation and deletion in one module </h2><br><p>  If the <code>new</code> operator has created an object, then the call to the <code>delete</code> operator to <code>delete</code> it must be in the same module.  Figuratively speaking, "put where you took."  This rule is well known, see, for example, [Sutter / Alexandrescu].  If this rule is violated, a ‚Äúdiscrepancy‚Äù of the functions of allocating and freeing memory may occur, which, as a rule, leads to the program termination. </p><br><a name="id-1-5"></a><br><h2>  1.5.  Polymorphic deletion </h2><br><p>  If a polymorphic hierarchy of classes is being designed, the instances of which are deleted using the <code>delete</code> operator, then the base class must have an open virtual destructor, this guarantees that the destructor of the actual object type is called when the <code>delete</code> operator is applied to the pointer to the base class.  If this rule is violated, a call to the base class destructor may occur, due to which resource leakage is possible. </p><br><a name="id-1-6"></a><br><h2>  1.6.  Deletion on incomplete class declaration </h2><br><p>  Certain problems can be created by the ‚Äúomnivorous nature‚Äù of the operator <code>delete</code> , it can be applied to a pointer of type <code>void*</code> or to a pointer to a class that has an incomplete (proactive) declaration.  In this case, the error does not occur, simply the call to the destructor is skipped, only the function of freeing the memory is called.  Consider an example: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><p>  This code is compiled, even if the full declaration of class <code>X</code> not available at the point of the call to <code>delete</code> .  True, when compiling (Visual Studio), a warning is issued: </p><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> </p> <br><p>  If there is an <code>X</code> implementation and <code>CreateX()</code> , then the code is assembled, if <code>CreateX()</code> returns a pointer to the object created by the <code>new</code> operator, the <code>Foo()</code> call succeeds, and the destructor is not called.  It is clear that this can lead to a drain on resources, so once again the need to carefully consider warnings. </p><br><p>  This situation is not contrived, it can easily arise when using classes such as smart pointer or classes-descriptors.  Scott Meyers deals with this problem in [Meyers3]. </p><br><a name="id-2"></a><br><h1>  2. Pure virtual functions and abstract classes </h1><br><p>  The concept of interface classes is based on such C ++ concepts as pure virtual functions and abstract classes. </p><br><a name="id-2-1"></a><br><h2>  2.1.  Pure virtual functions </h2><br><p>  A virtual function declared using the <code>"=0"</code> construct is called purely virtual. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...    virtual void Foo() = 0; };</span></span></code> </pre> <br><p>  Unlike a conventional virtual function, a pure virtual function can not be defined (except for the destructor, see section 2.3), but it must be redefined in one of the derived classes. </p><br><p>  Pure virtual functions can be defined.  The Sutter coat of arms offers several useful uses for this feature [Shutter]. </p><br><a name="id-2-2"></a><br><h2>  2.2.  Abstract classes </h2><br><p>  An abstract class is a class that has at least one purely virtual function.  A class derived from an abstract class and not redefining at least one purely virtual function will also be abstract.  The C ++ standard prohibits creating instances of an abstract class; only instances of derived non-abstract classes can be created.  Thus, an abstract class is created to be used as a base class.  Accordingly, if a constructor is defined in an abstract class, then it does not make sense to make it open, it must be protected. </p><br><a name="id-2-3"></a><br><h2>  2.3.  Pure virtual destructor </h2><br><p>  In some cases, it is advisable to make a destructor purely virtual.  But this solution has two features. </p><br><ol><li>  A pure virtual destructor must be defined.  (Typically, the default definition is used, that is, using the <code>"=default"</code> construct.) The destructor of the derived class calls the destructors of the base classes along the entire inheritance chain and, therefore, the queue is guaranteed to reach the root - a pure virtual destructor. </li><li>  If the programmer has not redefined the pure virtual destructor in the derived class, the compiler will do it for him (see Section 1.1).  Thus, a class derived from an abstract class with a purely virtual destructor may lose its abstractness without explicitly redefining the destructor. </li></ol><br><p>  An example of using a pure virtual destructor can be found in section 4.4. </p><br><a name="id-3"></a><br><h1>  3. Interface classes </h1><br><p>  An interface class is an abstract class that has no data and consists mainly of pure virtual functions.  Such a class may have ordinary virtual functions (not purely virtual), for example, a destructor.  There may also be static member functions, such as factory functions. </p><br><a name="id-3-1"></a><br><h2>  3.1.  Implementations </h2><br><p>  The implementation of the interface class will be called the derived class in which pure virtual functions are redefined.  There can be several implementations of the same interface class, with two possible schemes: horizontal, when several different classes inherit the same interface class, and vertical, when the interface class is the root of the polymorphic hierarchy.  Of course, there may be hybrids. </p><br><p>  The key point of the concept of interface classes is the complete separation of the interface from the implementation - the client works only with the interface class, the implementation is not available to it. </p><br><a name="id-3-2"></a><br><h2>  3.2.  Object creation </h2><br><p>  The inaccessibility of the implementation class causes certain problems when creating objects.  The client must create an instance of the implementation class and get a pointer to the interface class through which the object will be accessed.  Since the implementation class is not available, the constructor cannot be used, so the factory function defined on the implementation side is used.  This function usually creates an object using the <code>new</code> operator and returns a pointer to the created object, which is cast to a pointer to an interface class.  A factory function can be a static member of an interface class, but this is not necessary; for example, it can be a member of a special factory class (which, in turn, can be an interface class itself) or a free function.  The factory function can return not an intelligent pointer to the interface class, but an intelligent one.  This option is discussed in sections 3.3.4 and 4.3.2. </p><br><a name="id-3-3"></a><br><h2>  3.3.  Deleting an object </h2><br><p>  Object deletion is an extremely important operation.  In case of an error, there is either a memory leak or a double deletion, which usually leads to a program crash.  Below this issue is considered in as much detail as possible, with much attention being paid to the prevention of erroneous actions by the client. </p><br><p>  There are four main options: </p><br><ol><li>  Use the <code>delete</code> operator. </li><li>  Using a special virtual function. </li><li>  Using the external function. </li><li>  Automatic deletion using the smart pointer. </li></ol><br><a name="id-3-3-1"></a><br><h3>  3.3.1.  Using the <code>delete</code> operator <br></h3><br><p>  To do this, you must have an open virtual destructor in the interface class.  In this case, the operator <code>delete</code> , called for a pointer to the interface class on the client side, provides a call to the destructor of the implementation class.  This option may work, but it is difficult to recognize successful ones.  We receive calls to the <code>new</code> and <code>delete</code> operators on opposite sides of the barrier, <code>new</code> on the implementation side, <code>delete</code> on the client side.  And if the implementation of the interface class is done in a separate module (which is quite a common thing), then we get a violation of the rule in section 1.4. </p><br><a name="id-3-3-2"></a><br><h3>  3.3.2.  Using a special virtual function </h3><br><p>  Another option is more progressive: the interface class must have a special virtual function that deletes the object.  Such a function, in the end, comes down to calling <code>delete this</code> , but this happens already on the implementation side.  Such a function can be called differently, for example, <code>Delete()</code> , but other options are used: <code>Release()</code> , <code>Destroy()</code> , <code>Dispose()</code> , <code>Free()</code> , <code>Close()</code> , etc.  In addition to observing the rule in section 1.4, this option has several additional benefits. </p><br><ol><li>  Allows the use of user-defined memory allocation / release functions for the implementation class. </li><li>  Allows you to implement a more complex scheme for controlling the lifetime of the object of implementation, for example, using the reference counter. </li></ol><br><p>  In this embodiment, an attempt to delete an object using the <code>delete</code> operator can be compiled and even executed, but this is an error.  To prevent it, it is enough to have an empty or purely virtual protected destructor in the interface class (see section 1.3).  Note that the use of the <code>delete</code> operator can be quite strongly disguised, for example, the standard smart pointers to delete an object by default use the <code>delete</code> operator and the corresponding code is deeply buried in their implementation.  The protected destructor allows to detect all such attempts at the compilation stage. </p><br><a name="id-3-3-3"></a><br><h3>  3.3.3.  Using the external function </h3><br><p>  This option may involve a certain symmetry of the procedures for creating and deleting an object, but in reality it has no advantages over the previous version, but there are many additional problems.  This option is not recommended for use and is not considered further. </p><br><a name="id-3-3-4"></a><br><h3>  3.3.4.  Automatic deletion using the smart pointer </h3><br><p>  In this case, the factory function returns not the raw pointer to the interface class, but the corresponding smart pointer.  This smart pointer is created on the implementation side and encapsulates an object remover that automatically deletes the implementation object when the smart pointer (or its last copy) goes out of scope on the client side.  In this case, a special virtual function may not be necessary to delete the implementation object, but the protected destructor is still needed; it is necessary to prevent the erroneous use of the <code>delete</code> operator.  (However, it should be noted that the probability of such an error is markedly reduced.) This option is discussed in more detail in Section 4.3.2. </p><br><a name="id-3-4"></a><br><h2>  3.4.  Other options for controlling the lifetime of an instance of an implementation class </h2><br><p>  In some cases, the client may receive a pointer to the interface class, but not own it.  Managing the lifetime of the object of implementation is completely on the implementation side.  For example, an object can be a static singleton object (such a decision is typical for factories).  Another example is related to bidirectional interaction, see section 3.7.  The client should not delete such an object, but a protected destructor for such an interface class is needed, it is necessary to prevent the erroneous use of the <code>delete</code> operator. </p><br><a name="id-3-5"></a><br><h2>  3.5.  Copy semantics </h2><br><p>  For an interface class, creating a copy of an implementation object using a copy constructor is impossible, so if copying is required, then the class must have a virtual function that creates a copy of the implementation object and returns a pointer to the interface class.  Such a function is often called a virtual constructor, and its traditional name is <code>Clone()</code> or <code>Duplicate()</code> . </p><br><p>  Using the copy assignment operator is not prohibited, but cannot be considered a good idea.  The copy assignment operator is always paired; it must be paired with the copy constructor.  The operator generated by the compiler by default is meaningless, it does nothing.  Theoretically, you can declare an assignment statement as purely virtual and then redefine, but virtual assignment is not a recommended practice, details can be found in [Meyers1].  Moreover, the assignment looks very unnatural: access to objects of the implementation class is usually done through a pointer to the interface class, so the assignment will look like this: </p><br><pre> <code class="cpp hljs">* = *;</code> </pre> <br><p>  It is best to prohibit the assignment operator and, if necessary, similar semantics, to have a corresponding virtual function in the interface class. </p><br><p>  There are two ways to prohibit assignment. </p><br><ol><li>  Declare the assignment operator to be deleted ( <code>=delete</code> ).  If the interface classes form a hierarchy, then this is sufficient to do in the base class.  The disadvantage of this method is that it affects the class of implementation, the prohibition applies to it. </li><li>  Declare a protected assignment statement with a default definition ( <code>=default</code> ).  This does not affect the implementation class, but in the case of a hierarchy of interface classes, such an declaration must be made in each class. </li></ol><br><a name="id-3-6"></a><br><h2>  3.6.  Interface Class Designer </h2><br><p>  Often, the interface class constructor is not declared.  In this case, the compiler generates a default constructor, which is necessary to implement inheritance (see Section 1.1).  This constructor is open, although it is enough that it is protected.  If in the interface class the copying constructor is declared remote ( <code>=delete</code> ), then the generation of the default constructor by the compiler is suppressed, and you must explicitly declare such a constructor.  It is natural to make it protected with a default definition ( <code>=default</code> ).  In principle, the declaration of such a protected constructor can always be done.  An example is in section 4.4. </p><br><a name="id-3-7"></a><br><h2>  3.7.  Bidirectional interaction </h2><br><p>  Interface classes are useful for organizing bidirectional interaction.  If some module is available through interface classes, then the client can also create implementations of some interface classes and pass pointers to them into the module.  Through these pointers, the module can receive services from the client as well as transmit data or notifications to the client. </p><br><a name="id-3-8"></a><br><h2>  3.8.  Smart Pointers </h2><br><p>  Since access to objects of the implementation class is usually done through a pointer, it is natural to use intelligent pointers to control their lifetime.  But it should be borne in mind that if the second option of deleting objects is used, then a standard smart pointer needs to be passed a user deleter (type) or an instance of this type.  If this is not done, then the delete pointer will be used by the <code>delete</code> operator to remove the object, and the code simply will not be compiled (thanks to the protected destructor).  Standard smart pointers (including the use of custom deleters) are discussed in detail in [Josuttis], [Meyers3].  An example of using a custom remover can be found in section 4.3.1. </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the interface class supports the reference counter, then it is advisable to use not standard intelligent pointers, but specially written for such a case, it is quite easy to do. </font></font></p><br><a name="id-3-9"></a><br><h2>  3.9.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Constant member functions </font></font></h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You should carefully declare the member functions of the interface classes as const. </font><font style="vertical-align: inherit;">One of the important advantages of interface classes is the possibility of separating the interface from the implementation as completely as possible, but the limitations associated with the constancy of a member function can create problems when developing an implementation class.</font></font></p><br><a name="id-3-10"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.10. </font><font style="vertical-align: inherit;">COM interfaces</font></font></h2><br><p> COM-    ,     ,  COM ‚Äî      ,  COM-     ,   C,    ,   .  COM-  C++      ,   COM. </p><br><a name="id-3-11"></a><br><h2>  3.11.     </h2><br><p>         (API)    (SDK).       .    -,      -,           .     ,     (Windows DLL),     :  -.          .        ,  ,       .     <code>LoadLibrary()</code>      ,    -,       . </p><br><a name="id-4"></a><br><h1> 4.       </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>       ,      . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Delete() = 0; //      IBase&amp; operator=(const IBase&amp;) = delete; //   };</span></span></code> </pre> <br><p>    . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IActivatable</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IBase { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~IActivatable() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public:    virtual void Activate(bool activate) = 0;    static IActivatable* CreateInstance(); // - };</span></span></code> </pre> <br><p> ,         ,     .     ,           <code>IBase</code> .     ,            (.  1.3).       ,       . </p><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IActivatable { <span class="hljs-comment"><span class="hljs-comment">// ... private:    Activator(); protected:    ~Activator(); public:    void Delete() override;    void Activate(bool activate) override;    friend IActivatable* IActivatable::CreateInstance(); }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Delete() { delete this; } void Activator::Activate(bool activate) {/* ... */} IActivatable* IActivatable::CreateInstance() {    return static_cast&lt;IActivatable*&gt;(new Activator()); }</span></span></code> </pre> <br><p>      , ,        ,  -  ,         . </p><br><a name="id-4-3"></a><br><h2>  4.3.    </h2><br><a name="id-4-3-1"></a><br><h3> 4.3.1.     </h3><br><p>           . -   (     <code>IBase</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDeleter</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IBase* p)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ p-&gt;Delete(); } };</code> </pre> <br><p>  <code>std::unique_ptr&lt;&gt;</code> -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> ‚Äî  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;I, BaseDeleter&gt;;</code> </pre> <br><p> ,   ,  -   ,  <code>UniquePtr</code>    . </p><br><p>   -: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> ‚Äî  - </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateInstance</span></span></span><span class="hljs-class">() {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(I::CreateInstance()); }</code> </pre> <br><p>        : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">&gt; // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class"> ‚Äî  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UniquePtr</span></span></span><span class="hljs-class">&lt;I&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToPtr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">I</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">) {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UniquePtr&lt;I&gt;(p); }</code> </pre> <br><p>  <code>std::shared_ptr&lt;&gt;</code>    <code>std::unique_ptr&lt;&gt;</code> ,   ,  <code>std::shared_ptr&lt;&gt;</code>   .      <code>Activator</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un1 = CreateInstance&lt;IActivatable&gt;(); un1-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> un2 = ToPtr(IActivatable::CreateInstance()); un2-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh = CreateInstance&lt;IActivatable&gt;(); sh-&gt;Activate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><p>          (     ‚Äî -): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IActivatable&gt; sh2(IActivatable::CreateInstance());</code> </pre> <br><p>     <code>std::make_shared&lt;&gt;()</code> ,      (    ). </p><br><p>    :          ,     .     :     ,  - .     4.4. </p><br><a name="id-4-3-2"></a><br><h3>  4.3.2.     </h3><br><p>       .           -.   <code>std::shared_ptr&lt;&gt;</code>         ,    ,      (         ).     <code>std::shared_ptr&lt;&gt;</code> (  )  -  ,           <code>delete</code>     .  <code>std::shared_ptr&lt;&gt;</code> -       (   )   -      .        . </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class IActivatable; using ActPtr = std::shared_ptr&lt;IActivatable&gt;; //   class IActivatable { protected:    virtual ~IActivatable() = default; //      IActivatable&amp; operator=(const IActivatable&amp;) = default; //   public:    virtual void Activate(bool activate) = 0;    static ActPtr CreateInstance(); // - }; //   class Activator : public IActivatable { // ... public:    Activator();  //      ~Activator(); //      void Activate(bool activate) override; }; Activator::Activator() {/* ... */} Activator::~Activator() {/* ... */} void Activator::Activate(bool activate) {/* ... */} ActPtr IActivatable::CreateInstance() {    return ActPtr(new Activator()); }</span></span></span></span></code> </pre> <br><p>  -        <code>std::make_shared&lt;&gt;()</code> : </p><br><pre> <code class="cpp hljs">ActPtr IActivatable::CreateInstance() {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Activator&gt;(); }</code> </pre> <br><p>      <code>std::unique_ptr&lt;&gt;</code> ,        , -   ,        . </p><br><a name="id-4-4"></a><br><h2>  4.4.     </h2><br><p>    C#  Java  C++    ¬´¬ª,       .        .      <code>IBase</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBase</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IBase() = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       virtual void Delete(); //   public:    IBase(const IBase&amp;) = delete;            //      IBase&amp; operator=(const IBase&amp;) = delete; //      struct Deleter        // -    {        void operator()(IBase* p) const { p-&gt;Delete(); }    };    friend struct IBase::Deleter; };</span></span></code> </pre> <br><p>     , <code>Delete()</code>    ,     . </p><br><pre> <code class="cpp hljs">IBase::~IBase() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IBase::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>      <code>IBase</code> .         <code>Delete()</code> ,              . -      <code>IBase</code> . <code>Delete()</code>  , - .     <code>Delete()</code>         ,    .       ,    4.3.1. </p><br><a name="id-5"></a><br><h1> 5.   ,      </h1><br><a name="id-5-1"></a><br><h2> 5.1  </h2><br><p>  ,    ,   ,      ,        . </p><br><p>   ,  ,    <code>IException</code>    <code>Exception</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IException</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IException() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    IException&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IException&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class"> {</span></span>    IException* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> m_Ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Exception&amp; src) : m_Ptr(src.m_Ptr-&gt;Clone()) {}    ~Exception() { m_Ptr-&gt;Delete(); }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Ptr; } };</code> </pre> <br><p>         <code>Exception</code> ,            <code>IException</code> .       ,    <code>throw</code> ,   .    <code>Exception</code>      ,      .  -      ,   . </p><br><p>  <code>Exception</code> , ,  . </p><br><p>   <code>IException</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExcImpl</span></span></span><span class="hljs-class"> :</span></span> IException {    <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">;</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_What;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_Code;    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code);    ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ExcImpl&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;    <span class="hljs-function"><span class="hljs-function">IException* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    ~ExcImpl() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">What</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Code</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; }; ExcImpl::ExcImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_What(what), m_Code(code) {} IException* ExcImpl::Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExcImpl::Delete() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* ExcImpl::What() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_What.c_str(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExcImpl::Code() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_Code; }</code> </pre> <br><p>   <code>Exception</code> : </p><br><pre> <code class="cpp hljs">Exception::Exception(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code)    : m_Ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExcImpl(what, code)) {}</code> </pre> <br><p>    ,       ‚Äî .NET ‚Äî  , ‚Äî          ,     C++/CLI.  ,        ,     ,   C++/CLI. </p><br><a name="id-5-2"></a><br><h2> 5.2  </h2><br><p>   -    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ICollect() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ICollect&lt;T&gt;* Clone() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> T&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;    ICollect&lt;T&gt;&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ICollect&lt;T&gt;&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>        ,             -,        . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICollect</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contain</span></span></span><span class="hljs-class"> {</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ICollect&lt;T&gt; CollType;    CollType* m_Coll; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> T value_type;    Contain(CollType* coll);    ~Contain(); <span class="hljs-comment"><span class="hljs-comment">//     Contain(const Contain&amp; src);    Contain&amp; operator=(const Contain&amp; src); //     Contain(Contain&amp;&amp; src);    Contain&amp; operator=(Contain&amp;&amp; src);    bool mpty() const;    int size() const;    T&amp; operator[](int ind);    const T&amp; operator[](int ind) const;    Iterator&lt;T&gt; begin();    Iterator&lt;T&gt; end(); };</span></span></code> </pre> <br><p>      .   ,       . ,      ,    ,     ,    - <code>begin()</code>  <code>end()</code> ,   .           (. [Josuttis]),         <code>for</code>   .                .            , ,      . </p><br><a name="id-6"></a><br><h1> 6.    - </h1><br><p>       .         -,      .          .   ,         ++.              ,   .NET, Java  Pyton.              .      ,  ,         .   .NET Framework     C++/CLI          C++.    <a href="https://habr.com/post/426411/"></a> . </p><br><a name="id-conclusion"></a><br><h1> 7.  </h1><br><p>      -,         . </p><br><p>         . </p><br><ol><li>   <code>delete</code> . </li><li>    . </li><li>      . </li></ol><br><p>          . </p><br><p>         ,       <code>delete</code> .                ,      . </p><br><p>    -   ,           .             ,    ,      <code>delete</code> . </p><br><p>             . </p><br><p>      ,          ,     ,  ,       . </p><br><br><a name="id-refs"></a><br><h1>  Bibliography </h1><br><div class="spoiler">  <b class="spoiler_title">List</b> <div class="spoiler_text"><p> [GoF] <br>  .,  .,  .,  .  - .  .: .  from English ‚Äî .: , 2001. </p><br><p> [Josuttis] <br> ,  .   C++:  , 2- .: .  from English ‚Äî .:  ¬´.. ¬ª, 2014. </p><br><p> [Dewhurst] <br> ,  .   C++.         .: .  from English ‚Äî .:  , 2012. </p><br><p> [Meyers1] <br> , .    C++. 35        .: .  from English ‚Äî .:  , 2000. </p><br><p> [Meyers2] <br> , .   C++. 55        .: .  from English ‚Äî .:  , 2014. </p><br><p> [Meyers3] <br> , .    C++: 42    C++11  C++14.: .  from English ‚Äî .:  ¬´.. ¬ª, 2016. </p><br><p> [Sutter] <br> , .     C++.: .  from English ‚Äî :  ¬´.. ¬ª, 2015. </p><br><p> [Sutter/Alexandrescu] <br> , . , .    ++.: .  from English ‚Äî .:  ¬´.. ¬ª, 2015. </p><br></div></div><br><br></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/427281/">https://habr.com/ru/post/427281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427271/index.html">History and experience of using machine translation. Yandex lecture</a></li>
<li><a href="../427273/index.html">Can artificial intelligence leave bookmakers out of work?</a></li>
<li><a href="../427275/index.html">Information architecture on the Internet, part 3</a></li>
<li><a href="../427277/index.html">A diffraction pattern was found in the distribution of prime numbers, approximately as in quasicrystals.</a></li>
<li><a href="../427279/index.html">CoLaboratory: Android Night #Apple</a></li>
<li><a href="../427283/index.html">How to ensure high availability in Kubernetes</a></li>
<li><a href="../427285/index.html">School on the basics of digital circuitry: Novosibirsk - Ok, Krasnoyarsk - get ready</a></li>
<li><a href="../427289/index.html">Geological 3D-modeling, logging and technaton from Aramco Innovations</a></li>
<li><a href="../427291/index.html">Traffic minimization in ASP.NET Web Forms, clickable div and periodic server polling</a></li>
<li><a href="../427293/index.html">JavaScript Design Patterns</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>