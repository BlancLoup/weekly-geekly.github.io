<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Effective resizing of images using ImageMagick</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nowadays, more and more sites are faced with the need to introduce responsive design and responsive pictures - and in this regard, there is a need to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Effective resizing of images using ImageMagick</h1><div class="post__text post__text-html js-mediator-article">  Nowadays, more and more sites are faced with the need to introduce <a href="http://www.smashingmagazine.com/2014/05/14/responsive-images-done-right-guide-picture-srcset/">responsive design</a> and <a href="http://www.smashingmagazine.com/2014/02/03/one-solution-to-responsive-images/">responsive pictures</a> - and in this regard, there is a need to effectively change the size of all pictures.  The system should work so that each user can send a picture of the desired size upon request - small for users with small screens, large ones for large screens. <br><br>  The web works fine this way, but to deliver pictures of different sizes to different users, you must first create all these pictures. <br><br>  Many tools are involved in resizing, but too often they give out large files that invalidate the performance gain that should come along with responsive pictures.  Let's take a look at how using <a href="http://imagemagick.org/">ImageMagick</a> , a command-line tool, to quickly resize images while maintaining excellent quality and getting files of small sizes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Big pictures == big problems </h4><br>  The average web page <a href="httparchive.org/interesting.php%3Fa%3DAll%26l%3DMay%252015%25202015">weighs 2 MB</a> , of which 2/3 are pictures.  Millions of people go to the Internet via 3G, or worse.  2MB sites in these cases work terribly.  Even on a fast connection, such sites can use up traffic limits.  The work of web designers and developers is to simplify and improve the user's life. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15a/9be/c28/15a9bec28a5ab3c7da92f94ffbc082ec.png" alt="image"><br><br>  Very small sites can simply save several versions of all the pictures.  But what if you have them dofiga?  For example, there may be hundreds of thousands of pictures in a store - do not manually make their variants. <br><br><h4>  Imagemagick </h4><br>  The command line utility with 25 years of experience is at the same time a full-featured image editor.  It has a huge pile of features, and among them is a quick and automatic resizing of images.  But with the default settings, files are often overly large ‚Äî sometimes larger in size than the original, although they have fewer pixels.  Now I will explain what the problem is and show you what settings are needed to solve it. <br><a name="habracut"></a><br><h4>  How image size resizing works </h4><br>  By definition, when the image is resized, the number of pixels in it changes.  If it is increased, there will be more pixels at the output than at the input;  when decreasing - the opposite.  The challenge is how best to preserve the contents of the original image with a different number of pixels. <br><br>  Zooming in on pictures is easier, so let's start with it.  Consider a picture with a square of 4x4 pixels, which we want to double to 8x8.  In fact, we take this picture and pull on a new grid - this is called resampling (discretization).  To do a 4x4 picture at 8x8, you need to insert 48 extra pixels somewhere.  They must have some color - the process of its selection is called interpolation.  When sampling, an algorithm that chooses how interpolation works is called a sampling filter. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cd8/2d8/379/cd82d8379182165c555da6b0b5d881eb.png" alt="image"><br><br>  There are many such filters.  The easiest way to add four rows and four columns of any color.  Well, let's say red.  This will be the background interpolation when the background color (red) appears on the empty places.  In Photoshop, this is done via ‚ÄúImage‚Äù ‚Üí ‚ÄúCanvas Size‚Äù instead of ‚ÄúImage‚Äù ‚Üí ‚ÄúImage Size‚Äù. <br><br>  This, of course, does not suit us.  The picture will not be similar to the original.  Background interpolation is used only to add new pixels, and even then it is useless when resizing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0df/a22/3c6/0dfa223c69118d24bc664fcb30fb2eac.png" alt="image"><br><br>  Another simple interpolation is to make the color of the new pixels the same as their neighbors - this is the interpolation of the nearest neighbors.  For pictures, especially for our square, the result will be much better. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d6e/1db/522/d6e1db5222b79968d6312d92eb44c93b.png" alt="image"><br><br>  When downsampling, that is, reducing the picture, it is not so easy to interpolate the nearest neighbors.  It is necessary to accept that for mathematical purposes it is possible to operate with fractional pixels.  To begin with, a new grid is applied to the original picture.  Since the pixels are smaller and their size is larger, some of them contain several colors. <br><br>  But real pixels have only one color.  The resulting color of each pixel of the new grid is determined by the color of its center.  Therefore, sometimes the interpolation of the nearest neighbors with decreasing is called point discretization. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d78/cd4/b3a/d78cd4b3a934ebd50db67f52374e926b.png" alt="image"><br><br>  But if it is something more complicated than lines and squares, this method produces jagged and square pictures.  It works quickly, produces small files, but it looks bad. <br><br>  Most filters use interpolation variations on their nearest neighbors ‚Äî they do point sampling on several points and somehow calculate a certain average color for them.  In bilinear interpolation, a weighted average of colors is considered. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0d/287/ea9/e0d287ea908ca62361f35b01ff913bc3.png" alt="image"><br><br>  But such a filter affects the file size, because it adds new colors along with rounded edges.  The original picture had only two colors, but now we have more of them.  And other things being equal, the more colors, the heavier the file. <br><br>  And what does this mean for us <br><br>  We need to somehow reduce the number of colors without losing quality.  Most influenced by the choice of filter, but other settings too. <br><br><h4>  Optimal settings for ImageMagick </h4><br><h5>  ImageMagick Basics </h5><br>  ImageMagick <a href="http://www.imagemagick.org/script/command-line-options.php">doesn't have settings and functions</a> , and finding the one you need is pretty hard.  We are interested in two functions, convert and mogrify.  They perform similar actions, but mogrify works with several files at once, and convert - one at a time. <br><br>  Simple operation: <br><br><pre><code class="bash hljs">convert input.jpg -resize 300 output.jpg</code> </pre> <br><br>  At the same time, IM takes input.jpg and changes its size by pixels wide, saving the result in output.jpg.  The -resize 300 function is an example of one of a variety of functions.  They all have the same format: -functionName option. <br><br>  You can also use mogrify, with a small addition: <br><br><pre> <code class="bash hljs">mogrify -path output/ -resize 300 *.jpg</code> </pre><br><br>  Here IM takes all the JPEG files from the current directory (* .jpg), changes their size to 300 pixels wide and stores them in the output directory. <br><br>  Functions can be combined: <br><br><pre> <code class="bash hljs">convert input.jpg -resize 300 -quality 75 output.jpg</code> </pre><br><br>  This also changes the size of input.jpg to 300 pixels, but sets the JPEG quality to 75 before saving to output.jpg. <br><br><h5>  Testing and results </h5><br>  <a href="https://github.com/nwtn/image-resize-tests">By testing</a> various IM settings, I tried to reduce the size of the files without compromising their quality - so that they could not be distinguished from the Photoshop option ‚ÄúSave for Web‚Äù.  I used to test both subjective opinion and objective, measuring <a href="http://en.wikipedia.org/wiki/Structural_similarity">structural differences</a> (structural dissimilarity, DSSIM).  DSSIM compares two pictures and gives a rating.  The lower the score, the more they are similar.  0 means identity.  I sought a DSSIM score of no more than 0.0075.  And in <a href="http://www.radware.com/neurostrata-fall2014/">one of the studies</a> last year, it was found that usually people cannot distinguish by eye pictures with DSSIM less than 0.015. <br><br>  Having tested various images of different sizes in JPEG and PNG formats, I came to the conclusion that the following IM settings produce the lowest results, which are almost indistinguishable from the output of Photoshop: <br><br><pre> <code class="bash hljs">mogrify -path OUTPUT_PATH -filter Triangle -define filter:support=2 -thumbnail OUTPUT_WIDTH -unsharp 0.25x0.25+8+0.065 -dither None -posterize 136 -quality 82 -define jpeg:fancy-upsampling=off -define png:compression-filter=5 -define png:compression-level=9 -define png:compression-strategy=1 -define png:exclude-chunk=all -interlace none -colorspace sRGB -strip INPUT_PATH</code> </pre><br><br>  We analyze them in more detail. <br><br><h6>  Mogrify or Convert </h6><br>  IM uses convert to process images one by one, and mogrify is usually needed for batch processing.  In an ideal world, the results of their work must coincide.  Unfortunately, <a href="http://www.imagemagick.org/discourse-server/viewtopic.php%3Ff%3D3%26t%3D27177">there is an error</a> in <a href="http://www.imagemagick.org/discourse-server/viewtopic.php%3Ff%3D3%26t%3D27177">convert that</a> makes it ignore some of the settings (-define jpeg: fancy-upsampling = off), so I had to use mogrify. <br><br><h6>  Resampling </h6><br>  The selection of the sampling filter in IM is somehow confusing.  There are three ways to do this: <br><br><ul><li>  selecting the resize function </li><li>  using the -filter option </li><li>  or the -interpolate option </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c91/83c/3d6/c9183c3d6390a5e3d9a73058fb0d7355.jpg" alt="image"><br>  Work examples of twelve different resizing functions. <br><br>  The most obvious is to use ‚Äìresize, but the results are too large.  I checked 11 different functions and found that it‚Äôs best to reduce ‚Äìthumbnail, both in size and quality.  This feature works in three steps: <br><br><ol><li>  Resizes a picture to a size that is five times larger than what you need, using the ‚Äìsample function, which has its own built-in filter </li><li>  then resizes to the required through ‚Äìresize </li><li>  removes meta data from image </li></ol><br><br>  That is, if we reduce the image to 500 pixels wide, -thumbnail will first change its size to 2500 using ‚Äìsample.  Then IM will change the size from 2500 to 500 via ‚Äìresize.  And at the end will delete the meta data. <br><br>  The second way to select a sampling filter is via ‚Äìfilter.  Some features have built-in filters, while others have default filters that can be changed.  In the second step of working ‚Äìthumbnail, ‚Äìfilter is used, because the ‚Äìresize function is used there. <br><br>  I checked 31 settings for ‚Äìfilter and achieved the best results using Triangle.  This filter is also known as bilinear interpolation.  It calculates a weighted average color from neighboring pixels.  I found it best to set the region of neighboring pixels as -define filter: support = 2 setting. <br><br>  The third way to select a filter is ‚Äìinterpolate, but it is ignored when using -thumbnail. <br><br>  Among other things, IM by default uses a certain function called JPEG fancy upsampling, which tries to produce better quality JPEG.  I decided that it only increases the size of the pictures, and the difference in quality is negligible, so I recommend turning it off via -define jpeg: fancy-upsampling = off. <br><br><h6>  Sharpening </h6><br>  When you change the size of the image is slightly blurred, so the same photoshop uses different techniques to increase the definition.  I recommend the unsharp filter, which, despite the name, increases the clarity of the picture: -unsharp 0.25x0.25 + 8 + 0.065. <br><br>  The filter works in such a way that <a href="http://en.wikipedia.org/wiki/Gaussian_blur">Gaussian blur</a> is applied first.  The first two numbers are the radius and sigma (in our case, 0.25 pixels each).  After the blur, the filter compares the blurred version with the original, and where the brightness differs more than the specified threshold (0.065), an increase in the definition of the specified force (8) is applied. <br><br><h6>  Color reduction </h6><br>  As I said earlier, the main reason for the increase in file size when changing the size of pictures is the addition of new colors.  Therefore, we must try to reduce their quantity, but without loss of quality. <br><br>  One way to do this is posterization (posterization), when gradients are replaced with sets of crisp colors.  Posterization reduces the number of levels of color - this is how many options remain in the red, green and blue channels.  The total number of colors of the picture will be a combination of the colors of these channels. <br><br>  Posterization can reduce the file size, but also degrade the quality.  I suggest the number 136, at which you get a small file, without losing much in quality. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cd/1ba/067/3cd1ba06778094167a5ee38db68db656.jpg" alt="image"><br>  Original <br><br><img src="https://habrastorage.org/getpro/habr/post_images/34a/459/445/34a459445f9e2fcadf1a92ef744b2e2c.jpg" alt="image"><br>  Reducing the number of colors <br><br>  Dithering is a process that mitigates the effects of reducing the number of colors by adding noise to color sets to create the illusion of more colors.  In theory, this is a good idea. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4b/067/b17/e4b067b17a3e414083f7420351db272b.jpg" alt="image"><br>  After dithering <br><br>  Unfortunately, in IM there is an error that spoils the pictures with transparency in dithering.  Therefore, it is better to disable it through -dither None.  Fortunately, without it, the posterization results look good. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/281/e5e/557/281e5e5575e68589349550d35766cdd7.png" alt="image"><br>  Dithering error in IM <br><br><h6>  Color space </h6><br>  Color space is indirectly related to the number of colors in the picture.  This space determines which colors are available.  The picture below shows that the ProPhoto RGB color space contains more colors than Adobe RGB, which in turn contains more than sRGB.  And they all contain less flowers than the eye sees. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da5/031/c90/da5031c901a7c2a8942d56bdc18e790b.png" alt="image"><br><br>  sRGB made the king of internet color spaces.  He was approved by the W3C and other organizations.  It is required to support in CSS Color Module Level 3 and in the specifications of SVG and WebP.  It is referenced in the PNG specification.  In Photoshop, this is also the default color space.  In short, sRGB is the best choice for the web, and if you want your images to display correctly, it‚Äôs best to use it. <br><br><h6>  Quality and Compression </h6><br>  In lossy formats like JPEG, quality and compression are directly related - the greater the compression, the lower the quality and the smaller the file size.  Therefore, you need to find a balance. <br><br>  In my tests for control images and photoshop, the quality was set to high, or 60. And in the IM settings, I recommend using 82. Why? <br><br>  It turns out that the quality setting is not quantified in JPEG format, and therefore it is not a standard.  Quality 60 in Photoshop can be the same as quality 40 in one program, B + quality in another, or ‚Äúawesome‚Äù quality in the third.  In my tests, I found out that Photoshop 60 corresponds to -quality 82 in ImageMagick. <br><br>  And for formats without loss of quality like PNG, quality and compression are not related.  High compression does not change the look of the picture, but depends only on the level of CPU usage during its processing.  If you do not feel sorry for computers, then there is no reason not to set the maximum PNG compression. <br><br>  PNG compression in IM can be set in three settings: -define png: compression-filter, -define png: compression-level and -define png: compression-strategy.  <a href="http://www.libpng.org/pub/png/book/chapter09.html">The compression filter</a> is an extra step before compression, which sorts the data in such a way that compression becomes more efficient.  I achieved better results using adaptive filtering (-define png: compression-filter = 5).  I recommend setting the compression level to a maximum of 9 (-define png: compression-level = 9).  And the strategy determines the algorithm itself.  I liked the default strategy more (-define png: compression-strategy = 1). <br><br><h6>  Meta data </h6><br>  In addition to the picture itself, files may contain meta data ‚Äî information about the picture, when it was created, about the device that created it.  This information takes place, but does not improve the perception of the picture, and it is better to delete it.  And although I have indicated that ‚Äìthumbnail deletes meta data, it still doesn‚Äôt delete them all.  It is possible to delete everything using -strip and -define png: exclude-chunk = all.  This does not affect the quality. <br><br><h6>  Progressive render </h6><br>  JPEGs and PNGs can be saved using progressive (progressive) or sequential (sequential) rendering.  By default, the second one is executed, when pixels are loaded in rows, from top to bottom.  Progressive means that the picture is transmitted and output gradually. <br><br>  JPEG progressive render can occur in any number of steps - this is determined when saving the file.  The first step is the low resolution version of the full image;  on each subsequent version of a higher resolution appears, until the entire picture in high resolution is displayed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d18/390/22d/d1839022d48112ad865a301e3f48f51e.gif" alt="image"><br><br>  PNG has a kind of progressive rendering called <a href="http://en.wikipedia.org/wiki/Adam7_algorithm">Adam7 interlacing</a> , where pixels are displayed in seven steps based on an 8x8 grid. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14f/5cc/6e7/14f5cc6e7595b7fbf8f9011d74108ddc.gif" alt="image"><br><br>  Both types of render can be configured in IM through ‚Äìinterlace.  But is it necessary? <br><br>  This render increases the size of files.  For a long time it was thought that it should be included, because it improves user perception.  Even if the ideal picture does not load right away, it recognizes something, and it will be better than nothing. <br><br>  Last year, according to the <a href="http://www.radware.com/neurostrata-fall2014/">results of the study,</a> it became clear that users prefer a consistent render.  This is only one study, but still interesting.  So I decided to recommend using a sequential render using "-interlace none". <br><br><h6>  Image Optimization </h6><br>  I mentioned optimization.  I recommend all the settings described before, if you do not optimize your pictures.  If they can be optimized, then I will change them: small changes in the -unsharp settings work better (-unsharp 0.25x0.08 + 8.3 + 0.045 against -unsharp 0.25x0.25 + 8 + 0.065 without optimization) and do not need to use -strip. <br><br><pre> <code class="bash hljs">mogrify -path OUTPUT_PATH -filter Triangle -define filter:support=2 -thumbnail OUTPUT_WIDTH -unsharp 0.25x0.08+8.3+0.045 -dither None -posterize 136 -quality 82 -define jpeg:fancy-upsampling=off -define png:compression-filter=5 -define png:compression-level=9 -define png:compression-strategy=1 -define png:exclude-chunk=all -interlace none -colorspace sRGB INPUT_PATH</code> </pre><br><br>  There are plenty of optimizers.  I tested <a href="https://github.com/toy/image_optim">image_optim</a> , <a href="https://github.com/ajslater/picopt">picopt</a> and <a href="https://imageoptim.com/">ImageOptim</a> , and they all chase the pictures through a series of different steps.  I checked them one by one and came to the conclusion that it is better to run the files through all three in the order in which they are given.  However, after using image_optim, the benefit from picopt and ImageOptim becomes minimal.  If you do not have extra time and processor power, the use of more than one optimization will be excessive. <br><br><h4>  Results (and what, it was necessary to suffer so?) </h4><br>  Of course, my settings are complicated, but they are needed to improve user perception.  I am pleased to announce that having spent time on tests, I managed to drastically reduce the volume of files without losing in quality. <br><br>  On average, the file size has decreased by 35% compared to the ‚ÄúSave for Web‚Äù Photoshop option. <br><br>  Comparison with Photoshop Creative Cloud <br><img src="https://habrastorage.org/files/20f/afe/98f/20fafe98f235452a80e5b624accbbae6.png"><br><br>  My settings without optimization turned out to be even better than Photoshop with optimization! <br><br>  Compared to the default settings when changing the size of IM images, my recommendations won an average of 82%. <br><img src="https://habrastorage.org/files/556/d19/943/556d199438e24660a70941d6a17a7500.png"><br><br>  Compared to the default settings in WordPress, which ‚Äúunder the hood‚Äù uses ImageMagick, my settings won on average 77%. <br><img src="https://habrastorage.org/files/d31/4b6/021/d314b602109f4aa1ad5caf4018b179e9.png"><br><br>  Compared to other CMS and tools that use ImageMagick, my settings won up to 144%. <br><img src="https://habrastorage.org/files/ba6/5a2/d27/ba65a2d27df848ca8134bc97d146a1fa.png"><br><br>  I remind you that all the pictures turned out to be indistinguishable from Photoshop output. <br><br><h4>  How to implement it in your projects </h4><br><h5>  bash shell </h5><br>  Here you can add a macro function to the .bash_aliases (or .bashrc) file, which will replace my recommended command: <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">smartresize</span></span></span></span>() { mogrify -path <span class="hljs-variable"><span class="hljs-variable">$3</span></span> -filter Triangle -define filter:support=2 -thumbnail <span class="hljs-variable"><span class="hljs-variable">$2</span></span> -unsharp 0.25x0.08+8.3+0.045 -dither None -posterize 136 -quality 82 -define jpeg:fancy-upsampling=off -define png:compression-filter=5 -define png:compression-level=9 -define png:compression-strategy=1 -define png:exclude-chunk=all -interlace none -colorspace sRGB <span class="hljs-variable"><span class="hljs-variable">$1</span></span> }</code> </pre><br><br>  And you need to call it like this: <br><br><pre> <code class="bash hljs">smartresize inputfile.png 300 outputdir/</code> </pre><br><br><h5>  Node.js </h5><br>  The npm package called <a href="https://www.npmjs.com/package/imagemagick">imagemagick</a> allows you to use ImageMagick.  When using it, you can add a resizing function as follows: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> im = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'imagemagick'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputPath = <span class="hljs-string"><span class="hljs-string">'path/to/input'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputPath = <span class="hljs-string"><span class="hljs-string">'path/to/output'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> width = <span class="hljs-number"><span class="hljs-number">300</span></span>; <span class="hljs-comment"><span class="hljs-comment">// output width in pixels var args = [ inputPath, '-filter', 'Triangle', '-define', 'filter:support=2', '-thumbnail', width, '-unsharp 0.25x0.25+8+0.065', '-dither None', '-posterize 136', '-quality 82', '-define jpeg:fancy-upsampling=off', '-define png:compression-filter=5', '-define png:compression-level=9', '-define png:compression-strategy=1', '-define png:exclude-chunk=all', '-interlace none', '-colorspace sRGB', '-strip', outputPath ]; im.convert(args, function(err, stdout, stderr) { // do stuff });</span></span></code> </pre><br><br><h5>  Grunt </h5><br>  If you use Grunt to run tasks, then especially for you I did a task called <a href="https://github.com/nwtn/grunt-respimg">grunt-respimg</a> ( <a href="https://www.npmjs.com/package/grunt-respimg">npm</a> ), which does everything I described.  You can include it in your projects like this: <br><br><pre> <code class="bash hljs">npm install grunt-respimg --save-dev</code> </pre><br><br>  And then it can be done in the Grunt file: <br><br> <code>grunt.initConfig({ <br> respimg: { <br> default: { <br> options: { <br> widths: [200, 400] <br> }, <br> files: [{ <br> expand: true, <br> cwd: 'src/img/', <br> src: ['**.{gif,jpg,png,svg}'], <br> dest: 'build/img/' <br> }] <br> } <br> }, <br> }); <br> grunt.loadNpmTasks('grunt-respimg'); <br></code> <br><br><h5>  Php </h5><br>  In PHP, ImageMagick is integrated under the name <a href="http://php.net/manual/en/book.imagick.php">Imagick</a> .  Unfortunately, there it is limited and does not know how to do everything that I recommended - in particular, to configure the sampling filter to use the thumbnail function. <br><br>  But you were lucky - I created a <a href="https://github.com/nwtn/php-respimg">php-respimg</a> ( <a href="https://packagist.org/packages/nwtn/php-respimg">packagist</a> ) module that does everything necessary.  It can be included in the project using <a href="https://getcomposer.org/">Composer</a> : <br><br><pre> <code class="bash hljs">composer require nwtn/php-respimg</code> </pre><br><br>  And then change the size of the pictures like this: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span>(<span class="hljs-string"><span class="hljs-string">'vendor/autoload.php'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">nwtn</span></span>\<span class="hljs-title"><span class="hljs-title">Respimg</span></span> <span class="hljs-title"><span class="hljs-title">as</span></span> <span class="hljs-title"><span class="hljs-title">Respimg</span></span>; $image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Respimg($input_filename); $image-&gt;smartResize($output_width, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); $image-&gt;writeImage($output_filename);</code> </pre><br><br><h5>  Content Management Systems </h5><br>  If your CMS works in PHP, take the ‚ÄúPHP‚Äù section and make a plugin out of it.  If you are using WordPress, then you can use the <a href="https://wordpress.org/plugins/ricg-responsive-images/">RICG Responsive Images</a> plugin.  After installing it, you will need to add the following to the functions.php file to activate it: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">custom_theme_setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ add_theme_support( <span class="hljs-string"><span class="hljs-string">'advanced-image-compression'</span></span> ); } add_action( <span class="hljs-string"><span class="hljs-string">'after_setup_theme'</span></span>, <span class="hljs-string"><span class="hljs-string">'custom_theme_setup'</span></span> );</code> </pre><br><br>  Other CMS somehow give access to functions for working with pictures - refer to their documentation. <br><br><h4>  Speed ‚Äã‚Äãperformance </h4><br>  In my tests, I found that, compared to ‚Äìresize, by default IM took 2.25 times longer to process images. <br><br><h4>  Conclusion </h4><br>  Designers and developers greatly influence how the web works.  We can make websites more nimble, improve their perception by users, and even bring our content to <a href="http://blog.chriszacharias.com/page-weight-matters">new markets</a> .  Reducing the volume of images is quite simple and greatly affects the increase in site performance - I hope that all this information will be useful for you and allow you to improve your website for your users. <br><br><h4>  Links </h4><br>  <a href="https://github.com/nwtn/grunt-respimg">grunt-respimg</a> <br>  <a href="https://github.com/nwtn/php-respimg">php-respimg</a> <br>  <a href="https://wordpress.org/plugins/ricg-responsive-images/">RICG Responsive Images plugin</a> </div><p>Source: <a href="https://habr.com/ru/post/261625/">https://habr.com/ru/post/261625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261609/index.html">Five misconceptions about open source</a></li>
<li><a href="../261615/index.html">Magic of tensor algebra: Part 2 - Vector and tensor operations. Ranks of tensors</a></li>
<li><a href="../261619/index.html">Release of the Qt 5.5 framework</a></li>
<li><a href="../261621/index.html">Corporate Laboratories - Information Security Training Program</a></li>
<li><a href="../261623/index.html">StorIO - human API for working with SQLiteDatabase and ContentResolver</a></li>
<li><a href="../261627/index.html">Changes in the PMP exam in 2015</a></li>
<li><a href="../261629/index.html">We write our simplified OpenGL on Rust - part 1 (draw a line)</a></li>
<li><a href="../261631/index.html">Ciklum Kiev invites to Speakers' Corner dedicated to the development for the Apple Watch</a></li>
<li><a href="../261637/index.html">Google Developer Launchpad - Google Startup Program</a></li>
<li><a href="../261641/index.html">Compile-time reflection D, practice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>