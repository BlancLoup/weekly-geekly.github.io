<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is a computer virus?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first , second, and third issues of the blog, we talked about how autoprogrammability, a congenital feature of von Neumann computers, led to th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is a computer virus?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage1/70dee369/fa8d30fc/1ef2aaae/a9ffb8d7.jpg"><br><br>  In the <a href="http://habrahabr.ru/company/bitdefender/blog/121279/">first</a> , <a href="http://habrahabr.ru/company/bitdefender/blog/122067/">second,</a> and <a href="http://habrahabr.ru/company/bitdefender/blog/122329/">third</a> issues of the blog, we talked about how autoprogrammability, a congenital feature of von Neumann computers, led to the appearance of viruses in them.  The theme of the <a href="http://habrahabr.ru/company/bitdefender/blog/122586/">fourth</a> release was the <b>fundamental method of anti-virus protection</b> - multi-level fixing of programs based on the separation of programs and data.  This method is considered the most reliable of all.  It was shown its relationship with other major methods. <br><br>  In this article we will look at three different definitions of the notion ‚Äúcomputer virus‚Äù.  The first two were formulated by <a href="http://en.wikipedia.org/wiki/Fred_Cohen">Frederick Cohen</a> and <a href="http://en.wikipedia.org/wiki/Leonard_Adleman">Leonard Adleman</a> in the fundamental works of 1984-1992 and are considered classic in modern computer science.  Unfortunately, it automatically follows from them that the <b>problem of recognizing an arbitrary virus is insoluble.</b>  As these scientists proved in the same works where they gave their definitions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, we specially formulate the third definition in such a way that it makes the same problem <b>completely solvable.</b>  To do this, we abandon several poorly formalized concepts that underlie classical definitions, and assign a wider range of information objects to viruses.  Such an approach ‚Äî solving a complex problem by replacing categories in which it is formulated ‚Äî is often convenient and useful in the practical work of an information security specialist. <br><a name="habracut"></a><br>  The problem of computer viruses clearly manifested about 35 years after the emergence of the concept of "stored program computer".  The first authors and researchers of viruses were strongly impressed by the unprecedented phenomenon of self-replication (in the biological sense of the term) of man-made objects.  Later, experts realized that this phenomenon is not so much these objects themselves as the performing environment - even as relatively simple as a Turing machine or von Neumann machine with a typical operating system, not to mention more complex architectures and network environments.  It became clear that mass replication of objects is not a specific property of any one class of programs, but quite typical for all levels of a complex auto-programmable system.  For example, massively replicated blocks of code in the OOP paradigm or application programs downloaded by users from a central server.  But despite the discovery of the strategic role of the environment, replication is still associated in the majority of people with viruses ‚Äî and forms the basis of their classical definitions. <br><br><h3>  Cohen virus definition </h3><br>  Fred Cohen, a graduate student at the University of Southern California, became interested in the problem of computer viruses in the early 1980s.  In 1984, with the support of his scientific adviser Leonard Adleman, he wrote the first article on this topic, where he cited a very far from perfect wording: ‚ÄúWe‚Äôre possibly evolved copy of itself. "  At first, everything seemed simple, but as the topic was further developed, Cohen discovered its extreme complexity and key environmental value - both for the replication process and for deciding whether an arbitrary information object under study is a virus. <br><br>  In his book in 1985 and his dissertation in 1986, Cohen already gave a rigorous definition of a virus, in which he concentrated on his only property ‚Äî recursive replication.  The definition was given only for an abstract model based on a Turing machine (note that a real computer usually has less predictability than its ideal model).  No other properties than recursive replication are considered in Cohen‚Äôs model.  That is, it is a good particular case model of recursively reproducible algorithms, but a poor model of real computer viruses ‚Äî especially given the observed diversity of their types and the need for strict recursion for distribution. <br><br>  But the Cohen model of the virus became classical because it turned out to be simple, visual, and taking into account the role of the performing environment, which is necessary for understanding the essence of the problem.  In this model, in order to determine whether a studied information object is a virus (finite sequence of characters, program, code), it should be considered only in the context of a computer-environment, in a pair with it and in interaction with it - for as many steps forward as it takes execution code by machine.  The virus was defined as a <b>code whose execution will result in writing a copy of this code on the tape</b> of the Turing machine ahead of it, i.e.  in future. <br><br>  But for the Turing machine (as proved by its author in 1936) it is impossible to predict the future.  For an arbitrary code, the result of its execution is unpredictable, i.e.  a sequence of machine tape (memory) states for an unlimited number of ticks ahead.  The only way to figure out how this code will end is to test it in practice.  In other words, <b>to find out whether the code being studied is a virus, you need to run it and see what happens.</b>  Given the uncertainty of the result, in a real system it is not safe.  In addition, the waiting time for the execution of the code can be arbitrarily large (infinite).  And without information about what the code will lead to, you cannot judge whether it is a virus. <br><br>  Please note that analyzing the code without starting it is impossible even from the most convenient position - an external observer who is not limited in the means for studying the machine and the code that are in the original static states.  Moreover, there can be no question of analyzing the code without starting it with the tools of the machine itself, as well as analyzing the code in the process of the execution of another code by the machine. <br><br>  In addition to the disappointing conclusion about the impossibility of reliable recognition of viruses in his model, Cohen proved the following: <br>  a) to an arbitrary code you can always choose a machine that interprets it as a virus;  for example, for some machine, the virus will be a single-byte code - 42; <br>  b) some machines interpret any code as a virus; <br>  c) some machines do not interpret any code as a virus. <br><br>  Subsequently, Cohen returned to this topic more than once.  So, in 1992, he published an article where a strict definition of the concept ‚Äúcomputer worm‚Äù was cited (a special case of a virus for some environments, in particular, multiprocessor ones).  The article confirmed the previous conclusion: the recognition of viruses and similar objects in general is impossible. <br><br><h3>  Adleman virus detection </h3><br>  The topic of computer viruses has never been central to Leonard Adleman (co-author of public-key encryption technology and winner of the 2002 Turing Award), who pay much more attention to other problems of information technology, mathematics and molecular biology.  But as a result of his collaboration with Cohen, he found it necessary, somewhat later, in 1990, to write and publish <a href="http://ivanlef0u.fr/repo/madchat/vxdevl/papers/avers/ala01.pdf">An Abstract Theory of Computer Viruses</a> .  The Adleman model is very different from the Cohen model.  But even for this model an evidentiary conclusion is made about the <b>impossibility of solving the problem of recognizing an arbitrary virus.</b> <br><br>  Adleman, as a professional mathematician, defined the virus in categories and terms of recursive functions.  For the definition, a new concept was brought in - the original, reference, program not yet infected with this virus.  The virus was defined as a recursive <b>function that</b> meets some of the described criteria and <b>performs a mapping</b> ("map") of the <b>reference program to another that is considered infected.</b>  As actions of the infected program, Adleman called ‚Äúdamage‚Äù (information to which this program has access), ‚Äúinfection‚Äù (other information objects) and ‚Äúimitation‚Äù (normal behavior of the original, uninfected program).  As in Cohen's work, the virus is considered in conjunction with the environment (one function - in interaction with another).  Recursive replication remained the decisive criterion of the virus, and another decisive criterion was harmfulness (formalization of which in the Adleman model is difficult to understand and use as a practically applicable algorithm). <br><br>  Adleman‚Äôs definition is extremely latitude and abstract.  We provided a link to the original work, so that readers can independently draw conclusions about how far this definition is proportionate, complete, accurate and applicable to real computer viruses in a real environment 20 years after publication. <br><br>  In 2005, Chinese researchers Zhihong Zuo, Mingtian Zhou and Qing-xin Zhu published a paper <a href="http://vxheavens.com/lib/mzz01.html">, On the Time Complexity of Computer Viruses</a> , extending Adleman‚Äôs model to complex types of viruses, in particular, to polymorphic viruses.  This required a significant complication of the model, but did not change its essence.  The paper confirms the previous conclusion that it is impossible to recognize an arbitrary virus, more precisely, the possibility of the existence of viruses that are fundamentally unrecognizable within the framework of the model used. <br><br>  In the work of Adleman two points seem to us especially important.  First, as a strategic ‚Äî and, in fact, the only ‚Äî means of protection against viruses, he rightly called <b>complete and unconditional isolation of a computer,</b> i.e.  closeness of the environment (with regard to alternative methods of protection, the work only raised the question of how real they are).  Secondly, the scientist showed the need to bring the <b>concept of the original, uninfected program as a prerequisite for determining the virus.</b> <br><br>  Recall that the isolation of computer systems in relation to viruses always means the mutual isolation of systems controlled by different hosts.  Of course, there is no need for mutual isolation of individual elements of any closed system, which is <b>under the complete control of</b> one owner.  The owner programs his own system as he sees fit (this is the difference between the owner and the nominal owner).  Therefore, it is hardly possible to use the concept of ‚Äúharmfulness‚Äù outside the social context, exclusively in technological categories: no processes of changing programs and data themselves have ‚Äúharmfulness‚Äù. <br><br><h3>  Virus detection by code violation </h3><br>  The impossibility of reliable recognition of viruses in the framework of classical models gives reason to think about the approach to solving the problem from the other side. <br><br>  In the traditional approach, the virus model is created as accurate as possible, based on the concepts of ‚Äúrecursive replication‚Äù and, optionally, ‚Äúharmfulness‚Äù.  Within the framework of the model created, the definition of a virus is given.  Then, it is stated that it is impossible to use this definition to assess the compliance of the information objects being examined with it. <br><br>  But you can do the opposite: aiming at the practical applicability of the definition of a virus for a simple and guaranteed solution to the problem of its recognition ‚Äî and for a comprehensive solution to the problem of digital infections in general.  Then, using this definition, you can find out which model of the virus corresponds to it. <br><br>  For information security purposes, the most convenient will be a strictly formalized, proportionate and system definition, which <b>makes it easy to carry out an assessment of compliance</b> with arbitrary information objects.  The procedure for comparing the properties of each object under study with the definition should be in the form of a short, reliable and well-controlled algorithm, so that it can be automated and put into practice. <br><br>  The simplest and most obvious solution is to consider a virus <b>any</b> intrusion of a third-party <b>code</b> (that is, an arbitrary sequence of characters) into a reference, source, uninfected program.  This means the rejection of the resource-intensive and in the general case the unsolvable task of analyzing the processes of interaction between the code being tested and the machine - and the rejection of attempts to formalize these processes.  A virus is determined not through the properties of a sequence of characters, but through its location in a machine (computer, computer system).  In other words, the same sequence of characters may or may not be considered a virus, depending on where it is located in relation to the ‚Äúcoordinate system‚Äù of the machine ‚Äî exactly where the Turing tape, exactly which area of ‚Äã‚ÄãRAM, hard disk, and t .P.  A virus is any sequence of characters that is ‚Äúin the wrong place‚Äù, i.e.  in the area reserved for another information object - the protected code. <br><br>  A rigorous definition for a conventional <a href="http://ru.wikipedia.org/wiki/SISD">SISD</a> machine, which can be adapted for a wider range of information systems, is formulated as follows: a <b>computer virus is a modified part of the code compared to a standard.</b> <br><br>  Using in practice a model that meets the above definition of a virus, you are reinsured and go into a deep and very reliable defense.  Instead of analyzing unknown code to accurately answer the question about the possibility of initiating recursive replication, you assume that this possibility is <b>not excluded.</b>  Instead of analyzing the unknown code to accurately answer the question of its harmfulness, you proceed from the fact that entering into the protected code any, even the smallest change <b>with a certain probability</b> causes a violation of its functions - just as a violation of the functions of biological DNA can be caused by substitution single nucleotide in sequence. <br><br>  For the convenience of solving many practical problems in complex information systems, the definition can be extended to those data areas that should have the same immunity in the system as the executable code.  In general, any protected information object is declared infected, within the boundaries of which another object has fallen. <br><br>  Note that in the absence of a reference for an arbitrary code, all this code, by this definition, is considered a virus.  Although it sounds unusual, it must be well understood and always kept in mind.  About where the benchmark comes from, we'll talk in the next blog posts: this will require the involvement of social factors. <br><br>  <i>Linguistic reference.</i>  <i>The word "virus" appeared in modern languages ‚Äã‚Äãa little over 100 years ago, after the discovery of biological viruses.</i>  <i>Their characteristic feature is replication, executed by the corresponding medium.</i>  <i>But the word "virus" has another, original meaning: in Latin, this word means poison.</i>  <i>No connection with replication: a virus is an object characterized by a violation of the functions of an external object into which it has penetrated.</i>  <i>The use of the term ‚Äúcomputer virus‚Äù in the context of destructive impact is as correct as in the context of replication.</i>  <i>The use of informal terms ‚Äúmalicious‚Äù or ‚Äúmalicious‚Äù is undesirable, especially in technological terminology, outside the social context.</i>  <i>The term ‚Äúanti-virus protection‚Äù (rather than ‚Äúanti-malware‚Äù and ‚Äúanti-malware‚Äù) is most stable in Russian and has obvious connotations.</i> <br><br><h3>  Which virus definition is better? </h3><br>  Compare the approaches used in different models and definitions of the virus. <br><br>  A virus is: <br>  a) a function <b>corresponding to certain criteria</b> that displays a reference, uninfected object to an infected object that is different from it; <br>  b) <b>any</b> function that maps a reference, uninfected object to an infected object that is different from it. <br><br>  To recognize a virus in a scanned object, you need: <br>  a) conduct a full analytical or algorithmic study of the <b>properties and behavior of the</b> system consisting of the object being tested and the machine (environment); <br>  b) determine the <b>location of the</b> inspected object in the machine (environment). <br><br>  The definition of a virus is based on: <br>  a) the property of <b>recursive</b> replication; <br>  b) method of <b>comparing a</b> sample with a reference. <br><br>  We emphasize once again the essential role of the environment in the replication process.  For example, the sequences of characters ‚ÄúSENDMAIL‚Äù (8 bytes), ‚ÄúCOPY‚Äù (4 bytes) or ‚ÄúCP‚Äù (2 bytes), which can be contained in a simple virus and with which it can operate, do not carry anything like that would be specific to the replication process (especially recursive).  Nothing of the kind also contains a short byte sequence that calls the copying function from the operating system API in native code.  In this sequence, if we consider it outside the environment, there is neither replication mechanism, nor its description, nor even a hint of it. <br><br>  Moreover: the real virus may not even contain this information - literally!  Instead, a virus, for example, can include an arbitrarily complex cryptoalgorithm, and the key to this algorithm can be an arbitrary combination of environmental objects that can appear in it in an uncertain future.  This means that until some unknown moment, before the medium performs some unknown condition, the fundamental absence in the virus code of any connections with the concepts of both replication and recursion can be guaranteed with the accuracy of a mathematical proof.  But even in this case, the virus, merged in its properties with the environment and forming a complex system distributed in space and time with its elements, retains the possibility of reproducing the code. <br><br>  Thus, in modern large information systems, the formalization and search for signs of recursive replication in separate objects seem useless even from a theoretical point of view.  And to consider each object in the aggregate with the whole environment is impossible.  If the input data for the analysis of a single object requires the substitution into the abstract formula of complete information about the state of a practically infinite (due to its huge size and permanent variability) environment, then a dead end path is chosen.  Earlier we have already <a href="http://habrahabr.ru/company/bitdefender/blog/122329/">shown</a> that the Internet is a unified auto-programmable medium, a unified computing system, events in which can change the code in a single system unit.  Therefore, all these events should be taken into account in the formal definition of a virus, if it is based on the properties of the code, both in the abstract model and in practice.  Both are excluded. <br><br>  In the conditions of the global network, where unlimited combinations of direct and reverse connections between elements are possible, methods of mass replication of code that are not related to classical, recursive ones are obvious and used for a long time.  If a dangerous code infects an arbitrary system block of this network, then it does not matter whether the infection is recursive ‚Äî or the child code is formed by the parent using a much more complex algorithm.  The algorithm can be any.  And on the basis of an unknown algorithm it is impossible to build any exact models applicable in practice. <br><br>  It should not be forgotten that in real computing systems viruses are programmed (i.e., controlled) by humans.  And all that is controlled by man, almost defies formalization. <br><br>  It follows from the above that a formal definition of a computer virus, based not on the basis of recursive replication, but on fundamentally different signs, may be the best in many cases. <br><br>  This does not mean that the concept of recursive function has ceased to have meaning in the context of viruses.  It remains extremely important, although it cannot be regarded as decisive.  It does not allow to accurately position the goal, the phenomenon, the object of the threat and its semantic essence with the use of an acceptable mathematical apparatus.  Therefore it is better to always keep in mind alternatives.  A clear understanding by the information security specialist of several different definitions of a virus, their corresponding theoretical models and aspects of anti-virus protection provides the greatest opportunities for solving practical problems. <br><br>  PS Of course, other definitions are possible, except those given in the article.  You can search for them on the Web or create one yourself.  The main thing to keep in mind is that according to the norms of formal logic, a competent <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25BA%25D0%25B0)">definition</a> should allow, at a minimum, to <b>determine the</b> desired object among others :) <br><br>  * * * <br><br>  <i>Read in the next issue:</i> <i><br></i>  <i><b><a href="http://habrahabr.ru/company/bitdefender/blog/123698/">On the dangers of copyright and the benefits of licensed programs.</a></b></i> </div><p>Source: <a href="https://habr.com/ru/post/123180/">https://habr.com/ru/post/123180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123168/index.html">What do monks have in common with optical text recognition and goat cheese?</a></li>
<li><a href="../123169/index.html">NskConf Developer Conference</a></li>
<li><a href="../123177/index.html">Thermaltake - inside view</a></li>
<li><a href="../123178/index.html">Twitter has a new achievement: 200 million tweets per day</a></li>
<li><a href="../123179/index.html">I want to see</a></li>
<li><a href="../123182/index.html">IE10 PP2 released: WebWorkers, Drag & Drop, File API, CSS3 Positioned Floats, HTML5 Forms and more</a></li>
<li><a href="../123183/index.html">Google introduced a new tool for creating mobile sites</a></li>
<li><a href="../123186/index.html">PostSharp. Aspect-oriented programming vs Dependency Injection</a></li>
<li><a href="../123187/index.html">Add Pattern Matching and Parameterized Methods in Objective-C</a></li>
<li><a href="../123188/index.html">RIPE Visits Selectel Holds Training Courses in St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>