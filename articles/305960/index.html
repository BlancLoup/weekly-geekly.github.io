<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Control Flow Guard. The principle of work and workarounds on the example of Adobe Flash Player</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microsoft does not leave attempts to win the endless war with exploiters, implementing new application protection techniques over and over again. This...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Control Flow Guard. The principle of work and workarounds on the example of Adobe Flash Player</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/040/77f/ee9/04077fee9ecb42068a68e783f05ece34.png"><br><p>  Microsoft does not leave attempts to win the endless war with exploiters, implementing new application protection techniques over and over again.  This time, the developers of the Windows operating system approached the solution of this issue more fundamentally, shifting their view of the root of the problem.  The work of almost every exploit is somehow aimed at intercepting the flow of application execution, therefore, it would not hurt to ‚Äúteach‚Äù applications to monitor this moment. <br>  The concept of Control Flow Integrity was <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2005/11/ccs05-cfi.pdf">described</a> as early as 2005.  And now, 10 years later, the developers at Microsoft presented their incomplete implementation of this concept - Control Flow Guard. </p><br><h1>  What is Control Flow Guard? </h1><br><p>  Control Flow Guard (Guard CF, CFG) is a relatively new Windows protection mechanism (exploit mitigation), aimed at complicating the exploitation of binary vulnerabilities in user applications and kernel-mode applications.  The work of this mechanism is to validate implicit calls (indirect calls) that prevent an attacker from intercepting the flow of execution (for example, by rewriting the virtual function table).  Combined with previous security mechanisms ( <abbr title="Safe Structured Exception Handling">SafeSEH</abbr> , <abbr title="Address Space Layout Randomization">ASLR</abbr> , <abbr title="Data Execution Prevention">DEP</abbr> , etc.) is an additional headache for the creators of exploits. <a name="habracut"></a><br>  This security feature is available to users of Microsoft Windows 8.1 (Update 3, KB3000850) and Windows 10. <br>  Compiling programs with CFG support is available in Microsoft Visual Studio 2015 ( <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt637065(v%3Dvs.85).aspx">how to enable?</a> ). </p><br><blockquote>  A similar implementation of the protection mechanism based on the Control Flow Integrity concept for Linux operating systems is available in the <a href="https://pax.grsecurity.net/docs/PaXTeam-H2HC15-RAP-RIP-ROP.pdf">PaX</a> extension. </blockquote><br><h1>  How does Control Flow Guard work? </h1><br><p> Let's look at how CFG works in user mode.  This mechanism has two main components: the address bitmap (managed by the kernel) and the procedure for checking the pointer of the function being called (used by user applications). <br>  All CFG service information is recorded in the <code>IMAGE_LOAD_CONFIG_DIRECTORY</code> executable file at compile time: </p><br><img src="https://habrastorage.org/files/f4a/0f0/1be/f4a0f01beb7a4091b34ae9dba666bdfa.PNG"><br><ul><li>  <code>GuardCFCheckFunctionPointer</code> - pointer to the verification procedure </li><li>  <code>GuardCFFunctionTable</code> - a table of valid addresses of functions (used by the kernel to initialize the bitmap) </li><li>  <code>GuardCFFunctionCount</code> - the number of functions in the table </li><li>  <code>GuardFlags</code> - flags </li></ul><br><p>  The <code>IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics</code> header <code>IMAGE_DLLCHARACTERISTICS_GUARD_CF</code> flag, indicating that this executable file supports the CFG mechanism. </p><br><p>  All the service information can be viewed using the <code>dumpbin.exe</code> tool from Microsoft Visual Studio 2015 ( <em>Microsoft Visual Studio 14.0 \ VC \ bin \ dumpbin.exe</em> ) by running it with the <code>/loadconfig</code> . </p><br><img src="https://habrastorage.org/files/00b/a10/468/00ba10468c874772814c879aafda8240.PNG"><br><p><br></p><br><h3>  Guardflags </h3><br><p>  The <code>winnt.h</code> header file for Windows 10 (1511) contains the following CFG flags (the latter is a mask, not a flag): </p><br><ul><li>  <code>IMAGE_GUARD_CF_INSTRUMENTED</code> (0x00000100) - The module performs flow checks with the support of the system </li><li>  <code>IMAGE_GUARD_CFW_INSTRUMENTED</code> (0x00000200) - The module checks the integrity of the execution stream and the record </li><li>  <code>IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT</code> (0x00000400) - The module contains a table of valid functions </li><li>  <code>IMAGE_GUARD_SECURITY_COOKIE_UNUSED</code> (0x00000800) - The module does not use security cookies (/ GS) </li><li>  <code>IMAGE_GUARD_PROTECT_DELAYLOAD_IAT</code> (0x00001000) - Module supports Delay Load Import Table, read-only </li><li>  <code>IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION</code> (0x00002000) - The Delay Load Import Table is in its own <code>.didat</code> section </li><li>  <code>IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK</code> (0xF0000000) - Step of one element of the table of valid Guard CF functions are encoded in these bits (an additional number of bytes for each element) </li></ul><br><p>  It is worth noting that this is an incomplete list of existing flags.  The most complete list can be obtained from the <code>link.exe</code> file (linker): </p><br><img src="https://habrastorage.org/files/ab7/c50/8d4/ab7c508d405f421591eed827b0d1dd62.PNG"><br><p>  Also pay attention to the presence of some interesting flags, official information about which is not.  Microsoft developers are apparently testing an additional CFG mechanism to verify the address of the entry ( <code>IMAGE_GUARD_CFW_INSTRUMENTED</code> ). </p><br><h3>  Bitmap </h3><br><p>  During OS loading, the kernel (the <code>nt!MiInitializeCfg</code> ) creates the <code>nt!MiCfgBitMapSection</code> , which is a common (shared) section for all processes.  When a process that supports CFG is started, the mapping of the bitmap to the address space of the process takes place.  After that, the address and size of the bitmap are entered into the <code>ntdll!LdrSystemDllInitBlock</code> structure <code>ntdll!LdrSystemDllInitBlock</code> . <br>  The mapping of function addresses to bits in the bitmap is done by the executable file loader (the <code>nt!MiParseImageCfgBits</code> ).  Each bit in the bitmap is responsible for 8 bytes of the process‚Äôs user address space.  Addresses of the beginning of all valid functions correspond to a single bit of the corresponding offset in the bitmap, and all the rest - 0. </p><br><img src="https://habrastorage.org/files/0b5/82c/fef/0b582cfeffb046ffbe3e378cabf418be.PNG"><br><p><br></p><br><h3>  Procedure for checking the pointer of the called function </h3><br><p>  Each implicit call in the program at compile time is framed by checking the address of the called function.  The address of the verification procedure installs the executable loader, since the address of the empty procedure is initially set, thereby maintaining backward compatibility. <br>  For clarity, let's look at the same code compiled without CFG and with it. </p><br><p>  Original C ++ code: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CSomeClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CSomeClass *someClass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSomeClass(); someClass-&gt;doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  ASM listing (clipping): </p><br><pre> <code class="hljs sql">mov eax, [ecx] ; EAX = CSomeClass::vftable <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> dword ptr [eax] ; [EAX] = CSomeClass::doSomething()</code> </pre> <br><p>  Compile key / guard: cf: </p><br><pre> <code class="hljs pgsql">mov eax, [edi] ; EAX = CSomeClass::vftable mov esi, [eax] ; ESI = CSomeClass::doSomething() mov ecx, esi <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> ds:___guard_check_icall_fptr ; checks that ECX <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> pointer mov ecx, edi <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> esi</code> </pre> <br><p>  In the first case, the code is subject to an attack using the virtual function table substitution technique.  If an attacker is able to overwrite object data during the exploitation of a vulnerability, he can replace the virtual function table in such a way that a call to the function <code>someClass-&gt;doSomething()</code> will lead to the execution of the code controlled by the attacker, thereby intercepting the flow of application execution. <br>  In the case of using Control Flow Guard, the address of the called function will be pre-checked with the bitmap.  If the corresponding bit is zero, a program exception will occur. </p><br><p>  When running this application on an OS that supports the Guard CF mechanism, the executable file loader will build a bitmap and redirect the checking procedure address to the <code>ntdll!LdrpValidateUserCallTarget</code> function <code>ntdll!LdrpValidateUserCallTarget</code> . <br>  This feature in Windows 10 (build 1511) is implemented as follows: </p><br><img src="https://habrastorage.org/files/d4f/245/3dd/d4f2453dd96349ea916c542ddd6c68f3.PNG"><br><p><br>  We study the algorithm of this function on the example of the input address 0x0B3385B0. </p><br><p>  B3385B0 <sub>16</sub> = <u>10110011001110000101</u> <strong>10110</strong> 000 <sub>2</sub> </p><br><p>  This function receives the address being checked through the <code>ecx</code> .  In the register <code>edx</code> entered the address of the bitmap.  In my case, the bitmap is located at 0x01430000. </p><br><img src="https://habrastorage.org/files/359/604/091/3596040916b94ef1be95f7f4038edb86.PNG"><br><p><br>  Three bytes (24 bits) higher order (underlined) addresses correspond to the offset in the bitmap.  In this case, the offset will be <code>0xB3385</code> .  The unit of measure of the bitmap is 4 bytes (32 bits), therefore, to obtain the desired cell, it is necessary to calculate the <code>   +  * 4</code> .  For this example, we get <code>0x01430000 + 0xB3385 * 4 = 0x16FCE14</code> .  The value of the cell of the bitmap is written to the <code>edx</code> . </p><br><img src="https://habrastorage.org/files/551/ace/fd4/551acefd4d0d4de295aca73ccb75af55.PNG"><br><p>  The target cell received, now it is required to determine the number of the bit of interest to us.  The number is the value of the next 5 bits of the address (in bold).  But keep in mind that if the address being checked is not aligned at the boundary of 16 bytes ( <code>address &amp; 0xf != 0</code> ), then an odd bit will be used ( <code>offset | 0x1</code> ).  In this case, the address is aligned and the bit number will be 10110 <sub>2</sub> = 22 <sub>10</sub> . </p><br><p>  Now it only remains to check the value of the bit by performing a bit test.  The <code>bt</code> instruction checks the bit value of the first register, the sequence number of which is taken from the 5 low bits (modulo 32) of the second register.  If the bit is 1, the <code>Carry Flag (CF)</code> will be set and the program will continue its execution as usual. <img src="https://habrastorage.org/files/ffa/ce1/6c7/fface16c74614b8d95d75281a81592b4.PNG"></p><br><p>  Otherwise, the <code>ntdll!RtlpHandleInvalidUserCallTarget</code> function will be called and the program will end with the 29th interrupt with the 0xA parameter on the stack, which means <code>nt!_KiRaiseSecurityCheckFailure(FAST_FAIL_GUARD_ICALL_CHECK_FAILURE)</code> . </p><br><img src="https://habrastorage.org/files/9a2/b48/7ef/9a2b487ef7954c13bb2857a7465f07da.png"><br><p>  By checking bit 22, you can verify that the address of the function being called is valid. </p><br><p>  The implementation of this algorithm in Python is as follows: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate_bitmap_offset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr)</span></span></span><span class="hljs-function">:</span></span> offset = (addr &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) * <span class="hljs-number"><span class="hljs-number">4</span></span> bit = (addr &gt;&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) % <span class="hljs-number"><span class="hljs-number">32</span></span> aligned = (addr &amp; <span class="hljs-number"><span class="hljs-number">0xF</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> aligned: bit = bit | <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"addr = 0x%08x, offset = 0x%x, bit index = %u, aligned? %s"</span></span> % (addr, offset, bit, <span class="hljs-string"><span class="hljs-string">"yes"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> aligned <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"no"</span></span>) calculate_bitmap_offset(<span class="hljs-number"><span class="hljs-number">0x0B3385B0</span></span>)</code> </pre> <br><p>  The result of the script: </p><br><pre> <code class="python hljs">addr = <span class="hljs-number"><span class="hljs-number">0x0b3385b0</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x2cce14</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">22</span></span>, aligned? yes</code> </pre> <br><h3>  Exceptions </h3><br><p>  Not in all cases the call of an invalid function will end with the 29th interrupt.  The following checks occur in the <code>ntdll!RtlpHandleInvalidUserCallTarget</code> function: </p><br><ul><li>  Is DEP enabled for the current process? </li><li>  Does the target address have the required rights ( <code>PAGE_EXECUTE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE</code> ) </li><li>  Whether suppressed calls are <code>ntdll!RtlGuardAllowSuppressedCalls</code> - <code>ntdll!RtlGuardAllowSuppressedCalls</code> </li><li>  Whether the target address is "suppressed" - <code>ntdll!RtlpGuardIsSuppressedAddress</code> </li></ul><br><p>  The pseudocode of this function is as follows: </p><br><img src="https://habrastorage.org/files/6e8/ca0/b04/6e8ca0b04d8e4a7595b63a2c51e4a131.PNG"><br><p><br>  Official information about the "suppressed" calls is missing.  We can only say that these calls require compiler support ‚Äî the <code>IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK</code> mask must be set in the <code>GuardFlags</code> flags and the compiler must generate an extended table.  In the bytes corresponding to this mask, the value of the additional size for the elements of the <code>GuardCFFunctionTable</code> table is <code>GuardCFFunctionTable</code> .  If the address of the function is "suppressed", then the byte following the address must be equal to one. <br>  You can allow suppressed calls, for example, using the <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\</code> <code>CFGOptions</code> , by setting the <code>CFGOptions</code> parameter for the required application to 1. </p><br><h1>  Weak points Control Flow Guard </h1><br><p>  Like any other defense mechanism, CFG has some weak points: </p><br><ul><li><p>  Turning off the DEP process entails a loss of meaning of the CFG checks, since the <code>ntdll!RtlpHandleInvalidUserCallTarget</code> in this case will always allow the execution of an invalid address. </p><br></li><li><p>  The address of the bitmap is stored at a fixed address and can be easily calculated from the user mode.  The user is not allowed to modify the data in the bitmap, but exploiters will somehow find a way around this restriction. </p><br></li><li><p>  If the executable file is not compiled with CFG support, then CFG support in the modules loaded by it loses meaning.  The bitmap and the address of the verification procedure are filled only if the executable file supports the CFG mechanism, so checks inside the module code will be simple stubs. </p><br></li><li><p>  CFG depends on the compilation process, so third-party modules and even old Microsoft modules are a vulnerability in the protected CFG executable file.  Since the bitmap is compiled according to the table of addresses of valid functions, which is generated by the compiler, the entire module code without CFG support will be marked in the bitmap with a valid destination. </p><br></li><li><p>  For every 8 bytes of the address space, 1 bit answers, but, in fact, 1 equalized address corresponds to one even bit, while the next odd bit corresponds immediately to 15 bytes of the address space.  You can verify this by running the above Python script in a loop and analyzing the result: </p><br><pre> <code class="python hljs">addr = <span class="hljs-number"><span class="hljs-number">0x08f38480</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">16</span></span>, aligned? yes addr = <span class="hljs-number"><span class="hljs-number">0x08f38481</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38482</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38483</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38484</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38485</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38486</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38487</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38488</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38489</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f3848a</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f3848b</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f3848c</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f3848d</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f3848e</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f3848f</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">17</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38490</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">18</span></span>, aligned? yes addr = <span class="hljs-number"><span class="hljs-number">0x08f38491</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">19</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38492</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">19</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38493</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">19</span></span>, aligned? no addr = <span class="hljs-number"><span class="hljs-number">0x08f38494</span></span>, offset = <span class="hljs-number"><span class="hljs-number">0x23ce10</span></span>, bit index = <span class="hljs-number"><span class="hljs-number">19</span></span>, aligned? no ...</code> </pre> <br><p>  From this it follows that the attacker has the ability to call the untrusted function in the immediate vicinity of the trusted function, provided that the latter is not equalized. </p><br></li><li><p>  Dynamically generated functions (for example, <abbr title="Just in time">JIT</abbr> functions) require special attention from developers, since it is necessary to provide checks for implicit calls at the function generation stage.  In addition to this, it is necessary to take into account that the standard behavior of the <code>ntdll!NtAllocVirtualMemory</code> and <code>ntdll!NtProtectVirtualMemory</code> is to <code>ntdll!NtProtectVirtualMemory</code> a single bit for the entire memory region in the Control Flow Guard bitmap if the memory becomes executable ( <code>PAGE_EXECUTE_*</code> ). </p><br></li><li><p>  CFG is not able to prevent the execution thread from intercepting when an attacker modifies a function‚Äôs return address. </p><br></li><li>  The calls of library functions (for example, WinAPI) from the CFG point of view are valid, but the attacker has to solve the task of filling the stack / registers with the necessary parameters. </li></ul><br><h1>  Implementing Control Flow Guard bypass using the example of Adobe Flash Player </h1><br><p>  Starting with Windows 8, the Adobe Flash Player plugin is integrated into Internet Explorer, and with Windows 8.1 (Update 3) it comes with CFG support.  There are several implementations of the Control Flow Guard circumvention in exploits for Adobe Flash Player, some of which are still relevant today. </p><br><img src="https://habrastorage.org/files/8e0/2f7/014/8e02f70142134353afee6c7c22ed2372.PNG"><br><p><br></p><br><h3>  Bypass with dynamic code </h3><br><p>  In Adobe Flash Player, JIT-compilation is actively used, which allows you to avoid performing such a resource-intensive operation as interpreting ActionScript code.  But, as mentioned earlier, dynamically generated functions require additional attention from developers.  The two workarounds, described below, are a consequence of the omission of developers regarding work with memory allocation. </p><br><h4>  No implicit call checks in dynamic code </h4><br><p>  This method was proposed and implemented by the researcher Francisco Falc√≥n from Core Security in his <a href="https://blog.coresecurity.com/2015/03/25/exploiting-cve-2015-0311-part-ii-bypassing-control-flow-guard-on-windows-8-1-update-3/">analysis of an</a> exploit for the CVE-2015-0311 vulnerability.  The original article describes quite well the process of implementing a crawl in detail.  The essence of the method is to modify the internal table of virtual functions of a certain ActionScript class.  After that, one of the methods of this class must be called from the body of a dynamically generated function.  The class <code>ByteArray</code> well suited for this purpose. <br>  The structure of the <code>ByteArray</code> object: </p><br><img src="https://habrastorage.org/files/1dc/952/cec/1dc952ceca8d4fb78fd53f5217790c5a.png"><br><p>  At offset $ + 8 is a pointer to an object of class <code>VTable</code> : </p><br><img src="https://habrastorage.org/files/b27/1ab/a61/b271aba61a974d78933ed18c656fff06.png"><br><p><br>  The <code>VTable</code> class is an internal representation of a virtual table of functions (that is, not the one that C ++ generates) for ActionScript classes. <br>  An object of this class contains pointers to objects of the class <code>MethodEnv</code> : </p><br><img src="https://habrastorage.org/files/d25/1b8/def/d251b8def42948e2a60af34cf75137ee.png"><br><p>  This class is a description of the ActionScript method and contains a pointer to the function body in memory at the offset of $ + 4. </p><br><p>  The <code>VTable</code> object at offset $ + D4 contains the description of the method <code>ByteArray::toString()</code> .  Having the ability to arbitrarily read and write to memory, an attacker is able to change the function pointer to the function body ( <code>MethodEnv + 4</code> ) and safely intercept the application execution flow by executing <code>ByteArray::toString()</code> . </p><br><p>  This becomes possible due to the fact that the method of this class will be called from the JIT code: </p><br><img src="https://habrastorage.org/files/625/371/d03/625371d036564306a2bc933e9595ba9a.png"><br><p><br>  As can be seen in the screenshot above, an implicit call occurs without first checking the called address, since this function was generated dynamically. </p><br><p>  This CFG workaround was fixed with the release of Adobe Flash Player version 18.0.0.160 (KB3065820, June 2015).  The fix is ‚Äã‚Äãas follows: if the JIT function contains an implicit call, then the JIT compiler will insert a call to the check procedure immediately before the implicit call. </p><br><h4>  Any address within the body of a dynamic function is valid. </h4><br><p>  The previous workaround was possible due to a flaw in the function that makes the implicit call.  And this method is possible due to a flaw in a function that is implicitly called. <br>  Researchers Yuri Drozdov and Lyudmila Drozdov from the Center of Vulnerability Research presented this CFG bypass method at the <a href="https://defcon-russia.ru/">Defcon Russia</a> conference (St. Petersburg, 2015) ( <a href="http://www.slideshare.net/DefconRussia/advanced-cfg-bypass-on-adobe-flash-player-18">presentation</a> , <a href="http://cvr-data.blogspot.ru/2015/07/advanced-cfg-bypass-on-adobe-flash.html">article</a> ).  Their method is based on the fact that when allocating executable memory, the kernel sets a single bit in the CFG bitmap for the <strong>entire</strong> allocated memory.  Let's see what this behavior can lead to. </p><br><p>  Suppose that there is a certain JIT-function at the address 0x69BC9080, the body of which contains the following code: </p><br><img src="https://habrastorage.org/files/279/db1/9f8/279db19f8e4841818fca3d72055626d5.PNG"><br><p>  What exactly this function does is not what interests us, we just need to pay attention to the 2 bytes <code>FF D0</code> instructions at 0x69BC90F0.  What happens if the beginning of the function suddenly moves to the middle of this instruction?  That's what: </p><br><img src="https://habrastorage.org/files/267/f7a/b96/267f7ab9655f444fa4bed91b8a124e84.PNG"><br><p>  <code>FF D0</code> is nothing but <code>call eax</code> !  This is how a seemingly harmless function turned into an excellent target for an attacker ‚Äî an implicit call without checking Control Flow Guard.  It is only necessary to deal with two questions: how to achieve the desired sequence of bytes and how to write the necessary address in the register. </p><br><p>  You can generate the necessary sequence simply by experimenting with ActionScript code.  One has only to take into account the fact that Nanojit ( <abbr title="ActionScript Virtual Machine">AVM</abbr> JIT compiler) obfusts the generated code, so there will be no easy way.  Let's see what this function will turn Nanojit into: </p><br><pre> <code class="python hljs">public static function useless_func():uint { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0xD5EC</span></span>; }</code> </pre> <br><p>  Result: </p><br><img src="https://habrastorage.org/files/58a/171/5ee/58a1715ee53d4e6f8d9033f6c645a746.PNG"><br><p>  Not at all what we expected.  Experienced way you can come, for example, to this version of the code: </p><br><pre> <code class="python hljs">public static function useless_func():void { useless_func2(<span class="hljs-number"><span class="hljs-number">0x11</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">26</span></span>); } public static function useless_func2(arg1:uint, arg2:uint, arg3:uint, a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u, v, w, x, y, z):void { }</code> </pre> <br><p>  The body of the first function will contain the following instructions: </p><br><img src="https://habrastorage.org/files/17b/e08/cbd/17be08cbd7f24b1b8b52928ce2993196.PNG"><br><p>  The <code>FF 11</code> bytes of interest are the instruction <code>call [ecx]</code> : </p><br><img src="https://habrastorage.org/files/806/6d2/f91/8066d2f91a6d44999c8d41755543cd77.PNG"><br><p><br>  An implicit call was received, now you need to add a controlled address to the <code>ecx</code> .  Let us find out what is stored in this register at the moment of calling the function <code>useless_func()</code> . </p><br><img src="https://habrastorage.org/files/18f/13b/036/18f13b0365794eacbc5fc0e989a2f8f6.PNG"><br><p>  At the time of the function call, in the <code>ecx</code> is an object of class <code>MethodEnv</code> .  The first <abbr title="Double Word = 4 Bytes">DWORD of</abbr> this class is a pointer to a virtual table of functions (the one that the C ++ compiler generates).  This table is not used when calling the <code>useless_func()</code> method, so nothing prevents the attacker from replacing the pointer with his own just before calling the method. <br>     : </p><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class_addr:uint = read_addr(UselessClass); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vtable:uint = read_dword(class_addr + <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodenv:uint = read_dword(vtable + <span class="hljs-number"><span class="hljs-number">0x54</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $+54 = useless_func var func_ptr:uint = read_dword(methodenv + 4); write_dword(methodenv + 4, func_ptr + offset_to_call_ecx); write_dword(methodenv, rop_gadget); // ecx &lt;- pointer to rop gadgets UselessClass.useless_func(); // call [ecx]</span></span></code> </pre> <br><p>  ,        ,   ,   <abbr title="Return-oriented programming">ROP</abbr> -. </p><br><p>    CFG     18.0.0.194 (KB3074219,  2015).       <br> <code>PAGE_TARGETS_INVALID/PAGE_TARGETS_NO_UPDATE</code> (0x40000000)   <code>VirtualAlloc</code>  <code>VirtualProtect</code>      WinAPI ‚Äî <code>SetProcessValidCallTargets</code> . <br>  <code>PAGE_TARGETS_INVALID</code>           ,   <code>PAGE_TARGETS_NO_UPDATE</code>              . <br>       <code>AVMPI_makeCodeMemoryExecutable</code>  <a href="https://github.com/adobe/avmplus">   AVM</a> ( <em>AVMPI/MMgcPortWin.cpp</em> ): </p><br><img src="https://habrastorage.org/files/a9f/632/20c/a9f63220c52e4f37aa94470739adecab.PNG"><br><p><br>   <code>SetProcessValidCallTargets</code>   <code>AVMPI_makeTargetValid</code> ( <em>AVMPI/MMgcPortWin.cpp</em> ): </p><br><img src="https://habrastorage.org/files/5e5/53a/4a9/5e553a4a93e84e2bb2213ff9e05044d3.PNG"><br><p><br>     ,               CFG   : </p><br><ul><li> <code>VirtualAlloc(PAGE_READWRITE)</code> </li> <li>      </li><li> <code>VirtualProtect(PAGE_EXECUTE_READ |</code> <strong>PAGE_TARGETS_NO_UPDATE</strong> <code>)</code> </li><li> <code>SetProcessValidCallTargets()</code> </li> </ul><br><p> ,  ,         . </p><br><h3>     WinAPI </h3><br><p>  Control Flow Guard     ,         .   WinAPI,        ,      .           ,      (shellcode)  ROP-.       WinAPI  <code>kernel32!WinExec</code> . </p><br><p>       Yuki Chen  Qihoo 360 Vulcan Team   SyScan (, 2015)  <a href="https://infocon.org/cons/SyScan/SyScan%25202015%2520Singapore/SyScan%25202015%2520Singapore%2520presentations/SyScan15%2520Yuki%2520Chen%2520-%2520The%2520Birth%2520of%2520a%2520Complete%2520IE11%2520Exploit%2520Under%2520the%2520New%2520Exploit%2520Mitigations.pdf"></a> ,     Internet Explorer 11     .    BlackHat (, 2015)  Francisco Falc√≥n  <a href="https://www.blackhat.com/docs/eu-15/materials/eu-15-Falcon-Exploiting-Adobe-Flash-Player-In-The-Era-Of-Control-Flow-Guard.pdf"></a>     Adobe Flash Player. <br>    Francisco Falc√≥n   <code>toString()</code>   <code>Vector</code> ,      ,    . <br>       ,    <code>WinExec</code>  .  ,  <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms687393(v%3Dvs.85).aspx"></a> ,  2 : <code>LPCSTR lpCmdLine</code>  <code>UINT uCmdShow</code> . </p><br><ul><li> <code>lpCmdLine</code> ‚Äî   ,    (   ). </li><li> <code>uCmdShow</code> ‚Äî    . </li></ul><br><p>      : </p><br><img src="https://habrastorage.org/files/416/60e/5d6/41660e5d6c9e4b73b23a2869e2dd916e.PNG"><br><p>         3 .     .    ,  0 = <code>SW_HIDE</code> (  ).       <code>MethodEnv</code> . </p><br><img src="https://habrastorage.org/files/18c/847/bb7/18c847bb7da94080af0326900ad742d6.png"><br><p>     ,  4         ,     ActionScript-    .  4     ,         <code>WinExec</code> . <br>            ,       4 .    , ,   <code>cmd\0</code> (  Windows).  , ,     ,    . </p><br><p>         : </p><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> class_addr:uint = read_addr(UselessClass); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vtable:uint = read_dword(class_addr + <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodenv:uint = read_dword(vtable + <span class="hljs-number"><span class="hljs-number">0x50</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $+50 = useless_func var winexec:uint = get_proc_addr("kernel32.dll", "WinExec"); write_dword(methodenv + 4, winexec); // useless_func() --&gt; WinExec() write_dword(methodenv, 0x00646d63); // '\0', 'd', 'm', 'c' UselessClass.useless_func();</span></span></code> </pre> <br><p>  WinAPI     Flash-   .    ,      ,   <a href="https://github.com/rapid7/metasploit-framework/tree/master/external/source/flash_exploiter">Flash Exploiter</a>   Metasploit. <br>       ,      : </p><br><img src="https://habrastorage.org/files/df1/add/c29/df1addc29c854bbd8da0b6c7b4e6217a.PNG"><br><p><br>  ,      ,     ,     . </p><br><h3>    </h3><br><p>   Flash-         (payload)      HackingTeam.      .      WinAPI  <code>kernel32!VirtualProtect</code> ,        ,   , Control Flow Guard. <br>      <code>apply()</code>  <code>Function</code> ( <em>core/FunctionClass.cpp</em> ) </p><br><img src="https://habrastorage.org/files/420/eed/07c/420eed07c0c5487094f0f3863287dff1.PNG"><br><p>         <code>core-&gt;exec-&gt;apply(get_callEnv(), thisArg, (ArrayObject*)AvmCore::atomToScriptObject(argArray));</code> ,   ,   ActionScript. </p><br><img src="https://habrastorage.org/files/0de/f46/db3/0def46db344d463aac0de620c9aab255.PNG"><br><p><br>       ,       <a href="">GitHub</a> .           64- Flash  <a href="https://community.rapid7.com/community/metasploit/blog/2015/08/04/exploiting-a-64-bit-browser-with-flash-cve-2015-5119-part-2"> Metasploit</a> . </p><br><h1>     Control Flow Guard </h1><br><p>        CFG    Adobe Flash Player.      Flash,      ,      Control Flow Guard  Internet Explorer 11. </p><br><ul><li> <a href="https://www.blackhat.com/docs/us-15/materials/us-15-Zhang-Bypass-Control-Flow-Guard-Comprehensively-wp.pdf">Zhang Yunhai @ Black Hat 2015</a> <br>  read-only  <code>___guard_check_icall_fptr</code>  <code>CustomHeap::Heap</code>  <code>Jscript9</code> . </li><li> <a href="https://infocon.org/cons/SyScan/SyScan%25202015%2520Singapore/SyScan%25202015%2520Singapore%2520presentations/SyScan15%2520Yuki%2520Chen%2520-%2520The%2520Birth%2520of%2520a%2520Complete%2520IE11%2520Exploit%2520Under%2520the%2520New%2520Exploit%2520Mitigations.pdf">Yuki Chen @ SyScan 2015</a> <br>  WinAPI  <code>kernel32!LoadLibraryA</code> </li><li> <a href="https://www.youtube.com/watch%3Fv%3DZkZB9p433Xs">Rafal Wojtczuk &amp; Jared DeMott @ DerbyCon 2015 (video)</a> ,    <a href="https://labs.bromium.com/2015/09/28/an-interesting-detail-about-control-flow-guard/">Bromium Labs</a> <br>  ,      ‚Äî " " (stack desync).     ,  Control Flow Guard       .              (calling convention). </li></ul><br><h1>  Conclusion </h1><br><p>    , Control Flow Guard                  Windows.  Microsoft ,    ,   Control Flow Integrity,     ,    .        ,    Microsoft        . <br>  ,                  CFG. </p><br><blockquote>        .  Intel, ,     ,    ROP- ‚Äî <a href="https://blogs.intel.com/evangelists/2016/06/09/intel-release-new-technology-specifications-protect-rop-attacks/">CET (Control-flow Enforcement Technology)</a> ( <a href="https://habrahabr.ru/company/eset/blog/303086/">  </a> ).     , CET     Control Flow Guard. </blockquote><br><h1>  Sources </h1><br><p> <a href="http://sjc1-te-ftp.trendmicro.com/assets/wp/exploring-control-flow-guard-in-windows10.pdf">Jack Tang, Trend Micro Threat Solution Team. Exploring Control Flow Guard in Windows 10.</a> <br> <a href="http://www.powerofcommunity.net/poc2014/mj0011.pdf">mj0011, Qihoo 360 Vulcan Team. Windows 10 Control Flow Guard Internals.</a> <br> <a href="https://github.com/adobe/avmplus">Source code for the Actionscript virtual machine, GitHub.</a> <br> <a href="https://www.blackhat.com/docs/eu-15/materials/eu-15-Falcon-Exploiting-Adobe-Flash-Player-In-The-Era-Of-Control-Flow-Guard.pdf">Francisco Falcon, Core Security. Exploiting Adobe Flash Player in the era of Control Flow Guard.</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/305960/">https://habr.com/ru/post/305960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305948/index.html">Mobile UX-Design: How to correctly request user permissions</a></li>
<li><a href="../305950/index.html">The use of cloud technologies in stock trading - features and prospects</a></li>
<li><a href="../305952/index.html">Usability Testing: Do you want to know the truth about your users?</a></li>
<li><a href="../305954/index.html">How do FortiASIC ‚Äã‚Äãprocessors work?</a></li>
<li><a href="../305956/index.html">Yandex.Toloka. How people help teach machine intelligence</a></li>
<li><a href="../305964/index.html">Optimization of image processing using GPU on the example of Median filtering</a></li>
<li><a href="../305966/index.html">Teach practical security: Summer internship at Positive Technologies</a></li>
<li><a href="../305968/index.html">.NET conference DotNext 2016 Moscow, December 9</a></li>
<li><a href="../305970/index.html">From England to the Mysterious Island, along with the heroes of the novels of Jules Verne</a></li>
<li><a href="../305972/index.html">Artyom Geller will be mentor of the final hackathon ‚ÄúBudgetApps‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>