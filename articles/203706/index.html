<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to run a program without an operating system: part 6. Support for working with disks with the FAT file system</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the fifth part of our series of articles, we showed how you can use BIOS interrupts after switching to protected mode, and determined the size of R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to run a program without an operating system: part 6. Support for working with disks with the FAT file system</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/company/neobit/blog/211470/">fifth</a> part of our series of articles, we showed how you can use BIOS interrupts after switching to protected mode, and determined the size of RAM as an example.  Today we will develop this success and implement full support for working with disks with the FAT16 and FAT32 file system.  Work with files on the disk can be divided into 2 parts: work with the file system and work with the disk at the read / write level of sectors.  We can say that for this we need to write the ‚Äúdriver‚Äù of the file system and the ‚Äúdriver‚Äù of the disk. <a name="habracut"></a><br><br><h4>  <b>Work with the disk at the level of read / write sectors</b> </h4><br>  To begin to learn how to work with the disk. <br>  So we can cause BIOS interrupts.  Among other features, the BIOS provides an interface for working with the disk, namely, the int 0x13 interrupt.  The list of services provided by the interruption can be found on <a href="http://en.wikipedia.org/wiki/INT_13H">Wikipedia</a> .  We are interested in the services of reading and writing disks. <br><br>  There are two ways to address a sector on a disk that the BIOS works with - CHS ( <a href="http://en.wikipedia.org/wiki/Cylinder-head-sector">cylinder-head-sector</a> ) and LBA ( <a href="http://en.wikipedia.org/wiki/Logical_block_addressing">logical block addressing</a> ).  CHS addressing is based on the use of disk geometry, and the sector address is a set of three coordinates: a cylinder, a head, a sector.  The method allows you to address up to 8GB.  The int0x13 interrupt provides the ability <a href="http://en.wikipedia.org/wiki/INT_13H">to read</a> and <a href="http://en.wikipedia.org/wiki/INT_13H">write</a> to disk using this addressing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is clear that 8GB is very small, and this addressing method is obsolete, and all modern (and not so) hard disk controllers support LBA addressing.  Addressing LBA abstracts from the disk geometry and assigns each sector its own number.  Sector numbering starts from zero.  LBA uses 48 bits to set the block number, which allows addressing 128 pi, taking into account the sector size of 512 bytes.  The int0x13 interrupt provides two services for <a href="http://en.wikipedia.org/wiki/INT_13H">reading</a> and <a href="http://en.wikipedia.org/wiki/INT_13H">writing</a> sectors to disk using LBA.  We will use them.  To read the sector, the in0x13 interrupt expects the following parameters: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fff/c31/7fd/fffc317fd57d783b5a5c0251b06b329b.jpg"><br><br>  DAP structure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1af/919/21c/1af91921c82f0e573c609b7217d8d038.jpg"><br><br>  The interrupt returns the following values: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f11/d58/61e/f11d5861eb8debace33c54a6a3ef78b9.jpg"><br><br>  One of the parameters is the disk number.  We need to somehow find out the number of the disk with which we are going to work.  The numbering is as follows: floppy disks (fdd), and everything that is emulated as floppy is numbered from scratch, and hard disks (hdd), and everything that is emulated as they (usb flash drives, for example), are numbered from 0x80.  This number is not related to the boot sequence in the BIOS settings.  In our case, the disk with which we are going to work is the disk from which we booted. <br><br>  When the BIOS transfers control to the MBR, it loads it at the address 0000h: 7C00h, and in the DL register it transfers the number of the boot device we need.  This is part of the <a href="http://en.wikipedia.org/wiki/Master_boot_record">interface</a> between the BIOS and the MBR.  Thus, this number falls into GRUB, where it is further used to work with the disk.  GRUB, in turn, passes this OS number as part of the <a href="http://www.gnu.org/software/grub/manual/multiboot/multiboot.html">Multiboot information</a> structure. <br><br>  Immediately after the transfer of control from GRUB to the OS, the EBX register contains a pointer to this structure.  The first field of the structure is flags, and if the 2nd bit is set in it, then the boot_device field is correct.  This field also belongs to the Multiboot information structure and in its high byte (the field size is 4 bytes) we store the required disk number, which is understood by the int0x13 interrupt.  Thus, using GRUB, we got the missing parameter for reading / writing sectors to disk. <br><br>  We learned to read and write sectors to disk, this is certainly important.  But the file system is not tied to the whole disk, but only to its part - the partition.  To work with the file system, you need to find the sector from which the section on which it is located begins.  Information about the sectors on the disk is stored in the first sector of the disk, in the same place where the MBR is located.  There are many different <a href="http://en.wikipedia.org/wiki/Master_boot_record">MBR formats</a> , but the following structure is true for all of them: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/60d/e1e/01c/60de1e01cf75ade0415838fc145aaeb0.jpg"><br><br>  Information about the sections is stored in the partition table.  There can be only 4 primary partitions on the disk from which you can boot.  There are 8 bytes for a partition record.  The first byte is the flags, if its value is 0x80, then the partition is bootable.  The MBR code in the course of its work runs through these 4 sections in the search for a boot partition.  After its detection, the MBR copies the contents of the first sector of this section to the address 0000h: 7C00h and transfers control there.  We are interested in the LBA address of the first sector of the boot partition, since that is where our kernel resides, and there is a file system that we are going to read.  In order to get this address, you need to read the first sector of the disk, find the partition table on it, find the boot partition in the partition table, and read the required field from its entry. <br><br>  So, we have a mechanism for reading the sector from the disk and knowledge of the location of the partition we need on the disk.  It remains to learn how to work with the file system in this section. <br><br><h4>  <b>Work with file system</b> </h4><br>  To work with the file system, we will use the <a href="http://ultra-embedded.com/%3Ffat_filelib">fat_io_lib</a> library.  The library is available under the GPL license.  It provides an interface for working with files and directories, similar to that found in libc.  Functions such as fopen (), fgets (), fputc (), fread (), fwrite (), etc. are implemented.  The library requires only two functions for its work: to write down a sector and read a sector, the first being optional.  Functions have the following prototype: <br><br><pre><code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> media_read(<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> sector, <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> *buffer, <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> sector_count); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> media_write(<span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> sector, <span class="hljs-keyword"><span class="hljs-keyword">uint8</span></span> *buffer, <span class="hljs-keyword"><span class="hljs-keyword">uint32</span></span> sector_count); Return: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> = success, <span class="hljs-number"><span class="hljs-number">0</span></span> = failure.</code> </pre> <br><br>  The library is written in pure C, which is again to our advantage.  For use in our mini-OS, we do not have to change a single line in it.  The library expects the reading of sectors to occur within the file system section. <br><br>  So, we have functions of reading / writing sector per section and there is a library for working with FAT16 / 32, which uses these functions.  It remains to collect all together and demonstrate the result.  But before turning to the code, I would like to show that the approach we are going to use is quite applicable in real life.  Below is a small part of <a href="http://en.wikipedia.org/wiki/Volume_boot_record">VBR</a> windows 7, in which the disk sector is read by interrupting int0x13.  This code is repeatedly called during the system boot process, until the boot animation is drawn. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d6/275/777/0d627577730050dfa24baa9928b2a0d0.jpg"><br><br>  To call this code, Windows 7, just as we do, goes from protected mode to real mode, and vice versa.  This is easy to verify by running Windows 7 in QEMU.  QEMU should wait for a debugger connection.  After connecting the debugger (gdb), set the breakpoint to the address (0x7c00 + 0x11d).  Triggering a breakpoint will mean calling this function.  By the way, this mechanism is absent in Windows XP, in order to trigger BIOS interrupts there, they switch to VM86 mode. <br><br>  <b>!</b>  <b>IMPORTANT!</b>  All further actions can be successfully carried out only after successful completion of all steps from the <a href="http://habrahabr.ru/company/neobit/blog/211470/">fifth</a> part of our series of articles. <br><br><h4>  Step 1. Change the main logic in kernel.c </h4><br><br>  1. Add the following declarations in the kernel.c file: <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"multiboot.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fat_io_lib/fat_filelib.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    loader.s extern u32 mbd; extern u32 magic;</span></span></span></span></code> </pre><br><br>  Code printing the size of RAM <br><br><pre> <code class="hljs perl">u64 ram_size = GetRamsize(); <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"ram_size = %llu(%lluMb)\n"</span></span>, ram_size, ram_size / <span class="hljs-number"><span class="hljs-number">0x100000</span></span>);</code> </pre> <br><br>  replace with the following code: <br><br><pre> <code class="hljs perl">// ,    grub- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (magic != MULTIBOOT_BOOTLOADER_MAGIC) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid magic number: 0x%x\n"</span></span>, magic); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } multiboot_info_t *p_multiboot_info = (multiboot_info_t*)mbd; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Is boot_device valid? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((p_multiboot_info-&gt;flags &amp; <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Error: boot_device(2) flag is clear\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (InitBootMedia(p_multiboot_info-&gt;boot_device &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Error: InitBootMedia failed.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //   fat_io_lib fl_init(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fl_attach_media(ReadBootMedia, WriteBootMedia) != FAT_INIT_OK) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Error: Media attach failed.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } //      /boot/grub fl_listdirectory(<span class="hljs-string"><span class="hljs-string">"/boot/grub"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   /boot/grub/menu.lst   char str[<span class="hljs-number"><span class="hljs-number">64</span></span>]; void *file = fl_fopen(<span class="hljs-string"><span class="hljs-string">"/boot/grub/menu.lst"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Error: can not open file.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nConntent of the file /boot/grub/menu.lst:\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (fl_fgets(str, sizeof(str), file)) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s"</span></span>, str); }</code> </pre> <br><br>  The memory for the variables mbd and magic is reserved in the file loader.s, so that they can be used similarly to the global variables from the C code. The magic variable contains a signature confirming that the Multiboot standard was used for loading, the reference implementation of which is GRUB.  The mbd variable points to the multiboot_info_t structure, which is declared in multiboot.h.  The boot disk number is determined by the following expression - p_multiboot_info-&gt; boot_device &gt;&gt; 24. The InitBootMedia function remembers the disk number and searches for the first sector of the file system so that all offsets can be read from it. <br><br>  The fat_io_lib library for initialization requires calling two functions: fl_init and fl_attach_media.  The first function resets the internal structures of the library, and the second receives the parameters of the function of reading and writing sectors to disk, which are then used to access files.  Next is a demonstration of working with the library: a list of files in the / boot / grub folder is displayed, and the contents of the menu.lst file are printed. <br><br>  2. Add the multiboot.h file to the include folder.  The contents of the file we take from the <a href="http://www.gnu.org/software/grub/manual/multiboot/multiboot.html">site</a> specifications of the previous version. <br><br><h4>  Step 2. Add functions to work with the disk </h4><br><br>  1. In the file include \ callrealmode.h add prototypes of the following functions: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">u32 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitBootMedia</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 bootDevice)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadBootMedia</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sector, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sectorCount)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteBootMedia</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sector, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sectorCount)</span></span></span></span>;</code> </pre><br><br>  2. In the include \ callrealmode_asm.h file, add a new value to enum callrealmode_Func so that the following happens: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callrealmode_Func</span></span></span></span> { CALLREALMODE_FUNC_GETSYSMEMMAP = <span class="hljs-number"><span class="hljs-number">0</span></span>, CALLREALMODE_FUNC_READ_DISK = <span class="hljs-number"><span class="hljs-number">1</span></span> };  ,       : &lt;source lang=<span class="hljs-string"><span class="hljs-string">"c"</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callrealmode_read_disk</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span> start_sector_lba; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> buff_addr; <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> sectors_count; <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span> disk_number; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> ret_code; } __attribute__ ((packed));</code> </pre> <br><br>  Add the newly declared callrealmode_read_disk structure to the union inside the callrealmode_Data structure.  You should have the following: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callrealmode_Data</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callrealmode_Func</span></span></span></span> func : <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callrealmode_GetSysMemMap</span></span></span></span> getsysmemmap; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callrealmode_read_disk</span></span></span></span> readdisk; }; } __attribute__ ((packed));</code> </pre><br><br>  3. Add the strncmp and strncpy functions used in the fat_io_lib library to the include \ string.h file. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strncmp</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * str1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * str2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( ; num &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; str1++, str2++, --num) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*str1 != *str2) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)str1 &lt; *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)str2) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : +<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*str1 == <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strncpy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> num )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *d = dst; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *s = src; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*d++ = *s++) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (--num) *d++ = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (--num); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dst; }</code> </pre> <br><br>  4. Add the following declarations to the callrealmode.c file: <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fat_io_lib/fat_opts.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbr.h"</span></span></span><span class="hljs-meta"> u64 g_BootPartitionStart = 0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//        u32 g_BootDeviceInt13Num = 0; //   </span></span></span></span></code> </pre><br><br>  And several functions: <br><br><pre> <code class="hljs perl">//     <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ReadBootMedia(unsigned long sector, unsigned char *buffer, unsigned long sectorCount) { struct callrealmode_Data param; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,     //    RM,    param.func = CALLREALMODE_FUNC_READ_DISK; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         int13. //          //    <span class="hljs-number"><span class="hljs-number">1</span></span>Mb,   <span class="hljs-string"><span class="hljs-string">"buffer"</span></span>     . //         <span class="hljs-string"><span class="hljs-string">"low_mem_buff"</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     RM ,    CALLREALMODE_OFFSET &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>Mb <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; void *low_mem_buff = CALLREALMODE_OFFSET + (&amp;callrealmode_end - &amp;callrealmode_start); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; sectorCount; i++) { param.readdisk.start_sector_lba = sector + g_BootPartitionStart + i; param.readdisk.buff_addr = (u32)low_mem_buff; param.readdisk.disk_number = g_BootDeviceInt13Num; param.readdisk.sectors_count = <span class="hljs-number"><span class="hljs-number">1</span></span>; callrealmode_Call(¬∂<span class="hljs-keyword"><span class="hljs-keyword">m</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x13</span></span>    <span class="hljs-string"><span class="hljs-string">"param"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (param.readdisk.ret_code) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> error } memcpy(buffer + i * FAT_SECTOR_SIZE, low_mem_buff, FAT_SECTOR_SIZE); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> success } //    .  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WriteBootMedia(unsigned long sector, unsigned char *buffer, unsigned long sectorCount) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> error } //   u32 InitBootMedia(u8 bootDevice) { g_BootDeviceInt13Num = bootDevice; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     MBRSector_t mbr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ReadBootMedia(<span class="hljs-number"><span class="hljs-number">0</span></span>, (u8*)&amp;mbr, <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mbr.mbr_sign[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-number"><span class="hljs-number">0x55</span></span> || mbr.mbr_sign[<span class="hljs-number"><span class="hljs-number">1</span></span>] != <span class="hljs-number"><span class="hljs-number">0xaa</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } //    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mbr.part[i].boot_indicator == <span class="hljs-number"><span class="hljs-number">0x80</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } //       g_BootPartitionStart = mbr.part[i].start_lva; <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"start sector = %lld boot dev int13 num = 0x%x\n"</span></span>, g_BootPartitionStart, g_BootDeviceInt13Num); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><br>  The ReadBootMedia and WriteBootMedia functions are used by the fat_io_lib library to read / write sectors.  The WriteBootMedia function is optional and is a stub, since in this example there is no writing to disk.  Its implementation would look similar to the ReadBootMedia function.  The ReadBootMedia function is similar to the GetRamsize function from the previous article, accurate to the type param.func, and param.readdisk is used instead of param.getsysmemmap.  The InitBootMedia function must be called before the other two, since it initializes the g_BootPartitionStart and g_BootDeviceInt13Num values. <br><br>  5. Change the callrealmode_asm.s.  Add another type of CALLREALMODE_FUNC_READ_DISK called functions, you should get the following: <br><br><pre> <code class="hljs 1c"><span class="hljs-meta"><span class="hljs-meta">#   </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> enum callrealmode_Func CALLREALMODE_FUNC_GETSYSMEMMAP = 0x0 CALLREALMODE_FUNC_READ_DISK = 0x1</span></span></code> </pre><br><br>  Next, add another check on the type of the function and directly the code that reads from the disk.  You should have the following: <br><br><pre> <code class="hljs mel">callrealmode_switch: OFF_FUNC = <span class="hljs-number"><span class="hljs-number">44</span></span> #     %bp #   func  callrealmode_Data # Which function? movw OFF_FUNC(%bp),%ax cmp $CALLREALMODE_FUNC_GETSYSMEMMAP,%ax je getsysmemmap cmp $CALLREALMODE_FUNC_READ_DISK,%ax je readdisk ret readdisk: OFF_START_SECTOR = <span class="hljs-number"><span class="hljs-number">50</span></span> #    start_sector_lba  callrealmode_Data OFF_BUFFER_ADDR = <span class="hljs-number"><span class="hljs-number">58</span></span> #    buff_addr  callrealmode_Data OFF_SECTORS_COUNT = <span class="hljs-number"><span class="hljs-number">62</span></span> #    sectors_count  callrealmode_Data OFF_DISK_NUMBER = <span class="hljs-number"><span class="hljs-number">66</span></span> #    disk_number  callrealmode_Data OFF_RETURN_CODE = <span class="hljs-number"><span class="hljs-number">68</span></span> #    ret_code  callrealmode_Data push %bp mov %sp,%bp #     DAP pushl OFF_START_SECTOR+<span class="hljs-number"><span class="hljs-number">4</span></span>(%bp) pushl OFF_START_SECTOR+<span class="hljs-number"><span class="hljs-number">0</span></span>(%bp) pushl OFF_BUFFER_ADDR(%bp) pushw OFF_SECTORS_COUNT(%bp) pushw $0x10 mov %sp,%si # ds:si    , ..  DAP mov OFF_DISK_NUMBER(%bp),%dl #    dl mov $0x42,%ah # EXTENDED READ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> $0x13 # CALL DISK BIOS mov %ah,OFF_RETURN_CODE(%bp) #   add $0x10,%sp #    DAP pop %bp ret</code> </pre><br><br>  The readdisk label points to the code that forms the DAP structure from the callrealmode_Data structure and calls int0x13.  In the code after the callrealmode_switch label, 2 instructions were added to check if readdisk should be called. <br><br>  6. Add the file include \ mbr.h, containing definitions for working with the MBR.  Its contents are: <br><br><pre> <code class="hljs rust">#ifndef _MBR_H_ #define _MBR_H_ #include <span class="hljs-string"><span class="hljs-string">"types.h"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MBRPartitionEntry</span></span></span></span> { unsigned <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> boot_indicator; unsigned <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> start_head; unsigned short start_sector : <span class="hljs-number"><span class="hljs-number">6</span></span>; unsigned short start_cylinder : <span class="hljs-number"><span class="hljs-number">10</span></span>; unsigned <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> sys_id; unsigned <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> end_head; unsigned short end_sector : <span class="hljs-number"><span class="hljs-number">6</span></span>; unsigned short end_cylinder : <span class="hljs-number"><span class="hljs-number">10</span></span>; unsigned int start_lva; unsigned int size_in_sectors; } __attribute__ ((packed)); typedef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MBRPartitionEntry</span></span></span></span> MBRPartitionEntry_t; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MBRSector</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> code[<span class="hljs-number"><span class="hljs-number">446</span></span>]; MBRPartitionEntry_t part[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> mbr_sign[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } __attribute__ ((packed)); typedef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MBRSector</span></span></span></span> MBRSector_t;</code> </pre><br><br>  The MBRSector structure is used in the InitBootMedia function. <br><br><h4>  Step 3. Add the fat_io_lib library and run </h4><br><br>  1. Download the archive <a href="">fat_io_lib.zip</a> and unpack it into the folder fat_io_lib in the project root. <br>  2. Add empty files assert.h and stdlib.h to the include folder.  They are needed for the library to compile. <br>  3. Fix the makefile.  Add files from the library to the list of targets for compilation.  You should have the following: <br><br><pre> <code class="hljs tex">FAT_LIB_OBJFILES = <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>./fat_io_lib/fat_access.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>./fat_io_lib/fat_cache.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>./fat_io_lib/fat_filelib.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>./fat_io_lib/fat_format.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>./fat_io_lib/fat_misc.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>./fat_io_lib/fat_string.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>./fat_io_lib/fat_table.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>./fat_io_lib/fat_write.o OBJFILES = <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>loader.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>common/printf.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>common/screen.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>common/string.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>kernel.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>callrealmode.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>callrealmode_asm.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>descriptor.o <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span><span class="hljs-formula"><span class="hljs-formula">$(FAT_LIB_OBJFILES)</span></span></code> </pre><br><br>  Replace the line <br><pre> <code class="hljs javascript">@dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=<span class="hljs-regexp"><span class="hljs-regexp">/dev/</span></span>zero <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>=./hdd.img bs=<span class="hljs-number"><span class="hljs-number">512</span></span> count=<span class="hljs-number"><span class="hljs-number">16065</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;<span class="hljs-regexp"><span class="hljs-regexp">/dev/</span></span><span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  On <br><pre> <code class="hljs javascript">@dd <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>=<span class="hljs-regexp"><span class="hljs-regexp">/dev/</span></span>zero <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>=./hdd.img bs=<span class="hljs-number"><span class="hljs-number">1</span></span>M count=<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;<span class="hljs-regexp"><span class="hljs-regexp">/dev/</span></span><span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  Now the image size is 10Mb.  This is done so that the mkdosfs command will format the partition in FAT16 instead of FAT12.  FAT12 is not supported by the fat_io_lib library. <br><br>  Replace the line <br><br><pre> <code class="hljs mel">$(CC) -Iinclude $(CFLAGS) -o $@ -c $&lt;</code> </pre><br><br>  On <br><br><pre> <code class="hljs mel">$(CC) -Iinclude -DFAT_PRINTF_NOINC_STDIO $(CFLAGS) -o $@ -c $&lt;</code> </pre> <br><br>  With this define, the library will not include stdio.h, but it will use a ready-made prototype of the printf function, which coincides with ours, and which is already implemented. <br><br>  4. Reconstruct the project <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">make</span></span> rebuild</code> </pre> <br>  sudo make image <br><br>  5. Run <br><br><pre> <code class="hljs pgsql">sudo qemu-<span class="hljs-keyword"><span class="hljs-keyword">system</span></span>-i386 -hda hdd.img</code> </pre> <br><br>  You should have the following: <br><br><img src="http://habrastorage.org/storage3/610/239/281/61023928189612b5ac3ffae7264d86b4.jpg"><br><br>  As in the previous parts, you can make the dd image of hdd.img on a flash drive and check the code on a real hardware by booting from it. <br><br>  As a result, we implemented the work with the FAT16 and FAT32 file systems.  We fooled a bit using the ready-made library, but it would be less interesting to understand the FAT device, and we would hardly have been able to do it in 1 article.  I hope you enjoyed reading.  Write in the comments, if you have problems in the passage of the steps described! <br><br>  Selection of references to the previous parts: <br><ul><li>  <a href="http://habrahabr.ru/company/neobit/blog/173263/">How to run a program without an operating system</a> </li><li>  <a href="http://habrahabr.ru/company/neobit/blog/174157/">How to run a program without an operating system: part 2</a> </li><li>  <a href="http://habrahabr.ru/company/neobit/blog/176707/">How to run a program without an operating system: part 3: Graphics</a> </li><li>  <a href="http://habrahabr.ru/company/neobit/blog/181626/">How to run a program without an operating system: part 4. Parallel computing</a> </li><li>  <a href="http://habrahabr.ru/company/neobit/blog/211470/">How to run a program without an operating system: part 5. Accessing the BIOS from the OS</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/203706/">https://habr.com/ru/post/203706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../203696/index.html">Open State. data. Made in Ukraine</a></li>
<li><a href="../203698/index.html">Picaso 3D-Builder - Made in Russia</a></li>
<li><a href="../203700/index.html">Optimization of enumeration of surfaces composed of triangles</a></li>
<li><a href="../203702/index.html">Zend Framework 2.0 web application development</a></li>
<li><a href="../203704/index.html">Theory of a Large Supercomputer</a></li>
<li><a href="../203708/index.html">Black Hat USA 2013. What was a little about the reports</a></li>
<li><a href="../203714/index.html">US Department of Health threatens 23andMe</a></li>
<li><a href="../203720/index.html">MakeItLab & CoolRF at the International Exhibition Center</a></li>
<li><a href="../203724/index.html">Resumable functions</a></li>
<li><a href="../203726/index.html">Comparative study of the results of applying Scrum- and Kanban approaches based on case studies and modeling</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>