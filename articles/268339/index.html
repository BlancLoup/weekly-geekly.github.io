<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Adding a new processor family to IDA pro</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It was necessary not so long ago to gut the firmware from the M16C (Mitsubishi / Renesas). I was surprised to find out that IDA v6.1.xxx does not ‚Äúhol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Adding a new processor family to IDA pro</h1><div class="post__text post__text-html js-mediator-article">  It was necessary not so long ago to gut the firmware from the M16C (Mitsubishi / Renesas).  I was surprised to find out that IDA v6.1.xxx does not ‚Äúhold‚Äù this family of controllers, alas.  However, the SDK is available, so it's not scary - we will correct the situation.  As practice has shown, there is nothing beyond the complexity in writing your module (no rocket science, tea). <br><a name="habracut"></a><br><h4>  Denial of responsibility </h4><br>  I am not an expert on IDA pro and writing modules for it.  Since the task was to analyze the firmware, the module was written in a hurry (on the knee), part of the code was pulled from the SDK, without understanding how it works (and whether this is necessary at all).  We managed to figure out the rest of the code and it was ‚Äúcreatively‚Äù rethought. <br><br>  I did not have tests and time to write them.  The correctness of the work was verified by disassembling the firmware listing in the IDE from Renesas.  Thus, it is possible (and certainly is, although I did not come across in the process of work) errors.  If someone has a desire to write tests or modify the module, I will be glad. <br><br>  Anyway, the module turned out quite working and allowed to perform the task.  In this article I will present my thoughts on all of this.  So use this work at your own risk. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Sources and plugin build </h4><br>  The sources are <a href="https://github.com/Damon-V79/IDA_Plugins">here</a> . <br>  Since I do not particularly respect ‚ÄúStudio‚Äù (MSVC ++), I used MinGW to build it and pile up my toolchain.  You can take it <a href="https://drive.google.com/open%3Fid%3D0B97fmWkRKVpeWTE1c1AyTTJSY2M">here</a> .  This toolchain is self-sufficient - contains a compiler and tools for building. <br><br>  Preparation for assembly is as follows.  Unpack the IDA_Plugins.7z somewhere, clone the repository from GitHub and copy the m16c_xx directory to the root of the IDA_Plugins directory, then run build.cmd. <br><br><h4>  Introduction </h4><br>  Each processor module that is actually a regular dll (with a slight difference - the DOS header is slightly modified) must export a structure named LPH, with a processor_t type.  It stores pointers to key functions and module structures. <br>  Of all the variety of fields of this structure, we are primarily interested in the following function pointers: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">processor_t</span></span> LPH = { ‚Ä¶ ana, <span class="hljs-comment"><span class="hljs-comment">// analyze an instruction and fill the 'cmd' structure emu, // emulate an instruction out, // generate a text representation of an instruction outop, // generate a text representation of an operand ‚Ä¶ }</span></span></code> </pre> <br>  With their help, basically, all the work is done.  The <i>ana ()</i> function is called each time when analyzing a new instruction (if there is something to analyze), its signature: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ana</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//analyze one instruction and return the // instruction length</span></span></code> </pre><br>  The task of this function, by sampling the byte at the current instruction pointer, try to decode the instruction, if not, continue to select subsequent bytes until all instruction and its operands are decoded.  Then fill in the global cmd fields and return the length of the instruction in bytes. <br><br>  The <i>emu ()</i> function is intended to emulate an instruction, its signature: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//emulate one instruction</span></span></code> </pre><br>  The purpose of this function is to: <br><ul><li>  creating cross-references from (to) this instruction, both for data and for code; <br></li><li>  creating stack variables (unfortunately, I haven't figured out how it works yet) <br></li><li>  something else there. <br></li></ul><br>  The <i>out ()</i> function creates and displays a textual representation of the assembler instruction, its signature: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//output a single disassembled instruction</span></span></code> </pre><br>  The <i>outop ()</i> function creates and displays a textual representation of the operands of an assembler instruction, its signature: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">op_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;x)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//output an operand of disassembled // instruction</span></span></code> </pre><br><h4>  Instruction analysis </h4><br>  The source data is <i>analyzed by the ana ()</i> function, which we have to implement.  Its task, reading successively the bytes of the firmware, is to determine the instructions, their operands and the lengths of the instructions. <br><br>  After recognizing the instruction and its parameters, fill in the fields of the global variable cmd, which has the type <i>insn_t</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">insn_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> cs; <span class="hljs-comment"><span class="hljs-comment">// Current segment base paragraph. Set by kernel ea_t ip; // Virtual address of instruction (within segment). // Set by kernel ea_t ea; // Linear address of the instruction. Set by kernel uint16 itype; // instruction enum value (not opcode!). // Proc sets this in ana uint16 size; // Size of instruction in bytes. Proc sets this in ana union { // processor dependent field. Proc may set this uint16 auxpref; struct { uchar low; uchar high; } auxpref_chars; }; char segpref; // processor dependent field. Proc may set this char insnpref; // processor dependent field. Proc may set this op_t Operands[6]; // instruction operand info. Proc sets this in ana char flags; // instruction flags. Proc may set this };</span></span></code> </pre><br>  As can be seen from the description, instructions can have up to 6 operands (which is ‚Äúbehind our eyes‚Äù for us - in our case, the operations contain a maximum of 3 operands). <br><br>  So far, I have written a module only for the RISC controller - everything is quite simple there.  We put a mask on the KOP field (Operation Code) instructions, check additional conditions in the branches of the <i>switch statement</i> and, in fact, everything (this is how the code for the Microchip PIC is analyzed, an example can be found in the SDK).  The advantages of RISC here are obvious - an abbreviated set of commands and their identical length.  Alas, for the M16C, I counted more than 300 unique teams (it all depends on the point of view - I took into account unique COPs), and yes even variable-length commands (CISC).  Thus, the <i>switch statement</i> does not suit us because of its cumbersome and fraughtness with subtle errors. <br><br>  Here it is necessary to make a small lyrical digression.  Since the machine code (as well as the assembler itself) is in fact a <i>regular language</i> ( <i>grammar</i> ), it must, without any problems, be understood using the state machine (FSM), which, in essence, is the processor. <br><br>  There was no desire to manually automate a manual, but there was a positive experience with <i>Ragel</i> - a compiler of finite automata with a special description language FSM into code in C, C ++, C #, Objective-C, D, Java, OCaml, Go or Ruby.  It does not create any external dependencies, only a self-contained source in the selected programming language. <br><br>  Among other things, <i>Ragel is</i> interesting because it allows you to parse the input data on the fly.  Those.  there is no need to form and transmit a large buffer to the parser for analysis, which is guaranteed to contain a command, but it can be limited to small amounts of data, up to one byte, with state preserved between calls.  It is perfect for us! <br><br>  The result was a <i>DSL</i> for parsing processor commands. <br><br><h4>  DSL to parse commands </h4><br>  The advantage of this <i>DSL</i> over <i>switch</i> , primarily in its linearity.  No need to jump on the branches of the operator to understand how it works or behavior modification.  All processing of CPCs and operands for a specific team is concentrated in one place.  Example: <br><pre> <code class="cpp hljs">#<span class="hljs-comment"><span class="hljs-comment">// 0x00 0000 0000 BRK M16C_BRK = 0x00 @ { cmd.itype = M16C_xx_BRK; cmd.Op1.type = o_void; cmd.Op1.dtyp = dt_void; };</span></span></code> </pre><br>  Or, as an option, a command with operands: <br><br><pre> <code class="cpp hljs">#<span class="hljs-comment"><span class="hljs-comment">// 0x01..0x03 0000 00DS MOV.B:S R0L, DEST M16C_MOV_B_S_R0L_DEST = (0x01..0x03) @ { cmd.itype = M16C_xx_MOV_B_S_R0L_DEST; MakeSrcDest8(SRC_DEST_R0L, cmd.Op1); switch(*p &amp; 0x03) { case 0x01: MakeSrcDest8(SRC_DEST_DSP_8_SB_, cmd.Op2); break; case 0x02: MakeSrcDest8(SRC_DEST_DSP_8_FB_, cmd.Op2); break; default: MakeSrcDest8(SRC_DEST_ABS16, cmd.Op2); break; } };</span></span></code> </pre><br>  It seems to me, quite clearly and conveniently.  One of the <i>enum opcodes</i> enumeration values ‚Äã‚Äã( <i>ins.hpp</i> file) is <i>placed in cmd.itype</i> , which will later indicate the textual representation of the instruction, the number of operands, and describe the interaction of the instruction with operands.  And also the fields of operands are filled. <br><br><h4>  Emulation of instruction execution </h4><br>  The instructions themselves, the number of operands and the effect on operands is described in the <i>instruc_t instructions []</i> ( <i>ins.cpp</i> ) <i>array</i> .  In principle, the format of records is simple and intuitive: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">instruc_t</span></span> instructions[ ] = { ... { <span class="hljs-string"><span class="hljs-string">"ADC.B"</span></span>, CF_USE1|CF_CHG2 }, { <span class="hljs-string"><span class="hljs-string">"ADC.W"</span></span>, CF_USE1|CF_CHG2 }, { <span class="hljs-string"><span class="hljs-string">"ADC.B"</span></span>, CF_USE1|CF_CHG2 }, { <span class="hljs-string"><span class="hljs-string">"ADC.W"</span></span>, CF_USE1|CF_CHG2 }, { <span class="hljs-string"><span class="hljs-string">"ADCF.B"</span></span>, CF_CHG1 }, { <span class="hljs-string"><span class="hljs-string">"ADCF.W"</span></span>, CF_CHG1 }, { <span class="hljs-string"><span class="hljs-string">"ADD.B:G"</span></span>, CF_USE1|CF_CHG2 }, { <span class="hljs-string"><span class="hljs-string">"ADD.W:G"</span></span>, CF_USE1|CF_CHG2 }, { <span class="hljs-string"><span class="hljs-string">"ADD.B:Q"</span></span>, CF_USE1|CF_CHG2 }, ... };</code> </pre><br>  It is seen that the instruction " <i>ADC.B</i> " has 2 operands, the first one is simply used, and the second one is changed during the instruction execution.  Which is logical: <i>ADC</i> is addition with transfer ( <i>ADdition with Carry</i> ) and the operation looks like this: <br><br><pre> <code class="cpp hljs">[ Syntax ] ADC.size src,dest ^--- B, W [ Operation ] dest &lt;- src + dest + C</code> </pre><br>  Further, the execution of the instruction itself in the <i>emu ()</i> function is <i>emulated</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> feature = cmd.get_canon_feature( ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( feature &amp; CF_USE1 ) TouchArg( cmd.Op1, <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( feature &amp; CF_USE2 ) TouchArg( cmd.Op2, <span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( feature &amp; CF_CHG1 ) TouchArg( cmd.Op1, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( feature &amp; CF_CHG2 ) TouchArg( cmd.Op2, <span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !( feature &amp; CF_STOP ) ) ua_add_cref( <span class="hljs-number"><span class="hljs-number">0</span></span>, cmd.ea + cmd.size, fl_F); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  As you can see, if there is an argument, we will convert it to a digestible view in the <i>TouchArg ()</i> function.  This function looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">op_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isload )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> ( x.type ) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_near: { <span class="hljs-keyword"><span class="hljs-keyword">cref_t</span></span> ftype = fl_JN; <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> ea = toEA(cmd.cs, x.addr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( InstrIsSet(cmd.itype, CF_CALL) ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !func_does_return(ea) ) flow = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ftype = fl_CN; } ua_add_cref(x.offb, ea, ftype); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_imm: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !isload ) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; op_num(cmd.ea, xn); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( isOff(uFlag, xn) ) ua_add_off_drefs2(x, dr_O, OOF_SIGNED); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_displ: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(x.dtyp == dt_byte) op_dec(cmd.ea, xn); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_mem: { <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> ea = toEA( dataSeg( ),x.addr ); ua_dodata2( x.offb, ea, x.dtyp ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !isload ) doVar( ea ); ua_add_dref( x.offb, ea, isload ? dr_R : dr_W ); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Depending on the type of the operand, we appropriately fill in the fields of the <i>op_t</i> structure (‚Äúdecode‚Äù the operand). <br><br><h4>  The output text of the instructions </h4><br>  The out () function is responsible for this action.  It looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> str[MAXSTR]; <span class="hljs-comment"><span class="hljs-comment">//MAXSTR is an IDA define from pro.h init_output_buffer(str, sizeof(str)); OutMnem(12); //first we output the mnemonic if( cmd.Op1.type != o_void ) //then there is an argument to print out_one_operand( 0 ); if( cmd.Op2.type != o_void ) { //then there is an argument to print out_symbol(','); out_symbol(' '); out_one_operand( 1 ); } if( cmd.Op3.type != o_void ) { //then there is an argument to print out_symbol(','); out_symbol(' '); out_one_operand( 2 ); } term_output_buffer(); gl_comm = 1; //we want comments! MakeLine(str); //output the line with default indentation }</span></span></code> </pre><br>  Print the textual representation of the instruction and, if there are, operands with minimal formatting. <br><br><h4>  Textual representation of operands </h4><br>  Here the code is more interesting, but everything is also quite simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">op_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> ea; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (x.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_void: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_imm: OutValue(x, OOF_NUMBER | OOF_SIGNED | OOFW_IMM); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> o_displ: { <span class="hljs-comment"><span class="hljs-comment">//then there is an argument to print OutValue(x, OOF_NUMBER | OOF_SIGNED | OOFW_IMM); switch (x.dtyp) { case dt_byte: break; case dt_word: out_symbol(':'); out_symbol('8'); break; case dt_dword: out_symbol(':'); out_symbol('1'); out_symbol('6'); break; default: ea = toEA(cmd.cs, x.addr); if (!out_name_expr(x, ea, x.addr)) out_bad_address(x.addr); break; } out_symbol('['); out_register(M16C_xx_RegNames[x.reg]); out_symbol(']'); } break; case o_phrase: out_symbol('['); out_register(M16C_xx_RegNames[x.reg]); out_symbol(']'); break; case o_near: ea = toEA(cmd.cs, x.addr); if (!out_name_expr(x, ea, x.addr)) out_bad_address(x.addr); break; case o_mem: ea = toEA(dataSeg(), x.addr); if (!out_name_expr(x, ea, x.addr)) out_bad_address(x.addr); break; case o_reg: out_register(M16C_xx_RegNames[x.reg]); break; default: warning("out: %a: bad optype %d", cmd.ea, x.type); break; } return true; }</span></span></code> </pre><br>  Depending on the type of operand, we make its output to the screen accordingly. <br><br><h4>  Deficiencies and problems identified </h4><br>  At the moment there is one significant neponyatka.  When you try to create a string (ASCII-Z String) in Undefined data, the string is created only up to an address multiple of four bytes, even if the zero byte has not yet been encountered.  If the zero byte occurs earlier, then the string ends with it.  With an array, the same problem. <br><br>  The most annoying thing is that I don‚Äôt even know where to dig in this situation.  Can someone tell me? <br><br><h4>  Conclusion </h4><br>  Thus, writing plugins for IDA pro is not very difficult.  It's simple, except that with a large number of commands target assembler, quite tedious.  The introduction of <i>DSL</i> to parse the CPCs and operands greatly simplifies and speeds up development. </div><p>Source: <a href="https://habr.com/ru/post/268339/">https://habr.com/ru/post/268339/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268329/index.html">Intel sold Microsoft's Havok</a></li>
<li><a href="../268331/index.html">DHCP server on multiple VLANs</a></li>
<li><a href="../268333/index.html">Office as Platform Issue 5 - Introducing the OneNote REST API</a></li>
<li><a href="../268335/index.html">(Archive) Matreshka.js ECMAScript.next boilerplate</a></li>
<li><a href="../268337/index.html">Welcome to OWASP EEE October 11</a></li>
<li><a href="../268341/index.html">We are looking for stability in retail, XYZ analysis of the range</a></li>
<li><a href="../268343/index.html">How do startups need IaaS: Speech Recognition Services</a></li>
<li><a href="../268347/index.html">I will give the domain and site pastebin.ru</a></li>
<li><a href="../268349/index.html">Saving electricity on thin clients</a></li>
<li><a href="../268351/index.html">Calculation of formulas in office editors. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>