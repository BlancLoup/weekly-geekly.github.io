<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Database scaling through sharding and partitioning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Database scaling through sharding and partitioning 
 Denis Ivanov (2GIS) 
 Hello! My name is Denis Ivanov, and I will talk about database scaling thro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Database scaling through sharding and partitioning</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/2ff/736/498/2ff736498107c4bc32fe46ba15ce828e.jpg"><br><br><h1>  Database scaling through sharding and partitioning </h1><br><h2>  Denis Ivanov (2GIS) </h2><br>  Hello!  My name is Denis Ivanov, and I will talk about database scaling through sharding and partitioning.  After this report, everyone should have a desire to partivate something, shard them, you will understand that it is very simple, it does not ask for anything, it works, and everything is fine. <br><br>  I will tell you a little about myself - I work in the WebAPI team at 2GIS, we provide API for organizations, we have a lot of different data, 8 countries in which we work, 250 large cities, 50 thousand settlements.  We have a fairly large load - 25 million active users per month, and on average, about 2000 RPS loads go to the API.  All this is located in the three data centers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let us turn to the problems that we are going to solve today.  One of the problems is a large amount of data.  When you develop a project, it may happen at your moment that there is a lot of data.  If the business works, it brings money.  Accordingly, there is more data, more money, and something needs to be done with this data, because these requests start to run for a very long time, and our server does not begin to export.  One solution to do with this data is to scale the database. <br><a name="habracut"></a><br>  I will tell you more about sharding.  It can be vertical and horizontal.  There is also such a scaling method as replication.  The report " <a href="http://highload.guide/blog/mysql_replication_2015.html">How MySQL Replication Works</a> " by Andrei Aksenov from Sphinx was about it.  I practically will not cover this topic. <br><br>  Let's move on to the topic of partitioning (vertical sharding).  How does all this look? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/698/bdb/5c3/698bdb5c3854f92fea96ff3541a4e85c.png"><br><br>  We have a large table, for example, with users - we have a lot of users.  Partitioning is when we divide one big table into many small ones according to some principle. <br>  With horizontal sharding, everything is about the same, but at the same time, our tablets are in different bases on other instances. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f9/866/234/5f98662349e71b09690af453c8bfccf9.png"><br><br>  The only difference between horizontal scaling and vertical scaling is that horizontal scaling will spread data across different instances. <br><br>  About replication, I will not stop, everything is very simple. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/101/9b0/e90/1019b0e90b4a8cedcd43da9dc12a0ff6.png"><br><br>  Let's go deeper into this topic, and I will tell almost everything about partitioning using the example of Postgres. <br>  Let's look at a simple tablet, for sure, in almost 99% of projects there is such a tablet - this is news. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/290/e45/374/290e453749d55dd58b47e370c863f041.png"><br><br>  The news has an identifier, there is a category in which this news is located, there is the author of the news, its rating and some kind of heading - a completely standard table, nothing complicated. <br><br>  How can this table be divided into several?  Where to begin? <br><br>  In total, you will need to make 2 actions on the tablet - this is put in our shard, for example, news_1, that it will be inherited from the news table.  News will be the base table, it will contain the entire structure, and we will create a partition, indicating that it is inherited by our base table.  The inherited table will have all the columns of the parent - the base table that we specified, and it can also have its own columns, which we will additionally add there.  It will be a complete table, but inherited from the parent, and there will be no restrictions, indices and triggers from the parent - this is very important.  If you create indexes on the base table and inherit it, then there will be no restrictions or triggers in the inherited index table. <br><br>  The second action that needs to be done is to put restrictions.  This will be a check that only data with such a sign will fall into this table. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6a/e78/c80/c6ae78c800ec94e83ec95ff866125af3.png"><br><br>  In this case, the attribute is category_id = 1, i.e.  only entries with category_id = 1 will fall into this table. <br>  What types of checks are for partitioned tables? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/945/882/783/9458827838e5e7e1a0e153f6539276e4.png"><br><br>  There is a strict value, i.e.  we have some field clearly equal to some field.  There is a list of values ‚Äã‚Äã- this is an entry in the list, for example, we can have 3 news authors in this particular partition, and there is a range of values ‚Äã‚Äã- from what value to which data will be stored. <br><br>  Here you need to stop in more detail, because the check supports the BETWEEN operator, for sure you all know it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d41/d52/a9f/d41d52a9f8e4e090300bc93396ca9a03.png"><br><br>  And so easy to do it.  But it is impossible.  It can be done because we will be allowed to do this, PostgreSQL supports this.  As you can see, we have data in the 1st partition between 100 and 200, and in the 2nd one - between 200 and 300. Which of these partitions will get a record with a rating of 200?  It is not known how lucky.  Therefore, it is impossible to do this, you need to specify a strict value, i.e.  strictly, the 1st partition will contain values ‚Äã‚Äãgreater than 100 and less than or equal to 200, and to the second more than 200, but not 200, and less than or equal to 300. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14d/dc1/005/14ddc1005cfb1b4d5e51b536a222e538.png"><br><br>  It is necessary to remember this and not to do so, because you will not know which of the partitions the data will fall into.  It is necessary to clearly register all the conditions of the test. <br><br>  You should also not create partitions for different fields, i.e.  that in the 1st partition we will get records with category_id = 1, and in the 2nd - with a rating of 100. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/730/fee/f5c/730feef5cace9f5ec636c77a6c5924ff.png"><br><br>  Again, if we get a record in which category_id = 1 and rating = 100, then it is not known which of the partitions this record will fall into.  It is worth partiing by one sign, by some one field - this is very important. <br>  Let's take a look at our partition entirely: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d3/7b9/874/8d37b987486c3bc3e3e0f67f7bcd1a50.png"><br><br>  Your partitioned table will look like this, i.e.  this is the news_1 table with a sign that only entries with category_id = 1 will be included there, and this table will be inherited from the base news table - everything is very simple. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed7/458/57a/ed745857a1c77342895dad234242743e.png"><br><br>  We have to add a rule to the base table so that when we work with our main news table, the insert for the record with category_id = 1 falls into that partition, and not into the main one.  We specify a simple rule, call it what we want, and say that when data will be inserted into news with category_id = 1, we will instead insert data into news_1.  Here, too, everything is very simple: on the template, it all changes and it will be great to work.  This rule is created on the base table. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/5d7/6f6/3ad5d76f6e8167e55ef63fe7fa769451.png"><br><br>  Thus we get the number of partitions we need.  For example, I will use 2 partitions to make it easier.  Those.  we are all the same, except for the names of this table and the conditions under which the data will fall there.  We also create the appropriate rules for the pattern on each of the tables. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ee/14b/756/0ee14b75629e19e6c0b52c3788956992.png"><br><br>  Let's look at an example of inserting data: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/213/59d/3ab/21359d3ab564fb9e6db66f0cd9b611bc.png"><br><br>  We will insert the data as usual, as if we have an ordinary big thick table, i.e.  we insert a record with category_id = 1 with category_id = 2, we can even insert data with category_id = 3. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/193/b3c/55a/193b3c55ab6bc6ea94f28d70924bc8c2.png"><br><br>  Here we select the data, we have it all: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ec/78c/e6c/3ec78ce6cff8e96f0953d094262b1979.png"><br><br>  All that we inserted, despite the fact that we have no 3rd partition, but there is data.  There may be a little bit of magic in this, but actually not. <br><br>  We can also make corresponding queries in certain partitions, indicating our condition, i.e. category_id = 1, or occurrence in the numbers (2, 3). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18f/2a5/028/18f2a502843cc87ec783e56405d3818e.png"><br><br>  Everything will work fine, all data will be selected.  Again, despite the fact that from the partition with category_id = 3 we do not have. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0be/8d4/fbe/0be8d4fbe9ab219289a83162f548afe6.png"><br><br>  We can select data directly from partitions - this will be the same as in the previous example, but we clearly indicate the partition we need.  When we have an exact condition on the fact that we need to select data from this partition, we can directly specify this partition and not go to others.  But we do not have the 3rd partition, and the data will fall into the main table. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/562/20f/bbc/56220fbbc4b278004c5a516023be5220.png"><br><br>  Even though we have applied partitioning to this table, the main table still exists.  It is a real table, it can store data, and using the ONLY operator, you can only select data from this table, and we can find that this record is hidden here. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b35/41d/e79/b3541de7954e06ecfcdb9c5106081cac.png"><br><br>  Here you can, as can be seen on the slide, insert data directly into the partition.  You can insert data using rules in the main table, but you can also in the partition itself. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a54/d28/af2/a54d28af2d0c4b9314fb37f77c05d83f.png"><br><br>  If we insert data into the partition with some kind of alien condition, for example, with category_id = 4, then we get the error "such data cannot be inserted here" - this is also very convenient - we will just put the data only into those partitions that we really needed, and if something goes wrong with us, we will catch all this at the base level. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a0/9ee/4e1/3a09ee4e194c84aa06f862979c29453e.png"><br><br>  Here is a bigger example.  You can use bulk_insert, i.e.  insert several records at the same time and they will all be distributed using the rules of the desired partition.  Those.  we can not bother at all, just work with our table, as we used to work.  The application will continue to work, but the data will fall into the partition, it will all be beautifully laid out on the shelves without our participation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/716/3d6/d66/7163d6d66609536d262e95086d3c402f.png"><br><br>  Let me remind you that we can select data as from the main table with indication of the condition, we can, without indicating this condition, select data from the partition.  How it looks from the side of the explain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4bb/493/3d7/4bb4933d7fd7ddc0017642b83f8b7961.png"><br><br>  We will have Seq Scan all over the table, because there the data can still get there, and there will be a scan by partition.  If we specify the conditions of several categories, then it will scan only those tables for which there are conditions.  He will not look at the other partitions.  This is how the optimizer works ‚Äî that's right, and it‚Äôs really faster. <br><br>  We can see what the explain will look like on the partition itself. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ea/e18/bbc/3eae18bbc4fdd43d2647bc26d8665abb.png"><br><br>  This will be a regular table, just a Seq Scan for it, nothing supernatural.  In the same way update'y and delete'y will work.  We can update the main table, we can also send updates directly to the partitions.  Similarly, delete will work.  They also need to create the corresponding rules, as we created with insert, but instead of insert, write update or delete. <br><br><h3>  Let's move on to things like Indexes. </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/5ce/f17/096/5cef170960d78f09699fa1a8bfd4e978.png"><br><br>  Indexes created on the main table will not be inherited in the child table of our partition.  This is sad, but you have to get the same index on all partitions.  There is a lot to do about it, but you have to get all the indices, all the restrictions, all the triggers duplicated on all the tables. <br><br>  As we struggled with this problem at home.  We have created a wonderful utility PartitionMagic, which allows you to automatically manage partitions and not bother with creating indexes, triggers with non-existent partitions, with some kind of biases that can occur.  This utility is open source, below will be a link.  We add this utility in the form of a stored procedure to our database, it lies there, does not require additional extensions, no extensions, nothing needs to be reassembled, i.e.  we take PostgreSQL, the usual procedure, push it into the database and work with it. <br><br>  Here is the same table that we looked at, nothing new, everything is the same. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b93/ce7/21a/b93ce721a70c156b0d42d49df0bd9008.png"><br><br>  How do we partize it?  And just like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73e/0cc/673/73e0cc67313e859517a1a8e9f83cfeb0.png"><br><br>  We call the procedure, indicate that the table will be news, and we will partition by category_id.  And everything will continue to work on its own, we don‚Äôt need to do anything else.  We also insert data. <br><br>  We have three entries with category_id = 1, two entries with category_id = 2, and one with category_id = 3. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a2/bca/a0c/1a2bcaa0c1afc3642a5b36ef41ea0272.png"><br><br>  After insertion, the data will automatically fall into the necessary partitions, we can make selections. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f4/ca1/587/4f4ca158713251a1fdc6015a596ef564.png"><br><br>  Everything, partitions have already been created, all the data are decomposed on the shelves, everything works fine. <br>  What we get from this advantage: <br><br><ul><li>  when inserting, we automatically create a partition if it is not already there; </li><li>  we support the current structure, we can manage just the base table, putting indexes on it, checks, triggers, add columns, and they will automatically fall into all partitions after calling this procedure again. </li></ul><br>  We get a really big advantage in this.  Here ssylochka <a href="https://github.com/2gis/partition_magic">https://github.com/2gis/partition_magic</a> .  This concludes the first part of the report.  We learned to partition the data.  Let me remind you that partitioning is applied on one instance - this is the same base instance where you would have a large thick table, but we split it into small parts.  We can absolutely not change our application - it will work in the same way with the main table - we insert data into it, edit it, delete it.  It also works, but it works faster.  Approximately, on average, 3-4 times faster. <br><br>  We turn to the second part of the report - this is a horizontal sharding.  Let me remind you that horizontal sharding is when we distribute data across several servers.  All this is done too simply, once you set it up, and it will work great.  I will tell you more about how this can be done. <br><br>  We will consider the same structure with two shards - news_1 and news_2, but these will be different instances, the third instance will be the main base from which we will work: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6fc/8af/339/6fc8af33978d6c054cef589574962f2f.png"><br><br>  Same table: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e89/77e/407/e8977e407408a387e4f225fac312b629.png"><br><br>  The only thing to add there is CONSTRAINT CHECK, the fact that the records will fall out only with category_id = 1.  Just as in the previous example, but this is not an inherited table, it will be a table with a shard that we do on a server that will act as a shard with category_id = 1.  It needs to be remembered.  The only thing you need to do is add CONSTRAINT. <br><br>  We can additionally create an index by category_id: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fd7/193/58f/fd719358f1e1f1ae02642b1168dd07b1.png"><br><br>  Despite the fact that we have a check check, PostgreSQL still calls this shard, and a shard can think for a very long time, because there can be a lot of data, and in the case of an index, it will respond quickly because there is nothing in the index on such a request, so it is better to add it. <br><br>  How to configure sharding on the main server? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a89/c2e/638/a89c2e638e127562ab8fa056ff000485.png"><br><br>  We connect EXTENSION.  EXTENSION goes to Postgres out of the box, this is done by the CREATE EXTENSION command, it is called postgres_fdw, it stands for foreign data wrapper. <br><br>  Next, we need to have a remote server, connect it to the main server, we call it whatever you like, we indicate that this server will use the foreign data wrapper, which we have indicated. <br><br>  In the same way, you can use for the shard MySql, Oracle, Mongo ... Foreign data wrapper is available for very many databases, i.e.  it is possible to store separate shards in different bases. <br><br>  In the option we add the host, port and name of the base from which we will work, you just need to specify the address of your server, the port (most likely, it will be standard) and the base that we have entered. <br><br>  Next, we create a mapping for the user - according to this data, the main server will be authorized to the child.  We indicate that for the server news_1 there will be a postgres user, with the password postgres.  And it will be mapped to the main database as our user postgres. <br><br>  I showed everything with standard settings, you can have your own users for projects, for individual bases, here you need to specify them for everything to work. <br><br>  Next, we get a sign on the main server: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f77/9c4/722/f779c47227dfbdfd3c54d51795eccf3d.png"><br><br>  It will be a sign with the same structure, but the only thing that will be different is the prefix that it will be a foreign table, i.e.  it is some kind of foreign for us, remote, and we indicate from which server it will be taken, and in the options we indicate the scheme and the name of the table that we need to take. <br><br>  The default scheme is public, the table we got was called news.  Similarly, we connect the 2nd table to the main server, i.e.  we add the server, we add a mapping, we create the table.  All that is left is to get our main table. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a07/038/4e5/a070384e516dd5466ee15fc314b1dc44.png"><br><br>  This is done using VIEW, through the view, we use UNION ALL to glue queries from remote tables and get one big thick news table from remote servers. <br><br>  We can also add rules to this table when inserting, deleting, to work with the main table instead of shards, so that it is more convenient for us - no rewriting, nothing in the application to do. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7b/45b/5c6/a7b45b5c62ec791990b5ae02ec47a6dc.png"><br><br>  We make a basic rule that will work if no checks have worked, so that nothing happens.  Those.  we specify DO INSTEAD NOTHING and start the same checks as we did before, but only with our condition, i.e.  category_id = 1 and the table to which the data will instead fall. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f31/26b/c92/f3126bc927aa8d4a95cb8d1b70c19bb8.png"><br><br>  Those.  the only difference is that in category_id we will specify the name of the table.  Also look at the insert data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/853/8ca/139/8538ca13968d5b91257ca850580d387c.png"><br><br>  I specifically singled out non-existent partitions, since  these data, by our condition, will not get anywhere, i.e.  we have stated that we will not do anything if there is no condition, because this is a VIEW, this is not a real table, data cannot be inserted there.  In that condition we can write that the data will be inserted into some third table, i.e.  we can get something like a buffer or a basket and INSERT INTO to do in that table, so that data is accumulated there, if suddenly we have no partitions, and the data began to arrive, for which there are no shards. <br><br><h3>  Select data </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/5aa/536/d66/5aa536d6691aee674b1e37e9316aa207.png"><br><br>  Pay attention to the sorting of identifiers - we first display all the records from the first shard, then from the second.  This is due to the fact that postgres walks VIEW sequentially.  We have selected selects via UNION ALL, and it executes this way - it sends requests to remote machines, collects this data and sticks together, and they will be sorted according to the principle we used to create this VIEW, according to which that server gave the data. <br><br>  We make requests, which we did earlier from the main table with the category, then postgres will give data only from the second shard, or directly contact the shard. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b98/975/a15/b98975a158094433da0740dc83861a9e.png"><br><br>  Just as in the examples above, only we have different servers, different instances, and everything works just the same as it did before. <br><br>  Let's look at explain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df6/541/a0c/df6541a0c391debe2d60f907ffae7ffc.png"><br><br>  We have foreign scan for news_1 and foreign scan for news_2, just as it was with partitioning, but instead of Seq Scan, we have foreign scan - this is a remote scan that runs on another server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/518/a53/1b0/518a531b0033cdf3fdd9cc1568caf2a4.png"><br><br>  <b>Partitioning</b> is really easy, you just have to do a few actions, set everything up, and it will work fine, it won't ask for food.  You can also work with the main table, as we have worked before, but at the same time everything is fine on the shelves and ready for scaling, ready for a large amount of data.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All this works on one server, and at the same time we get a performance increase of 3-4 times, due to the fact that we have reduced the amount of data in the table, because </font><font style="vertical-align: inherit;">these are different tables. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sharding</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is only slightly more complicated than partitioning, because you need to configure each server separately, but this gives some advantage in that we can simply add an infinite number of servers, and everything will work fine.</font></font><br><br><h2>  Contacts </h2><br> <a href="https://habrahabr.ru/company/2gis/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2GIS blog</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/309330/">https://habr.com/ru/post/309330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309318/index.html">4 types of memory leaks in javascript and how to deal with them</a></li>
<li><a href="../309320/index.html">Mail of Russia: in e-commerce-future with cautious optimism</a></li>
<li><a href="../309324/index.html">Anatomy of a web service</a></li>
<li><a href="../309326/index.html">How does MySQL replication work?</a></li>
<li><a href="../309328/index.html">The basics of indexing and EXPLAIN in MySQL</a></li>
<li><a href="../309332/index.html">Principles and techniques for processing queues</a></li>
<li><a href="../309338/index.html">Future is now: what will happen on JavaDay Kharkiv 2016, September 17</a></li>
<li><a href="../309340/index.html">.Net Core, 1C, dynamic compilation, Scripting API</a></li>
<li><a href="../309342/index.html">We invite you on October 19, Moscow to the IX conference "Embedded Technologies 2016. Industrial Internet of Things"</a></li>
<li><a href="../309344/index.html">Contact Service Desk. Where do customers care more: in IT services or repair of air conditioners?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>