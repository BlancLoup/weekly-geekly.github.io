<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Thoughts on the ideal programming language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I would like to share my thoughts on an ideal general purpose programming language. First of all - about the language that could repla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Thoughts on the ideal programming language</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/59e/ec1/0dd/59eec10ddaae4ee6ac2d9a95057dc950.png"><br><br>  In this article I would like to share my thoughts on an ideal general purpose programming language.  First of all - about the language that could replace C ++. <br><br>  It so happens that programming languages ‚Äã‚Äãare my hobby and my main interest in IT.  Probably, any programmer sometimes wants to create his own - perfect - programming language.  For me, this is more than just a dream; in fact, I have long been collecting all the information in various languages ‚Äã‚Äãand designing my own language. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At various resources, I regularly speak on this subject.  In this article, I tried to put the main ideas together.  We will look at the main drawbacks of C ++, the features of other languages ‚Äã‚Äãthat can be compared with C ++ one way or another, and - most interestingly - the needs of programmers for language features, using the example of the Boost library. <br><br>  This article does not claim to be of any technical utility (although if it is useful to someone, that‚Äôs great).  This article is an invitation to a discussion. <br><a name="habracut"></a><br>  C ++ is far from perfect.  I think any C ++ programmer will agree with me. <br><br>  The disadvantages of C ++ are, first of all, the heavy legacy of C: the terrible system of inclusions and the complete absence of modularity.  The inclusion of the header file essentially leads to the inclusion of the entire contents of the file in the compilation unit;  since the header files include each other, and modern libraries can contain tens of thousands of header files ... of course, this cannot but affect the compilation time.  Sometimes various ‚Äúprecompiled headers‚Äù (pch) solutions help, but, as practice shows, these solutions are also far from ideal.  For example, Visual C ++ does not allow creating common pch for several projects of the same solution (despite the fact that in precompiled headers, as a rule, they include really common and immutable headers - such as stl, boost, etc.). <br><br>  And of course, the internal perfectionism peculiar to any programmer strongly protests against such an implementation - essentially a crutch, supports for the originally incorrect architecture. <br><br><pre><code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br>  Of course, the ‚Äúlexical‚Äù preprocessor, another hello from Xi, is a heavy and tightly inherited unix-way legacy (yes, once it really was a separate program, and yes, there are alternative preprocessors, for example <a href="http://www.gnu.org/software/m4/manual/index.html">m4</a> ... but now the preprocessor is definitely perceived as part of language).  But it is absolutely obvious that a certain set of possibilities is needed that solves the tasks of the preprocessor (or rather the system of syntax macros), and this should not be a non-standard third-party program that is not related to the language. <br><br>  And from the relatively new - the turing-completeness of the templates, which gave rise to hellish metaprogramming constructs on these very templates.  Initially it was assumed, of course, that the template functions and classes will be used exclusively for writing universal algorithms and data structures that do not depend on the type of data being processed / stored.  Great application!  But. <br><br>  The absence of built-in syntax macros and the eternal feeling of hunger for features forced programmers to create full metalanguages ‚Äã‚Äãon templates, with metatypes, meta-algorithms, and calculations performed by the compiler during compilation ... What's wrong with that?  Nothing but the fact that these are essentially crutches. <br><br>  But it is just unpleasant when, for example, the keywords (struct) are used not at all for what they are intended for.  And, of course, inadequate error messages, often due to a random typo and occupying dozens (if not hundreds) of lines per error ... this is truly awful. <br><br>  Of course, in C ++ there are plenty of other shortcomings - small things.  Anyway, many of them are taken into account in the next generation of application programming languages ‚Äã‚Äã- Java and C #.  By the way, for my taste, C # is developing most dynamically and organically absorbs features from many other languages;  This is an excellent example of a beautiful and balanced language (and, therefore, an excellent example that you can look at when designing new languages).  But neither Java, nor C # all the same are not system programming languages. <br><br>  It is necessary to note one more group of new (with respect to C ++) languages, to which I would refer D, Go, Rust, Swift, Nim, and at the same time relatively old Objective C (for its very interesting feature - runtime). <br><br>  What is interesting about these languages? <br><br>  Let's start with D. The language was developed as ‚Äúimproved C ++‚Äù, and indeed - many concepts are made more competently.  Contract programming was carefully implemented, there is an FP, there is some implementation of metaprogramming (but you can do better!).  A language is compiled into a native code, which means it can claim to be ‚Äúsystematic‚Äù.  But I would not single out in D one particular feature that overshadows everything.  However, it seems that the language has taken the C ++ path in terms of accumulating ‚Äúhacks‚Äù, this is especially noticeable when studying the compiler code (which I occasionally do). <br><br>  Go.  Among the nice things - structural typing of interfaces.  The opportunity is extremely interesting, just want to use ... <br><br>  Another worth mentioning is embedding instead of inheritance.  When you look at it, you think - but this must still be in C!  It is so easy to implement - and, nevertheless, how elegant this solution looks.  The built-in support for multithreading is also good. <br><br>  Rust  The main feature is a terrific system of smart pointers and checks during compilation.  Yes, it is worth taking in an ideal language ... although many complain that the system is over complicated.  In fact, there is nothing superfluous in it, although I would not give up classical pointers (in Rust, by the way, they are not abandoned, they are simply wrapped in unsafe).  Is it possible to combine this?  Can.  There is nothing terrible in possibilities, their absence is terrible. <br><br>  And I would also like to mention Objective C. The language is quite old, but people unfamiliar with the OSX world will find a lot of interesting things in it.  This is a special implementation of OOP, in particular, sending messages instead of direct calling methods, a system of selectors and metaclasses.  Coming to the language from Smalltalk, these features allow you to do many amazing things in a compiled language, which can only be achieved in interpreted scripts - in particular, adding methods to classes right during program execution!  In my opinion, a great opportunity. <br><br>  The next interesting question is the relationship between the features of the language and what can be brought to the libraries.  It so happened that for a long time it was C ++ that was the most powerful programming language for universal use (and even now it probably remains, despite all the flaws).  There were no alternatives, but C ++ itself developed for a long time rather slowly, but programmers always want more!  One way or another, various libraries began to appear and develop.  Despite the fact that the standard library already existed, many other libraries and frameworks often duplicated its functionality with their classes.  A prime example is strings.  It would seem that in C ++ there is a standard string (std :: string), but no - almost every more or less large library has its own implementation of strings.  CString (MFC / ATL), QString (Qt), TString (VCL), wxString (wxWidgets). <br><br>  The same fate befell various containers (dynamic arrays and lists), the base classes for different hierarchies (object - the truth must be admitted that there is nothing like this in the standard library).  I'm not talking about the redefinition of simple types, found in almost every small program (not even the library).  Remember all sorts of UINT, uint, u32, DWORD, uint32_t ... But the most interesting object for studying the design of a language is perhaps the Boost library (both <a href="http://www.boost.org/">its official part</a> and the <a href="https://svn.boost.org/trac/boost/wiki/LibrariesUnderConstruction">libraries in the Under Constuction status</a> , found in <a href="http://rrsd.com/blincubator.com/alphabetically">Boost Incubator</a> and other unofficial extensions).  To her, we will return. <br><br>  Now we can say that C ++ looks like this: a small language core, a small standard library, and many third-party libraries that intersect with each other and partially with the standard library and capture various areas of responsibility - from emulating language features to applied tasks.  Many libraries rely only on the kernel.  Like that: <br><br><img src="https://habrastorage.org/files/b2c/c12/b6f/b2cc12b6f8e14aa887c3b319264ccfb1.PNG"><br><br>  The small language core does not support many language features and provokes programmers to write "emulation of language capabilities."  Since there are many programmers, there are many corresponding emulations;  they are generally incompatible with each other;  cumbersome (since they are built on non-standard and / or non-obvious use of existing language capabilities);  difficult to compile and debug, and indeed in understanding.  On the other hand, a small kernel allows the language to contain nothing superfluous and that is good (moreover, it is necessary for system programming).  Contradiction?  In fact, a solvable contradiction.  Here is my ideal language organization chart: <br><br><img src="https://habrastorage.org/files/8a1/3eb/b97/8a13ebb978604a969007f387803533e2.png"><br><br>  In the center - the basic language core.  ‚ÄúLanguage extensions‚Äù around it, language extensions are some parts of the language that are supported syntactically, but which can be turned on and off when building a project, as well as replaced with their own implementations;  next is the standard library that supports everything related to general-purpose programming;  and around - application libraries that do not try to emulate kernel functions, but solve purely applied tasks.  Application libraries must implement <b>specific</b> things.  This is essential - the difference between the general and the specific.  Work with graphics, with a network, with iron;  specific mathematics, cryptography, applied libraries for some specific areas;  working with different file formats, with databases, with various services ... all these are specific, applied areas, and they certainly should be implemented as libraries.  But reflection or multithreading, higher-order functions or coroutines are fundamental things in terms of language, and they must be supported in the language (some with the possibility of replacing the default implementation with something else). <br><br>  Let's go back to the Boost library.  Let's talk about Buste as the clearest example of the fact that languages ‚Äã‚Äãare developing much more slowly than programmers want.  A good half of the Bust libraries are essentially an emulation of language features.  Perhaps someday I will write separate articles about the Bust library ... here is just a brief overview of what is there - in the context of including these features directly into the programming language.  Bust has his own library classification, with which I do not fully agree (although I have different goals for classification).  Some libraries certainly belong to the ‚Äústandard library‚Äù group;  part - generally applied libraries;  but a significant part is exactly what is missing in the language itself, in the core!  I will not give here either my division, or the description of libraries (this is the topic of a separate article, or even several).  Instead, I will simply give a list (incomplete!) Of those libraries of the Bust libraries, which I would refer to the language core: <br><br><ul><li>  integer - meta information and traits for integer types </li><li>  multiprecision - wrapper for libraries of work with arbitrary precision numbers GMP, MPIR, MPFR </li><li>  any - universal dynamic type </li><li>  optional - an optional type, maybe;  in theory should be built into the language and integrated with nullable </li><li>  variant - algebraic data type (sum-type, tagged union) </li><li>  preprocessor - metaprogramming on the preprocessor </li><li>  inentity_type - a helper for generating unique type names </li><li>  assign - multi-operations associated with filling containers </li><li>  mpl - type containers and operations on them </li><li>  fusion - containers of types and values ‚Äã‚Äãand operations on them </li><li>  tuple tuples </li><li>  bind - functional objects created using partial application of functions </li><li>  function - functional objects </li><li>  lambda - lambda functions;  by the way, something superior lambda from c ++ 11; </li><li>  local_function - emulation of nested functions </li><li>  signals2 - signals and slots </li><li>  context - saving and restoring the state of the thread (stack and registers) </li><li>  coroutine - coroutine implementation </li><li>  foreach - cycle through collections </li><li>  parameter - emulation of named functions arguments </li><li>  scope_exit is a language construct, in the D language this is called scope (exit), scope (success), scope (failure), in Go - defer </li><li>  type_erasure is an alternative implementation of polymorphism runtime </li><li>  predef - meta information about the OS, compiler, platform ..., </li><li>  typeof - emulation of the typeof / decltype operator </li><li>  endian - work with numbers with different byte order </li></ul><br><br>  Let me remind you that this is not a complete list (and I don‚Äôt even consider the library of Boost extensions here, and there are also a lot of interesting things - for example Contract, Hana, Introspection, Mirror, Reflection ...).  I note that not all libraries should be included in the language core: in general, it is enough to include only some small (and in fact common to many libraries) part of the kernel, and it may turn out that many libraries from this list will not be needed at all.  Also, inclusion in the language core will allow you to avoid the many restrictions imposed on existing artificial implementations of various features.  Such excellent features as algebraic data types, the universal dynamic type any, optional types, named parameters are of course best implemented at the language level. <br><br>  We now turn to the ‚ÄúLanguage Extensions‚Äù.  What is it and why did I introduce it? <br>  In fact, such ‚Äúextensions‚Äù somehow or other exist in C ++, just no one identifies them into a separate group.  An example is the memory allocation system in C ++.  The language core interface is the new and delete operators as such;  their language syntax is clearly spelled out in the language core, and their semantics (allocation and freeing of memory) is written in the documentation.  In this case, the language provides a standard implementation, but if you wish, you can redefine these operators and write your own memory allocation system.  The second example is type identification at runtime, RTTI.  The example demonstrates another aspect - the detachability of extensions. <br><br>  I have a lot of experience with microcontrollers, with a very small amount of onboard memory I had to allocate memory only statically - there was no ‚Äúheap‚Äù, and even more so there was no RTTI. <br><br>  The difference between Core and Extensions is that core elements cannot be redefined;  so, the conditional if statement is unambiguous, its logic is embedded in the kernel and there is no way to replace its implementation with something else.  Extensions are <b>spelled out at the syntax level in the kernel</b> <b>, and some default implementation is provided in the language</b> that will suit 95% of programmers;  the remaining 5% are invited to write their own implementation, however corresponding to the language interfaces, or disable it altogether - for specific cases. <br><br>  Other such extensions could be <br><ul><li>  garbage collection (see Rust - Gc) </li><li>  memory management using reference counting (see Rust - Rc, Arc) </li><li>  long arithmetic (important here is that arithmetic should be integrated into the language, including at the literal level; and long constants like 128-bit numbers should be written in a natural way - in the form of numeric literals, the same for all implementations!) </li><li>  multithreading (go operator in go language) </li><li>  reflection (yes, there are a lot of ways to implement it manually - but no one can cope with this task anyway) </li><li>  virtuality and multimethods </li><li>  signals and slots </li><li>  objc style speaker </li><li>  embedded scripts </li><li>  rtti </li><li>  exception handling (there are different ways to implement it; there are cases when it is not needed at all) </li><li>  floating point (yes, some microcontrollers do not have FPU and the library emulates floating-point operation) </li></ul><br>  and probably much more that I did not remember right away. <br><br>  In the end, I want to dwell on one philosophical principle that underlies my idea of ‚Äã‚Äãan ideal programming language.  Usually during the discussion on the forums, when you start saying that there is no feature Y in language X, there will definitely be someone who will say: well, then, if you take features A, B and C, and fasten the crutches D, E and F, then we get almost Y. Yes, it is.  But I do not like this approach.  You can imagine that such programmers will arrange some difficult way through the maze.  It is possible to go through the maze, but the path is not obvious.  I would like to see, instead of a labyrinth, there was a spacious area where you could walk from any point to any other one in a straight line.  Just in a straight line. </div><p>Source: <a href="https://habr.com/ru/post/257875/">https://habr.com/ru/post/257875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257863/index.html">How I set up IPv6 6to4 on Keenetic</a></li>
<li><a href="../257865/index.html">Z-monitor: monitoring and control of government orders</a></li>
<li><a href="../257867/index.html">DIY Robot Vacuum Cleaner</a></li>
<li><a href="../257869/index.html">MyBatis and OSGi</a></li>
<li><a href="../257871/index.html">MBLT15: A week before the international mobile conference</a></li>
<li><a href="../257877/index.html">Typical errors and not very</a></li>
<li><a href="../257879/index.html">How ‚ÄúRussian hackers‚Äù tried to learn about new sanctions against Russia: we study CVE-2015-1701</a></li>
<li><a href="../257881/index.html">Analysis of accounts of one (not) reliable email-service</a></li>
<li><a href="../257883/index.html">Comparative analysis of HL7 and openEHR</a></li>
<li><a href="../257885/index.html">Courses on ethical hacking and penetration testing: updated program</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>