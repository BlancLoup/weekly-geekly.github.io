<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GUID-like primary keys in SQLite on Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intro 


 Each table in SQLite by default contains a private key based on an automatically generated 64-bit integer. It is effective and convenient in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GUID-like primary keys in SQLite on Android</h1><div class="post__text post__text-html js-mediator-article"><h2 id="intro">  Intro </h2><br><p>  Each table in SQLite by default contains a private key based on an automatically generated 64-bit integer.  It is effective and convenient in most situations.  The inconvenience begins, perhaps, only in two cases: </p><br><ul><li>  when the range of 64 bits is not enough (then you should think about the appropriateness of the SQLite task) </li><li>  when the storage becomes "distributed" </li></ul><br><p>  It may seem that the second task in combination with SQLite should not arise, but distribution does not always mean something like BigData.  A typical example (which is why I personally needed a study on this topic) is an application with the ability to synchronize data between devices.  It can be as small as a notebook, or more loaded, like browser history.  The problem here is not so much the amount of data as the merging of several databases.  Obviously, integer record counters, starting from 1, will inevitably produce conflicting sequences, and therefore it is no longer possible to use them as a unique record identifier on several devices.  It is possible to be confused with division into subranges or "shifting" aydishnikov records before transferring them, but these are all curves and fragile crutches.  Nobody does that, of course.  Instead, each device assigns something like a GUID to its entries ‚Äî simply and securely. </p><a name="habracut"></a><br><h2 id="guid-v-kachestve-pervichnogo-klyucha">  GUID as a primary key </h2><br><p>  A GUID is a random "number", 128 bits long.  That is, in the database it will be 16 bytes in the form of a BLOB, or at least 32 bytes in the form of a string.  A certain overhead projector (especially if the remaining columns are small) compared to the default key, which is stored very efficiently: usually there is not 8 bytes, but as much as the value of the key requires to be represented.  We are ready to pay this overhead for the sake of solving the problem, but we don‚Äôt want to exacerbate it - therefore, of course, we prefer binary storage rather than textual strings. </p><br><p>  Well, it's easy to declare a blob column, let's make a primitive label: </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">records</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span>);</code> </pre> <br><p>  You can also add a <code>WITHOUT ROWID</code> as a table specifier for optimization ‚Äî so that SQLite does not add or support an implicit key column. </p><br><p>  The topic could be closed if it were not for the desire to force the database to generate IDs on its own, just as in the case of the default integer key.  Well, if there is no fundamental requirement to have <em>real</em> GUIDs (which are not just a random number, but have several predefined bits), then this is also easy: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">records</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> (randomblob(<span class="hljs-number"><span class="hljs-number">16</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span>);</code> </pre> <br><p>  It would be possible to stop at this again, if not for perfectionism.  Looking ahead, I will say that even with perfectionism of a severe form, it is worth staying at this if you are not going to insert millions of records into the database.  But if it can be that you are going, then you should pay attention that a long random number is not very well suited as a key for the reason that it is more expensive to index: just add the records one by one and hope for a quick search will not work. </p><br><p>  This problem is fortunately <a href="http://www.informit.com/articles/article.aspx%3Fp%3D25862">solved long ago and successfully,</a> and the solution has been adapted <a href="https://www.codeproject.com/Articles/388157/GUIDs-as-fast-primary-keys-under-multiple-database">to many databases</a> .  In short, everything is simple there: the first 6 bytes of the identifier are replaced by the timestamp.  As a result, records are created immediately (partially) ordered, which greatly facilitates their indexing.  The probability of collisions at the same time increases, but only slightly.  And again, the story would have ended exactly at this place, if in the Android API <a href="https://developer.android.com/reference/android/database/SQLite/SQLiteDatabase.html">SQLiteDatabase would</a> allow defining external functions to generate a guid-like BLOB.  You can of course generate them in Java code and bind to all insert requests, but this is unsportsmanlike.  In addition, there may be other reasons for not doing this.  For example, the need to keep "global" identifiers separate from "local" ones, generating them as necessary using a trigger. </p><br><p>  Well, take 6 bytes from the unix timestamp with a sin in half, <a href="http://www.sqlite.org/lang_datefunc.html">you can</a> : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>((julianday(<span class="hljs-string"><span class="hljs-string">'now'</span></span>) - <span class="hljs-number"><span class="hljs-number">2440587.5</span></span>) * <span class="hljs-number"><span class="hljs-number">86400000</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ts;</code> </pre> <br><p>  The result will be a number.  For example, this: 1489877740453 - at the time of this writing.  The good news is that it will usually be non-decreasing, and it can be considered the means of the database itself.  But then some difficulties begin.  The fact is that SQLite has a very limited set of functions for working with BLOBs: just trim ( <code>substr()</code> ) and glue ( <code>||</code> ).  And how to make the number interpret as a string of bytes is not clear.  That is, you can of course make <code>CAST(... AS BLOB)</code> , but this is not it: <a href="http://www.sqlite.org/lang_expr.html">it will translate the number into a string</a> , and then take the bytes of the received string ‚Äî that is, turn 6 bytes into 13. Even if you <a href="http://www.sqlite.org/lang_corefunc.html">preformat it in hexadecimal</a> , there will be a lot - 12. Does not roll. </p><br><h2 id="preobrazovanie-chisla-v-blob">  Convert number to blob </h2><br><p>  ... in SQLite is impossible - google and stackoverflow will answer you.  That's the way it is, of course, true, but if you really want it, then you can actually.  I couldn't find anything on the Internet, and I had to invent it myself.  I must say: it will be dirty :) </p><br><p>  So, we have a gluing ( <code>||</code> ), so having two byte strings ‚Äî the timestamp and the random part ‚Äî we could get Jimmy Nelson's COMB: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ts_bytes || randomblob(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  The <code>ts_bytes</code> required is just a string of 6 bytes representing an integer.  Let's take a look at it <code>1489877740453</code> : <code>1489877740453</code> .  Or <code>0x 01 5A E3 A2 2B A5</code> .  If we could take individually each byte in the form of BLOBs, and glue them together - even in manual mode, this is all (and always) 6 glues.  Well, let's try to divide the number into bytes.  Their numerical values ‚Äã‚Äãcan be obtained with the help of small arithmetic: </p><br><ul><li>  first: <code>ts &gt;&gt; 40 == 1</code> (0x01) </li><li>  second: <code>(ts &gt;&gt; 32) % 256 == 90</code> (0x5A) </li><li>  third: <code>(ts &gt;&gt; 24) % 256 == 227</code> (0xE3) </li><li>  ... </li></ul><br><p>  But, again, this is not bytes yet.  SQLite interpreter will consider it just numbers: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> typeof( (<span class="hljs-number"><span class="hljs-number">1489877740453</span></span> &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span> ); integer</code> </pre> <br><p>  And we need a blob.  BLOB of one byte representing the resulting number.  Obviously, we cannot do this, but if we had something like a table - byte values ‚Äã‚Äãare <em>only 256 pieces</em> .  Here we recall the second operation available in SQLite and returning bytes - <code>substr</code> , which by index returns a substring of letters <strong>or bytes</strong> .  Bingo!  Zahardkodim all the values ‚Äã‚Äãof bytes in the string, where the index value of this byte will be.  Fortunately, you can write a binary literal using the syntax of the form x'DEADBEEF ': </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> X<span class="hljs-string"><span class="hljs-string">' 000102030405060708090A0B0C0D0E0F 101112131415161718191A1B1C1D1E1F 202122232425262728292A2B2C2D2E2F 303132333435363738393A3B3C3D3E3F 404142434445464748494A4B4C4D4E4F 505152535455565758595A5B5C5D5E5F 606162636465666768696A6B6C6D6E6F 707172737475767778797A7B7C7D7E7F 808182838485868788898A8B8C8D8E8F 909192939495969798999A9B9C9D9E9F A0A1A2A3A4A5A6A7A8A9AAABACADAEAF B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> b;</code> </pre> <br><p>  This is slightly pseudo-code, because it is impossible to wrap the lines this way, but it is more obvious, and in the code it is possible to format it in one line.  But now all that is left to do is to "cut" the desired byte from the table and glue it with the others.  Six times: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, (ts &gt;&gt; <span class="hljs-number"><span class="hljs-number">40</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, (ts &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, (ts &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, (ts &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, (ts &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, ts % <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || randomblob(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p>  Pseudo-GUID in binary form is ready!  In fact, SQLite will still treat the received byte string as "text", but <code>CAST(... AS BLOB)</code> will do everything as it should.  In fact, this is even mandatory, because otherwise reading from this column will not return 16 bytes, as expected, but 17 - with a zero terminator string.  It remains to substitute the expression as the value of the default column. </p><br><h2 id="avtovstavka-identifikatorov">  Autotap identifiers </h2><br><p>  Simply stuffing this whole train into <code>DEFAULT(...)</code> in the table column definition is impossible, because there must be only "simple" expressions, but we need nested SELECTs to avoid copy-paste and multiple calculations of the same. </p><br><p>  Fortunately, SQLite has triggers with which you can modify strings on the fly when inserting.  Unfortunately, neither the <code>BEFORE INSERT</code> phase nor the <code>AFTER INSERT</code> phase is suitable for <code>PRIMARY KEY</code> , since  to satisfy the implicit <code>NOT NULL</code> condition, the column value must be specified in the original query.  In addition, for such triggers, the UPDATE expression again allows only primitive expressions.  But the <code>INSTEAD OF INSERT</code> trigger type is available, which can just create a new record based on the passed values ‚Äã‚Äãwith the addition of the generated blob.  There is only one feature with it that is not indicated in the documentation: INSTEAD OF INSERT trigger cannot be created on a table.  It is possible only on VIEW. </p><br><p>  As a result, the scheme is built as follows: </p><br><ul><li>  the main table is clearly read only </li><li>  write requests go to VIEW dummy with insert trigger </li><li>  trigger generates a blob and inserts into the main table </li></ul><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">records</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHARACTER</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITHOUT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWID</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> fake <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ts, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> auto_guids INSTEAD <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> fake <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">records</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(new_guid <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BLOB</span></span>), NEW.data <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, (ts &gt;&gt; <span class="hljs-number"><span class="hljs-number">40</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, (ts &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, (ts &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, (ts &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, (ts &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) % <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || <span class="hljs-keyword"><span class="hljs-keyword">substr</span></span>(b, ts % <span class="hljs-number"><span class="hljs-number">256</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) || randomblob(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> new_guid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>((julianday(<span class="hljs-string"><span class="hljs-string">'now'</span></span>) - <span class="hljs-number"><span class="hljs-number">2440587.5</span></span>) * <span class="hljs-number"><span class="hljs-number">86400000</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFFFFFFFF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ts, x<span class="hljs-string"><span class="hljs-string">'000102030405060708090A0B0C0D0E0F...'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> b ) ); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>;</code> </pre> <br><p>  We read as usual: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">records</span></span>;</code> </pre> <br><p>  And we write it this way: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> fake (<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Hello COMBs!'</span></span>);</code> </pre> <br><p>  It was possible to put the byte table in a separate VIEW for readability, but this somewhat affects the performance.  It was also possible to leave the primary key on the integer counter, make the <code>guid</code> column simply unique and write the <code>ON AFTER INSERT</code> trigger that would "add" the row with the new <code>guid</code> , but, running a little ahead, I would say that it is about 30% slower.  By the way, it's time to look at the performance. </p><br><h2 id="proizvoditelnost">  Performance </h2><br><p>  Obviously, manually gluing the bytes is slower than the built-in function <code>randomblob()</code> .  Winning should appear on a large number of inserts.  We will take measurements.  We will compare the ‚Äúregular‚Äù integer ROWID, the key based on <code>randomblob(16)</code> and our partially ordered blobs (COMBs, as they were called in the above article). </p><br><p>  The test script is: </p><br><ul><li>  three insert transactions with a million entries </li><li>  random selection of all inserted records by id </li></ul><br><p>  The recording time is measured both for each series, and inside every 20% of the records.  Tests were run in the Android 6.0 emulator (SQLite 3.8.10).  <a href="https://bitbucket.org/knuckles/sqlite-combs-test">Sources here</a> . </p><br><p><img src="https://bytebucket.org/knuckles/sqlite-combs-test/raw/bb6a213430c2f6c51695457369675cd42eb10c92/3mrecs.png?token=8d8cbb83a8bd64619a1706ea6461fd6c5142415a" alt="image"><br>  On the chart: the time of insertion of each subsequent portion of 200 thousand records.  Performance standard, of course, the default integer index (blue line).  Its speed does not depend on the number of consecutive inserts.  The yellow line (COMBs) is our patient.  Its speed is also almost constant, although it is 55-59% lower.  And the red line is the table with the primary key on randomblob (16).  It can be seen that starting just 11% slower than INTEGER PRIMARY KEY, somewhere after the first million inserts, its overhead for maintaining the index exceeds the partially ordered sequences and continues to grow, reaching 75% deceleration by the end of the 3rd million. </p><br><p>  In fact, COMB can be made even faster.  The current problem is that with millisecond accuracy of time stamps, adjacent lines are arranged in clusters of 18-20 pieces, where the first 6 bytes (timestamps) are the same, partially returning the problem of arranging random bytes.  If you somehow add the sequence number of the added record to the timestamp (at least within the transaction), it will reduce the overhead to 29-34% compared to "INT" and give a gain compared to <code>randomblob(16)</code> after 500 thousand entries. </p><br><p><img src="https://bytebucket.org/knuckles/sqlite-combs-test/raw/bb6a213430c2f6c51695457369675cd42eb10c92/1.5mrecs.png?token=cdea01c69eea807a2938f19246e151f872501fa6" alt="image"><br>  The disadvantage is that in the simplest case, the sequence number must be transferred from the control code, and I do not want to do this according to the conditions of the problem.  In addition, it is already possible to draw conclusions. </p><br><h2 id="vyvody">  findings </h2><br><p>  SQLite itself is very well managed with indexing even something GUID-o-like. </p><br><p>  If the estimated amount of data does not exceed at least 500 thousand records, pure <code>randomblob()</code> has quite acceptable performance.  I‚Äôll probably choose it in my current project. </p><br><p>  Even if there are many records, but they are rarely inserted, or, especially, in the form of single records, the primary key type will not play any role at all in performance.  Only one transaction commit (in Android with default database settings) takes about 20-50 milliseconds.  And many times more if the IO system is loaded.  Inserting an entry within a mass transaction that occurs in microseconds, in comparison with this, takes negligible time in any case. </p><br><p>  In SQLite, you can turn numbers into BLOBs - there would be a desire :) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323794/">https://habr.com/ru/post/323794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323784/index.html">Magento U has published a free course Fundamentals of Magento 2 Development</a></li>
<li><a href="../323786/index.html">Excursion to the Moscow production of components for communication networks. Part one</a></li>
<li><a href="../323788/index.html">INS-based interlocutor: recurrent networks</a></li>
<li><a href="../323790/index.html">Asynchronous vs delayed javascript</a></li>
<li><a href="../323792/index.html">Why play getKanban: experience Tutu.ru</a></li>
<li><a href="../323796/index.html">Overview of data bootcamps abroad</a></li>
<li><a href="../323798/index.html">HR-technologies in Russia: expectation and reality</a></li>
<li><a href="../323802/index.html">How to talk about your side projects</a></li>
<li><a href="../323804/index.html">CVs that sell us</a></li>
<li><a href="../323806/index.html">Let's deal with the BitCoin exchange</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>