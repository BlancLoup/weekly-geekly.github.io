<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Toy Front End for LLVM written in Rust: Beginner's Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's Note  The code given in the article was compiled with fairly old versions of peg and peg_syntax_ext crate. For current versions of the so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Toy Front End for LLVM written in Rust: Beginner's Guide</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">Translator's Note</b> <div class="spoiler_text">  <i>The code given in the article was compiled with fairly old versions of peg and peg_syntax_ext crate.</i>  <i>For current versions of the source you need to make minimal changes.</i>  <i>I inserted the changed sites in the spoilers on the text of the article.</i>  <i>To build the code, install the nightly Rust compiler.</i> <i><br></i>  <i>The full source code with my edits can be downloaded here: <a href="https://github.com/arktur04/rust-llvm-toy-frontend">https://github.com/arktur04/rust-llvm-toy-frontend</a></i> <i><br></i> <br></div></div><br>  I am currently working on a compiler that is written in Rust, and spawns LLVM IR.  The LLVM API looks a bit scary for newbies, and there are not so many guides on it (and they are all in C ++, so it‚Äôs not quite clear how to do the same in Rust).  I would like someone to give me a helping hand when I started all this, and this article is what I would like to show myself at that time. <br><br><img src="https://habrastorage.org/web/91b/abc/cfb/91babccfb6604110bad66cfc1d5819ed.jpg"><br><br>  In Rust, the best way to interact with LLVM is through llvm-sys crate.  One kind person posted documentation to him <a href="http://rustdoc.taricorp.net/llvm-sys/llvm_sys/">here</a> .  Of course, you should also read <a href="https://habrahabr.ru/post/119850/">the</a> LLVM <a href="https://habrahabr.ru/post/119850/">guide</a> , as it will help you understand how LLVM ‚Äúthinks‚Äù.  This post is basically a translation of the subsets from this guide to Rust. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The full source code for this tutorial is <a href="https://github.com/ucarion/llvm-rust-getting-started">here</a> . <br><a name="habracut"></a><br><h3>  Get the development environment </h3><br>  For starters, here is a way to start working with LLVM: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># `curl` is just so we can next install Rust sudo apt-get -y install clang curl llvm-3.8-dev curl https://sh.rustup.rs -sSf | sh # The `llvm-sys` crate expects something called `llvm-config` on your PATH. sudo ln -s /usr/bin/llvm-config-3.8 /usr/bin/llvm-config</span></span></code> </pre> <br>  If you are working on a fresh Ubuntu (you may need <i>apt-get update</i> ), then everything is ready, you can start.  If not, you can run in the Vagrant virtual machine, via <i>Vagrantfile</i> : <br><br><pre> <code class="bash hljs">Vagrant.configure(<span class="hljs-string"><span class="hljs-string">"2"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> |config| config.vm.box = <span class="hljs-string"><span class="hljs-string">"bento/ubuntu-16.04"</span></span> end</code> </pre> <br>  You can proceed by running <i>cargo init llvm-example --bin</i> and placing the following (taken from llvm-sys) in <i>src / main.rs</i> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//! Construct a function that does nothing in LLVM IR. extern crate llvm_sys as llvm; use std::ptr; fn main() { unsafe { // Set up a context, module and builder in that context. let context = llvm::core::LLVMContextCreate(); let module = llvm::core::LLVMModuleCreateWithName(b"nop\0".as_ptr() as *const _); let builder = llvm::core::LLVMCreateBuilderInContext(context); // Get the type signature for void nop(void); // Then create it in our module. let void = llvm::core::LLVMVoidTypeInContext(context); let function_type = llvm::core::LLVMFunctionType(void, ptr::null_mut(), 0, 0); let function = llvm::core::LLVMAddFunction(module, b"nop\0".as_ptr() as *const _, function_type); // Create a basic block in the function and set our builder to generate // code in it. let bb = llvm::core::LLVMAppendBasicBlockInContext(context, function, b"entry\0".as_ptr() as *const _); llvm::core::LLVMPositionBuilderAtEnd(builder, bb); // Emit a `ret void` into the function llvm::core::LLVMBuildRetVoid(builder); // Dump the module as IR to stdout. llvm::core::LLVMDumpModule(module); // Clean up. Values created in the context mostly get cleaned up there. llvm::core::LLVMDisposeBuilder(builder); llvm::core::LLVMDisposeModule(module); llvm::core::LLVMContextDispose(context); } }</span></span></code> </pre> <br>  And in your <i>Cargo.toml</i> : <br><br><pre> <code class="cpp hljs">[package] name = <span class="hljs-string"><span class="hljs-string">"llvm-example"</span></span> version = <span class="hljs-string"><span class="hljs-string">"0.1.0"</span></span> authors = [<span class="hljs-string"><span class="hljs-string">"Ulysse Carion &lt;ulysse@ulysse.io&gt;"</span></span>] [[bin]] name = <span class="hljs-string"><span class="hljs-string">"main"</span></span> [dependencies] llvm-sys = <span class="hljs-string"><span class="hljs-string">"0.2"</span></span></code> </pre> <br>  You should get the following: <br><br><pre> <code class="cpp hljs">vagrant@vagrant:/vagrant$ cargo run Compiling llvm-example v0<span class="hljs-number"><span class="hljs-number">.1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> (file:<span class="hljs-comment"><span class="hljs-comment">///vagrant) Running `target/debug/main` ; ModuleID = 'nop' define void @nop() { entry: ret void }</span></span></code> </pre> <br>  Hooray!  We can start writing our own program. <br><br><h3>  A bit less trivial program. </h3><br>  To begin with, let's compile a program that simply returns the termination code by returning the integer from the <i>main</i> function. <br><br>  Here's how I did it: (We will need a parser soon, and I added it now; I used a <i>peg</i> crate): <br><br><div class="spoiler">  <b class="spoiler_title">Note</b>  <b class="spoiler_title">trans.</b> <div class="spoiler_text">  <i>Text Cargo.toml:</i> <br><br><pre> <code class="rust hljs">[package] name = <span class="hljs-string"><span class="hljs-string">"llvm-example"</span></span> version = <span class="hljs-string"><span class="hljs-string">"0.1.0"</span></span> authors = [<span class="hljs-string"><span class="hljs-string">"Ulysse Carion &lt;ulysse@ulysse.io&gt;"</span></span>] [[bin]] name = <span class="hljs-string"><span class="hljs-string">"main"</span></span> [dependencies] llvm-sys = <span class="hljs-string"><span class="hljs-string">"38"</span></span> peg = <span class="hljs-string"><span class="hljs-string">"0.5.4"</span></span> peg-syntax-ext = <span class="hljs-string"><span class="hljs-string">"0.5.2"</span></span></code> </pre> <br></div></div><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(plugin)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#![plugin(peg_syntax_ext)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> llvm_sys <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> llvm; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ffi::CString; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::io::Read; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ptr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> f = File::open(<span class="hljs-string"><span class="hljs-string">"in.ex"</span></span>).unwrap(); f.read_to_string(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> input).unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parsed_input = parser::program(&amp;input).unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { codegen(parsed_input); } } peg! parser(<span class="hljs-string"><span class="hljs-string">r#" #[pub] program -&gt; String = i:int_literal "\n" { i } int_literal -&gt; String = [0-9]+ { match_str.to_owned() } "#</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">codegen</span></span></span></span>(input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = llvm::core::LLVMContextCreate(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> module = llvm::core::LLVMModuleCreateWithName(<span class="hljs-string"><span class="hljs-string">b"example_module\0"</span></span>.as_ptr() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> builder = llvm::core::LLVMCreateBuilderInContext(context); <span class="hljs-comment"><span class="hljs-comment">// In LLVM, you get your types from functions. let int_type = llvm::core::LLVMInt64TypeInContext(context); let function_type = llvm::core::LLVMFunctionType(int_type, ptr::null_mut(), 0, 0); let function = llvm::core::LLVMAddFunction(module, b"main\0".as_ptr() as *const _, function_type); let entry_name = CString::new("entry").unwrap(); let bb = llvm::core::LLVMAppendBasicBlockInContext(context, function, entry_name.as_ptr()); llvm::core::LLVMPositionBuilderAtEnd(builder, bb); // The juicy part: construct a `LLVMValue` from a Rust value: let int_value: u64 = input.parse().unwrap(); let int_value = llvm::core::LLVMConstInt(int_type, int_value, 0); llvm::core::LLVMBuildRet(builder, int_value); // Instead of dumping to stdout, let's write out the IR to `out.ll` let out_file = CString::new("out.ll").unwrap(); llvm::core::LLVMPrintModuleToFile(module, out_file.as_ptr(), ptr::null_mut()); llvm::core::LLVMDisposeBuilder(builder); llvm::core::LLVMDisposeModule(module); llvm::core::LLVMContextDispose(context); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Note</b>  <b class="spoiler_title">trans.</b> <div class="spoiler_text">  <i>Parser changes:</i> <br><br><pre> <code class="rust hljs">peg! parser(<span class="hljs-string"><span class="hljs-string">r#" #[pub] program -&gt; String = i:int_literal "\n" { i } int_literal -&gt; String = n:$([0-9]+) { n.to_owned() } "#</span></span>);</code> </pre> <br></div></div><br>  Works!  Checking: <br><br><pre> <code class="cpp hljs">vagrant@vagrant:/vagrant$ cat in.ex <span class="hljs-number"><span class="hljs-number">42</span></span> vagrant@vagrant:/vagrant$ cargo run Running `target/debug/main` vagrant@vagrant:/vagrant$ lli<span class="hljs-number"><span class="hljs-number">-3.8</span></span> out.ll ; echo $? <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre> <br>  Cool!  This is how <i>out.ll</i> looks <i>like</i> : <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'example_module'</span></span> define i64 @main() { entry: ret i64 <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre> <br><h3>  Arithmetic </h3><br>  Add support for addition, subtraction, multiplication, and division of numbers.  To do this, we need to expand our grammar.  Let's enter the <i>enum</i> that represents AST: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span></span> { Add(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Sub(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Mul(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Div(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Literal(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br>  We also need to expand the grammar: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// `product` and `sum` are that way to get operator precedence peg! parser(r#" use super::Expr; #[pub] program -&gt; Expr = e:expression "\n" { e } expression -&gt; Expr = sum sum -&gt; Expr = a:product _ "+" _ b:sum { Expr::Add(Box::new(a), Box::new(b)) } / a:product _ "-" _ b:sum { Expr::Sub(Box::new(a), Box::new(b)) } / product product -&gt; Expr = a:int_literal _ "*" _ b:product { Expr::Mul(Box::new(a), Box::new(b)) } / a:int_literal _ "/" _ b:product { Expr::Div(Box::new(a), Box::new(b)) } / int_literal int_literal -&gt; Expr = [0-9]+ { Expr::Literal(match_str.to_owned()) } _ = " "* "#);</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Note</b>  <b class="spoiler_title">trans.</b> <div class="spoiler_text">  Parser changes: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// `product` and `sum` are that way to get operator precedence peg! parser(r#" use super::Expr; #[pub] program -&gt; Expr = e:expression "\n" { e } expression -&gt; Expr = sum sum -&gt; Expr = a:product _ "+" _ b:sum { Expr::Add(Box::new(a), Box::new(b)) } / a:product _ "-" _ b:sum { Expr::Sub(Box::new(a), Box::new(b)) } / product product -&gt; Expr = a:int_literal _ "*" _ b:product { Expr::Mul(Box::new(a), Box::new(b)) } / a:int_literal _ "/" _ b:product { Expr::Div(Box::new(a), Box::new(b)) } / int_literal int_literal -&gt; Expr = n:$([0-9]+) { Expr::Literal(n.to_owned()) } _ = " "* "#);</span></span></code> </pre> <br></div></div><br>  Then we generate the code.  You can define strings, such as ‚Äú <i>addtmp</i> ‚Äù, and they will be used as part of the corresponding register name in IR. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// When you write out instructions in LLVM, you get back `LLVMValueRef`s. You // can then use these references in other instructions. unsafe fn codegen_expr(context: LLVMContextRef, builder: LLVMBuilderRef, expr: Expr) -&gt; LLVMValueRef { match expr { Expr::Literal(int_literal) =&gt; { let int_type = llvm::core::LLVMInt64TypeInContext(context); llvm::core::LLVMConstInt(int_type, int_literal.parse().unwrap(), 0) }, Expr::Add(lhs, rhs) =&gt; { let lhs = codegen_expr(context, builder, *lhs); let rhs = codegen_expr(context, builder, *rhs); let name = CString::new("addtmp").unwrap(); llvm::core::LLVMBuildAdd(builder, lhs, rhs, name.as_ptr()) }, Expr::Sub(lhs, rhs) =&gt; { let lhs = codegen_expr(context, builder, *lhs); let rhs = codegen_expr(context, builder, *rhs); let name = CString::new("subtmp").unwrap(); llvm::core::LLVMBuildSub(builder, lhs, rhs, name.as_ptr()) }, Expr::Mul(lhs, rhs) =&gt; { let lhs = codegen_expr(context, builder, *lhs); let rhs = codegen_expr(context, builder, *rhs); let name = CString::new("multmp").unwrap(); llvm::core::LLVMBuildMul(builder, lhs, rhs, name.as_ptr()) }, Expr::Div(lhs, rhs) =&gt; { let lhs = codegen_expr(context, builder, *lhs); let rhs = codegen_expr(context, builder, *rhs); let name = CString::new("divtmp").unwrap(); llvm::core::LLVMBuildUDiv(builder, lhs, rhs, name.as_ptr()) }, } }</span></span></code> </pre> <br>  Now you can execute programs like <i>10 * 4 + 20/2 - 8</i> !  Very cool, I think. <br><br><h3>  Variables </h3><br>  We will follow a simple path and assume that our program does not do various annoying things, such as references to undefined variables.  We simply save the variables to the registers, and save them to the HashMap &lt;String, LLVMValueRef&gt;.  This works because the program has only one execution path. <br>  Extend the language and parser: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span></span> { Literal(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), Ref(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), Assign(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Add(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Sub(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Mul(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Div(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), } peg! parser(<span class="hljs-string"><span class="hljs-string">r#" use super::Expr; #[pub] program -&gt; Vec&lt;Expr&gt; = e:(expression ** "\n") "\n" { e } expression -&gt; Expr = i:identifier _ "=" _ s:sum { Expr::Assign(i, Box::new(s)) } / sum sum -&gt; Expr = a:product _ "+" _ b:sum { Expr::Add(Box::new(a), Box::new(b)) } / a:product _ "-" _ b:sum { Expr::Sub(Box::new(a), Box::new(b)) } / product product -&gt; Expr = a:ref_or_literal _ "*" _ b:product { Expr::Mul(Box::new(a), Box::new(b)) } / a:ref_or_literal _ "/" _ b:product { Expr::Div(Box::new(a), Box::new(b)) } / ref_or_literal ref_or_literal -&gt; Expr = i:identifier { Expr::Ref(i) } / int_literal identifier -&gt; String = [a-zA-Z]+ { match_str.to_owned() } int_literal -&gt; Expr = [0-9]+ { Expr::Literal(match_str.to_owned()) } _ = " "* "#</span></span>);</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Note</b>  <b class="spoiler_title">trans.</b> <div class="spoiler_text">  <i>Parser changes:</i> <br><br><pre> <code class="rust hljs">peg! parser(<span class="hljs-string"><span class="hljs-string">r#" use super::Expr; #[pub] program -&gt; Vec&lt;Expr&gt; = e:(expression ** "\n") "\n" { e } expression -&gt; Expr = i:identifier _ "=" _ s:sum { Expr::Assign(i, Box::new(s)) } / sum sum -&gt; Expr = a:product _ "+" _ b:sum { Expr::Add(Box::new(a), Box::new(b)) } / a:product _ "-" _ b:sum { Expr::Sub(Box::new(a), Box::new(b)) } / product product -&gt; Expr = a:ref_or_literal _ "*" _ b:product { Expr::Mul(Box::new(a), Box::new(b)) } / a:ref_or_literal _ "/" _ b:product { Expr::Div(Box::new(a), Box::new(b)) } / ref_or_literal ref_or_literal -&gt; Expr = i:identifier { Expr::Ref(i) } / int_literal identifier -&gt; String = n:$([a-zA-Z]+) { n.to_owned() } int_literal -&gt; Expr = n:$([0-9]+) { Expr::Literal(n.to_owned()) } _ = " "* "#</span></span>);</code> </pre> <br></div></div><br>  Then we add support for two new expressions: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">codegen_expr</span></span></span></span>(context: LLVMContextRef, builder: LLVMBuilderRef, names: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, LLVMValueRef&gt;, expr: Expr) -&gt; LLVMValueRef { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> expr { <span class="hljs-comment"><span class="hljs-comment">// ... Expr::Ref(name) =&gt; { *names.get(&amp;name).unwrap() }, Expr::Assign(name, expr) =&gt; { let new_value = codegen_expr(context, builder, names, *expr); names.insert(name, new_value); new_value }, } }</span></span></code> </pre> <br>  And change the <i>codegen</i> function a <i>bit</i> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_type = llvm::core::LLVMInt64TypeInContext(context); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zero = llvm::core::LLVMConstInt(int_type, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> names = HashMap::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> return_value = zero; <span class="hljs-comment"><span class="hljs-comment">// return value on empty program for expr in input { return_value = codegen_expr(context, builder, &amp;mut names, expr); } llvm::core::LLVMBuildRet(builder, return_value);</span></span></code> </pre> <br>  Voila!  Checking: <br><br><pre> <code class="cpp hljs">vagrant@vagrant:/vagrant$ cat in.ex a = <span class="hljs-number"><span class="hljs-number">3</span></span> b = <span class="hljs-number"><span class="hljs-number">76</span></span> a + b vagrant@vagrant:/vagrant$ cargo run Running `target/debug/main` vagrant@vagrant:/vagrant$ cat out.ll ; ModuleID = <span class="hljs-string"><span class="hljs-string">'example_module'</span></span> define i64 @main() { entry: ret i64 <span class="hljs-number"><span class="hljs-number">79</span></span> }</code> </pre> <br><h3>  If </h3><br>  With <i>if,</i> things get a bit more complicated.  The easiest way to make it work is to save local variables on the stack, and allow LLVM to optimize.  In LLVM, you create a stack variable with the <i>alloca</i> command, and then read / write with the <i>load</i> / <i>store</i> commands. <br><br>  In order to do this, we again expand the language and grammar by adding new parser rules: <br><br><pre> <code class="rust hljs">expression -&gt; Expr = if_expression / i:identifier _ <span class="hljs-string"><span class="hljs-string">"="</span></span> _ s:expression { Expr::Assign(i, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(s)) } / sum if_expression -&gt; Expr = <span class="hljs-string"><span class="hljs-string">"if"</span></span> _ e:expression _ <span class="hljs-string"><span class="hljs-string">"{\n"</span></span> _ then_body:statements _ <span class="hljs-string"><span class="hljs-string">"}"</span></span> _ <span class="hljs-string"><span class="hljs-string">"else"</span></span> _ <span class="hljs-string"><span class="hljs-string">"{\n"</span></span> _ else_body:statements _ <span class="hljs-string"><span class="hljs-string">"}"</span></span> { Expr::If(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(e), then_body, else_body) }</code> </pre> <br>  And add a new type of AST node: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Expr</span></span></span></span> { Literal(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), Ref(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), Assign(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Add(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Sub(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Mul(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), Div(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;), If(<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Expr&gt;, <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;Expr&gt;), }</code> </pre> <br>  Finally, we generate code for the <i>if</i> expression: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">codegen_expr</span></span></span></span>(context: LLVMContextRef, builder: LLVMBuilderRef, func: LLVMValueRef, names: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> HashMap&lt;<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, LLVMValueRef&gt;, expr: Expr) -&gt; LLVMValueRef { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> expr { <span class="hljs-comment"><span class="hljs-comment">// ... Expr::If(condition, then_body, else_body) =&gt; { let condition_value = codegen_expr(context, builder, func, names, *condition); let int_type = llvm::core::LLVMInt64TypeInContext(context); let zero = llvm::core::LLVMConstInt(int_type, 0, 0); // `is_nonzero` is a 1-bit integer let name = CString::new("is_nonzero").unwrap(); let is_nonzero = llvm::core::LLVMBuildICmp(builder, llvm::LLVMIntPredicate::LLVMIntNE, condition_value, zero, name.as_ptr()); // It's fine to create blocks first, and then fill them in later. let entry_name = CString::new("entry").unwrap(); let then_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr()); let else_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr()); let merge_block = llvm::core::LLVMAppendBasicBlockInContext(context, func, entry_name.as_ptr()); llvm::core::LLVMBuildCondBr(builder, is_nonzero, then_block, else_block); llvm::core::LLVMPositionBuilderAtEnd(builder, then_block); let mut then_return = zero; for expr in then_body { then_return = codegen_expr(context, builder, func, names, expr); } llvm::core::LLVMBuildBr(builder, merge_block); llvm::core::LLVMPositionBuilderAtEnd(builder, else_block); let mut else_return = zero; for expr in else_body { else_return = codegen_expr(context, builder, func, names, expr); } llvm::core::LLVMBuildBr(builder, merge_block); // Position the builder so that it's ready to work on the next // expression. llvm::core::LLVMPositionBuilderAtEnd(builder, merge_block); zero } } }</span></span></code> </pre> <br>  A lot of code, but it does what we expected.  Now we can run this program: <br><br><pre> <code class="cpp hljs">a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a { a = <span class="hljs-number"><span class="hljs-number">42</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { a = <span class="hljs-number"><span class="hljs-number">13</span></span> } a</code> </pre> <br>  which generates such an IR: <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'example_module'</span></span> define i64 @main() { entry: %a = alloca i64 store i64 <span class="hljs-number"><span class="hljs-number">1</span></span>, i64* %a %a1 = load i64, i64* %a %is_nonzero = icmp ne i64 %a1, <span class="hljs-number"><span class="hljs-number">0</span></span> br i1 %is_nonzero, label %entry2, label %entry3 entry2: ; preds = %entry store i64 <span class="hljs-number"><span class="hljs-number">42</span></span>, i64* %a br label %entry4 entry3: ; preds = %entry store i64 <span class="hljs-number"><span class="hljs-number">13</span></span>, i64* %a br label %entry4 entry4: ; preds = %entry3, %entry2 %a5 = load i64, i64* %a ret i64 %a5 }</code> </pre> <br>  However, we have not finished yet.  Now our "expression" <i>if is</i> always zero.  Instead, <i>if</i> should be equal to <i>then_return</i> if the ‚Äú <i>then</i> ‚Äù path is executed, or <i>else_return</i> otherwise. <br><br>  How to make LLVM track which path was taken?  Using the ‚Äú <i>Phi</i> ‚Äù node.  You give the <i>phi</i> instructions a list of pairs (block, value), and then the phi node will return the value corresponding to the block that was executed before it. <br><br>  This concludes with <i>if</i> .  Note that we need to update <i>then_block</i> and <i>else_block</i> .  This is done in order to get the last block in the ‚Äú <i>then</i> ‚Äù / ‚Äù <i>else</i> ‚Äù structure, and earlier <i>then_block</i> was the first block in the ‚Äú <i>then</i> ‚Äù / ‚Äù <i>else</i> ". <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// ... // This is mostly the same code as before, just note the new calls to // `LLVMGetInsertBlock`. llvm::core::LLVMPositionBuilderAtEnd(builder, then_block); let mut then_return = zero; for expr in then_body { then_return = codegen_expr(context, builder, func, names, expr); } llvm::core::LLVMBuildBr(builder, merge_block); let then_block = llvm::core::LLVMGetInsertBlock(builder); llvm::core::LLVMPositionBuilderAtEnd(builder, else_block); let mut else_return = zero; for expr in else_body { else_return = codegen_expr(context, builder, func, names, expr); } llvm::core::LLVMBuildBr(builder, merge_block); let else_block = llvm::core::LLVMGetInsertBlock(builder); // Insert the phi node llvm::core::LLVMPositionBuilderAtEnd(builder, merge_block); let phi_name = CString::new("iftmp").unwrap(); let phi = llvm::core::LLVMBuildPhi(builder, int_type, phi_name.as_ptr()); let mut values = vec![then_return, else_return]; let mut blocks = vec![then_block, else_block]; llvm::core::LLVMAddIncoming(phi, values.as_mut_ptr(), blocks.as_mut_ptr(), 2); phi</span></span></code> </pre> <br>  And here he is, an amazing compiler: <br><br><pre> <code class="cpp hljs">vagrant@vagrant:/vagrant$ cat in.ex a = <span class="hljs-number"><span class="hljs-number">1</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b { <span class="hljs-number"><span class="hljs-number">11</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-number"><span class="hljs-number">40</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b { <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-number"><span class="hljs-number">20</span></span> } } c + <span class="hljs-number"><span class="hljs-number">2</span></span> vagrant@vagrant:/vagrant$ cargo run Running `target/debug/main` vagrant@vagrant:/vagrant$ lli<span class="hljs-number"><span class="hljs-number">-3.8</span></span> out.ll ; echo $? <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre> <br>  Cool!  Here is the code that is generated for this example input program: <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'example_module'</span></span> define i64 @main() { entry: %a = alloca i64 %b = alloca i64 %c = alloca i64 store i64 <span class="hljs-number"><span class="hljs-number">1</span></span>, i64* %a store i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64* %b %a1 = load i64, i64* %a %is_nonzero = icmp ne i64 %a1, <span class="hljs-number"><span class="hljs-number">0</span></span> br i1 %is_nonzero, label %entry2, label %entry3 entry2: ; preds = %entry %b5 = load i64, i64* %b %is_nonzero6 = icmp ne i64 %b5, <span class="hljs-number"><span class="hljs-number">0</span></span> br i1 %is_nonzero6, label %entry7, label %entry8 entry3: ; preds = %entry %b10 = load i64, i64* %b %is_nonzero11 = icmp ne i64 %b10, <span class="hljs-number"><span class="hljs-number">0</span></span> br i1 %is_nonzero11, label %entry12, label %entry13 entry4: ; preds = %entry14, %entry9 %iftmp16 = phi i64 [ %iftmp, %entry9 ], [ %iftmp15, %entry14 ] store i64 %iftmp16, i64* %c %c17 = load i64, i64* %c %addtmp = add i64 %c17, <span class="hljs-number"><span class="hljs-number">2</span></span> ret i64 %addtmp entry7: ; preds = %entry2 br label %entry9 entry8: ; preds = %entry2 br label %entry9 entry9: ; preds = %entry8, %entry7 %iftmp = phi i64 [ <span class="hljs-number"><span class="hljs-number">11</span></span>, %entry7 ], [ <span class="hljs-number"><span class="hljs-number">40</span></span>, %entry8 ] br label %entry4 entry12: ; preds = %entry3 br label %entry14 entry13: ; preds = %entry3 br label %entry14 entry14: ; preds = %entry13, %entry12 %iftmp15 = phi i64 [ <span class="hljs-number"><span class="hljs-number">10</span></span>, %entry12 ], [ <span class="hljs-number"><span class="hljs-number">20</span></span>, %entry13 ] br label %entry4 }</code> </pre> <br>  Note the pattern that the blocks form: with the exception of the entry block, they form groups of three, where the ‚Äúthen‚Äù branch goes first, then the ‚Äúelse‚Äù branch, then the ‚Äúmerge‚Äù block (which can be recognized by the phi instruction).  This is a consequence of the fact that every time we find an ‚Äúif‚Äù expression, we add three new blocks to main.  The triples of blocks are arranged in the order in which the AST tree is traversed. <br><br>  That's all!  I hope that now you have a sufficient basis to act independently. </div><p>Source: <a href="https://habr.com/ru/post/338420/">https://habr.com/ru/post/338420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338410/index.html">IT vs AI: will cars be taken away from their creators?</a></li>
<li><a href="../338412/index.html">RailsClub 2017. Interview with Nikita Sobolev, the organizer of elixir-lang.moscow</a></li>
<li><a href="../338414/index.html">How operators form tariffs in different countries of the world</a></li>
<li><a href="../338416/index.html">10 things that hx writers hate</a></li>
<li><a href="../338418/index.html">Resource management in product development in mechanical engineering</a></li>
<li><a href="../338422/index.html">New FinFisher cyber espionage operation: MitM attacks at the provider level?</a></li>
<li><a href="../338424/index.html">IT work in Barcelona, ‚Äã‚Äãbriefly failed</a></li>
<li><a href="../338426/index.html">Three ideas on how to improve development efficiency: the results of the hackathon for Machine Learning in SberTech</a></li>
<li><a href="../338428/index.html">How we teach AI to help find employees</a></li>
<li><a href="../338430/index.html">REQ Labs 2017. Online conference for business and system analysts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>