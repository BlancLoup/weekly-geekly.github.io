<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why one AJAX is not enough: WAMP protocol</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="AJAX calls have taken web work to a new level. You no longer need to reload the page in response to each user input. Now it is possible to send calls ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why one AJAX is not enough: WAMP protocol</h1><div class="post__text post__text-html js-mediator-article">  AJAX calls have taken web work to a new level.  You no longer need to reload the page in response to each user input.  Now it is possible to send calls to the server and refresh the page based on the responses received.  This speeds up the work of the interactive interface. <br><br>  But what AJAX does not provide is the updates from the server that are necessary for the application to work in real time.  These can be applications in which users simultaneously edit one document, or notifications sent to millions of news readers.  Another template is needed for sending messages, in addition to AJAX requests, which would work at different scales.  For this, the PubSub template (‚Äúpublish and subscribe‚Äù, ‚Äúpublication and subscription‚Äù) is traditionally used. <br><br><h4>  What task solved AJAX </h4><br>  Before AJAX, interactive interactions with the page were heavyweight.  Each of them required reloading the page that was created on the server.  In this model, the main unit of interaction was the page.  It does not matter how much information was sent from the browser to the server - the result was a fully updated page.  It was a waste of both traffic and server resources.  And it was slow and inconvenient for users. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://developer.mozilla.org/en/docs/AJAX">AJAX</a> solved the problem by breaking everything apart: it became possible to send data, get a specific result and update only the part of the page relevant to it.  From the ‚Äúgive me a new page‚Äù call, we moved to specific data requests.  We have the opportunity to make remote procedure calls ( <a href="http://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a> ). <br><a name="habracut"></a><br>  Consider a simple web voting example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d5d/b5a/47d/d5db5a47d9507790691ac43e5bf60d81.png" alt="image"><br><br>  Using AJAX, the processing of clicking on ‚ÄúVote‚Äù is approximately as follows: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, <span class="hljs-string"><span class="hljs-string">'send-vote-data.php'</span></span>); xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      } else{ alert('Error: '+xhr.status); //   } } }</span></span></code> </pre> <br><br>  Then you need to change only one vote count.  From redrawing the page, we moved on to changing a single DOM element. <br><br>  The server has less work and the traffic has decreased.  And most importantly, the interface is updated faster, improving the attractiveness of use. <br><br><h4>  What is missing </h4><br>  In the real world, such an application will receive many votes in parallel.  The number of votes will vary.  Since the only connection between the client and the server will be AJAX requests, the user will see the results only when the application loads.  Then the changes will not be transmitted to the user. <br><br>  AJAX refreshes pages only in response to user actions.  It does not solve the problem of processing updates coming from the server.  It does not offer a way to do what we need: to transfer information from the server to the browser.  This requires a messaging pattern that sends updates to the client without user intervention and without the need for the client to constantly poll the server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30f/542/41d/30f54241da2d11146f639c29aa72ec64.png" alt="image"><br><br><h4>  PubSub: one-to-many updates </h4><br>  The established template for such tasks is the PubSub.  The client declares his interest in a topic (subscribes) to the server.  When a client sends an event to a server (publishes), the server distributes it to all connected clients. <br><br>  One of the advantages is that publishers and subscribers are not connected to the server.  The publisher does not need to know about the current subscribers, and subscribers - about the publishers.  Therefore, PubSub is easy to implement both for those and for others, and it scales well. <br><br>  Pattern implementations are many.  You can use <a href="http://faye.jcoglan.com/">Faye</a> on Node.js or Ruby.  If you do not want to keep your server, you can use web services like <a href="http://pusher.com/">Pusher</a> . <br><br><h4>  Two templates for sending messages, two technologies? </h4><br>  It's pretty easy to find a PubSub technology that is suitable for the needs of a particular application.  But even in such simple applications as voting, it is necessary to implement both RPC and PubSub ‚Äî sending data, requests, and receiving updates.  Using pure PubSub, you have to use two different technologies: AJAX and <br><br>  This approach has disadvantages: <br>  - organization of two different stacks, possibly two servers <br>  - separate application connections for two templates, high server load <br>  - on the server you need to integrate two stacks in one application and coordinate them with each other <br>  - the same on the frontend <br><br><h4>  WAMP: RPC and PubSub </h4><br>  Web Application Messaging Protocol ( <a href="http://wamp.ws/">WAMP</a> ) solves these problems by integrating RPC and PubSub into one protocol.  One library, one connection and one API. <br><br>  The protocol is open, and for it there is an open JavaScript implementation ( <a href="http://autobahn.ws/js">Autobahn | JS</a> ), which works both in the browser and under Node.js.  For other languages, there are also implementations, so you can use PHP, Java, Python, or Erlang on the server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/503/961/8d1/5039618d14f6b1232005a337a2319f80.png" alt="image"><br><br>  WAMP libraries can be used not only on the backend, but also for native clients, allowing you to combine web and clients running on the same protocol.  The C ++ library is well suited for running WAMP components on devices with limited resources. <br><br>  Connections do not occur from the browser to the backend, but through a WAMP router that distributes messages.  For PubSub, it plays the role of a server ‚Äî your server publishes a message for the router, and it already distributes it.  For RPC, the frontend sends a request for a remote procedure to the router, and it forwards it to the backend, and then returns the result. <br><br>  Let's see how to solve our problem with voting with the help of WAMP. <br><br><h4>  Voting update live: WebSockets and WAMP </h4><br>  For simplicity, our backend will also be written in JS and will work in another tab.  A browser backend is possible because browser clients can register procedures for a remote call just like any other WAMP client. <br><br>  The code for the demo is on <a href="https://github.com/tavendo/AutobahnJS/tree/master/doc/_static/code/votes">GitHub</a> , along with instructions for launching it.  <a href="http://crossbar.io/">Crossbar.io is</a> used as a router. <br><br><h5>  WAMP library connection </h5><br>  To get started, let's connect the Autobahn | JS library. <br><br>  For demonstration purposes, you can connect it as follows: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://autobahn.s3.amazonaws.com/autobahnjs/latest/autobahn.min.jgz"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span>;</code> </pre><br><br><h5>  We establish connection </h5><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> autobahn.Connection({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">"ws://example.com/wamprouter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">realm</span></span>: <span class="hljs-string"><span class="hljs-string">"votesapp"</span></span> });</code> </pre><br><br>  The first argument is the URL of the router.  The ws scheme is used because WAMP uses <a href="https://developer.mozilla.org/en/docs/WebSockets">WebSockets</a> as the default transport.  In addition, HTTP headers are not transmitted during communication, which reduces traffic.  WebSockets are supported in all <a href="http://crossbar.io/docs/Browser-Support/">modern browsers</a> . <br><br>  The second argument we set is ‚Äúrealm‚Äù, the space to which the connection is attached.  Spaces create separate domains for routing on the server ‚Äî that is, messages are transmitted only within a single space. <br><br>  The created object allows you to attach two callbacks - one for a successful connection, and the second for an unsuccessful one, and for the moment when the connection is interrupted. <br><br>  The onopen handler is called upon establishing the connection, and receives the session object.  We pass it to the main function, which contains the functionality of the application. <br><br><pre> <code class="javascript hljs">connection.onopen = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">session, details</span></span></span><span class="hljs-function">) </span></span>{ main(session); };</code> </pre><br><br>  Next, you need to run the opening of the connection: <br><br><pre> <code class="javascript hljs">connection.open();</code> </pre><br><br><h5>  Register and call the procedure </h5><br>  The frontend sends votes by calling a procedure on the backend.  Define the function of processing the transmitted voice: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> submitVote = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flavor = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; votes[flavor] += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> votes[flavor]; };</code> </pre><br><br>  It increases the number of votes and returns this number. <br><br>  Then we register it on the WAMP router: <br><br><pre> <code class="javascript hljs">session.register(<span class="hljs-string"><span class="hljs-string">'com.example.votedemo.vote'</span></span>, submitVote)</code> </pre><br><br>  At the same time, we assign it a unique identifier used for the call.  For this, WAMP uses URIs in the form of Java packages. <br><br>  Now the submitVote function can be called from any authorized client from the same space.  The call looks like this: <br><br><pre> <code class="javascript hljs">session.call(<span class="hljs-string"><span class="hljs-string">'com.example.votedemo.vote'</span></span>,[flavor]).then(onVoteSubmitted)</code> </pre><br><br>  What submitVote returns is passed to the onVoteSubmitted handler. <br><br>  Autobahn | JS does this through regular callbacks, but with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promises</a> : session.call immediately returns an object that is processed at the time the call is returned, the callback is made, and then the handler function is executed. <br><br>  For simple use cases of WAMP and Autobahn | JS, ‚Äã‚Äãyou don‚Äôt need to know anything about promises.  You can consider them another callback entry. <br><br><h5>  Subscribe and send updates </h5><br>  What about updating other clients?  To receive updates, the client must inform the router what information it needs.  For this: <br><br><pre> <code class="javascript hljs">session.subscribe(<span class="hljs-string"><span class="hljs-string">'com.example.votedemo.on_vote'</span></span>, updateVotes);</code> </pre><br><br>  We pass on the topic and the function that will be called each time the information is received. <br><br>  It remains only to configure the sending of updates from the server.  Create an object to send and publish information on the topic we need.  We will add this functionality to the previously registered submitVote: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> submitVote = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, kwargs, details</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flavor = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; votes[flavor] += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = { <span class="hljs-attr"><span class="hljs-attr">subject</span></span>: flavor, <span class="hljs-attr"><span class="hljs-attr">votes</span></span>: votes[flavor] }; session.publish(<span class="hljs-string"><span class="hljs-string">'com.example.votedemo.on_vote'</span></span>, [res]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> votes[flavor]; };</code> </pre><br><br>  That's all: sending votes to the backend and updating votes for all connected browsers work on the same protocol. <br><br><h4>  Total </h4><br>  WAMP unifies message passing.  RPC and PubSub should be enough for all application tasks.  The protocol works through WebSockets, fast, single and bidirectional connection to the server.  Since the WAMP protocol is open and its implementations already exist for different languages, you are free to choose technology for use on the backend and even write applications for native clients, and not just for the web. <br><br><h4>  Notes </h4><br>  ‚Äú <a href="https://demo.crossbar.io/demo/vote/web/index.html">Vote</a> ‚Äù, Crossbar.io - the current version of the vote <br><br>  ‚Äú <a href="http://wamp.ws/why/">Why WAMP?</a>  ", WAMP - explanation of the development of the protocol <br><br>  ‚Äú <a href="http://tavendo.com/blog/post/free-your-code-backends-in-the-browser/">Free Your Code: Backends in the Browser</a> ,‚Äù Alexander G√∂dde, Tavendo - an article on how protocol symmetry affects deployment <br><br>  ‚Äú <a href="http://tavendo.com/blog/post/websocket-why-what-can-i-use-it/">WebSockets: Why, What and Can I Use It?</a>  ‚Äù, Alexander G√∂dde, Tavendo - WebSockets Review <br><br>  ‚Äú <a href="http://wamp.ws/compared/">WAMP Compared</a> ‚Äù, WAMP - protocol comparison with others <br><br>  <a href="http://crossbar.io/">Crossbar.io</a> - an introduction to using a universal router for applications </div><p>Source: <a href="https://habr.com/ru/post/255327/">https://habr.com/ru/post/255327/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255315/index.html">AppStore comprehension path or how much experience?</a></li>
<li><a href="../255317/index.html">openEMS is an open source electromagnetic simulator</a></li>
<li><a href="../255321/index.html">Create a fully automatic farm (finished implementation)</a></li>
<li><a href="../255323/index.html">We are switching from STM32 to the Russian K1986BE92QI microcontroller. Setting up the project in keil and flashing LED</a></li>
<li><a href="../255325/index.html">Malefactors use complex malware to attack Russian business</a></li>
<li><a href="../255329/index.html">Simulate sensor readings using an array of waypoints</a></li>
<li><a href="../255331/index.html">Vulnerability in Xamarin for Android: we replace dll and we eat for free</a></li>
<li><a href="../255333/index.html">New adware is embedded directly in the browser.</a></li>
<li><a href="../255337/index.html">How does a boiler house in Middle Akhtuba differ from a power center of a data center?</a></li>
<li><a href="../255339/index.html">Hardware room (about satellite network infrastructure and oscilloscope)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>