<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>7 simple optimizations that reduce the CPU load from 80% to 27%</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For more than 3 years, our team has been developing such an important component of the operator's network as PCRF . Policy and Charging Rules Function...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>7 simple optimizations that reduce the CPU load from 80% to 27%</h1><div class="post__text post__text-html js-mediator-article">  For more than 3 years, our team has been developing such an important component of the operator's network as <b>PCRF</b> .  Policy and Charging Rules Function (PCRF) is a solution for managing subscriber service policies in LTE networks (3GPP), which allows you to assign a policy in real time, taking into account the services connected to the subscriber, his location, the quality of the network in a given location in currently, time of day, amount of traffic consumed, etc.  Under the policy in this context refers to the set of services available to the subscriber and the parameters of QoS (quality of service).  Analyzing the price-quality ratio for various products in this field from various suppliers, we decided to develop our product.  And now, for more than 2 years, our PCRF has been successfully operating on the commercial network of the Yota company.  The solution is fully software, with the ability to install even on ordinary virtual servers.  It works in commerce on Red Hat Linux, but in general it can be installed for other Linux systems. <br><a name="habracut"></a><br>  Of all the capabilities of our PCRF, the most successful were: <br><ul><li>  flexible tool for direct decision making about subscriber policies, based on Lua language, which allows the operating service to easily and on the fly change the policy assignment algorithm; </li><li>  support of various <b>PCEF</b> (Policy and Charging Enforcement Function - a component that directly establishes policies to subscribers), <b>DPI</b> (Deep Packet Inspection - a component for analyzing traffic packets, in particular, allowing to calculate the amount of traffic consumed by categories), <b>AF</b> (Application Function - a component describing flows service data and informing about the resources required by the service).  All these network nodes can be installed in any number, many sessions from different network components per subscriber are supported.  We have carried out many IOT with many large manufacturers of such equipment; </li><li>  a whole family of external interfaces for systems located in the network, and a monitoring system describing all processes occurring in the system; </li><li>  scalability and performance. </li></ul><br>  Actually, later in the article we will discuss one of the many criteria of the latter. <br><br>  We have a resource on which we laid out an <a href="http://freepcrf.com/download/">image</a> for testing six months ago, available to everyone under the appropriate <a href="http://freepcrf.com/docs/latest/Yota_PCRF_software_license_agreement.pdf">license</a> , a <a href="http://freepcrf.com/iots/">list of</a> equipment suppliers with whom we had IOTs, a <a href="http://freepcrf.com/documentation/">package</a> of product <a href="http://freepcrf.com/documentation/">documents</a> and several articles in English about our development experience (about Lua -based <a href="http://freepcrf.com/2013/10/10/pcrf-experience-dynamic-script-based-policy-decision-maker-or-what-do-we-need-lua-for/">engine</a> , for example, or a variety of <a href="http://freepcrf.com/2013/11/01/pcrf-experience-from-functional-testing-to-performance-monsters-or-how-did-we-climb-the-testing-hill/">testing</a> ). <br><br>  When it comes to performance, there are many criteria by which it is evaluated.  The article about testing on our resource describes in some detail the load tests and tools that we used.  Here I would like to stop at such a parameter as using CPU. <br>  I will compare the results obtained on the test with 3000 transactions per second and the following scenarios: <br><ol><li>  CCR-I - setting the subscriber session, </li><li>  CCR-U - update session information with information about the amount of traffic consumed by the subscriber, </li><li>  CCR-T - the end of the session with information about the amount of traffic consumed by the subscriber. </li></ol><br>  In version 3.5.2, released by us in the first quarter of last year, the CPU load on this scenario was quite high and was <b>80%</b> .  We were able to lower it to <b>35%</b> in version 3.6.0, which is currently on the commercial network, and up to <b>27%</b> in version 3.6.1, which is currently at the stage of stabilization. <br> <a href=""><img src="http://freepcrf.com/docs/posts_data/cpu.png" alt="image"></a> <br>  Despite such a huge difference, we didn‚Äôt perform any miracle, but simply performed 7 simple optimizations, which I will describe below.  Perhaps, in your product you can also use something from the above to make it better in terms of CPU usage. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First of all, I would like to say that most of the optimizations concerned the interaction of the database and application logic.  A more thoughtful use of requests and information caching is, perhaps, the main thing that we have done.  To analyze the time of the database queries, we had to make our utility.  The fact is that initially the application used Oracle TimesTen base, which does not have built-in advanced monitoring tools.  And after introducing PostgreSQL, we decided that using one tool to compare two databases is correct, so we left our utility.  In addition, our utility allows not to collect data all the time, but to enable / disable it as needed, for example, in a commercial network with a small increase in CPU utilization, but with the ability to analyze right away at production what query is causing problems at the moment. <br>  The utility calls <i>tt_perf_info</i> and simply measures the time spent at different stages of the query execution: fetch, direct execution, number of calls per second, percentage taken from the total time.  Time is displayed in microseconds.  Top 15 requests for versions 3.5.2 and 3.6.1 can be seen in the tables by the links: <br>  <a href="http://freepcrf.com/docs/posts_data/3.5.2.html">3.5.2 top 15</a> <br>  <a href="http://freepcrf.com/docs/posts_data/3.6.1.html">3.6.1 top 15</a> (empty cells correspond to the value 0 in this version) <br><br><h5>  Optimization 1: reduced commits </h5><br>  If you look closely at the output of <i>tt_perf_info</i> on different versions, you can see that the number of calls to pcrf.commit has been reduced from <b>12006</b> times per second to <b>1199</b> , that is, <b>10</b> times!  A completely obvious decision that occurred to us was to check whether any changes in the database really occurred, and to make a commit only in the case of a positive answer.  For example, for an UPDATE request, the PCRF checks the number of changed records.  If it is 0, then the commit is not performed.  Similar to DELETE. <br><br><h5>  Optimization 2: removing the MERGE query </h5><br>  Based on Oracle TimesTen, it was noted that the MERGE query sets the lock on the entire table.  That in conditions of processes constantly competing for tables, led to obvious problems.  So we simply replaced all MERGE requests with a combination of GET-UPDATE-INSERT.  If there is an entry, it is updated; if not, a new one is added.  We did not even bother wrapping all this into a transaction, but recursively called the function in case of failure.  On pseudocode, it looks like this: <br><pre><code class="hljs kotlin">our_db_merge_function() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (db_get() == OK) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (db_update() == OK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OK; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out_db_merge_function(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (db_insert() == OK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OK; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out_db_merge_function(); } } }</code> </pre> <br>  In practice, this almost always works out without a recursive call, since conflicts on one record still rarely occur. <br><br><h5>  Optimization 3: configuration caching for calculating the amount of traffic consumed by subscribers </h5><br>  The algorithm for calculating the amount of traffic consumed according to the 3GPP specification has a rather complex structure.  In version 3.5.2, the entire configuration was stored in the database and represented tables of monitoring keys and batteries with a many-to-many relationship.  The system also supported the summation of traffic accumulators from different external systems into one value on the PCRF and this setting was stored in the database.  As a result, with the arrival of the next data on the accumulated volume, there was a complex sampling on the base. <br>  In 3.6.1 most of the configuration was moved to the xml file with the notification of the processes of changing this file and counting the checksum on the configuration information.  Also, the current information about the traffic monitoring subscription is stored in a blob associated with each user session.  Reading and writing a blob is undoubtedly faster and less resource-intensive than a huge selection of tables with a many-to-many relationship. <br><br><h5>  Optimization 4: reducing the number of exports Lua engine </h5><br>  The Lua engine is called for each CCR-I, CCR-U and RAR request, processed in the PCRF, and executes the Lua script describing the policy selection algorithm, since the subscriber‚Äôs policy is likely to change when processing the request data.  But the idea of ‚Äã‚Äãcheck-sums has been applied here.  In version 3.6.1, we saved all the information on which the actual change in policy could depend, into a separate structure and began to count the checksum on it.  Accordingly, the engine began to twitch only in case of real changes. <br><br><h5>  Optimization 5: removal of the network configuration from the database </h5><br>  The network configuration is also stored in the Database from the earliest versions of the PCRF.  In release 3.5.2, the application logic and the network part quite intersected the tables with the network settings, since the logic module regularly read connection parameters from the database, and the network part used the database as a repository of all network information.  In version 3.6.1, the information for the network part was transferred to shared memory, and periodic processes were added to the main logic, updating it with changes in the database.  Thereby, locks were reduced according to the general tables in the database. <br><br><h5>  Optimization 6: Selective Analysis of Diameter Commands </h5><br>  PCRF communicates with external systems using the Diameter protocol, analyzing and parsing multiple commands per unit of time.  These commands, as a rule, contain many fields (avp) within themselves, but not every component needs all the fields.  Often, only a few fields from the first (header) part of the command are used, such as Destination / Origin Host / Realm, or fields that identify the subscriber or session, that is, id (which are also often located at the beginning).  And only one or two main processes use all message fields.  Therefore, in version 3.6.1, masks were introduced that describe which fields need to be read for this component.  And also removed almost all copy memory operations.  In fact, only the original message remains in memory, and all processes use structures with pointers to the necessary parts, the data is copied inside the processes for strict need. <br><br><h5>  Optimization 7: Time Caching </h5><br>  When the PCRF began to process more than 10,000 transactions per second, it became noticeable that the logging process takes up a significant amount of time and CPU.  Sometimes it seems that the logs can be sacrificed in favor of greater performance, but the operator should be able to reproduce the whole picture of what is happening on the network and on a specific component.  Therefore, we sat down to analyze and found out that the most frequent entry in the log is a time and date stamp.  Of course, in every record in the log it is present.  And then, limiting the accuracy of time to a second, we simply began to cache the line with the current time and rewrite it only for the next second. <br><br>  All these seven optimizations will surely seem to an experienced high-performance developer simple and obvious.  They also seemed so to us, but only when we realized and realized them.  The best solution often lies on the surface, but it is also the most difficult to see.  So I summarize: <br><ol><li>  Check that the data actually changes; </li><li>  Try to minimize the number of locks on entire tables; </li><li>  Cache and remove configuration data from the database; </li><li>  Do only those actions that are really needed, even if it seems that it is easier to make the entire list. </li></ol><br></div><p>Source: <a href="https://habr.com/ru/post/210390/">https://habr.com/ru/post/210390/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210374/index.html">Employees of Google, Microsoft, Cisco and Apple went to Twitter, Box and Dropbox</a></li>
<li><a href="../210382/index.html">CES 2014 results: new ATIV line devices</a></li>
<li><a href="../210384/index.html">"Debriefing" - Dart-Anyang web development</a></li>
<li><a href="../210386/index.html">What is the theory and where does the scientific method</a></li>
<li><a href="../210388/index.html">Non-standard application of IT in everyday life: parsing, perceptual hash, image comparison = cost optimization</a></li>
<li><a href="../210406/index.html">Lexand Capella: a smartphone with Full HD-screen and support for two SIM-cards for 9,600 rubles ($ 280)</a></li>
<li><a href="../210408/index.html">Forgotten zoom</a></li>
<li><a href="../210410/index.html">Implement an L2TP / IPsec VPN server using standard Windows 7/8 tools for connecting Windows / iOS / Android systems to an internal network</a></li>
<li><a href="../210412/index.html">The legacy of Konrad Zuse: Architecture Z1 and Z3 [Translation]</a></li>
<li><a href="../210416/index.html">Clear cookies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>