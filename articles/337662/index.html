<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript: Asynchronous Programming Techniques</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Synchronous JavaScript code, the author of which did not seek to confuse those who will read this code, usually looks simple and clear. The commands o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript: Asynchronous Programming Techniques</h1><div class="post__text post__text-html js-mediator-article">  Synchronous JavaScript code, the author of which did not seek to confuse those who will read this code, usually looks simple and clear.  The commands of which it is composed are executed in the order in which they follow in the text of the program.  A bit of confusion can make <a href="https://scotch.io/tutorials/understanding-hoisting-in-javascript">raising</a> declarations of variables and functions, but to turn this feature of JS into a problem, you have to try very hard.  Synchronous JavaScript code has only one serious drawback: one cannot go far on it. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/337662/"><img src="https://habrastorage.org/web/0e1/1e3/3e4/0e11e33e470f496baed4267be68fcf86.jpg"></a> <br><br>  Virtually every useful JS program is written using asynchronous development methods.  This is where callbacks come in, in common parlance, callbacks.  Here there are ‚Äúpromises‚Äù or Promise objects, usually called promises.  Here you can encounter generators and async / await constructions.  Asynchronous code, in comparison with synchronous, is usually more difficult to write, read and maintain.  Sometimes it turns into completely creepy structures like hell callbacks.  However, it can not do without. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Today we offer to talk about the features of callbacks, promises, generators, and async / await constructions, and to think about how to write simple, understandable and efficient asynchronous code. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">About synchronous and asynchronous code</font> </h2><br>  We'll start by looking at fragments of synchronous and asynchronous JS code.  For example, the usual synchronous code: <br><br><pre><code class="hljs pgsql">console.log(<span class="hljs-string"><span class="hljs-string">'1'</span></span>) console.log(<span class="hljs-string"><span class="hljs-string">'2'</span></span>) console.log(<span class="hljs-string"><span class="hljs-string">'3'</span></span>)</code> </pre> <br>  He, without any particular difficulty, displays numbers from 1 to 3 to the console. <br><br>  Now the code is asynchronous: <br><br><pre> <code class="hljs lua">console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'1'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterTwoSeconds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'2'</span></span>) }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'3'</span></span>)</code> </pre> <br>  Here the sequence 1, 3, 2 will be displayed. The number 2 is derived from the callback, which handles the timer triggering event specified when the <code>setTimeout</code> function was called.  The callback will be called, in this example, after 2 seconds.  The application will not stop while waiting for the two seconds to expire.  Instead, its execution will continue, and when the timer fires, the <code>afterTwoSeconds</code> function will be called. <br><br>  Perhaps, if you are just starting the path of a JS developer, you will be asked questions: ‚ÄúWhy is this all?  Maybe you can convert asynchronous code to synchronous? ".  Let's look for answers to these questions. <br><br><h2>  <font color="#3AC1EF">Formulation of the problem</font> </h2><br>  Suppose we are faced with the task of finding a GitHub user and loading data about his repositories.  The main problem here is that we do not know the exact username, so we need to display all users with names similar to what we are looking for and their repositories. <br><br>  In terms of the interface, we restrict ourselves to something <a href="https://jsfiddle.net/fp9pk8pq/">simple</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/443/525/bad/443525bad4d58eb56115cb77d83a57e2.png"><br>  <i><font color="#999999">Simple search interface for GitHub users and their corresponding repositories</font></i> <br><br>  In the examples, requests will be executed using <code>XMLHttpRequest</code> (XHR), but you can easily use jQuery ( <code>$.ajax</code> ) here, or the more modern standard approach, based on the use of the function <code>fetch</code> .  Both that and another is reduced to use of promises.  The code, depending on the campaign, will change, but here, for a start, this example: <br><br><pre> <code class="hljs lua">//  url   -  <span class="hljs-string"><span class="hljs-string">'https://api.github.com/users/daspinola/repos'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(url)</span></span></span></span> { const xhr = new XMLHttpRequest(); xhr.timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span> === <span class="hljs-number"><span class="hljs-number">200</span></span>) {      //          } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      //           }   } } xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {   //      ,   ,     } xhr.<span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) xhr.send(); }</code> </pre> <br>  Pay attention to the fact that in these examples it‚Äôs important not what comes from the server and how it will be processed, but the organization of the code itself using different approaches that you can use in your asynchronous development. <br><br><h2>  <font color="#3AC1EF">Callback functions</font> </h2><br>  You can do a lot of things with functions in JS, including passing in arguments to other functions.  Usually this is done in order to call the transferred function after the completion of some process, which may take some time.  This is a callback function.  Here is a simple example: <br><br><pre> <code class="hljs lua">//   <span class="hljs-string"><span class="hljs-string">"doThis"</span></span>      ,    -   <span class="hljs-string"><span class="hljs-string">"andThenThis"</span></span>.  <span class="hljs-string"><span class="hljs-string">"doThis"</span></span>  ,   ,  ,   ,   <span class="hljs-string"><span class="hljs-string">"andThenThis"</span></span>. doThis(andThenThis) //  <span class="hljs-string"><span class="hljs-string">"doThis"</span></span>         <span class="hljs-string"><span class="hljs-string">"callback"</span></span> , ,   ,      <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">andThenThis</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'and then this'</span></span>) } //  ,      ,   , <span class="hljs-string"><span class="hljs-string">"callback"</span></span> -     <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doThis</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'this first'</span></span>) //  ,  ,      ,  ,      , <span class="hljs-string"><span class="hljs-string">'()'</span></span>,     callback() }</code> </pre> <br>  Using this approach to solve our problem, we can write the following <code>request</code> function: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>; xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span>) {      callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, xhr.response)     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {      callback(xhr.status, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)     }   } } xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Timeout'</span></span>) } xhr.open(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) xhr.send(); }</code> </pre> <br>  Now the function for executing the request accepts the <code>callback</code> parameter, therefore, after executing the request and receiving the server response, the callback will be called both in case of an error and in case of successful completion of the operation. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userGet = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/search/users?page=1&amp;q=daspinola&amp;type=Users`</span></span> request(userGet, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleUsersList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, users</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(users).items list.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{   request(user.repos_url, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleReposList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, repos</span></span></span><span class="hljs-function">) </span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err     <span class="hljs-comment"><span class="hljs-comment">//      }) }) })</span></span></code> </pre> <br>  Let's analyze what is happening here: <br><br><ul><li>  A request is made to get the user's repositories (in this case, I upload my own repositories); <br></li><li>  After the request is completed, the <code>handleUsersList</code> handleUsersList is <code>handleUsersList</code> ; <br></li><li>  If there were no errors, parse the server response using J <code>SON.parse</code> , convert it, for convenience, into an object; <br></li><li>  After that, we iterate over the list of users, since there may be more than one item in it, and for each of them we request the list of repositories using the URL returned for each user after the first request is completed.  This implies that <code>repos_url</code> is the URL for our next requests, and we got it from the first request. <br></li><li>  When the request to download the repository data is completed, the callback is called, now it's <code>handleReposList</code> .  Here, as well as when loading a list of users, you can handle errors or useful data, which contain a list of user repositories. <br></li></ul><br>  Please note that using the error object as the first parameter is a widespread practice, in particular, for developing using Node.js. <br><br>  If we give our code a more complete look, provide it with error handling tools and separate the definition of callback functions from the request execution code, which improves the readability of the program, we get the following: <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { request(userGet, handleUsersList) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { console.error(<span class="hljs-string"><span class="hljs-string">'Request boom! '</span></span>, e) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleUsersList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error, users)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = JSON.parse(users).items <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span><span class="hljs-function"> </span></span>{   request(user.repos_url, handleReposList) }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleReposList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, repos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err <span class="hljs-comment"><span class="hljs-comment">//     console.log('My very few repos', repos) }</span></span></code> </pre> <br>  This approach works, but using it we run the risk of problems like the race conditions of queries and the complexity of error handling.  However, the main trouble with callbacks, which, considering what happens in the <code>forEach</code> loop, here are three, is that such code is hard to read and maintain.  A similar problem exists, perhaps, from the day the callback functions appeared, it is widely known as callback hell. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/03b/dd6/4c0/03bdd64c012e4de2e08e21d89924b62b.png"><br>  <i><font color="#999999">Hell kollbekov in all its glory.</font></i>  <i><font color="#999999">The image is taken <a href="https://medium.com/%40sagish/node-with-benefits-using-coffeescript-in-your-stack-e9754bf58668">from here</a> .</font></i> <br><br>  In this case, under the ‚Äúrace condition‚Äù we understand the situation when we do not control the procedure for obtaining data on user repositories.  We request data for all users, and it may well turn out that the answers to these requests will be mixed up.  Say, the answer for the tenth user comes first, and the second - the last.  Below we talk about a possible solution to this problem. <br><br><h2>  <font color="#3AC1EF">Promises</font> </h2><br>  Using promises can improve code readability.  As a result, for example, if a new developer comes to your project, he will quickly understand how everything is arranged there. <br><br>  In order to create a promise, you can use this design: <br><br><pre> <code class="hljs lua">const myPromise = new Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span></span> { //    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (codeIsFine) {   resolve(<span class="hljs-string"><span class="hljs-string">'fine'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">'error'</span></span>) } }) myPromise .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">whenOk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(response)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notOk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>(err) })</code> </pre> <br>  Let's sort this example: <br><br><ul><li>  Promis is initialized using a function in which there are calls to the <code>resolve</code> and <code>reject</code> methods; <br></li><li>  Asynchronous code is placed inside a function created using the <code>Promise</code> constructor.  If the code is executed successfully, call the <code>resolve</code> method, if not, <code>reject</code> ; <br></li><li>  If the function calls <code>resolve</code> , the <code>.then</code> method for the <code>Promise</code> object will be executed; similarly, if <code>reject</code> is called, the <code>.catch</code> method will be executed. <br></li></ul><br>  Here is something to remember when working with promises: <br><br><ul><li>  The <code>resolve</code> and <code>reject</code> methods take only one parameter; as a result, for example, when executing a command of the type <code>resolve('yey', 'works')</code> , only <code>'yey'</code> will be passed to the callback <code>.then</code> ; <br></li><li>  If you chain multiple <code>.then</code> calls at the end of the corresponding callbacks, you should always use <code>return</code> , otherwise they will all be executed at the same time, and this is obviously not what you want to achieve; <br></li><li>  When the <code>reject</code> command is executed, if the next in the chain goes <code>.then</code> , it will be executed (you can consider <code>.then</code> expression that is executed in any case); <br></li><li>  If an error occurs in the chain of <code>.then</code> calls in one of them, the next ones will be skipped until the expression <code>.catch</code> is found; <br></li><li>  Promises have three states: ‚Äúpending‚Äù ‚Äîthe wait state for a call to <code>resolve</code> or <code>reject</code> , as well as the states ‚Äúresolved‚Äù and ‚Äúrejected‚Äù, which correspond to a successful, with a call to <code>resolve</code> , and unsuccessful, with a call to <code>reject</code> , completion of the work of promis.  When the promise is in the ‚Äúresolved‚Äù or ‚Äúrejected‚Äù state, it cannot be changed. <br></li></ul><br>  Please note that promises can be created without using separately defined functions, describing functions at the moment of creating promises.  What is shown in our example is only a common way to initialize promises. <br><br>  In order not to get bogged down in theory, let us return to our example.  Rewrite it using promises. <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest();   xhr.timeout = <span class="hljs-number"><span class="hljs-number">2000</span></span>;   xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span>) {         resolve(xhr.response)       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         reject(xhr.status)       }     }   }   xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     reject(<span class="hljs-string"><span class="hljs-string">'timeout'</span></span>)   }   xhr.open(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)   xhr.send(); }) }</code> </pre> <br>  With this approach, when you call <code>request</code> , the following will be returned. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa5/801/993/aa58019939048df78a63ade184aaacce.png"><br>  <i><font color="#999999">This is a promise in the waiting state.</font></i>  <i><font color="#999999">It can either be resolved successfully or rejected.</font></i> <br><br>  Now, using the new <code>request</code> function, we will rewrite the rest of the code. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userGet = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/search/users?page=1&amp;q=daspinola&amp;type=Users`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = request(userGet) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'will be pending when logged'</span></span>, myPromise) myPromise .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleUsersList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'when resolve is found it comes here with the response, in this case users '</span></span>, users)   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> list = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(users).items   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(list.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request(user.repos_url)   })) }) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleReposList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">repos</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'All users repos in an array'</span></span>, repos) }) .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'when a reject is executed it will come here ignoring the then statement '</span></span>, error) })</code> </pre> <br>  Here we find ourselves in the first expression <code>.then</code> with the successful resolution of promise.  We have a list of users.  In the second expression <code>.then</code> we pass an array with repositories.  If something went wrong, we‚Äôll end up in a <code>.catch</code> expression. <br><br>  Through this approach, we have dealt with the state of the race and with some of the problems that arise.  Ada kollbekov here is not observed, but the code is still not read so easy.  In fact, our example can be further improved by extracting callback functions from it: <br><br><pre> <code class="hljs lua">const userGet = `https://api.github.com/search/users?page=<span class="hljs-number"><span class="hljs-number">1</span></span>&amp;q=daspinola&amp;<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>=Users` const userRequest = request(userGet) //       ,        userRequest .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(handleUsersList) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(repoRequest) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(handleReposList) .catch(handleErrors) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleUsersList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(users)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JSON.parse(users).items } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repoRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(users)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.all(users.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request(user.repos_url) })) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleReposList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(repos)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'All users repos in an array'</span></span>, repos) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>(<span class="hljs-string"><span class="hljs-string">'Something went wrong '</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) }</code> </pre> <br>  With this approach, one look at the names of callbacks in <code>.then</code> expressions reveals the meaning of the call to <code>userRequest</code> .  The code is easy to work with and easy to read. <br><br>  In fact, this is only the tip of the iceberg of what is called the promise.  Here is the <a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html">material</a> that I recommend to read to those who want to more thoroughly immerse themselves in this topic. <br><br><h2>  <font color="#3AC1EF">Generators</font> </h2><br>  Another approach to the solution of our problem, which, however, you rarely meet, is generators.  The topic is a little more complicated than the rest, so if you feel that it‚Äôs too early for you to study, you can skip ahead to the next section of this material. <br><br>  In order to define a generator function, you can use the asterisk, ‚Äú*‚Äù, after the keyword <code>function</code> .  Using generators, asynchronous code can be made very similar to synchronous.  For example, it may look like this: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> const args = <span class="hljs-built_in"><span class="hljs-built_in">yield</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(args) } var fooIterator = foo() console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(fooIterator.<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>().value) //  <span class="hljs-number"><span class="hljs-number">1</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(fooIterator.<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>().value) //  <span class="hljs-number"><span class="hljs-number">2</span></span> fooIterator.<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(<span class="hljs-string"><span class="hljs-string">'aParam'</span></span>) //    console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>      <span class="hljs-string"><span class="hljs-string">'aParam'</span></span></code> </pre> <br>  The point here is that the generators, instead of <code>return</code> , use the expression <code>yield</code> , which stops the execution of the function until the next call to the <code>.next</code> iterator.  This is similar to the expression <code>.then</code> in promises, which is performed when promise is resolved. <br><br>  Let us now see how to apply all this to our task.  So, here is the <code>request</code> function: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest();   xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span>) {         callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, xhr.response)       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         callback(xhr.status, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)       }     }   }   xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'timeout'</span></span>)   }   xhr.open(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)   xhr.send() } }</code> </pre> <br>  Here, as usual, we use the <code>url</code> argument, but instead of immediately executing the request, we want to execute it only when we have a callback function to process the response. <br><br>  The generator will look like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userGet = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/search/users?page=1&amp;q=daspinola&amp;type=Users`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> request(userGet) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;=users.length; i++) {   <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> request(users[i].repos_url) } }</code> </pre> <br>  This is what happens here: <br><br><ul><li>  We wait for the preparation of the first request, returning the function reference and waiting for the callback for this first request (recall the <code>request</code> function, which it receives the <code>url</code> and returns the function that expects the callback); <br></li><li>  We expect the list of users, <code>users</code> , to be ready to be sent to the next <code>.next</code> ; <br></li><li>  We pass through the resulting <code>users</code> array and expect, for each of them, <code>.next</code> , returning, for each, the corresponding callback. <br></li></ul><br>  Using this all will look like this: <br><br><pre> <code class="hljs lua">try { const iterator = list() iterator.<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>().value(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleUsersList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, users)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) throw err   const list = JSON.parse(users).items     //       iterator.<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>(list)     list.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user)</span></span></span></span> {     iterator.<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>().value(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userRepos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error, repos)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) throw repos       //              console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(user, JSON.parse(repos))     })   }) }) } catch (e) { console.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>(e) }</code> </pre> <br>  Here we can individually process the list of repositories of each user.  In order to improve this code, we could select callback functions, as we have done above. <br><br>  I am ambiguous about generators.  On the one hand, you can quickly understand what to expect from the code by looking at the generator, on the other hand, the execution of generators leads to problems similar to those that arise in the hell of callbacks. <br><br>  It should be noted that generators are a relatively new opportunity, as a result, if you expect to use your code in older versions of browsers, the code should be processed with a transpiler.  In addition, generators in the writing of asynchronous code are used infrequently, so if you are involved in team development, keep in mind that some programmers may be unfamiliar with them. <br>  In case you decide to better delve into this topic, <a href="https://codeburst.io/generators-in-javascript-1a7f9f884439">here</a> and <a href="http://chrisbuttery.com/articles/synchronous-asynchronous-javascript-with-es6-generators/">now</a> - excellent materials about the internal structure of the generators. <br><br><h2>  <font color="#3AC1EF">Async / await</font> </h2><br>  This method is similar to a mixture of generators and promises.  You just need to specify, using the <code>async</code> , which function is supposed to be performed asynchronously, and using <code>await</code> , tell the system what part of the code should wait for the permission of the corresponding promise. <br>  As usual, first is a simple example. <br><br><pre> <code class="hljs javascript">sumTwentyAfterTwoSeconds(<span class="hljs-number"><span class="hljs-number">10</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'after 2 seconds'</span></span>, result)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sumTwentyAfterTwoSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> remainder = afterTwoSeconds(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value + <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> remainder } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterTwoSeconds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(value) }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); }</code> </pre> <br>  Here the following happens: <br><br><ul><li>  There is an asynchronous function <code>sumTwentyAfterTwoSeconds</code> ; <br></li><li>  We offer the code to wait for permission to promise <code>afterTwoSeconds</code> , which can end with a call to <code>resolve</code> or <code>reject</code> ; <br></li><li>  Code execution ends in <code>.then</code> , where the operation marked with the <code>await</code> keyword is completed, in this case it is just one operation. <br></li></ul><br>  Prepare the <code>request</code> function for use in the <code>async/await</code> construction: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest();   xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span>) {         resolve(xhr.response)       } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {         reject(xhr.status)       }     }   }   xhr.ontimeout = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     reject(<span class="hljs-string"><span class="hljs-string">'timeout'</span></span>)   }   xhr.open(<span class="hljs-string"><span class="hljs-string">'get'</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)   xhr.send() }) }</code> </pre> <br>  Now we create a function with the <code>async</code> , in which we use the <code>await</code> keyword: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userGet = <span class="hljs-string"><span class="hljs-string">`https://api.github.com/search/users?page=1&amp;q=daspinola&amp;type=Users`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request(userGet) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> usersList = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(users).items usersList.forEach(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> repos = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request(user.repos_url)     handleRepoList(user, repos) }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleRepoList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user, repos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userRepos = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(repos) <span class="hljs-comment"><span class="hljs-comment">//       console.log(user, userRepos) }</span></span></code> </pre> <br>  So, we have an asynchronous <code>list</code> function that will process the request.  We also need the <code>async/await</code> construction in a <code>forEach</code> loop to form a list of repositories.  Calling all this is very simple: <br><br><pre> <code class="hljs javascript">list() .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(e))</code> </pre> <br>  This approach and the use of promises are my favorite methods of asynchronous programming.  Code written with their use is convenient to read and edit.  Details about <code>async/await</code> can be found <a href="https://davidwalsh.name/async-await">here</a> . <br><br>  The minus <code>async/await</code> , like the minus of the generators, is that the old browsers do not support this design, and for its use in server development you need to use Node 8. In this situation, again, a transpiler will help, for example, <a href="https://babeljs.io/">babel</a> . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  <a href="https://codepen.io/daspinola/pen/EvOEKB">Here</a> you can see the project code that solves the problem set at the beginning of the material using <code>async/await</code> .  If you want to properly deal with what we talked about - experiment with this code and with all the technologies discussed. <br><br>  Please note that our examples can be improved, made more concise, if you rewrite them using alternative ways to execute queries, like <code>$.ajax</code> and <code>fetch</code> .  If you have ideas on how to improve the quality of the code using the methods described above, I will be grateful if you tell <a href="https://medium.com/%40daspinola">me</a> about it. <br><br>  Depending on the features of the task before you, it may turn out that you will use async / await, callbacks, or some kind of mixture from different technologies.  In fact, the answer to the question of which particular method of asynchronous development to choose depends on the characteristics of the project.  If a certain approach allows you to solve a problem with a readable code that is easy to maintain, which is understandable (and will be clear after a while) to you and other team members, then this approach is what you need. <br><br>  Dear readers!  What methods of writing asynchronous JavaScript code do you use? </div><p>Source: <a href="https://habr.com/ru/post/337662/">https://habr.com/ru/post/337662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337652/index.html">Platform for collecting donations in two weeks - the results of anti-hacking</a></li>
<li><a href="../337654/index.html">Read user input (digits) in the 3CX Call Flow Designer application</a></li>
<li><a href="../337656/index.html">This is not an article - just food for thought about how to write it.</a></li>
<li><a href="../337658/index.html">How we built our mini data center. Part 5 - experience, breaks, heat</a></li>
<li><a href="../337660/index.html">Why is a site audit useless for 99% of small businesses?</a></li>
<li><a href="../337664/index.html">Report with mitap for back-end developers</a></li>
<li><a href="../337666/index.html">How to meet the requirements of the quality management system according to ISO 9001: 2015</a></li>
<li><a href="../337668/index.html">How to use Java with CryptoPro to sign a PDF document</a></li>
<li><a href="../337670/index.html">Interserver WebRTC</a></li>
<li><a href="../337672/index.html">Getting the text of requests from SoapHttpClientProtocol</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>