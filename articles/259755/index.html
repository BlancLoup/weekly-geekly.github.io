<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Oberon system implemented on an affordable FPGA board</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="by Niklaus Wirth 
 Professor (retired) 
 Swiss Federal Institute of Technology (ETH) 
 Zurich, Switzerland 

 In 1988, J√ºrg Gutknecht and I completed ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Oberon system implemented on an affordable FPGA board</h1><div class="post__text post__text-html js-mediator-article">  <b>by Niklaus Wirth</b> <br>  Professor (retired) <br>  Swiss Federal Institute of Technology (ETH) <br>  Zurich, Switzerland <br><br>  In 1988, J√ºrg Gutknecht and I completed and published the Oberon programming language [1, 2], which was the successor to the two other languages, Pascal and Modula-2, which I developed earlier.  Oberon language was designed by us initially as more rational and efficient than Modula-2, which made it easier for students of the academic education system to master computer science.  Not stopping there, in 1990 we built an Oberon for workstations using windows and text processing capabilities.  Then we published a book revealing the details of both the Oberon compiler and the OS of the same name.  The book, entitled "Project Oberon", included the source code of the system. <br><br>  A few years later, my friend Paul Reed suggested that I publish a reprint of the book, because of its importance for the study of system architecture and giving a good starting point for those who want to build reliable systems from scratch. <br><a name="habracut"></a><br>  However, there was a serious obstacle.  The original compiler was created for a processor that has already disappeared from the market.  So I decided to rewrite the compiler for a modern processor.  But in the course of a small study, I could not find a processor that fully meets my criteria for clarity, regularity and simplicity.  So I had to design my own processor.  This idea was realized thanks to a modern PPVM chip (user-programmable gate array, FPGA), which allowed me to create hardware in the same way as a software system is created.  Moreover, the choice of Xilinx¬Æ FPGA gave me the opportunity to remake the system without deviating much from the original project of 1990. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The new RISC processor is implemented on an inexpensive Digilent Spartan¬Æ-3 card with a single megabyte static memory module (SRAM).  All my hardware improvements related to the mouse interface and the SD card, replacing the hard drive in the old system. <br><br>  The book and the source code of the entire system are available at <a href="http://projectoberon.com/">projectoberon.com</a> [3,4,5].  A separate <a href="">S3RISCinstall.zip</a> file is also available <a href="">there</a> .  It contains instructions, a file system image for the SD card and bit configuration files for the FPGA (in the form of PROM files for the Spartan-3 flash memory), structural parts for the hardware interface of the SD card and the mouse. <br><br>  <b>RISC processor</b> <br><br>  The processor is represented by a RISC5 Verilog module and consists of an arithmetic logic unit (ALU), an array of sixteen 32-bit registers and a control module with an IR instruction register and a PC software counter (for more <a href="http://www.inf.ethz.ch/personal/wirth/FPGA-relatedWork/RISC.pdf">details</a> see approx. Transl.). <br><br>  The processor processes 20 instructions: four for moving, shifting, and rotating;  four for logical operations;  four for integer arithmetic;  four for floating point calculations;  two for memory access and two for branching. <br><br>  RISC5 is imported from the RISC5Top context (environment) containing interfaces for various devices mapped to memory and SRAM (256 MB x 32 bits).  The whole system (Fig. 1) <div style="text-align:center;"><img src="https://habrastorage.org/files/525/62d/f1e/52562df1e5544cd092b87b8880cc2378.png" width="600" height="337"></div>  Fig.  1. System diagram with Verilog modules. <br><br>  contains the following Verilog modules (the number of lines of each module is shown): <br><table><tbody><tr><td>  RISC5Top </td><td>  environment </td><td>  194 </td></tr><tr><td>  RISC5 </td><td>  processor </td><td>  201 </td></tr><tr><td>  Multiplier </td><td>  integer arithmetic </td><td>  47 </td></tr><tr><td>  Divider </td><td></td><td>  24 </td></tr><tr><td>  FPAdder </td><td>  floating-point arithmetic </td><td>  98 </td></tr><tr><td>  FPMultiplier </td><td></td><td>  33 </td></tr><tr><td>  FPDivider </td><td></td><td>  35 </td></tr><tr><td>  SPI </td><td>  SD card and transmitter / receiver </td><td>  25 </td></tr><tr><td>  Vid </td><td>  1024 x 768 video controller </td><td>  73 </td></tr><tr><td>  PS2 </td><td>  keyboard </td><td>  25 </td></tr><tr><td>  Mouse </td><td>  mouse </td><td>  95 </td></tr><tr><td>  RS232T </td><td>  RS232 transmitter </td><td>  23 </td></tr><tr><td>  RS232R </td><td>  RS232 receiver </td><td>  25 </td></tr></tbody></table><br>  I mapped a black and white VGA display into memory so that it occupies 1024 x 768 x 1 bit per pixel = 98,304 bytes, essentially 10 percent of the total available memory of 1 megabyte.  The SD card, which replaced 80 megabytes from the original system, is accessed via a standard SPI interface that accepts and serializes bytes or 32-bit words.  The keyboard and mouse are connected via a standard PS-2 serial interface.  In addition, there are cables for serial asynchronous RS-232 and a multipurpose 8-bit parallel I / O interface.  Also, the RISC5Top module contains a millisecond counter. <br><br>  <b>Operating system Oberon</b> <br><br>  The OS software includes a kernel that includes a memory allocator with the garbage collector, a file system along with the loader, a text system, a viewer system, and a text editor. <br><br>  The module called ‚ÄúOberon‚Äù is the central task manager, and ‚ÄúSystem‚Äù is the basic command module.  The action (action) is invoked by clicking the middle mouse button on the text of the form ‚ÄúMP‚Äù in any display on the display, where P is the name of the procedure declared in module M. If M is not available, it is automatically loaded. <br>  Most text editing commands are triggered by normal mouse clicks, in which the left button serves the carriage marking the current position in the text, and the right button is responsible for selecting the text. <br><br>  The Kernel module includes disk storage (disk-store management) and a garbage collector. <br>  Viewers are tiled and do not overlap each other.  Standard markup displays two vertical tracks with an unlimited number of browsers.  You can increase or decrease them, as well as drag them for the title strip.  In fig.  Figure 2 shows the user interface on a monitor connected to a Spartan-3 board with a keyboard and mouse. <br><br><img src="https://habrastorage.org/files/510/000/f4c/510000f4c6494ec39f1419405fe4bef5.png"><br>  Fig.  2. The user interface on the monitor and the Spartan-3 at the bottom right. <br><br>  The loaded system is 112.640 bytes in the modular space (21 percent) and 16,128 bytes on the heap (3 percent).  It consists of the following modules (with the number of lines each), shown in Fig.  3: <br><table><tbody><tr><td>  Kernel </td><td>  271 (inner core) </td></tr><tr><td>  Filedir </td><td>  352 </td></tr><tr><td>  Files </td><td>  505 </td></tr><tr><td>  Modules (loader) </td><td>  226 </td></tr><tr><td>  Viewers </td><td>  216 (outer core) </td></tr><tr><td>  Texts </td><td>  532 </td></tr><tr><td>  Oberon </td><td>  411 </td></tr><tr><td>  Menuviewers </td><td>  208 </td></tr><tr><td>  Textframes </td><td>  874 </td></tr><tr><td>  System </td><td>  420 </td></tr><tr><td>  Edit </td><td>  233 </td></tr></tbody></table><br><img src="https://habrastorage.org/files/352/61e/c50/35261ec50bf74b5f8b5dac7b0a121369.png" align="left" title="Fig. 3. The system and its modules.">  It is worth noting that loading the system when it is turned on or restarted takes only 2 seconds, including scanning the file directory for garbage collection. <br><br>  <b>Oberon Compiler</b> <br><br>  The compiler is built into the system and uses a simple method of recursive downward parsing.  Compiler activation is done using the ORP.Compile @ command.  The parser receives characters from a scanner that handles identifiers, numbers, and special characters (such as BEGIN, END, +, and others).  This scheme has proven its suitability and elegance in many applications and is described in my book Compiler Construction [6,7]. <br><br>  The parser calls the procedures from the code-generation module, which directly add instructions to the code array.  Branch instructions are formed by jump addresses at the very end of the compilation, when all transition points are already known. <br><br>  All variable addresses are calculated relative to the base register.  This is R14 (stack pointer) for local variables (specified when entering the procedure in runtime), or R13 for global and imported variables.  Base addresses are loaded on request from the global module table, whose address is stored in register R12.  Register R15 is used for return addresses according to the RISC architecture.  The remaining registers, R0 - R11, are available for evaluating expressions and passing procedural parameters. <br><br>  The entire compiler consists of four relatively small and efficient modules (the number of lines of each is indicated): <br><table><tbody><tr><td>  ORP </td><td>  parser </td><td>  968 </td></tr><tr><td>  ORG </td><td>  code generator </td><td>  1120 </td></tr><tr><td>  ORB </td><td>  base def </td><td>  435 </td></tr><tr><td>  ORS </td><td>  scanner </td><td>  311 </td></tr></tbody></table><br>  The compiler occupies 115.912 bytes (22 percent) of the modular space and 17.508 bytes (4 percent) of the heap (before compilation).  Its source code is about 65 kilobytes.  Compiling the compiler itself takes only a few seconds on a 25-MHz RISC processor [8]. <br><br>  The compiler always generates checks for array indices and pointers to NIL.  This creates traps (trap, trap - approx. Transl.) In case of violation.  This technique guarantees a high level of protection against errors and damage.  In fact, the integrity of the system can be broken only by using such SYSTEM pseudo-module operations, such as PUT and COPY.  These operations should be used in a limited way, only in device driver modules and easy to find by the name SYSTEM in the import list.  The whole system is programmed on Oberon itself, without using assembly codes. <br><br>  I chose the Digilent Spartan-3 board because of its affordability and simplicity, which makes it suitable for educational institutions purchasing entire sets for classes.  The big benefit is also in the presence of static RAM on the board, which allows you to connect (interfacing) directly (and even read bytes).  Unfortunately, newer boards use dynamic RAM, which, although more capacious, is more difficult to connect, requires additional circuits for updating and initialization (calibration).  Such circuitry may be no less complex than the entire processor with static RAM.  Even if the controller is supplied on a chip, it violates our principle that everything should be available for control. <br><br>  <b>Last thoughts</b> <br><br>  More than 40 years ago, C. Hoar noted that in all branches of science and technology, students are influenced by a large number of examples of serious constructions before gaining their own experimental experience.  Programming and program design emphasize this paradigm.  Students have to write programs from the very beginning, instead of studying various samples. <br>  The reason for such a terrible situation was that there was almost no literature with qualified examples.  Therefore, I decided to rectify the situation and wrote the book Algorithms and Data Structures in 1975.  Later (together with J. Gutknecht), in the framework of teaching the course of operating systems, I designed the Oberon system (1986‚Äì88). <br>  After a while, the teaching of programming did not receive a noticeable improvement due to the fact that the systems dramatically complicated and increased in size.  Although the open course was recognized, it could not change the situation, since most of the programs are created just to start them as soon as possible, and not for a better understanding of them by man. <br>  I continue to make bold assumptions that all programs should be created not only for the computer, but also for human understanding.  They should be available.  This task is much more difficult than creating executable programs, even if they are correct and effective.  This implies that there should be no assembler inserts. <br><br>  The result of ignoring the human factor leads to the fact that everywhere there are not very carefully designed applications, brought to the working state by debugging, sometimes with grim consequences.  To achieve comprehensibility, it is worth adhering to simplicity and order, refusing unnecessary decorations and, avoiding hand bells with whistles, distinguish between conventional and suitable (conventional and convenient). <br><br>  The small size of such systems shows how small things can be achieved.  OS Oberon is ridiculously small in comparison with modern operating systems, although it includes a file system, a text editor and a window system.  A side effect is that a few simple rules are very easy to learn for future reference. <br><br>  Finally, the advantage of brevity is that it is safe to build on such a system without fear of unknown possibilities, such as back doors.  This is an essential feature that is very important for systems that are critical to security issues, given the increasing danger of attacks on the integrity of systems.  It is equally important that the hardware of our system does not contain any hidden parts.  No one can give guarantees for systems built on a foundation that is inaccessible for understanding in its entirety. <br><br>  <b>Thanks</b> <br><br>  I am very grateful to Paul Reed for his invaluable contribution.  He suggested that I edit the book ‚ÄúProject Oberon‚Äù and also offered to re-implement the entire system on FPGA.  Paul was an inexhaustible source of encouragement.  Replacing the disk with an SD card was his idea and he also provided SPI, PS-2 and VID Verilog interfaces. <br><br>  <b>Links</b> <br><br>  1. <a href="http://www.inf.ethz.ch/personal/wirth/Oberon/Oberon07.Report.pdf">www.inf.ethz.ch/personal/wirth/Oberon/Oberon07.Report.pdf</a> <br>  2. <a href="http://www.inf.ethz.ch/personal/wirth/Oberon/PIO.pdf">www.inf.ethz.ch/personal/wirth/Oberon/PIO.pdf</a> <br>  3. <a href="http://www.inf.ethz.ch/personal/wirth/ProjectOberon/index.html">www.inf.ethz.ch/personal/wirth/ProjectOberon/index.html</a> <br>  4. <a href="http://www.inf.ethz.ch/personal/wirth/Oberon/PIO.pdf">www.inf.ethz.ch/personal/wirth/Oberon/PIO.pdf</a> <br>  5. <a href="http://www.inf.ethz.ch/personal/wirth/Oberon/Oberon07.Report.pdf">www.inf.ethz.ch/personal/wirth/Oberon/Oberon07.Report.pdf</a> <br>  6. <a href="http://www.inf.ethz.ch/personal/wirth/CompilerConstruction/CompilerConstruction1.pdf">www.inf.ethz.ch/personal/wirth/CompilerConstruction/CompilerConstruction1.pdf</a> <br>  7. <a href="http://www.inf.ethz.ch/personal/wirth/CompilerConstruction/CompilerConstruction2.pdf">www.inf.ethz.ch/personal/wirth/CompilerConstruction/CompilerConstruction2.pdf</a> <br>  8. <a href="http://www.inf.ethz.ch/personal/wirth/ProjectOberon/PO.Applications.pdf">www.inf.ethz.ch/personal/wirth/ProjectOberon/PO.Applications.pdf</a> (Ch. 12) <br><br>  <b>application</b> <br><br><h1>  Lola language and its translation in Verilog </h1><br><br>  A hardware description language (HDL), called Lola, was defined in 1990 to teach the fundamentals of hardware design.  It was a time when textual definitions began to replace circuit diagrams and at the same time the first FPGAs became available, although they had not yet reached the industrial level.  For Lola, a compiler was generated that generates bit files suitable for loading into FPGA.  Bit file formats are disclosed by Algotronix, Inc.  and Concurrent Logic Inc.  Both formats made it possible to work with cells of fairly simple structures that are optimal for automatic wiring. <br><br>  As a result of my project to rework Oberon for the FPGA, the idea arose of reviving Lola as well.  Since Xilinx FPGA cells are more complex, we didn‚Äôt risk making efforts to implement placement and layout, regardless of the fact that Xilinx refused to open its patented bit-file format. <br><br>  The obvious solution was to build a Lola compiler that would not generate proprietary bit files, but would allow it to be translated into a language for which Xilinx provides a special tool.  We chose Verilog.  This solution implied a somewhat extravagant workaround: first, the Lola module must be parsed, then translated, and eventually it will be parsed again.  At all these stages, we must ensure that the Lola compiler has proper error control and type checking capabilities. <br><br>  To push the development of Lola-2, we needed to reformulate all the modules of the RISC5 processor on Lola.  What was done. <br><br>  <b>Lola language</b> <br><br>  Lola is a small, laconic language in the Oberon style (see <a href="http://www.inf.ethz.ch/personal/wirth/Lola/Lola2.pdf">www.inf.ethz.ch/personal/wirth/Lola/Lola2.pdf</a> ).  For the sake of brevity, we will show here only one example of text on Lola (Fig. 1).  The unit of source text is called a module.  Its header defines the module name, the names and types of input and output parameters.  The header is followed by a section of declarations of local objects, such as variables and registers.  Next is the section for determining the values ‚Äã‚Äãof variables and registers.  BYTE defines an array of 8 bits. <br><br><pre> MODULE Counter0 (IN CLK50M, rstIn: BIT;
	 IN swi: BYTE;  OUT leds: BYTE);

 TYPE IBUFG: = MODULE (IN I: BIT; OUT O: BIT) ^;
 Var clk, tick0, tick1: BIT;
	 clkInBuf: IBUFG;
	 REG (clk) rst: BIT;
	 cnt0: [16] BIT;  (* half milliseconds *)
	 cnt1: [10] BIT;  (* half seconds *)
	 cnt2: BYTE;

 BEGIN leds: = swi.7 -&gt; swi: swi.0 -&gt; cnt1 [9: 2]: cnt2;
	 tick0: = (cnt0 = 49999);
	 tick1: = tick0 &amp; (cnt1 = 499);
	 rst: = ~ rstIn;
	 cnt0: = ~ rst -&gt; 0: tick0 -&gt; 0: cnt0 + 1;
	 cnt1: = ~ rst -&gt; 0: tick1 -&gt; 0: cnt1 + tick0;
	 cnt2: = ~ rst -&gt; 0: cnt2 + tick1;
	 clkInBuf (CLK50M, clk)
 END Counter0.
</pre><br>  Fig.  1. The source text on Lola shows the seconds and milliseconds counter displayed on the board indicators. <br><br>  <b>Lola compiler</b> <br><br>  The compiler uses a simple method of recursive downward parsing.  It is activated on the selected Lola source code with the LSC.Compile @ command.  The parser receives characters from a scanner that handles identifiers, numbers, and special characters (such as BEGIN, END, +, and others).  This scheme has proven its suitability and elegance in many applications and is described in the book Compiler Construction (Part 1 and 2). <br><br>  Instead of generating Verilog texts on the fly, the parser first creates a tree of operators, which is more suitable for further processing.  This approach has the advantage that any required output can be easily generated by a suitable translator.  One of these is the translator in Verilog.  The first LSV.List command is outputfile.v.  Another team can translate to VHDL or simply display a tree.  The third can generate a netlist for further processing by the razvodchik. <br><br>  Thus, the entire compiler consists of at least four relatively small and efficient modules: <br><table><tbody><tr><td>  Lss </td><td>  scanner </td><td>  159 </td></tr><tr><td>  LSB </td><td>  base </td><td>  52 </td></tr><tr><td>  Lsc </td><td>  compiler / parser </td><td>  503 </td></tr><tr><td>  LSV </td><td>  Verilog generator </td><td>  215 </td></tr></tbody></table><br>  Transaction instructions from Lola to Verilog can be found here: <a href="http://www.inf.ethz.ch/personal/wirth/Lola/LolaCompiler.pdf">www.inf.ethz.ch/personal/wirth/Lola/LolaCompiler.pdf</a> . <br><br>  <b>Differences between software and hardware "programs"</b> <br><br>  Many efforts have been made in the past to make HDL languages ‚Äã‚Äãlook like ‚Äúnormal‚Äù programming languages.  In addition, HDL have "twins" among other PL, adapting to their style.  For example, Verilog is derived from C, VHDL from Ada, and Lola from Oberon.  But we believe that it is important to see the fundamental differences between these two classes, in particular, in the presence of syntactic similarities, or even identities.  What are these fundamental differences? <br><br>  To simplify the explanation, we will limit our analysis to synchronous circuits ‚Äî that is, those in which all registers are tied to one clock generator.  In general, synchronous schemes are a good architectural paradigm, which should be followed, if possible. <br><br>  Further, it is abundantly clear that all elements of the scheme work simultaneously, literally at the same time.  Each variable and each register are determined by one and only one expression (combinational circuit).  Multiple assignments are meaningless.  We can easily imagine each HDL program to be enclosed in a large infinite loop, since assignments to registers and variables occur every cycle. <br><br>  The idea of ‚Äã‚ÄãJohn von Neumann to present a processor architecture based on a sequencer (sequencer) was ingenious.  The sequencer contains a register of instructions, according to which certain patterns are selected and the others are ignored in each measure, which leads to skillful reuse of various parts of the ALU.  Tacts or steps are consistent in nature, so it is possible to reassign values ‚Äã‚Äãto variables according to how the program counter relates them to specific places in the program and in the sequence of instructions.  The idea of ‚Äã‚Äãthe sequencer made it possible to run huge programs on relatively simple circuits. <br><br>  So, Lola-2 is the HDL in the style of Yap Oberon.  The compiler presented here translates Lola modules into Verilog modules.  The advantages of Lola are both in the simple and familiar structure of the language, and in emphasizing the compiler for type checking and advanced error diagnostics.  A complete set of modules for the RISC processor, described on Lola: <a href="http://www.inf.ethz.ch/personal/wirth/Lola/index.html">www.inf.ethz.ch/personal/wirth/Lola/index.html</a> <br></div><p>Source: <a href="https://habr.com/ru/post/259755/">https://habr.com/ru/post/259755/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259737/index.html">Common Lisp IDE</a></li>
<li><a href="../259739/index.html">The digest of interesting materials for the mobile developer # 106 (June 1-7)</a></li>
<li><a href="../259745/index.html">Google expands its data centers in Asia</a></li>
<li><a href="../259747/index.html">Flickr Image Gallery with Shortcode API</a></li>
<li><a href="../259749/index.html">Installing vmware tools for debian 8 in a virtual machine [manual]</a></li>
<li><a href="../259761/index.html">The device of the game engine for NES on the example of the games "Capcom"</a></li>
<li><a href="../259763/index.html">Confusion with job titles</a></li>
<li><a href="../259765/index.html">Views on Zend PHP Certification</a></li>
<li><a href="../259767/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ163 (June 1 - 7, 2015)</a></li>
<li><a href="../259771/index.html">As I was increasing machine learning conversion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>