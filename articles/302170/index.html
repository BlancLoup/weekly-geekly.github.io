<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stack Trace in C ++ or cycling, level ‚ÄúBydlokod‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="DISCLAMER 
 The article is comic, but with some truth (programming, the same). This article also contains a code that can be fatal to your vision. Rea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stack Trace in C ++ or cycling, level ‚ÄúBydlokod‚Äù</h1><div class="post__text post__text-html js-mediator-article"><h4>  DISCLAMER </h4><br>  The article is comic, but with some truth (programming, the same).  This article also contains a code that can be fatal to your vision.  Read at your risk. <br><br><h4>  Introduction </h4><br>  Hello.  I think many are faced with the lack of information of the majority of critical errors flying in the program.  Let's list what situations can lead to the crash of the program: <br><a name="habracut"></a><br><h5>  An exception </h5><br>  Exceptions are a very powerful system for handling exceptional situations that arise in a program.  But if the exception was not processed, then it drops the program through std :: terminate.  Therefore, in well-written programs, the exception that was not handled often means a bug in the program that needs to be fixed. <br><br>  This type of error is the most informative, since the exception method what () is output to stderr automatically when the program crashes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Assert </h5><br>  Disabled method for checking the correct use of functions.  Disabling is provided as a tool to increase performance in functions in which every nanosecond is counted.  If the program has fallen on the assert, then the programmer has nakosyachil somewhere when using the interface of a module.  But it is quite possible that he simply did not foresee any critical values ‚Äã‚Äãand for this reason he left the conditions of the assert. <br><br>  This type of error is not the most informative, but when it falls, it displays a condition that was violated. <br><br><h5>  SIGSEGV </h5><br>  You, as a professional in your own business, deposed a null pointer and happily wrote some value into it.  The program is not particularly resisting fell. <br><br>  Such a fall is not accompanied by any messages and is probably the most non-informative and presented, but it is and cannot be ruled out in any way. <br><br>  All kinds of errors, regardless of their informativeness, do not really help determine for what reason it appeared.  In the framework of this article, I will try to show that I got in a rush to get at least some kind of stack trace during error trapping. <br><br><h4>  We look around </h4><br>  First you need to understand how to track function calls in general.  Google gave extremely disappointing results.  Obviously, there is no cross-platform solution.  Under Linux and Mac OS there is a header file execinfo.h with which you can get a linked list of the call stack.  Under Windows, there is a WinAPI CaptureStackBackTrace function that allows you to walk along the stack and receive calls from frames.  But we will go through C ++.  We will not use platform-specific functions. <br><br>  The data will be stored in a normal stack.  For pushing and pushing functions, we will use the object that will be created during the function call.  The advantages of this approach are that even if an exception is thrown, this object will be deleted. <br><br>  And what exactly do we need data?  Well for beauty, of course, it would not be bad to have a file, a string, and a function name.  It would also be a good idea to have the arguments of this function, so that you can concretize the called function during an overload. <br><br>  But which interface to use?  How to write more or less beautiful code and at the same time get the required functionality. <br>  The only solution that I could find was macros (maybe it‚Äôs also possible to somehow implement it through templates, but I know the surface very superficially and therefore I do as I can). <br><br><h4>  Implementation </h4><br>  To begin with, we implement a singleton that will be used to work with the stack.  As the user interface, we implement only the method for getting the string representation of the trace trace. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackTracer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallHolder</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> StackTracer&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackTracer s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStackTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ss; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> iterator = m_data.begin(), end = m_data.end(); iterator != end; ++iterator) ss &lt;&lt; iterator-&gt;file &lt;&lt; <span class="hljs-string"><span class="hljs-string">':'</span></span> &lt;&lt; iterator-&gt;line &lt;&lt; <span class="hljs-string"><span class="hljs-string">" -&gt; "</span></span> &lt;&lt; iterator-&gt;name &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ss.str(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line)</span></span></span><span class="hljs-function"> </span></span>{ m_data.push_front({name, file, line}); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_data.pop_front(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *file; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> line; }; StackTracer() : m_data() {} <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;CallData&gt; m_data; };</code> </pre> <br>  There is no way to use std :: stack, because in order to get all the elements for output, you would have to copy the entire container. <br><br>  Of the problems of this class is complete streaming insecurity.  But we will deal with this later, and now PoC. <br><br>  Now we will implement a class that will register and delete a function call. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CallHolder(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;name, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *file, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> line) { StackTracer::i().push(name, file, line); } ~CallHolder() { StackTracer::i().pop(); } };</code> </pre><br>  Pretty nontrivial code right?  Again, this ‚Äúregistrar‚Äù does not take into account multithreading. <br><br>  Now we will try to throw a small example in order to check the performance of such a Frankenstein. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CallHolder __f(<span class="hljs-string"><span class="hljs-string">"func2()"</span></span>, __FILE__, __LINE__); func1(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CallHolder __f(<span class="hljs-string"><span class="hljs-string">"func1()"</span></span>, __FILE__, __LINE__); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i-- == <span class="hljs-number"><span class="hljs-number">1</span></span>) func2(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; StackTracer::i().getStackTrace() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ func1(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Result: <br><br><img src="https://habrastorage.org/files/b57/a4e/07e/b57a4e07ef36407fa3cc29527c6e73da"><br>  <i>Figure 3.1 - ‚ÄúIt is alive !!‚Äù</i> <br><br>  Fine!  But it is necessary to somehow pack a call to CallHolder, otherwise it‚Äôs not beautiful to somehow get the pens to call and prescribe the name of the method twice. <br><br>  For the implementations of functions and methods, this is the macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEM_IMPL(func_name, args)\ func_name args\ {\ CallHolder __f(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> #func_name #args </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, __FILE__, __LINE__);</span></span></code> </pre><br>  Now our Frankenstein can be modified and get something like this.  Already more like the "normal" code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func2, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func1, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i </span></span>= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i-- == <span class="hljs-number"><span class="hljs-number">1</span></span>) func2(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; StackTracer::i().getStackTrace() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ func1(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The result of the execution is exactly the same as before.  But there is a clear problem with this approach.  The opening brace that the macro hides disappears.  This makes it difficult to read the code.  Although people who adhere to the ideology with the opening brace in the string with the title will not consider it a strong minus.  A stronger disadvantage is that the development environment, which I use, does not know how to work with such quirky cases and considers only braces outside of macros. <br><br>  But we digress from our orgy.  What to do if we have a class?  Well, if the implementation is outside the class - then nothing.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func2, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func1, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i </span></span>= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i-- == <span class="hljs-number"><span class="hljs-number">1</span></span>) func2(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; StackTracer::i().getStackTrace() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpicClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EpicClass::someFunc, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ EpicClass a; a.someFunc(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Result: <br><br><img src="https://habrastorage.org/files/1b0/dfb/a11/1b0dfba11de545c6b87c5dfe086ed2d0"><br>  <i>Figure 3.2 - Output from the class</i> <br><br>  And what if you write the implementation directly in the class declaration?  Then another macro is required: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CLASS_IMPL(class_name, func_name, args)\ func_name args\ {\ CallHolder __f(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> #class_name </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"::"</span></span></span><span class="hljs-meta"> #func_name </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, __FILE__, __LINE__);</span></span></code> </pre><br>  But this approach has a problem.  It is necessary to separately indicate the name of the class, which is not very good.  This can be skipped if we use C ++ 11.  I use the solution found on stack overflow.  This is type_name &lt;decltype (i)&gt; ().  Where type_name is <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include &lt;typeinfo&gt; #ifndef _MSC_VER # include &lt;cxxabi.h&gt; #endif #include &lt;memory&gt; #include &lt;string&gt; #include &lt;cstdlib&gt; template &lt;class T&gt; std::string type_name() { typedef typename std::remove_reference&lt;T&gt;::type TR; std::unique_ptr&lt;char, void(*)(void*)&gt; own ( #ifndef _MSC_VER abi::__cxa_demangle(typeid(TR).name(), nullptr, nullptr, nullptr), #else nullptr, #endif std::free ); std::string r = own != nullptr ? own.get() : typeid(TR).name(); // if (std::is_const&lt;TR&gt;::value) // r += " const"; // if (std::is_volatile&lt;TR&gt;::value) // r += " volatile"; // if (std::is_lvalue_reference&lt;T&gt;::value) // r += "&amp;"; // else if (std::is_rvalue_reference&lt;T&gt;::value) // r += "&amp;&amp;"; return r; }</span></span></span></span></code> </pre><br>  The part with modifiers is commented out for the reason that the result of processing (* this) will then at the end have a reference sign ‚Äî an ampersand (&amp;). <br><br>  A smart macro looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CLASS_IMPL(func_name, args)\ func_name args\ {\ CallHolder __f(type_name</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;decltype(*this)&gt;() + "::" + #func_name + #args, __FILE__, __LINE__);</span></span></span></span></code> </pre><br>  Let's edit our franc and look at the result: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func2, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func1, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i </span></span>= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i-- == <span class="hljs-number"><span class="hljs-number">1</span></span>) func2(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; StackTracer::i().getStackTrace() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpicClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CLASS_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(insideFunc, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EpicClass::someFunc, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ EpicClass a; <span class="hljs-comment"><span class="hljs-comment">// a.someFunc(); a.insideFunc(); return 0; }</span></span></code> </pre><br>  Result: <br><br><img src="https://habrastorage.org/files/fde/981/904/fde98190438c4e339e397e61e083d60a"><br>  <i>Figure 3.3 - The class method declared internally</i> <br><br>  Well, but what about the informative?  How can you get at least some useful information in the fall.  After all, now with the occurrence of the same Seg Fault, everything will just fall.  Well, first of all, we implement our int main, which will catch errors.  In the title we announce: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span></span>;</code> </pre><br>  In cpp, we implement our ‚Äúsafe‚Äù main, which will already call safe_main. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> signum)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Death signal has been taken. Stack trace:"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; StackTracer::i().getStackTrace() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; signal(signum, SIG_DFL); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(main, (</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argv[]))</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SIGSEGV, signal_handler)</span></span></span></span>; signal(SIGTERM, signal_handler); signal(SIGABRT, signal_handler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> safe_main(argc, argv); }</code> </pre><br>  I think it is worth explaining.  With the signal function, we set a handler that will be called when SIGSEGV, SIGTERM and SIGABRT signals appear.  In which will already be displayed in stderr stack trace.  (The latter is required for assert). <br><br>  Let's try to break the program SIGSEGV.  Again we change our "test stand": <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func2, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func1, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i </span></span>= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i-- == <span class="hljs-number"><span class="hljs-number">1</span></span>) func2(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; (*i) = <span class="hljs-number"><span class="hljs-number">12</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EpicClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CLASS_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(insideFunc, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EpicClass::someFunc, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(safe_main, (</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[]))</span></span></span><span class="hljs-function"> EpicClass a</span></span>; <span class="hljs-comment"><span class="hljs-comment">// a.someFunc(); a.insideFunc(); return 0; }</span></span></code> </pre><br>  Result: <br><br><img src="https://habrastorage.org/files/430/c85/3dc/430c853dce064da69f45290d584812b3"><br>  <i>Figure 3.4 - Work safe main</i> <br><br>  But what about the exceptions?  After all, if you throw an exception, it will simply destroy all the existing CallHolder and in the stack trace we will not get anything thorough.  To do this, we create our own THROW macro, which would receive the stack trace when an exception was thrown: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> THROW(exception, explanation)\ throw exception(explanation + std::string(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n\rStack trace:\n\r"</span></span></span><span class="hljs-meta">) + StackTracer::i().getStackTrace());</span></span></code> </pre><br>  We also modify our test bench a bit: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func2, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func1, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i </span></span>= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i-- == <span class="hljs-number"><span class="hljs-number">1</span></span>) func2(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// int *i = nullptr; // (*i) = 12; THROW(std::runtime_error, "Some cool error"); } } class EpicClass { public: void someFunc(); void CLASS_IMPL(insideFunc, ()) func1(); } }; void MEM_IMPL(EpicClass::someFunc, ()) func1(); } int MEM_IMPL(safe_main, (int argc, char *argv[])) EpicClass a; // a.someFunc(); a.insideFunc(); return 0; }</span></span></code> </pre><br>  And we get the result: <br><br><img src="https://habrastorage.org/files/3bb/5da/88e/3bb5da88e69b4efa99ebef9bc629acd4"><br>  <i>Figure 3.5 - THROW does not forgive</i> <br><br>  Good.  We have achieved full basic functionality, but what about multithreading?  Will we do something with her? <br>  Well, at least try! <br><br>  To begin, edit StackTracer so that it starts working with different streams: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackTracer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallHolder</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> StackTracer&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackTracer s; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStackTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ss; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; guard(m_readMutex); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> mapIterator = m_data.begin(), mapEnd = m_data.end(); mapIterator != mapEnd; ++mapIterator) { ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Thread: 0x"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::hex &lt;&lt; mapIterator-&gt;first &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::dec &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> listIterator = mapIterator-&gt;second.begin(), listEnd = mapIterator-&gt;second.end(); listIterator != listEnd; ++listIterator) ss &lt;&lt; listIterator-&gt;file &lt;&lt; <span class="hljs-string"><span class="hljs-string">':'</span></span> &lt;&lt; listIterator-&gt;line &lt;&lt; <span class="hljs-string"><span class="hljs-string">" -&gt; "</span></span> &lt;&lt; listIterator-&gt;name &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; ss &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ss.str(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::thread::id thread_id)</span></span></span><span class="hljs-function"> </span></span>{ m_data[thread_id].push_front({name, file, line}); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::thread::id thread_id)</span></span></span><span class="hljs-function"> </span></span>{ m_data[thread_id].pop_front(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *file; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> line; }; StackTracer() : m_data() {} <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m_readMutex; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;CallData&gt; &gt; m_data; };</code> </pre><br>  Similarly, we change the CallHolder so that the thread_id is passed to it: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CallHolder(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;name, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *file, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> line, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id thread_id) { StackTracer::i().push(name, file, line, thread_id); m_id = thread_id; } ~CallHolder() { StackTracer::i().pop(m_id); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::id m_id; };</code> </pre><br>  Well, we modify some macros: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CLASS_IMPL(func_name, args)\ func_name args\ {\ CallHolder __f(type_name</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;decltype(*this)&gt;() + "::" + #func_name + #args, __FILE__, __LINE__, std::this_thread::get_id()); #define MEM_IMPL(func_name, args)\ func_name args\ {\ CallHolder __f("" #func_name #args "", __FILE__, __LINE__, std::this_thread::get_id());</span></span></span></span></code> </pre><br><br>  We are testing.  Let's prepare such a ‚Äústand‚Äù: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sleepy, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::this_thread::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep_for</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::chrono::seconds(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; THROW(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::runtime_error, <span class="hljs-string"><span class="hljs-string">"Thread exception"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(thread_func, ())</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleepy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MEM_IMPL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(safe_main, (</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[]))</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">std</span></span></span><span class="hljs-function">::thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">th</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;thread_func)</span></span></span></span>; th.detach(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::this_thread::sleep_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">20</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  And try to run: <br><br><img src="https://habrastorage.org/files/bbe/123/d64/bbe123d6481e483e8b51604c89b2d8e8"><br>  <i>Figure 3.6 - Death occurred at 1:10 Moscow time</i> <br><br>  So we got a multithreaded stack trace.  The experiment is over, the test subject is dead.  From the obvious problems of this implementation <br><ul><li>  We cannot receive calls from libraries not written by us; </li><li>  Additional overhead for each function call. </li></ul><br><h4>  Conclusion </h4><br>  Unfortunately, without a serious compiler support, it is extremely difficult to implement the debug stack trace and you have to use crutches.  But in any case, thanks for reading this article. </div><p>Source: <a href="https://habr.com/ru/post/302170/">https://habr.com/ru/post/302170/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302158/index.html">War of Delays: Why is low delay so important?</a></li>
<li><a href="../302160/index.html">Why PostgreSQL is better than other open source SQL databases. Part 2</a></li>
<li><a href="../302162/index.html">How to help the forces of good fight spam or DMARC on your server</a></li>
<li><a href="../302164/index.html">Measurement collection system using a weather station</a></li>
<li><a href="../302168/index.html">Pivoting or port forwarding</a></li>
<li><a href="../302172/index.html">Hosting provider RUVDS joins ISIC student discount program partners</a></li>
<li><a href="../302174/index.html">Cloud computing economics</a></li>
<li><a href="../302176/index.html">FileChangesWatcher</a></li>
<li><a href="../302178/index.html">Fiery number system, or why 1 + 10 = 100</a></li>
<li><a href="../302180/index.html">Introduction to the DLMS / COSEM stack for the MS Instruments MSP430 family of Texas Instruments</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>