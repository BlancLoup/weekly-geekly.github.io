<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exploring Hyper-V internal mechanisms: Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since the publication of the first part of the article, nothing has changed globally in the world: the Earth has not hit the celestial axis, the popul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exploring Hyper-V internal mechanisms: Part 2</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/91f/49b/495/91f49b4951554c6f90573c19ad580bc3.jpg"><br><br>  Since the publication of the first part of the article, nothing has changed globally in the world: the Earth has not hit the celestial axis, the popularity of cloud services is still growing, still no new holes were found in the Microsoft hypervisor, and researchers don‚Äôt want to spend their time searching bugs in poorly documented and little studied technology.  Therefore, I suggest you refresh your memory with the first part of the previous number, replenish your bar‚Äôs stock and start reading, because today we‚Äôll make a driver interacting with the hypervisor interface and tracking messages sent by the hypervisor, as well as examine the operation of the components of Data Exchange Integration Services. <br><a name="habracut"></a><br><br><h3>  Hypervisor Message Processing </h3>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On <a href="http://dvd.xakep.ru/190/">dvd.xakep.ru</a> we have laid out a driver written using Visual Studio 2013. It should be loaded into the root of the OS, for example using OSRLoader.  To send IOCTL codes, use a simple program SendIOCTL.exe.  After sending the INTERRUPT_CODE IOCTL code, the driver starts processing the data transmitted by the hypervisor through the null SIM slot.  Unfortunately, the HvlpInterruptCallback variable, which contains the address of the array with message handler pointers, is not exported by the kernel, so to find it, you need to analyze the code of the HvlRegisterInterruptCallback function that contains the address of the array that we export.  Also, unfortunately, it will not be possible to simply call HvlRegisterInterruptCallback to register your message handler, since at the very beginning of the function there is a check of the value of the HvlpFlags variable.  If the variable is equal to 1 (and this value is assigned to it at the initial stages of kernel loading), the function stops execution, returns error code 0xC00000BB (STATUS_NOT_SUPPORTED) and, accordingly, the handler registration does not occur, therefore you will have to write your own version of the HvlpInterruptCallback function to replace the handlers.  In the hyperv4 driver, the necessary actions are performed by the RegisterInterrupt function: <br><br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ UNICODE_STRING uniName; PVOID pvHvlRegisterAddress = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; PHYSICAL_ADDRESS pAdr = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; ULONG i,ProcessorCount; <span class="hljs-comment"><span class="hljs-comment">//      ProcessorCount = KeQueryActiveProcessorCount(NULL); //      HvlRegisterInterruptCallback DbgLog("Active processor count",ProcessorCount); RtlInitUnicodeString(&amp;uniName,L"HvlRegisterInterruptCallback"); pvHvlRegisterAddress = MmGetSystemRoutineAddress(&amp;uniName); if (pvHvlRegisterAddress == NULL){ DbgPrintString("Cannot find HvlRegisterInterruptCallback!"); return 0; } DbgLog16("HvlRegisterInterruptCallback address ",pvHvlRegisterAddress); //     HvlpInterruptCallback, FindHvlpInterruptCallback((unsigned char *)pvHvlRegisterAddress); //       ArchmHvlRegisterInterruptCallback((uintptr_t)&amp;ArchmWinHvOnInterrupt,(uintptr_t)pvHvlpInterruptCallbackOrig,WIN_HV_ON_INTERRUP_INDEX); ArchmHvlRegisterInterruptCallback((uintptr_t)&amp;ArchXPartEnlightenedIsr,(uintptr_t)pvHvlpInterruptCallbackOrig,XPART_ENLIGHTENED_ISR0_INDEX); ArchmHvlRegisterInterruptCallback((uintptr_t)&amp;ArchXPartEnlightenedIsr,(uintptr_t)pvHvlpInterruptCallbackOrig,XPART_ENLIGHTENED_ISR1_INDEX); ArchmHvlRegisterInterruptCallback((uintptr_t)&amp;ArchXPartEnlightenedIsr,(uintptr_t)pvHvlpInterruptCallbackOrig,XPART_ENLIGHTENED_ISR2_INDEX); ArchmHvlRegisterInterruptCallback((uintptr_t)&amp;ArchXPartEnlightenedIsr,(uintptr_t)pvHvlpInterruptCallbackOrig,XPART_ENLIGHTENED_ISR3_INDEX); //    SIMP    ,       SIM</span></span></code> </pre> <br><br><blockquote><h3>  WARNING </h3><br>  During experiments related to the intensive work of virtual machines, it is better to replace one handler in the HvlpInterruptCallback array, since replacing all immediately leads to unstable system operation (at least, with a large flow of debug messages through KdPrint and WPP). <br><br></blockquote><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      ,     Mm MapIoSpace,             for (i = 0; i &lt; ProcessorCount; i++) {KeSetSystemAffinityThreadEx(1i64 &lt;&lt; i); DbgLog("Current processor number",KeGetCurrentProcessorNumberEx(NULL)); pAdr.QuadPart = ArchReadMsr (HV_X64_MSR_SIMP) &amp; 0xFFFFFFFFFFFFF000; pvSIMP[i] = MmMapIoSpace (pAdr, PAGE_SIZE, MmCached); if (pvSIMP[i] == NULL){ DbgPrintString("Error during pvSIMP MmMapIoSpace"); return 1; } DbgLog16("pvSIMP[i] address", pvSIMP[i]); pAdr.QuadPart = ArchReadMsr (HV_X64_MSR_SIEFP) &amp; 0xFFFFFFFFFFFFF000; pvSIEFP[i] = MmMapIoSpace(pAdr, PAGE_SIZE, MmCached); if (pvSIEFP[i] == NULL){DbgPrintString("Error during pvSIEFP MmMapIoSpace"); return 1; } DbgLog16("pvSIEFP address", pvSIEFP[i]); } return 0; }</span></span></code> </pre><br><br><img src="//habrastorage.org/files/72b/ad0/d5a/72bad0d5a5aa4c84a1067bf3182c9e19.png"><br>  Fig.  1. HvlpInterruptCallback array with modified handlers <br><br>  The array HvlpInterruptCallback after the execution of the RegisterInterrupt function (if all the handlers are replaced at the same time) looks like this (see Figure 1).  The replacement is done in the same way as the original code: one handler for hypervisor messages and four for processing messages from VMBus.  The ArchmWinHvOnInterrupt and ArchXPartEnlightenedIsr procedures save all registers on the stack and transfer control to the parsing functions of ParseHvMessage and ParseVmbusMessage messages, respectively (mPUSHAD and mPOPAD are macros that save registers on the stack) (see Figure 2). <br><br><br><img src="//habrastorage.org/files/3a5/d64/003/3a5d64003aeb4aed982b91714eb41fc0.png"><br>  Fig.  2. ArchmWinHvOnInterrupt and ArchXPartEnlightenedIsr <br><br>  After parsing, control is transferred to the original WinHvOnInterrupt and XPartEnlightenedIsr procedures.  The function of parsing messages hypervisor looks like this: <br><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseHvMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ PHV_MESSAGE phvMessage, phvMessage1; <span class="hljs-comment"><span class="hljs-comment">//      ULONG uCurProcNum = KeGetCurrentProcessorNumberEx(NULL); Unlock+0x162 vmbkmcl!VmbChannelEnable+0x231 vmbus!PipeStartChannel+0x9e vmbus!PipeAccept+0x81 vmbus!InstanceCreate+0x90 .................................. nt!IopParseDevice+0x7b3 nt!ObpLookupObjectName+0x6d8 nt!ObOpenObjectByName+0x1e3 nt!IopCreateFile+0x372 nt!NtCreateFile+0x78 nt!KiSystemServiceCopyEnd+0x13 ntdll!NtCreateFile+0xa KERNELBASE!CreateFileInternal+0x30a KERNELBASE!CreateFileW+0x66 vmbuspipe!VmbusPipeClientOpenChannel+0x44 icsvc!ICTransportVMBus::ClientNotification+0x60 vmbuspipe!VmbusPipeClientEnumeratePipes+0x1ac icsvc!ICTransportVMBusClient::Open+0xe5 icsvc!ICEndpoint::Connect+0x66 icsvc!ICChild::Run+0x65 icsvc!ICKvpExchangeChild::Run+0x189 icsvc!ICChild::ICServiceWork+0x137 icsvc!ICChild::ICServiceMain+0x8f ..................................</span></span></code> </pre><br><br>  The Data Exchange component is activated on the virtual machine. After activating the Data Exchange component in the properties of the virtual machine and clicking the Apply root button of the OS, the HvPostMessage sends the guest OS a message with the code CHANNELMSG_OFFERCHANNEL (see Figure 9).  The transmitted data contains the GUID of the device that is a child of the VMBUS (see Figure 10).  The guest OS then processes the data and calls the vmbus! InstanceDeviceControl function. <br><br><br><img src="//habrastorage.org/files/63c/027/775/63c0277757064dfd946078944fdb9283.png"><br>  Fig.  9. Device GUID in the message <br><br><img src="//habrastorage.org/files/ead/bc8/084/eadbc80842da4629beff443856c9266d.png"><br>  Fig.  10. Conclusion! Devnode for a VMBus device <br><br>  Part of the stack: <br><br><br><pre> <code class="cpp hljs">WINDBG&gt;k Call Sitent!IoAllocateMdl vmbus!InstanceCloseChannel+<span class="hljs-number"><span class="hljs-number">0x22d</span></span> (   ,     ) vmbus!InstanceDeviceControl+<span class="hljs-number"><span class="hljs-number">0x118</span></span> .................................. vmbkmcl!KmclpSynchronousIoControl+<span class="hljs-number"><span class="hljs-number">0xa7</span></span> vmbkmcl!KmclpClientOpenChannel+<span class="hljs-number"><span class="hljs-number">0x2a6</span></span> vmbkmcl!<span class="hljs-function"><span class="hljs-function">KmclpClientFindVmbusAnd </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pvSIMP[uCurProcNum] != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ phvMessage = (PHV_MESSAGE)pvSIMP[uCurProcNum]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ DbgPrintString(<span class="hljs-string"><span class="hljs-string">"pvSIMP is NULL"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//      1-  SIM phvMessage1 = (PHV_MESSAGE)((PUINT8)pvSIMP[uCurProcNum]+ HV_MESSAGE_SIZE); // for SINT1 if (phvMessage1-&gt;Header.MessageType != 0){ DbgPrintString("SINT1 interrupt"); } //         //        TLFS switch (phvMessage-&gt;Header.MessageType) { case HvMessageTypeX64IoPortIntercept: PrintIoPortInterceptMessage(phvMessage); break; case HvMessageTypeNone:DbgPrintString("HvMessageTypeNone"); break; case HvMessageTypeX64MsrIntercept:PrintMsrInterceptMessage(phvMessage); break; case HvMessageTypeX64CpuidIntercept:PrintCpuidInterceptMessage(phvMessage); break; case HvMessageTypeX64ExceptionIntercept:PrintExceptionInterceptMessage(phvMessage); break; default: DbgLog("Unknown MessageType", phvMessage-&gt; Header.MessageType); break; } }</span></span></code> </pre><br><br>  The function obtains the number of the active logical processor, the address of the SIM page and reads the value of the zero SIM slot.  First, an analysis of the type of message phvMessage-&gt; Header.MessageType is performed, since the message body is different for each type.  You can see the following picture in DbgView (see fig. 3). <br><br><img src="//habrastorage.org/files/6dc/a0e/274/6dca0e27460d4c578ba91b8f9a9d3f12.png"><br>  Fig.  3. DbgView output when the hypervisor processes MSR registers <br><br><img src="//habrastorage.org/files/4f3/423/2aa/4f34232aa04d431dbb3f3a8ef6999c8e.png"><br>  ParseVmbusMessage function (Fig. 4). <br><br>  The function obtains the number of the active logical processor, the address of the SIM page and reads the value of the fourth SIM slot.  For example, the CHANNELMSG_OPENCHANNEL and CHANNELMSG_GPADL_HEADER messages are parsed, but in the LIS source codes you can see the format of all message types and easily add the necessary handlers.  Messages for the VMBus bus are usually generated when you turn on / off a virtual machine or one of the components of Integration Services.  For example, if you turn on the Data Exchange component, the debugger or DbgView will show the information shown in Figure 2.  five. <br><br><img src="//habrastorage.org/files/3ac/46a/d40/3ac46ad4041b4d48b2a4cbc915befac9.png"><br>  Fig.  5. Debug output when the Data Exchange component is enabled. <br><br><h3>  Integration Services - Data Exchange </h3><br>  Next, we consider how data is exchanged between the guest and the root OS for the example of one of the components of the integration services - Data Exchange.  This component allows root OS to read data from a specific branch of the guest OS registry.  To check in the guest OS, create in the HKEY_LOCAL_MACHINE \\ SOFTWARE \\ Microsoft \ Virtual Machine \ Guest branch a key with the KvPDataValue value (see Figure 6). <br><br><br><img src="//habrastorage.org/files/aea/9ae/7b4/aea9ae7b4653466c96186e3525557dbf.png"><br>  Fig.  6. KvPDataValue Key <br><br>  The following PowerShell script was used to obtain the key value in the OS root (see Figure 7). <br><br><img src="//habrastorage.org/files/fc9/f16/d7b/fc9f16d7bea944fead30686575ed8628.png"><br>  Fig.  7. PowerShell script to query registry values ‚Äã‚Äãfrom guest OS <br><br>  The script will return the value of the KvPDataKey key (see Figure 8).  The script gets the entire available set of values ‚Äã‚Äãusing $ vm.GetRelated ("Msvm_KvpExchangeComponent"). GuestExchangeItems and only after that it parses each received object to find the KvPDataKey key.  Accordingly, the script will work only if nt! IoAllocateMdl with the size of the allocated buffer 0xC000 is called in the properties of this function.  The result of the function is a formed MDL structure (see Fig. 11).  Next, nt! MmProbeAndLockPages is called, after the completion of which the MDL structure is supplemented with PFN elements (see Fig. 12).  In this example, a contiguous area of ‚Äã‚Äãphysical memory was allocated, although this condition is optional.  Next, vmbus! ChCreateGpadlFromNtmdl is called (the second parameter is the address of the MDL), which calls vmbus! ChpCreateGpaRanges, passing all the same MDL as the first parameter.  Next, the PFN elements are copied from the MDL structure to a separate buffer (see Fig. 13), which will become the body of the CHANNELMSG_GPADL_HEADER message sent by the guest OS to the root OS by calling vmbus! ChSendMessage.  hv! HvPostMessage or in winhv! WinHvPostMessage you can see the message (Figure 14). <br><br><img src="//habrastorage.org/files/219/9c0/344/2199c03440a24838be89d34e7e393734.png"><br>  Fig.  8. Script Execution Result <br><br><img src="//habrastorage.org/files/c8d/5b6/1de/c8d5b61de32344b580bfe7f84ee3d005.png"><br>  Fig.  11. Value of MDL structure <br><br><img src="//habrastorage.org/files/bad/b3d/e58/badb3de58f184f97ad2b27879e56e246.png"><br>  Fig.  12. PFN in MDL structure <br><br><img src="//habrastorage.org/files/c42/4c2/787/c424c2787ff34f41a5d845c47331d2cf.png"><br>  Fig.  13. Plot of code responsible for copying PFN to separate buffer <br><br><img src="//habrastorage.org/files/c25/75b/31a/c2575b31ab3e4ac491c1ecc85327bd00.png"><br>  Fig.  14. PFN Array Processed by the Hypervisor <br><br>  The first 16 bytes is the general header of the message, where, for example, 0xF0 is the size of the message body, a VMBus-package is placed inside, the header of which contains the packet type - 8 (CHANNELMSG_GPADL_HEADER), rangecount is 1, which means that one packet contained all the data that was needed to transfer.  In the case of a large amount of data, the guest OS driver would divide them into parts and send them in separate messages.  Then the root OS sends the message CHANNELMSG_OPENCHANNEL_RESULT, then the guest OS sends CHANNELMSG_OPENCHANNEL.  After that, the root OS executes the WorkItem procedure.  (see fig. 15). <br><br><br><img src="//habrastorage.org/files/4dd/243/a97/4dd243a97cb04e438b95bcfceb4efa3b.png"><br>  Fig.  15. Calling ChMapGpadlView <br><br>  During its execution, vmbusr! ChMapGpadlView-&gt; vmbusr! PkParseGpaRanges is called, which, in turn, receives a pointer to the message part containing the buffer size 0xC000 and PFN, sent in the CHANNELMSG_GPADL_HEADER message.  Next, vmbusr! XPartLockChildPagesSynchronous-&gt; vmbusr! XPartLockChildPages is called, after which the function is executed from the vid.sys driver (function name is unknown, since there are no characters for the driver), which is passed as a second parameter to the PFN block sent earlier in the message from the guest OS ( see figure 16). <br><br><br><img src="//habrastorage.org/files/f2b/18a/9cf/f2b18a9cf13e401d9e32584c8383881b.png"><br>  Fig.  16. Processing guest PFN with vid.sys driver <br><br>  Immediately after returning from the function to [rsp + 30h] there is a pointer to the newly created MDL structure (see Fig. 17). <br><br><br><img src="//habrastorage.org/files/10a/0f1/813/10a0f1813ebd4d7794bf90228ac928ea.png"><br>  Fig.  17. MDL structure returned by the vid.sys driver <br><br>  The size of the allocated buffer is also 0xC000.  After that, the root OS sends the message CHANNELMSG_OPENCHANNEL_RESULT.  This completes the activation process of the Data Exchange component.  This creates a kind of shared-buffer, visible as a guest, and root OS.  This can be verified by writing arbitrary data to the buffer in the guest OS, for example, using the command: <br><br><pre> <code class="bash hljs">WINDBG&gt;!ed 2d5bb000 aaaaaaaa WINDBG&gt;!db 2d5bb000 \<span class="hljs-comment"><span class="hljs-comment">#2d5bb000 aa aa aa aa 10 19 00</span></span></code> </pre><br><br>  And in root OS, view the contents of the page corresponding to the PFN, as returned by the vid.sys driver function: <br><br><pre> <code class="bash hljs">WINDBG&gt;!db 1367bb000 \<span class="hljs-comment"><span class="hljs-comment">#1367bb000 aa aa aa aa 10 19</span></span></code> </pre><br><br>  As you can see, the values ‚Äã‚Äãmatch, so this is really the same physical memory area.  Recall that in the previous steps we determined that when activating the Data Exchange component, a port of type HvPortTypeEvent is created with TargetSint = 5. Accordingly, all operations with this port in the OS root will be processed by KiVmbusInterrupt1, from which vmbusr! XPartEnlightenedIsr is called, and it will turn, calls KeInsertQueueDpc with the DPC parameter (its value is shown in Figure 19). <br><br><br><img src="//habrastorage.org/files/412/c69/b23/412c69b2324d4af09aa999f873ac63fe.png"><br>  Fig.  19. DPC value queued by XPartEnlightenedIsr <br><br>  From vmbusr! ParentRingInterruptDpc, vmbusr! PkGetReceiveBuffer will be executed after several calls. <br><br><pre> <code class="cpp hljs">WINDBG&gt;k Child-SP RetAddr Call Site fffff800\`fcc1ea38 fffff800\`<span class="hljs-number"><span class="hljs-number">6</span></span>cdc440c vmbusr!PkGetReceiveBuffer+<span class="hljs-number"><span class="hljs-number">0x2c</span></span> fffff800\`fcc1ea40 fffff800\`<span class="hljs-number"><span class="hljs-number">6</span></span>cdc41a7 vmbusr!PipeTryReadSingle+<span class="hljs-number"><span class="hljs-number">0x3c</span></span> fffff800\`fcc1eaa0 fffff800\`<span class="hljs-number"><span class="hljs-number">6</span></span>cdc4037 vmbusr!PipeProcessDeferredReadWrite+<span class="hljs-number"><span class="hljs-number">0xe7</span></span> fffff800\`fcc1eaf0 fffff800\`<span class="hljs-number"><span class="hljs-number">6</span></span>c96535e vmbusr!PipeEvtChannelSignalArrived+<span class="hljs-number"><span class="hljs-number">0x63</span></span> fffff800\`fcc1eb30 fffff800\`<span class="hljs-number"><span class="hljs-number">6</span></span>cdc4e3d vmbkmclr!KmclpVmbusManualIsr+<span class="hljs-number"><span class="hljs-number">0x16</span></span> fffff800\`fcc1eb60 fffff800\`fb2d31e0 vmbusr!ParentRingInterruptDpc+<span class="hljs-number"><span class="hljs-number">0x5d</span></span></code> </pre><br><br>  If you look at this memory area, you will see the parameters of the guest OS. <br><br><pre> <code class="cpp hljs">WINDBG&gt; dc ffffd0016fe33000 L1000 ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶ ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>e35b30 <span class="hljs-number"><span class="hljs-number">0065004</span></span>e <span class="hljs-number"><span class="hljs-number">00770074</span></span> <span class="hljs-number"><span class="hljs-number">0072006f</span></span> <span class="hljs-number"><span class="hljs-number">0041006b</span></span> NetworkA ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>e35b40 <span class="hljs-number"><span class="hljs-number">00640064</span></span> <span class="hljs-number"><span class="hljs-number">00650072</span></span> <span class="hljs-number"><span class="hljs-number">00730073</span></span> <span class="hljs-number"><span class="hljs-number">00500049</span></span> ddressIP ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>e35b50 <span class="hljs-number"><span class="hljs-number">00340076</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> v<span class="hljs-number"><span class="hljs-number">.4</span></span>............. ‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶‚Ä¶ ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>e35d20 <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> ................ ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>e35d30 <span class="hljs-number"><span class="hljs-number">00300031</span></span> <span class="hljs-number"><span class="hljs-number">0030002</span></span>e <span class="hljs-number"><span class="hljs-number">0030002</span></span>e <span class="hljs-number"><span class="hljs-number">0033002</span></span>e <span class="hljs-number"><span class="hljs-number">1.0</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>..<span class="hljs-number"><span class="hljs-number">.0</span></span>..<span class="hljs-number"><span class="hljs-number">.3</span></span>. ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>e35d40 <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> ................ WINDBG&gt;!pte ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>e35b30 VA ffffd0016fe35b30 PXE at FFFFF6FB7DBEDD00 PPE at FFFFF6FB7DBA0028 PDE at FFFFF6FB74005BF8 PTE at FFFFF6E800B7F1A8 contains <span class="hljs-number"><span class="hljs-number">0000000000225863</span></span> contains <span class="hljs-number"><span class="hljs-number">00000000003B</span></span>7863 contains <span class="hljs-number"><span class="hljs-number">000000010F</span></span>B12863 contains <span class="hljs-number"><span class="hljs-number">80000001367B</span></span>D963 pfn <span class="hljs-number"><span class="hljs-number">225</span></span> ---DA--KWEV pfn <span class="hljs-number"><span class="hljs-number">3b</span></span>7 ---DA--KWEV pfn <span class="hljs-number"><span class="hljs-number">10f</span></span>b12 ---DA-KWEV pfn <span class="hljs-number"><span class="hljs-number">1367b</span></span>d -G-DA--KW-V pfn <span class="hljs-number"><span class="hljs-number">1367b</span></span>d ‚Äî  PFN <span class="hljs-number"><span class="hljs-number">3</span></span>-    MDL</code> </pre><br><br>  Also, the same function in rdx is passed a pointer containing an offset relative to the address of the beginning of the common guest OS pages (in the example, it is 4448h), which needs to be read: <br><br><pre> <code class="cpp hljs">vmbusr!PkGetReceiveBuffer+<span class="hljs-number"><span class="hljs-number">0x4e</span></span>: mov r8,r10 ( r10d      rdx) add r8,qword ptr [rcx+<span class="hljs-number"><span class="hljs-number">20</span></span>h] ‚Äî  rcx+<span class="hljs-number"><span class="hljs-number">20</span></span>           WINDBG&gt;!pte @r8 VA ffffd0016ff22448 PXE at FFFFF6FB7DBEDD00 PPE at FFFFF6FB7DBA0028 PDE at FFFFF6FB74005BF8 PTE at FFFFF6E800B7F910 contains <span class="hljs-number"><span class="hljs-number">0000000000225863</span></span> contains <span class="hljs-number"><span class="hljs-number">00000000003B</span></span>7863 contains <span class="hljs-number"><span class="hljs-number">000000010F</span></span>B12863 contains <span class="hljs-number"><span class="hljs-number">80000001367</span></span>C0963 pfn <span class="hljs-number"><span class="hljs-number">225</span></span> ---DA--KWEV pfn <span class="hljs-number"><span class="hljs-number">3b</span></span>7 ---DA--KWEV pfn <span class="hljs-number"><span class="hljs-number">10f</span></span>b12 ---DA-KWEV pfn <span class="hljs-number"><span class="hljs-number">1367</span></span>c0 -G-DA--KW-V</code> </pre><br><br>  Put a breakpoint at the beginning of the vmbusr! PkGetReceiveBuffer function and execute a PowerShell script.  The breakpoint will work, it will be seen that the structure is passed to the function (pointer to rcx) and there is a pointer to the memory block in rcx + 18: <br><br><pre> <code class="cpp hljs">WINDBG&gt;? poi(@rcx+<span class="hljs-number"><span class="hljs-number">18</span></span>) Evaluate expression: <span class="hljs-number"><span class="hljs-number">-52770386006016</span></span> = ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>e33000 WINDBG&gt;!pte ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>e33000 VA ffffd0016fe33000 PXE at FFFFF6FB7DBEDD00 PPE at FFFFF6FB <span class="hljs-number"><span class="hljs-number">7</span></span>DBA0028 PDE at FFFFF6FB74005BF8 PTE at FFFFF6E800B7F198 contains <span class="hljs-number"><span class="hljs-number">0000000000225863</span></span> contains <span class="hljs-number"><span class="hljs-number">00000000003B</span></span>7863 contains <span class="hljs-number"><span class="hljs-number">000000010F</span></span>B12863 contains <span class="hljs-number"><span class="hljs-number">80000001367B</span></span>B963 pfn <span class="hljs-number"><span class="hljs-number">225</span></span> ---DA--KWEV pfn <span class="hljs-number"><span class="hljs-number">3b</span></span>7 ---DA--KWEV pfn <span class="hljs-number"><span class="hljs-number">10f</span></span>b12 ---DA--KWEV pfn <span class="hljs-number"><span class="hljs-number">1367b</span></span>b -G-DA--KW-V WINDBG&gt;r cr3 cr3=<span class="hljs-number"><span class="hljs-number">00000000001</span></span>ab000 WINDBG&gt;!vtop <span class="hljs-number"><span class="hljs-number">1</span></span>ab000 ffffd <span class="hljs-number"><span class="hljs-number">0016f</span></span>e33000 Amd64VtoP: Virt ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>e33000, pagedir <span class="hljs-number"><span class="hljs-number">1</span></span>ab000 Amd64VtoP: PML4E <span class="hljs-number"><span class="hljs-number">1</span></span>abd00 Amd64VtoP: PDPE <span class="hljs-number"><span class="hljs-number">225028</span></span> Amd64VtoP: PDE <span class="hljs-number"><span class="hljs-number">3b</span></span>7bf8 Amd64VtoP: PTE <span class="hljs-number"><span class="hljs-number">00000001</span></span>\`<span class="hljs-number"><span class="hljs-number">0f</span></span>b12198 Amd64VtoP: Mapped phys <span class="hljs-number"><span class="hljs-number">00000001</span></span>\`<span class="hljs-number"><span class="hljs-number">367b</span></span>b000 Virtual address ffffd0016fe33000 translates to physical address <span class="hljs-number"><span class="hljs-number">1367b</span></span>b000.</code> </pre><br><br><blockquote><h3>  INFO </h3><br>  Information on KvP technology can be found on MSDN blogs: <br>  <a href="http://goo.gl/R0U52l">goo.gl/R0U52l</a> <br>  <a href="http://goo.gl/UeZRK2">goo.gl/UeZRK2</a> <br><br></blockquote><br>  If you put a breakpoint on the instruction add r8, qword ptr [rcx + 20h], then after several iterations in r8 you can see the name and value of the key KvpDataKey: <br><br><br><pre> <code class="cpp hljs">WINDBG&gt;dc @r8 ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>f21d10 ....H........... ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>f21d20 ....(........... ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>f21d30 <span class="hljs-number"><span class="hljs-number">00020006</span></span> <span class="hljs-number"><span class="hljs-number">00000148</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000001</span></span> <span class="hljs-number"><span class="hljs-number">00000</span></span> a28 <span class="hljs-number"><span class="hljs-number">00000003</span></span> <span class="hljs-number"><span class="hljs-number">00050002</span></span>    <span class="hljs-number"><span class="hljs-number">0</span></span>a140000 <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000515</span></span> <span class="hljs-number"><span class="hljs-number">00000103</span></span> ................ ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>f21d40 <span class="hljs-number"><span class="hljs-number">00000004</span></span> <span class="hljs-number"><span class="hljs-number">00000001</span></span> <span class="hljs-number"><span class="hljs-number">00000016</span></span> <span class="hljs-number"><span class="hljs-number">0000001</span></span>a ................ ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>f21d50 <span class="hljs-number"><span class="hljs-number">0076004b</span></span> <span class="hljs-number"><span class="hljs-number">00440050</span></span> <span class="hljs-number"><span class="hljs-number">00740061</span></span> <span class="hljs-number"><span class="hljs-number">004b</span></span>0061 KvPDataK ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>f21d60 <span class="hljs-number"><span class="hljs-number">00790065</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> ey............ ............................................................. .......... ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>f21f50 <span class="hljs-number"><span class="hljs-number">0076004b</span></span> <span class="hljs-number"><span class="hljs-number">00440050</span></span> <span class="hljs-number"><span class="hljs-number">00740061</span></span> <span class="hljs-number"><span class="hljs-number">00560061</span></span> KvPDataV ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>f21f60 <span class="hljs-number"><span class="hljs-number">006</span></span>c0061 <span class="hljs-number"><span class="hljs-number">00650075</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> <span class="hljs-number"><span class="hljs-number">00000000</span></span> alue........ WINDBG&gt;!pte ffffd001\`<span class="hljs-number"><span class="hljs-number">6f</span></span>f21f50 VA ffffd0016ff21f50 PXE at FFFFF6FB7DBEDD00 PPE at FFFFF6FB7DBA0028 PDE at FFFFF6FB74005BF8 PTE at FFFFF6E800B7F908 contains <span class="hljs-number"><span class="hljs-number">0000000000225863</span></span> contains <span class="hljs-number"><span class="hljs-number">00000000003B</span></span>7863 contains <span class="hljs-number"><span class="hljs-number">000000010F</span></span>B12863 contains <span class="hljs-number"><span class="hljs-number">80000001367B</span></span>F963 pfn <span class="hljs-number"><span class="hljs-number">225</span></span> ---DA--KWEV pfn <span class="hljs-number"><span class="hljs-number">3b</span></span>7 ---DA--KWEV pfn <span class="hljs-number"><span class="hljs-number">10f</span></span>b12 ---DA-KWEV pfn <span class="hljs-number"><span class="hljs-number">1367b</span></span>f -G-DA--KW-V</code> </pre><br><br>  Then, after the PkGetReceiveBuffer is completed, the PipeTryReadSingle function copies the data from the shared buffer using the memmove function. <br><br>  The block size (in this case, A28) is indicated directly in the block itself, but if a number greater than 4000h is specified, no copying will be performed.  Thus, it can be seen that the data exchange between the root OS and the guest OS uses a common buffer, and the hypervisor interface is used only to notify the root OS that it is necessary to read data from this buffer.  In principle, the same operation could be performed by sending several messages using winhv! HvPostMessage, but this would lead to a significant decrease in performance. <br><br><h3>  Using the Hypervisor Interception Interface </h3><br><br>  Let us configure the hypervisor so that it sends a root OS notification in case the cpuid instruction with the 0x11114444 parameter is executed in one of the guest OS.  For this, Hyper-V provides an interface in the form of the HvInstallIntercept hypercall.  The hyperv4 driver implements the SetupIntercept function, which receives a list of identifiers for all active guest OSes and calls WinHvInstallIntercept for each. <br><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetupIntercept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ HV_INTERCEPT_DESCRIPTOR Descriptor; HV_INTERCEPT_PARAMETERS Parameters = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; HV_STATUS hvStatus = <span class="hljs-number"><span class="hljs-number">0</span></span>; HV_PARTITION_ID PartID = <span class="hljs-number"><span class="hljs-number">0x0</span></span>, NextPartID = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       RAX- CPUID    0x11114444,             DbgPrintString("SetupInterception was called"); Parameters.CpuidIndex = 0x11114444; Descriptor.Type = HvInterceptTypeX64Cpuid; Descriptor.Parameters = Parameters; hvStatus = WinHvGetPartitionId(&amp;PartID); do{ hvStatus = WinHvGetNextChildPartition(PartID,NextPartID,&amp;NextPartID); if (NextPartID != 0){ DbgLog("Child partition id", NextPartID); hvStatus = WinHvInstallIntercept(NextPartID, HV_INTERCEPT_ACCESS_MASK_EXECUTE, &amp;Descriptor); DbgLog("hvstatus of WinHvInstallIntercept = ",hvStatus); } } while ((NextPartID != HV_PARTITION_ID_INVALID) &amp;&amp; (hvStatus == 0)); return 0;}</span></span></code> </pre><br><br>  We will also change the PrintCpuidInterceptMessage function so that it is in the guest OS in the EAX register (or RAX, if the code that executes the CPUID instruction is executed in longmode) is 0x11114444, wrote down the DefaultResultRdx structure of the HV_X64_CPUID_INTERCEPT_MESSAGE rapple, registered, in a field of the HV_X64_CPUID_INTERCEPT_MESSAGE, ram. , value 0x12345678: <br><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintCpuidInterceptMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PHV_MESSAGE hvMessage)</span></span></span><span class="hljs-function"> </span></span>{PHV_X64_CPUID_INTERCEPT_MESSAGE_phvCPUID = (PHV_X64_CPUID_NTERCEPT_MESSAGE)_hvMessage-&gt;Payload; DbgLog(<span class="hljs-string"><span class="hljs-string">" phvCPUID-&gt;DefaultResultRax"</span></span>,phvCPUID-&gt;DefaultResultRax); DbgLog(<span class="hljs-string"><span class="hljs-string">" phvCPUID-&gt;DefaultResultRbx"</span></span>,phvCPUID-&gt;DefaultResultRbx); DbgLog(<span class="hljs-string"><span class="hljs-string">" phvCPUID-&gt;DefaultResultRcx"</span></span>,phvCPUID-&gt;DefaultResultRcx); DbgLog(<span class="hljs-string"><span class="hljs-string">" phvCPUID-&gt;DefaultResultRdx"</span></span>,phvCPUID-&gt;DefaultResultRdx); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phvCPUID-&gt;Rax == <span class="hljs-number"><span class="hljs-number">0x11114444</span></span>){ phvCPUID-&gt;DefaultResultRdx =<span class="hljs-number"><span class="hljs-number">0x12345678</span></span>; DbgLog16(<span class="hljs-string"><span class="hljs-string">" phvCPUID-&gt;Header.Rip"</span></span>,phvCPUID-&gt;Header.Rip); DbgPrintString(<span class="hljs-string"><span class="hljs-string">" Interception was handled"</span></span>); } }</code> </pre><br><br>  To check in the guest OS, run the test utility that calls the CPUID with Eax equal to 0x11114444.  Before installing the interception, the utility will display the result shown in Fig.  20. <br><br><img src="//habrastorage.org/files/7bc/6d7/641/7bc6d7641b5747fea780240c07a45970.png"><br>  Fig.  20. Result of the CPUID instruction on a regular guest OS <br><br>  After activating interception, the result will be as follows (see Fig. 21). <br><br><img src="//habrastorage.org/files/a5d/088/4ca/a5d0884cabb4413f9fc847dc0cf92beb.png"><br>  Fig.  21. Result of the CPUID instruction after setting the capture <br><br>  At the same time, a message will be displayed in the root of the OS (see Figure 22). <br><br><img src="//habrastorage.org/files/70c/17f/39b/70c17f39bc5e4fe7bae06325ea3759ca.png"><br>  Fig.  22. Debug output of processing a hypervisor message when interception is set <br><br>  Immediately you should pay attention to the fact that this trick will pass only if the root OS has not previously installed hooks for the specified conditions.  In this case, after the hyperv driver replaces the value, control passes to the original WinHvOnInterrupt, which calls the processing function from the vid.sys driver (this function is the fourth parameter of the winhvr! WinHvCreatePartition function, called in the OS root when creating a child partition when the virtual machine starts ), which may cause a change in the result  In our case, such a handler, of course, was not installed, the hypervisor analyzed the data in the null SIM slot and corrected the result of the CPUID instruction. <br><br><br><h3>  Finally </h3><br>  Despite the fact that after reading my work, your brain probably stood in the pose of a river scorpion (and if you read it to it at all - respect you from all of our editorial staff) ... so, I digress.  This article was more of an overview, demonstrating the work of some of the functions and components of the Microsoft virtualization system.  However, I hope the examples will help to better understand the principles of operation of these components and will allow for a more in-depth analysis of their safety. <br><br><br>  Posted by: gerhart <br><br><img src="//habrastorage.org/files/9bc/a0b/27d/9bca0b27d8424e6b9750da40633dd6cb.jpg"><br><br>  <i>First published in the Hacker magazine dated 12/2014.</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://bit.ly/xakep_on_ipad">Hacker on iOS / iPad</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul><br><br> <a href="http://bit.ly/xakep_on_ipad"><img src="http://habrastorage.org/getpro/habr/post_images/6d3/e39/90b/6d3e3990b645b719835d84e9c02699ef.png"></a> <br><br> <a href="http://bit.ly/habr_android"><img src="http://habrastorage.org/getpro/habr/post_images/117/fc7/5d3/117fc75d3fe93b8601be69119c2ecd88.jpg"></a> </div><p>Source: <a href="https://habr.com/ru/post/247273/">https://habr.com/ru/post/247273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247263/index.html">Dagaz: Factorial is easy!</a></li>
<li><a href="../247265/index.html">Evolution of Zeus. Part III</a></li>
<li><a href="../247267/index.html">Win32 / Virlock - the first self-propagating extortionist</a></li>
<li><a href="../247269/index.html">Interesting on .Net hub for 2014</a></li>
<li><a href="../247271/index.html">PVS-Studio rummaged through the guts of Linux (3.18.1)</a></li>
<li><a href="../247275/index.html">Debugger for a penny: do ST-Link from Maple Mini</a></li>
<li><a href="../247277/index.html">SageMathCloud - a dream for fans of Python, math and Linux</a></li>
<li><a href="../247279/index.html">Large collection of hashing functions on Github</a></li>
<li><a href="../247283/index.html">Tutorial AngularJS: A Comprehensive Guide, Part 2</a></li>
<li><a href="../247285/index.html">When to use OOP, and when - OP?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>