<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating game levels: tips and tricks (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second part of my article with level design Tips and Tricks that a developer can use to improve the overall quality of their game. This is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating game levels: tips and tricks (part 2)</h1><div class="post__text post__text-html js-mediator-article">  This is the second part of my <a href="http://habrahabr.ru/post/274483/">article</a> with level design Tips and Tricks that a developer can use to improve the overall quality of their game.  This is by no means a step-by-step guide, but only a collection of ideas and useful tips based on my personal experience.  The first part of the article was more focused on the visual component of the level design, this time we will talk about even more fundamental things, starting with prototyping and ending with analytics playouts. <br><br><img src="https://habrastorage.org/files/006/592/a9d/006592a9df234f658b8467a51da1287d.jpg"><a name="habracut"></a><br><br><h3>  <font color="#9cc2ce">Prototyping</font> </h3><br>  It's no secret that taking the time to prototyping now will save you a lot of time and energy later.  It is obvious, it is important, and for some reason we often neglect this stage.  In my experience, the longer a team works, the more difficult changes and rework are experienced, therefore it is crucial from the very beginning to lay a solid foundation in the form of a prototype of a game, levels, key game mechanics.  If we speak in the context of level design, your work is divided into four stages: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>‚ÄúGreybox‚Äù</b> .  The level is literally made from gray cubes.  Here you lay the foundation for all subsequent work and find out the size of the level, the required graphic and audio assets, working on game mechanics and script events. </li><li>  ‚Äú <b>Whitebox‚Äù</b> .  The geometry of the level is specified, wherever possible, new game mechanics, dialogues, blue-workpieces, sound, and so on are added.  Here you even better grind out existing game mechanics and script events. </li><li>  <b>Graphic pass</b> .  By the time you work on this stage, you must be convinced that it is interesting to play at the level, and it suits you all.  Replacing prototype graphics with final assets is long and expensive.  Any changes at this stage are highly undesirable. </li><li>  <b>The final pass</b> .  Here final touches are put: birds flying in the sky, sounds of bonfires and other pleasant trifles are added. </li><li>  <b>Polishing</b> .  The inevitable stage, usually occurring after the work on the level has been completed.  There will be edits of the little things missed earlier, as well as changes based on the results of the new playtests and the statistics collected. </li></ul><br>  In the picture below you can see a comparison of the ‚Äúwhitebox‚Äù stages and the final graphic itself in ‚ÄúMass Effect 2‚Äù. <br><br><img src="https://habrastorage.org/files/7c9/612/345/7c96123451c3432f93597ef9ee884633.jpg"><br><br>  I also want to add that too early transition to the stage of working with graphics is a serious mistake.  You can easily fool yourself and the team by making a level with exciting graphics, but no gameplay, and all because it looks good visually.  Look at this one and a half minute <a href="https://www.youtube.com/watch%3Fv%3DdkohwfXXnpk">video</a> from mod for ‚ÄúGears of War‚Äù, well illustrating the work on the gameplay in the absence of most of the graphical content. <br><br>  At the prototyping stage in a healthy team or company, it is important to adhere to the ‚ÄúFailure is an Option‚Äù rule.  You make a prototype, evaluate the result and, if it does not suit you, throw it away.  Fast iterations allow you not to become emotionally attached to the work done, so the process is simple and enjoyable.  The screenshot below shows a slice of the prototype level from the indie game I'm working on. <br><br><img src="https://habrastorage.org/files/c21/665/2fc/c216652fc0524f1db55fce851dc8bc89.jpg"><br><br>  During prototyping, it is important to determine and approve the size of the hero, the scale of the environment relative to the hero, as well as the speed of the hero‚Äôs run.  Details further. <br><br><h3>  <font color="#9cc2ce">Hero Scale</font> </h3><br>  Approve the size of the game character as early as possible.  I work in Maya in centimeters, and usually set the average size of the main character: 200cm.  in height, 100cm.  in width and 100cm.  in length.  Thus, creating any new content (bush, tank, house), we always know their size relative to the hero.  It is assumed that the size of the character's collider will be approximately the same size, respectively, the aisles and doors in buildings must be at least one and a half to two times wider than the collider. <br><br>  Also, if you have several 3d-artists, it is strongly recommended that everyone follow a single measurement system.  In other words, if one person has a hero size set at 200 centimeters, and another - 2 meters, then when importing into the engine, for example, in Unity, you will most likely have to give the models different scale compensation (Scale Factor), since Unity 2 and 200 ‚ÄúMay‚Äù units of measurement are different sizes.  The situation becomes more complicated when you work with programs like 3ds Max, where the coordinate system operates with abstract units of measurement, so you have to experiment to find common dimensions for all three-dimensional graphics packages involved in your team. <br><br><h3>  <font color="#9cc2ce">The scale of the environment</font> </h3><br>  Working with the scale of the environment is an extremely interesting topic.  Following the reasoning from the previous paragraph, you need to work on a real scale, starting from the approved 200cm.  And at the same time you will have to lie non-drying.  The point is that at times the object of a real size feels too large or too small, and you have to adjust its scale, trying to achieve a reliable, albeit an incorrect size.  This is well seen in games with stylized graphics, for example, ‚ÄúWorld of Warcraft‚Äù, where you can often see objects like stone stairs with steps that are almost the height of a character.  Interestingly, in the context of styling it looks appropriate and does not cause questions, but if you look closely, all this is pretty damn strange. <br><br><img src="https://habrastorage.org/files/01c/cec/f7c/01ccecf7c5ba43b2aa07bc224c7badf4.jpg"><br><br>  Nevertheless, we must strive to ensure that, on average, your scene has real dimensions.  This is especially important in view of the trend that is currently fashionable for physically correct materials and lighting.  It is known that the intensity of light decreases in proportion to the square of the distance.  In this case, if in your scene, due to errors on the scale, the reading lamp will have a size of under 5 meters, you will inevitably have to twist the lighting math so that it looks more or less adequate in these conditions.  In the end, your scene will consist of many such hacks, which negatively affect both the work of the physically correct render and the quality of the picture as a whole. <br><br>  The scale of the environment is usually known only in comparison with a person or very familiar objects.  Suppose you are a sci-fi shooter, which takes place on a strange alien planet, where even the architecture looks extremely unusual.  What is the size of that ... stone (or is it a plant?).  Or what size is this building?  Not at all clear.  And only if people are scattered around the scene, then you will immediately understand the scale of what is happening.  In some cases, very familiar objects will work: in the picture, the usual shape of the car sets the starting point for the scale. <br><br><img src="https://habrastorage.org/files/ff8/9de/eec/ff89deeecc53438887a9b77aa005fb41.jpg"><br><br>  There is still a good method that allows you to better display the scale of the scene as a whole.  Show some object near, then place a copy of it somewhere far away, then further away.  The player understands that these are objects of the same type, and perceives the difference in scale as a difference in the distance to the object.  In the image below, the objects are so large that they all together do not fit into one screenshot.  As a result, we have an epic range of location.  By the way, I will tell you another cool trick: if the size of a distant object is slightly reduced, then it will seem further than it actually is.  This is often used to create scenes of enormous size, although in reality it is just a tricky game with scales and fog. <br><br><img src="https://habrastorage.org/files/36e/1df/b8e/36e1dfb8e1db458bbc50329bbd09432b.jpg"><br><br><h3>  <font color="#9cc2ce">Hero movement speed</font> </h3><br>  The scale of the environment does not make sense without carefully adjusted the speed of movement of the hero.  The faster the hero moves, the more space is compressed.  A good example is the introduction of flying mount animals in ‚ÄúWorld of Warcraft‚Äù.  Before, the world seemed large enough: it took time to get from one point to another.  With the advent of air transport, this has ceased to be a problem, the hero‚Äôs speed of movement has radically changed the size of the world, while the locations themselves have remained the same. <br><br>  Obviously, such a speed affects the gameplay: the passage of quests, enkontery with monsters, hunting for treasure and finding the road somewhere (one thing to climb the mountain, and the other - just take off and land on top).  The speed of the environment also depends on the speed.  Think about how you would detail the mountain, on which the mountaineer hero will climb to the top, and the mountain, past which the hero-pilot would fly by plane. <br><br>  Thus, it is important to approve the speed of movement as early as possible during the prototyping stage, otherwise constant alterations await you. <br><br><h3>  <font color="#9cc2ce">Level passing time</font> </h3><br>  In the era of mobile games, developers began to pay a lot of attention to the duration of the game session.  Unlike PCs and consoles, it is critically important to find out how long a player can be involved before he has to return to reality - he waited in line, reached the required station, the change was over. <br><br>  As a result, you should know exactly how much time a player can spend on passing a separate level, and on the basis of this data it is already working.  Otherwise, sooner or later you will have to redraw all levels, adjusting them to the requirements.  In ‚ÄúFlappy Bird‚Äù with its instant death, the gaming session can be extremely short.  At the same time, the open world ‚ÄúDragon Age: Inquisition‚Äù threatens to suck you on the clock, and all the action will take place in one location. <br><br><h3>  <font color="#9cc2ce">Smooth colliders for smooth gameplay</font> </h3><br>  Suppose you have a number of small objects such as boxes and barrels, each has its own collider.  If the hero runs straight into the group of objects as in the screenshot below, he will get stuck and stupid due to the randomness of the overall shape of the colliders.  Formally, you did everything correctly - the colliders correctly beat the shape of individual objects.  However, imagine the situation in a mobile game, where control is much less accurate than on a PC or console.  The player will often stick into objects, and it will be more difficult for him to run out of the colliders surrounding him. <br><br>  Take the same group of objects and give them a common collider.  Now the player will not just not stick in the corners, but the character controller will automatically flow around a group of objects.  As a result - a pleasant smooth movement of the hero. <br><br><img src="https://habrastorage.org/files/6c1/641/984/6c16419840084d38bb233ecdbc97486d.jpg"><br><br>  For clarity, I made a <a href="">GIF</a> with a demonstration of smooth motion around a streamlined collider.  As always, there is an underwater rock.  Shared colliders should not capture a lot of empty space.  Invisible walls beat hard on engagement.  If I try to run away from hitting a monster and sticking myself into an invisible wall at a key moment, this is very annoying. <br><br><h3>  <font color="#9cc2ce">Not all colliders are equally useful.</font> </h3><br>  One of the most important tasks of the level designer is to create the most enjoyable gaming experience, on which the colliders have a tremendous impact, as can be seen from the previous section.  You should think twice before giving the collider to a small object.  In the heat of battle, a player can pass through a small object and not pay attention to it at all.  However, if he suddenly sticks into an impassable invisible wall created by a tiny object, nestled in a corner, it will inevitably knock him out of a thin state of flow. <br><br><img src="https://habrastorage.org/files/aa7/906/099/aa7906099db54174aa5fa6afc1963233.jpg"><br><br>  I can give an illustrative example from The Witcher: you see a group of boxes from which you can collect loot.  You are trying to reach them, but Geralt suddenly begins to get confused in colliders, stick into invisible walls, spin around and generally act like a drowned man on a fire.  It completely breaks the sense of involvement in the game, and you involuntarily reach for a cup of coffee, returning to reality. <br><br><h3>  <font color="#9cc2ce">Occlusion Culling</font> </h3><br>  Just want to remind about this technique.  In short, it disables the rendering of objects hidden behind other objects.  Unity, for example, allows you to bake Occlusion Culling, which has a significant impact on performance.  And both for the better and for the worse, depending on the situation.  Two examples: <br><br><ul><li>  In a mobile game with a Top-Down camera (as in Diablo), activating this feature saves 2-4 Draw Calls (DC).  At the same time, 5ms is added to the processor.  on frame processing.  Absolutely not worth it. </li><li>  In a PC game with a First Person camera, where the action takes place in a narrow cave, there is initially 450 DC.  Activating Occlusion Culling reduces the amount of DC to 50 at the cost of the same + 5ms.  Definitely need to use. </li></ul><br><h3>  <font color="#9cc2ce">Parallax and pseudo-3d</font> </h3><br>  Any 3d game on the monitor screen is still an array of pixels in the 2d plane of the screen, whatever one may say (VR does not count).  But there are a number of tricks to create the illusion of three-dimensional space.  In terms of level design, the most useful tool will be a conscious breakdown of the picture into the front, middle and long-range plans.  This is most easily realized in games with Top-Down cameras a la ‚ÄúDiablo‚Äù and ‚ÄúPath of Exile‚Äù, as well as sidescrollers (platformers).  The average is your character.  The farthest may be an epic view, as in the following screenshot, but more often it‚Äôs just distant objects. <br><br><img src="https://habrastorage.org/files/e6a/37d/5ae/e6a37d5aebe24e28b2125335acf5f625.jpg"><br><br>  The foreground is more interesting.  As a rule, it uses shaded objects such as hanging ropes, chains, chandeliers and other junk, creating parallax between backgrounds.  Parallax is the difference in the speed of the plans relative to the camera.  That is, the foreground is always replaced faster than the distant, generally remaining static due to its remoteness from the browser. <br><br><img src="https://habrastorage.org/files/0d4/7c2/e9c/0d47c2e9c3c94624a9407c4a9f5ef1d3.jpg"><br><br>  The most difficult to show the foreground in games from the first and from the third person.  Developers go for different tricks, here are some examples: <br><br><ul><li>  Dirt on the breathing mask glass, as in ‚ÄúMetro 2033‚Äù. </li><li>  Splashes of blood right in front of the face, when, for the sake of the skin, the hero carves the animal‚Äôs carcass in ‚ÄúFar Cry‚Äù. </li><li>  The hands and sneakers of the character, like Faith's in ‚ÄúMirror's Edge‚Äù. </li><li>  Cracked car glass while driving (‚ÄúGTA‚Äù, ‚ÄúFar Cry‚Äù). </li><li>  The gun in the face, especially in the optical sight mode (any shooter). </li><li>  Obstacle (concrete block, corner of the house), behind which you hide from opponents.  Games specifically encourage this gameplay.  For example, in ‚ÄúFar Cry 4‚Äù you can hide behind bushes, and the enemy will not see you. </li><li>  Interference in the neural interface located on the screen, as in ‚ÄúBlack Ops 3‚Äù and ‚ÄúDeux Ex: HR‚Äù. </li></ul><br><img src="https://habrastorage.org/files/4da/ec1/66c/4daec166c248426fb8dc992ab2171485.jpg"><br><br><h3>  <font color="#9cc2ce">Invisible walls</font> </h3><br>  This is a fairly specific case, but worth mentioning.  In the indie project where I work, we applied this mechanic: when you enter a certain zone, a magic wall appears behind your back, and monsters begin to appear in front of you.  After the death of all the monsters enchanted walls disappear.  We did this by analogy with other mobile projects like ‚ÄúDungeon Hunter‚Äù, as well as by analogy with ‚ÄúWorld of Warcraft‚Äù, where in the battle with the bosses behind you, the passage is blocked in the same way. <br><br>  So, this is a cheap and lazy way to simplify and speed up the work.  But the result is the same cheap;  the player feels it.  Try to get away from this, albeit with the classical method: jump down from the ledge, and never get back.  Cliche?  Yes, but still better than invisible walls. <br><br>  There is an even more unforgivable subclass of invisible walls - level boundaries that kill a player.  Worse, if the developer builds the gameplay around this horror.  A vivid example of ‚ÄúDestiny‚Äù: treasure chests are often placed near the very border of the level, so much so that it is often not obvious where the border lies.  As a result, a stupid death is inevitable when you jump onto a flat stone two meters below you, and he instantly kills the hero in response.  And yes, this is not death from falling in a game where you can jump 10 meters high and land on solid ground without any problems. <br><br><h3>  <font color="#9cc2ce">Target platform</font> </h3><br>  As far as is obvious, as often it is ignored.  Everything you do should be checked on the target platform.  I have repeatedly seen how a person is interested in a task, for example, designing a GUI, and forgets to check his work on a mobile device where the interface will be used. <br><br>  The same with levels.  It is important not to be lazy and regularly test your work on the target platform.  If you are creating a game for the console, see how comfortable it is to run and fight using a gamepad.  If the level is developed for a mobile device, then the more often you will watch your work on a small screen with extremely inaccurate touch controls, the less headache you will get in the future.  However, it is not even a headache, but in the quality of work.  Noticing in time that you are moving in the wrong direction, you will be able to correct the vector of work in a timely manner and end up with a decent result. <br><br><h3>  <font color="#9cc2ce">Playtesting</font> </h3><br>  Playtesting is a completely surreal experience, forgive me for anglicisms.  It is difficult to convey in words the sensations of observing a player interacting with your level.  In general, seeing a player on your level is a surge of motivation, which is always good for an indie developer who does not receive a monthly cash reward for his work. <br><br>  However, the main task is to test all of our hypotheses in practice, to see where they have failed and where corrections are required.  Like any creator, over time, the eye becomes blurred, and you will inevitably make some mistake or miss something.  The sooner there is adequate feedback, the better. <br><br><h3>  <font color="#9cc2ce">Analytics</font> </h3><br>  Playtests are good, but observing 5-10 players is not statistics, so it makes sense to track the behavior of hundreds or thousands of players.  For example, we collect data with the frequency and coordinates of the point of death of the hero, and we understand where the game is too complicated, we edit the balance and repeat the whole process. <br><br><img src="https://habrastorage.org/files/193/a86/611/193a86611f654b48b400435000c76828.jpg"><br><br>  And even if you have not been released yet, but you have several testers, or your demo is available to a limited number of people (for example, ‚Äúbackers‚Äù from Kickstarter), it still makes sense to collect and analyze data already at this stage. <br><br><h3>  <font color="#9cc2ce">Polishing</font> </h3><br>  Try to leave a little bit of time for polishing, that is, for minor edits and closing small holes, which have never been reached before for one reason or another.  For example, one of my recent levels has a task with a list of 29 points.  Each of them requires from 5 to 15 minutes of work.  Having overcome these problem areas, you are transferring a level from the polishing stage to the status of ‚Äúfinal‚Äù or ‚Äúrelease candidate‚Äù.  Problems that need to be ‚Äúpolished‚Äù will emerge during the playtest and collection of statistics.  It‚Äôs more effective not to run right away to correct every tiny flaw, but to prepare a separate list, and then fix everything in a crowd.  Remember, this stage is inevitable, so leave time for it in advance, even if you are sure that you immediately did everything cool, and you will not have to polish it. <br><br><h3>  <font color="#9cc2ce">Conclusion</font> </h3><br>  This concludes this article, which consists of two parts.  If you missed the first part, here's a <a href="http://habrahabr.ru/post/274483/">link</a> .  Also, if you are interested in lighting in Unity, you may be interested in my recent <a href="http://habrahabr.ru/post/266839/">article</a> right there on Habr√©.  Having accumulated more experience, I see some inaccuracies in the article, but in general it is very close to reality.  Therefore, if you are just studying the topic of lighting in Unity, the material should be useful to you. <br><br>  I would welcome any comments and suggestions.  In addition, I accept ideas for new articles on level design, as well as lighting and post-effects in Unity :) Thank you for your attention! </div><p>Source: <a href="https://habr.com/ru/post/274625/">https://habr.com/ru/post/274625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274613/index.html">Wi-Fi Alliance announced a new type of Wi-Fi for IoT and low-power devices</a></li>
<li><a href="../274615/index.html">The pitfalls of using Excel Power Query and MySQL to automate reporting</a></li>
<li><a href="../274617/index.html">Disable the bomb with Radare2</a></li>
<li><a href="../274619/index.html">Some sugar in combinatorics</a></li>
<li><a href="../274621/index.html">Tools for hacking, flashed in the TV series Mr Robot</a></li>
<li><a href="../274629/index.html">The first build of Vivaldi 1.0.365.3 in the coming year</a></li>
<li><a href="../274631/index.html">Pagekit: Symfony Modular CMS Review</a></li>
<li><a href="../274633/index.html">Rodent Hunt for Linux</a></li>
<li><a href="../274635/index.html">Use android.os.Binder to organize asynchronous interaction in Android</a></li>
<li><a href="../274637/index.html">Ember.js - goodbye MVC (part 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>