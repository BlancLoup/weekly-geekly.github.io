<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating PHP Extensions: An Introduction to PHP and Zend</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of Sara Golemon 's article ‚ÄúExtension Writing Part I: Introduction to PHP and Zend‚Äù . 



 Introduction 
 If you are reading this article,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating PHP Extensions: An Introduction to PHP and Zend</h1><div class="post__text post__text-html js-mediator-article">  Translation of <a href="http://devzone.zend.com/member/4580-SaraMG">Sara Golemon</a> <a href="http://devzone.zend.com/node/view/id/1021">'s</a> article <a href="http://devzone.zend.com/node/view/id/1021">‚ÄúExtension Writing Part I: Introduction to PHP and Zend‚Äù</a> . <br><br><a name="habracut"></a><br><br><h1>  Introduction </h1><br>  If you are reading this article, most likely you have some interest in creating extensions for the PHP language.  If not ... maybe when you read this article, you will find that interest in yourself, despite the fact that you didn‚Äôt even know about it! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The material in this article implies an introduction to both the PHP language itself and the language in which the PHP interpreter is written: <i>C.</i> <br><br>  Let's start by identifying the reasons why you want to write an extension for PHP: <br><ol><li>  The existence of any library or a specific OS call that cannot be made from PHP directly due to the level of abstraction adopted in the language; </li><li>  You want to make PHP work in a non-standard way; </li><li>  You already have a solution written in PHP, but you know that it can be faster, more compact and consume less memory in the process; </li><li>  You have a special code that you would like to sell.  However, it is important that the buyer could run your code, but not watch the source. </li></ol><br>  All the reasons listed above are quite adequate, but when creating an extension, first of all you should understand that this is primarily an <strong>extension</strong> . <br><br><br><br><h1>  What is Expansion? </h1><br>  If you had to use PHP, then you used and extensions.  With a few exceptions, each available function in PHP is grouped into one or another extension.  The main part of the functions (more than 400) is included in the <em>standard extension</em> .  PHP source codes are distributed with about 86 extensions, having about 30 functions each.  Considering, we get somewhere in 2500 functions in the amount.  If this is not enough, <a href="http://pecl.php.net/">the PECL repository</a> offers over 100 additional extensions, even more can be found on the vast expanses of the Internet. <br><br>  ‚ÄúWell, considering all this variety of functions that live in extensions, then remains outside the extensions?‚Äù - you ask.  ‚ÄúWhat extensions expand?  What is the <strong>core of PHP</strong> ? <br><br>  The PHP core is implemented as 2 separate parts.  The technical part of the language is presented in the form of <strong>Zend Engine</strong> (ZE).  ZE is responsible for converting a human-readable script into computer-friendly tokens, and then executes them.  In addition, the ZE is responsible for managing the memory, scopes of variables, handling function calls. <br>  The second part of the kernel is what is directly called the ‚Äú <strong>PHP core</strong> ‚Äù.  It is responsible for interacting with the SAPI layer (Server Application Programming Interface, PHP interface with other server software - CLI, CGI, Apache, and so on).  In addition, the kernel implements a generic control layer for safe_mode and open_basedir checks (features are depricated from version 5.3), as well as a thread layer that associates file and network I / O operations with the fopen, fread and fwrite functions. <br><br><br><br><h1>  Life cycle </h1><br>  When a given SAPI starts up (for example, when Apache server is started by the command <em>/ usr / local / apache / bin / apachectl start</em> ), PHP starts its work by starting the kernel subsystem.  By the end of the startup procedure, it loads the code for each extension and calls its <strong>Module Initialization</strong> (MINIT) function.  This gives each extension the ability to initialize internal variables, allocate memory for resources, register resource handlers and its functions in the ZE, so that when you call a function of this extension, ZE knows what code to execute. <br><br>  Next, PHP waits for the page processing request from the SAPI layer.  In the case of SAPI CGI or CLI, this happens immediately and only once.  In the case of SAPI Apache, IIS or another full-fledged web server, a request to process a page occurs every time a page is requested (possibly competitive) by a remote user.  However, regardless of how the request arrived, its processing begins with the fact that the PHP core asks the ZE to set up the environment to run the script, after which it calls the <strong>Request Initialization</strong> (RINIT) function for each extension.  <i>RINIT</i> gives extensions the ability to set specific environment variables, allocate memory for specific request resources, and perform other tasks.  A vivid example of the <i>RINIT</i> function in action can be the <i>session</i> extension, in which, with the <i>session.auto_star</i> t setting turned on, the <i>RINIT</i> function automatically causes the execution of the <em>session_start</em> function and initializes the <em>$ _SESSION</em> variable. <br><br>  After the request is initialized, ZE translates the PHP script into <strong>tokens</strong> and then into <strong>opcodes</strong> that it can execute.  If any of these opcodes request a function call from the extension, the ZE forms the arguments for calling this function and temporarily transfers control to it until it completes. <br><br>  After the script has completed its execution, PHP calls the <strong>Request Shutdown</strong> (RSHUTDOWN) function for each extension to do everything necessary to complete the cleanup (for example, saving session variables to disk).  The next step ZE performs the cleanup process (also known as garbage collection), which actually performs the <em>unset</em> method for each variable used in the executed script (since PHP 5.3, <a href="http://php.net/manual/en/features.gc.php">the garbage collection mechanism has been</a> greatly improved). <br><br>  After completing the processing of the request, PHP is waiting for the SAPI to either request a processing of another script, or a signal for completion.  In the case of CGI or CLI SAPI, the ‚Äúnext request‚Äù is not possible; therefore, SAPI initiates PHP shutdown immediately.  In the process of completing PHP, it iterates through all the extensions and calls the <strong>Module Shutdown</strong> (MSHUTDOWN) function for each, and then completes its own kernel subsystem. <br><br>  This process may seem a bit confusing at first, but if you are immersed in the work on extensions, you will gradually feel it. <br><br><br><br><h1>  Memory allocation </h1><br>  In order to avoid memory leaks in poorly written extensions, ZE uses its own internal memory management mechanism, based on an additional flag to determine the lifetime of the data.  Permanent ( <b>persistent</b> ) memory allocation means that memory will be allocated more than the time it takes to process a single page request.  Non <b>-persistent</b> memory allocation means freeing up memory after processing a request, regardless of whether the freeing function was called.  For example, the allocation of memory for user variables is variable, since upon completion of the processing of the request they become useless. <br><br>  Although the extension in theory may place the ZE on freeing non-permanent memory automatically upon completion of each request, this is not recommended.  The allocated memory will remain unclaimed for a long time, the resources associated with this memory will be less likely to be closed correctly, and, in the end, creating confusion with the release of memory is a bad practice.  As you will see later, making sure that all the data is cleaned up is easy enough. <br><br>  Let's briefly compare the traditional memory allocation functions (which should be used only when working with external libraries) with the functions of permanent and non-constant memory allocation in PHP / ZE. <br><br><table><tbody><tr><th>  <strong>Traditional</strong> </th><th>  <strong>Inconsistent</strong> </th><th>  <strong>Permanent</strong> </th></tr><tr><td>  malloc (count) </td><td>  emalloc (count) </td><td>  pemalloc (count, 1) <sup>*</sup> </td></tr><tr><td>  calloc (count, num) </td><td>  ecalloc (count, 1) </td><td>  pecalloc (count, num, 1) </td></tr><tr><td>  strdup (str) </td><td>  estrdup (str) </td><td>  pestrdup (str, 1) </td></tr><tr><td>  strndup (str, len) </td><td>  estrndup (str, len) </td><td>  pemalloc () &amp; memcpy () </td></tr><tr><td>  free (ptr) </td><td>  efree (ptr) </td><td>  pefree (ptr, 1) </td></tr><tr><td>  realloc (ptr, newsize) </td><td>  erealloc (ptr, newsize) </td><td>  perealloc (ptr, newsize, 1) </td></tr><tr><td>  malloc (count * num + extr) <sup>**</sup> </td><td>  safe_emalloc (count, num, extr) </td><td>  safe_pemalloc (count, num, extr) </td></tr></tbody></table>  <em>* The pemalloc family of functions accepts a ‚Äúconstancy‚Äù flag as a parameter, which allows them to behave like their non-permanent counterparts.</em> <em><br></em>  <em>For example: emalloc (1234) is the same as pemalloc (1234, 0)</em> <em><br></em>  <em>** safe_emalloc () and (in PHP 5) safe_pemalloc implement an additional check for integer overflows.</em> <em><br></em> <br><br><br><br><h1>  Setting up and building the environment </h1><br>  Now that you are familiar with the theory of the work of PHP and Zend Engine, I bet you can‚Äôt wait to dive into the work and start doing something.  However, before that you need to acquire some utilities for building and set up the environment for your purposes. <br><br>  First of all, you need PHP itself and the set of build tools needed for PHP.  If you don‚Äôt have to build PHP from source, I suggest taking a look at <a href="http://www.php.net/manual/en/install.unix.php">this article</a> .  Despite the fact that the use of a binary package with PHP source files may seem tempting, such builds often lack two important parameters of the <em>./configure</em> program, which are very useful during the development process.  The first one is <strong>enabled-debug</strong> .  This option compiles PHP with additional debugging information in executable files, so if a segfault error occurs, you can get a kernel dump and use the gdb debugger to figure out where and why the error occurred. <br>  The name of the second option depends on which version of PHP you are going to work with.  In PHP 4.3, it is called <strong>--enable-experimental-zts</strong> , since PHP 5, it has been renamed to <strong>--enable-maintainer-zts</strong> .  This option will make PHP think that it works in a multithreaded (multithread) environment, and allows you to catch common errors that are invisible in a non-threaded environment, but will cause your extension to be unstable in a multi-threaded environment. <br>  By compiling PHP with additional options and installing it on a development server (or workstation), you can start creating your first extension. <br><br><br><br><h1>  Hello world </h1><br>  What is the introductory article on programming can be considered complete without an example of the now obligatory program Hello World?  In this case, we‚Äôll look at creating an extension that adds a single function to PHP that returns a string with the word ‚ÄúHello World.‚Äù  In PHP, you would probably implement it like this: <br><blockquote><code><font color="black">&lt;?php <br> <br> function hello_world() { <br> <font color="#0000ff">return</font> <font color="#A31515">'Hello World'</font> ; <br> } <br> <br> ?&gt;</font></code> </blockquote> <br>  Now let's make a PHP extension from this function.  First of all, create a <em>hello</em> subdirectory in the <em>ext /</em> directory directory of the PHP source tree and make a <em>cd</em> into it.  In principle, this directory can be located anywhere inside or outside the source directory tree, but you should put it here to be able to refer to it from the article in the future.  Here you need to create three files: <br><ol><li>  The configuration file ( <em>config.m4</em> ) used by the <em>phpize</em> utility to prepare the extension for compilation: <br><blockquote> <code>PHP_ARG_ENABLE(hello, whether to enable Hello World support, <br> [ --enable-hello Enable Hello World support]) <br> <br> if test "$PHP_HELLO" = "yes"; then <br> AC_DEFINE(HAVE_HELLO, 1, [Whether you have Hello World]) <br> PHP_NEW_EXTENSION(hello, hello.c, $ext_shared) <br> fi <br></code> </blockquote><br></li><li>  a header file ( <em>php_hello.h</em> ) containing instructions used by PHP to load extensions: <br><blockquote> <code><font color="black">#ifndef PHP_HELLO_H <br> <font color="#0000ff">#define</font> PHP_HELLO_H 1 <br> <br> <font color="#0000ff">#define</font> PHP_HELLO_WORLD_VERSION <font color="#A31515">"1.0"</font> <br> <font color="#0000ff">#define</font> PHP_HELLO_WORLD_EXTNAME <font color="#A31515">"hello"</font> <br> <br> PHP_FUNCTION(hello_world); <br> <br> <font color="#0000ff">extern</font> zend_module_entry hello_module_entry; <br> <font color="#0000ff">#define</font> phpext_hello_ptr &amp;hello_module_entry <br> <br> <font color="#0000ff">#endif</font></font> <br> <br></code> </blockquote><br></li><li>  source file ( <em>hello.c</em> ) containing the body of the hello_world function: <br><blockquote> <code><font color="black">#ifdef HAVE_CONFIG_H <br> #include <font color="#A31515">"config.h"</font> <br> <font color="#0000ff">#endif</font> <br> <br> #include <font color="#A31515">"php.h"</font> <br> #include <font color="#A31515">"php_hello.h"</font> <br> <br> <font color="#0000ff">static</font> function_entry hello_functions[] = { <br> PHP_FE(hello_world, NULL) <br> {NULL, NULL, NULL} <br> }; <br> <br> zend_module_entry hello_module_entry = { <br> <font color="#0000ff">#if</font> ZEND_MODULE_API_NO &gt;= 20010901 <br> STANDARD_MODULE_HEADER, <br> <font color="#0000ff">#endif</font> <br> PHP_HELLO_WORLD_EXTNAME, <br> hello_functions, <br> NULL, <br> NULL, <br> NULL, <br> NULL, <br> NULL, <br> <font color="#0000ff">#if</font> ZEND_MODULE_API_NO &gt;= 20010901 <br> PHP_HELLO_WORLD_VERSION, <br> <font color="#0000ff">#endif</font> <br> STANDARD_MODULE_PROPERTIES <br> }; <br> <br> #ifdef COMPILE_DL_HELLO <br> ZEND_GET_MODULE(hello) <br> <font color="#0000ff">#endif</font> <br> <br> PHP_FUNCTION(hello_world) <br> { <br> RETURN_STRING( <font color="#A31515">"Hello World"</font> , 1); <br> }</font> <br> <br></code> </blockquote><br></li></ol>  Most of the code that you see in the previous example is just a kind of ‚Äúglue‚Äù - a protocol for registering an extension in PHP and establishing a dialogue between them.  The real code is only the last 4 lines in the file <em>hello.c</em> , which perform actions at a level that can be invoked from a user script.  Undoubtedly, this code is quite similar to the PHP code that we saw earlier, and can be easily disassembled into parts: <br><ul><li>  function declaration with the name hello_world, </li><li>  setting the return value to the string "Hello World", </li><li>  hmm ... 1?  What does this 1 mean? </li></ul><br>  Recall that the ZE uses an advanced memory management mechanism that verifies that all requested resources are released at the time the script is finished.  In the world of memory management, the re-release of the same block of memory is considered <i>big ah-ah-ah</i> .  Such an action is called ‚Äúdouble freeing‚Äù and is a common cause of segmentation errors, as it causes the program to try to gain access to a block of memory that no longer belongs to it. <br>  Simply put, so that ZE does not start re-freeing the memory occupied by a static string (which is ‚ÄúHello World‚Äù in our example), the hello_world function should return a copy of the string each time it is called. <br>  In principle, the <em>RETURN_STRING</em> function can take responsibility for the fact that any string passed to it must be copied, so that it would be possible to safely free its memory later.  However, since allocating memory for a string, copying a string, and returning a copy as a result is not a standard behavior for internal ZE functions, <em>RETURN_STRING</em> allows <em>you</em> to specify whether you need to make a copy of a variable or not using the second argument.  For a clearer description of this concept, pay attention to the following code fragment, which is functionally identical to the previous one: <br><blockquote> <code><font color="black">PHP_FUNCTION(hello_world) <br> { <br> <font color="#0000ff">char</font> *str; <br> <br> str = estrdup( <font color="#A31515">"Hello World"</font> ); <br> RETURN_STRING(str, 0); <br> }</font> <br> <br></code> </blockquote><br>  In this example, you manually allocated non-permanent memory for the string ‚ÄúHello World‚Äù, which you passed back to the calling script using the RETURN_STRING <em>function</em> , specifying 0 as the second parameter, which causes the function not to make a copy of the string, as it can use ours. <br><br><br><br><h1>  Extension build </h1><br>  The final step in this exercise will be to build your extension as a dynamically loadable module.  If you copied the previous examples correctly, all that remains is to run three commands from the ext / hello / directory: <br><blockquote> <code>$ phpize <br> $ ./configure --enable-hello <br> $ make <br></code> </blockquote><br>  Please note that for the <i>phpize</i> utility to work correctly, <i>you</i> must have the <i>m4</i> and <i>autoconf</i> utilities. <br>  After running all these commands, you should have the file <em>hello.so</em> in the <em>ext / hello / modules /</em> folder.  Now, like any other PHP extension, you can simply copy its directory with extensions (the default is <em>/ usr / local / lib / php / extensions /</em> , but just in case, check the <em>php.ini</em> settings or use the <i>php-config -</i> command <i>-extension-dir</i> ) and add the line <em>extension = hello.so</em> to <em>php.ini</em> to initialize the loading of the extension when PHP starts.  For SAPI type CGI / CLI, this will be the next script launch, for SAPI web servers like Apache this will be the next server restart.  Let's try calling the function from the command line: <br><blockquote> <code>$ php ‚Äìr 'echo hello_world();' <br></code> </blockquote><br>  If everything goes as it should, you will see the string <i>Hello World</i> as the result of the script, since the <em>hello_world</em> function from the loaded extension returns a string, and the <i>echo</i> command displays what was passed to the input (in this case, the result of the <em>hello_world</em> function ). <br><br>  In this example, we returned a string, other scalar data types can be returned on a similar basis: RETURN_LONG for integer values, <em>RETURN_DOUBLE</em> for floating-point numbers, <em>RETURN_BOOL</em> for TRUE / FALSE and <em>RETURN_NULL</em> for, you guessed it, NULL-values.  Let's look at each of them in action by adding lines with the <em>PHP_FE</em> macro to the <em>function_entity</em> structure and the corresponding <em>PHP_FUNCTION</em> macros in the <em>hello.c</em> file: <br><blockquote> <code><font color="black"><font color="#0000ff">static</font> function_entry hello_functions[] = { <br> PHP_FE(hello_world, NULL) <br> PHP_FE(hello_long, NULL) <br> PHP_FE(hello_double, NULL) <br> PHP_FE(hello_bool, NULL) <br> PHP_FE(hello_null, NULL) <br> {NULL, NULL, NULL} <br> }; <br> <br> PHP_FUNCTION(hello_long) <br> { <br> RETURN_LONG(42); <br> } <br> <br> PHP_FUNCTION(hello_double) <br> { <br> RETURN_DOUBLE(3.1415926535); <br> } <br> <br> PHP_FUNCTION(hello_bool) <br> { <br> RETURN_BOOL(1); <br> } <br> <br> PHP_FUNCTION(hello_null) <br> { <br> RETURN_NULL(); <br> }</font> <br> <br></code> </blockquote><br>  In addition, we will have to add prototypes for these functions next to the prototype for the <em>hello_world</em> function in the <em>php_hello.h</em> header file in <em>order</em> for the build process to go without problems: <br><blockquote> <code><font color="black">PHP_FUNCTION(hello_world); <br> PHP_FUNCTION(hello_long); <br> PHP_FUNCTION(hello_double); <br> PHP_FUNCTION(hello_bool); <br> PHP_FUNCTION(hello_null);</font> <br> <br></code> </blockquote><br>  Since you did not make any changes to the <em>config.m4</em> file, technically there is no need to repeat the <em>phpize</em> and <em>./configure</em> steps, but you can immediately proceed to the execution of the <em>make command</em> .  However, this time I will ask you to go through all three steps of the assembly anew in order to make sure that no problems have arisen.  In addition, as the last step, you can use the command <em>make clean all</em> instead of <em>make</em> to be sure that all the files with the sources will be rebuilt.  I repeat that this is not necessary due to the type of changes you made, but it is better to be safe than stumble upon an error.  After the module is assembled, you need to copy it into the extensions directory, replacing the old version with it. <br><br>  Now you can call the PHP interpreter again, passing simple scripts to it in order to test the newly added functions.  In fact - why not do it now?  I'll wait for you here ... <br><br>  Is it done?  Good.  If you used <em>var_dump</em> instead of <em>echo</em> to view the result of each function, you may have noticed that <em>hello_bool</em> returns TRUE.  This is the result of the equality of the 1st argument of the function.  As with PHP scripts, the integer value 0 is equivalent to FALSE, while any other number is equivalent to TRUE.  The authors of extensions often use the agreement according to which this number is 1. It is desirable, but not necessary, that you also adhere to this agreement.  In addition, the <em>RETURN_TRUE</em> and <em>RETURN_FALSE</em> macros are available for more convenience.  Below is an example of the <em>hello_bool</em> function using the <em>RETURN_TRUE</em> macro. <br><blockquote> <code><font color="black">PHP_FUNCTION(hello_bool) <br> { <br> RETURN_TRUE; <br> }</font> <br> <br></code> </blockquote><br>  Note that no parentheses were used when calling the macro.  In this regard, the <em>RETURN_TRUE</em> and <em>RETURN_FALSE macros</em> are different from other <em>RETURN_ *</em> macros, so be careful not to fall for it! <br><br>  You may have noticed that in all previous examples we do not pass the parameter responsible for creating a copy of the result.  The reason for this is that such simple scalar values ‚Äã‚Äãdo not require the allocation or freeing of additional memory. <br><br>  There are 3 additional return types: <strong>RESOURCE</strong> (returned, for example, by the functions <em>mysql_connect</em> , <em>fsockopen</em> or <em>ftp_connect</em> ), <strong>ARRAY</strong> (also known as <strong>HASH</strong> ) and <b>OBJECT</b> (returned by the keyword <em>new</em> ).  We will talk about them later. <br><br><br><br><h1>  INI-settings </h1><br>  Zend Engine provides two approaches for working with INI data.  Now we will look at the simplest of them, and will return to the more general one after becoming familiar with global variables. <br><br>  Suppose you want to declare in the <em>php.ini file</em> the <em>hello.greeting</em> setting for your extension, which will contain the value to be output by the <em>hello_world</em> function.  To do this, we will have to add a few changes to the <em>hello.c</em> and <em>php_hello.h files</em> as part of the change in the <em>hello_module_entry</em> structure.  Let's start by adding the following prototypes before the list of prototypes of user-defined functions in the <em>php_hello.h</em> file: <br><blockquote> <code><font color="black">PHP_MINIT_FUNCTION(hello); <br> PHP_MSHUTDOWN_FUNCTION(hello); <br> <br> PHP_FUNCTION(hello_world); <br> PHP_FUNCTION(hello_long); <br> PHP_FUNCTION(hello_double); <br> PHP_FUNCTION(hello_bool); <br> PHP_FUNCTION(hello_null);</font> <br> <br></code> </blockquote><br>  Next, open the file <em>hello.c</em> and replace the current version of <em>hello_module_entry</em> with the following: <br><blockquote> <code><font color="black">zend_module_entry hello_module_entry = { <br> <font color="#0000ff">#if</font> ZEND_MODULE_API_NO &gt;= 20010901 <br> STANDARD_MODULE_HEADER, <br> <font color="#0000ff">#endif</font> <br> PHP_HELLO_WORLD_EXTNAME, <br> hello_functions, <br> PHP_MINIT(hello), <br> PHP_MSHUTDOWN(hello), <br> NULL, <br> NULL, <br> NULL, <br> <font color="#0000ff">#if</font> ZEND_MODULE_API_NO &gt;= 20010901 <br> PHP_HELLO_WORLD_VERSION, <br> <font color="#0000ff">#endif</font> <br> STANDARD_MODULE_PROPERTIES <br> }; <br> <br> PHP_INI_BEGIN() <br> PHP_INI_ENTRY( <font color="#A31515">"hello.greeting"</font> , <font color="#A31515">"Hello World"</font> , PHP_INI_ALL, NULL) <br> PHP_INI_END() <br> <br> PHP_MINIT_FUNCTION(hello) <br> { <br> REGISTER_INI_ENTRIES(); <br> <br> <font color="#0000ff">return</font> SUCCESS; <br> } <br> <br> PHP_MSHUTDOWN_FUNCTION(hello) <br> { <br> UNREGISTER_INI_ENTRIES(); <br> <br> <font color="#0000ff">return</font> SUCCESS; <br> }</font> <br> <br></code> </blockquote><br>  Now you need to add the appropriate <em>#include</em> directive at the beginning of the <em>hello.c</em> file to get the headers for working with INI files: <br><blockquote> <code><font color="black">#ifdef HAVE_CONFIG_H <br> #include <font color="#A31515">"config.h"</font> <br> <font color="#0000ff">#endif</font> <br> <br> #include <font color="#A31515">"php.h"</font> <br> #include <font color="#A31515">"php_ini.h"</font> <br> #include <font color="#A31515">"php_hello.h"</font></font> <br> <br></code> </blockquote><br>  The last thing you need to do is modify the <em>hello_world</em> function so that it uses the INI setting: <br><blockquote> <code><font color="black">PHP_FUNCTION(hello_world) <br> { <br> RETURN_STRING(INI_STR( <font color="#A31515">"hello.greeting"</font> ), 1); <br> }</font> <br> <br></code> </blockquote><br>  Note that you are creating a copy of the value received from <em>INI_STR</em> .  The reason is that the string returned by <em>INI_STR</em> is static.  In other words, if you try to change it, the PHP working environment may become unstable or even crash. <br><br>  The first set of changes in this chapter adds two new methods that you should already be familiar with: <em>MINIT</em> and <em>MSHUTDOWN</em> .  As mentioned earlier, these methods are called when the SAPI layer is first launched and in the process of completing its work, respectively.  They are not called during or between requests.  In this example, they are used to register entries from the php.ini file declared in your extension.  Also in these functions, resources, objects and stream handlers can be registered. <br><br>  In your <em>hello_world</em> function <em>,</em> you use the <em>INI_STR</em> macro to get the current value of the <em>hello.greating entry</em> as a string.  There are a number of other functions for obtaining integer values, floating point values, boolean values ‚Äã‚Äãlisted below.  In addition, these functions have duplicates with the ORIG suffix, allowing you to get the value of the record as written in the <em>php.ini file</em> (before it could be changed using the <em>.htaccess</em> file or the <em>ini_set</em> function). <br><table><tbody><tr><th>  <strong>present value</strong> </th><th>  <strong>Original meaning</strong> </th><th>  <strong>Type of</strong> </th></tr><tr><td>  INI_STR (name) </td><td>  INI_ORIG_STR (name) </td><td>  Char * (NULL terminated) </td></tr><tr><td>  INI_INT (name) </td><td>  INI_ORIG_INT (name) </td><td>  signed long </td></tr><tr><td>  INI_FLT (name) </td><td>  INI_ORIG_FLT (name) </td><td>  signed double </td></tr><tr><td>  INI_BOOL (name) </td><td>  INI_ORIG_BOOL (name) </td><td>  Zend_bool </td></tr></tbody></table><br>  Moving on to the function <em>PHP_INI_ENTRY</em> .  The first parameter is the string that contains the name of the entry you are interested in the <em>php.ini file</em> .  In order to avoid collisions between the names of records in <em>php.ini</em> , you should use the same conventions as in naming functions: the name must begin with a prefix that matches the name of the extension.  The agreement also provides that the separator of the extension name from the original setting name in the INI files must be a period.  In this case, the name of the setting will look like <em>hello.greeting</em> . <br>  The second parameter is the initial value of the setting, which is always specified as char *, regardless of whether the value is a number or not.  This is a consequence of the fact that all the settings in the INI files are inherently textual, since the file itself is textual.  Only subsequent use of the <em>INI_INT</em> , <em>INI_FLT</em> or <em>INI_BOOL</em> macros in the script causes a conversion of their types. <br>  The third parameter is the access level modifier.  This is a bitmask that determines when and how a given INI setting can be modified.  For some settings, such as <em>register_globals</em> , it simply does not make sense to allow changing the value inside the script using the <em>ini_set</em> function, since this setting makes sense only during the preparation of the processing of the request - before the script is given the opportunity to work.  Others, such as <em>allow_url_fopen</em> , are administrative settings that users should not have the right to modify either through <em>ini_set</em> or through <em>.htaccess</em> directives.  The default value for this parameter is the value of <em>PHP_INI_ALL</em> , indicating that the value of the setting can change anywhere.  <em>PHP_INI_SYSTEM | PHP_INI_PERDIR</em> values ‚Äã‚Äãare also possible, indicating that the setting value can be changed via php.ini or a directive in the .htaccess file, but through the ini_set () function.  Or perhaps the value of <em>PHP_INI_SYSTEM</em> , meaning that the setting can only be changed via the <em>php.ini file</em> and nowhere else. <br><br>  The last fourth parameter allows you to specify a callback function (callback), called when changing settings using the <em>ini_set</em> function.  This allows extensions to have more control over the conditions for changing the setting or to call the corresponding function depending on the new setting value. <br><br><br><br><h1>  Global variables </h1><br>  Quite often, an extension needs to process a variable in a separate request, keeping its value independent of other requests that can be processed at the same time.  In a non-threaded SAPI, this can be done very simply: just declare a global variable in the source file and access it when you need it.  The problem is that since PHP is designed to work with multi-threaded web servers (such as Apache 2 and ISS), it needs to keep the global variables used by one thread separately from the global variables of the other.  PHP greatly simplifies this task by using the Thread Safe Resource Manager ( <strong>TSRM)</strong> abstraction layer, sometimes called <strong>ZTS</strong> (Zend Thread Safety).  In fact, this article has already used parts of the TSRM, which you did not even notice.  (Do not try to find them, as long as it is too difficult for you). <br><br>  The first part of creating a thread-safe global variable, like any other global variable, is in its declaration.  As an example, we will declare one global variable of the long type, the initial value of which will be 0. Each time the hello_long function is called, we will increase the value of the global variable and return its value. <br>  Add the following code snippet to the <em>php_hello.h</em> file immediately after the <em>#define PHP_HELLO_H line</em> : <br><blockquote> <code><font color="black">#ifdef ZTS <br> #include <font color="#A31515">"TSRM.h"</font> <br> <font color="#0000ff">#endif</font> <br> <br> ZEND_BEGIN_MODULE_GLOBALS(hello) <br> <font color="#0000ff">long</font> counter; <br> ZEND_END_MODULE_GLOBALS(hello) <br> <br> #ifdef ZTS <br> <font color="#0000ff">#define</font> HELLO_G(v) TSRMG(hello_globals_id, zend_hello_globals *, v) <br> <font color="#0000ff">#else</font> <br> <font color="#0000ff">#define</font> HELLO_G(v) (hello_globals.v) <br> <font color="#0000ff">#endif</font></font> <br> <br></code> </blockquote><br>  You will also have to use the <em>RINIT</em> method, so you need to declare its prototype in the title: <br><blockquote> <code><font color="black">PHP_MINIT_FUNCTION(hello); <br> PHP_MSHUTDOWN_FUNCTION(hello); <br> PHP_RINIT_FUNCTION(hello);</font> <br> <br></code> </blockquote><br>  Now let's go to the file <em>hello.c</em> and add the following code after the include block: <br><blockquote> <code><font color="black">#ifdef HAVE_CONFIG_H <br> #include <font color="#A31515">"config.h"</font> <br> <font color="#0000ff">#endif</font> <br> <br> #include <font color="#A31515">"php.h"</font> <br> #include <font color="#A31515">"php_ini.h"</font> <br> #include <font color="#A31515">"php_hello.h"</font> <br> <br> ZEND_DECLARE_MODULE_GLOBALS(hello)</font> <br></code> </blockquote><br>  Change <em>hello_module_entry</em> by adding <em>PHP_RINIT (hello) to it</em> : <br><blockquote> <code><font color="black">zend_module_entry hello_module_entry = { <br> <font color="#0000ff">#if</font> ZEND_MODULE_API_NO &gt;= 20010901 <br> STANDARD_MODULE_HEADER, <br> <font color="#0000ff">#endif</font> <br> PHP_HELLO_WORLD_EXTNAME, <br> hello_functions, <br> PHP_MINIT(hello), <br> PHP_MSHUTDOWN(hello), <br> PHP_RINIT(hello), <br> NULL, <br> NULL, <br> <font color="#0000ff">#if</font> ZEND_MODULE_API_NO &gt;= 20010901 <br> PHP_HELLO_WORLD_VERSION, <br> <font color="#0000ff">#endif</font> <br> STANDARD_MODULE_PROPERTIES <br> };</font> <br></code> </blockquote><br><br>  And change your <em>MINIT</em> function along with adding a few more functions to handle initialization at the start of the request: <br><blockquote> <code><font color="black"><font color="#0000ff">static</font> <font color="#0000ff">void</font> php_hello_init_globals(zend_hello_globals *hello_globals) <br> { <br> } <br> <br> PHP_RINIT_FUNCTION(hello) <br> { <br> HELLO_G(counter) = 0; <br> <br> <font color="#0000ff">return</font> SUCCESS; <br> } <br> <br> PHP_MINIT_FUNCTION(hello) <br> { <br> ZEND_INIT_MODULE_GLOBALS(hello, php_hello_init_globals, NULL); <br> <br> REGISTER_INI_ENTRIES(); <br> <br> <font color="#0000ff">return</font> SUCCESS; <br> }</font> <br> <br></code> </blockquote><br>  And finally, you can change the <em>hello_long</em> function by adding a global variable to it: <br><blockquote> <code><font color="black">PHP_FUNCTION(hello_long) <br> { <br> HELLO_G(counter)++; <br> <br> RETURN_LONG(HELLO_G(counter)); <br> }</font> <br> <br></code> </blockquote><br>  In the changes you made to the <em>php_hello.h</em> file, you used a couple of macros - <em>ZEND_BEGIN_MODULE_GLOBALS</em> and <em>ZEND_END_MODULE_GLOBALS</em> .  With their help, the <em>zend_hello_globals</em> structure was defined, containing one long variable.  After that, the <em>HELLO_G</em> macro was defined, which allows, depending on the compilation mode (with or without multithreading), to get the value from the thread pool or just take it from the global scope. <br>  In the <em>hello.c</em> file, using the <em>ZEND_DECLARE_MODULE_GLBALS</em> macro <em>,</em> you declared the <em>zend_hello_globals</em> structure either as a global (non-thread safe) or as a member of the resource pool of the stream.  We, as authors of extensions, do not need to think about this mechanism, since ZE takes over all the work.  And finally, you use the <em>ZEND_INIT_MODULE_GLOBALS</em> function to allocate a thread-safe resource identifier. <br>  You may have noticed that the <em>php_hello_init_globals</em> function actually does nothing.  In addition, the initialization of the counter value 0 was in the function <em>RINIT</em> .  Why? <br>  The key to answering this question lies in the moment when these functions are called.  The <em>php_hello_init_globals</em> function <em>is</em> called only when starting a new process or thread.  However, each process can serve more than one request, so using this function to initialize our counter with a value of 0 will be true only for the first request.  A subsequent query to the same process will still work with the old value of the counter and, therefore, will not start the report from scratch.  To initialize the counter with a value of 0 for each request, we used the <em>RINIT</em> function, which, as you have already read, is called before each script processing request.  We included the <em>php_hello_init_globals</em> function in our code at least due to the fact that passing NULL as the corresponding parameter <em>ZEND_INIT_MODULE_GLOBALS</em> to the <em>init</em> function will result in a segmentation error for non- <em>threading</em> platforms. <br><br><br><br><h1>  INI-settings and global variables </h1><br>  As you already know, the settings in the php.ini file, declared using the <em>PHP_INI_ENTRY</em> function, are read as strings and, if necessary, converted to other formats using the <em>INI_INT</em> , <em>INI_FLT</em> and <em>INI_BOOL functions</em> .  However, some settings during script execution may be requested too often, which will lead to a large number of unnecessary read operations from a file.  Fortunately, it is possible to instruct ZEs to store INI settings in a particular data type and perform type casting only when the setting value is changed.  Let's test this feature in the work by declaring another INI setting, this time of type boolean, which determines whether the counter should currently decrease or increase.  We begin by modifying the <em>MODULE_GLOBALS</em> block in the p <em>hp_hello.h</em> file as follows: <br><blockquote> <code><font color="black">ZEND_BEGIN_MODULE_GLOBALS(hello) <br> <font color="#0000ff">long</font> counter; <br> zend_bool direction; <br> ZEND_END_MODULE_GLOBALS(hello)</font> <br> <br></code> </blockquote><br>  The next step is to declare the INI setting by changing the <em>PHP_INI_BEGIN</em> block: <br><blockquote> <code><font color="black">PHP_INI_BEGIN() <br> PHP_INI_ENTRY( <font color="#A31515">"hello.greeting"</font> , <font color="#A31515">"Hello World"</font> , PHP_INI_ALL, NULL) <br> STD_PHP_INI_ENTRY( <font color="#A31515">"hello.direction"</font> , <font color="#A31515">"1"</font> , PHP_INI_ALL, OnUpdateBool, direction, zend_hello_globals, hello_globals) <br> PHP_INI_END()</font> <br> <br></code> </blockquote><br>  Now initialize the setting in the <em>init_globals</em> function: <br><blockquote> <code><font color="black"><font color="#0000ff">static</font> <font color="#0000ff">void</font> php_hello_init_globals(zend_hello_globals *hello_globals) <br> { <br> hello_globals-&gt;direction = 1; <br> }</font> <br> <br></code> </blockquote><br>  And finally, use the INI-setting value in the <em>hello_long</em> function to select the operation on the counter: <br><blockquote> <code><font color="black">PHP_FUNCTION(hello_long) <br> { <br> <font color="#0000ff">if</font> (HELLO_G(direction)) { <br> HELLO_G(counter)++; <br> } <font color="#0000ff">else</font> { <br> HELLO_G(counter)--; <br> } <br> <br> RETURN_LONG(HELLO_G(counter)); <br> }</font> <br> <br></code> </blockquote><br>  That's all!  Using the <em>OnUpdateBool</em> method (the method is part of the ZE), passed as the third parameter of the <em>STD_PHP_INI_ENTRY</em> macro, the type of the setting value obtained from the <em>php.ini file</em> , <em>.htaccess</em> , or using the <em>ini_set</em> function will be automatically <em>converted</em> to the corresponding TRUE / FALSE value, which you can get right inside the script.  The last three parameters of the <em>STD_PHP_INI_ENTRY</em> function <em>tell</em> PHP which global variable to change, what the structure of the global variables of our extension looks like, and the name of the global variable container in which they are contained. <br><br><br><br><h1>  What's next? </h1><br>  In this article, we explored the structure of a simple PHP extension that exports functions that return values, loads and processes INI settings, saving them throughout the processing of a request. <br><br>  In the <a href="http://devzone.zend.com/node/view/id/1022">next article</a> we will look at the internal structure of PHP variables, how they are stored and processed.  <em>Let's</em> work with the <em>zend_parse_parameters</em> function used to get parameters from a program when calling a function, and open ways to return more complex results from a function, such as an array, an object, and a resource. <br><br><br><br><h1>  PS </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some places, the translation has a rather free format, which is a consequence of the difficulties of translation, which I have not been able to fully overcome. </font><font style="vertical-align: inherit;">In addition, the translation contains a number of minor additions that seemed relevant to me. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The process of building an extension according to the article is verified on the </font></font><a href="http://ru2.php.net/get/php-5.3.2.tar.bz2/from/a/mirror"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP 5.3.2 source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><a href="http://devzone.zend.com/member/4580-SaraMG"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">author</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has several articles on this topic: </font></font><a href="http://devzone.zend.com/node/view/id/1021"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://devzone.zend.com/node/view/id/1022"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://devzone.zend.com/node/view/id/1023"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://devzone.zend.com/node/view/id/1024"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The fourth article apparently will not see the light of view due to the publication of the book </font></font><a href="http://www.amazon.com/Extending-Embedding-PHP-Sara-Golemon/dp/067232704X"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúExtending and Embedding PHP‚Äù by the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> author of this book </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also </font></font><a href="http://www.php.net/manual/en/internals2.php"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">read</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about Zend Engine </font><a href="http://www.php.net/manual/en/internals2.php"><font style="vertical-align: inherit;">on php.net</font></a><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/98862/">https://habr.com/ru/post/98862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../98857/index.html">Use Google SketchUp to create a music video.</a></li>
<li><a href="../98858/index.html">Authorized training: is it worth it?</a></li>
<li><a href="../98859/index.html">Gigabyte gsmart S1205. 2 sim communicator</a></li>
<li><a href="../98860/index.html">WD SiliconEdge Blue: SSD from the famous manufacturer of hard drives</a></li>
<li><a href="../98861/index.html">How to make a project, the right investor?</a></li>
<li><a href="../98863/index.html">Hoster, put me a module, eh?</a></li>
<li><a href="../98865/index.html">All your old consoles inside the gamepad from any of them</a></li>
<li><a href="../98867/index.html">Social networks. Models of information influence, control and confrontation</a></li>
<li><a href="../98868/index.html">Mail.Ru launched social plugins for internet sites.</a></li>
<li><a href="../98873/index.html">High-tech spying on students on exams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>