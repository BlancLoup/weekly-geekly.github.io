<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of Wi-Fi network scanner for Sailfish OS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Sometimes, when solving work tasks, there is a need for information about the surrounding Wi-Fi networks: channel, power, encryption ty...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of Wi-Fi network scanner for Sailfish OS</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  Sometimes, when solving work tasks, there is a need for information about the surrounding Wi-Fi networks: channel, power, encryption type, etc. And if there is a lot of utilities for popular Android and iOS mobile apps, then only <a href="https://openrepos.net/content/osanwe/wifi-analyser">one</a> for Sailfish OS.  Today, using this utility as an example, obtaining information about the surrounding Wi-Fi networks and displaying it in two ways will be disassembled: list and graphically. <br><br>  Before studying the material, it is desirable to have a basic understanding of the <a href="https://habrahabr.ru/post/305510/">development</a> under Sailfish OS and the utility <code><a href="https://wiki.archlinux.org/index.php/WPA_supplicant_(%25D0%25A0%25D1%2583%25D1%2581%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9)">wpa_cli</a></code> . <br><a name="habracut"></a><br><h3>  Getting information about Wi-Fi networks </h3><br>  There are two main ways to get information about the Wi-Fi networks surrounding the device: use the <code>wpa_cli</code> utility or the undocumented <code>TechnologyModel</code> element from the <code>MeeGo.Connman</code> module. <br><br>  The first method is a head-on solution.  Using the <code>wpa_cli</code> utility in Sailfish OS is no different from another Linux distribution: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">wpa_cli scan &amp;&amp; wpa_cli scan_results</b> <div class="spoiler_text"> <code># wpa_cli scan <br> Selected interface 'wlan0' <br> OK <br> # wpa_cli scan_results <br> Selected interface 'wlan0' <br> bssid / frequency / signal level / flags / ssid <br> 10:bf:48:4b:2b:f4 2412 -46 [WPA-PSK-CCMP][WPA2-PSK-CCMP][ESS] Asd_496283 <br> d4:21:22:33:ec:46 2417 -57 [WPA2-PSK-CCMP][WPS][ESS] MGTS_243 <br> 78:94:b4:99:1c:41 2462 -59 [WPA2-PSK-CCMP][WPS][ESS] MGTS_GPON_8959 <br> 78:96:82:64:ea:fd 2427 -62 [WPA2-PSK-CCMP][WPS][ESS] Onlime248 <br> 90:f6:52:66:20:92 2412 -41 [WPA2-PSK-CCMP][ESS] Hearthstone <br> 14:cc:20:32:e7:04 2437 -65 [WPA2-PSK-CCMP][WPS][ESS] ViVa239 <br> 00:0e:8f:2f:ff:3c 2412 -67 [WPA-PSK-TKIP][WPA2-PSK-CCMP][WPS][ESS] Smart_box - 297 <br> d4:6e:0e:b0:17:16 2462 -73 [WPA2-PSK-CCMP+TKIP][WPS][ESS] MGTS_GPON_8959 <br> 94:4a:0c:ce:93:05 2462 -71 [WPA2-PSK-CCMP][WPS][ESS] MGTS_GPON_7870 <br> e8:94:f6:fa:43:86 2417 -77 [WPA2-PSK-CCMP][ESS] Home236 <br> be:85:56:e2:9a:fc 2427 -74 [WPA2-PSK-CCMP][WPS][ESS] DIRECT-HR-BRAVIA <br> c0:a0:bb:1d:4c:58 2412 -74 [WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][WPS][ESS] dlink-4C58 <br> 40:3d:ec:31:ca:fb 2432 -86 [WPA-PSK-CCMP+TKIP][WPA2-PSK-CCMP+TKIP][ESS] TV kinescope <br> fc:2d:5e:45:db:35 2437 -82 [WPA2-PSK-CCMP+TKIP][WPS][ESS] Matthew <br> 00:0e:8f:6e:47:ba 2412 -65 [WPA-PSK-TKIP][WPA2-PSK-CCMP][WPS][ESS] Genya <br> c0:a0:bb:81:c7:4a 2447 -83 [WPA2-PSK-CCMP][ESS] mrnext-245 <br> d8:fe:e3:f9:26:45 2437 -66 [WPA-PSK-CCMP][WPA2-PSK-CCMP][ESS] NBN</code> <br> </div></div><br>  This approach has two main problems.  First, it requires superuser rights.  Secondly, it is necessary to implement the reading of the result of the console command execution. <br><br>  The first problem is solved by requesting a password from the user when starting the program and further using the <a href="http://doc.qt.io/qt-5/qprocess.html">QProcess</a> module: <br><br><div class="spoiler">  <b class="spoiler_title">Interacting with wpa_cli</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       wpa_cli. * @param password -     root. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WpaCliHelper::callWpaCli(QString password) { <span class="hljs-comment"><span class="hljs-comment">//    QProcess process; //    Wi-Fi   root process.start(QString("/bin/bash -c \"echo %1 | devel-su wpa_cli scan\"").arg((password))); //    if (!process.waitForFinished()) { //   ,   emit gotScanError(); return; } //     mWifiInfo = process.readAll(); //    ,   if (mWifiInfo.contains("Auth failed")) { emit gotAuthError(); return; } //      root process.start(QString("/bin/bash -c \"echo %1 | devel-su wpa_cli scan_results\"").arg((password))); //    if (!process.waitForFinished()) { //   ,   emit gotResultError(); return; } //     mWifiInfo = process.readAll(); //      emit calledWpaCli(); }</span></span></code> </pre> <br></div></div><br>  One function is also enough to read the scan results: <br><br><div class="spoiler">  <b class="spoiler_title">Getting the wpa_cli result</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       wpa_cli. * @param info -   wpa_cli. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WifiInfoParser::parseInfo(QString info) { <span class="hljs-comment"><span class="hljs-comment">//      wifiInfo.clear(); //      QStringList networks = info.split('\n'); //      if (networks.length() == 3) { networkCount = 0; emit parsed(PARSE_COMPLETED_WITH_NO_NETWORKS); } //     Wi-Fi networkCount = networks.length() - 3; for (int i = 0; i &lt; networkCount; i++) { //      QStringList data = networks.at(i+2).split('\t'); //     wifiInfo &lt;&lt; QVariant::fromValue( (QStringList() &lt;&lt; QString::number(calculateChannel(data[1].toInt())) //   &lt;&lt; data[2] //   &lt;&lt; data[4] //   &lt;&lt; data[0])); // BSSID  } //      emit parsed(PARSE_COMPLETED_CORRECTLY); }</span></span></code> </pre> <br></div></div><br>  However, requesting superuser privileges when launching an application can confuse a regular user, and, therefore, it is necessary to avoid using functions that require root access.  Therefore, as part of the task of obtaining information about the surrounding Wi-Fi networks, it is recommended to use the <code><a href="https://git.merproject.org/mer-core/libconnman-qt/tree/master">MeeGo.Connman</a></code> module, unfortunately not presented in the standard documentation. <br><br>  To use it, you need to add the following line: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MeeGo.Connman <span class="hljs-number"><span class="hljs-number">0.2</span></span></code> </pre> <br>  This module provides the necessary element for the task <code><a href="">TechnologyModel</a></code> , allowing just a few lines in the QML file to get structured information about the surrounding Wi-Fi networks: <br><br><pre> <code class="javascript hljs">TechnologyModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: networksList <span class="hljs-comment"><span class="hljs-comment">//    name: "wifi" //     }</span></span></code> </pre> <br>  However, it is necessary to update the information manually.  This is best done using the <code><a href="http://doc.qt.io/qt-5/qml-qtqml-timer.html">Timer</a></code> component: <br><br><pre> <code class="javascript hljs">Timer { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: updateTimer <span class="hljs-comment"><span class="hljs-comment">//    interval: 2000 //     running: true //   repeat: true //      triggeredOnStart: true //      onTriggered: networksList.requestScan() //     Wi-Fi }</span></span></code> </pre> <br>  Now all the necessary information is presented in a structured form, and the process of obtaining it does not require an administrator password.  Accordingly, you can proceed to the process of displaying the received data. <br><br>  It is worth noting that the same interface is also available for applications implemented in C ++.  An example of its use is <a href="https://git.merproject.org/mer-core/libconnman-qt/tree/master/examples/counters">published</a> in the repository of the module. <br><br><h3>  Display data list </h3><br>  The model described in the previous section returns a list of elements of the <code><a href="">NetworkService</a></code> type, which provides all the necessary information about the surrounding networks.  Of all the variety of the greatest interest for the scanner are the fields described in table 1. <br><br><table><caption>  Table 1. Fields used in the Wi-Fi network scanner. </caption><tbody><tr><th>  Field name </th><th>  Data type </th><th>  Description </th></tr><tr><td>  name </td><td>  QString </td><td>  Network name </td></tr><tr><td>  frequency </td><td>  quint16 </td><td>  Signal frequency </td></tr><tr><td>  strength </td><td>  uint </td><td>  Signal strength </td></tr><tr><td>  bssid </td><td>  QString </td><td>  Bssid </td></tr><tr><td>  security </td><td>  QStringList </td><td>  Encryption type </td></tr></tbody></table><br>  Now, knowing the way of storing information about networks and the <a href="https://sailfishos.org/develop/docs/silica/qml-sailfishsilica-sailfish-silica-silicalistview.html/">element</a> for drawing lists, you can readily display the obtained information (Figure 1): <br><br><div class="spoiler">  <b class="spoiler_title">List Display Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">SilicaListView { <span class="hljs-comment"><span class="hljs-comment">//    id: wifiInfoList //    anchors.fill: parent //    model: networksList //       delegate: Item { //    width: parent.width //   height: Theme.itemSizeHuge //        Column { //     anchors { fill: parent //     leftMargin: Theme.horizontalPageMargin //    rightMargin: Theme.horizontalPageMargin //    topMargin: Theme.paddingLarge //    } Row { //     //      anchors.right: parent.right anchors.left: parent.left height: childrenRect.height //      Label { //   width: parent.width / 2 //     horizontalAlignment: Text.AlignLeft //      font.bold: true //    text: modelData.name //   truncationMode: TruncationMode.Fade //     } Label { // ,   width: parent.width / 4 //     horizontalAlignment: Text.AlignRight //      text: (calculateChannel(modelData.frequency) + 1) + " ch." //   } Label { //    width: parent.width / 4 //     horizontalAlignment: Text.AlignRight //      text: (modelData.strength - 120) + " dBm" //    } } Item { //   //      anchors.right: parent.right anchors.left: parent.left height: childrenRect.height //      Label { // BSSID  anchors.left: parent.left //   text: "bssid: " + modelData.bssid // BSSID  } Label { //   anchors.right: parent.right //   text: modelData.security.join("/") //   } } ProgressBar { //      width: parent.width //      minimumValue: 0 //    maximumValue: 100 //    value: modelData.strength //    } } } VerticalScrollDecorator {} //    }</span></span></code> </pre> <br></div></div><br>  To determine the channel number by signal frequency, the <a href="https://ru.wikipedia.org/wiki/IEEE_802.11">standard table of</a> channel separation by frequency and a simple function based on it are used: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *        . * @param frequency -   Wi-Fi * @return      Wi-Fi */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateChannel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">frequency</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> channel = (frequency - <span class="hljs-number"><span class="hljs-number">2412</span></span>) / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> channel &gt; <span class="hljs-number"><span class="hljs-number">12</span></span> ? <span class="hljs-number"><span class="hljs-number">13</span></span> : channel; }</code> </pre> <br><img src="https://habrastorage.org/webt/qe/vh/4p/qevh4pmqzs5t5zf53m0hdz5yune.png" width="300" alt="Figure 1. Displaying surrounding Wi-Fi networks in a list."><br>  Figure 1. Displaying surrounding Wi-Fi networks in a list. <br><br>  It is also necessary to check for the possibility of obtaining a list of networks and the number of elements in it.  Responsible for this are the fields <code>powered</code> and <code>count</code> , respectively.  If the network interface is turned off or there are no networks around, the user needs to display a corresponding message (Figure 2).  To do this, use the <code><a href="https://sailfishos.org/develop/docs/silica/qml-sailfishsilica-sailfish-silica-viewplaceholder.html/">ViewPlaceholder</a></code> element: <br><br><pre> <code class="javascript hljs">ViewPlaceholder { <span class="hljs-attr"><span class="hljs-attr">enabled</span></span>: !networksList.powered <span class="hljs-comment"><span class="hljs-comment">//      text: qsTr("Please, turn WiFi on") //    } ViewPlaceholder { enabled: networksList.powered &amp;&amp; networksList.count === 0 //      text: qsTr("There are no WiFi networks") //    }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/bh/su/nf/bhsunfro6np4gpnaedompfe9s6u.png" width="300" alt="Figure 2. The message about the need to turn on Wi-Fi."><br>  Figure 2. The message about the need to turn on Wi-Fi. <br><br><h3>  Graphic display of data </h3><br>  The purpose of the graphical display of information about Wi-Fi networks is to visually show the overlap between them.  Therefore, only the values ‚Äã‚Äãof the network name, the strength and frequency of its signal will be required. <br><br>  First you need to prepare a screen for drawing.  To do this, use the <code>Canvas</code> element, on which the graphics are <code>onPaint</code> when the <code>onPaint</code> signal <code>onPaint</code> .  Also, with the help of the <code>Connections</code> element, the graph is redrawn when changing information about the surrounding Wi-Fi networks.  As in the case with the list, the possibility is set to display a message to the user if it is impossible to obtain the necessary data. <br><br><div class="spoiler">  <b class="spoiler_title">Graphic display code</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Page { ViewPlaceholder { <span class="hljs-comment"><span class="hljs-comment">//      Wi-Fi enabled: !networksList.powered text: qsTr("Please, turn WiFi on") } ViewPlaceholder { //       Wi-Fi enabled: networksList.powered &amp;&amp; networksList.count === 0 text: qsTr("There are no WiFi networks") } SilicaFlickable { //    anchors.fill: parent Canvas { //    id: graph //    anchors { //         fill: parent leftMargin: Theme.horizontalPageMargin rightMargin: Theme.horizontalPageMargin topMargin: Theme.paddingLarge bottomMargin: Theme.paddingLarge } onPaint: drawGraph() //    } } Connections { //    target: networksList //   -       onScanRequestFinished: graph.requestPaint() //      } onOrientationChanged: graph.requestPaint() //      }</span></span></code> </pre> <br></div></div><br>  The function of drawing graphics can be divided into three parts.  First, the drawing field is initialized and cleared.  Then coordinates of axes and grids are calculated in accordance with the screen.  And finally, the rendering is done. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawGraph</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = graph.getContext(<span class="hljs-string"><span class="hljs-string">"2d"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    context.clearRect(0, 0, graph.width, graph.height); //     context.lineWidth = 3; //      context.strokeStyle = "gray"; //    context.fillStyle = "gray"; //    context.font = "12pt sans-serif"; //    //        var channels = calculateChannelsPositions(graph.width); var levels = calculateSignalLevelsPositions(graph.height) drawAxes(context, channels, levels); //      Wi-Fi if (networksList.count === 0) return; drawWifiFigures(context, graph.width, graph.height, channels); }</span></span></code> </pre> <br>  The coordinates of the axes and grids are calculated by evenly separating the screen space between the channels and possible signal levels.  It also uses the above table of division of Wi-Fi channels by frequency. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       Wi-Fi property variant channelsInfo: [11, 16, 21, 26, 31, 36, 41, 46, 51, 56, 61, 66, 71, 83] /** *          . * @:param: width -     * @:return: channels -      */ function calculateChannelsPositions(width) { var channels = []; var step = (width - Theme.horizontalPageMargin) / 94; for (var index in channelsInfo) { channels[index] = channelsInfo[index] * step + Theme.horizontalPageMargin; } return channels; } /** *           . * @:param: height -     * @:return: levels -       */ function calculateSignalLevelsPositions(height) { var levels = []; var step = (height - Theme.paddingLarge) / 10; for (var index = 0; index &lt; 10; ++index) { levels[index] = index * step + Theme.paddingLarge; } return levels; }</span></span></code> </pre> <br>  After obtaining the coordinate values ‚Äã‚Äãin pixels, it becomes possible to draw the axes and the grid.  At this stage, the main work falls on the <code><a href="http://doc.qt.io/qt-5/qml-qtquick-context2d.html">moveTo</a></code> and <code><a href="http://doc.qt.io/qt-5/qml-qtquick-context2d.html">lineTo</a></code> to move the brush and draw a straight line, respectively. <br><br><div class="spoiler">  <b class="spoiler_title">Grid drawing code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *    . * @:param: context -    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawGraphBounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context</span></span></span><span class="hljs-function">) </span></span>{ context.beginPath(); context.moveTo(<span class="hljs-number"><span class="hljs-number">2</span></span> * Theme.horizontalPageMargin, Theme.paddingLarge); context.lineTo(graph.width - Theme.horizontalPageMargin, Theme.paddingLarge); context.lineTo(graph.width - Theme.horizontalPageMargin, graph.height - Theme.paddingLarge); context.lineTo(<span class="hljs-number"><span class="hljs-number">2</span></span> * Theme.horizontalPageMargin, graph.height - Theme.paddingLarge); context.closePath(); context.stroke(); } <span class="hljs-comment"><span class="hljs-comment">/** *    . * @:param: context -    * @:param: channelX -    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawChannelAxe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context, channelX</span></span></span><span class="hljs-function">) </span></span>{ context.beginPath(); context.moveTo(channelX, Theme.paddingLarge); context.lineTo(channelX, graph.height - Theme.paddingLarge); context.closePath(); context.stroke(); } <span class="hljs-comment"><span class="hljs-comment">/** *    . * @:param: context -    * @:param: channelIndex -   * @:param: channelX -    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawChannelNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context, channelIndex, channelX</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(channelIndex) + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> textWidth = context.measureText(text).width; context.fillText(text, channelX - (textWidth / <span class="hljs-number"><span class="hljs-number">2</span></span>), graph.height); } <span class="hljs-comment"><span class="hljs-comment">/** *     . * @:param: context -    * @:param: channels -     */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawChannelsAxes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context, channels</span></span></span><span class="hljs-function">) </span></span>{ context.lineWidth = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> channelIndex <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> channels) { drawChannelAxe(context, channels[channelIndex]); drawChannelNumber(context, channelIndex, channels[channelIndex]); } } <span class="hljs-comment"><span class="hljs-comment">/** *     . * @:param: context -    * @:param: signalLevelY -    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawSignalLevelAxe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context, signalLevelY</span></span></span><span class="hljs-function">) </span></span>{ context.beginPath(); context.moveTo(<span class="hljs-number"><span class="hljs-number">2</span></span> * Theme.horizontalPageMargin, signalLevelY); context.lineTo(graph.width - Theme.horizontalPageMargin, signalLevelY); context.closePath(); context.stroke(); } <span class="hljs-comment"><span class="hljs-comment">/** *     . * @:param: context -    * @:param: signalLevel -   * @:param: signalLevelY -    */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawSignalLevel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context, signalLevel, signalLevelY</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signalLevel === <span class="hljs-string"><span class="hljs-string">'0'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text = <span class="hljs-string"><span class="hljs-string">'-'</span></span> + signalLevel + <span class="hljs-string"><span class="hljs-string">'0'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> textWidth = context.measureText(text).width; context.fillText(text, Theme.horizontalPageMargin - (textWidth / <span class="hljs-number"><span class="hljs-number">2</span></span>), signalLevelY); } <span class="hljs-comment"><span class="hljs-comment">/** *      . * @:param: context -    * @:param: levels -     */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawSignalLevelsAxes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context, levels</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> levelIndex <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> levels) { drawSignalLevelAxe(context, levels[levelIndex]); drawSignalLevel(context, levelIndex, levels[levelIndex]); } } <span class="hljs-comment"><span class="hljs-comment">/** *        . * @:param: context -    * @:param: channels -    * @:param: levels -      */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawAxes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context, channels, levels</span></span></span><span class="hljs-function">) </span></span>{ drawGraphBounds(context); drawChannelsAxes(context, channels); drawSignalLevelsAxes(context, levels); }</code> </pre> <br></div></div><br>  After the grid is drawn, you can proceed to the display of graphs of surrounding networks.  <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F_%25D0%2591%25D0%25B5%25D0%25B7%25D1%258C%25D0%25B5">Bezier curves</a> will be used for this: <br><br><div class="spoiler">  <b class="spoiler_title">Network Graphics Drawing Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    property var strokeColors: ["rgb(255, 0, 0)", "rgb(128, 128, 0)", "rgb(255, 255, 0)", "rgb( 0, 128, 0)", "rgb( 0, 255, 0)", "rgb( 0, 128, 128)", "rgb( 0, 255, 255)", "rgb( 0, 0, 128)", "rgb( 0, 0, 255)", "rgb(128, 0, 128)", "rgb(255, 0, 255)", "rgb(128, 0, 0)"] //    ( ) property var fillColors: ["rgba(255, 0, 0, 0.33)", "rgba(128, 128, 0, 0.33)", "rgba(255, 255, 0, 0.33)", "rgba( 0, 128, 0, 0.33)", "rgba( 0, 255, 0, 0.33)", "rgba( 0, 128, 128, 0.33)", "rgba( 0, 255, 255, 0.33)", "rgba( 0, 0, 128, 0.33)", "rgba( 0, 0, 255, 0.33)", "rgba(128, 0, 128, 0.33)", "rgba(255, 0, 255, 0.33)", "rgba(128, 0, 0, 0.33)"] /** *   y-    . * @:param: height -     * @:param: level -    * @:return: y-    */ function calculateCurrentSignalLevelPosition(height, level) { return (height - Theme.paddingLarge) / 100 * Math.abs(level) + Theme.paddingLarge; } /** *   x-    . * @:param: width -     * @:param: channel -    * @:return: x-     */ function calculateBoundsPositionForChannel(width, channel) { var step = (width - Theme.horizontalPageMargin) / 94; var left = (channelsInfo[channel] - 11) * step + Theme.horizontalPageMargin; var right = (channelsInfo[channel] + 11) * step + Theme.horizontalPageMargin; return [left, right]; } /** *       . * http://codetheory.in/calculate-control-point-to-make-your-canvas-curve-hit-a-specific-point/ * @:param: channelCoord -    * @:param: levelPosition -     * @:param: bounds -     * @:return:    */ function calculateCurrentPoint(channelCoord, levelPosition, bounds) { var cpx = 2 * channelCoord - (bounds[0] + bounds[1]) / 2; var cpy = 2 * levelPosition - (graph.height + graph.height - (2 * Theme.paddingLarge)) / 2; return { x: cpx, y: cpy }; } /** *     Wi-Fi    . * @:param: context -    () * @:param: channelCoord -   * @:param: levelPosition -    * @:param: bounds -    */ function drawWifiFigure(context, channelCoord, levelPosition, bounds) { var cp = calculateCurrentPoint(channelCoord, levelPosition, bounds); context.beginPath(); context.moveTo(bounds[0], graph.height - Theme.paddingLarge); context.quadraticCurveTo(cp.x, cp.y, bounds[1], graph.height - Theme.paddingLarge); context.closePath(); context.stroke(); context.fill(); } /** *       . * @:param: context -    () * @:param: wifiInfo -      Wi-Fi * @:param: channels -   * @:param: levelPosition -    */ function drawWifiName(context, wifiInfo, channels, levelPosition) { var textWidth = context.measureText(wifiInfo.name).width; context.fillText(wifiInfo.name, channels[calculateChannel(wifiInfo.frequency)] - (textWidth / 2), levelPosition - Theme.paddingSmall); } /** *      . * @:param: context -    () * @:param: width -     * @:param: height -     * @:param: channels -   */ function drawWifiFigures(context, width, height, channels) { context.lineWidth = 2; for (var networkIndex = 0; networkIndex &lt; networksList.count; ++networkIndex) { var levelPosition = calculateCurrentSignalLevelPosition(height, (networksList.get(networkIndex).strength - 120)) var bounds = calculateBoundsPositionForChannel(width, calculateChannel(networksList.get(networkIndex).frequency)) context.strokeStyle = strokeColors[networkIndex % strokeColors.length]; context.fillStyle = fillColors[networkIndex % fillColors.length]; drawWifiFigure(context, channels[calculateChannel(networksList.get(networkIndex).frequency)], levelPosition, bounds); context.fillStyle = context.strokeStyle; drawWifiName(context, networksList.get(networkIndex), channels, levelPosition); } }</span></span></code> </pre> <br></div></div><br>  At the creation of a network of graphics ends.  The result is shown in Figure 3. <br><br><img src="https://habrastorage.org/webt/8t/x_/f-/8tx_f-7kixrcn69my077frg27di.png" width="300" alt="Figure 3. Graphic display of Wi-Fi networks."><br>  Figure 3. Graphic display of Wi-Fi networks. <br><br><h3>  Conclusion </h3><br>  This article showed two ways to obtain information about the surrounding Wi-Fi networks and two ways to display it: a list and a schedule.  The full code of the finished application, as always, is available on <a href="https://github.com/osanwe/harbour-wifianalyzer">GitHub</a> . <br><br>  Questions and ideas arising in the course of development can always be discussed in the <a href="http://sailfish.su/telegram">Telegram-chat</a> and in <a href="http://sailfish.su/vk">the VKontakte group</a> . </div><p>Source: <a href="https://habr.com/ru/post/345750/">https://habr.com/ru/post/345750/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345740/index.html">What is Hashing? Under the hood of the blockchain</a></li>
<li><a href="../345742/index.html">How not to write on Habr: Antireyting 2017</a></li>
<li><a href="../345744/index.html">New release Oh, my code! How I became a VKontakte developer at 16</a></li>
<li><a href="../345746/index.html">Eat three donuts from UWP and not choke</a></li>
<li><a href="../345748/index.html">How to write in assembler in 2018</a></li>
<li><a href="../345752/index.html">Richard Hamming: ‚ÄúThe teacher must prepare the student for the student‚Äôs future, not for the teacher‚Äôs past‚Äù</a></li>
<li><a href="../345754/index.html">Blockchain technology in a new business model from a small candy store</a></li>
<li><a href="../345756/index.html">Is it logical that Google rejected the candidacy of Max Howell, author of Homebrew, for his inability to invert binary trees?</a></li>
<li><a href="../345758/index.html">Comparative testing of Smart IDReader on 5 computing complexes with Elbrus processors</a></li>
<li><a href="../345762/index.html">What you need to be able to not be afraid of losing your job</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>