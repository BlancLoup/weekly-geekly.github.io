<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>When did Phoenix kill Reils?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It happens that some problems can not be solved in your usual programming language. Suppose we were faced with the task of implementing real-time mess...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>When did Phoenix kill Reils?</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/59/d6/ac/59d6acd235ae7424743973.jpeg"></p><br><p>  It happens that some problems can not be solved in your usual programming language.  Suppose we were faced with the task of implementing real-time messaging with large volumes of traffic.  How to make it optimal?  For obvious reasons, Ruby is not the best option for this, so you have to start searching for alternatives.  Many ways will appear before you, and as for a rubist, the best choice would be to use Elixir. </p><br><p>  Elixir is a functional programming language with Ruby syntax, working on the Erlang virtual machine.  Therefore, for a person from Ruby‚Äôs world, familiarity with the language will be very easy.  Although in order to understand it completely, you will have to try, repeatedly <a href="https://wunsh.ru/docs">re-reading the documentation</a> . </p><br><p>  The answer to the question from the title and the mass of interesting about Elixir immediately under the cut. </p><a name="habracut"></a><br><blockquote>  <strong>Never!</strong>  <strong>Phoenix is ‚Äã‚Äãnot a killer Rails, but a partner</strong> </blockquote><br><br><p>  The structure of the web application on both platforms is quite similar.  And this is not surprising: one of the most significant members of the Phoenix community is a former member of the core team Reils, and most people involved in the development of the framework are rubists.  Some differences still exist. </p><br><ul><li>  Implementing the a la ‚ÄúClean Architecture‚Äù approach to building an application.  The most significant changes came with the latest version of Phoenix 1.3 at the moment.  Read more about this in <a href="https://habrahabr.ru/post/332898/">this article</a> .  Separating parts of Phoenix from parts of the application, limiting business logic to contexts, and using repositories for working with a database are all not typical of the Rails world. </li><li>  Umbrella applications <em>aka</em> Umbrella app - the idea of ‚Äã‚Äãabandoning the premature use of microservices and the separation of voluminous business logic into parts within one large application.  Read more about this feature of Elixir in <a href="https://wunsh.ru/docs/mix-otp/dependencies-and-umbrella-apps.html">this article</a> . </li><li>  Representations in Phoenix are called templates and look more like decorators, but theoretically this should not cause any particular difficulties, although it changes the idea of ‚Äã‚Äãinteraction, making it more like the <a href="http://hanamirb.org/">now popular Khans</a> . </li><li>  Another of the features of Phoenix - channels.  Each time you connect to a channel, a new process is created, which in the event of an error does not affect other connections.  We will look at this topic further below.  In addition, Phoenix offers a front-end library with excellent abstractions for connections to an unstructured web socket. </li><li>  All the delights of the Elixir language, which will be discussed below. </li></ul><br><p>  There is also a huge number of small differences, ranging from the built-in tools for working with the front-end, ending with ideas and philosophy different from Rails. </p><br><h2 id="virtualnaya-mashina-erlanga-i-s-chem-eyo-edyat">  Erlang's virtual machine and what it eats </h2><br><p> Ruby is an object-oriented programming language.  It is an interpreted language created by Yukihiro Matsumoto with a view to productivity and simplicity.  The elixir is a functional language created by Jos√© Walim and running on an Erlang virtual machine called <code>BEAM</code> .  Programs are compiled into a bytecode for <code>BEAM</code> , which looks like a single process of the operating system, but in fact harbors the whole universe. </p><br><p>  <code>BEAM</code> runs on the server continuously.  The Ruby process (and Rails) is started only when the server starts processing the request.  Therefore, if, for example, you need to perform some kind of action every hour, in the Reils environment you will have to use <code>CronJob</code> , while in Phoenix a little Elixir-program inside <code>BEAM</code> will take care of this. </p><br><pre> <code class="hljs lisp">defmodule Stack do use GenServer # Callbacks def handle_call(<span class="hljs-symbol"><span class="hljs-symbol">:pop</span></span>, _from, [h | t]) do {:reply, h, t} end def handle_cast({:push, item}, state) do {:noreply, [item | state]} end end # Start the server {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, pid} = GenServer.start_link(<span class="hljs-name"><span class="hljs-name">Stack</span></span>, [<span class="hljs-symbol"><span class="hljs-symbol">:hello</span></span>]) # This is the client GenServer.call(<span class="hljs-name"><span class="hljs-name">pid</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:pop</span></span>) #=&gt; <span class="hljs-symbol"><span class="hljs-symbol">:hello</span></span> GenServer.cast(<span class="hljs-name"><span class="hljs-name">pid</span></span>, {<span class="hljs-symbol"><span class="hljs-symbol">:push</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:world</span></span>}) #=&gt; <span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span> GenServer.call(<span class="hljs-name"><span class="hljs-name">pid</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:pop</span></span>) #=&gt; <span class="hljs-symbol"><span class="hljs-symbol">:world</span></span></code> </pre> <br><p>  In the Elixir to perform the task, there is the possibility to create a new process (which in the magical world of Erlang behaves more like a thread, although in fact it is neither the one nor the other), while in Ruby most of them have to put background tasks in a separate queue (for example , via <code>Sidekiq</code> ) so that you can scale independently of the web application. </p><br><p>  Since the processes are isolated, and when exchanging messages, a new copy of the data is created, you no longer have to worry about data damage or changes on the other side of the system.  The operations within the process are synchronous, so the order of its execution is much more adequate than in the same Node.  Another advantage is an efficient garbage collector.  Once the process has ‚Äúworked its way,‚Äù it frees the memory for the OS. </p><br><p>  Ruby streams ( <code>JRuby</code> , <code>Rubinius</code> ) tend to interact with data from other streams, which is then quite problematic to debug.  In such cases, the race condition develops fairly quickly. </p><br><h2 id="rabota-s-veb-soketami">  Work with web sockets </h2><br><p>  Real-time applications (for example, chat rooms) use a data exchange channel (for example, a web socket).  Creating such using the Phoenix - easy.  With Rails, this is also possible, but the <code>ActionCable</code> component, which serves connections to web sockets, will hardly cope with the first thousand simultaneous connections.  From the point of view of Phoenix, the <code>ActionCable</code> algorithm for sending messages from the server to the client is ridiculously simple, unreliable, and poorly scalable.  So that you understand how advantageous to use in this case, the Elixir and Phoenix: the application can easily handle a couple of hundred thousand simultaneous connections from one server. </p><br><p>  To be fair, if you run into problems with the Rails cable on a running application, I advise you <a href="https://github.com/anycable/anycable"><code>  AnyCable</code></a> , one of the implementations of which is made right on Erlang.  Thereby you will get the benefits of <code>BEAM</code> on the Rail application. </p><br><p>  Running large-scale web applications with <code>BEAM</code> especially enjoyable: scaling to multiple servers is very easy.  Creating a project in Phoenix, you can forget about the problems with scaling.  By the way about this ... You know that the <code>WhatsApp</code> server also works on <code>BEAM</code> ? </p><br><h3 id="-1">  ~~~ </h3><br><p>  <em>Many frankly declare that in order to make the application scalable, it is necessary to use the Elixir, because Ruby and Rails are not capable of it.</em> </p><br><p>  <em>This is extremely short-sighted advice, showing that its author is not entirely familiar with the concept of scaling.</em>  <em>Let Ruby is not the smartest programming language, but you can scale a typical Rails application without much effort.</em>  <em>Such an application is usually based on an architecture without resource sharing, which in most cases allows increasing the total number of processed requests per second by simply adding servers.</em> </p><br><p>  <em>Maybe not the cheapest option in terms of iron, but exactly scalable!</em> </p><br><h3 id="-2">  ~~~ </h3><br><h2 id="funkcionalnoe-programmirovanie-vs-oop">  Functional programming vs OOP </h2><br><p>  Sometimes the Elixir is slightly reminiscent of Ruby.  This is significantly confusing, because Ruby belongs to the world of object-oriented programming, and the Elixir is built on the principles of the functional.  These are two parallel universes!  If you and Ruby have long since switched to ‚Äúyou,‚Äù it will still take time to understand Elixir. </p><br><blockquote>  <strong>Phoenix - this is not just a nimble Rails, written on Elixir</strong> </blockquote><br><br><p>  Let's look at what is the process of sending messages in the Elixir, using the following module: </p><br><pre> <code class="hljs sql">defmodule Example <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> start_link <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> spawn(fn() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> receive <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:hello, pid} -&gt; IO.inspect(<span class="hljs-string"><span class="hljs-string">"Got hello from #{inspect pid}"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  And now let's open <code>IEx</code> : </p><br><pre> <code class="hljs smalltalk">iex(<span class="hljs-number"><span class="hljs-number">1</span></span>)&gt; pid = <span class="hljs-type"><span class="hljs-type">Example</span></span>.start_link() <span class="hljs-symbol"><span class="hljs-symbol">#PID</span></span>&lt;<span class="hljs-number"><span class="hljs-number">0.120</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>&gt; iex(<span class="hljs-number"><span class="hljs-number">2</span></span>)&gt; send pid, {:hello, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>()} <span class="hljs-comment"><span class="hljs-comment">"Got hello from "</span></span><span class="hljs-symbol"><span class="hljs-symbol">#PID</span></span>&lt;<span class="hljs-number"><span class="hljs-number">0.118</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>&gt;<span class="hljs-comment"><span class="hljs-comment">" "</span></span><span class="hljs-symbol"><span class="hljs-symbol">#PID</span></span>&lt;<span class="hljs-number"><span class="hljs-number">0.118</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>&gt;<span class="hljs-comment"><span class="hljs-comment">" {:hello, #PID&lt;0.118.0&gt;}</span></span></code> </pre> <br><p>  Looks like OOP, isn't it?  In the Erlang / Elixir community, even with humor, they note that these two languages ‚Äã‚Äãcorrespond more closely to OOP concepts than other popular programming languages.  So, Elixir is an object-oriented language?  Nothing like this.  But more on that later. </p><br><p>  The advantages of messaging are that the sender is known in advance, and the interaction of the processes can be controlled.  Visualization and debugging processes become much simpler compared to what happens with the usual methods of controlling parallel threads, such as locks and mutexes. </p><br><p>  Unlike object Ruby, a code on a functional Elixir consists of modules, each of which includes a set of functions, usually aimed at solving a particular type of problem.  A huge plus of the Elixir is that the results of certain actions are predictable. </p><br><p>  Arguments of each function are written in advance, which saves the developer from further difficulties, for example, with instance variables.  It also helps to avoid the above problem, when some part of the system interacts with data not intended for it. </p><br><h2 id="konkurentnost">  Competitiveness </h2><br><p>  About Ruby, you can say that his competitiveness is lame.  Yes, in some versions of Ruby stream concurrency is supported, but the built-in <code>MRI</code> (the original Ruby written in C language) method of synchronizing <code>GIL</code> streams prevents competitive execution of tasks.  It should be noted that Ruby still allows competitive input-output operations. </p><br><p>  The elixir is simply made for this.  Literally.  Competition in it is realized on the basis of the so-called ‚Äúmodel of actors‚Äù - a concept implemented by the Erlang virtual machine even before this term saw the light. </p><br><p>  The idea is that you can create isolated processes that interact with each other through the exchange of messages and do not affect the states of each other.  An example of such a model you saw in the previous section. </p><br><p>  It should be noted that rubists like the Elixir usually have no less than Ruby himself once liked.  The problem here can be switching from one language to another.  Each of them is good and attractive in its own way, but it is impossible to write simultaneously in two languages.  We'll have to make a choice. </p><br><h2 id="rabota-s-bazami-dannyh">  Work with databases </h2><br><p>  Let's compare the most popular tools for working with databases in Ruby and Elixir, respectively - <code>ActiveRecord</code> and <code>Ecto</code> .  Both allow you to make requests and use validations, but they still function completely differently.  For rubists, <code>ActiveRecord</code> is simple and easy to use; moreover, it does not require any knowledge of <code>SQL</code> .  The story with <code>Ecto</code> completely opposite: it is more difficult to understand, plus you need a basic knowledge of <code>SQL</code> . </p><br><pre> <code class="hljs sql">defmodule Sample.App <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ecto.Query <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Sample.Weather <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Sample.Repo <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> keyword_query <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Weather, <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: w.prcp &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> is_nil(w.prcp), <span class="hljs-keyword"><span class="hljs-keyword">select</span></span>: w Repo.all(<span class="hljs-keyword"><span class="hljs-keyword">query</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> pipe_query <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Weather |&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span>(city: <span class="hljs-string"><span class="hljs-string">"Krak√≥w"</span></span>) |&gt; order_by(:temp_lo) |&gt; <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) |&gt; Repo.all <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  It can be said that <code>ActiveRecord</code> is the secret weapon of the Rails ( <em>from which everyone really turned up their nose</em> ).  About <code>Ecto</code> this can not be said.  <code>Ecto</code> is good, but Phoenix is ‚Äã‚Äãon top without him, but Rails would not be himself without <code>ActiveRecord</code> . </p><br><h2 id="gemy-vs-pakety">  Gems vs packages </h2><br><p>  A heme is a code created by another developer that can be easily integrated into your application.  Essentially a regular library.  Most of the rubists in their projects constantly use the same set of gems.  It can be said that the code without gems is like food without salt.  To appreciate the full power of the geme ecosystem, take a <a href="https://ossert.evilmartians.io/%3Futm_source%3Dhabrahabr.ru%26utm_medium%3Dwunsh.ru">look here</a> . </p><br><p>  In the world of Elixir, such pieces of software from third-party developers are called packages.  The ecosystem of packages has not yet grown to the scale of the gems ecosystem (for more details <a href="https://elixir.libhunt.com/categories">, click here</a> ).  Judging from the way Phoenix and <code>Ecto</code> , packages should not create problems with updates in the future.  But you can say for sure only a couple of years later. </p><br><h2 id="skorost">  Speed </h2><br><blockquote>  It's safe to say: Phoenix is ‚Äã‚Äãfaster.  Much faster than Rails. </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  In the open spaces of the network you can find a lot of information about various performance tests, detailed and not so much.  It's funny, but when you try to load test and "overload" the server with the Elixir, the testing machine will rather fail, even despite the excellent performance indicators. </p><br><p>  And the speed of development in Ruby and Elixir (as well as on the Rails and Phoenix) takes approximately the same time.  Of course, moving from one framework to another for the first time, you need to understand that the loss of time is inevitable. </p><br><h2 id="bystroe-razvertyvanie-bez-prostoya">  Fast deployment without downtime </h2><br><p>  For most web applications, little downtime when updating software doesn‚Äôt cause any problems.  Many companies are trying to eliminate a 1-2 minute downtime without even realizing that they are throwing money down the drain.  Although in some cases, deployment without downtime is really necessary. </p><br><p>  We'll have to sweat to solve this problem in Ruby's environment, and the Elixir will cope with it with a bang: <code>BEAM</code> has built-in functionality for this purpose - hot-swappable code.  For many, it becomes a miracle.  Here are just the most likely have to abandon the Docker.  In short, some advantages. </p><br><p>  But do not be in a hurry to rejoice: if the update includes a database migration, it will not be so easy to achieve a lack of downtime for both technologies. </p><br><h2 id="yukihiro-vs-zhoze-devid-vs-kris"><del>  Yukihiro vs Jose </del>  David vs chris </h2><br><p>  Yukihiro Matsumoto and Jos√© Valim are really significant people, each of whom has done a lot for their language and community as a whole.  But let's now talk more about the creators of the driving forces of each of the languages.  Open source projects such as Rails and Phoenix, as a rule, have large development teams.  In such teams, product creators usually play a key role.  They determine the direction of development and conduct public activities. </p><br><p>  Creator Rails David Heinemeyer Hensson <em>aka</em> DHH has been giving presentations since the very first day of his brainchild.  He is a great speaker.  Earlier, his talks at RailsConf conferences always opened their eyes to many things.  Now he has lost a little position, but his contribution is still enormous. </p><br><p>  David is able to give visibility to dry examples.  In addition to programming, he is engaged in photography and motor sports.  But still his ability to ‚Äúrevive‚Äù a software product or a book (yes, he <a href="https://www.mann-ivanov-ferber.ru/books/luchiernoctar/rework1/">is also a writer</a> ) is difficult to compete with. </p><br><p>  David may seem arrogant, but he can be understood.  The Rails community is much larger than the Phoenix community, and David just physically couldn‚Äôt communicate with anyone at conferences, as Chris does. </p><br><p>  Not that money was an indicator of success, but David became a multi-millionaire thanks to his <a href="https://basecamp.com/">company Basecamp</a> working on the Ruby and Rails stack. </p><br><p>  Chris McCord, the founder of Phoenix, also speaks publicly from the very beginning.  Chris was a member of the Rails community, but somehow he didn‚Äôt find a solution to several issues and went to Elixir for the sake of it.  One feels that he is no less passionate about his creation than David once was.  At conferences, Chris is more loyal to newcomers;  his reports are more adapted for the unprepared listener. </p><br><p>  Chris works for <a href="https://dockyard.com/">DockYard</a> , whose leader has assembled an impressive team of elixirs.  The company also has a <a href="https://dockyard.com/blog">cool blog</a> , many articles from which we <a href="https://wunsh.ru/"><strong>translate for our site</strong></a> . </p><br><h2 id="osnovnaya-problema-oboih-freymvorkov">  The main problem of both frameworks </h2><br><p>  The biggest challenge is finding good developers, which is relevant for both Phoenix and Reils.  Although for the Phoenix, this task is much more acute.  And this is a huge problem.  Why do we need a perfect framework if there is no one to work in it?  Perhaps Phoenix should be friends with first-class PHP developers? </p><br><blockquote>  <strong>Today everyone speaks about Elixir and everywhere.</strong>  <strong>It's time to start studying it - right now.</strong> </blockquote><br><br><p>  The driving force of technology is you and me, so join the development on Elixir as soon as possible! </p><br><h2 id="a-kakoy-freymvork-vybrali-by-vy">  And which framework would you choose? </h2><br><p>  Summarizing, we can say that Phoenix offers slightly more powerful technologies, but this is not yet an indicator of the success of the project.  What really matters is the presence of developers who are well versed in the framework with which they work. </p><br><p>  If you have been driving a project on Rails for a long time, be extremely careful when switching to Phoenix.  In a foreign court, the grass is always greener.  In their practice there are successful transfers, but almost always they were engaged in the master of their craft. </p><br><p>  If you already have a team of talented Rails developers who want to try something new, then you should organize some side project on Phoenix, watch what happens, and then decide whether the game is worth the candle. </p><br><p>  Elixir and Phoenix can be used to create conventional CRUD applications if your company wants this for some reason, be it functional programming, the presence of only one server, the novelty of the language, etc. </p><br><p>  If speed and deployment without downtime are vital to your project, then with Phoenix you are exactly on the way. </p><br><p>  And whatever you choose, you know, there is no wrong option. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  This article is an adaptation of the compilation of three materials: </p><br><ul><li>  <a href="https://hackernoon.com/phoenix-is-better-but-rails-is-more-popular-8975d5e68879">Phoenix is ‚Äã‚Äãbetter but Rails is more popular</a> / Stefan Wintermeyer </li><li>  <a href="http://www.diatomenterprises.com/so-why-elixir-phoenix/">So why Elixir + Phoenix?</a>  / Dainis Lapins </li><li>  <a href="https://hmans.io/posts/2017/05/24/elixir-phoenix-use-cases.html">Elixir / Phoenix is ‚Äã‚Äãmore advantageous than Ruby / Rails?</a>  / Hendrik mans </li></ul><br><p>  Over the translation worked <strong>Hope</strong> / <a href="https://habrahabr.ru/users/tresstensel/" class="user_link">tresstensel</a> . <br>  Adaptation material performed <strong>Jaroslav</strong> / <a href="https://habrahabr.ru/users/jarosluv/" class="user_link">jarosluv</a> . </p><br><p>  PS All those interested are invited to the <a href="https://rambler-co-e-org.timepad.ru/event/587676/">mitap on the Elixir in the Rambler</a> on October 19 at 19:00.  For residents of other cities and countries will be organized online broadcast. </p><br><p>  PPS Answers to questions about the Elixir <a href="https://t.me/wunsh">in Telegram</a> . </p></div><p>Source: <a href="https://habr.com/ru/post/339460/">https://habr.com/ru/post/339460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339448/index.html">Design for iPhone X</a></li>
<li><a href="../339450/index.html">Parse BGP NOTIFICATION by RFC</a></li>
<li><a href="../339454/index.html">How the brain hits a tree, or how we made a recommendation system using a neural network.</a></li>
<li><a href="../339456/index.html">ZFS and KVM. @home</a></li>
<li><a href="../339458/index.html">Uneducated youth: an attempt to summarize and some personal</a></li>
<li><a href="../339464/index.html">Photogrammetry research</a></li>
<li><a href="../339468/index.html">Google Chrome distribution knows who downloaded it</a></li>
<li><a href="../339470/index.html">Root worse Mikhalkov</a></li>
<li><a href="../339472/index.html">Large list of telegram channels for designers, product managers and analysts</a></li>
<li><a href="../339474/index.html">Testing in Openshift: Openstack Integration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>