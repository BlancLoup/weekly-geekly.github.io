<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We use fast exponentiation of matrices to write a very fast interpreter of a simple programming language.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently on Habr√© there was a good article about the calculation of the N-th number of fibonacci for O (log N) arithmetic operations. The sensible que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We use fast exponentiation of matrices to write a very fast interpreter of a simple programming language.</h1><div class="post__text post__text-html js-mediator-article">  Recently on Habr√© there was a good <a href="http://habrahabr.ru/post/148336/">article</a> about the calculation of the N-th number of fibonacci for O (log N) arithmetic operations.  The sensible question that popped up in the comments was: "why can this be useful in practice."  In itself, the calculation of the N-th number of fibonacci may not be very interesting, however, the matrix approach used in the article can be used in practice for a much wider range of tasks. <br><br>  In this article, we will discuss how to write an interpreter that can perform simple operations (assignment, addition, subtraction, and truncated multiplication) on a limited number of variables with nested loops with an arbitrary number of iterations in a fraction of a second (of course, if the intermediate values ‚Äã‚Äãin the calculations remain in reasonable limits).  For example, this is the code given as input to the interpreter: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-number"><span class="hljs-number">1000000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-number"><span class="hljs-number">1000000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-number"><span class="hljs-number">1000000000</span></span> a += <span class="hljs-number"><span class="hljs-number">1</span></span> b += a <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Immediately displays a = 10000000000000000000000000, b = 5000000000000000000000000000000000000000000000000, despite the fact that if the program were performed naively, the interpreter would have to perform an octillion operations. <br><a name="habracut"></a><br>  I believe that the reader has an idea of ‚Äã‚Äãwhat a matrix is ‚Äã‚Äãand what a product of matrices is.  In this article, we will use exclusively square matrices and rely on a very important property of multiplying square matrices ‚Äî associativity. <br><br>  For simplicity, we will limit our interpreter to four variables - A, B, C and D. To represent the state of the interpreter at a given moment we will use a vector of size five, the first four elements of which will contain the values ‚Äã‚Äãof four variables, respectively, and the last will be equal to one throughout the interpreter‚Äôs work . <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">A</span></span>, B, C, D, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><br>  At the beginning of the interpreter, we will set the values ‚Äã‚Äãof all variables to zero. <br><br><pre> <code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><br>  Suppose that the first operation in the program code contains the string <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">A</span></span> += <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br><br>  The effect of this command is that the value of variable A will increase by five, while the values ‚Äã‚Äãof the other three variables will not change.  This can be represented as the following matrix: <br><br><pre> <code class="hljs">1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 5 0 0 0 1</code> </pre> <br><br>  If you look at it, you can see that it is almost identical to the identity matrix (which, as you know, when multiplying any vector by it, does not change its value), except for the last element in the first column, which is five.  If we recall how the vector is multiplied by the matrix, we can understand that the values ‚Äã‚Äãof all elements except the first one will not change, while the value of the first element will be equal to <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">v</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0]</span></span> * 1 + <span class="hljs-selector-tag"><span class="hljs-selector-tag">v</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[4]</span></span> * 5</code> </pre> <br><br>  Since v [0] contains the current value in the variable A, and v [4] is always equal to one, <br><br><pre> <code class="hljs markdown">v[0] <span class="hljs-bullet"><span class="hljs-bullet">* 1 + v[4] *</span></span> 5 = A + 5</code> </pre> <br><br>  If the vector of the current state is multiplied by this matrix, the resulting vector will correspond to the state in which A is five more, as required. <br>  If the matrix is ‚Äã‚Äãchanged a little, removing one in the first element of the first row: <br><br><pre> <code class="hljs">0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 5 0 0 0 1</code> </pre> <br><br>  As before, the values ‚Äã‚Äãof all elements except the first one will not change, while the first element will become equal to v [4] * 5, or just five.  Multiplying the current state vector by such a matrix is ‚Äã‚Äãequivalent to executing the command <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">A</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br><br>  Let's look at this matrix: <br><br><pre> <code class="hljs">1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 0 0 1</code> </pre> <br><br>  Its only difference from the unit matrix is ‚Äã‚Äãthe second element in the fourth row, which is equal to one.  It is obvious that multiplying the current state vector by this matrix will not change the values ‚Äã‚Äãin the first and last three elements, while the value of the second element will change to <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">v</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span> * 1 + <span class="hljs-selector-tag"><span class="hljs-selector-tag">v</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[3]</span></span> * 1</code> </pre> <br><br>  Since v [1] contains the current value of the variable B, and v [3] contains the current value of the variable D, multiplying the state vector by such a matrix is ‚Äã‚Äãequivalent to executing the command B + = D <br><br>  Similarly, arguing, it can be understood that multiplying the state vector by the next matrix is ‚Äã‚Äãequivalent to executing the command C * = 7 <br><br><pre> <code class="hljs">1 0 0 0 0 0 1 0 0 0 0 0 7 0 0 0 0 0 1 0 0 0 0 0 1</code> </pre> <br><br>  Let's move on to combining commands.  Let the vector v set the current state, the matrix Ma corresponds to the command A + = 5, and the matrix Mm correspond to the command A * = 7. Then, to get the vector r for the state after executing these two commands, you must first multiply v by Ma, and then Mm: <br><br><pre> <code class="hljs markdown">r = v <span class="hljs-bullet"><span class="hljs-bullet">* Ma *</span></span> Mm</code> </pre> <br><br>  As expected, multiplying the initial state vector by these two matrices leads to a state in which a = 35: <br><br><pre> <code class="hljs"> 1 0 0 0 0 7 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 0 5 0 0 0 1 0 0 0 0 1 0 0 0 0 1 5 0 0 0 1 35 0 0 0 1</code> </pre> <br><br>  Consider another example - let, instead of multiplying by seven, we just want to add five to A seven times. <br><br><pre> <code class="hljs markdown">r = v <span class="hljs-bullet"><span class="hljs-bullet">* Ma *</span></span> Ma <span class="hljs-bullet"><span class="hljs-bullet">* Ma *</span></span> Ma <span class="hljs-bullet"><span class="hljs-bullet">* Ma *</span></span> Ma * Ma</code> </pre> <br><br>  Here comes the associative multiplication property of matrices: <br><br><pre> <code class="hljs markdown">r = v <span class="hljs-bullet"><span class="hljs-bullet">* Ma *</span></span> Ma <span class="hljs-bullet"><span class="hljs-bullet">* Ma *</span></span> Ma <span class="hljs-bullet"><span class="hljs-bullet">* Ma *</span></span> Ma <span class="hljs-bullet"><span class="hljs-bullet">* Ma = v *</span></span> (Ma <span class="hljs-bullet"><span class="hljs-bullet">* Ma *</span></span> Ma <span class="hljs-bullet"><span class="hljs-bullet">* Ma *</span></span> Ma <span class="hljs-bullet"><span class="hljs-bullet">* Ma *</span></span> Ma) = v * Ma ^ 7</code> </pre> <br><br>  This is an example of a simple cycle - instead of multiplying v by Ma seven times, it is enough to raise the matrix Ma to the seventh power, after which you can perform only one multiplication.  If we wanted to perform the following two operations in a loop three times: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">A</span></span> += <span class="hljs-number"><span class="hljs-number">5</span></span> B -= C</code> </pre> <br><br>  (Let the operation B - = C be represented by the matrix Mbc), it would look like this: <br><br><pre> <code class="hljs lisp">r = v * Ma * Mbc * Ma * Mbc * Ma * Mbc = v * ((<span class="hljs-name"><span class="hljs-name">Ma</span></span> * Mbc) * (<span class="hljs-name"><span class="hljs-name">Ma</span></span> * Mbc) * (<span class="hljs-name"><span class="hljs-name">Ma</span></span> * Mbc)) = v * (<span class="hljs-name"><span class="hljs-name">Ma</span></span> * Mbc) ^ 3</code> </pre> <br><br>  We calculate the matrix corresponding to the body of the cycle only once, after which we raise it to a power. <br><br>  The examples considered are enough to start working on a simple language interpreter that supports assignment, addition, subtraction, multiplication (by a constant only) and cycles.  To do this, we will learn to represent any such program as an N + 1 matrix by N + 1, where N is the number of variables with which the program operates, after which we simply multiply the vector with the initial state by this matrix. <br><br>  The rules for presenting a program as a matrix are very simple: <br>  1. Each individual command is represented as a matrix, which differs from the single one element (or two for the assignment operation).  Examples of such matrices are discussed above in this article. <br>  2. Several consecutive teams are presented in the form of a matrix equal to the product of the matrix representation of each individual team. <br>  3. The cycle is represented as a matrix representing the cycle body, raised to the power of the number of loop iterations. <br><br>  If we have an identity function that returns a single matrix: <br><br><pre> <code class="hljs pgsql">def <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == j <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(REGS + <span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(REGS + <span class="hljs-number"><span class="hljs-number">1</span></span>)]</code> </pre> <br><br>  That function that builds the matrix for the command r1 + = r2 (where r1 and r2 are variables) may look like this: <br><br><pre> <code class="hljs markdown">def addreg(r1, r2): ret = identity() ret[<span class="hljs-string"><span class="hljs-string">r2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">r1</span></span>] = 1 return ret</code> </pre> <br><br>  And for the command r + = val (r is a variable, val is a constant) like this: <br><br><pre> <code class="hljs markdown">def addval(r, val): ret = identity() ret[<span class="hljs-string"><span class="hljs-string">REGS</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">r</span></span>] = val return ret</code> </pre> <br><br>  The functions for constructing matrices of other commands look similar - a unit matrix is ‚Äã‚Äãobtained, in which one element is replaced. <br><br>  The interpreter without cycles is now written very simply - let the mat matrix correspond to the code already read.  At the beginning it is equal to the identity matrix, because an empty program does not change the state.  Then we read the instructions one by one, divide them into three elements (left operand, operator, right operand), and depending on the operator, multiply the matrix corresponding to the whole program by the matrix corresponding to the current command: <br><br><pre> <code class="hljs vala">def doit(): mat = identity() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> True: line = sys.<span class="hljs-keyword"><span class="hljs-keyword">stdin</span></span>.readline().lower() tokens = line.split() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tokens[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'loop'</span></span>: #      elif tokens[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'end'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mat <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: r1 = reg_names.index(tokens[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: r2 = reg_names.index(tokens[<span class="hljs-number"><span class="hljs-number">2</span></span>]) except: r2 = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tokens[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'+='</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r2 == <span class="hljs-number"><span class="hljs-number">-1</span></span>: cur = addval(r1, <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>(tokens[<span class="hljs-number"><span class="hljs-number">2</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: cur = addreg(r1, r2) elif tokens[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'-='</span></span>: .... mat = matmul(mat, cur)</code> </pre> <br><br>  It remains the case for small - add support for cycles.  The loop raises the matrix of the loop body to the extent of the number of iterations of the loop.  Exponentiation, as is known, requires only O (log N) operations, where N is the degree to which the matrix is ‚Äã‚Äãraised.  The exponentiation algorithm is very simple: <br>  1. If the degree is zero, return the identity matrix. <br>  2. If the degree is even, let be 2N, then we can recursively calculate M ^ N, and then return the square of the resulting matrix. <br>  3. If the degree is odd, let 2N + 1, then it is sufficient to recursively calculate the value M ^ 2N, and return the resulting matrix multiplied by M. <br><br>  Since every two iterations the degree is reduced by two, the complexity of this algorithm is logarithmic. <br><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matpow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m, p)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> identity() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> p % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: tmp = matpow(m, p / <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> matmul(tmp, tmp) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> matmul(m, matpow(m, p - <span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br><br>  In the interpreter, it now remains to add one line: <br><br><pre> <code class="hljs cs"> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tokens[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'loop'</span></span>: cur = matpow(doit(), <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>(tokens[<span class="hljs-number"><span class="hljs-number">1</span></span>])) ...</code> </pre> <br><br>  And the interpreter is ready. <br><br>  An example interpreter is available on <a href="">github</a> .  All code takes less than 100 lines. <br><br>  For the speed test, you can return to the already mentioned fibonacci numbers.  For example, the following code: <br><br><pre> <code class="hljs pgsql">A = <span class="hljs-number"><span class="hljs-number">1</span></span> B = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> C = A C += B A = B B = C <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><br>  Calculate the 101st and 102nd fibonacci numbers: <br><br>  A = 573147844013817084101, B = 927372692193078999176 <br><br>  Replacing 100 with 1,000,000 will calculate the million first and million second numbers in four seconds.  Running such a program in the forehead would take much more, because the program has to operate on many thousands of digits.  If you write a code that does not have to operate with large numbers, for example, the code for calculating the sum of an arithmetic progression given at the beginning of the article, the number of iterations may go beyond the reasonable, but the code will be executed in a fraction of a second <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-number"><span class="hljs-number">1000000000000000000000000000000000000000000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-number"><span class="hljs-number">1000000000000000000000000000000000000000000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-number"><span class="hljs-number">1000000000000000000000000000000000000000000000</span></span> a += <span class="hljs-number"><span class="hljs-number">1</span></span> b += a <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><br>  In practice, this approach can be used, for example, in optimizing compilers, which can thus fold cycles with a large number of iterations, operating on a small number of variables. </div><p>Source: <a href="https://habr.com/ru/post/148901/">https://habr.com/ru/post/148901/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148894/index.html">One day from our life</a></li>
<li><a href="../148895/index.html">We hand over positions?</a></li>
<li><a href="../148896/index.html">About how we vorpsimanii teskkt</a></li>
<li><a href="../148897/index.html">Video review of the laptop (slikbuk) HP ENVY 6</a></li>
<li><a href="../148899/index.html">Object Oriented Functional Metaprogramming</a></li>
<li><a href="../148902/index.html">Nokia 101 Review - Flashlight with Player and $ 35 Phone</a></li>
<li><a href="../148903/index.html">Setting up wireless networks on a Cisco controller</a></li>
<li><a href="../148904/index.html">The development of Windows 8 has been completed. The system has moved to the RTM stage</a></li>
<li><a href="../148905/index.html">Duck typing or ‚Äúis old foreach so simple?‚Äù</a></li>
<li><a href="../148906/index.html">Compiling a Fortran software project</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>