<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rewriting Clojure test scripts in 24 hours</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I offer readers of "Habrakhabr" a free translation of the article "Rewriting Your Test Suite in Clojure in 24 hours" from the founder of CircleCI . 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rewriting Clojure test scripts in 24 hours</h1><div class="post__text post__text-html js-mediator-article"><p>  <i>I offer readers of "Habrakhabr" a free translation of the article <a href="https://circleci.com/blog/rewriting-your-test-suite-in-clojure-in-24-hours/">"Rewriting Your Test Suite in Clojure in 24 hours"</a> from the founder of <a href="https://circleci.com/">CircleCI</a> .</i> </p><br><div style="text-align:center;"><img src="http://thedaily3x5.com/cards/2016-01-01-starting-clojure-today.jpg" alt="image"></div><br><p>  This story is about how I wrote a compiler for automatic translation of the <a href="https://circleci.com/">CircleCI</a> test <a href="https://circleci.com/">suite</a> (14,000 lines) to another test library in 24 hours. <a name="habracut"></a></p><br><p>  To date, this set of tests is probably one of the largest in the world of Clojure.  Our server code is 100% Clojure, including tests consisting of 14,000 lines in 140 files, with 5000 asserts.  Without <a href="https://circleci.com/docs/how-parallelism-works/">parallelization,</a> execution takes 40 minutes. </p><br><p> At the start of this adventure, all tests were written in <a href="https://github.com/marick/Midje">Midje</a> - a library for BDD testing, something like RSpec.  We were not particularly happy with Midje, and decided to switch to <a href="http://richhickey.github.io/clojure/clojure.test-api.html">clojure.test</a> - probably the most widely used library for testing.  <code>clojure.test</code> simpler and has less magic in it, and at the same time a more developed ecosystem of tools and plugins. </p><br><p>  Obviously, it is impractical to rewrite 5000 tests with your hands.  Instead, we decided to use Clojure to rewrite them automatically using Clojure‚Äôs metaprogramming functions. </p><br><p>  Clojure is homo-ionic, which means that any code can be represented as a data structure.  Our translator translates each test file into a Clojure data structure.  Then we convert the code and write the result back to disk.  Once it is recorded, we can run the tests, and even automatically add the file back to the version control system if the tests have passed, and all this without leaving the REPL. </p><br><h2>  Reading </h2><br><p>  The key to the entire conversion is the <code>read</code> function.  <code>read-string</code> is a Clojure-embedded function that takes a string containing any Clojure code and returns it as a data structure.  The same function is used by the compiler when loading source files.  Example: <code>(read-string "[1 2 3]")</code> returns <code>[1 2 3]</code> . </p><br><p>  We use <code>read</code> to turn the code of our tests into a large nested list, which can be changed with the usual Clojure code. </p><br><h2>  Transformation </h2><br><p>  Our tests were written in <code>midje</code> , and we want to convert them to <code>clojure.test</code> .  An example of a test using <code>midje</code> : </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">ns</span></span> circle.foo-test (<span class="hljs-symbol"><span class="hljs-symbol">:require</span></span> [midje.sweet <span class="hljs-symbol"><span class="hljs-symbol">:refer</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:all</span></span>] [circle.foo <span class="hljs-symbol"><span class="hljs-symbol">:as</span></span> foo])) (<span class="hljs-name"><span class="hljs-name">fact</span></span> <span class="hljs-string"><span class="hljs-string">"foo works"</span></span> (<span class="hljs-name"><span class="hljs-name">foo</span></span> x) =&gt; <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br><p>  and a converted version using <code>clojure.test</code> : </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">ns</span></span> circle.foo-test (<span class="hljs-symbol"><span class="hljs-symbol">:require</span></span> [clojure.test <span class="hljs-symbol"><span class="hljs-symbol">:refer</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:all</span></span>])) (<span class="hljs-name"><span class="hljs-name">deftest</span></span> foo-works (<span class="hljs-name"><span class="hljs-name">is</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> (<span class="hljs-name"><span class="hljs-name">foo</span></span> x))))</code> </pre> <br><p>  Conversion includes replacement: </p><br><ul><li><p>  <code>midje.sweet</code> on <code>clojure.test</code> in ns form </p><br></li><li><p>  <code>(fact "a test name"...)</code> on <code>(deftest a-test-name ...)</code> , because in the <code>clojure.test</code> for the naming of tests identifiers are used, not strings </p><br></li><li><p>  <code>(foo x) =&gt; 42</code> at <code>(is (= 42 (foo x)))</code> </p><br></li><li>  small details that are missing for now </li></ul><br><p>  Transformation is a simple deeper tree traversal: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> munge-form [form] (<span class="hljs-name"><span class="hljs-name">let</span></span> [form (<span class="hljs-name"><span class="hljs-name">-&gt;</span></span> form (<span class="hljs-name"><span class="hljs-name">replace-midje-sweet</span></span>) (<span class="hljs-name"><span class="hljs-name">replace-foo</span></span>) ...)] (<span class="hljs-name"><span class="hljs-name">cond</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">list</span></span>? form) (<span class="hljs-name"><span class="hljs-name">vector</span></span>? form)) (<span class="hljs-name"><span class="hljs-name">-&gt;</span></span> form (<span class="hljs-name"><span class="hljs-name">replace-fact</span></span>) (<span class="hljs-name"><span class="hljs-name">replace-arrow</span></span>) (<span class="hljs-name"><span class="hljs-name">replace-bar</span></span>) ... (<span class="hljs-name"><span class="hljs-name">map</span></span> munge-form))) <span class="hljs-symbol"><span class="hljs-symbol">:else</span></span> form))</code> </pre> <br><p>  Behavior <code>-&gt;</code> similar to chaining in Ruby or JQuery, or to Bash's pipes: passes the result of a function call calculation, as an argument to a call to the next function. </p><br><p>  The first part <code>(let [form ...])</code> takes a Clojure form and applies each conversion function to it.  The second part takes a list of forms representing other Clojure expressions and functions - and recursively transforms them. </p><br><p>  An interesting process occurs in the replacement functions.  They all look something like this: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">this-form-is-relevant</span></span>? form) (<span class="hljs-name"><span class="hljs-name">some-transformation</span></span> form) form)</code> </pre> <br><p>  i.e., they check whether the submitted form complies with the replacement criterion, and if so, transforms it as necessary.  For example, <code>replace-midje-sweet</code> looks like this: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> replace-midje-sweet [form] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> 'midje.sweet form) 'clojure.test form))</code> </pre> <br><h2>  Arrows </h2><br><p>  The entire syntax of tests in Midje revolves around the ‚Äúarrows‚Äù - a non-idiomatic design that Midje uses to enhance the declarativeness of tests in the style of BDD.  A simple example: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">foo</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre> <br><p>  checks that <code>(foo 42)</code> returns 5. </p><br><p>  Depending on which arrows are used and which types are on the other side of the arrow, a large number of different behaviors vary. </p><br><pre> <code class="hljs swift">(foo <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>?</code> </pre> <br><p>  If in the example above <code>map?</code>  Is a function, it is verified that the result of applying this function to the left side of the expression is true (truthy is not equal to nil or false).  In Clojure it would be like this: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">map</span></span>? (<span class="hljs-name"><span class="hljs-name">foo</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>))</code> </pre> <br><p>  A few examples of midje shooter: </p><br><pre> <code class="hljs php">(foo <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; falsey (foo <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; map? (foo <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; (throws <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>) (foo <span class="hljs-number"><span class="hljs-number">42</span></span>) =not=&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> (foo <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; <span class="hljs-comment"><span class="hljs-comment">#"hello world" ;; regex (foo 42) =not=&gt; "hello"</span></span></code> </pre> <br><h4>  Replacing the arrows </h4><br><p>  The real transformation uses the order of forty <a href="https://github.com/clojure/core.match">core.match</a> rules.  But they all look something like this: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">match</span></span> [actual arrow expected] [actual '=&gt; 'truthy] `(is ~actual) [actual '=&gt; expected] `(is (= ~expected ~actual) [actual '=&gt; (_ :guard regex?)] `(is (re-find ~contents ~actual)) [actual '=&gt; nil] `(is (<span class="hljs-literal"><span class="hljs-literal">nil</span></span>? ~actual)))</code> </pre> <br><p>  (For Clojure experts: to improve readability, I omitted the set of ~ 'characters in the macro above. To see how it actually looks, see the source.) </p><br><p>  Most transformations are very straightforward.  However, everything becomes much more complicated with the form of <code>contains</code> : </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">foo</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; (<span class="hljs-name"><span class="hljs-name">contains</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>}) (<span class="hljs-name"><span class="hljs-name">foo</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; (<span class="hljs-name"><span class="hljs-name">contains</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:b</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:gaps-ok</span></span>) (<span class="hljs-name"><span class="hljs-name">foo</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; (<span class="hljs-name"><span class="hljs-name">contains</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:b</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:in-any-order</span></span>) (<span class="hljs-name"><span class="hljs-name">foo</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; (<span class="hljs-name"><span class="hljs-name">contains</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span>)</code> </pre> <br><p>  The last case is especially interesting.  For expression </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">foo</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>) =&gt; (<span class="hljs-name"><span class="hljs-name">contains</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span>)</code> </pre> <br><p>  There are two completely different situations in which the test will be successfully passed.  <code>(foo 42)</code> can return a list that contains the ‚Äúhello‚Äù element, or can return a string that contains the substring ‚Äúhello‚Äù: </p><br><pre> <code class="hljs swift"><span class="hljs-string"><span class="hljs-string">"hello world"</span></span> =&gt; (<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span>) [<span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span>] =&gt; (<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span> <span class="hljs-string"><span class="hljs-string">"hello"</span></span>)</code> </pre> <br><p>  In general, the <code>contains</code> form is complex for automatic conversion.  Some cases require additional information at run time (as a final example), and since  there is no implementation for many <code>contains</code> cases in Clojure, such as <code>(contains [:a :b] :in-any-order)</code> , we decided to ignore all cases of <code>contains</code> .  Instead of trying to broadcast them automatically, we use the ‚Äúdisastrous‚Äù rule, which looks like this: </p><br><pre> <code class="hljs kotlin">[<span class="hljs-keyword"><span class="hljs-keyword">actual</span></span> arrow expected] (<span class="hljs-keyword"><span class="hljs-keyword">is</span></span> (~arrow ~expected ~<span class="hljs-keyword"><span class="hljs-keyword">actual</span></span>))</code> </pre> <br><p>  It turns <code>(foo 42) =&gt; (contains bar)</code> into <code>(is (=&gt; (contains bar) (foo 42)))</code> .  Such code will not compile, because the definition of the function of the arrow from Midje is not loaded, and we can fix it manually. </p><br><h4>  Runtime Type Information </h4><br><p>  There was another added complexity with automatic conversion.  If we have two expressions: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">let</span></span> [bar <span class="hljs-number"><span class="hljs-number">3</span></span>] (<span class="hljs-name"><span class="hljs-name">foo</span></span>) =&gt; bar</code> </pre> <br><p>  and </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">let</span></span> [bar clojure.core/map?] (<span class="hljs-name"><span class="hljs-name">foo</span></span>) =&gt; bar</code> </pre> <br><p>  The interpretation of the Midje arrow depends on the expression to the right, which can be determined (without problems) only at run time.  If <code>bar</code> resolves to data, for example, string, number, list, or map ‚Äî Midje checks for equality.  But if <code>bar</code> resolves to a function, Midje <em>calls</em> this function, i.e.  <code>(is (= bar (foo)))</code> versus <code>(is (bar (foo)))</code> .  Our 90% solution includes ( <code>require</code> ) the namespace from the source test, and resolves functions during the conversion process: </p><br><pre> <code class="hljs rust">(defn form-is-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">? [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ns</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">] </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [resolved (ns-resolve ns f)] (and resolved (or (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">? </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolved</span></span></span><span class="hljs-function">) </span></span>(and (var? resolved) (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function">? @</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolved</span></span></span><span class="hljs-function">)))))))</span></span></code> </pre> <br><p>  In most cases this works fine, but the problem occurs when the local variable overlaps the global one: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">let</span></span> [s [<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>] count (<span class="hljs-name"><span class="hljs-name">count</span></span> s)] (<span class="hljs-name"><span class="hljs-name">foo</span></span> s) =&gt; count)</code> </pre> <br><p>  In this case, we want <code>(is (= count (foo s)))</code> , but we get <code>(is (count (foo s)))</code> , which is wrong, because  in the local environment, <code>count</code> is a number, and <code>(3 [1 2 3])</code> causes an error.  Fortunately, there were few such situations, because solving this problem would require writing a full-fledged compiler with definition of local variables in the environment. </p><br><h2>  Test execution </h2><br><p>  When the transform code was written, we needed to understand if it worked.  Since  we run the code in the REPL at runtime, we need (after conversion) to simply run the tests using the built-in function <code>clojure.test</code> . </p><br><p>  The implementation of <code>clojure.test</code> helps bind the transformation and calculation processes together.  All test functions can be called from REPL, and even <code>(clojure.test/run-all-tests)</code> returns a meaningful value ‚Äî a <code>map</code> containing the number of tests passed and dropped: </p><br><pre> <code class="hljs json">{:pass <span class="hljs-number"><span class="hljs-number">61</span></span>, :test <span class="hljs-number"><span class="hljs-number">21</span></span>, :error <span class="hljs-number"><span class="hljs-number">0</span></span>, :fail <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre> <br><p>  The ability to run tests in the REPL makes the process very convenient, you can make changes in the compiler and retest it, immediately receiving feedback. </p><br><h4>  Reading </h4><br><p>  However, not everything worked so easy. </p><br><p>  A ‚Äúreader‚Äù (a term in Clojure to indicate the part of the compiler that implements the <code>read</code> function) is designed to convert source files into data structures, primarily for use by the compiler.  It removes comments, opens macros, which requires us to check all diffs manually to return these lines.  Fortunately, there were only a few of them in the tests.  In our programming style, we usually prefer docstrings to comments, and isolate macros in a small number of files, so this doesn‚Äôt affect us much. </p><br><h4>  Indentation </h4><br><p>  We have not found a good enough library that would make idiomatic indents in our new code.  We used <code>clojure.pprint</code> , which is probably the best available library, does not do very well with this task.  We had no desire to write such a library within the framework of this project, so some files were recorded back onto a disk with non-idiomatic spaces and indents.  Now, when we work directly with the file, we can fix it by hand.  Otherwise, it would require a tool that understands idiomatic formatting and takes into account the file and string metadata at the data reading stage. </p><br><p>  There was a big delay between rewriting test scripts and publishing this article.  During this time, the release of <a href="https://github.com/xsc/rewrite-clj">rewrite-clj</a> .  I did not use it, but at first glance it has something that we lacked so much. </p><br><h2>  results </h2><br><p>  About 40% of the test files passed without our intervention, which is actually amazing, considering how quickly we compiled this solution.  In the remaining files, about 90% of the test asserts were converted and completed.  Total 94% of assertions in all files were converted automatically - a great result. </p><br><p>  Our code can be found on github <a href="https://github.com/circleci/translate-midje">here</a> .  Let <a href="https://twitter.com/arohner">us</a> know if you will use it.  Since  we would not recommend it for an uncontrollable conversion, especially because of comments and macros.  This code worked well for <a href="https://circleci.com/">CircleCI</a> as part of a controlled process. </p><br><p>  From the translator.  Thanks for the help: <a href="https://habrahabr.ru/users/comerc/" class="user_link">comerc</a> , <a href="https://habrahabr.ru/users/source/" class="user_link">Source</a> , <a href="https://habrahabr.ru/users/chort409/" class="user_link">chort409</a> and <a href="http://github.com/artemyarulin">artemyarulin</a> . <br>  <a href="http://thedaily3x5.com/">Source of the title picture</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308734/">https://habr.com/ru/post/308734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308720/index.html">OpenCV and image processing</a></li>
<li><a href="../308726/index.html">Interview with the first speaker of Moscow Python</a></li>
<li><a href="../308728/index.html">‚ÄúMy life through the prism of technology ...‚Äù - Stephen Wolfram</a></li>
<li><a href="../308730/index.html">Digital Help: 14 useful business bots for Telegram</a></li>
<li><a href="../308732/index.html">Why shadow copies do not save most encryptors</a></li>
<li><a href="../308738/index.html">Why do banks, regulators and payment systems have their own cryptocurrency</a></li>
<li><a href="../308740/index.html">Configuring MongoDB ShardedCluster with X.509 Authentication</a></li>
<li><a href="../308742/index.html">Scalable solutions for EMV and mobile NFC payments in closed networks</a></li>
<li><a href="../308746/index.html">SWEET32 attack: Researchers have discovered a new way to crack the 3DES and Blowfish ciphers</a></li>
<li><a href="../308748/index.html">Published program Droidcon Moscow 2016</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>