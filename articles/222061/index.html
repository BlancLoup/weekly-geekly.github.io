<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with external device registers in the C language, part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All is well that ends well 
 Now that we have examined how using the C language we can determine the fixed location of the register in the MK address ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with external device registers in the C language, part 3</h1><div class="post__text post__text-html js-mediator-article"><h5>  All is well that ends well </h5><br>  Now that we have examined how using the C language we can determine the fixed location of the register in the MK address space (part 1), how we can determine the individual bit groups in the register (part 2), it's time to consider how we can with these groups work.  Working with a group of bits, as with the whole, presents no problems, relies on their description in the form of bit fields and has already been demonstrated, however, we may need to work with individual bits of the field; . <br><a name="habracut"></a>  Suppose we need to separately manipulate the high bit of the command field from our example.  The first thing that comes to mind is union, but unions cannot have a bit length.  There is an option to create two versions of the register description and combine them already, and it works: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> bitfields=reversed typedef struct { unsigned :1; unsigned int code:3; unsigned :26; const unsigned flag1:1; unsigned flag:1; } tIO_STATUS; typedef struct { unsigned :1; unsigned int start:1; unsigned :30; } tIO_STATUSA; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> bitfields=default typedef union { tIO_STATUS; tIO_STATUSA; } tIO_STATUS2; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IO_ADR 0x20000004 volatile tIO_STATUS2 * const pio_device = (tIO_STATUS2 *) (IO_ADR); pio_device-&gt;code = 3; while (pio_device-&gt;flag) {}; pio_device-&gt;start=1;</span></span></code> </pre>  , but the creation of two additional types is somewhat redundant (in my opinion). <br>  An alternative for manipulating the individual bits of the group are all the same bit masks and we come to constructions of the type: <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BITNUM 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      0 #define BITMASK (1&lt;&lt;BITNUM) pio_device-&gt;code |= (1&lt;&lt; BITNUM); //   pio_device-&gt;code &amp;= ~BITMASK;; //  </span></span></span></span></code> </pre>  Note that the compiler does not control the validity of values ‚Äã‚Äãfor such operations (as opposed to assigning a constant).  Also note that the bit number is applied, from which a bitmask is created by shifting.  I do this because it is more difficult to make a mistake in dialing a number than in the bitmask dialing (0x40000000), and you still have to think in your head, and there is no difference in the code (but this is, of course, a matter of taste).  But now a really serious remark - all authors of articles on embedded programming (including myself) categorically DO NOT recommend using such constructions in the text, but define macros to set and reset bit fields <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SETBIT(DEST,MASK) (DEST) |= (MASK) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CLRBIT(DEST,MASK) (DEST) &amp;= ~(MASK)</span></span></code> </pre>  continue to use them only. <pre> <code class="cpp hljs"> SETBIT(pio_device-&gt;code,<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; BITNUM); CLRBIT(pio_device-&gt;code,BITMASK);</code> </pre>  First, you will not make an offensive mistake, forgetting to put a bitwise negative (~) in the second case or put a logical negative (!) Instead of it (those who have never made such a mistake are very attentive people, I, unfortunately, to them do not belong).  Second, by switching to bit-addressable MK, you can redefine this macro (only for single bits), taking into account the capabilities of the hardware, and get a significantly faster code.  Thirdly, if (when) you have to turn these operations into atomic ones, it is much easier to do this in the definition of a macro, rather than chasing them throughout the program. <br><br>  Here's the last aspect, it makes sense to talk a little more.  As is known, the need for atomic operations arises when there are more than one processes competing for access to a resource.  So, for access to the registers of external devices, even in the case of one process (the main While loop), there is implicit competition from the interrupt service routines. Therefore, when accessing registers of VU, the read-modify-write sequence is a threat from the point of view of ensuring continuity of actions.  The fact is that the operations of setting / resetting bits on the mask that are in the command set can NOT operate on the address space cells directly and, accordingly, cannot provide an atomic change of the VU register.  It cannot be said that the developers of the MC do not understand the shortcomings of this approach, but there is still no direct solution to the problem, which clearly indicates the presence of deep internal aspects that impede such.  There are various approaches to problemma.  The presence of two registers in the address space, writing a unit to one of them sets the value bit, writing a unit to the other resets the value bit.  The presence of a bit-banding mechanism, when each bit corresponds to a separate value in the address space (of course, in addition to the usual access mechanism to the entire register as a whole).  Well, a widespread mechanism for disconnecting feathers before starting an operation with a resolution after it ends.  Maybe I do not know, but there is still no good atomic hardware for hardware. <br><br>  Now let's talk about constants.  As a rule, to communicate with the registers of the control unit there is a certain set of valid field values ‚Äã‚Äãand a good programming style is to consider the description of these possibilities as a set of constants with meaningful names and checking for validity of the value in the assignment (so far I have used the magic number 3, but this is exclusively educational purposes).  What possibilities does the C language provide for us to solve this problem?  There are two of them - defining constants via #define and creating enumerated types.  Let us examine each of these alternatives.  Suppose that our device is able to accept only 2 commands - ‚Äústart work‚Äù with code 3 and ‚Äústop work‚Äù with code 2. Then we can write: <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IO_DEVICE_START 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IO_DEVICE_STOP 2 pio_device-&gt;code=IO_DEVICE_START;</span></span></code> </pre>  what is most often done.  So the magic number has disappeared, even the check is on matching the size of the bit field, but the expression <pre> <code class="cpp hljs"> pio_device-&gt;code=<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre>  the compiler will be skipped as valid.  That is, the task of controlling the value of admissibility falls on the shoulders of the developer and is implemented by an ASSERT.  The method is quite efficient, often used and quite acceptable if it were not more convenient, namely the use of an enumerated type: <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> bitfields=reversed typedef struct { unsigned :1; enum { O_DEVICE_START=3, IO_DEVICE_STOP=2, } code:3; unsigned :26; const unsigned flag1:1; unsigned flag:1; } tIO_STATUS; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> bitfields=default pio_device-&gt;code=IO_DEVICE_START; SETBIT(pio_device-&gt;code,BITMASK); pio_device-&gt;code |= BITMASK; pio_device-&gt;code=pio_device | BITMASK;</span></span></code> </pre>  Let's pay attention to the fact that in the last line we will receive a warning about the incompatibility of types, and in the two previous ones that do the same, we will not receive (this is not a bug, this is a feature like this).  Why is this method more convenient?  First, we can place the enumeration of possible values ‚Äã‚Äãdirectly in the body of the structure description, which is more readable.  Secondly, the compiler will check the values ‚Äã‚Äãin the definitions and will not allow us to go beyond the size of the field.  Third, and most importantly, the compiler will not allow us to assign an invalid (not specified in the list) value to the field, although it leaves us with a loophole shown in the penultimate line (if anyone knows how to close it, write).  In short, everything is wonderful and wonderful, BUT you can not use such a construction in any compiler, since the C standard does not allow using anything for the bit fields except int.  In addition, even in IAR, an additional compiler directive - enum_is_int is needed to ensure proper alignment.  But if you are not afraid of compiler dependency, then the method is very beautiful, transparent and convenient (I agree in advance with those who write in comments that this will greatly reduce the possibility of porting). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So in conclusion, a few thoughts about the functions and wraps to them.  Often when viewing files, you will find something similar to the following: <pre> <code class="cpp hljs">dev_data_r_w (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data_command, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r_w, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *adr) { ... }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dev_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data_comand, iint *adr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dev_data_r_w (n, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *adr); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_dev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *adr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dev_data(n,<span class="hljs-number"><span class="hljs-number">1</span></span>,adr); }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ch_read_dev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *adr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> read_dev(<span class="hljs-number"><span class="hljs-number">1</span></span>,adr); };</code> </pre>  it is easy to see that the first function does the real work, and all the others create wrappers for it, in order not to write the corresponding constant parameters.  In C ++ (and in a number of others), this problem is removed by the default parameter values, but for C it is still relevant.  My personal opinion is not to do that.  If dynamic type conversion is not required, use macros to create convenient (easy to use) synonyms for a common function: <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> dev_data(N,DC,ADR) dev_data_r_w ((N),(DC),1,(ADR)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> read_dev(N,ADR) dev_data((N),1,(ADR)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ch_read_dev(ADR) read_dev(1,(ADR))</span></span></code> </pre>  Such a definition is not more difficult, slightly loses in code size, but wins in execution time and memory size used.  Such multi-tier constructs in interrupt handling routines are especially appealing.  And one more observation - for some reason, some programmers (if there are such readers among them, write why) consider that the creation of their own enumeration type <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { SET=<span class="hljs-number"><span class="hljs-number">1</span></span>, RESET=<span class="hljs-number"><span class="hljs-number">0</span></span> } ACTIVE;</code> </pre>  - that's cool.  I can still understand when this type is used to write a value to a bit, but when to control its value?  It seems to me that the type of bool completely replaces this type, although who knows, I am ready to listen to other opinions. <br><br>  I summarize the third part of the article - the goal was to agree on some general rules in the description of access registers to the VU registers, to develop some vocabulary, because I think about writing several posts in which, step by step, I disassemble the construction of the MK peripheral service routines from the simplest ones (SPI , UART) (although with a deep examination of very simple devices is not so much) to quite complex (USB, Ethernet).  In principle, the task is completed, there are still a number of remarks on the design of the programs, but I will state them as we go. </div><p>Source: <a href="https://habr.com/ru/post/222061/">https://habr.com/ru/post/222061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../222049/index.html">Roboforum 2014: dossier for 40 speakers and one big question</a></li>
<li><a href="../222051/index.html">Who will take the tickets for a pack ... or about the monetization of gaming applications</a></li>
<li><a href="../222053/index.html">CamIRa online thermal imager</a></li>
<li><a href="../222055/index.html">The story of one discovery</a></li>
<li><a href="../222057/index.html">Bags with built-in outlet</a></li>
<li><a href="../222063/index.html">The TinkerForge do-it-yourself kit will make your home more comfortable</a></li>
<li><a href="../222065/index.html">Light controllers with AngularJS</a></li>
<li><a href="../222067/index.html">Own impressions and review NAS Synology DS214</a></li>
<li><a href="../222077/index.html">Java 8, Spring, Hibernate, SSP - we start playing</a></li>
<li><a href="../222079/index.html">Caching all HTML and connecting JS ‚Äúon the go‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>