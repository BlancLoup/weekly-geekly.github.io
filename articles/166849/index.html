<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interview with the creator of C ++ STL, 1995 Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In recent years, when the demand for C ++ is growing again , it is interesting to look into the recent past and recall how this classic development pl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interview with the creator of C ++ STL, 1995 Part 1</h1><div class="post__text post__text-html js-mediator-article"> <i>In recent years, when the demand for C ++ <a href="http://channel9.msdn.com/Events/TechEd/Europe/2012/DEV368">is growing again</a> , it is interesting to look into the recent past and recall how this classic development platform was created.</i>  <i>In this question, certainly unconstructive are the books of Straustrup, like ‚Äú <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B7%25D0%25B0%25D0%25B9%25D0%25BD_%25D0%25B8_%25D1%258D%25D0%25B2%25D0%25BE%25D0%25BB%25D1%258E%25D1%2586%25D0%25B8%25D1%258F_C%252B%252B">Design and Evolution of C ++</a> ‚Äù.</i>  <i>However, it is equally interesting to hear about the language from its very first followers, and sometimes full-fledged collaborators.</i>  <i>Perhaps the most famous of them is our (in general :) compatriot <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B5%25D0%25BF%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2,_%25D0%2590%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581%25D0%25B0%25D0%25BD%25D0%25B4%25D1%2580_%25D0%2590%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581%25D0%25B0%25D0%25BD%25D0%25B4%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B8%25D1%2587_(%25D1%2583%25D1%2587%25D1%2591%25D0%25BD%25D1%258B%25D0%25B9)">Alex Stepanov</a> , the author of the <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B0%25D0%25BD%25D0%25B4%25D0%25B0%25D1%2580%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B1%25D0%25B8%25D0%25B1%25D0%25BB%25D0%25B8%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BA%25D0%25B0_%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B2">Standard Template Library</a> .</i>  <i>The interview, cited below, was taken from Alex in 1995 by columnist <a href="http://www.drdobbs.com/">Dr.Dobbs</a> magazine <a href="http://www.alstevens.org/the-author/">Al Stevens</a> .</i>  <i>The material will be interesting for both beginners to learn C ++, and experienced users of the language.</i> <br><br>  <b>Alex, tell us something about your long-standing interest in generic programming.</b> <br><br>  I started thinking about generalized programming in the late 70s, when I noticed that some algorithms do not depend on the specific implementation of the data structure, but only on a small number of essential semantic properties of this structure.  So I began to consider a variety of algorithms, and found that most of them can be abstracted from a specific implementation so that efficiency is not lost.  Efficiency is one of my main concerns.  <a href="http://alenacpp.blogspot.ru/2006/08/blog-post.html">It</a> is <a href="http://alenacpp.blogspot.ru/2006/08/blog-post.html">foolish to</a> abstract the algorithm in such a way that when you use it for the resulting implementation, it becomes inefficient. <br><a name="habracut"></a><br>  At that time, I thought that the right way to do this kind of research was to develop a programming language, which I started to do with my two friends, Deepak Kapoor (currently a professor at the University of New York, Albani) and David Musser, Professor at the Rensselaer Polytechnic Institute.  Then the three of us worked at the General Electric Research Center in Schenectady, New York.  We started working on a language called Tecton, which would allow people to describe the algorithms associated with what we called generic structures.  They are simply collections of formal types and their properties.  Something like math tools.  We realized that it is possible to define the algebra of operations on these structures: you can replenish them, enrich them and do various things with them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There were some interesting ideas, but the research did not lead us to practical results, since Tecton was a functional language.  We believed in the idea of ‚Äã‚ÄãBackus Naur that <a href="http://en.wikipedia.org/wiki/Von_Neumann_programming_languages">programming should be freed from the Von Neumann style</a> , and we did not want to have <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B1%25D0%25BE%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D1%258D%25D1%2584%25D1%2584%25D0%25B5%25D0%25BA%25D1%2582_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">side effects</a> in the language as a result of the work of a procedure or function.  As a result, it was not possible to touch on many algorithms, which in essence required the concepts of state and side effect. <br><br>  An interesting fact about Tecton, which I realized somewhere in the late 70s, was that this language had a basic limitation on the accepted representation of an abstract data type (ADT).  Typically, ADT is presented as something that tells you only about the behavior of the object, while the implementation is completely hidden.  It was considered generally accepted that the complexity of the operation is part of the implementation, and the abstraction ignores the complexity.  One of the facts that I now consider to be central to generic programming is that complexity, or at least some general idea of ‚Äã‚Äãcomplexity, must be associated with an operation. <br>  Consider an example.  Imagine ATD "Stack".  It is not enough to have the ‚ÄúPush to stack‚Äù and ‚ÄúPush out from stack‚Äù methods: the postulate - something is put on the stack, and after the top of the stack is pushed out, the same stack is obtained.  The statement of paramount importance is that putting an item on the stack is an operation with a constant time regardless of the size of the stack.  If I implement the stack in such a way that every time this element is added to it, this operation becomes slower and slower, then no one wants to use this stack. <br><br>  We need to separate the implementation from the interface, but not at the price of completely ignoring the complexity.  Complexity must be and is part of the unwritten agreement between the module and its user.  The reason for introducing the concept of ADT was to allow the creation of interchangeable software modules.  It is impossible to have interchangeable modules as long as these modules do not share similar complexity behavior.  If I replace one module with another with the same functional behavior, but with excellent compromises in complexity, the user of this code will be unpleasantly surprised.  I could tell him everything I like about data abstraction, but he still wouldn‚Äôt want to use code.  Assertions of complexity should be part of the interface. <br><br>  Around 1983, I moved from GE Research to the faculty of the Polytechnic University, formerly known as the Brooklyn Polytechnic, in New York.  I started working on graph algorithms.  My main co-author was Aaron Kershenbaum, now working at IBM Yorktown Heights.  He was an expert in graph and network algorithms, and I convinced him that some ideas of high-level and generalized programming were applicable to graph algorithms.  He had access to several research grants and provided me with support so that I could start working with him on applying these ideas to real network algorithms.  He was interested in creating a set of tools in the form of high-level generalized components, so that some of these algorithms could be implemented.  The fact is that some network algorithms are so complex that they were never implemented at that time, although they were well analyzed theoretically.  I decided to use a Lisp dialect called Scheme to build such a toolkit.  Aaron and I developed a large component library at Scheme that demonstrates all kinds of programming techniques.  Network algorithms were the main goal.  Later, Dave Musser, still working at GE Research, joined us, and we developed an even larger component, a fairly large library.  It was used at university by students completing their studies, but was never employed for commercial purposes.  Being engaged in this work, I realized that the side effects of the functions are important, because  in fact, it is impossible to perform operations on graphs without side effects.  You cannot copy a graph every time you need to modify a vertex.  So the insight at the time was that when building generalized algorithms, you can combine high-order techniques with moderate use of side effects.  Side effects are not necessarily bad;  they are bad, just being misused. <br><br>  In the summer of 1985, I was invited back to GE Research to teach a high-level programming course.  There I showed how to construct complex algorithms using this technique.  One of those attending the course was Art Chen, later on managing the Laboratory for Information Systems.  He was impressed enough to ask me a question: could I create with the help of this technique a library ready for industrial use in the Ada language, while ensuring my support for it.  Being a poor assistant professor, I agreed, although I did not know any Ada then.  Together with Dave Musser, we began work on the creation of the Ada library.  This was a significant circumstance, since  switching from a dynamically typed language, such as Scheme, to a strongly typed language, such as Ada, allowed me to realize the importance of strong typing.  Everyone understands that strong typing helps in finding errors.  I found that strong typing in the context of the <a href="http://en.wikibooks.org/wiki/Ada_Programming/Generics">generics of the Ada language</a> (generic procedures ‚Äî that is, applicable to any type) was also a tool for identifying models.  It was not only a tool for catching errors.  She was also a tool for thought.  This work led me to the idea of ‚Äã‚Äãorthogonal decomposition of the component space.  I realized that software components belong to different categories.  PLO supporters think that everything is an object.  When I was working on a generic library for Ada, I realized that it was not.  There are things that are objects.  Things that have a state and change their state are objects.  And at the same time there are things that are not objects.  Binary search is not an object.  This is an algorithm.  Moreover, I realized that by decomposing the component space into several orthogonal dimensions, we can reduce the number of components, and, more importantly, we can provide a conceptual basis for how to design something. <br><br>  Then I was offered a job at Bell Lab in the C ++ language group on C ++ libraries.  They asked me if I could do the same in C ++.  Of course, I did not know C ++, and of course I agreed.  But I could not do this in C ++, because  in 1987, C ++ did not have the templates needed for this programming style.  Inheritance was the only mechanism for generalization, and it was not sufficient. <br><br>  Even now, inheritance in C ++ is not particularly valuable for generic programming.  Let's discuss why.  Many have tried to use inheritance to implement data structures and container classes.  As we know now, there have been very few successful attempts, if any.  The C ++ inheritance and programming style associated with it are significantly limited.  So, it is impossible to implement a design that includes such a simple thing as using the comparison operator for equality.  If you start with the base class X as the root of your hierarchy and define a virtual equality operator for this class that takes an argument of type X, then inherit the class Y from X. What is the interface of the comparison operator for equality?  It has an equality that compares Y with X. Using animals as an example (object-oriented people like animals), define a "mammal" and inherit the "giraffe" from a mammal.  Then define a mate member function in which one animal mates with another and returns the animal.  Then you remove the "giraffe" from the animal and, of course, it has the function of "mate", in which the giraffe mates with the animal and returns the animal.  This is definitely not what you would like.  While pairing may not be very important for C ++ programmers, the equality operator is one.  I do not know of any algorithm in which some kind of equality comparison would not be used. <br><br>  You need templates to deal with similar problems.  You can have the ‚ÄúAnimal‚Äù template class that has a mate member function that accepts an animal and returns an animal.  When you instantiate Giraffe, mating will do the right thing.  In this regard, the pattern is a more powerful mechanism. <br><br>  However, I was able to create a very large library of algorithms, which later became part of the Standard Components Library of the Unix Systems Lab.  I learned a lot at Bell Labs, talking about programming with people like Andy Koenig and Bjarn Straustrup.  I realized that C / C ++ is an important programming language with some basic paradigms that can no longer be ignored.  In particular, I learned that pointers are very good.  I do not mean <a href="http://en.wikipedia.org/wiki/Dangling_pointer">"hanging" pointers</a> .  I don't mean pointers to the stack.  But I mean, general pointer notation is a powerful tool.  The concept of address is used everywhere.  It is incorrectly assumed that pointers make our thinking consistent.  This is not true.  Without some kind of address, we cannot describe any parallel algorithm.  If you try to describe the parallel summation of n numbers, you will not be able to do this until you can talk about the first number that adds up to the second, while the third number adds up to the fourth.  You need some kind of indexing.  You need some kind of addressing to describe an algorithm of any kind, serial or parallel.  The notation of an address or position is fundamental to our understanding and conceptualization of computational processes - algorithms. <br><br>  Now let's think about why C is a great language.  It is generally accepted that C is such a big ‚Äúhack‚Äù that succeeded because  Unix was written on it.  I disagree.  Over a long period of time, computer architectures evolved, not due to the fact that some smart people figured out how to develop architectures, but because of the needs of various programmers to solve real problems.  In fact, ‚Äúsmart‚Äù people at that time promoted tagged ( <a href="http://en.wikipedia.org/wiki/Tagged_architecture">LISP-oriented</a> ) architectures, which, of course, was not very relevant to the basic needs of developers.  Computers that were able to deal only with numbers evolved into computers with byte-by-byte memory, flat address spaces, and pointers.  It was a natural evolution, reflecting a growing array of problems that people solved.  C, who reflected the genius of Denis Ricci, provided a minimal computer model, which as a result of development was obtained during the past 30 years.  C was not a quick hack.  As computers evolved to handle all kinds of problems, C, being the minimum model for such a computer, has become a very popular language for solving all kinds of problems in various areas with a high degree of efficiency.  This is the secret of C portability: it is the best representation of an abstract computer that we have.  Of course, abstraction is carried out on a variety of real computers, and not some imaginary computing devices.  Moreover, people understood the machine model underlying C. It is much easier for an average engineer to understand the machine model underlying C than the machine model Ada or even Scheme.  C succeeded because  he did the right thing, not because AT &amp; T advertised it or because Unix was written on it. <br><br>  C ++ is successful, because, instead of trying to propose a machine model, invented perhaps in the process of contemplating his navel, Bjarn began with C and tried to develop C further, providing more generalized programming techniques, but in the context of the framework of this machine model.  Machine model C is very simple.  You have a memory where the entities are located.  You have pointers to consecutive memory elements.  This is very easy to understand.  C ++ retains this model, but makes entities located in memory more exhaustive than in the C machine, since  C has a limited set of data types.  Namely, C has structures that provide a kind of extensible type system, but it does not allow you to define operations on structures.  This limits the extensibility of the type system.  C ++ has greatly advanced the machine model C to a truly extensible type system. <br><br>  In 1988, I moved to HP Labs, where I was hired to work on generic libraries.  For several years, I worked instead on hard drives, and it was exciting, but completely orthogonal to this area of ‚Äã‚Äãresearch.  I returned to the development of a generalized library in 1992, when Bill Worley, the former head of my laboratory, launched a project on algorithms with me as a manager.  C ++ had templates by that moment.  I found that Bjarn did an excellent job in designing patterns.  A long time ago, I took part in several discussions at Bell Laboratories about designing patterns, and argued with Bjarn quite toughly that he should make C ++ patterns as close to Ada generics as possible.  I think I argued so hard that he made the opposite decision.  I realized the importance of having template functions in C ++, and not just template classes, as many believe.  I thought, however, that the template functions should work as Ada generics, i.e.  that they should have been explicitly instantiated.  Bjarn did not listen to me and designed a template functions mechanism in which templates are explicitly instantiated using the overload mechanism.  This particular technique was decisive for my work, because  I found that she allowed me to do a lot of things that were impossible in Ada.  I see this particular design, developed by Bjarn, as an excellent result, and I am happy that he did not follow my advice. <br><br>  <b>When did you start working on the STL and what was its original purpose?</b> <br><br>  In 1992, when the project was formed, there were 8 people in it.  Gradually, the group decreased, and eventually included two - me and Meng Li.  While Meng was new to the field ‚Äî she developed compilers for most of her professional life, she accepted from start to finish the vision of generalized programming research, and believed that they could lead to changes in the software development process at a time when very few people shared this belief.  I don‚Äôt think I could construct STL without her help (after all, STL means Stepanov and Lee).    ,         ,   (),   ..   ,   .           ,    ,   ,   ,  -  .    ,  ,  ,       ,     ,      ,     .      -    !  ,   ,     .    ,     STL. <br><br> ( <a href="http://habrahabr.ru/post/167257/"></a> ) <br><br> ( <a href="http://www.sgi.com/tech/stl/drdobbs-interview.html"> </a> ) </div><p>Source: <a href="https://habr.com/ru/post/166849/">https://habr.com/ru/post/166849/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../166839/index.html">Cloud hosting as it should be</a></li>
<li><a href="../166841/index.html">10 reasons why you quit your job in 2013</a></li>
<li><a href="../166843/index.html">Open game development - preparation</a></li>
<li><a href="../166845/index.html">NoSQL and Big Data - deception of workers?</a></li>
<li><a href="../166847/index.html">5 days after the launch, file hosting Mega bypassed Rapidshare and Dropbox</a></li>
<li><a href="../166851/index.html">Radio transmitter from Raspberry Pi and a piece of wire</a></li>
<li><a href="../166855/index.html">About one little-known vulnerability in web sites</a></li>
<li><a href="../166857/index.html">On-line test of phones on the manufactured stand of servo drives, plastic and cardboard</a></li>
<li><a href="../166861/index.html">Write an algorithm for the ISS and win 10 thousand dollars</a></li>
<li><a href="../166863/index.html">Github has completely reworked the search.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>