<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parboiled Pro (Part 3)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 3: Data Extraction 

 In this article we will build a parser for the format of configuration files already described by us earlier. We also imple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parboiled Pro (Part 3)</h1><div class="post__text post__text-html js-mediator-article">  <strong>Part 3: Data Extraction</strong> <br><br>  In this article we will build a parser for the format of configuration files already described by us earlier.  We also implement a small DSL for easy access to the elements of the resulting tree.  From this article, you will also learn about the types of rules, the actions of the parser, as well as the ‚Äúdark matter‚Äù Parboiled - a stack of values. <br><br>  <strong>Cycle structure:</strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="http://habrahabr.ru/post/270233">Part 1. Why Parboiled?</a> </li><li>  <a href="http://habrahabr.ru/post/270531">Part 2. Comparison of the text</a> </li><li>  Part 3. Data Extraction </li><li>  <a href="http://habrahabr.ru/post/271003">Part 4. The harsh reality</a> </li></ul><br><a name="habracut"></a><br><h1>  Value Stack </h1><br>  Before extracting any data using the rules, you should tell a little about one of the concepts, which is implemented in Parboiled.  It is called the Value Stack and it can not quite correctly be translated as a ‚Äústack of values‚Äù.  It represents, indeed, a stack that is modified <em>by the</em> parser actions, the results of the rules are parsed into it and extracted from it.  It is to this stack that we must give a hint when declaring recursive rules.  In order for the elements to be placed on the stack, they must be explicitly captured, which will be reflected in the form of your rules.  Types of rules also reflect the number of captured items and their type.  Stack items can have a different type, and the typification of a stack of values ‚Äã‚Äãis checked at compile time. <br><br><h1>  Types of rules </h1><br>  In Parboiled2, the following types of rules exist: <br><br><ul><li> <code>Rule0</code> - simply answers the question "did it <code>Rule0</code> ?" Without changing the contents of the stack. </li><li>  <code>Rule1</code> - pushes one object <code>Rule1</code> stack of values. </li><li>  <code>Rule2</code> - <code>Rule2</code> two objects <code>Rule2</code> stack of values. </li><li>  <code>RuleN</code> - pushes N objects to the stack of values ‚Äã‚Äãusing the semantics of the Shapeless library.  You do not need to know Shapeless to work with Parboiled2 (although it will be useful). </li><li>  <code>PopRule</code> - retrieves values ‚Äã‚Äãfrom the stack, without placing new values ‚Äã‚Äãthere. </li></ul><br>  If you wish, you can declare your aliases for types, as it was in Parboiled1.  For example, in the Parboiled2 code, Rule2 is implemented: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rule2</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, +</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">B</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">RuleN</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span> :: <span class="hljs-type"><span class="hljs-type">B</span></span> :: <span class="hljs-type"><span class="hljs-type">HNil</span></span>]</code> </pre> <br>  In Parboiled1, for each number of arguments from 0 to 7, there was a separate type that created the so-called ‚Äú <code>Rule7</code> problem‚Äù: the <code>Rule8</code> class <code>Rule8</code> longer exists and putting eight items on the stack of values ‚Äã‚Äãdoes not work, even if you really want to.  There are various ways to work around this problem, and I‚Äôll tell you about one of them in the next article. <br><br><h1>  Parser actions </h1><br>  Parser actions should be called actions on the stack, since they allow you to extract data from the matching rules, convert them, and if you are highly corrupted, produce side effects with them (which may in some cases be really necessary, for example, if and the amount of data retrieved is not known in advance).  Using actions, you can form abstract syntax trees ( <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">AST</a> ), you can use them to calculate "on the spot", as is done in the <a href="https://github.com/sirthias/parboiled2/blob/master/examples/src/main/scala/org/parboiled2/examples/Calculator1.scala">example with a calculator</a> . <br><br><h1>  Exciting stories </h1><br>  To perform some useful action on the data, we need to capture them first.  There is a <code>capture</code> function for this: it matches the data with the rule and, if successful, puts it on a stack of values. <br><br>  Suppose we have a rule of the type <code>Rule0</code> , from which we want to get at least something: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule0</span></span> = rule { <span class="hljs-type"><span class="hljs-type">FirstName</span></span> ~ <span class="hljs-type"><span class="hljs-type">Separator</span></span> ~ <span class="hljs-type"><span class="hljs-type">LastName</span></span> }</code> </pre> <br>  We need to decide what we will capture, although it is obvious that the separator is of no artistic value: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule2</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = rule { capture(<span class="hljs-type"><span class="hljs-type">FirstName</span></span>) ~ <span class="hljs-type"><span class="hljs-type">Separator</span></span> ~ capture(<span class="hljs-type"><span class="hljs-type">LastName</span></span>) }</code> </pre> <br>  From this point on, our rule is no longer <code>Rule0</code> , but <code>Rule2</code> , since it captures and sends two lines to the stack of values.  However, the type can not be specified, the compiler will understand everything himself. <br><br><h2>  Operator of action ~&gt; </h2><br>  ... or the operator that you have to use the most.  It takes lambda as the right parameter and sends the objects captured from the stack to the input, thereby allowing the lambda to work with these objects.  Then, if you wish, you can send the values ‚Äã‚Äãback to the stack, or create a node from them for your AST - choose according to your taste.  In any case, in order for the action to take place, you must first capture the data on the stack using the <code>capture</code> function.  Depending on the type of the return value, different forms of the <code>~&gt;</code> operator are used, which makes the use of this operator simple and intuitive. <br><br><blockquote>  In Parboiled1, the capture was performed implicitly, which I find very uncomfortable. <br></blockquote><br>  Now a little more about the lambda.  Its signature depends on the number and typification of the captured objects, and a lambda can capture <a href="https://github.com/sirthias/parboiled2/issues/85">no more than 22 arguments at a time</a> .  The types of lambda arguments correspond to the types of values ‚Äã‚Äãremoved from the stack, and the types of return values ‚Äã‚Äãcorrespond to the types of values ‚Äã‚Äãput back on the stack. <br><br>  For example, let's try to extract at least one integer from the parser: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnsignedInteger</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = rule { capture(<span class="hljs-type"><span class="hljs-type">Digit</span></span>.+) ~&gt; (numStr =&gt; numStr.toInt) }</code> </pre> <br>  In this situation, the use of a brand Skalovsky placeholder is encouraged: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnsignedInteger</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = rule { capture(<span class="hljs-type"><span class="hljs-type">Digit</span></span>.+) ~&gt; (_.toInt) }</code> </pre> <br>  Here our lambda is of type <code>(String =&gt; Int)</code> , which determines the type of our rule - <code>Rule1[Int]</code> .  It is allowed to apply the <code>~&gt;</code> operator to a typed rule as well, for example, the following rule matches an integer, but pushes its double value onto the stack: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TwoTimesLarger</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">UnsignedInteger</span></span> ~&gt; (i =&gt; i * <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre> <br>  The type of the <code>TwoTimesLarger</code> rule will remain <code>Rule1[Int]</code> , only a different value will be on the stack. <br><br><blockquote>  Explicitly specifying the type of arguments to lambda functions is not the best idea (at least at the time of this writing).  In the Scala compiler, there is a very unpleasant bug that will not allow your code to compile properly. <br></blockquote><br>  We dealt with one argument, but what if there are several of them?  How will lambda behave?  Simple and predictable: the first parameter corresponds to the highest value on the stack, the second parameter to the second from the top, and so on.  Since the procedure of capturing subexpressions is performed <em>from right to left</em> , the order of the arguments of the lambda function corresponds to the order of writing the capture operations: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserWithLambda</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule2</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = rule { capture(<span class="hljs-type"><span class="hljs-type">FirstName</span></span>) ~ <span class="hljs-type"><span class="hljs-type">Separator</span></span> ~ capture(<span class="hljs-type"><span class="hljs-type">LastName</span></span>) ~&gt; ((firstName, lastName) =&gt; ...) }</code> </pre> <br>  Thanks to the action operator, we can reduce the number of values ‚Äã‚Äãon the stack: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserName</span></span></span><span class="hljs-function"> </span></span>= rule { <span class="hljs-type"><span class="hljs-type">User</span></span> ~&gt; ((firstName, lastName) =&gt; <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$firstName</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$lastName</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br>  In the example above, the original type of the <code>User</code> rule was <code>Rule2[String, String]</code> , applying the lambda function to it, we created a new <code>UserFirstName</code> rule with the type <code>Rule1[String]</code> . <br><br>  Lambda is not required to take <em>all the</em> parameters from the stack; you can limit yourself to the last N values ‚Äã‚Äã(remember that lambda takes arguments from the end of the stack): <br><br><pre> <code class="scala hljs">(foo: <span class="hljs-type"><span class="hljs-type">Rule2</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]) ~&gt; (_.toDouble) <span class="hljs-comment"><span class="hljs-comment">// foo: Rule2[Int, Double].</span></span></code> </pre> <br>  Nothing prevents us from trying to feed the lambda function rule, which has no arguments, with a predictable result: <br><br><pre> <code class="scala hljs">(foo: <span class="hljs-type"><span class="hljs-type">Rule0</span></span>) ~&gt; (() =&gt; <span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-comment"><span class="hljs-comment">// foo: Rule1[Int].</span></span></code> </pre> <br>  Parboiled2 has more powerful tools, for example, the ability to immediately return a group of values ‚Äã‚Äãfrom a lambda to the stack: <br><br><pre> <code class="scala hljs">(foo: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">Event</span></span>]) ~&gt; (e =&gt; e::<span class="hljs-type"><span class="hljs-type">DateTime</span></span>.now()::<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>::<span class="hljs-type"><span class="hljs-type">HNil</span></span>) <span class="hljs-comment"><span class="hljs-comment">// foo: RuleN[Event::DateTime::String::HNil]</span></span></code> </pre> <br>  In fact, we are constructing a corporate shapeless <code>HList</code> .  The type of the resulting rule will be <code>RuleN[Event::DateTime::String::HNil]</code> . <br><br>  Similarly, you can take values ‚Äã‚Äãfrom the stack of values ‚Äã‚Äãwithout giving anything in return: for this, the lambda only has to ‚Äúreturn‚Äù the type <code>Unit</code> .  The type of the resulting rule, as you probably guessed, is <code>Rule0</code> : <br><br><pre> <code class="scala hljs">(foo: rule1[<span class="hljs-type"><span class="hljs-type">String</span></span>]) ~&gt; (println(_)) <span class="hljs-comment"><span class="hljs-comment">// foo: Rule0</span></span></code> </pre> <br>  In addition, the action operator offers especially sweet sugar for case classes: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">foo: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Rule2</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">~&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>]</code> </pre> <br>  However, it should be noted that the compiler may not digest this sugar, if a companion object is defined for a case class.  Then you have to add a lambda, a few underscores and write: <code>~&gt; (Person(_, _))</code> . <br><br>  Sugar for case classes is ideal for building AST, experienced users may even notice that in this case it works quite similarly to the operator <code>~~&gt;</code> from Parboiled1.  There are other ways of applying <code>~&gt;</code> , but you will learn about them not from me, but from the documentation.  I will only note that the <code>~&gt;</code> operator is implemented in the Parboiled2 code in a very non-trivial way, but no matter how difficult its definition would look, it is a pleasure to use it.  Perhaps the best technical decision made at the stage of creating a DSL. <br><br><h2>  run </h2><br>  A special action operator version for thrill-seekers.  For a programmer, in many respects, <code>run</code> behaves exactly the same as <code>~&gt;</code> , except for the little inconvenience when in the case of <code>run</code> compiler does not automatically infer types and must be explicitly designated.  The operator is a very convenient tool for creating untestable side effects, for example as follows: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RuleWithSideEffect</span></span></span><span class="hljs-function"> </span></span>= rule { capture(<span class="hljs-type"><span class="hljs-type">EmailAddress</span></span>) ~ run { address: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; send(address, subj, message) } ~ <span class="hljs-type"><span class="hljs-type">EOI</span></span> }</code> </pre> <br>  The type of the resulting rule will be <code>Rule0</code> , and the matching string is not needed by anyone and will not fall into any stack of values, which is sometimes necessary.  Parboiled1 users probably noticed that in the context described above, <code>run</code> behaves the same way as the <code>~%</code> operator. <br><br><blockquote>  <strong>Warning:</strong> When using side effects, do not flirt with a stack of values.  Yes, you can get direct access to it, but for a number of reasons it is better not to do it. <br></blockquote><br><h2>  push </h2><br>  The <code>push</code> function places data on a stack of values ‚Äã‚Äãif the corresponding rule matches it.  In practice, I have not had to use it often, since most of the work can be done by the <code>~&gt;</code> operator, but there is an example in which <code>push</code> simply shines: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">True</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">False</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BoolMatch</span></span></span><span class="hljs-class"> </span></span>= rule { <span class="hljs-string"><span class="hljs-string">"true"</span></span> ~ push(<span class="hljs-type"><span class="hljs-type">True</span></span>) | <span class="hljs-string"><span class="hljs-string">"false"</span></span> ~ push(<span class="hljs-type"><span class="hljs-type">False</span></span>) }</code> </pre> <br><blockquote>  Although this is not noted anywhere, this rule follows the semantics of call-by-name and is evaluated every time, and therefore its argument is calculated every time.  This usually has a detrimental effect on performance, so <code>push</code> best used with constants and only with constants. <br></blockquote><br>  As in the case of <code>run</code> and <code>~&gt;</code> , the type of the value passed to <code>push</code> determines the contents of the stack and the type of rule being created. <br><br><h2>  Nested parsers </h2><br>  In Parboiled2, there is support for nested parsers: capturing the text and feeding it to the operator <code>~&gt;</code> we get the variable of the string type as a parameter of the lambda function.  After some operations with the side, we can feed it to some subparser and so on.  In practice, it was not necessary to apply, but you should know that there is such an opportunity. <br><br><h1>  AST generation </h1><br>  We have all the necessary knowledge to write our parser, generating a syntactic tree.  Syntax trees are built from nodes.  Therefore, we begin with them, or rather with their description: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AstNode</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyValueNode</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">key: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AstNode</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlockNode</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, nodes: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">AstNode</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AstNode</span></span></span></span></code> </pre> <br>  Each of the case classes corresponds to a particular type of node; everything seems to be clear and understandable.  Nevertheless, let's try to find something in common among the above nodes.  Everyone has a name, just in the case of a key-value pair, this is a key.  It is also necessary to distinguish the nodes among themselves. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AstNode</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">name</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyValueNode</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">override val name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AstNode</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlockNode</span></span></span><span class="hljs-class"> (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">override val name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, nodes: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">AstNode</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AstNode</span></span></span></span></code> </pre> <br>  Let's start with the node for key-value pairs.  We need to capture the key, capture the value and collect it all in the case class using the <code>~&gt;</code> operator.  Capture we will do "on the spot" (in the rules for the key and value).  And we start with the key: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//          def Key: Rule1[String] = rule { capture(oneOrMore(KeySymbol)) }</span></span></code> </pre> <br>  Just add <code>capture</code> and that's it - Parboiled thinks about us.  The string will be sent to the stack.  But with the capture of values, the situation is more complicated.  If we verify an operation similar to the key, we will receive a string with quotes.  We need them?  Therefore, we will capture the line: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QuotedString</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = rule { '<span class="hljs-string"><span class="hljs-string">"' ~ capture(QuotedStringContent) ~ '"</span></span>' }</code> </pre> <br>  You don‚Äôt need to do anything for the Value rule, it will automatically be of type Rule1 (since the body of the string was captured earlier, it didn‚Äôt go away from the stack). <br><br><blockquote>  Capture <code>capture</code> needs to be done once.  And preferably, in the rule where it should have happened <br></blockquote><br>  Now we will collect case class: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KeyValuePair</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">AstNode</span></span>] = rule { <span class="hljs-type"><span class="hljs-type">Key</span></span> ~ <span class="hljs-type"><span class="hljs-type">MayBeWS</span></span> ~ <span class="hljs-string"><span class="hljs-string">"="</span></span> ~ <span class="hljs-type"><span class="hljs-type">MayBeWS</span></span> ~ <span class="hljs-type"><span class="hljs-type">Value</span></span> ~&gt; <span class="hljs-type"><span class="hljs-type">KeyValueNode</span></span> }</code> </pre> <br>  We use syntactic sugar and elegantly pack the obtained key and value into a suitable node.  Of course, we can use the extended lambda syntax and perform any transformations.  But we do not need them.  Now let's deal with the list of nodes: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,       def Node: Rule1[AstNode] = rule { KeyValuePair | Block }</span></span></code> </pre> <br>  Since each of the nodes is captured, the <code>Nodes</code> rule does not require changes, unless you specify the type of value to be placed on the stack: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Nodes</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">AstNode</span></span>]] = rule { <span class="hljs-type"><span class="hljs-type">MayBeWS</span></span> ~ zeroOrMore(<span class="hljs-type"><span class="hljs-type">Node</span></span>).separatedBy(<span class="hljs-type"><span class="hljs-type">NewLine</span></span> ~ <span class="hljs-type"><span class="hljs-type">MayBeWS</span></span>) ~ <span class="hljs-type"><span class="hljs-type">MayBeWS</span></span> }</code> </pre> <br>  We have everything to describe the block node.  The name will be captured in place, similar to the rule for the key: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BlockName</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = rule { capture(oneOrMore(<span class="hljs-type"><span class="hljs-type">BlockNameSymbol</span></span>.+)) }</code> </pre> <br>  Nodes have already been captured, so just collect the data in the case class: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Block</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">AstNode</span></span>] = rule { <span class="hljs-type"><span class="hljs-type">BlockName</span></span> ~ <span class="hljs-type"><span class="hljs-type">MayBeWS</span></span> ~ <span class="hljs-type"><span class="hljs-type">BlockBeginning</span></span> ~ <span class="hljs-type"><span class="hljs-type">Nodes</span></span> ~ <span class="hljs-type"><span class="hljs-type">BlockEnding</span></span> ~&gt; <span class="hljs-type"><span class="hljs-type">BlockNode</span></span> }</code> </pre> <br>  The rule that describes the root of a tree also consists of nodes, so you can do nothing more.  And everything seems to be working well and I don‚Äôt want to change anything, however, the result does not look very nice: we have two types of nodes, and the root that represents the list of nodes.  And the third is clearly superfluous.  We can represent the root as a block, with a special name. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Root</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Rule1</span></span>[<span class="hljs-type"><span class="hljs-type">AstNode</span></span>] = rule { <span class="hljs-type"><span class="hljs-type">Nodes</span></span> ~ <span class="hljs-type"><span class="hljs-type">EOI</span></span> ~&gt; {nodes: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">AstNode</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">BlockNode</span></span>(<span class="hljs-type"><span class="hljs-type">RootNodeName</span></span>, nodes)} }</code> </pre> <br>  What name to choose?  We can give the block a conscious name, such as root, but then unexpected surprises can await us if someone wants to choose the name root.  Knowing that BlockName is an identifier that does not allow a series of characters, you can try names like <code>"$root"</code> , <code>"!root!"</code>  or <code>"%root%"</code> .  Will work.  I prefer the blank line: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">RootNodeName</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span></code> </pre> <br>  Empty line: <br><br><ul><li>  Satisfies the main requirement ‚Äî it is not a valid block or key name; </li><li>  Perfect if we want to expand the grammar.  As if we did not torture the parser, something that, and the user definitely will not create an empty string. </li></ul><br>  Now we have captured data.  It remains only to perform a run from the root for a suitable text. <br><br><h1>  DSL for working with nodes </h1><br>  Having received a working parser capable of rendering a syntax tree, we must somehow work with this tree.  Creating a small DSL greatly simplifies this task.  For example, we need to go to the next node by name.  You can write the same code each time, or you can make a small method (duplicated by an overloaded statement) that can return the next node.  Below are the basic methods needed to work with AstNode.  On the basis of which you can do a lot of others (most suitable for your needs).  If you want, you can give them symbolic names and admire the beauty of the received DSL. <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">/** *       parboiled */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeAccessDsl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>: <span class="hljs-type"><span class="hljs-type">AstNode</span></span> =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isRoot</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name == <span class="hljs-type"><span class="hljs-type">BkvParser</span></span>.<span class="hljs-type"><span class="hljs-type">RootNodeName</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isBlockNode = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _: <span class="hljs-type"><span class="hljs-type">KeyValueNode</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-comment"><span class="hljs-comment">/** *         * - */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pairs</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">KeyValueNode</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">BlockNode</span></span>(_, nodes) =&gt; nodes collect { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> node: <span class="hljs-type"><span class="hljs-type">KeyValueNode</span></span> =&gt; node } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-type"><span class="hljs-type">Seq</span></span>.empty } <span class="hljs-comment"><span class="hljs-comment">/** *        *  */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blocks</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">BlockNode</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">BlockNode</span></span>(_, nodes) =&gt; nodes collect { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> node: <span class="hljs-type"><span class="hljs-type">BlockNode</span></span> =&gt; node } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-type"><span class="hljs-type">Seq</span></span>.empty } <span class="hljs-comment"><span class="hljs-comment">/** *     "-" */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">KeyValueNode</span></span>(_, value) =&gt; <span class="hljs-type"><span class="hljs-type">Some</span></span>(value) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-type"><span class="hljs-type">None</span></span> } }</code> </pre> <br>  I want to note that there are no unnecessary methods, and almost every time they are required: a recursive search, the ability to change values ‚Äã‚Äãin the nodes (by changing the state, or using <a href="http://stackoverflow.com/questions/8307370/functional-lenses">lenses</a> ).  Having a variety of auxiliary methods working with wood makes life a lot easier. <br><br>  As a result, we wrote a functional parser using Parboiled2, and made the work with the resulting syntax tree relatively comfortable.  In the next article I will discuss the additional features of the library and the process of optimizing performance.  Also will be considered the process of migration from the previous version.  I'll tell you about the shortcomings, and how to live with these shortcomings. <br><br>  Parser code can be found <a href="https://github.com/ppopoff/bkv-parser">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/270609/">https://habr.com/ru/post/270609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270599/index.html">The worm that changed the Internet</a></li>
<li><a href="../270601/index.html">Digest KolibriOS # 10: briefly about the accumulated</a></li>
<li><a href="../270603/index.html">Fast closing tabs in the assembly Vivaldi 1.0.321.3</a></li>
<li><a href="../270605/index.html">Google will close Chrome web browser support for Windows XP and Vista</a></li>
<li><a href="../270607/index.html">Insider API: search for trends and quick navigation in the texts of social. and traditional media</a></li>
<li><a href="../270611/index.html">IPv6 configuration in Linux OS Debian v7.XX, Ubuntu v14.XX, CentOS v6.XX and FreeBSD v10.XX</a></li>
<li><a href="../270615/index.html">How to store a complex hierarchy of settings in Redmine projects</a></li>
<li><a href="../270617/index.html">Minify a project created in Blocs 1.5.2 using Gulp</a></li>
<li><a href="../270619/index.html">How we teach machine learning and data analysis in Beeline</a></li>
<li><a href="../270621/index.html">Six years go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>