<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pure pragmatic architecture. Brainstorm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Did you get the idea to rewrite your fat enterprise application from scratch? If from scratch, then it's woo hoo. At least the code will be two times ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pure pragmatic architecture. Brainstorm</h1><div class="post__text post__text-html js-mediator-article">  Did you get the idea to rewrite your fat enterprise application from scratch?  If from scratch, then it's woo hoo.  At least the code will be two times less, right?  But a couple of years will pass, and it will also grow, it will become a legacy ... there is not much time and money for rewriting to make it perfect. <br><br>  Calm down, the authorities still will not give anything to rewrite.  It remains to refactor.  What is the best way to spend your small resources?  How exactly to refactor, where to clean? <br><br>  The title of this article - including a reference to Uncle Bob <a href="https://habr.com/company/piter/blog/353170/">'s</a> book <a href="https://habr.com/company/piter/blog/353170/">"Pure Architecture"</a> , and it was made on the basis of the remarkable Victor Rentea report ( <a href="https://twitter.com/victorrentea%3Flang%3Dru">twitter</a> , <a href="http://victorrentea.ro/">site</a> ) at JPoint (under the cut he will speak from the first person, but for now read the introductory one).  Reading smart books is not a substitute for this article, but it‚Äôs written very well for such a short description. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The idea is that popular things like ‚ÄúClean Architecture‚Äù are really useful.  Surprise.  If you need to solve a very specific problem, a simple elegant code does not require super efforts and over-engineering.  Pure architecture says that you need to protect your domain model from external effects, and tells you exactly how to do this.  An evolutionary approach to increasing the volume of microservices.  Tests that make refactoring less scary.  You know all this already?  Or you know, but you are afraid to even think about it, because this is a horror then what will you have to do? <br><br>  Who wants to get a magic anti-procrastination pill that will help to stop shaking and start refactoring - welcome to the video report or under the cat. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mBxpOvlbAow" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><br>  My name is Victor, I'm from Romania.  Formally, I am a consultant, technical leader and leading architect at IBM in Romania.  But if I were asked to define my activities myself, then I am a clean code evangelist.  I love to create a beautiful, clean, supported code - as a rule, I tell about it on reports.  Even more, I am inspired by teaching: training for developers in the areas of Java EE, Spring, Dojo, Test Driven Development, Java Performance, as well as in the field of evangelism mentioned above - the principles of cleanliness of code patterns and their development. <br><br>  The experience on which my theory is based is mainly the development of enterprise applications for the largest IBM client in Romania, the banking sector. <br><br>  The plan for this article is: <br><br><ul><li>  Data modeling: data structures should not become our enemies; <br></li><li>  Logic organization: the principle of ‚Äúcode decomposition, of which there are too many‚Äù; <br></li><li>  Onion is the purest Transaction Script philosophy architecture; <br></li><li>  Testing as a way to deal with developer fears. <br></li></ul><br><br>  But first, let's remember those main principles that we, as developers, should always remember. <br><br><h4>  Principle of sole responsibility </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/353/dd0/cd5/353dd0cd58012749b70e379e37231265.jpg"><br><br>  In other words, quantity vs quality.  As a rule, the more functionality your class contains, the worse it is in quality terms.  When developing large classes, the programmer gets confused, makes mistakes in building dependencies, and large code, among other things, is harder to debug.  It is better to break such a class into several smaller ones, each of which will be responsible for a certain subtask.  Let it be better you have several strongly connected modules, than one - large and clumsy.  Modularity also makes it possible to reuse logic. <br><br><h4>  Loose coupling of modules </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/1c8/0f7/f721c80f7b3184be2218a01b66f7440a.jpg"><br><br>  The degree of binding is a characteristic of how closely your modules interact with each other.  It shows how widely the effect of the changes you make at any one point in the system can spread.  The higher the binding, the more difficult it is to implement modifications: you change something in one module, and the effect spreads far and not always in the expected way.  Therefore, the binding rate should be as low as possible - this will give you greater control over the system undergoing modifications. <br><br><h4>  Do not repeat </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/9de/5c0/2b99de5c00257d6123553c7bfaed0519.jpg"><br><br>  Your own implementations may be good today, but not so good tomorrow.  Do not allow yourself to copy your own work and thus distribute them on the code base.  You can copy from StackOverflow, from books - from any reputable sources that (as you know for sure) offer an ideal (or close to that) implementation.  It is very tiring to modify your own implementation, which occurs not only once, but multiplied throughout the code base. <br><br><h4>  Simplicity and conciseness </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d4/8d4/c85/7d48d4c85408c620ddcbe644c4acb6f9.jpg"><br><br>  In my opinion, this is the main principle that must be followed in engineering and software development.  ‚ÄúPremature encapsulation is the root of evil,‚Äù said Adam Bien.  In other words, the root of evil is "re-engineering."  The author of the quote, Adam Bien, was at one time engaged in taking legacy applications and, completely rewriting their code, received a code base 2-3 times smaller than the original one.  Where does so much extra code come from?  After all, it does not just happen.  It is generated by the fears we experience.  It seems to us that, piling up patterns in a large number, producing indirectness and abstraction, we provide our code with protection ‚Äî protection from the unknowns of tomorrow and tomorrow's requirements.  After all, in actual fact, today we do not need any of this, we invent all this just for the sake of some ‚Äúfuture needs‚Äù.  And it is possible that these data structures will subsequently interfere.  Frankly, when some developer comes up to me and voices that he came up with something interesting that you can add to the production code, I always answer the same way: ‚ÄúBoy, this will not be useful for you.‚Äù <br><br>  There should not be a lot of code, but the one that is should be simple - only in this way can it work normally.  This is a concern for your developers.  You have to remember that they are the key figures for your system.  Try to reduce their energy costs, reduce the risks with which they will have to work.  This does not mean that you will have to create your own framework, moreover, I would not advise you to do this: there will always be bugs in your framework, everyone will need to learn it, etc.  It is better to use existing funds, of which there is a mass today.  These should be simple solutions.  Register global error handlers, apply aspect technology, code generators, Spring extensions or CDI, configure Request / Thread scopes, use bytecode and manipulation on the fly, etc. All this will be your contribution to the truly important thing - to the comfort of your developer. <br><br>  In particular, I would like to show you the use of Request / Thread areas.  I have often observed how this thing simplified corporate applications in an incredible way.  The bottom line is that it gives you the opportunity, being logged in by the user, to store RequestContext data.  Thus, RequestContext will store user data in a compact form. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/341/6c5/474/3416c54740aca3b8f514696bf9cf7f3d.jpg"><br><br>  As you can see, the implementation takes only a couple of lines of code.  By writing the request to the desired annotation (it is easy to do if you use Spring or CDI), you will forever free yourself from having to pass a user login to the methods and whatever else: the metadata stored in the context will move the application transparently.  Scoped proxy allows you to access the metadata of the current request at any time. <br><br><h4>  Regression tests </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c5/edf/d7a/5c5edfd7a14d760bc335d8e65f0d5666.jpg"><br><br>  Developers are afraid of the requirements being updated because they are afraid of the refactoring procedure (code modification).  And the easiest way to help them is to create a reliable set of tests for regression testing.  With it, the developer will be able to test his work at any time - to make sure that it does not break the system. <br><br>  The developer should not be afraid to break anything.  You must do everything so that refactoring is perceived as something good. <br>  Refactoring is a crucial aspect of development.  Remember, exactly at the moment when your developers are afraid of refactoring, the application can be considered to have passed into the category of "Legacy." <br><br><h2>  Where to implement business logic? </h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fb/8a2/08d/4fb8a208dc6d89279a663747de74369f.jpg"><br><br>  Starting the implementation of any system (or system components), we ask ourselves the question: where is it better to implement the domain logic, that is, the functional aspects of our application?  There are two opposite approaches. <br>  The first one is based on the philosophy of <i>Transaction Script</i> .  Here, logic is implemented in procedures that work with <a href="https://en.wikipedia.org/wiki/Anemic_domain_model">anemic entities</a> (that is, with data structures).  Such an approach is good because in the course of its implementation it is possible to rely on formulated business objectives.  While working on applications for the banking sector, I have repeatedly observed the transfer of business procedures to software.  I can say that it is really very natural to correlate scripts with software. <br><br>  An alternative approach is to use the principles of <i>Domain-Driven Design</i> .  Here, you will need to relate the specifications and requirements with the object-oriented methodology.  It is important to think carefully over the objects, and to ensure good business involvement.  The advantage of the systems so designed is that they are easily maintained in the future.  However, in my experience, mastering this methodology is rather difficult: you feel more or less brave no sooner than after six months of studying it. <br><br>  For my development, I always chose the first approach.  I can assure you that in my case it worked perfectly. <br><br><h2>  Data modeling </h2><br><br><h4>  Entities </h4><br><br>  How do we simulate data?  As soon as the application accepts more or less decent sizes, <i>persistent data is</i> sure to appear.  This is the data that you need to keep longer than others - they are the <i>domain entities</i> (domain entities) of your system.  Where to store them ‚Äî whether in a database, in a file, or directly managing memory ‚Äî does not matter.  What matters is <i>how</i> you will store them ‚Äî in which data structures. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a8/56b/127/0a856b127ec938a8c17eb345610b0ee8.jpg"><br><br>  As a developer, this choice is given to you, and it only depends on you whether these data structures will work for you or against you in the implementation of functional requirements in the future.  For everything to be good, you must implement the entities, laying in them the nuggets of <i>reused domain logic</i> .  How exactly?  I will demonstrate several ways by example. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c73/e56/7da/c73e567da2fb69ceb3d627fb408530cd.jpg"><br><br>  Let's see what I have provided with the Customer entity.  First, I implemented the <code>getFullName()</code> <i>synthetic getter</i> , which will return me the concatenation of firstName and lastName.  I also implemented the <code>activate()</code> method to control the state of my entity, thus encapsulating it.  In this method, I put, firstly, the <i>operation on validation</i> , and, secondly, the <i>assignment of values ‚Äã‚Äãto the</i> status and activatedBy <i>fields</i> , so that it is not necessary to prescribe setters for them.  I also added the <code>isActive()</code> and <code>canPlaceOrders()</code> methods to the Customer entity, performing lambda validation within themselves.  This is the so-called predicate encapsulation.  Such predicates are useful if you use Java 8 filters: you can pass them as arguments to filters.  I advise you to use these helpers. <br><br>  Perhaps you are using some kind of ORM like Hibernate.  Suppose you have two entities with two-way communication.  Initialization must be performed on both sides, otherwise, as you understand, you will encounter problems when accessing this data in the future.  But developers often forget to initialize an object from one of the parties.  You, developing these entities, can provide special methods that will guarantee two-way initialization.  Look at <code>addAddress()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c55/7fe/273/c557fe273cc1f2658573f9e78a70ca1d.png"><br><br>  As you can see, this is a completely ordinary entity.  But inside it laid the domain logic.  Such entities should not be scanty and superficial, but they should not be overflowed with logic.  Logic overflow occurs more often: if you decide to implement all the logic in the domain, then for each use-case there will be a temptation to implement some specific method.  And use-cases, as a rule, are many.  You will not get an entity, but one big pile of all sorts of logic.  Try to observe a measure here: only <i>reusable logic</i> is placed in the domain and only <i>in a small amount.</i> <i><br><br></i> <h4>  <i>Value objects</i> </h4> <i><br><br></i>  In addition to entities, you will most likely also need object values.  This is nothing more than a way to group the domain data in order to move it along the system together. <br><br>  The value object must be: <br><br><ul><li>  <b>Small</b> .  No <code>float</code> for monetary variables!  Be very careful when choosing data types.  The more compact your object, the easier it will understand the new developer.  This is the basis of the foundations for a comfortable life. <br></li><li>  <b>Unchangeable</b> .  If the object is really immutable, then the developer can be sure that your object will not change its value or break after creation.  This lays the foundation for a calm, confident job. <br></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/765/284/a0e76528432de8c55dc146805a8b286d.jpg"><br><br>  And if you add a call to the constructor method <code>validate()</code> , then the developer can be calm for the validity of the created entity (when transferring, say, a nonexistent currency or a negative amount of money, the designer will not work). <br><br><h4>  The difference of an entity from a value object </h4><br><br>  Value objects differ from entities in that they do not have a permanent ID.  In entities there will always be fields associated with the foreign key of some table (or other storage).  Object values ‚Äã‚Äãdo not have such fields.  The question arises: do the procedures for checking for equality of two value objects and two entities differ?  Since value objects have no ID field in order to conclude that two such objects are equal, it is necessary to compare the values ‚Äã‚Äãof all their fields in pairs (that is, to inspect the entire contents).  When comparing entities, it suffices to conduct a single comparison ‚Äî across the ID field.  It is in the comparison procedure that the main difference between entities and value objects lies. <br><br><h4>  Data Transfer Objects (DTOs) </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/72a/d31/681/72ad31681509cdef20509d4514b02139.jpg"><br><br>  What is the interaction with the user interface (UI)?  You must give him the <i>data to display</i> .  Will another structure be needed?  And there is.  That's because the user interface is not your friend.  He has his own requests: he needs the data to be stored in accordance with how they should be displayed.  This is so wonderful - what exactly user interfaces and their developers require from us.  Then they need to get data for five lines;  then it occurs to them to get a boolean <code>isDeletable</code> field for an object (can an object have such a field?) to know whether to make the ‚ÄúDelete‚Äù button active or not.  But there is nothing to be outraged.  User interfaces have other requirements. <br><br>  The question is, is it possible to trust our entities with them?  Most likely, they will change them, and in the most undesirable way for us.  Therefore, we will provide them with something else - <i>Data Transfer Objects</i> (DTO).  They will be adapted specifically for external requirements and for logic that is different from ours.  Some examples of the DTO structures are: Form / Request (come from the UI), View / Response (sent to the UI), SearchCriteria / SearchResult, etc. You can in a sense call this an API model. <br><br>  The first important principle: DTO must contain a minimum of logic. <br>  This is an example implementation of <code>CustomerDto</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ec/3bb/716/4ec3bb716c630f3b39ca82f8fe4c5e33.jpg"><br><br>  Content: <i>private</i> fields, <i>public-</i> getters and setters for them.  It seems to be all super.  OOP in all its glory.  But one thing is bad: in the form of getters and setters, I implemented too many methods.  In DTO, the logic should be as small as possible.  And then what is my way out?  I make the fields public!  You will say that it does not work well with method references from Java 8, that restrictions will arise, etc. But believe it or not, I did all my projects (10-11 pieces) with such DTOs.  Brother is alive.  Now, since my fields are public, I have the ability to easily assign the value <code>dto.fullName</code> by simply setting the equal sign.  What could be more beautiful and easier? <br><br><h2>  Organization of logic </h2><br><br><h4>  Mapping </h4><br><br>  So, we have a task: we need to transform our entities into a DTO.  We implement the transformation as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/dfd/ca8/995dfdca8c1945fb92a64cee09851259.jpg"><br><br>  As you can see, by declaring a DTO, we move on to mapping operations (assignment of values).  Do I need to be a senior developer to write ordinary assignments in such a quantity?  For some, it is so unusual that they begin to change their shoes on the go: for example, to copy data using some kind of mapping framework using reflex.  But they miss the main point - that sooner or later the UI will interact with the DTO, as a result of which the entity and the DTO will diverge in their meanings. <br><br>  We could, for example, put mapping operations in a constructor.  But this is not possible for any mapping;  in particular, the designer cannot access the database. <br><br>  Thus, we have to leave the mapping operations in the business logic.  And if they have a compact look, then there is nothing wrong with that.  If the mapping does not take a couple of lines, but more, then it is better to put it in the so-called <i>mapper</i> .  Mapper is a class specifically designed for copying data.  This is, in general, antediluvian thing and a boilerplate.  But behind them, you can hide our numerous assignments - to make the code cleaner and slimmer. <br><br>  Remember: the <i>code that has grown too much, you need to make a separate structure</i> .  In our case, the mapping operations were really a bit much, so we carried them into a separate class - to the mapper. <br><br>  Do mappers allow database access?  You can allow it by default - this is often done for reasons of simplicity and pragmatics.  But it puts you at some risk. <br><br>  I will illustrate with an example.  Let's create the <code>Customer</code> entity based on the existing DTO. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef3/9e8/b82/ef39e8b82a023a2fad6afe8e3c22b5ec.png"><br><br>  For mapping, we need to get a link to the customer group from the database.  So I run the <code>getReference()</code> method, and it returns some entity to me.  The request will most likely go to the database (in some cases this does not happen, and the stub function works). <br><br>  But trouble awaits us not here, but in the method that performs the inverse operation ‚Äî transformation of the entity into DTO. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6a/e27/7ff/e6ae277ff6b22588b5bc5aaffabf9d0e.png"><br><br>  With the help of a cycle, we go through all the addresses associated with the existing Customer, and convert them into DTO addresses.  If you use ORM, then, probably, when you call the <code>getAddresses()</code> method, the lazy loading will be executed.  If you do not use ORM, then it will be an open request to all children of this parent.  And here you run the risk of getting into the ‚ÄúN + 1 problem‚Äù.  Why? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/001/2bb/e540012bbb4a242d84e55a2dffa5ca11.jpg"><br><br>  You have a set of parents, each of whom has children.  For all this, you need to create your own analogs inside the DTO.  You will need to perform one <code>SELECT</code> query to bypass N parent entities, and then another N <code>SELECT</code> queries to bypass the children of each of them.  Total N + 1 request.  For 1000 parent <code>Customer</code> entities, such an operation takes 5-10 seconds, which, of course, takes a long time. <br><br>  Suppose that, nevertheless, our <code>CustomerDto()</code> method is called inside the loop, converting the list of Customer objects into the <code>CustomerDto</code> list. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58c/9c3/2b3/58c9c32b3e8a01a96d500920dfe5ef07.jpg"><br><br>  The problem with N + 1 queries has simple typical solutions: in <i>JPQL,</i> you can use <code>FETCH</code> on customer.addresses to retrieve children and then join them using <code>JOIN</code> , and in SQL you can use <code>IN</code> traversal and the <code>WHERE</code> operator. <br><br>  But I would have done differently.  You can find out what is the maximum length of the list of children (this can be done, for example, on the basis of a search with pagination).  If there are only 15 entities in the list, then we need only 16 requests.  Instead of 5ms, we will spend on everything, say, 15ms - the user will not notice the difference. <br><br><h4>  About optimization </h4><br><br>  I would not advise you to look at the performance of the system at the initial stage of development.  As Donald Knud said: "Premature optimization is the root of evil."  You can not optimize from the beginning.  This is exactly what needs to be left for later.  And what is especially important: <i>no assumptions - only measurements and measurement of measurements!</i> <br><br>  Are you sure that you are competent, that you are a real expert?  Be modest in assessing yourself.  Do not think that you understood the work of the JVM until you read at least a couple of books about JIT compilation.  It happens that the best programmers from our team come up to me and say that, <i>as it seems to them</i> , they have found a more efficient implementation.  It turns out that they again invented something that only complicates the code.  Therefore, I answer time after time: YAGNI.  We do not need it. <br><br>  Often for corporate applications no optimization of algorithms is required at all.  The bottleneck for them, as a rule, is not a compilation, and not what concerns the operation of the processor, but various input-output operations.  For example, reading a million lines from a database, volume records to a file, interaction with sockets. <br><br>  Over time, you begin to understand what bottlenecks the system contains, and, having backed up all the measurements, you will begin to gradually optimize.  Until then, keep the code as clean as possible.  You will find that such code is much easier to further optimize. <br><br><h4>  Prefer composition to inheritance. </h4><br><br>  Let's return to our DTO.  Suppose we have defined such a DTO: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/180/39d/f91/18039df91fd1cc76a2413b7f373e7c0b.png"><br><br>  We may need it in a variety of workflows.  But these streams are different and, most likely, each use-case will imply a different degree of field filling.  For example, we obviously need to create a DTO earlier than when we have complete information about the user.  You can temporarily leave the field blank.  But the more fields you ignore, the more you will want to create a new, more restrictive DTO for a given use-case. <br><br>  Alternatively, you can create copies of an excessively large DTO (in the number of available use cases) and then remove the extra fields from each copy.  But for many programmers, by virtue of intelligence and literacy, it really hurts to press Ctrl + V.  Axiom says that copy-paste is bad. <br><br>  You can resort to the <i>inheritance</i> principle known in OOP theory: we simply define a certain basic DTO and for each use-case we create a successor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f7/069/77f/6f706977fec8625d720323b64fe87ad8.png"><br><br>  The well-known principle says: "Prefer composition to inheritance."  Read what it says: <i>"extends</i> . <i>"</i>  It seems that we had to "expand" the original class.  But if you think about it, what we have now done is not at all an ‚Äúextension‚Äù.  This is the most real "repetition" - the same copy-paste, side view.  Therefore, we will not use inheritance. <br><br>  But how then can we be?  How to go to the composition?  Let's do it like this: write a field in the CustomerView that points to the base DTO object. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f2/d49/831/1f2d49831b9b286b8bc069c824ac2871.jpg"><br><br>  Thus, our basic structure will be embedded inside.  This is how the real composition will come out. <br><br>  Whether we use inheritance or solve the problem of composition - these are all particulars, subtleties that have arisen deeply in the course of our implementation.  They are very <i>fragile</i> .  What do fragile mean?  Look carefully at this code: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/921/eb1/ef2/921eb1ef20effd43b129ad5d28b88253.png"><br><br>  Most of the developers to whom I showed it, immediately blurted out that the number "2" is repeated, so it must be rendered as a constant.  They did not notice that the two in all three cases has a completely different meaning (or "business value") and that its repetition is nothing more than a coincidence.  Making a deuce in a constant is a legitimate solution, but very fragile.  Try not to allow fragile logic to the domain.  Never work from it with external data structures, in particular, with DTO. <br><br>  So, why is the work on the elimination of inheritance and the introduction of the composition is useless?  It is precisely because we create DTO not for ourselves, but for an external client.  And how the client application will parse the DTO received from you - you just have to guess.  But it is obvious that this will have little to do with your implementation.  Developers on the other side may not make a distinction for the basic and non-basic DTOs that you have so carefully thought out;  for sure they use inheritance, and perhaps stupidly copy-paste that‚Äôs all. <br><br><h4>  Facades </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/be7/31c/9e4/be731c9e4cfe002cb3b59c11a708f623.jpg"><br><br>  Let's return to the overall picture of the application.  I would advise you to implement domain logic through the <i>Facade pattern</i> , expanding the facades with <i>domain services</i> as needed.  Domain service is created when too much logic accumulates in the facade, and it is more convenient to put it into a separate class. <br>  Your domain services must speak the language of your domain model (its entities and value objects).  In no case should they work with DTO, because, as you remember, DTO are structures that are constantly changing on the client side, too fragile for a domain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/eb8/657/3adeb86570a92f804ba491836c99b9e8.jpg"><br><br>  What is the purpose of the facade? <br><br><ol><li>  Data conversion  If we have entities from one end and DTO from the other, it is necessary to convert from one to the other.  And this is the first thing for what facades are needed.  If the conversion procedure has expanded in size - use mapping classes. <br></li><li>  The implementation of logic.  In the facade you will begin to write the main logic of the application.  As soon as it becomes a lot - take out the parts in the domain service. <br></li><li>  Validation of data.  Remember that any data from the user by definition is incorrect (containing errors).  The facade has the ability to validate the data.  These procedures, when exceeding the volume, are taken to be <i>validators</i> . <br></li><li>  Aspects.  You can go ahead and make each use-case pass through its facade.  Then it will be possible to build on the facade methods such things as transactions, logging, global exception handlers, etc. I note that it is very important to have global exception handlers in any application that would catch all errors not caught by other handlers.  They will greatly help your programmers - they will give them peace of mind and freedom of action. <br></li></ol><br><br><h4>  Code decomposition </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/604/a9c/8e8/604a9c8e859ff1dc3fb38208d6bf836d.jpg"><br><br>  Just a couple of words about this principle.  If the class has reached some size that is inconvenient for me (say, 200 lines), then I should try to break it apart.  But it is not always easy to select a new class from the existing one.  We need to come up with some universal ways.  One of these ways is to search for names: you try to pick a name for a subset of the methods in your class.  As soon as you manage to find the name - feel free to create a new class.  But this is not so easy.  In programming, as you know, there are only two difficult things: it is cache invalidation and inventing names.  In this case, inventing a name is associated with the identification of a subtask - hiding and therefore not previously identified. <br><br>  Example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81f/fe3/82b/81ffe382b74f6bbd4a91626d83249a97.jpg"><br><br>  In the initial fa√ßade of <code>CustomerFacade</code> some of the methods are directly related to the buyer, and some are related to the preferences of the buyer.  Based on this, I will be able to split the class into two parts when it reaches critical sizes.  I will receive two fronts: <code>CustomerFacade</code> and <code>CustomerPreferencesFacade</code> .  The only bad thing is that both of these facades belong to the same level of abstraction.  Separation by levels of abstraction suggests something else. <br><br>  One more example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ac/84e/788/2ac84e788af60fb038091aed273a390e.jpg"><br><br>  Suppose there is a class <code>OrderService</code> in our system in which we implemented an email notification mechanism.  Now we are creating <code>DeliveryService</code> and would like to use the same notification mechanism here.  Kopipast - excluded.  Let's do this: extract the functionality of notifications to the new class <code>AlertService</code> and write it as a dependency for the <code>DeliveryService</code> and <code>OrderService</code> .  Here, in contrast to the previous example, the separation occurred precisely according to levels of abstraction. <code>DeliveryService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more abstract than </font></font><code>AlertService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">because it uses it </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as part of</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> its workflow. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The division into levels of abstraction always assumes that the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">class</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> being </font><i><font style="vertical-align: inherit;">extracted becomes an addiction</font></i><font style="vertical-align: inherit;"> , and the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extraction is carried out for reuse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The extraction task is not always easy. </font><font style="vertical-align: inherit;">It can also entail some difficulties and require some refactoring of unit tests. </font><font style="vertical-align: inherit;">Nevertheless, according to my observations, it is even harder for developers to search for any kind of functionality based on the huge monolithic code base of the application.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pair programming </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/625/5b2/346/6255b23467294d6224107235443379f1.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many consultants will tell you about pair programming, about the fact that this is a universal solution to any problems of IT development today. During it, programmers develop their technical skills and functional knowledge. In addition, the process itself is interesting, it rallies the team. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we speak not as consultants, but humanly, the most important thing here is: pair programming improves the ‚Äúbus factor‚Äù. The essence of the ‚Äúbus factor‚Äù is that there </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should be as many people with knowledge about the system as possible</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Losing these people means losing the last keys to this knowledge.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Re-factoring in the pair programming format is an art that requires experience and training. Here, for example, the practice of aggressive refactoring, hacking, coding, coding dojos, etc. are useful. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pair programming works well in cases where you need to solve problems of high complexity. The process of working together is not always easy. But he guarantees you that you will avoid "reengineering" - on the contrary, you will get an implementation that addresses the requirements with minimum complexity. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a5a/5aa/666/a5a5aa666cb29c58dc9bb5b7d5bc6651.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Organizing a convenient work format is one of your main responsibilities to the team. You must continue to take care of the working conditions of the developer - to provide them with full comfort and freedom of creativity, especially if they are required to increase the design architecture and its complexity.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúI am an architect. </font><font style="vertical-align: inherit;">By definition, I'm always right. ‚Äù</font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This nonsense is periodically expressed publicly or behind the scenes. </font><font style="vertical-align: inherit;">In today's practice, architects as such are less and less found. </font><font style="vertical-align: inherit;">With the advent of Agile, this role was gradually transferred to the senior developers, because usually all the work, one way or another, is built around them. </font><font style="vertical-align: inherit;">The size of the implementation is gradually increasing, and along with this, there is a need for refactoring and new functionality is being developed.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Architecture "onion" </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lukovitsa is the purest architecture in Transaction Script philosophy. When building it, we are guided by the goal of protecting the code that we consider critical, and for this we move it to the domain module. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a45/bb4/94a/a45bb494a51b04ecfe92606b744c0857.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our application, the most important are domain services: they implement the most critical flows. Move them to the domain module. Of course, here it is worth moving all your domain objects - entities and value objects. Everything else that we are today nakodili - DTO, mappers, validators, etc. - becomes, so to speak, the first line of defense from the user. Because as a user, alas, we are not a friend, and the system must be protected from it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention here on this dependence:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/273/6bd/c7d2736bdc016b732c5c431299bf32ea.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The application module will depend on the domain module - just like that, and not vice versa. By registering such a connection, we guarantee that DTO will never break into the holy territory of the domain module: they are simply not visible and inaccessible from the domain module. It turns out that in some sense we have fenced the territory of the domain - we have limited access to outsiders to it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, the domain may need to interact with some external service. With external means with unfriendly, because it is equipped with its own DTO. What are our options? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First: skip the enemy inside the module. </font></font><br><br><img src="https://habrastorage.org/webt/un/tn/hk/untnhkiksv5id_i-6c4qwdjxy1c.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, this is a bad option: it is possible that tomorrow the external service will not upgrade to version 2.0, and we will have to redraw our domain. You can not let the enemy inside the domain!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I propose another approach: for interaction we will create a special </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adapter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/8b1/09c/1238b109c54ac8f19524e6d41b32e85e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The adapter will receive data from the external service, extract those that are needed by our domain, and convert them to the required types of structures. </font><font style="vertical-align: inherit;">In this case, all that is required of us during development is to match the calls to the external system with the requirements of the domain. </font><font style="vertical-align: inherit;">Think of it as such a huge </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adapter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I call this layer "anti-corruption." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, we may need to perform LDAP query from a domain. </font><font style="vertical-align: inherit;">To do this, we implement the "anti-corruption module </font></font><code>LDAPUserServiceAdapter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">" </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/520/fdc/84a/520fdc84a53641a26b957ac010a19c42.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the adapter, we can:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hide ugly API calls (in our case, hide the method that accepts an array of Object); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pack exceptions into our own implementations; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Convert foreign data structures into their own (in our domain objects); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Check the validity of incoming data. </font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the purpose of the adapter. </font><font style="vertical-align: inherit;">For good, at the junction with each external system with which you need to interact, should be wound up its adapter. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/663/9c5/b1a6639c58457537fb6a4d9c15e09eae.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the domain will direct the call not to the external service, but to the adapter. </font><font style="vertical-align: inherit;">For this, a corresponding dependency must be written in the domain (on the adapter or on the infrastructure module in which it is located). </font><font style="vertical-align: inherit;">But is such a dependency safe? </font><font style="vertical-align: inherit;">If you install it like this, DTO external service can get into our domain. </font><font style="vertical-align: inherit;">This we should not allow. </font><font style="vertical-align: inherit;">Therefore, I suggest you another way to model dependencies.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dependency Inversion Principle </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/058/4a1/f7c/0584a1f7c309505e4e5ea0c2b0b26c21.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create an interface, write the signature of the necessary methods in it and place it inside our domain. The task of the adapter is to implement this interface. It turns out that the interface is inside the domain, and the adapter is outside, in the infrastructure module that imports the interface. Thus, we turned the direction of dependence in the opposite direction. During execution, the domain system will call any class through the interfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, by simply entering interfaces into the architecture, we were able to deploy dependencies and thereby secure our domain from foreign structures and APIs. This approach is called </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25B8%25D0%25BD%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B8%25D0%25B8_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B5%25D0%25B9"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dependency inversion</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2c/cc2/cd0/c2ccc2cd0309a4c8f97b7521cfc63fb7.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, dependency inversion assumes that you place the methods you are interested in the interface inside your high-level module (in the domain), and you implement this interface from the outside - in one or another low-level (infrastructure) ugly module. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The interface implemented inside the domain module must speak the domain language, that is, it will operate with its entities, its parameters and return types. During execution, the domain will call any class through a polymorphic call to the interface. The frameworks intended for dependency injection (for example, Spring and CDI) will provide us with a specific instance of the class right in runtime.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the main thing is that during the compilation of the domain module will not see the contents of the external module. </font><font style="vertical-align: inherit;">That is what we need. </font><font style="vertical-align: inherit;">No external entity should be in the domain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According to </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2580%25D1%2582%25D0%25B8%25D0%25BD,_%25D0%25A0%25D0%25BE%25D0%25B1%25D0%25B5%25D1%2580%25D1%2582"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uncle Bob</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the principle of inversion of control (or, as he calls it, ‚Äúplug-in architecture‚Äù) is perhaps the best that the OOP paradigm offers. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a96/3cf/e13/a963cfe13d030fb1d7ec2bf0f780fe43.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This strategy can be used for integration with any systems, for synchronous and asynchronous calls and messages, for sending files, etc.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bulb Review </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc3/64d/cdb/dc364dcdb589b35a0597b6e478aace46.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we decided that we will protect the domain module. </font><font style="vertical-align: inherit;">Inside it, there is a domain service, entities, value objects, and now interfaces for external services, plus interfaces for the repository (for interacting with the database). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The structure looks like this: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/07e/983/0c7/07e9830c76d3b263743f8514b13bf42a.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The application module, the infrastructure module (via dependency inversion), the repository module (we also consider the database an external system), the batch module, and possibly some other modules are declared as dependencies for the domain. </font><font style="vertical-align: inherit;">This architecture is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"onion"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">it is also called ‚Äúclean‚Äù, ‚Äúhexagonal‚Äù and ‚Äúports and adapters‚Äù.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Repository module </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefly tell about the repository module. Whether to take it out of the domain is a question. The task of the repository is to make the logic cleaner by hiding from us the horror of working with persistent data. The option for the old school guys is to use to interact with the JDBC database: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/d70/44a/7edd7044a76373b2c513e246bf6eabaa.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also use Spring and its JdbcTemplate: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/64b/d68/749/64bd68749f5b3de16591a23a8acda193.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or MyBatis DataMapper: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/423/31b/aa1/42331baa178ff3ad8f0ea8fb92704265.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this is so difficult and ugly that discourages any desire to do something further. Therefore, I suggest using JPA / Hibernate or Spring Data JPA. They will give us the opportunity to send requests that are not built on the database schema, but directly based on the model of our entities. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation for JPA / Hibernate: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/110/ebf/ef7/110ebfef7dad2a2bb278c50668eecda9.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of Spring Data JPA:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/10b/e2a/0ff/10be2a0ff082a8c1ac962c4754ec55a8.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Data JPA can automatically generate methods at runtime, such as, for example, getById (), getByName (). It also allows you to perform JPQL queries if necessary - and not to the database, but to your own entity model. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Hibernate JPA and Spring Data JPA code really looks pretty good. Do we need to extract it from the domain at all? In my opinion, this is not so necessarily. Most likely, the code will be even cleaner if you leave this fragment within the domain. So act on the situation.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/055/f04/37c/055f0437cf059c9f7001db6b3d231e70.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you still create a repository module, then for the organization of dependencies it is better to use the principle of inversion of control in the same way. To do this, place an interface in the domain and implement it in the repository module. As for the repository logic, it is better to transfer it to the domain. This makes testing convenient, as in the domain you can use Mock objects. They allow you to test the logic quickly and repeatedly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traditionally, only one entity is created for the repository in the domain. It is broken only when it becomes too voluminous. Do not forget that classes should be compact.</font></font><br><br><h4>  API </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c8/9e1/7e7/1c89e17e784e4db6fe8d7c713bcf1ab6.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can create a separate module, put the interface extracted from the facade and the DTOs that belong to it, then package it into a JAR, and send it to your Java clients in this form. </font><font style="vertical-align: inherit;">Having this file, they will have the opportunity to send requests to the facades.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Pragmatic Onion" </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to our ‚Äúenemies‚Äù to whom we supply functionality, that is, clients, we have enemies and, on the other hand, those modules that we ourselves depend on. </font><font style="vertical-align: inherit;">We also need to protect ourselves from these modules. </font><font style="vertical-align: inherit;">And for this I offer you a slightly modified ‚Äúonion‚Äù - in it the entire infrastructure is combined into one module. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/265/1f1/481/2651f1481062cfe6c18974df9a6dde9b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I call this architecture </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"pragmatic onion"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here, the separation of components takes place on the principle of ‚Äúmine‚Äù and ‚Äúintegrable‚Äù: what is related to my domain is stored separately, and what is related to integration with external collaborators is stored separately. </font><font style="vertical-align: inherit;">Thus, it turns out only two modules: domain and application. </font><font style="vertical-align: inherit;">This architecture is very good, but only when the application module is small. </font><font style="vertical-align: inherit;">Otherwise, you'd better go back to the traditional "onion."</font></font><br><br><h2>  Tests </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said earlier, if your application is all afraid, consider that it has expanded the ranks of Legacy. </font></font><img src="https://habrastorage.org/getpro/habr/post_images/12a/508/d1b/12a508d1b9595239f6d9b9a8a72c9474.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But tests are good. </font><font style="vertical-align: inherit;">They give us a sense of confidence, thanks to which we can continue to work on refactoring. </font><font style="vertical-align: inherit;">But unfortunately, this confidence may calmly be unjustified.</font></font> I will explain why.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TDD (development through testing) assumes that you are both the author of the code and the author of test cases at the same time: read the specifications, implement the functionality and immediately write the test suite for it. The tests, for example, will succeed. But what if you misunderstand the requirements of the specifications? Then the tests will not check what you need. So, your confidence is worth nothing. And all because you wrote both the code and the tests alone. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But let's try to close our eyes to this. Tests are still necessary, and in any case they give us confidence. Most of all, we, of course, love functional tests: they do not imply any side effects, no dependencies - only input and output data. To test the domain, you need to use mock objects: they will allow you to test classes in isolation.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As for queries to the database, then testing them is unpleasant. </font><font style="vertical-align: inherit;">These tests are fragile, they require that you first add test data to the database - and only after that you can proceed to functionality testing. </font><font style="vertical-align: inherit;">But as you understand, these tests are also necessary, even if you use JPA.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unit tests </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/332/6ec/8bd3326ec6ca9886c78b4239491dc936.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would say that the strength of unit tests is not in the ability to run them, but in the process of writing them. While you are writing a test, you rethink and work through the code - reduce connectivity, break into classes - in short, perform the next refactoring. The code under test is pure code; it is simpler, its connectivity is reduced; in general, it is also documented (a well-written unit test perfectly describes how the class works). It is not surprising that writing unit tests is difficult, especially the first few pieces. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/116/be7/361/116be7361d4d6a2dc8cac91983808378.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the stage of the first unit-tests, many are really scared of the prospects that they </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">really have</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to test something. Why are they so difficult? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because these tests are the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first load on your class</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is the first blow to the system, which may show that it is fragile and flimsy. But we must understand that these several tests are the most important for your development. They are, in essence, your best friends, because they will say it is as it is about the quality of your code. If you are afraid of this stage, you will not be able to go far. You need to run testing for your system. After that, the difficulty will subside, the tests will be written faster. By adding them one by one, you will create a reliable </font><i><font style="vertical-align: inherit;">regression test base</font></i><font style="vertical-align: inherit;"> for your system.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And this is incredibly important for the further work of your developers. </font><font style="vertical-align: inherit;">It will be easier for them to refactor; </font><font style="vertical-align: inherit;">They will understand that the system can be tested regression at any time, which is why it is safe to work with the code base. </font><font style="vertical-align: inherit;">And, I assure you, they will be much more willing to refactor. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb5/3d7/cbd/eb53d7cbdc3b190b2b597d6427088b1a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My advice to you is: if you feel that today you have a lot of strength and energy, devote yourself to writing unit tests. </font><font style="vertical-align: inherit;">And make sure that each of them is clean, fast, has its own weight and does not repeat the others.</font></font><br><br><h2>  Tips </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summarizing everything said today, I would like to admonish you with the following tips: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keep your </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplicity as</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> long as possible (and no matter what it </font><font style="vertical-align: inherit;">takes </font><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">: avoid ‚Äúre-engineering‚Äù and late optimization, do not overload the application;</font></font><br></li><li> <i>   </i> ,        ,   ; <br></li><li>  ¬´¬ª           ‚Äî <i>     </i> ; <br></li><li>   ,        ‚Äî <i></i> :         ; <br></li><li>    ¬´¬ª,  ,     ‚Äî <i>           </i> ; <br></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not be afraid of tests</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : give them the opportunity to bring down your system, feel all their benefits - after all, they are your friends because they can honestly point out problems.</font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By doing these things, you will help your team and yourself. </font><font style="vertical-align: inherit;">And then, when the day of delivery of the product comes, you will be ready for it.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What to read </font></font></h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/852/a4c/37d/852a4c37d17677fa3fb1e7e021f29e4a.jpg"><br><br><ul><li> <a href="https://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 Virtues of a Good Object</font></font></a> <br></li><li> <a href="https://dzone.com/articles/the-worst-mistake-of-computer-science-1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL is the worst mistake in computer science</font></font></a> <br></li><li> <a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The clean architecture</font></font></a> <br></li><li> <a href="https://blog.codinghorror.com/new-programming-jargon/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New Programming Jargon</font></font></a> <br></li><li> <a href="http://commadot.com/wtf-per-minute/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code quality: WTFs / minute</font></font></a> <br></li><li> <a href="https://speakerdeck.com/tastapod/why-every-element-of-solid-is-wrong"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why every single element of SOLID is wrong!</font></font></a> <br></li><li> <a href="https://www.javaworld.com/article/2072651/becoming-a-great-programmer--use-your-trash-can.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Good software is written 3 times</font></font></a> <br></li></ul><br><br><blockquote>  Minute advertising.        <b>JPoint</b> ‚Äî  ,  19-20   -  <a href="https://jokerconf.com/">Joker 2018</a> ‚Äî    Java-.       .        . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/419179/">https://habr.com/ru/post/419179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419165/index.html">We send ‚Äúanonymous‚Äù SMS from the Console to the desired number using the bytehand service and C ++</a></li>
<li><a href="../419169/index.html">"World of the Wild West" eyes of the developer</a></li>
<li><a href="../419171/index.html">Disabling runtime status checks in an Android application</a></li>
<li><a href="../419173/index.html">Clean architecture in the context of cross-platform development</a></li>
<li><a href="../419177/index.html">Amazing Amazon Patterns</a></li>
<li><a href="../419181/index.html">Programming the mouse: how we run away from the routine with CRM</a></li>
<li><a href="../419183/index.html">Demopati in Helsinki "Assembly 2018" photo report, the first day</a></li>
<li><a href="../419185/index.html">An overview of current protocols for achieving consensus in a decentralized environment</a></li>
<li><a href="../419193/index.html">Understanding JavaScript Objects</a></li>
<li><a href="../419199/index.html">Report of the Club of Rome 2018, Chapter 3.5: ‚ÄúSome Success Stories in Agriculture‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>