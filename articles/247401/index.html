<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Five popular myths about C ++, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introduction 
 In this article I will try to investigate and debunk five popular myths about C ++: 

 1 . To understand C ++, you first need to lea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Five popular myths about C ++, part 1</h1><div class="post__text post__text-html js-mediator-article"><h4>  1. Introduction </h4><br>  In this article I will try to investigate and debunk five popular myths about C ++: <br><br>  <b>1</b> .  To understand C ++, you first need to learn C <br>  <b>2</b>  C ++ is an object-oriented programming language. <br>  <b>3</b>  Reliable programs require garbage collection <br>  <b>4</b>  To achieve efficiency, it is necessary to write low-level code. <br>  <b>5</b>  C ++ is only suitable for large and complex programs. <br><br>  If you or your colleagues believe in these myths - this article is for you.  Some myths are true for someone, for some task at some point in time.  However, today's C ++, which uses ISO C ++ 2011 compilers, makes these assertions myths. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      They seem to me popular because I often hear them.  Sometimes they are argued, but more often used as axioms.  Often they are used to eliminate C ++ as one of the possible solutions to a problem. <br><br>  A book can be devoted to every myth, but I will confine myself to a simple statement and a brief statement of my arguments against them. <br><a name="habracut"></a><br><h4>  2. Myth 1: To understand C ++, you first need to learn C </h4><br>  Not.  In C ++, it is easier to learn the basics of programming than in C. C is almost a subset of C ++, but not the best of them, because C does not have type safety and convenient libraries that C ++ has and that make it easier to perform simple tasks .  Consider a simple example of creating email addresses: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; domain)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name+<span class="hljs-string"><span class="hljs-string">'@'</span></span>+domain; }</code> </pre> <br><br>  It is used like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> addr = compose(<span class="hljs-string"><span class="hljs-string">"gre"</span></span>,<span class="hljs-string"><span class="hljs-string">"research.att.com"</span></span>);</code> </pre><br><br>  Naturally, in a real program, not all arguments will be strings. <br><br>  In the C-version, it is necessary to work directly with symbols and memory: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* domain)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* res = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(name)+<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(domain)+<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   , '@',  0 char* p = strcpy(res,name); p += strlen(name); *p = '@'; strcpy(p+1,domain); return res; }</span></span></code> </pre><br><br>  It is used like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* addr = compose(<span class="hljs-string"><span class="hljs-string">"gre"</span></span>,<span class="hljs-string"><span class="hljs-string">"research.att.com"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ free(addr); //    </span></span></code> </pre><br><br>  Which option is easier to teach?  Which is easier to use?  Have I confused something in the C-version?  Right?  Why? <br><br>  And finally, which version of compose () is more efficient?  C ++ - because it does not need to count the characters in the arguments and it does not use dynamic memory for short strings. <br><br><h5>  2.1 Learning C ++ </h5><br>  This is not some strange exotic example.  In my opinion, it is typical.  So why do so many teachers preach the ‚ÄúFirst C‚Äù approach?  Because: <br><br>  - they always did <br>  - it is required by the curriculum <br>  - that they themselves studied this way <br>  - Since C is less than C ++, it means that it should be easier <br>  - students don't care, sooner or later, will have to learn C <br><br>  But C is not the simplest or most useful subset of C ++.  Knowing enough C ++, it will be easy for you to learn C. Studying C before C ++ will come up with a lot of mistakes that are easy to avoid in C ++, and you will spend time learning how to avoid them.  For the right approach to learning C ++, see my book Programming: Principles and Practice Using C ++.  In the end, there is even a chapter on how to use C. It has been successfully used in teaching many students.  To simplify learning, its second edition uses C ++ 11 and C ++ 14. <br><br>  Thanks to C ++ 11, C ++ has become more friendly for beginners.  For example, here is a vector from the standard library, initialized with a sequence of elements: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>};</code> </pre><br><br>  In C ++ 98, we could initialize lists with only arrays.  In C ++ 11, we can specify a constructor that accepts a list {} for any type.  We can cycle through the vector: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x : v) test(x);</code> </pre><br><br>  test () will be called for each v element. <br><br>  The for loop can go through any sequence, so we could just write: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x : {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>}) test(x);</code> </pre><br><br>  In C ++ 11, we tried to make simple things simple.  Naturally, without sacrificing speed. <br><br><h4>  3. Myth 2: C ++ is an object-oriented programming language. </h4><br>  Not.  C ++ supports OOP and other styles, but it is not specifically limited.  It supports the synthesis of program styles, including OOP and generic programming.  More often, the best solution to the problem is to use several styles.  The best means shorter, most understandable, efficient, serviced, etc. <br><br>  This myth leads people to the conclusion that they do not need C ++ (compared to C), unless they need large class hierarchies with all sorts of virtual functions.  Believing in the myth, C ++ is reproached for not being purely object-oriented.  If you equate ‚Äúgood‚Äù to ‚ÄúOOP‚Äù, then C ++, containing a lot of non-OOP, will automatically become ‚Äúbad.‚Äù  In any case, this myth is an excuse not to learn C ++. <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate_and_draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Shape*&gt;&amp; vs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ for_each(vs.begin(),vs.end(), [](Shape* p) { p-&gt;rotate(r); }); <span class="hljs-comment"><span class="hljs-comment">//    vs for (Shape* p : vs) p-&gt;draw(); //    vs }</span></span></code> </pre><br><br>  Is it an OOP?  Of course - there is a hierarchy of classes and virtual functions.  Is this generic programming?  Of course, there is a parameterized container (vector) and a normal function. <br><br>  for_each.  Is it functional programming?  Something like that.  Lambda is used (construction []).  And what is this style?  This is the modern style of C ++ 11. <br><br>  I used both the standard for loop and the for_each library algorithm, just to demonstrate the possibilities.  In this code, I would use only one loop, any of them. <br><br><h5>  3.1 Generalized programming. </h5><br>  Want a more generalized code?  In the end, it only works with pointer vectors for Shapes.  What about lists and embedded arrays?  What about smart pointers, such as shared_ptr and unique_ptr?  And the objects that are not called Shape, but which can be draw () and rotate ()?  Heed: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Iter&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate_and_draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iter first, Iter last, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ for_each(first,last,[](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p) { p-&gt;rotate(r); }); <span class="hljs-comment"><span class="hljs-comment">//    [first:last) for (auto p = first; p!=last; ++p) p-&gt;draw(); //    [first:last) }</span></span></code> </pre><br><br>  This works with any sequence.  This is the style of standard library algorithms.  I used auto to not call the interface types of objects.  This is a C ++ 11 feature, meaning ‚Äúto use the type of expression that was used during initialization‚Äù, so for p the type will be the same as for first. <br><br>  Another example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">list</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Shape&gt;&gt;&amp; lus, Container&lt;Blob&gt;&amp; vb)</span></span></span><span class="hljs-function"> </span></span>{ rotate_and_draw(lus.begin(),lus.end()); rotate_and_draw(begin(vb),end(vb)); }</code> </pre><br><br>  Here, Blob is a kind of graphic type that has draw () and rotate () operations, and Container is a type of some kind of container.  A list from the standard library (std :: list) has begin () and end () methods that help you walk through the sequence.  This is a beautiful classic OOP.  But what if Container does not support standard iteration over half-open sequences, [b: e)?  If begin () and end () methods are missing?  Well, I have never met something like a container that cannot be passed through, so we can define separate begin () and end ().  The standard library provides such an opportunity for C-style arrays, so if the Container is an array from C, the problem is solved. <br><br><h5>  3.2 Adaptation </h5><br>  The case is more complicated: what if the Container contains pointers to objects, and it has a different model for access and passage?  For example, it should be addressed as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = c.first(); p!=<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; p=c.next()) { <span class="hljs-comment"><span class="hljs-comment">/*  -  *p */</span></span>}</code> </pre><br><br>  This style is not rare.  It can be brought to the form of the sequence [b: e) like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iter</span></span></span><span class="hljs-class"> {</span></span> T* current; Container&lt;T&gt;&amp; c; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; Iter&lt;T&gt; begin(Container&lt;T&gt;&amp; c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Iter&lt;T&gt;{c.first(),c}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; Iter&lt;T&gt; end(Container&lt;T&gt;&amp; c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Iter&lt;T&gt;{<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>,c}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; Iter&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++(Iter&lt;T&gt; p) { p.current = pcnext(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; T* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(Iter&lt;T&gt; p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.current; }</code> </pre><br><br>  Such a modification is non-aggressive: I did not have to change the Container or the hierarchy of its classes to bring it to the passage model supported by the standard C ++ library.  This is an adaptation, not a refactoring.  I chose this example to demonstrate that such techniques of generalized programming are not limited to the standard library.  In addition, they do not fall under the definition of "OO". <br><br>  The idea that C ++ code is required to be OO (use hierarchies and virtual functions everywhere) has a detrimental effect on program performance.  If you need to analyze a set of types at runtime, this is a good approach, and I use it often.  However, it is rather inflexible (not all types fit into the hierarchy), and the call of a virtual function prevents inlining, which can slow down your program 50 times. <br><br><h4>  4. Myth 3: Garbage Collection Required in Reliable Programs </h4><br>  Garbage collection is good, but not perfect copes with returning unused memory.  This is not a panacea.  Memory may not be occupied directly, and a multitude of resources are not just memory.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     iname      oname public: Filter(const string&amp; iname, const string&amp; oname); //  ~Filter(); //  // ‚Ä¶ private: ifstream is; ofstream os; // ‚Ä¶ };</span></span></code> </pre><br><br>  The Filter constructor opens two files.  After that, a certain task is performed, the input from the file is accepted and the result is output to another file.  You can hardcode a task in Filter and use it as a lambda, or you can use it as a function provided by an inherited class that overloads a virtual function.  For resource management, it does not matter.  You can define a Filter like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Filter flt {‚Äúbooks‚Äù,‚Äùauthors‚Äù}; Filter* p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Filter{‚Äúnovels‚Äù,‚Äùfavorites‚Äù}; <span class="hljs-comment"><span class="hljs-comment">//  flt  *p delete p; }</span></span></code> </pre><br><br>  From a resource management perspective, the problem is how to ensure that the files are closed and the resources associated with the two threads are correctly returned for future use. <br><br>  A common solution for systems that rely on garbage collectors is to remove delete and destructor (because garbage collectors rarely have destructors and are better avoided because they can lead to algorithmic problems and adversely affect performance).  The garbage collector can clear all memory, but we need to close the files and return all resources not related to memory (locks), but related to threads.  It turns out that the memory is automatically returned, but the management of other resources is carried out manually, therefore it is prone to leaks and errors. <br><br>  A common and recommended approach in C ++ is to rely on destructors to make sure that resources are returned.  Usually, resources are taken away in constructors, which gives this technique the name ‚ÄúResource Acquisition Is Initialization‚Äù (RAII)).  In user (), the flt destructor implicitly calls the is and os thread destructors.  They, in turn, close files and release resources related to streams.  delete would do the same for * p. <br><br>  Advanced C ++ users will notice that user () is clumsy and error prone.  So it would be better: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Filter flt {‚Äúbooks‚Äù,‚Äùauthors‚Äù}; <span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Filter&gt; p {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Filter{‚Äúnovels‚Äù,‚Äùfavorites‚Äù}}; <span class="hljs-comment"><span class="hljs-comment">//  flt  *p }</span></span></code> </pre><br><br>  Now, upon exiting user () * p is automatically released.  The programmer will not forget to do this.  unique_ptr is a standard library class that verifies that resources are freed up, without loss in performance and memory, compared to the built-in pointers. <br><br>  Although this solution is too verbose (Filter repeats), and the separation of the constructor of a regular pointer (new) and a smart one (unique_ptr) requires optimization.  This can be improved through the auxiliary C ++ 14 function make_unique, which creates an object of the specified type and returns unique_ptr pointing to it: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Filter flt {‚Äúbooks‚Äù,‚Äùauthors‚Äù}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = make_unique&lt;Filter&gt;(‚Äúnovels‚Äù,‚Äùfavorites‚Äù); <span class="hljs-comment"><span class="hljs-comment">//  flt  *p }</span></span></code> </pre><br><br>  Or even a better option, unless we need a second Filter in order to write everything through pointers: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">user4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Filter flt {‚Äúbooks‚Äù,‚Äùauthors‚Äù}; Filter flt2 {‚Äúnovels‚Äù,‚Äùfavorites‚Äù}; <span class="hljs-comment"><span class="hljs-comment">//  flt  flt2 }</span></span></code> </pre><br><br>  In short, simpler, clearer, and faster. <br><br>  But what does the Filter destructor do?  Frees resources Filter - closes files (causing their destructors).  This is done implicitly, so if Filter doesn‚Äôt need anything more, you can get rid of mentioning its destructor and let the compiler do it yourself.  Therefore, it is only necessary to write: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     iname      oname public: Filter(const string&amp; iname, const string&amp; oname); // ‚Ä¶ private: ifstream is; ofstream os; // ‚Ä¶ }; void user3() { Filter flt {‚Äúbooks‚Äù,‚Äùauthors‚Äù}; Filter flt2 {‚Äúnovels‚Äù,‚Äùfavorites‚Äù}; //  flt  flt2 }</span></span></code> </pre><br><br>  This record is simpler than most records from languages ‚Äã‚Äãwith automatic garbage collection (Java, C #), and there are no leaks due to forgetfulness.  It is also faster than obvious alternatives. <br><br>  This is my ideal resource management.  It manages not only memory, but also other resources - files, streams, locks.  But is it really comprehensive?  What about objects that don't have one obvious owner? <br><br><h5>  4.1 Transfer of ownership: move </h5><br>  Consider the problem of transferring objects between scopes.  The question is how to get a lot of information out of scope, without unnecessary copying or error-prone use of pointers.  Traditionally used pointer: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_X</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ X* p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X: <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶  X ‚Ä¶ return p; } void user() { X* q = make_X(); // ‚Ä¶  *q ‚Ä¶ delete q; }</span></span></code> </pre><br><br>  And who is responsible for removing the object?  In our simple case, the one who calls make_X (), but in general, the answer is not so obvious.  What if make_X () caches objects to minimize memory usage?  If user () passed a pointer to other_user ()?  Many where you can get confused and with this programming style leaks are not uncommon.  You could use shared_ptr or unique_ptr to directly determine the owner of the object: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;X&gt; make_X();</code> </pre><br><br>  But why use a pointer at all?  Often it is not needed, often it distracts from the usual use of the object.  For example, the addition function Matrix creates a new object, the sum of two arguments, but returning a pointer would result in a strange code: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Matrix&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Matrix&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Matrix&amp; b); Matrix res = *(a+b);</code> </pre><br><br>  The <b>*</b> symbol is needed to get an object with a sum, not a pointer.  What I really need is an object, not a pointer to it.  Small objects are quickly copied and I would not use a pointer: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    double s2 = sqrt(2); //     </span></span></code> </pre><br><br>  On the other hand, objects containing a bunch of data are usually the processors of this data.  istream, string, vector, list and thread - they all use only a few bytes to access much larger data.  Returning to the addition of the Matrix.  What do we need: <br><br><pre> <code class="cpp hljs">Matrix <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Matrix&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Matrix&amp; b); <span class="hljs-comment"><span class="hljs-comment">//   a  b Matrix r = x+y;</span></span></code> </pre><br><br>  Easy: <br><br><pre> <code class="cpp hljs">Matrix <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Matrix&amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Matrix&amp; b) { Matrix res; <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶  res  ‚Ä¶ return res; }</span></span></code> </pre><br><br>  By default, the res elements are copied to r, but since res is deleted and its memory is freed, you do not need to copy them: you can ‚Äústeal‚Äù the elements.  This could be done from the first days of C ++, but it was difficult to implement and not everyone understood the technique.  C ++ 11 supports the ‚Äútheft of the view‚Äù directly, in the form of move operations that transfer ownership of the object.  Consider a simple two-dimensional matrix of double elements: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Matrix</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>* elem; <span class="hljs-comment"><span class="hljs-comment">//    int nrow; //   int ncol; //   public: Matrix(int nr, int nc) // :   :elem{new double[nr*nc]}, nrow{nr}, ncol{nc} { for(int i=0; i&lt;nr*nc; ++i) elem[i]=0; //  } Matrix(const Matrix&amp;); //   Matrix operator=(const Matrix&amp;); //   Matrix(Matrix&amp;&amp;); //   Matrix operator=(Matrix&amp;&amp;); //   ~Matrix() { delete[] elem; } // :   // ‚Ä¶ };</span></span></code> </pre><br><br>  The copy operation is recognized by &amp;.  Move operation - by &amp;&amp;.  The move operation should ‚Äústeal‚Äù the view and leave behind the ‚Äúempty object‚Äù.  For Matrix, this means something like: <br><br><pre> <code class="cpp hljs">Matrix::Matrix(Matrix&amp;&amp; a) <span class="hljs-comment"><span class="hljs-comment">//   :nrow{a.nrow}, ncol{a.ncol}, elem{a.elem} // ‚Äú‚Äù  { a.elem = nullptr; //     }</span></span></code> </pre><br><br>  That's all.  When the compiler sees return res;  he understands that res will soon be destroyed.  It will not be used after return.  Then he uses the move constructor instead of copying to pass in the return value.  For <br><br><pre> <code class="cpp hljs">Matrix r = a+b;</code> </pre><br><br>  res inside operator + () becomes empty.  The destructor is left with very little work, and the res elements now own r.  We got the elements of the result (it could be megabytes of memory) from the function (operator + ()) to a variable.  And they did it with minimal cost. <br><br>  C ++ experts indicate that in some cases a good compiler can completely eliminate copying for return.  But it depends on their implementation, and I don‚Äôt like that the speed of simple things depends on how clever the compiler got.  Moreover, a compiler that eliminates copying can also eliminate moving.  We have here a simple, reliable and universal way to eliminate the complexity and cost of moving a large amount of information from one area of ‚Äã‚Äãview to another. <br><br>  In addition, the displacement semantics works for assignment, so in the case of <br><br><pre> <code class="cpp hljs">r = a+b;</code> </pre><br><br>  we get motion optimization for the assignment operator.  Optimizing compiler assignment is more difficult. <br><br>  Often we don‚Äôt even have to define all these copy and move operations.  If the class consists of members that behave as expected, we can simply rely on the default operations.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Matrix</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; elem; <span class="hljs-comment"><span class="hljs-comment">//  int nrow; //   int ncol; //   public: Matrix(int nr, int nc) // constructor: allocate elements :elem(nr*nc), nrow{nr}, ncol{nc} { } // ‚Ä¶ };</span></span></code> </pre><br><br>  This option behaves the same as the previous one, except that it handles errors better and takes a little more space (a vector is usually three words). <br><br>  What about handles that are not handlers?  If they are small, like int or complex, do not worry.  Otherwise, make them handlers or return them via smart pointers unique_ptr and shared_ptr.  Do not use the "bare" operations new and delete.  Unfortunately, Matrix from the example is not included in the ISO C ++ standard library, but there are several libraries for it.  For example, look for ‚ÄúOrigin Matrix Sutton‚Äù and refer to Chapter 29 of The C ++ Programming Language (Fourth Edition) for comments on its implementation. <br><br>  <a href="http://habrahabr.ru/post/247551/"><i>Part 2</i></a> </div><p>Source: <a href="https://habr.com/ru/post/247401/">https://habr.com/ru/post/247401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247391/index.html">Fail2ban integration with CSF to counter DDoS on nginx</a></li>
<li><a href="../247393/index.html">https comes on geektimes / habrahabr?</a></li>
<li><a href="../247395/index.html">Internet in a closed country: the experience of North Korea</a></li>
<li><a href="../247397/index.html">WS_EX_LAYERED style for child windows in Windows 8</a></li>
<li><a href="../247399/index.html">History of the creation of Norton Commander. Part 1: introduction</a></li>
<li><a href="../247405/index.html">Approaches to the creation of a scripting language for the description of board games</a></li>
<li><a href="../247409/index.html">Potential Android Telegram Vulnerability</a></li>
<li><a href="../247413/index.html">Pulp Fiction Weekend - Microsoft Press Free Books</a></li>
<li><a href="../247415/index.html">Marxico - markdown editor for Evernote</a></li>
<li><a href="../247419/index.html">Beautiful Fall: Gravity CSS3 Animation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>