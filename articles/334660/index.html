<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test documentation. Turn tables into trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article I described how the first stage of project testing is going on in our company - analysis. Today I will talk about the next sta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test documentation. Turn tables into trees</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/9c2/c85/776/9c2c8577699c440ebe3d6e2a6797e00c.jpg"><br><br>  In the previous article I described how the first stage of project testing is going on in our company - analysis.  Today I will talk about the next stage - designing and documenting tests. <br><br>  This stage is optional.  Some projects do not have documented requirements, and then often supporting test documentation is the only sensible way to store and transfer knowledge about the product.  Sometimes the test documentation is required by the customer, sometimes we write it for ourselves.  Sometimes, if we have well-written requirements, we refuse to document tests in order to save resources. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The type of test documentation also depends on the situation on the project and the expectations of the customer. <br><a name="habracut"></a><br><h2>  Check lists vs Test cases </h2><br>  The checklist differs from the test case by the degree of detail.  In the checklist, you will not meet the detailed steps of the case, to use the checklist when testing a lot of information you need to keep in mind when running the tests and know the logic of the application to work perfectly. <br><br>  Our company has always used checklists, because it takes an unreasonable amount of time to write test cases, and they are too heavy ‚Äî reading a case and understanding it also takes time.  In addition, do not forget about the effect of the pesticide - code bugs tend to adapt to the tests.  When using a checklist, some freedom of action is retained, and test cases are completely deprived of this freedom, increasing the effect mentioned above.  However, when the checklist is run for the seventh time in the last day before the release, some of the functionality laid down under one item of the checklist is lost due to the human factor. <br><br>  It was decided to expand the checklists and make them more detailed.  So the tester, unconsciously chasing the feature before the release, will not forget to check the network errors in response to each request, will not lose checking any "unimportant" button or any one of the twelve.  So we came to writing a detailed user story, completely covering the application feature, but in fact being one huge test case. <br><br>  Advantages of this approach: <br><br><ul><li>  checklist implies continuous execution by the tester.  Accordingly, all cases are arranged in a convenient manner for the run, and no time is spent on moving to the next case. </li><li>  checklist covers a large number of user scripts </li><li>  The checklist contains both positive and negative cases.  Checks for error and interrupt recovery, which is very important for mobile applications. </li><li>  checklist means long sessions, which increases the likelihood of detecting memory leaks and navigation problems </li><li>  information about requirements is received by the tester consistently, which gives a better understanding of the logic of the application </li></ul><br>  Cons of this approach: <br><br><ul><li>  The checklist implies a decomposition on the application screens and is strongly tied to the design.  Accordingly, all changes in the design imply changes in the checklist </li><li>  taking into account that such check-list cases should be connected in one story, and there can be up to two hundred cases in one check-list, it is difficult to maintain </li><li>  the effect of the pesticide is greatly enhanced </li><li>  checklist cannot replace requirements for developers - it‚Äôs inconvenient to develop for such requirements </li><li>  the checklist is long enough to write and because of its cumbersome it is not always convenient to use - in fact it comes in handy only in the final before the release </li></ul><br>  For a long time we lived like this.  Led their checklists in the test management system Sitechko.  But the company was changing, business processes were changing, and the question of switching to another TMS was in the air.  He became the impetus for the revision of the process of maintaining test documentation. <br><br><h2>  Tables vs Trees </h2><br>  Once I drank multivitamins, and it dawned on me that instead of storing tests in tabular formats, it‚Äôs more convenient to use trees, or rather, nested lists.  After all, when writing the very largest user story, we often face the problem of not knowing where to place alternative actions.  For example, when we have several buttons on the alert.  To check each of them, we have to register the call of this alert several times.  Instead, we could suspend checking each of the buttons for an alert call. <br><br>  In general, the idea was to write the same user scenarios in the form of a tree in which the transition is an action, and the node is the state in which the application is after this action.  In fact, the state transition diagram, only the objects are the application screens.  Each branch of such a tree is a test case. <br><br><img src="https://habrastorage.org/web/51d/c6a/653/51dc6a65357f4c8abcb269d534120559.png"><br><br>  When they began to try, they ran into problems.  It turned out that the usual decomposition on the screens of the application does not work: it is inconvenient to rely on the design when designing tests.  Tree branches grew far into the depths, and it was uncomfortable visually.  In pursuit of the script, we turned back the cycles.  And it also became clear that it is impossible to refuse the tables. <br><br>  The decision was in the change of approach to decomposition, greater awareness and rejection of the ‚Äúdefault solutions‚Äù.  The tree structure of the test documentation is really convenient, because it gives more freedom in the design.  The decomposition view determines what exactly will become the nodes of our tree.  And this in turn is determined by the features of the product and customer priorities. <br><br>  In general, the advantages of using a tree structure: <br><br><ul><li>  As a result, the structure of such documentation is very flexible and allows you to maintain both checklists and test cases, depending on the needs of the project. </li><li>  the tree is represented as nested lists: the nodes of the tree have a certain order, which preserves the possibility of a consistent and structured transfer of information about the requirements to the tester if there is no documented TK on the project </li><li>  This structure allows you to design test documentation that can be transferred to developers instead of TK </li><li>  time spent on writing checklists and test cases is reduced, because the structure allows you to avoid copy-paste </li></ul><br>  Cons of the approach: <br><br><ul><li>  such a structure of test documentation requires careful design and preliminary analytics - with poor design, all the advantages mentioned above are lost </li></ul><br><h2>  Summary Patterns </h2><br>
<h3>  Application screens </h3><br>  The source of knowledge is navshema.  The first level of the tree is a list of case studies, which usually corresponds to sections of the application.  Next, they are hung with a list of screens of each section, to each screen - a list of its states.  Each node of the tree, starting with the third level, may contain a checklist in tabular format describing each design element and how to interact with it.  If the design elements are complex and have many states or there are duplicate elements on the screen, you can decompose even deeper.  Thus, one branch of the tree describes the life cycle of a single screen. <br><br>  Below, as an example, the general scheme of reasoning is given when decomposing the order section of the ticket aggregator. <br><br><img src="https://habrastorage.org/web/f98/3cc/efe/f983ccefe3654ffcb777a342e592fa99.png"><br><br><img src="https://habrastorage.org/web/99a/0b0/925/99a0b092500c4045ad6569e9c0a1b201.png"><br><br>  We fasten short checklists to the leaves of this tree.  So to each sheet of the ‚Äúnavbar‚Äù link the checklist for the navbar elements for the current screen: <br><br><img src="https://habrastorage.org/web/3ec/180/6e7/3ec1806e7719438688e09fbab97eb2df.png"><br><br>  And for each sheet of the ‚Äúscheduled trips section‚Äù we link the checklist to check the part of the list with active orders: <br><br><img src="https://habrastorage.org/web/d29/354/db1/d29354db14ca4d72bcbcddeeff6b8da6.png"><br><br>  The criteria for choosing such a pattern are as follows: <br><br><ul><li>  UI is a priority for the customer </li><li>  minimum business logic on the client </li><li>  for the application are characterized by custom design elements and animations, complex gestures </li><li>  there are no other documented requirements on the project other than navshema </li></ul><br><h3>  Objects / Actions </h3><br>  With this approach, we focus not on the whole scheme, but on the documentation of the IPA and the client's business logic.  Negative and positive cases are divided into different branches.  It is desirable that elements of the same tree level answer one question, but you can leave this restriction only for one level of the hierarchy. <br><br>  Such a scheme is extremely convenient in cases where we have an active influence of users on each other, which gives rise to complex scenario chains.  An example is the chat.  With respect to the previous approach, such documentation is easier to maintain, since changes in logic happen less frequently than in design. <br><br>  Below is an example of a general scheme of reasoning for decomposition on the principle object / action. <br><br><img src="https://habrastorage.org/web/5db/35e/937/5db35e93757741d1b930582d2c165b2e.png"><br><br><img src="https://habrastorage.org/web/a71/6ea/853/a716ea853ee3470db58fac81a8194e81.png"><br><br>  In this scheme, an additional bonus is the ability to use it as a map for exploratory testing and for Smoke test.  The degree of testing details can be adjusted by cutting off the tree levels during the run, as each next level specifies the previous one.  When you go deep into a tree branch, you go deep into functionality. <br><br>  For example, for the chat already mentioned, the documentation scheme would look something like this: <br><br><img src="https://habrastorage.org/web/16b/121/32b/16b12132bc164916a9a129dca3764270.png"><br><br>  Criteria for choosing such a pattern: <br><br><ul><li>  the goal is to test the functionality </li><li>  complex business logic </li><li>  frequent design changes </li><li>  testing strategy on a project involves a combination of scripting and research testing </li></ul><br><h2>  Based on use cases </h2><br>  There are situations in which it is unprofitable to decompose the functionality and design tests according to two previously described schemes.  For example, if we want to cover long-term work with an application with tests, as is the case with a social network tape or listening to music in the background.  Or when the feature is tied to scripts with a small number of alternatives - for example, subscribing to a content.  In this case, we use the third pattern based on user scripts. <br><br>  First we decompose the functionality of use cases.  We decide on which actors can participate in the process of working with the application and what goals they can set for themselves.  The first two levels of our tree will be responsible for this.  Next, we try to find all possible input conditions that may affect the development of the scenario to achieve the current goal, and structure them in the tree.  They are also the most convenient to divide into positive and negative.  Next to each sheet we suspend the scenario check list to check the functionality responsible for achieving the goal. <br><br>  As an example, below is a diagram for a music player with the function of downloading tracks for listening offline: <br><br><img src="https://habrastorage.org/web/9bd/ff8/0b7/9bdff80b7c924bd6be0918659fba504d.png"><br><br><img src="https://habrastorage.org/web/0fc/b4f/419/0fcb4f419bf64ee7a24aa97b01f142b9.png"><br><br>  Here, to all the leaves of the positive scenario, we suspend the checklist, which will need to be run under different network connections: <br><br><img src="https://habrastorage.org/web/f14/9de/fe7/f149defe7be14105801847c7cc4fa5df.png"><br><br>  It so happens that when thinking about possible use-cases, the goals of users turn out to be very global.  For example, in the already mentioned air ticket aggregator, the goal ‚Äúto buy a ticket‚Äù can stump with an abundance of possible preconditions and the number of steps that must be taken to achieve the goal.  In addition, in such an application, much depends on the behavior of third-party systems, which imposes some restrictions on the definition of all preconditions and the uniquely executed script.  Offers come from different airlines and can change at any time.  At any given time, it is impossible to guarantee that the purchase of the ticket will be successful, since this ticket may be purchased while we are filling in the reservation data. <br><br>  The solution to the first problem is a more detailed decomposition.  That is, the big goal ‚Äúto buy a ticket‚Äù can be broken down into small goals, corresponding to the clearance steps - ‚Äúread the offers‚Äù, ‚Äúfill in the passengers data‚Äù, ‚Äúpay for the order‚Äù.  And then find a set of possible preconditions, user actions and results for these small goals. <br><br>  The solution to the second problem is less obvious.  This is generally a limitation of the use case - in case if the behavior of the system is not uniquely determined by the user's actions, there are problems with the coverage and design of use cases.  For ourselves, we decided that in such situations we try to prescribe all possible behaviors of systems not subject to the user, as preconditions, and thereby reduce the uncertainty of the result of the script.  Or use a different design scheme for test documentation. <br><br>  Criteria for choosing such a pattern: <br><br><ul><li>  priority for the customer is the correct operation of certain user scenarios </li><li>  The application contains screens where the user will spend a lot of time consuming content. </li><li>  The application contains features that consist in working out a linear script. </li><li>  testing strategy on a project involves scripting </li><li>  simple business logic easily covered by use cases </li></ul><br>  The patterns described above can and should be combined.  In a large application with high quality requirements, there are sure to meet both features that are optimally broken down by object / action, and features that require a scenario description of use case.  And in the same way, in such an application, screens can be found for which it is necessary to prescribe all the states of the elements and all sorts of user interactions with them.  Therefore, it is not necessary to choose one single documentation scheme for the entire application as a whole, it is better to always look at the circumstances. <br><br><h2>  Pushing away from the goal </h2><br>  We changed the tool and developed new approaches to test documentation, but did not reject the old approaches.  The choice of strategy depends on the needs of the project and the priorities of the customer.  If the application logic is simple and the project does not last long, then standard checklists for functionality with minimal detail are usually sufficient.  If the project is large, complex and without requirements, then part of the features should write a full-fledged "tree" documentation.  If the project has well-documented requirements, sometimes you can not waste time writing tests on functionality, but you can pay more attention to non-functional testing (performance, security) and systematize it - again, if there is an appropriate agreement with the customer.  Or document only "risky" tests.  User-story is still almost always written, but not as detailed as the acceptance for the customer or as a smoke test, and the decomposition work carried out before this helps us to quickly design the script and set the priorities correctly. <br><br>  The availability of test documentation on a project allows you to capture information about requirements, plan and structure tests in advance, lower the threshold for a new tester to enter a project, and reduce the risk of missing errors due to human factors.  However, writing and maintaining test documentation requires resources that are not always possible or not always worth spending. </div><p>Source: <a href="https://habr.com/ru/post/334660/">https://habr.com/ru/post/334660/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334648/index.html">Modular testing of Pega applications: changing lives for the better with Ninja</a></li>
<li><a href="../334650/index.html">The authenticity of your videos is now undeniable thanks to Prover.</a></li>
<li><a href="../334652/index.html">Android O: features support for the new operating system</a></li>
<li><a href="../334656/index.html">5 fresh examples of parsing and improving the design in simple ways</a></li>
<li><a href="../334658/index.html">How to try to make the user comfortable and bungle something in the process.</a></li>
<li><a href="../334662/index.html">Zimbra - we build communications in the company</a></li>
<li><a href="../334664/index.html">About supporting C # language features in Visual Studio and CodeRush for Roslyn</a></li>
<li><a href="../334666/index.html">Generation of documents. Problems and Solutions</a></li>
<li><a href="../334668/index.html">Thematic modeling with BigARTM</a></li>
<li><a href="../334670/index.html">Math pack for Android - "Micro-Math" - now open source</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>