<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OCaml and RESTful JSON API using Eliom</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to your attention the translation of the RESTful JSON API manual using Eliom . 

 This tutorial describes how to create a simple b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OCaml and RESTful JSON API using Eliom</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to your attention the translation of the <a href="http://ocsigen.org/tuto/4.0/manual/rest">RESTful JSON API manual using Eliom</a> . <br><br>  This tutorial describes how to create a simple but complete REST API using JSON as the serialization format. <br><a name="habracut"></a><br>  To illustrate our example, suppose we want to provide access to a database of locations that store the description and coordinates (latitude and longitude). <br><br>  To be RESTful, our interface will conform to the following principles: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  URLs and GET parameters define resources </li><li>  HTTP methods (GET, POST, PUT, DELETE) are used to define actions. </li><li>  GET action is safe (no side effects) </li><li>  PUT and DELETE actions are idempotent. </li><li>  Requests are stateless (no client status information is stored on the server between client requests) </li></ul><br>  With this in mind, our goal will be to implement CRUD (Create, Read, Update, Delete) functions to process our resources.  We want the following requests to be valid: <br><br>  <b>GET</b> http: // localhost / will return all available locations. <br><br>  <b>GET</b> http: // localhost / ID will return the location associated with the ID. <br><br>  <b>POST</b> http: // localhost / ID with content: <br><br><pre><code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Paris"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"coordinates"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"latitude"</span></span>: <span class="hljs-number"><span class="hljs-number">48.8567</span></span>, <span class="hljs-attr"><span class="hljs-attr">"longitude"</span></span>: <span class="hljs-number"><span class="hljs-number">2.3508</span></span> } }</code> </pre> <br>  store this location in the database. <br><br>  <b>PUT</b> http: // localhost / ID, with some content, will update the location associated with the id. <br><br>  <b>DELETE</b> http: // localhost / ID will delete the location associated with the ID. <br><br><h2>  Dependencies </h2><br><ul><li>  <a href="http://ocsigen.org/eliom/">eliom</a> &gt; = 4.0 </li><li>  <a href="https://github.com/mjambon/yojson">yojson</a> </li><li>  <a href="https://github.com/hhugo/deriving-yojson">deriving-yojson</a> </li></ul><br>  It is assumed that you are already familiar with <a href="http://ocsigen.org/eliom/">Eliom</a> , it is necessary to fully understand the tutorial.  This tutorial is not an introduction to Eliom. <br>  The following browser extensions can be useful for manually checking the REST API: <br><br><ul><li>  <a href="https://addons.mozilla.org/en-US/firefox/addon/restclient/">RESTClient for Firefox</a> </li><li>  <a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop%3Fhl%3Dru">Postman for Chrome</a> </li></ul><br><h2>  Data types </h2><br>  We begin by defining our database types, that is, how we will present our locations and related information.  Each location will be associated with a unique and arbitrary identifier, and will also contain the following information: description and coordinates (consisting of latitude and longitude). <br><br>  We present the coordinates with decimal degrees and use the deriving-yojson library to analyze and serialize our types in JSON. <br><br>  We use the highlighted type of error returned when something is wrong with the request or with the processing of the request. <br><br>  As for the database, we use a simple <a href="https://ocsigen.org/ocsigenserver/2.8/api/Ocsipersist">Ocsipersist</a> table. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> coordinates = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">latitude</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">longitude</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float</span></span></span><span class="hljs-class">; } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Yojson</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> location = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">description</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">coordinates</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">coordinates</span></span></span><span class="hljs-class">; } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Yojson</span></span></span><span class="hljs-class">) (* </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pairs</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identifier</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">location</span></span></span><span class="hljs-class">) *) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> locations = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">location</span></span></span><span class="hljs-class">) list </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Yojson</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> error = { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error_message</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">; } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Yojson</span></span></span><span class="hljs-class">) let db : location </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ocsipersist</span></span></span><span class="hljs-class">.table = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ocsipersist</span></span></span><span class="hljs-class">.open_table "locations"</span></span></code> </pre> <br><h2>  Service definition </h2><br>  First, let's define the general service parameters: <br><br><ul><li>  <i>path</i> API: same for all services. </li><li>  GET parameter, which is an optional identifier specified as a URL suffix.  We set it as optional so that we can distinguish GET requests for one or all of the resources and return a detailed error if the identifier is missing in the POST, PUT and DELETE requests.  An alternative would be to use two services on the same path (one with id and one without). </li></ul><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = [] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> get_params = Eliom_parameter.(suffix (neopt (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">"id"</span></span>)))</code> </pre><br>  The next step is to define our service APIs.  We identify four of them with the same path, using the four HTTP methods at our disposal: <br><br><ul><li>  The GET method will be used to access the database, for any of the resources if no identifier is specified, or only for a single resource.  If the resource does not match the identifier, an error will be returned. </li><li>  The POST method will be used to create a new resource (or update it if it already exists).  We set one POST parameter: Eliom_parameter.raw_post_data to get raw JSON and bypass the parameter lock after decoding. </li><li>  The PUT method will be used to update an existing resource.  If the resource does not match the identifier, an error will be returned.  We do not need to define the POST parameter, the PUT services take the value Eliom_parameter.raw_post_data as default content. </li><li>  The DELETE method will be used to delete an existing resource.  If the resource does not match the identifier, an error will be returned. </li></ul><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> read_service = <span class="hljs-type"><span class="hljs-type">Eliom_service</span></span>.<span class="hljs-type"><span class="hljs-type">Http</span></span>.service ~path ~get_params () <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> create_service = <span class="hljs-type"><span class="hljs-type">Eliom_service</span></span>.<span class="hljs-type"><span class="hljs-type">Http</span></span>.post_service ~fallback:read_service ~post_params:<span class="hljs-type"><span class="hljs-type">Eliom_parameter</span></span>.raw_post_data () <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> update_service = <span class="hljs-type"><span class="hljs-type">Eliom_service</span></span>.<span class="hljs-type"><span class="hljs-type">Http</span></span>.put_service ~path ~get_params () <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> delete_service = <span class="hljs-type"><span class="hljs-type">Eliom_service</span></span>.<span class="hljs-type"><span class="hljs-type">Http</span></span>.delete_service ~path ~get_params ()</code> </pre> <br><h2>  Handlers </h2><br>  Let's start defining handlers with a few auxiliary values ‚Äã‚Äãand functions used by handlers. <br><br>  Since we use the low-level function Eliom_registration.String.send to send our response, we transfer it to three specialized functions: send_json, send_error and send_success (this sends only the 200 OK status code without any content). <br><br>  Another function helps us verify that the received content type is expected by matching it with the MIME type.  In our example, we check that we get JSON. <br><br>  The read_raw_content function retrieves the specified or standard <i>length</i> number of characters from the Ocsigen stream raw_content. <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json_mime_type = <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> send_json ~code json = Eliom_registration.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.send ~code (json, json_mime_type) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> send_error ~code error_message = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json = Yojson.to_string&lt;error&gt; { error_message } <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> send_json ~code json <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> send_success () = Eliom_registration.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.send ~code:<span class="hljs-number"><span class="hljs-number">200</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> check_content_type ~mime_type content_type = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> content_type with | <span class="hljs-literal"><span class="hljs-literal">Some</span></span> ((type_, subtype), _) when (type_ ^ <span class="hljs-string"><span class="hljs-string">"/"</span></span> ^ subtype) = mime_type -&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> | _ -&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> read_raw_content ?(length = <span class="hljs-number"><span class="hljs-number">4096</span></span>) raw_content = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> content_stream = Ocsigen_stream.get raw_content <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Ocsigen_stream.string_of_stream length content_stream</code> </pre> <br>  Then we define our handlers to perform the necessary actions and return a response. <br><br>  The POST and PUT handlers will read the contents of the original content in JSON and use Yojson to convert it to our types. <br><br>  In the responses we use HTTP status codes, with values: <br><br><ul><li>  200 (OK): Request completed successfully. </li><li>  400 (invalid query): something was wrong with the query (missing parameter, parse error ...). </li><li>  404 (Not Found): The resource does not match the provided id. </li></ul><br>  The GET handler either returns one location if provided an identifier, otherwise a list of all existing locations. <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> read_handler id_opt () = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> id_opt with | <span class="hljs-literal"><span class="hljs-literal">None</span></span> -&gt; Ocsipersist.fold_step (fun id loc acc -&gt; Lwt.<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((id, loc) :: acc)) db [] &gt;&gt;= fun locations -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json = Yojson.to_string&lt;locations&gt; locations <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> send_json ~code:<span class="hljs-number"><span class="hljs-number">200</span></span> json | <span class="hljs-literal"><span class="hljs-literal">Some</span></span> id -&gt; catch (fun () -&gt; Ocsipersist.find db id &gt;&gt;= fun location -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json = Yojson.to_string&lt;location&gt; location <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> send_json ~code:<span class="hljs-number"><span class="hljs-number">200</span></span> json) (function | Not_found -&gt; (* [id] hasn<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> been found, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a <span class="hljs-string"><span class="hljs-string">"Not found"</span></span> message *) send_error ~code:<span class="hljs-number"><span class="hljs-number">404</span></span> (<span class="hljs-string"><span class="hljs-string">"Resource not found: "</span></span> ^ id))</code> </pre> <br>  Then let's create a common function for the POST and PUT handlers, which have very similar behavior.  The only difference is that a PUT request with a nonexistent identifier will return an error (so it will only accept update requests and reject creation requests), while the same request with the POST method will be successful (a new location will be created with an identifier). <br><br><pre> <code class="hljs sql">let edit_handler_aux ?(<span class="hljs-keyword"><span class="hljs-keyword">create</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) id_opt (content_type, raw_content_opt) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (check_content_type ~mime_type:json_mime_type content_type) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> send_error ~code:<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-string"><span class="hljs-string">"Content-type is wrong, it must be JSON"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> id_opt, raw_content_opt <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, _ -&gt; send_error ~code:<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-string"><span class="hljs-string">"Location identifier is missing"</span></span> | _, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> -&gt; send_error ~code:<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-string"><span class="hljs-string">"Body content is missing"</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Some</span></span> raw_content -&gt; read_raw_content raw_content &gt;&gt;= fun location_str -&gt; catch (fun () -&gt; (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Lwt.return_unit <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Ocsipersist.find db <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> &gt;&gt;= fun _ -&gt; Lwt.return_unit) &gt;&gt;= fun () -&gt; let location = Yojson.from_string&lt;location&gt; location_str <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Ocsipersist.add db <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> location &gt;&gt;= fun () -&gt; send_success ()) (<span class="hljs-keyword"><span class="hljs-keyword">function</span></span> | Not_found -&gt; send_error ~code:<span class="hljs-number"><span class="hljs-number">404</span></span> (<span class="hljs-string"><span class="hljs-string">"Location not found: "</span></span> ^ <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) | Deriving_Yojson.Failed -&gt; send_error ~code:<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-string"><span class="hljs-string">"Provided JSON is not valid"</span></span>) let create_handler id_opt <span class="hljs-keyword"><span class="hljs-keyword">content</span></span> = edit_handler_aux ~<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span> id_opt <span class="hljs-keyword"><span class="hljs-keyword">content</span></span> let update_handler id_opt <span class="hljs-keyword"><span class="hljs-keyword">content</span></span> = edit_handler_aux ~<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span> id_opt <span class="hljs-keyword"><span class="hljs-keyword">content</span></span></code> </pre> <br>  To delete locations, you need a fourth handler: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> delete_handler id_opt _ = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> id_opt with | <span class="hljs-literal"><span class="hljs-literal">None</span></span> -&gt; send_error ~code:<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-string"><span class="hljs-string">"An id must be provided to delete a location"</span></span> | <span class="hljs-literal"><span class="hljs-literal">Some</span></span> id -&gt; Ocsipersist.remove db id &gt;&gt;= fun () -&gt; send_success ()</code> </pre> <br><h2>  Registration of services </h2><br>  Finally, we register services using the Eliom_registration.Any module in order to have full control over the response sent.  Thus, we can send the corresponding HTTP status code depending on what happens during the processing of the request (parsing error, resource not found ...), as shown above when defining handlers. <br><br><pre> <code class="hljs pgsql">let () = Eliom_registration.<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>.register read_service read_handler; Eliom_registration.<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>.register create_service create_handler; Eliom_registration.<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>.register update_service update_handler; Eliom_registration.<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>.register delete_service delete_handler; ()</code> </pre> <br><h2>  Full source </h2><br><div class="spoiler">  <b class="spoiler_title">All that we have in the end</b> <div class="spoiler_text"><pre> <code class="hljs rust">open Lwt (**** Data types ****) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">coordinates</span></span></span></span> = { latitude : float; longitude : float; } deriving (Yojson) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">location</span></span></span></span> = { description : string option; coordinates : coordinates; } deriving (Yojson) (* List of pairs (identifier * location) *) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">locations</span></span></span></span> = (string * location) list deriving (Yojson) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span></span> = { error_message : string; } deriving (Yojson) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> db : location Ocsipersist.table = Ocsipersist.open_table <span class="hljs-string"><span class="hljs-string">"locations"</span></span> (**** Services ****) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = [] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> get_params = Eliom_parameter.(suffix (neopt (string <span class="hljs-string"><span class="hljs-string">"id"</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> read_service = Eliom_service.Http.service ~path ~get_params () <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> create_service = Eliom_service.Http.post_service ~fallback:read_service ~post_params:Eliom_parameter.raw_post_data () <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> update_service = Eliom_service.Http.put_service ~path ~get_params () <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> delete_service = Eliom_service.Http.delete_service ~path ~get_params () (**** Handler helpers ****) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json_mime_type = <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> send_json ~code json = Eliom_registration.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.send ~code (json, json_mime_type) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> send_error ~code error_message = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json = Yojson.to_string&lt;error&gt; { error_message } <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> send_json ~code json <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> send_success () = Eliom_registration.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>.send ~code:<span class="hljs-number"><span class="hljs-number">200</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> check_content_type ~mime_type content_type = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> content_type with | <span class="hljs-literal"><span class="hljs-literal">Some</span></span> ((type_, subtype), _) when (type_ ^ <span class="hljs-string"><span class="hljs-string">"/"</span></span> ^ subtype) = mime_type -&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> | _ -&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> read_raw_content ?(length = <span class="hljs-number"><span class="hljs-number">4096</span></span>) raw_content = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> content_stream = Ocsigen_stream.get raw_content <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Ocsigen_stream.string_of_stream length content_stream (**** Handlers ****) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> read_handler id_opt () = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> id_opt with | <span class="hljs-literal"><span class="hljs-literal">None</span></span> -&gt; Ocsipersist.fold_step (fun id loc acc -&gt; Lwt.<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((id, loc) :: acc)) db [] &gt;&gt;= fun locations -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json = Yojson.to_string&lt;locations&gt; locations <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> send_json ~code:<span class="hljs-number"><span class="hljs-number">200</span></span> json | <span class="hljs-literal"><span class="hljs-literal">Some</span></span> id -&gt; catch (fun () -&gt; Ocsipersist.find db id &gt;&gt;= fun location -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json = Yojson.to_string&lt;location&gt; location <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> send_json ~code:<span class="hljs-number"><span class="hljs-number">200</span></span> json) (function | Not_found -&gt; (* [id] hasn<span class="hljs-symbol"><span class="hljs-symbol">'t</span></span> been found, <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a <span class="hljs-string"><span class="hljs-string">"Not found"</span></span> message *) send_error ~code:<span class="hljs-number"><span class="hljs-number">404</span></span> (<span class="hljs-string"><span class="hljs-string">"Resource not found: "</span></span> ^ id)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> edit_handler_aux ?(create = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) id_opt (content_type, raw_content_opt) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> not (check_content_type ~mime_type:json_mime_type content_type) then send_error ~code:<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-string"><span class="hljs-string">"Content-type is wrong, it must be JSON"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> id_opt, raw_content_opt with | <span class="hljs-literal"><span class="hljs-literal">None</span></span>, _ -&gt; send_error ~code:<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-string"><span class="hljs-string">"Location identifier is missing"</span></span> | _, <span class="hljs-literal"><span class="hljs-literal">None</span></span> -&gt; send_error ~code:<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-string"><span class="hljs-string">"Body content is missing"</span></span> | <span class="hljs-literal"><span class="hljs-literal">Some</span></span> id, <span class="hljs-literal"><span class="hljs-literal">Some</span></span> raw_content -&gt; read_raw_content raw_content &gt;&gt;= fun location_str -&gt; catch (fun () -&gt; (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> create then Lwt.return_unit <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Ocsipersist.find db id &gt;&gt;= fun _ -&gt; Lwt.return_unit) &gt;&gt;= fun () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> location = Yojson.from_string&lt;location&gt; location_str <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Ocsipersist.add db id location &gt;&gt;= fun () -&gt; send_success ()) (function | Not_found -&gt; send_error ~code:<span class="hljs-number"><span class="hljs-number">404</span></span> (<span class="hljs-string"><span class="hljs-string">"Location not found: "</span></span> ^ id) | Deriving_Yojson.Failed -&gt; send_error ~code:<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-string"><span class="hljs-string">"Provided JSON is not valid"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> create_handler id_opt content = edit_handler_aux ~create:<span class="hljs-literal"><span class="hljs-literal">true</span></span> id_opt content <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> update_handler id_opt content = edit_handler_aux ~create:<span class="hljs-literal"><span class="hljs-literal">false</span></span> id_opt content <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> delete_handler id_opt _ = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> id_opt with | <span class="hljs-literal"><span class="hljs-literal">None</span></span> -&gt; send_error ~code:<span class="hljs-number"><span class="hljs-number">400</span></span> <span class="hljs-string"><span class="hljs-string">"An id must be provided to delete a location"</span></span> | <span class="hljs-literal"><span class="hljs-literal">Some</span></span> id -&gt; Ocsipersist.remove db id &gt;&gt;= fun () -&gt; send_success () (* Register services *) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> () = Eliom_registration.Any.register read_service read_handler; Eliom_registration.Any.register create_service create_handler; Eliom_registration.Any.register update_service update_handler; Eliom_registration.Any.register delete_service delete_handler; ()</code> </pre><br>  Source: <a href="https://ocsigen.org/tuto/4.0/manual/rest">RESTful JSON API using Eliom</a> <br></div></div><br><h3>  From translator </h3><br>  I wanted the OCaml community to grow and grow, and the language itself developed faster, the language is good, and sometimes even better than mainstream languages, here are a few of its advantages: it‚Äôs going native, its syntax is rather concise and understandable (not immediately, but it is easier for me than Haskell, but in general it is a taste), also a rather convenient type system and a good OOP of course.  If this translation was useful to someone or made me look at OCaml and its ecosystem, try it, then I can do more translations or author articles.  <b>Please report errors in lichku.</b> <br><br>  <b>PS:</b> <br>  Introductory articles about OCaml and Ocsigen on Habr√© with which it is probably worth getting acquainted to beginners: <br><br><ul><li>  <a href="https://habrahabr.ru/post/108529/">Introduction to OCaml: The Basics [1]</a> </li><li>  <a href="https://habrahabr.ru/post/108532/">Introduction to OCaml: The Structure of OCaml Programs [2]</a> </li><li>  <a href="https://habrahabr.ru/post/108920/">Introduction to OCaml: Data Types and Mapping [3]</a> </li><li>  <a href="https://habrahabr.ru/post/118183/">Introduction to OCaml: Null Pointers, Assertions and Warnings</a> </li><li>  <a href="https://habrahabr.ru/post/129109/">Dynamic applications with Ocsigen or Yob returns</a> </li></ul><br>  but of course it is better to get acquainted with the official manuals, because the articles above are 6-7 years old, some basics can be extracted from them (and given the sluggish development of the language, the probability to extract basic knowledge and not be undermined, tends to be 100%), but I I can not vouch that at the moment everything is right there, especially in the article about Oscigen.  All good and pleasant path in development. </div><p>Source: <a href="https://habr.com/ru/post/336336/">https://habr.com/ru/post/336336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336326/index.html">How complex automation can help if you have a small business</a></li>
<li><a href="../336328/index.html">Creating a quiz on Vue.js</a></li>
<li><a href="../336330/index.html">Game of God, or how I wrote "Wolf Island"</a></li>
<li><a href="../336332/index.html">Fish, fish: how to use the "data lake" in the bank. VTB experience</a></li>
<li><a href="../336334/index.html">Paraquire, or Stop Trusting Libraries</a></li>
<li><a href="../336338/index.html">Accelerate Viola-Jones Method</a></li>
<li><a href="../336342/index.html">Agents, principals and online ticket booths in between</a></li>
<li><a href="../336346/index.html">How I did realtime roulette on NodeJS & VueJS</a></li>
<li><a href="../336348/index.html">Using the terminal when developing for Android</a></li>
<li><a href="../336350/index.html">Calculation of the weight spectrum of a linear subspace in Wolfram Mathematica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>