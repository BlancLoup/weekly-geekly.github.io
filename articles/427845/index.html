<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to fit in the iPhone million stars</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Such a romantic thing, as the starry sky, and such a hardcore thing, as optimization of memory consumption by an iOS application, may well go together...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to fit in the iPhone million stars</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/q7/xz/3_/q7xz3_mzwjft238rwmzhjpbnwqm.jpeg"><br><br>  Such a romantic thing, as the starry sky, and such a hardcore thing, as optimization of memory consumption by an iOS application, may well go together: it is worth trying to stuff this starry sky into an AR application, as soon as the question arises about that consumption. <br><br>  Minimizing memory usage will be useful in many other cases.  So this text shows, on the example of a small project, optimization methods that can be useful in completely different iOS applications (and not only iOS-). <br><a name="habracut"></a><br>  The post was prepared on the basis of the decoding of the report by <b>Konrad Fayler</b> from the Mobius 2018 Piter conference.  We attach his video, and then - the text version of the first person: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/51PJjrh9yTA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  I am glad to welcome everyone!  My name is Konrad Fayler, and under the spectacular name ‚ÄúMillion Stars in One iPhone‚Äù we will discuss how you can minimize the memory size occupied by your iOS application.  Colorful and in examples. <br><br><h2>  Why optimize? </h2><br>  What generally encourages us to engage in optimization, what exactly would we like to achieve?  We do not want this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54b/0ef/fbf/54b0effbffa93a27e65a50000242046d.gif"></div><br><br>  We do not want the user to have to wait.  That is the first reason - to <b>reduce the load time</b> . <br><br>  Another reason is <b>to improve the quality</b> . <br><br><img src="https://habrastorage.org/webt/dj/6i/0w/dj6i0wxgzgv87xkdvnkiy6ddy48.jpeg"><br><br>  Speech here can go about the quality of images, sound and even AI.  "Optimized AI" means that you can achieve more - for example, calculate the game for a larger number of moves forward. <br><br>  The third reason is very important: <b>battery saving</b> .  Optimization helps to discharge the battery less.  Here is an interesting comparison, albeit from the world of Android.  Vulkan and OpenGL ES were compared here: <br><br><img src="https://habrastorage.org/webt/9n/ni/dx/9nnidxssdqtw_t2ibkdatsaapfm.jpeg"><br><br>  The second is worse optimized for mobile platforms.  Observing battery consumption, you can see that for a similar image, OpenGL ES was spending a lot more resources than Vulkan. <br><br>  What kind of optimization can help here?  For example, in a turn-based game, when the user thinks about his own move, you can reduce the FPS to zero.  If you have a 3D engine, then it is perfectly reasonable to simply turn everything off while the user just looks at the screen. <br><br>  In addition, there are times when, without an optimized approach, you will not be able to implement this or that advanced feature: it simply will not pull. <br><br><h2>  Without fanaticism </h2><br>  Speaking of optimization, one can not forget the thesis of Donald Knuth: ‚ÄúWe should forget about a little efficiency, say, in 97% of cases: premature optimization is the root of all evil.  Although we should not give up our opportunities in this critical 3%. ‚Äù <br><br>  In 97% of cases, we should not care about efficiency, but first of all about how to make our code understandable, safe and testable.  We are still developing for mobile devices, not for spacecraft.  Companies where we work should not overpay for the support of the code written by us.  In addition, the developer‚Äôs working time has a cost, and if you spend it on optimizing something unimportant, then you spend the company's funds.  Well, the fact that a well-optimized code tends to be more difficult to understand, you can be sure of those examples that I will demonstrate to you today. <br><br>  In general, meaningfully prioritize and optimize as needed. <br><br><h2>  Approaches </h2><br>  When working on optimization, we usually monitor either performance (read: processor load) or memory usage.  Often, these two options will conflict, and you will need to find a balance between them. <br><br>  In the case of a processor, we can reduce the number of processor cycles required by our operations.  As you understand, fewer processor cycles give us less boot time, less battery consumption, the ability to provide better quality, etc. <br><br>  For iOS developers, Xcode Instruments has a handy Time Profiler tool.  It allows you to track the number of CPU cycles spent by different parts of your application.  This report is not about tools, so I‚Äôm not going to dive into the details now, this was a good video from WWDC. <br><br>  You can choose another goal - optimization for the sake of memory.  We will try to make sure that when launching our application fit into the smallest possible number of RAM cells.  Remember that the most voluminous applications become the first candidates for a forced completion during the cleanup, which the OS has to do.  Therefore, it affects how long your application will remain in the background. <br><br>  It is also important that the RAM resource of different devices is also different.  If you, say, decided to develop for Apple Watch, then there is little memory, and this also forces you to optimize. <br><br>  Finally, sometimes a small amount of memory also makes the program very fast.  I will give an example.  Before you are structures of various sizes in bytes: <br><br><img src="https://habrastorage.org/webt/mg/2c/_2/mg2c_2se8rpo_gwwnqlfbcaf2ks.jpeg"><br><br>  Element8 contains 8 bytes, Element16 - 16, and so on. <br><br><img src="https://habrastorage.org/webt/ot/hq/l3/othql3uj6cujllgs99m_ypmkok8.jpeg"><br><br>  Let's get arrays, one for each of our kinds of structures.  The dimension of all arrays is the same - 10,000 elements each.  Each structure contains a different number of fields (incrementally);  The n field is the first field and, accordingly, is present in all structures. <br><br>  Now let's try the following: for each array we will calculate the sum of all its fields n.  That is, each time we will sum up the same number of elements (10,000 pieces).  The only difference is that for each sum, the variable n will be extracted from structures of different sizes.  We are interested in whether the same time will take summation. <br><br>  The result is the following: <br><br><img src="https://habrastorage.org/webt/el/mu/k1/elmuk1tm_yaku9exe4xgbaw8gp4.jpeg"><br><br>  The graph shows the dependence of the summation time on the size of the structure used in the array.  It turns out that it is longer to extract the field n from the larger structure, and therefore the summation operation takes longer. <br>  Many of you have already understood why this is happening. <br><br>  The processor has L1, L2 caches (sometimes also L3 and L4).  The processor accesses this type of memory directly and quickly. <br><br><img src="https://habrastorage.org/webt/u1/yy/r9/u1yyr9z2pxbwcffecy8i_xoa5qq.jpeg"><br><br>  Caches exist to speed up data reuse.  Suppose we work with arrays.  If the processor-needed array is already present in any of the caches, then the processor already needed it.  At that moment, he requested them from the main memory, put them in the cache, performed all the necessary operations with them, after which the data remained to lie down (they did not manage to wipe others). <br><br><img src="https://habrastorage.org/webt/qt/cd/om/qtcdomuam8uo4cz2tnkevtmvxuk.jpeg"><br><br>  The sizes of caches L1, L2 are not so big.  The array required by the processor to work may be more.  In order to fully perform the operation on such an array, we will have to unload it into the cache in parts and operate with these parts in turn.  Due to constant requests to the main memory, the processing of our array will take much longer. <br><br>  When programming data structures, try to keep track of how caches work.  It is possible that by reducing the size of your data structure, you will achieve its successful cache capacity and speed up the operations that will be performed on it in the future.  Interaction with the main memory has always been, is and, most likely, will remain a significant performance factor - even when you write on Swift for modern high-performance devices. <br><br><h2>  CPU vs. RAM: lazy initialization </h2><br>  Although in some cases when the memory used decreases, the program starts to work faster, there are also cases when these two metrics conflict, on the contrary.  I will give an example with the concept of lazy initialization. <br><br>  Suppose we have a method makeHeavyObject (), which returns some large object.  This method will initialize the lazilyCalculated variable. <br><br><img src="https://habrastorage.org/webt/-y/2v/4l/-y2v4lzluwid2sxmelau-qp9yiu.jpeg"><br><br>  The lazy modifier sets the lazilyCalculated variable to lazy initialization.  This means that the value will be assigned to it only when the first access to it occurs during execution.  It is then that the makeHeavyObject () method will work and the resulting object will be assigned to the variable lazilyCalculated. <br><br>  What is the plus here?  From the moment of initialization (let it be later, but it will be executed) we have a memory object.  Its value is counted, it is ready to use - just make a request.  Another thing is that our object is large and from the time of initialization will occupy its lion‚Äôs share of cells in memory. <br><br>  You can go another way - do not store the value of the field at all: <br><br><img src="https://habrastorage.org/webt/rd/dj/td/rddjtdebqiiyidg1vravbwzreli.jpeg"><br><br>  With each link to the lazilyCalculated field, the makeHeavyObject () method will be re-executed.  The value will be returned to the query point, but it will not be stored in memory.  As you can see, storing a variable is optional. <br><br>  What is more expensive - to keep a large object in memory, but not to spend CPU time, or to call a method every time we need our field, while saving memory?  Do you have a ready value at hand or calculate it on the fly?  This kind of dilemma arises quite often, no matter where you perform your calculations ‚Äî on a remote server or on your local machine, no matter what cache you have to work with.  You will have to make a decision based on the system constraints in this particular case. <br><br><h2>  Optimization cycle </h2><br><br><img src="https://habrastorage.org/webt/3y/jb/tz/3yjbtzvba5c5cmvdmyxws4ubev8.jpeg"><br><br>  Whatever you optimize, your work, as a rule, will be based on the same algorithm.  First, you examine the code, profile / measure it (in Xcode using appropriate tools), trying to identify its bottlenecks.  Essentially, you order the methods by how much time they are executed.  And then look at the top lines to determine what to optimize. <br><br>  Having chosen an object, you set yourself a task (or, scientifically speaking, put forward a hypothesis): using certain optimization methods, you can make the selected piece of code run faster. <br><br>  Next you try to optimize.  After each modification, you look at the performance indicators, assessing how effective the modification turned out to be, how much you have managed to progress. <br><br>  Just like in scientific work: assumption, experiment, analysis of results.  You go through this cycle of action time after time.  Practice shows that the work constructed in this way really allows you to eliminate the bottlenecks one by one. <br><br><h2>  Unit tests </h2><br><br><img src="https://habrastorage.org/webt/yp/c3/zl/ypc3zlrxtbnbkp9cwekladdj-ug.jpeg"><br><br>  Briefly about unit tests: we have some function that we test, some input data input and output data output;  receiving input, our function should always return output, and none of our optimizations should violate this property. <br><br>  Unit tests help us track down a breakdown.  If, in response to input, our function stopped returning output, then, directly or indirectly, we changed the old course of operation of our function. <br><br>  Don't even try to start optimizing if you haven't written to your code a generous portion of unit tests.  You should be able to regression testing.  If you look at GitHub my commits in my sample application, to which I will go further, you can see that some of my optimizations have brought bugs with me. <br><br>  And now the most interesting - go to the stars. <br><br><h2>  Million stars </h2><br>  There is a large (huge) database describing a million stars.  Over it I have created several applications.  One of them uses augmented reality, in real time, drawing the stars over the image from the camera of the phone.  Now I will demonstrate it in action: <br><br><img src="https://habrastorage.org/webt/cr/rs/jv/crrsjv1iezyd2hzyxdxpjricu0u.png"><br><br>  In the absence of city lights, a person can discern up to 8,000 stars in the sky.  I would need about 1.8 MB to store 8000 records.  In principle, acceptable.  But I wanted to add those stars that a person can see through a telescope - it turned out about 120,000 stars (according to the so-called Hipparcos catalog, now obsolete).  This required 27 MB already.  And among the modern directories in the public domain you can find one that will total about 2,500,000 stars.  Such a database would have occupied about 560 MB.  As you can see, it requires a lot of memory.  And after all, we want not just a database, but an application based on it, with ARKit, SceneKit and other things that also require memory. <br><br>  What to do? <br>  We will optimize the stars. <br><br><h2>  MemoryLayout tool </h2><br>  You can estimate the size of the program as a whole.  But for such jewelry work as optimization, you will need tools to estimate the size of each individual data structure. <br><br>  Swift allows you to do this quite simply - using MemoryLayout &lt;&gt; objects.  You declare a MemoryLayout &lt;&gt;, specifying the data structure that interests you as a generic type.  Now, referring to the properties of the resulting object, you can get a variety of useful information about its structure. <br><br><img src="https://habrastorage.org/webt/4b/dy/ki/4bdykiugciapow4d-avqvmfhp7e.jpeg"><br><br>  The size property gives us the number of bytes occupied by a single instance of the structure. <br>  Now about the stride property.  You may have noticed that the size of the array, as a rule, is not equal to the sum of the sizes of its constituent elements, but exceeds it.  Obviously, some ‚Äúair‚Äù is left in the memory between the elements.  To estimate the distance between successive elements in an adjacent array, we use the stride property.  If you multiply it by the number of elements in the array, you get its size. <br><br><img src="https://habrastorage.org/webt/vo/9x/6i/vo9x6ivnzz5-nzdhowe4cvtox3u.jpeg"><br><br>  StarData, our experimental structure, in its original non-optimized state: <br><br><img src="https://habrastorage.org/webt/no/ku/51/noku51vmtamzm8yk1cclohg1-ea.jpeg"><br><br>  This is a data structure for storing data about a single star.  You do not need to go into what each of these elements means.  It is more important now to pay attention to the types: Float variables that store the coordinates of the star (in fact, latitude and longitude), several Int32 for different IDs, String for storing names and names of various classifications;  There is a distance, color and some other values ‚Äã‚Äãneeded to properly display the star. <br><br>  Request the stride property: <br><br><img src="https://habrastorage.org/webt/ob/pu/l-/obpul-qs28mwnfqhfnay3b5ml-m.jpeg"><br><br>  At the moment, our structure weighs 208 bytes.  A million of these structures will require 250 MB - this, as you understand, is too much.  Therefore, it is necessary to optimize. <br><br><h2>  Correct int </h2><br>  The fact that there are different types of Int, tell more on the first programming lessons.  The most familiar Int to us in the Swift language is called Int8.  It takes 8 bits (1 byte) and can store values ‚Äã‚Äãfrom -128 to 127 inclusive.  There are also other ints: <br><ul><li>  Int16 is 2 bytes in size, the range of values ‚Äã‚Äãis from -32,768 to 32,767; </li><li>  Int32 size in 4 bytes, the range of values ‚Äã‚Äã- from -2 147 483 648 to 2 147 483 647; </li><li>  Int64 (or simply Int) size of 8 bytes, the range of values ‚Äã‚Äã- from -9 223 372 036 854 775 808 to 9 223 372 036 854 775 807. </li></ul><br><br>  Probably those of you who have been doing web development and have dealt with SQL are already thinking about it.  But yes, the first thing is to choose the optimal Int.  I am in this project even before approaching the optimization of the mind, I started doing a bit of premature optimization (which, as I just said, you don‚Äôt need to do). <br><br>  Let's look, for example, on fields with ID.  We know that we will have about a million stars - not a few tens of thousands, but not a billion.  It means that for such fields it is optimal to choose Int32.  Then I realized that for Float, 4 bytes is enough.  Double will take on 8, String on 24, we will add this all - 152 bytes turn out.  If you remember, before MemoryLayout told us that 208. Why?  We must dig deeper. <br><br><img src="https://habrastorage.org/webt/ss/pd/-d/sspd-d52ece7xuninv1aivvbapi.jpeg"><br><br>  First, let's take a look at Optional.  Optional types are distinguished by the fact that in the absence of an assigned value they store nil.  This achieves security in conjunction with objects.  But as you understand, such a measure does not cost for free: by requesting the size property of any optional type, you will see that such a type always takes one byte more.  We pay for the opportunity to register for the nil field. <br><br>  We would not like to spend on a variable byte.  At the same time, the idea inherent in optional, we very much like.  What to think up?  Let's try to realize our structure. <br><br>  Choose a value that is reasonably considered ‚Äúinvalid‚Äù for a given field, whichever is appropriate for the type claimed.  For getHipId (Int32) this may be, for example, the value "-1".  It will mean that our field is not initialized.  Here is such a bicycle optional, which can do without an extra byte on nil. <br><br>  It is clear that with such a trick we have a potential vulnerability.  To protect yourself from an error, we create a getter for the field, which will independently manage our new logic and check the value of the field for validity. <br><br><img src="https://habrastorage.org/webt/f8/_7/ar/f8_7ar0uns7lzeude7do0avszaw.jpeg"><br><br>  Such a getter completely abstracts the complexity of the invented solution. <br>  Turn to our StarData.  Replace all optional types with regular ones and see what stride shows: <br><br><img src="https://habrastorage.org/webt/bw/v4/rf/bwv4rfqgdjkyle-jziflwtbdgjq.jpeg"><br>  It turns out that by eliminating optionsals, we did not save 9 bytes (bytes for each of the nine optionsals), but as many as 48. A pleasant surprise, but I would like to know why this happened.  And this happened because of the alignment of data in memory. <br><br><h2>  Data alignment </h2><br>  Recall that before Swift we wrote on Objective-C, and it was repelled by C - and this situation also has its roots in C. <br><br>  Placing any structures in memory, modern processors place their elements not in a continuous stream (not ‚Äúshoulder to shoulder‚Äù), but into some non-uniformly thinned mesh.  This is the alignment of the data.  It allows you to simplify and speed up access to the desired data elements in memory. <br>  Data alignment rules are applied to each variable depending on its type: <br><br><ul><li>  a char variable can begin on the 1st, 2nd, 3rd, 4th, etc.  byte, since it only takes one byte; </li><li>  the short variable is 2 bytes, so it can start from the 2nd, 4th, 6th, 8th, etc.  bytes (that is, from each even byte); </li><li>  a variable of type float is 4 bytes, which means it can start from every 4th, 8th, 12th, 16th, etc.  bytes (that is, from every fourth byte); </li><li>  Double and String variables occupy 8 bytes each, so they can start from 8th, 16th, 24th, 32nd, etc.  byte; </li><li>  etc. </li></ul><br><br>  MemoryLayout &lt;&gt; objects have an alignment property that returns the corresponding alignment rule for the specified type. <br><br>  Can we apply knowledge of alignment rules to optimize the code?  Let's look at an example.  There is a User structure: for firstName and lastName we use a regular String, for middleName - an optional String (the user may not have such a name).  In memory, an instance of such a structure will be placed as follows: <br><br><img src="https://habrastorage.org/webt/ah/2y/iz/ah2yizmjxwar-9d6gycudjcspv0.jpeg"><br><br>  As you can see, since the middleName option takes up 25 bytes (instead of multiples of 8 24 bytes), the alignment rules oblige to skip the 7 bytes that follow it and spend 80 bytes on the whole structure, not 73, but.  Here, no matter how you rearrange blocks with lines, it is impossible to count on a smaller number of bytes. <br><br>  And now an example of unsuccessful alignment: <br><br><img src="https://habrastorage.org/webt/ea/ag/ch/eaagch2qax-7hpbvfbvrbkd4xog.jpeg"><br><br>  The BadAligned structure first declares isHidden of type Bool (1 byte), then size of type Double (8 bytes), isInteractable of type bool (1 byte) and finally age of type Int (also 8 bytes).  Declared in this order, our variables will be placed in memory in such a way that the total structure will take 32 bytes. <br><br>  Let's try to change the order of the declaration of the fields - arrange them in ascending order of the occupied volume and see how the picture changes in memory. <br><br><img src="https://habrastorage.org/webt/qt/de/mw/qtdemwpwvb_tvkd-gnhmx1pfnbm.jpeg"><br><br>  Our structure does not occupy 32 bytes, but 24. Savings by 25%. <br><br>  Looks like a Tetris game, isn't it?  Swift is obliged to such low-level things to C language - its ancestor.  By declaring the fields in a large data structure out of focus, you are more likely to use more memory than you would, given the alignment rules.  Therefore, try to remember them and take into account when writing code - this is not so difficult. <br><br>  Turn again to our StarData.  Let's try to arrange its fields in ascending order of the occupied volume. <br><br><img src="https://habrastorage.org/webt/4r/jj/po/4rjjpozl7hnmfcnx9yb_e4q66xm.jpeg"><br><br>  First Float and Int32, then Double and String.  Not such an elaborate Tetris! <br>  The stride we received is 152 bytes.  That is, by optimizing the implementation of optionals and having worked with alignment, we managed to reduce the volume of the structure from 208 to 152 bytes. <br><br>  Are we approaching the limit of our optimization capabilities?  Probably yes.  However, there is something else that we have not tried - something more complicated by an order of magnitude, but sometimes capable of striking with its result. <br><br><h2>  Domain Logic </h2><br>  Try to focus on what specificity is inherent in your service.  Remember my example with chess: the idea of ‚Äã‚Äãvarying the FPS index, when nothing changes on the screen - this is exactly the optimization by taking into account the domain logic of the application. <br><br>  Take another look at StarData.  Our obvious bottleneck is String type fields, they really take up a lot of space.  And here the specifics are as follows: during runtime, most of these lines remain empty!  Only 146 stars have a ‚Äúreal‚Äù name, which is indicated in the properName field.  And gl_id - star ID in accordance with the Gliese catalog, which has 3801 stars, is also far from a million.  bayer_flamstedt ‚Äî the Flemsteed designations ‚Äî will be assigned to 3064th stars.  SpectralType spectral type - 4307-mi.  It turns out that for the majority of stars, the entered string variables will be empty, while occupying 24 bytes each. <br><br>  I came up with the next solution.  Let's create as an additional structure an associative array.  The key is a unique numeric identifier of the Int16 type, as a value, depending on the presence of a characteristic string, either its value or -1. <br><br>  In our StarData, opposite the properName, gl_id, bayer_flamstedt and spectralType we will prescribe the index corresponding to the key in the array.  If it is necessary to get one or another characteristic string, we will request a value from the array using an index.  There is no need to do this manually - we better implement a convenient, secure getter: <br><br><img src="https://habrastorage.org/webt/n7/i5/bi/n7i5bilqodef52ninsnoilrneci.jpeg"><br><br>  Getter is very important here - he hides from us the complexity of its own implementation.  The array can be registered as private, now it is not necessary to know about its existence. <br><br>  Of course, such a solution has a minus.  Saving memory can not affect the CPU load.  With this scheme, we are forced to constantly make calls to our associative array;  in most cases, for nothing, since most of the lines will remain blank and queries will return ‚Äú-1‚Äù. <br><br>  Therefore, I had to slightly change the concept of the application.  It was decided to provide the user with information about the star only when they click on this star - only then a query to the associative array will be executed and the data will be displayed on the screen. <br><br>  Despite the abstraction by the getter, we must admit that by introducing an associative array, we still significantly complicate the code.  This is usually the case with optimization.  Therefore, it is important to conduct high-quality unit-testing - to make sure that our associative array will not let us down at an unexpected moment. <br><br>  Total: stride now gives us 64 bytes! <br><br>  That's all?  No, now we need to recall the alignment rules again: we rearrange Int16 type fields higher. <br><br><img src="https://habrastorage.org/webt/qs/yh/hs/qsyhhsoleaji_jnucoeew5fjguq.jpeg"><br><br>  Now that's it.  As you can see, with the help of a small number of simple methods, we managed to reduce the size of the StarData structure from 208 to 56 bytes.  A million stars now occupies not 500 MB, but 130. Four times less! <br><br>  Do not forget about the dangers of premature optimization.  If your User data structure will be used for some 20 users, you won‚Äôt win there so much that there‚Äôs any point in doing this.  It is much more important that the next developer after you would be comfortable supporting the code.  Please do not say then "this dude at the conference said that the order should be exactly like this"!  Do not do this just for fun.  Well, for me such things are a good entertainment, I don‚Äôt know how for you. <br><br><h2>  Swift compiler optimization </h2><br>  Most programmers are well aware of the pain of a long (unbearably long) reassembly project.  You just made a small change to the code, and here you sit again and wait for the build to finish. <br><br>  But the build process can tell you something about your code.  This is an excellent indicator of bottlenecks, you only need to adapt it to work. <br><br>  Personally, I researched compilation in Xcode.  As a tool, I used the following command: <br><br><img src="https://habrastorage.org/webt/1x/36/j6/1x36j61elqsczwzbjldxjmdewtq.jpeg"><br><br>  This command instructs xCode to keep track of the compile time of each function and write it to the culprits.txt file.  The contents of the file are simultaneously sorted. <br><br><img src="https://habrastorage.org/webt/zz/ht/rp/zzhtrpbqbipvucqydinougkyzhu.jpeg"><br><br>  Using my simple tool, I could observe interesting things.  Some methods could be compiled for as long as 2 seconds, containing only three lines of code.  What can cause? <br><br>  For example, such a thing as output by the type compiler.  If you do not specify the types explicitly, Swift is forced to detect them yourself.  For this (I must say, non-trivial) operation, CPU time is required, therefore, from the point of view of the compiler, it is always better to specify the type.  Only by explicitly typing types, I once was able to reduce the build time of an application from 5 to 2 (!) Minutes. <br><br>  But there is one ‚Äúbut‚Äù: the code without types is still more readable.  And we have already talked about priorities.  Do not optimize ahead of time: at first, readability of the code will cost more. <br><br><h2>  Server option </h2><br>  So far, I have only mentioned my application with augmented reality.  But based on a million stars, I also created a server application for Swift.  You can see both <a href="https://starsonkitura.eu-de.mybluemix.net/">his own</a> and <a href="https://github.com/Bersaelor/StarsOnKitura">his GitHub code</a> .  This is an API service that allows you to get information about any stars from my huge database.  I was able to optimize it using the same methods that I used for the ARkit application.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result in this case was literally material for me: having reduced the volume to the 500 MB mark, I was able to place it on the free Bluemix server. </font><font style="vertical-align: inherit;">As a result, my service costs me absolutely free.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summarizing </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In conclusion, a small summary of the main thoughts that I wanted to address to you today: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Be careful about the choice of goals for the fight. </font><font style="vertical-align: inherit;">Optimization will always cost you the effort. </font><font style="vertical-align: inherit;">You can work hard to ensure that your variables are evaluated only once during runtime, but is it worth it, if in the code each of these variables is requested only a couple of times?</font></font></li><li>    ,     unit-. ,          unit-.    ,          . Unit-    ,     . </li><li>   .      ,        .   ,   :   ‚Äî  . </li><li>      .         .   ,    ‚Äî   ,   ¬´¬ª . </li><li> RAM vs.  CPU.           .     ,           . </li></ul><br><br><blockquote>        Mobius ‚Äî  ,  8-9   <b><a href="https://mobiusconf.com/">Mobius 2018 Moscow</a></b> ,     .  1    ,       ! </blockquote></div><p>Source: <a href="https://habr.com/ru/post/427845/">https://habr.com/ru/post/427845/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427835/index.html">The picture generated by the neural network went under the hammer for $ 432,500</a></li>
<li><a href="../427837/index.html">The first days in the development team - as it happens with us</a></li>
<li><a href="../427839/index.html">Authorization of users in Django through GSSAPI and delegation of user rights to the server</a></li>
<li><a href="../427841/index.html">Scam company Magic Leap</a></li>
<li><a href="../427843/index.html">How to sleep right and wrong</a></li>
<li><a href="../427847/index.html">Curiosity and procrastination in machine learning</a></li>
<li><a href="../427849/index.html">Straight line with TM. v3.0</a></li>
<li><a href="../427851/index.html">Mortal Kombat source leak</a></li>
<li><a href="../427853/index.html">Reflections on TDD. Why this methodology is not widely accepted</a></li>
<li><a href="../427855/index.html">MOSDROID mitap in FunCorp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>