<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unicode for Dummies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I myself do not really like headlines like ‚ÄúPokemons in their own juice for dummies \ pots \ pans‚Äù, but this seems to be the case - let's talk about b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unicode for Dummies</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/aeb/76d/d43/aeb76dd43e91158010a3c676752c0b21.png" alt="logo"><br>  I myself do not really like headlines like ‚ÄúPokemons in their own juice for dummies \ pots \ pans‚Äù, but this seems to be the case - let's talk about basic things, working with which often lead to a compartment full of cones and a lot of wasted time around "Why is it not working?"  If you are still afraid and \ or do not understand Unicode - I ask under cat. <br><br><a name="habracut"></a><br><h4>  What for? </h4><br>  The main question of a beginner, who meets with an impressive number of encodings and seemingly confusing mechanisms for working with them (for example, in Python 2.x).  The short answer is because it happened :) <br><br>  The coding, who does not know, refers to the way in which the computer‚Äôs memory (read, in zero-units / numbers) numbers, letters, and all other characters is called.  For example, a space is represented as 0b100000 (in binary), 32 (in decimal) or 0x20 (in hexadecimal). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, once there was very little memory and 7 computers were enough for all computers to represent all the necessary characters (numbers, lowercase / uppercase Latin alphabet, a bunch of characters and so-called manageable characters - all possible 127 numbers were given to someone).  The encoding at this time was one - <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a> .  As time went on, everyone was happy, and who was not happy (read - who lacked the "¬©" sign or the native letter "y") - they used the remaining 128 characters at their discretion, that is, they created new encodings.  That is how <a href="http://en.wikipedia.org/wiki/ISO/IEC_8859-1">ISO-8859-1</a> and our (that is, Cyrillic) <a href="http://en.wikipedia.org/wiki/Windows-1251">cp1251</a> and <a href="http://en.wikipedia.org/wiki/KOI_character_encodings">KOI8 appeared</a> .  Together with them appeared the problem of interpreting bytes of type 0b1 ******* (that is, characters \ numbers from 128 to 255) - for example, 0b11011111 in the cp1251 encoding is our native "I", at the same time in the ISO- 8859-1 is the <s>Greek</s> German Eszett (suggested by <a href="https://habrahabr.ru/users/moonrise/" class="user_link">Moonrise</a> ) "√ü".  It is expected, network communication and just file sharing between different computers turned into damn-knows-what, despite the fact that headers like 'Content-Encoding' in the HTTP protocol, email-letters and HTML pages saved the situation a bit. <br><br>  At that moment, bright minds gathered and proposed a new standard - <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a> .  This is exactly the standard, not the encoding - Unicode itself does not determine how the characters will be stored on the hard disk or transmitted over the network.  It only defines the connection between a character and a certain number, and the format according to which these numbers will be converted into bytes is determined by Unicode encodings (for example, <a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a> or <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a> ).  Currently, there are a little more than 100 thousand characters in the Unicode standard, while UTF-16 allows you to support more than one million (UTF-8 - and even more). <br><br>  Fuller and more fun on the topic I advise you to read the magnificent Joel Spolsky <a href="http://joelonsoftware.com/articles/Unicode.html">The Absolutely Positive Must Know About Unicode and Character Sets</a> . <br><br><h4>  Get to the point! </h4><br>  Naturally, there is Unicode support in Python.  But, unfortunately, only in Python 3 all lines became Unicode, and beginners have to be killed about errors like: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">'1.txt'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fh: s = fh.read() &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> s  &gt;&gt;&gt; parser_result = <span class="hljs-string"><span class="hljs-string">u'-'</span></span> <span class="hljs-comment"><span class="hljs-comment">#   ,  ,     -  &gt;&gt;&gt; parser_result + s</span></span></code> </pre> <pre> <code class="python hljs">Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;pyshell#43&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; parser_result + s UnicodeDecodeError: <span class="hljs-string"><span class="hljs-string">'ascii'</span></span> codec can<span class="hljs-string"><span class="hljs-string">'t decode byte 0xea in position 0: ordinal not in range(128)</span></span></code> </pre><br>  or so: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>str(parser_result)</code> </pre><pre> <code class="python hljs">Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;pyshell#52&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; str(parser_result) UnicodeEncodeError: <span class="hljs-string"><span class="hljs-string">'ascii'</span></span> codec can<span class="hljs-string"><span class="hljs-string">'t encode characters in position 0-3: ordinal not in range(128)</span></span></code> </pre><br>  Let's see, but in order. <br><br><h5>  Why would anyone use Unicode? </h5><br>  Why does my favorite html parser return Unicode?  Let him return the usual string, and I'll figure it out with her already!  Right?  Not really.  Although each of the characters existing in Unicode can (probably) be represented in some single-byte encoding (ISO-8859-1, cp1251, and others are called single-byte encoding, since they encode any character in exactly one byte), but what to do if the string should contain characters from different encodings?  Assign a separate encoding to each character?  No, of course, you need to use Unicode. <br><br><h5>  Why do we need a new type of "unicode"? </h5><br>  So we got to the most interesting.  What is a string in Python 2.x?  This is just <b>bytes</b> .  Just binary data that can be anything.  In fact, when we write something like: <pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-string"><span class="hljs-string">'abcd'</span></span> &gt;&gt;&gt; x <span class="hljs-string"><span class="hljs-string">'abcd'</span></span></code> </pre>  the interpreter does not create a variable that contains the first four letters of the Latin alphabet, but only the sequence <pre> <code class="python hljs">(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>)</code> </pre>  with four bytes, and the Latin letters here are used exclusively to denote this particular byte value.  That is, 'a' here is just a synonym for writing '\ x61', and not a bit more.  For example: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'\x61'</span></span> <span class="hljs-string"><span class="hljs-string">'a'</span></span> &gt;&gt;&gt; struct.unpack(<span class="hljs-string"><span class="hljs-string">'&gt;4b'</span></span>, x) <span class="hljs-comment"><span class="hljs-comment"># 'x' -    signed/unsigned char- (97, 98, 99, 100) &gt;&gt;&gt; struct.unpack('&gt;2h', x) #   short- (24930, 25444) &gt;&gt;&gt; struct.unpack('&gt;l', x) #   long (1633837924,) &gt;&gt;&gt; struct.unpack('&gt;f', x) #  float (2.6100787562286154e+20,) &gt;&gt;&gt; struct.unpack('&gt;d', x * 2) #    double- (1.2926117739473244e+161,)</span></span></code> </pre><br>  And that's it! <br><br>  And the answer to the question - why do we need a ‚Äúunicode‚Äù is more obvious - we need a type that will be represented by characters, not bytes. <br><br><h5>  Well, I understood what the string is.  Then what is Unicode in Python? </h5><br>  ‚ÄúType unicode‚Äù is primarily an abstraction that implements the idea of ‚Äã‚ÄãUnicode (a set of characters and numbers associated with them).  An object of the ‚Äúunicode‚Äù type is no longer a sequence of bytes, but a sequence of actual characters without any idea how these characters are effectively stored in the computer‚Äôs memory.  If you wish, this is a higher level of abstraction than byte strings (this is how Python 3 refers to regular strings used in Python 2.6). <br><br><h5>  How to use Unicode? </h5><br>  A unicode string in Python 2.6 can be created in three (at least naturally) ways: <br><ul><li>  u "" literal: <pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">u'abc'</span></span> <span class="hljs-string"><span class="hljs-string">u'abc'</span></span></code> </pre><br></li><li>  The ‚Äúdecode‚Äù method for a byte string: <pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'abc'</span></span>.decode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>) <span class="hljs-string"><span class="hljs-string">u'abc'</span></span></code> </pre><br></li><li>  Unicode feature: <pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>unicode(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>, <span class="hljs-string"><span class="hljs-string">'ascii'</span></span>) <span class="hljs-string"><span class="hljs-string">u'abc'</span></span></code> </pre><br></li></ul>  ascii in the last two examples is specified as the encoding that will be used to convert bytes into characters.  The stages of this transformation look like this: <br><br><pre> <code class="hljs rust"><span class="hljs-string"><span class="hljs-string">'\x61'</span></span> -&gt;  ascii -&gt;   <span class="hljs-string"><span class="hljs-string">"a"</span></span> -&gt; u<span class="hljs-string"><span class="hljs-string">'\u0061'</span></span> (unicode-point   )  <span class="hljs-string"><span class="hljs-string">'\xe0'</span></span> -&gt;  c1251 -&gt;   <span class="hljs-string"><span class="hljs-string">"a"</span></span> -&gt; u<span class="hljs-string"><span class="hljs-string">'\u0430'</span></span></code> </pre><br><br>  How from an unicode-line to receive the normal?  Encode it: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">u'abc'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'ascii'</span></span>) <span class="hljs-string"><span class="hljs-string">'abc'</span></span></code> </pre><br><br>  The coding algorithm is naturally the reverse of the above. <br><br>  We remember and do not confuse - Unicode == characters, string == bytes, and bytes -&gt; something meaningful (characters) is de-coding (decode), and characters -&gt; bytes - coding (encode). <br><br><h5>  Not encoded: ( </h5><br>  Let us examine the examples from the beginning of the article.  How does string and unicode string concatenation work?  A simple string must be turned into a unicode string, and since the interpreter does not know the encoding, it uses the default encoding - ascii.  If this encoding fails to decode the string, we get an ugly error.  In this case, we need to cast the string to the unicode string using the correct encoding: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> type(parser_result), parser_result &lt;type <span class="hljs-string"><span class="hljs-string">'unicode'</span></span>&gt; - &gt;&gt;&gt; s = <span class="hljs-string"><span class="hljs-string">''</span></span> &gt;&gt;&gt; parser_result + s</code> </pre><pre> <code class="python hljs">Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;pyshell#67&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; parser_result + s UnicodeDecodeError: <span class="hljs-string"><span class="hljs-string">'ascii'</span></span> codec can<span class="hljs-string"><span class="hljs-string">'t decode byte 0xea in position 0: ordinal not in range(128)</span></span></code> </pre><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>parser_result + s.decode(<span class="hljs-string"><span class="hljs-string">'cp1251'</span></span>) <span class="hljs-string"><span class="hljs-string">u'\xe1\xe0\xe1\xe0-\xff\xe3\xe0\u043a\u043e\u0449\u0435\u0439'</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> parser_result + s.decode(<span class="hljs-string"><span class="hljs-string">'cp1251'</span></span>) - &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'&amp;'</span></span>.join((parser_result, s.decode(<span class="hljs-string"><span class="hljs-string">'cp1251'</span></span>))) -&amp; <span class="hljs-comment"><span class="hljs-comment">#   :)</span></span></code> </pre><br><br>  "UnicodeDecodeError" is usually evidence that you need to decode a string into Unicode using the correct encoding. <br><br>  Now use "str" ‚Äã‚Äãand unicode strings.  Do not use "str" ‚Äã‚Äãand unicode strings :) In "str" ‚Äã‚Äãthere is no possibility to specify the encoding, accordingly the default encoding will always be used and any characters&gt; 128 will lead to an error.  Use the "encode" method: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> type(s), s &lt;type <span class="hljs-string"><span class="hljs-string">'unicode'</span></span>&gt;  &gt;&gt;&gt; str(s)</code> </pre><pre> <code class="python hljs">Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;pyshell#90&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; str(s) UnicodeEncodeError: <span class="hljs-string"><span class="hljs-string">'ascii'</span></span> codec can<span class="hljs-string"><span class="hljs-string">'t encode characters in position 0-4: ordinal not in range(128)</span></span></code> </pre> <pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s = s.encode(<span class="hljs-string"><span class="hljs-string">'cp1251'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> type(s), s &lt;type <span class="hljs-string"><span class="hljs-string">'str'</span></span>&gt; </code> </pre> <br><br>  ‚ÄúUnicodeEncodeError‚Äù is a sign that we need to specify the correct encoding during the conversion of a unicode string into a regular one (or use the second parameter 'ignore' \ 'replace' \ 'xmlcharrefreplace' in the ‚Äúencode‚Äù method). <br><br><h5>  I want more! </h5><br>  Well, use Baba Yaga from the example above again: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>parser_result = <span class="hljs-string"><span class="hljs-string">u'-'</span></span> <span class="hljs-comment"><span class="hljs-comment">#1 &gt;&gt;&gt; parser_result u'\xe1\xe0\xe1\xe0-\xff\xe3\xe0' #2 &gt;&gt;&gt; print parser_result √°√†√°√†-√ø√£√† #3 &gt;&gt;&gt; print parser_result.encode('latin1') #4 - &gt;&gt;&gt; print parser_result.encode('latin1').decode('cp1251') #5 - &gt;&gt;&gt; print unicode('-', 'cp1251') #6 -</span></span></code> </pre><br>  The example is not quite simple, but there is everything (or almost everything).  What's going on here: <br><ol><li>  What do we have at the entrance?  The bytes that IDLE transmits to the interpreter.  What is needed at the exit?  Unicode, that is, characters.  It remains to turn the bytes into characters - but you need the encoding, right?  What encoding will be used?  We look further. <br></li><li>  Here is an important point: <pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">'-'</span></span> <span class="hljs-string"><span class="hljs-string">'\xe1\xe0\xe1\xe0-\xff\xe3\xe0'</span></span> &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">u'\u00e1\u00e0\u00e1\u00e0-\u00ff\u00e3\u00e0'</span></span> == <span class="hljs-string"><span class="hljs-string">u'\xe1\xe0\xe1\xe0-\xff\xe3\xe0'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre>  As you can see, Python does not bother with the choice of encoding - bytes simply turn into Unicode points: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>ord(<span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-number"><span class="hljs-number">224</span></span> &gt;&gt;&gt; ord(<span class="hljs-string"><span class="hljs-string">u''</span></span>) <span class="hljs-number"><span class="hljs-number">224</span></span></code> </pre></li><li>  But the problem is that the 224th character in cp1251 (the encoding used by the interpreter) is not at all the same as 224 in Unicode.  It is because of this that we get cracks when trying to print our unicode string. <br></li><li>  How to help a woman?  It turns out that the first 256 Unicode characters are the same as in the ISO-8859-1 \ latin1 encoding, respectively, if we use it to encode a Unicode string, we get those bytes that were entered by ourselves (who are interested - <a href="">Objects / unicodeobject.c</a> , look for the definition of the function ‚Äúunicode_encode_ucs1‚Äù): <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>parser_result.encode(<span class="hljs-string"><span class="hljs-string">'latin1'</span></span>) <span class="hljs-string"><span class="hljs-string">'\xe1\xe0\xe1\xe0-\xff\xe3\xe0'</span></span></code> </pre></li><li>  How to get a woman in Unicode?  You must specify which encoding to use: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>parser_result.encode(<span class="hljs-string"><span class="hljs-string">'latin1'</span></span>).decode(<span class="hljs-string"><span class="hljs-string">'cp1251'</span></span>) <span class="hljs-string"><span class="hljs-string">u'\u0431\u0430\u0431\u0430-\u044f\u0433\u0430'</span></span></code> </pre></li><li>  The way from point # 5 is certainly not so hot, it is much more convenient to use use built-in <a href="http://docs.python.org/library/functions.html">unicode</a> . </li></ol>  In fact, not everything is so bad with "u" literals, since the problem occurs only in the console.  After all, if non-ascii characters are used in the source file, Python will insist on using a header like "# - * - coding: - * -" ( <a href="http://www.python.org/dev/peps/pep-0263/">PEP 0263</a> ), and unicode strings will use the correct encoding. <br><br>  There is also a way to use ‚Äúu‚Äù to represent, for example, Cyrillic, and not to specify the encoding or unreadable unicode points (that is, ‚Äúu '\ u1234'‚Äù).  The method is not entirely convenient, but interesting - use unicode entity codes: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s = <span class="hljs-string"><span class="hljs-string">u'\N{CYRILLIC SMALL LETTER KA}\N{CYRILLIC SMALL LETTER O}\N{CYRILLIC SMALL LETTER SHCHA}\N{CYRILLIC SMALL LETTER IE}\N{CYRILLIC SMALL LETTER SHORT I}'</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> s </code> </pre><br><br>  Well, everything seems to be.  The basic advice is not to confuse "encode" \ "decode" and understand the differences between bytes and characters. <br><br><h5>  Python 3 </h5><br>  There is no code here, because there is no experience.  Witnesses claim that everything is much simpler and more fun.  Who will take on the cats to demonstrate the differences between here (Python 2.x) and there (Python 3.x) - Respect and respect. <br><br><h4>  Useful </h4><br>  Since we're talking about encodings, I would recommend a resource that helps to overcome crackers from time to time - <a href="http://2cyr.com/decode/%3Flang%3Dru">http://2cyr.com/decode/?lang=ru</a> . <br><br>  Once again, link to Spolsky's article - <a href="http://joelonsoftware.com/articles/Unicode.html">The Absolutely Minimum Every Software Developer</a> . <br><br>  <a href="http://docs.python.org/howto/unicode.html">Unicode HOWTO</a> - the official document on where, how and why Unicode in Python 2.x. <br><br>  Thanks for attention.  I would be grateful for comments in private. <br><br>  PS They threw a link to the translation of Spolsky - the <a href="http://local.joelonsoftware.com/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D0%25BE%25D0%25BB%25D1%258E%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D0%259C%25D0%25B8%25D0%25BD%25D0%25B8%25D0%25BC%25D1%2583%25D0%25BC,_%25D0%25BA%25D0%25BE%25D1%2582%25D0%25BE%25D1%2580%25D1%258B%25D0%25B9_%25D0%259A%25D0%25B0%25D0%25B6%25D0%25B4%25D1%258B%25D0%25B9_%25D0%25A0%25D0%25B0%25D0%25B7%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D1%2587%25D0%25B8%25D0%25BA_%25D0%259F%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%259E%25D0%25B1%25D0%25B5%25D1%2581%25D0%25BF%25D0%25B5%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%259E%25D0%25B1%25D1%258F%25D0%25B7%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE_%25D0%2594%25D0%25BE%25D0%25BB%25D0%25B6%25D0%25B5%25D0%25BD_%25D0%2597%25D0%25BD%25D0%25B0%25D1%2582%25D1%258C_%25D0%25BE_Unicode_%25D0%25B8_%25D0%259D%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2580%25D0%25B0%25D1%2585_%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25B2%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B2">Absolute Minimum that Every Software Developer Must Know about Unicode and Character Sets</a> . </div><p>Source: <a href="https://habr.com/ru/post/135913/">https://habr.com/ru/post/135913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135902/index.html">Packaging of Python-program in APK format</a></li>
<li><a href="../135904/index.html">Project management system with blackjack and addons</a></li>
<li><a href="../135908/index.html">Django Admin Bootstrap Theme</a></li>
<li><a href="../135909/index.html">Comprehensive course on site development: prerequisites, dreams and plans</a></li>
<li><a href="../135912/index.html">Super cheap camera with control - do it yourself</a></li>
<li><a href="../135914/index.html">The interaction of the circuit in Proteus with the outside world</a></li>
<li><a href="../135915/index.html">Backdoor in Active Directory # 2</a></li>
<li><a href="../135916/index.html">Manual: Pyramid for People - Table of Contents</a></li>
<li><a href="../135917/index.html">New C ++ World Map from Alenacpp</a></li>
<li><a href="../135919/index.html">Simple minimalist implementation of complex JavaScript applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>