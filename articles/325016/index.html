<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Little tricks DirectX and HLSL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I decided to write an article about small tricks that I use in my modest engine. This is more like a note to yourself, and experienced progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Little tricks DirectX and HLSL</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I decided to write an article about small tricks that I use in my modest engine.  This is more like a note to yourself, and experienced programmers will only smile, but I think it may be useful for beginners. <br><a name="habracut"></a><br><h3>  1. HLSL Matrices </h3><br>  Suppose in the vertex shader we need to rotate the normal (tangent, binormal) vertex and we have a 4x4 world matrix.  But the shift wired into the matrix, we do not need.  Then simply bring the matrix to 3x3: <br><br><pre><code class="cpp hljs">output.Normal = mul(input.Normal.xyz, (float3x3)RotM);</code> </pre> <br>  By the way, if you need to get an inverse matrix from a 3x3 rotation matrix, and at the same time it is orthogonal, then simply transpose it: <br><br><pre> <code class="cpp hljs">float3<span class="hljs-number"><span class="hljs-number">3</span></span> invMat = transpose(Mat);</code> </pre> <br>  Or you can do without it, if you only need to get the vector transformed by the inverse matrix - then it is enough to change the order of multiplication of the matrix and vector: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs">float3 outVector = mul((float3x3)RotM, inVector.xyz);</code> </pre> <br>  You probably know that you can use the following entry to access the matrix element: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> value = World._m30;</code> </pre> <br>  However, the syntax allows you to get several values ‚Äã‚Äãfrom a matrix at once.  For example, get the move from the transformation matrix: <br><br><pre> <code class="cpp hljs">float3 objPosition = World._m30_m31_m32;</code> </pre> <br><h3>  2. Render without vertex buffer </h3><br>  DX11 has a great opportunity to send vertices to the render without creating a vertex buffer for this.  Code for C # and SharpDX wrapper: <br><br><pre> <code class="cpp hljs">System.IntPtr n_IntPtr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> System.IntPtr(<span class="hljs-number"><span class="hljs-number">0</span></span>); device.ImmediateContext.InputAssembler.InputLayout = null; device.ImmediateContext.InputAssembler.SetVertexBuffers(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, n_IntPtr, n_IntPtr, n_IntPtr); device.ImmediateContext.InputAssembler.SetIndexBuffer(null, Format.R32_UInt, <span class="hljs-number"><span class="hljs-number">0</span></span>); device.ImmediateContext.Draw(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Here we send three vertices to the render.  And in the shader, for example, we can build a full-screen quad from them: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VertexInput</span></span></span><span class="hljs-class"> {</span></span> uint VertexID : SV_VertexID; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PixelInput</span></span></span><span class="hljs-class"> {</span></span> float4 Position : SV_POSITION; }; <span class="hljs-function"><span class="hljs-function">PixelInput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DefaultVS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexInput input)</span></span></span><span class="hljs-function"> </span></span>{ PixelInput output = (PixelInput)<span class="hljs-number"><span class="hljs-number">0</span></span>; uint id = input.VertexID; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = <span class="hljs-number"><span class="hljs-number">-1</span></span>, y = <span class="hljs-number"><span class="hljs-number">-1</span></span>; x = (id == <span class="hljs-number"><span class="hljs-number">2</span></span>) ? <span class="hljs-number"><span class="hljs-number">3.0</span></span> : <span class="hljs-number"><span class="hljs-number">-1.0</span></span>; y = (id == <span class="hljs-number"><span class="hljs-number">1</span></span>) ? <span class="hljs-number"><span class="hljs-number">3.0</span></span> : <span class="hljs-number"><span class="hljs-number">-1.0</span></span>; output.Position = float4(x, y, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre> <br><br><h3>  3. Render without pixel shader </h3><br>  Another useful feature is a render without a pixel shader.  This allows you to significantly optimize the time to render in some cases.  For example, when the depth prepas, or when rendering shadows.  We simply do not install the pixel shader in our pipeline: <br><br><pre> <code class="cpp hljs">pass GS_PSSM { SetVertexShader(CompileShader(vs_5_0, ShadowMapVS())); SetGeometryShader(CompileShader(gs_5_0, ShadowMapGS())); SetPixelShader(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); SetBlendState(NoBlending, float4(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>); SetDepthStencilState(EnableDepth, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Or: <br><br><pre> <code class="cpp hljs">device.ImmediateContext.PixelShader.Set(null);</code> </pre> <br>  In both cases, the pixel shader will not be executed, and the depth interpolated in the vertex shader will be recorded in the render target. <br><br>  You can go further and install a pixel shader, which returns nothing: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZPrepasPS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PixelInputZPrePass input)</span></span></span><span class="hljs-function"> </span></span>{ float4 albedo = AlbedoMap.Sample(Aniso, input.UV.xy); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (albedo.w &lt; AlphaTest.x) discard; }</code> </pre> <br>  In this case, an alpha test is performed.  And if it is not passed, then the pixel will be thrown out of the pipeline.  If everything is in order, then, similarly to the previous case, the depth interpolated by the vertex shader will be written into the render target. <br><br><h3>  4. Alpha to coverage </h3><br>  In the DX10 / 11, there is a remarkable opportunity to smooth out alphatest using hardware, using MSAA.  If in simple terms, this is an opportunity in the pixel shader to independently indicate how many samples of each pixel of the MSAA renderarget passed the test. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float2 MSAAOffsets8[<span class="hljs-number"><span class="hljs-number">8</span></span>] = { float2(<span class="hljs-number"><span class="hljs-number">0.0625</span></span>, <span class="hljs-number"><span class="hljs-number">-0.1875</span></span>), float2(<span class="hljs-number"><span class="hljs-number">-0.0625</span></span>, <span class="hljs-number"><span class="hljs-number">0.1875</span></span>), float2(<span class="hljs-number"><span class="hljs-number">0.3125</span></span>, <span class="hljs-number"><span class="hljs-number">0.0625</span></span>), float2(<span class="hljs-number"><span class="hljs-number">-0.1875</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3125</span></span>), float2(<span class="hljs-number"><span class="hljs-number">-0.3125</span></span>, <span class="hljs-number"><span class="hljs-number">0.3125</span></span>), float2(<span class="hljs-number"><span class="hljs-number">-0.4375</span></span>, <span class="hljs-number"><span class="hljs-number">-0.0625</span></span>), float2(<span class="hljs-number"><span class="hljs-number">0.1875</span></span>, <span class="hljs-number"><span class="hljs-number">0.4375</span></span>), float2(<span class="hljs-number"><span class="hljs-number">0.4375</span></span>, <span class="hljs-number"><span class="hljs-number">-0.4375</span></span>) }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZPrepasPSMS8</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PixelInputZPrePass input, out uint coverage : SV_Coverage)</span></span></span><span class="hljs-function"> </span></span>{ coverage = <span class="hljs-number"><span class="hljs-number">0</span></span>; [branch] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AlphaTest.x &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">255.0</span></span>) coverage = <span class="hljs-number"><span class="hljs-number">255</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { float2 tc_ddx = ddx(input.UV.xy); float2 tc_ddy = ddy(input.UV.xy); [unroll] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { float2 texelOffset = MSAAOffsets8[i].x * tc_ddx + v2MSAAOffsets8[i].y * tc_ddy; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> temp = AlbedoMap.Sample(Aniso, input.UV.xy + texelOffset).w; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>) coverage |= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; i; } } }</code> </pre> <br>  My accounting for alpha test occurs only at the stage of Z-prepas.  After the final pass, we only need to perform the MSAA buffer resolver and our alpha-test will smooth out like a normal geometry (the correct HDR MSAA buffer resolver is a topic for a separate article). <br><br><div class="spoiler">  <b class="spoiler_title">Comparative screenshots</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/010/807/ca1/010807ca11d24bc3b683cbcbd1e9b0a6.png"><br><img src="https://habrastorage.org/files/b5f/c14/e39/b5fc14e3941a496a8e92792c13731daf.png"><br></div></div><br><h3>  5. Screen antialiasing normals </h3><br>  This idea came to me after the introduction of the previous paragraph.  I perform a supersampling from a normal texture with a UV offset calculated in the screenspace.  Since I use the Forward + approach with Z-prepas, such an operation is minimal. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float2 MSAAOffsets4[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { float2(<span class="hljs-number"><span class="hljs-number">-0.125</span></span>, <span class="hljs-number"><span class="hljs-number">-0.375</span></span>), float2(<span class="hljs-number"><span class="hljs-number">0.375</span></span>, <span class="hljs-number"><span class="hljs-number">-0.125</span></span>), float2(<span class="hljs-number"><span class="hljs-number">-0.375</span></span>, <span class="hljs-number"><span class="hljs-number">0.125</span></span>), float2(<span class="hljs-number"><span class="hljs-number">0.125</span></span>, <span class="hljs-number"><span class="hljs-number">0.375</span></span>) }; float3 ONormal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); float2 tc_ddx = ddx(input.UV.xy); float2 tc_ddy = ddy(input.UV.xy); [unroll] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { float2 texelOffset = MSAAOffsets4[i].x * tc_ddx + MSAAOffsets4[i].y * tc_ddy; float4 temp = NormalMap.Sample(Aniso, input.UV.xy + texelOffset*<span class="hljs-number"><span class="hljs-number">1.5</span></span>); ONormal += temp.ywy; } ONormal *= <span class="hljs-number"><span class="hljs-number">0.25</span></span>; Normal = ONormal * <span class="hljs-number"><span class="hljs-number">2.0f</span></span> - <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comparative screenshots</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/bce/21f/b43/bce21fb4341a4408b99025f2a2bbe7d3.png"><br><img src="https://habrastorage.org/files/c82/006/8c7/c820068c7e9d4ffe96c0ad2f418444e4.png"><br></div></div><br><h3>  6. Normals of two-sided geometry </h3><br>  To avoid lighting artifacts, for a double-sided triangle, you need to invert the normal if we look at the opposite side of them: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalPS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PixelInput input, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isFrontFace : SV_IsFrontFace)</span></span></span><span class="hljs-function"> : SV_Target </span></span>{ input.Normal *= (<span class="hljs-number"><span class="hljs-number">1</span></span> - isFrontFace * <span class="hljs-number"><span class="hljs-number">2</span></span>); ...</code> </pre> <br><h3>  7. Find out the texture size in the shader. </h3><br>  I do not use this opportunity myself, as there are doubts about its performance, however, it may be useful to someone: <br><br><pre> <code class="cpp hljs">Texture2D texture; uint width, height; texture.GetDimensions(width, height);</code> </pre> <br><h3>  8. Sprites geometric shaders </h3><br>  With the advent of geometry shaders, it has become possible to do various optimizations.  For example, speed up render sprites.  Single vertices are sent to the video card containing all the information about the sprite.  A full sprite is constructed in a geometric shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VS_IN</span></span></span><span class="hljs-class"> {</span></span> float4 Position : POSITION; float4 UV : TEXCOORD0; float4 Rotation : TEXCOORD1; float4 Color : TEXCOORD2; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VS_OUT</span></span></span><span class="hljs-class"> {</span></span> float4 Position : SV_POSITION; float4 UV : TEXCOORD0; float4 Rotation : TEXCOORD1; float4 Color : TEXCOORD2; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GS_OUT</span></span></span><span class="hljs-class"> {</span></span> float4 Position : SV_POSITION; float2 TexCoord : TEXCOORD0; float4 Color : TEXCOORD1; } <span class="hljs-function"><span class="hljs-function">VS_OUT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GSSprite_VS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( VS_IN Input )</span></span></span><span class="hljs-function"> </span></span>{ VS_OUT Output; float2 center = (Input.Position.xy + Input.Position.zw) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; float2 size = (Input.Position.zw - center)*<span class="hljs-number"><span class="hljs-number">2.0</span></span>; Output.Position = float4(center, size); Output.UV = Input.UV; Output.Color = Input.Color; Output.Rotation = Input.Rotation; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Output; } [maxvertexcount(<span class="hljs-number"><span class="hljs-number">6</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GSSprite_GS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point VS_OUT In[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;GS_OUT&gt; triStream)</span></span></span><span class="hljs-function"> </span></span>{ GS_OUT p0 = (GS_OUT) <span class="hljs-number"><span class="hljs-number">0</span></span>; GS_OUT p1 = (GS_OUT) <span class="hljs-number"><span class="hljs-number">0</span></span>; GS_OUT p2 = (GS_OUT) <span class="hljs-number"><span class="hljs-number">0</span></span>; GS_OUT p3 = (GS_OUT) <span class="hljs-number"><span class="hljs-number">0</span></span>; In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.xy = In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.xy * Resolution.zw * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.y = -In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.y; float2 r = float2(In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Rotation.x, -In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Rotation.y); float2 t = float2(In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Rotation.y, In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Rotation.x); p0.Position = float4(In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.xy + (-In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.z * r + In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.w * t) * Resolution.zw, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); p0.TexCoord = In[<span class="hljs-number"><span class="hljs-number">0</span></span>].UV.xy; p0.Color = In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Color; p1.Position = float4(In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.xy + (In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.z * r + In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.w * t) * Resolution.zw, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); p1.TexCoord = In[<span class="hljs-number"><span class="hljs-number">0</span></span>].UV.zy; p1.Color = In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Color; p2.Position = float4(In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.xy + (In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.z * r - In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.w * t) * Resolution.zw, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); p2.TexCoord = In[<span class="hljs-number"><span class="hljs-number">0</span></span>].UV.zw; p2.Color = In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Color; p3.Position = float4(In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.xy + (-In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.z * r - In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Position.w * t) * Resolution.zw, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); p3.TexCoord = In[<span class="hljs-number"><span class="hljs-number">0</span></span>].UV.xw; p3.Color = In[<span class="hljs-number"><span class="hljs-number">0</span></span>].Color; triStream.Append(p0); triStream.Append(p1); triStream.Append(p2); triStream.RestartStrip(); triStream.Append(p0); triStream.Append(p2); triStream.Append(p3); triStream.RestartStrip(); }</code> </pre> <br>  According to my measurements, this approach gives about 20-30% of acceleration on both weak and powerful gland. <br><br><h3>  9. Lens Flare </h3><br>  I use a similar approach for drawing lens effects.  Only the visibility check I spend immediately before constructing the sprite.  First, I check how far the effect is from the edges of the screen.  Then there is a check for the percentage of effect overlapping by objects in the depth buffer.  If both checks are passed, then I construct the sprite: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int2 offset[<span class="hljs-number"><span class="hljs-number">61</span></span>] = { int2( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), int2( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), int2( <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), int2( <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), int2( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), int2( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), int2( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), int2( <span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), int2( <span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>), int2( <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>), int2( <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), int2( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), int2( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), int2( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), int2( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), int2( <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), int2( <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), int2( <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>), int2( <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-3</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>), int2( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), int2( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), int2( <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), int2( <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), int2( <span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), int2( <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>), int2( <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>), int2( <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>), int2( <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">-4</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>), int2( <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">-3</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-3</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-4</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), int2(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), int2( <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), int2( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), int2( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), int2( <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), int2( <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), int2( <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)}; [maxvertexcount(<span class="hljs-number"><span class="hljs-number">6</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GSSprite_GS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point VS_OUT In[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;GS_OUT&gt; triStream, uniform </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MSAA)</span></span></span><span class="hljs-function"> </span></span>{ LensFlareStruct LFS = LensFlares[In[<span class="hljs-number"><span class="hljs-number">0</span></span>].VertexID]; float4 Position = mul(LFS.Direction, ViewProection); float3 NPos = Position.xyz / Position.w; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = NPos.x - <span class="hljs-number"><span class="hljs-number">-1</span></span>; dist = min(<span class="hljs-number"><span class="hljs-number">1</span></span> - NPos.x, dist) * ScrRes.z; <span class="hljs-comment"><span class="hljs-comment">//Proportion dist = min(NPos.y - -1, dist); dist = min(1 - NPos.y, dist); dist = min(NPos.z &lt; 0.9, dist); dist = saturate(dist * 20); if (dist &gt; 0) { float2 SPos = float2(NPos.x, -NPos.y) * 0.5 + 0.5; int2 LPos = round(SPos * ScrRes.xy); float v = 0; if (MSAA) { for (int i = 0; i &lt; 61; i++) v += DepthTextureMS.Load(LPos + offset[i], 0) &lt; NPos.z; } else { for (int i = 0; i &lt; 61; i++) v += DepthTexture.Load(uint3(LPos + offset[i], 0)) &lt; NPos.z; } v = pow(v / 61.0, 2.0); dist *= v; if (dist &gt; 0) { float2 Size = LFS.Size.xy * float2(ScrRes.w, 1); Quad(triStream, Position, LFS.UV, Size * saturate(dist + 0.1), LFS.Color.xyz * dist); } } }</span></span></code> </pre> <br><h3>  10. Render PSSM using geometric shaders </h3><br>  Another great example is the optimization of Parallel-Split Shadow Maps geometric shaders from GPU Gems.  In order to send a separate dip to render an object to each split, we can duplicate the geometry of the video card and render it into different renderargets for one dip: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SHADOW_VS_OUT</span></span></span><span class="hljs-class"> {</span></span> float4 pos : SV_POSITION; float4 UV1 : TEXCOORD0; nointerpolation uint instId : SV_InstanceID; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GS_OUT</span></span></span><span class="hljs-class"> {</span></span> float4 pos : SV_POSITION; float2 Texcoord : TEXCOORD0; nointerpolation uint RTIndex : SV_RenderTargetArrayIndex; }; [maxvertexcount(SPLITCOUNT * <span class="hljs-number"><span class="hljs-number">3</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GS_RenderShadowMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(triangle SHADOW_VS_OUT In[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">], inout TriangleStream&lt;GS_OUT&gt; triStream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// For each split to render for (int split = IstanceData[In[0].instId].Start; split &lt;= IstanceData[In[0].instId].Stop; split++) { GS_OUT Out; // Set render target index. Out.RTIndex = split; // For each vertex of triangle [unroll(3)] for (int vertex = 0; vertex &lt; 3; vertex++) { // Transform vertex with split-specific crop matrix. Out.pos = mul(In[vertex].pos, cropMatrix[split]); Out.Texcoord = In[vertex].UV1.xy; // Append vertex to stream triStream.Append(Out); } // Mark end of triangle triStream.RestartStrip(); } }</span></span></code> </pre> <br><h3>  11. Instancing </h3><br>  With the transition to DX11, rendering with the use of instancing has become much easier.  Now it is not necessary to create an additional stream of vertices with information for each instance.  You can simply specify how many instances we need: <br><br><pre> <code class="cpp hljs">device.ImmediateContext.DrawIndexedInstanced(IndicesCount, Meshes.Count, StartInd, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  And then, in the shader, get its index for each instance and determine the necessary additional information from it: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PerInstanceData</span></span></span><span class="hljs-class"> {</span></span> float4x4 WVP; float4x4 World; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Start; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Stop; int2 Padding; }; StructuredBuffer&lt;PerInstanceData&gt; IstanceData : <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(t16); <span class="hljs-function"><span class="hljs-function">PixelInput </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DefaultVS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VertexInput input, uint id : SV_InstanceID)</span></span></span><span class="hljs-function"> </span></span>{ PixelInput output = (PixelInput) <span class="hljs-number"><span class="hljs-number">0</span></span>; output.Position = mul(float4(input.Position.xyz, <span class="hljs-number"><span class="hljs-number">1</span></span>), IstanceData[id].WVP); output.UV.xy = input.UV; output.WorldPos = mul(float4(input.Position, <span class="hljs-number"><span class="hljs-number">1</span></span>), IstanceData[id].World).xyz; ...</code> </pre> <br><h3>  12. Converting 2D UV and Side Index to Vector for Cubic </h3><br>  It can be useful when working with cubmaps. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float3 offsetV[<span class="hljs-number"><span class="hljs-number">6</span></span>] = { float3(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), float3(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), float3(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>), float3(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), float3(<span class="hljs-number"><span class="hljs-number">-1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>), float3(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">-1</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float3 offsetX[<span class="hljs-number"><span class="hljs-number">6</span></span>] = { float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>), float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), float3(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), float3(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), float3(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), float3(<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> float3 offsetY[<span class="hljs-number"><span class="hljs-number">6</span></span>] = { float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>), float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>), float3(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">-2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertUV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 UV, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FaceIndex)</span></span></span><span class="hljs-function"> </span></span>{ float3 outV = offsetV[FaceIndex] + offsetX[FaceIndex] * UV.x + offsetY[FaceIndex] * UV.y; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> normalize(outV); }</code> </pre> <br><h3>  13. Optimization of the Gauss filter </h3><br>  And for a snack - a simple way to optimize Gauss.  We use hardware filtering - we sample two neighboring pixels, with a pre-calculated shift between them.  Thereby minimizing the total number of samples. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Shift[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0.4861161486</span></span>, <span class="hljs-number"><span class="hljs-number">0.4309984373</span></span>, <span class="hljs-number"><span class="hljs-number">0.3775380497</span></span>, <span class="hljs-number"><span class="hljs-number">0.3269038909</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Mult[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {<span class="hljs-number"><span class="hljs-number">0.194624</span></span>, <span class="hljs-number"><span class="hljs-number">0.189416</span></span>, <span class="hljs-number"><span class="hljs-number">0.088897</span></span>, <span class="hljs-number"><span class="hljs-number">0.027063</span></span> }; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetGauss15</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Texture2D&lt;float3&gt; Tex, float2 UV, float2 dx)</span></span></span><span class="hljs-function"> </span></span>{ float3 rez = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) rez += (Tex.Sample(LinSampler, UV + (Shift[i] + i*<span class="hljs-number"><span class="hljs-number">2</span></span>)*dx ).xyz + Tex.Sample(LinSampler, UV - (Shift[i] + i*<span class="hljs-number"><span class="hljs-number">2</span></span>)*dx).xyz) * Mult[i]; rez += Tex.Sample( LinSampler, UV ).xyz * <span class="hljs-number"><span class="hljs-number">0.134598</span></span>; rez += (Tex.Sample( LinSampler, UV + dx ).xyz + Tex.Sample( LinSampler, UV - dx ).xyz )* <span class="hljs-number"><span class="hljs-number">0.127325</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rez; }</code> </pre> <br>  That's actually the whole damn dozen, I hope the material will be useful to someone. </div><p>Source: <a href="https://habr.com/ru/post/325016/">https://habr.com/ru/post/325016/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325006/index.html">15 VoIP Providers and 8 CRM: Compatibility Overview</a></li>
<li><a href="../325008/index.html">We try to do web-frontend on Rust (WebAssembly)</a></li>
<li><a href="../325010/index.html">Painless inoculation of object thinking</a></li>
<li><a href="../325012/index.html">Managing CST MWS with Matlab</a></li>
<li><a href="../325014/index.html">The company has more similar jobs</a></li>
<li><a href="../325018/index.html">‚ÄúSim-Sim, open!‚Äù, Or how to open a link via RemoteApp</a></li>
<li><a href="../325022/index.html">The new chip from Applied Micro is ready to contend with Intel Xeon</a></li>
<li><a href="../325026/index.html">Infrastructure organization with the help of Kubernetes and Helm. Video recordings of reports from Kubernetes meetup March 22, 2017</a></li>
<li><a href="../325028/index.html">Web Scrolling: Primer</a></li>
<li><a href="../325030/index.html">7 questions that you ask at the interview for the position of UX designer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>