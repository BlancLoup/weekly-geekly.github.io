<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerated course on notations in the theory of programming languages</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programmers are often faced with the problems of reading mathematical notations when they try to understand the theoretical foundations of a programmi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerated course on notations in the theory of programming languages</h1><div class="post__text post__text-html js-mediator-article">  Programmers are often faced with the problems of reading mathematical notations when they try to understand the theoretical foundations of a programming language.  I also pushed with them in my theoretical research.  Fortunately, the wonderful article by Jeremy Siek, whose translation I want to share with you, helped me a lot.  I hope it will help many non-mathematician programmers. <br><a name="habracut"></a><br><h3>  Introduction </h3><br>  With this post I want to help my friends with reading my other posts.  This is an accelerated course on notations used in the theory of programming languages ‚Äã‚Äã(TNG).  For a much better study of the topic, I recommend ‚ÄúTypes and Programming Languages‚Äù from Benjamin C. Pierce and ‚ÄúSemantic Engineering with PLT Redex‚Äù from Felleisen, Findler, and Flatt.  I assume that the reader is an experienced programmer, but not so good at math and TNT.  I will start with the basic definitions and try to quickly get you up to speed. <br><br><h3>  Sets, tuples, relationships, and rule definitions </h3><br>  I suspect that many readers will be familiar with sets, tuples, and relationships, but if you are not familiar with inductive definitions, then read the ‚Äúrules by definition‚Äù section below. <br><br><h4>  The sets </h4><br>  The main building block that we use in the TNG is a multitude, i.e.  collection of objects (or items).  For example, a set consisting of the first three natural numbers: {0, 1, 2}. <br>  The only fact that matters is whether the object belongs to the set or not.  It does not matter whether there are duplicates or what order the object appears in the set.  For example, the set {0, 2, 1} is the same as the one above.  Notation <b>‚àà</b> means "in".  Thus, 1 ‚àà {0, 1, 2} is true and 3 ‚àà {0, 1, 2} is false.  Sets can contain an infinite number of elements.  For example, the set of all natural numbers (nonnegative integers), denoted by <b>N.</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Tuples </h4><br>  Another building block is a tuple, i.e.  ordered collection of objects.  So  (0, 1, 2) is a tuple of three elements and it differs from the tuple (0, 2, 1).  The subscript t <sub>i</sub> stands for the i-th (with index i) element of the tuple t.  For example, if t = (0, 2, 1), then t <sub>1</sub> = 0, t <sub>2</sub> = 2, t <sub>3</sub> = 1. Tuples always contain a finite number of elements and usually quite a bit.  Sometimes to refer to tuples, angle brackets are used instead of round ones: <img src="https://habrastorage.org/files/b1b/b2f/d62/b1bb2fd622e243da85e7a9992df8597d.png">  . <br><br><h4>  Relations </h4><br>  By combining tuples and sets we get relationships.  Attitude is a multitude of tuples. <br><br>  {(0, 1), (1,2), (2, 3), (3, 4), ...} <br><br>  We often use relationships to display input values ‚Äã‚Äãover the weekend.  For example, we can think of the relation above as the mapping of a natural number to its follower, i.e.  to the next greater natural number.  The definition above is rather inaccurate due to the use of (...).  Fortunately, there are more accurate notations for describing infinite sets and relations. <br><br><h4>  Definition rules </h4><br>  The main way in which we define infinite sets in the TNG is to provide a set of rules describing which elements are in the set.  Let's use the name R for the set above.  Then the following two rules will give us a precise definition of R. Note that the second rule is recursive in the sense that it refers to itself.  This is a normal and fairly common situation. <br><br><ol><li>  (0, 1) ‚àà R. </li><li>  For any positive integers n and m, if (n, m) ‚àà R, then (n + 1, m + 1) ‚àà R. </li></ol><br>  When we use rules to define a set, we mean that the element is not in the set, if there is no way to use these rules to justify finding this element in the set.  So (0, 0) does not belong to R, because it is impossible to substantiate with the help of the indicated rules that (0, 0) belongs to it. <br>  Some rule sets are meaningless and do not define a set.  For example, the rules should not contradict each other, like this: <br><br><ol><li>  (0, 1) ‚àà R. </li><li>  (0, 1) ‚àâ R. </li></ol><br>  The TNG textbook describes limitations for ‚Äúgood‚Äù rule sets, but we will not go into that.  We will only say that at least one rule should be non-recursive and there should be no such logical contradictions. <br>  A common notation for rules, as above, uses a horizontal line between ‚Äúif‚Äù and ‚Äúthen‚Äù.  For example, an equivalent definition for R is given as follows. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db4/399/e9a/db4399e9a5d8356b4f9a41c4d2f3fd26.png" alt="(1) \, \ frac {} {(0,1) \ in R} \ qquad (2) \, \ frac {(n, m) \ in R} {(n + 1, m + 1) \ in R}" width="318" height="46"></div><br>  We omitted ‚Äúfor any natural numbers n and m‚Äù from rule 2. The convention is used, according to which variables, such as n and m, which appear in the rule, can be replaced by any object of the correct type.  In this case, a natural number.  Often, the ‚Äúcorrect type‚Äù is something that can be guessed from the context of the conversation.  In this case, natural numbers. <br>  Suppose I say that some element is in R. Let's say (2, 3) ‚àà R. You can answer that you do not believe me.  To convince you, I need to show how the rules justify the fact that (2, 3) ‚àà R. I have to show you the conclusion.  The output is a chain of rules in which variables, such as n and m, are replaced with specific values ‚Äã‚Äãand prerequisites, such as (n, m) ‚àà R, are replaced with more specific conclusions. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a90/dcf/fb3/a90dcffb347e94ec6a432852175406d7.png" alt="(2) \ frac {(2) \ begin {array} {c} (1) \ begin {array} {c} \\\ hline (0,1) \ in R \ end {array} \\\ hline ( 1,2) \ in R \ end {array}} {(2,3) \ in R}" width="185" height="76"></div><br>  I marked each step in the derivation with a rule number.  A whimsical name for what I call the ‚Äúdefinition of rules‚Äù is an inductive definition. <br><br><h3>  Language and Grammar Syntax </h3><br>  It turns out that the use of rules to define sets, as we did above, is also suitable for determining the syntax of a programming language.  Suppose we need to define a simple language for integer arithmetic.  Let's call it Arith.  It will contain expressions such as 1 + 3 and - (5 + 2).  Recall that Z is a set of integers.  Then the set of rules describing Arith will be: <br><br><ul><li>  For any i ‚àà Z, it is true that i ‚àà Arith. </li><li>  For any e, if e ‚àà Arith, then -e ‚àà Arith. </li><li>  For any e1 and e2, if e1 ‚àà Arith and e2 ‚àà Arith, then e1 + e2 ‚àà Arith. </li><li>  For any e, if e ‚àà Arith, then (e) ‚àà Arith. </li></ul><br>  The Backus-Naur form (BNF) is another common notation for writing rules that define the syntax of a language, which means the same thing.  (There are several variants of the BNF. I forgot which one I use here.) The rule set is called grammar. <br><br><pre> Arith :: = integer
 Arith :: = "-" Arith
 Arith :: = Arith "+" Arith
 Arith :: = "(" Arith ")"
</pre><br>  A vertical bar (meaning ‚Äúor‚Äù) is often used to make the syntax more concise. <br><br>  Arith :: = integer |  "-" Arith |  Arith "+" Arith |  "(" Arith ")" <br><br>  In TNT, we use a peculiar variant of the BNF, which replaces the name of the language being defined, in this case Arith, with a variable that is used to walk through the Arith elements.  Now suppose we use the variable i as a placeholder for integers and e as a placeholder for Arith elements.  Then we can write our grammar like this: <br><br><pre>  e :: = i ‚à£ ‚àíe ‚à£ e + e </pre><br>  Notice that I omitted the brackets.  As a rule, it is clear that brackets are allowed in any language.  The concept of output coincides with the parse tree.  They both demonstrate why a particular element is included in the set. <br><br><h3>  Operational semantics </h3><br>  To describe a language is to describe what will happen when a program is launched in this language.  That is what operational semantics does.  In the case of Arith, we need to specify an integer result for each program.  As mentioned above, we can use relationships to display input data on the result.  And we usually do this in TNG.  There are several different styles of relationships.  The first, which we consider, is the semantics of a big step (big-step semantics), which displays the program directly on its result. <br><br><h4>  Big-step semantics </h4><br>  Define an Eval relation that maps Arith elements to integers.  For example, the condition (- (2 + ‚àí5), 3) ‚àà Eval should be satisfied.  This relationship will be infinite (because there are an infinite number of programs on Arith).  Again, we will use the rule set to define Eval.  But before we begin, we introduce the abbreviation: <img src="https://habrastorage.org/files/32e/419/3ba/32e4193ba30b4e6ebe0582fcae2218b5.png">  means (e, i) ‚àà Eval.  Below we describe the rules defining Eval using horizontal bar notation.  To make sure that we don‚Äôt miss a single program, we will create one rule for each Arith syntax rule (there are three of them).  We will say that the rules are syntactically-oriented, when one rule corresponds to each syntactic rule of a language. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee1/64a/a35/ee164aa3559e30a6ff20f8d9c7e6b584.png" alt="\ frac {} {i \ Downarrow i} \ qquad \ frac {e \ Downarrow i \ quad j = -i} {\ mathtt {-} e \ Downarrow j} \ qquad \ frac {e_1 \ Downarrow i \ quad e_2 \ Downarrow j \ quad k = i + j} {e_1 \ mathtt {+} e_2 \ Downarrow k}" width="386" height="47"></div><br>  This may seem a little odd, that I defined "-" in terms of "-" and "+" in terms of "+".  Is this a cyclical dependency?  The answer is no.  Plus and minus are the usual arithmetic operations for the integers each pass in the school.  In this sense, it would be more strange for Arith not to use 32 or 64-bit arithmetic.  A programmer implementing Arith could use the package to work with BigInteger to handle arithmetic. <br><br><h4>  Small-step semantics semantics </h4><br>  The second and most common style of operational semantics is the semantics of a small step.  In this style the relation does not display the program on its result.  Instead, it maps the program to a slightly simplified program, in which some subexpression is replaced by its result.  You can think of this style as a text replacement.  To give an example of this style, we define the step relation.  This relationship will contain the following elements, like many others: <br><br><pre> (- (2 + -5), - (- 3)) ‚àà Step
         (- (- 3), 3) ‚àà Step
</pre><br>  Enter the abbreviation again: <img src="https://habrastorage.org/files/b8f/036/8df/b8f0368df7e64910bf1ebd7603aee208.png">  means (e1, e2) ‚àà Step.  And if we put the steps together, then <img src="https://habrastorage.org/files/4e8/4eb/3f5/4e84eb3f5de143a892ce201f46d3a34b.png">  will mean <img src="https://habrastorage.org/files/b8f/036/8df/b8f0368df7e64910bf1ebd7603aee208.png">  and <img src="https://habrastorage.org/files/554/ec1/ea6/554ec1ea6878417781c86ad83e470e7d.png">  .  The synonym for a step is the term ‚Äúreduce‚Äù (reduce).  The previous two-step example can now be written like this: <br><br><img src="https://habrastorage.org/files/65c/fa9/e10/65cfa9e107164628a2f3541af99782ce.png"><br><br>  We now turn to the rules governing the relation Step.  Here are five rules that we will explain below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a72/c78/416/a72c784165e744663f825b7c38e0e676.png" alt="\ begin {gather *} (1) \ frac {j = -i} {\ mathtt {-} i \ longrightarrow j} \ qquad (2) \ frac {k = i + j} {i \ mathtt {+} j \ longrightarrow k} \\ [3ex] (3) \ frac {e \ longrightarrow e '} {\ mathtt {-} e \ longrightarrow \ mathtt {-} e'} \ qquad (4) \ frac {e_1 \ longrightarrow e '_1} {e_1 \ mathtt {+} e_2 \ longrightarrow e'_1 \ mathtt {+} e_2} \ qquad (5) \ frac {e_2 \ longrightarrow e'_2} {i \ mathtt {+} e_2 \ longrightarrow i \ mathtt {+} e'_2} \ end {gather *}"></div><br>  The rules (1) and (2) are the most interesting.  They perform arithmetic.  We call them the ‚Äúcomputational reduction rules‚Äù.  Rules (3-5) allow us to go into subexpressions to perform calculations.  They are often referred to as congruence rules for reasons we will not go into now.  Using the variable i in rule (5) means that the reduction occurs from left to right.  In particular, we do not allow shortening the right expression from the + sign until the left expression is reduced to an integer. <br><br>  <b>Digression:</b> The left-to-right order I considered here was chosen as a language designer.  I could not define the order, allowing it to be vague.  Our language has no side effects, so the order does not matter.  However, most languages ‚Äã‚Äãhave side effects and they determine the order (but not all), so I thought that we should consider an example of how the order usually determines. <br><br>  Time for an example.  Let's look at the conclusion for the step: <img src="https://habrastorage.org/files/648/ed0/f5a/648ed0f5a08f4432b0e0d1ddae38f7b1.png"><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05a/d9d/84c/05ad9d84c8c08d3341c79e6c64834603.png" alt="(3) \ begin {array} {c} (2) \ begin {array} {c} \\\ hline \ mathtt {2 + -5} \; \ longrightarrow \; \ mathtt {-3} \ end {array} \\\ hline \ mathtt {- (2 + -5)} \; \ longrightarrow \; \ mathtt {- (- 3)} \ end {array}" width="219" height="49"></div><br>  We have defined one calculation step, i.e.  Step relationship.  But we are not completely finished.  We still have to define what it means to execute the program before completion.  We do this by defining Eval 'in terms of the Step relationship.  In other words, the relation Eval 'will contain any pairs (e, i) if the expression e is reduced to integer i in zero or more steps.  There is a new notation here, which is explained further. <br><br><img src="https://habrastorage.org/files/abc/d26/3a8/abcd263a826e4a55a8fb99139ef7f1aa.png"><br><br>  The notation {... ‚à£ ...} defines a set constructor.  The expression to the left of the vertical bar defines the pattern for a typical set element and the expression to the right defines the restrictions on the set elements.  Notation <img src="https://habrastorage.org/files/502/2a4/038/5022a403875b41379d62254200165974.png">  means zero or more steps.  I would define these multi-step relationships using the rules: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c3/c33/7b4/7c3c337b4a245c2129c0b72596cac490.png" alt="\ frac {} {e \ longrightarrow ^ {*} e} \ qquad \ frac {e_1 \ longrightarrow e_2 \ quad e_2 \ longrightarrow ^ {*} e_3} {e_1 \ longrightarrow ^ {*} e_3}" width="287" height="46"></div><br>  (I think of it in terms of Lisp-like lists. So, the first rule is nil, and the second cons.) <br><br><h3>  Type systems (with lambda calculus as an example) </h3><br>  Many programming languages ‚Äã‚Äãare statically typed, i.e.  the compiler performs some validation checks before performing the actual compilation.  Usually, during testing, the compiler makes sure that objects are used as they should.  For example, that no one tries to use an integer as a function.  The way in which the language developer specifies which particular checks should be performed is to define a type system for the language.  Arith is so simple that there are no interesting type checks in it.  Consider a more complex language that is used again and again in the TNG - lambda calculus (technically, lambda calculus with simplified typing).  Lambda calculus consists only of anonymous functions.  We will expand lambda calculus so that it includes our arithmetic expressions.  Then our language will be defined by the following grammar. <br><br><pre>  e :: = i ‚à£ ‚àíe ‚à£ e + e ‚à£ x ‚à£ ee ‚à£ Œªx: Te </pre><br>  The variable x lists parameter names, such as foo and g.  The next two expressions (ee) to the right indicate the use of a function (or function call).  If you are familiar with the C language, you can read e1 e2 as e1 (e2).  In lambda calculus, functions take only one parameter, so a function call requires only one argument.  The syntax Œªx: Te creates a function with one parameter x of type T (we will soon define the types) and a body consisting of the expression e.  (Often people are mistaken in thinking that x is the name of a function. In fact, this is the name of the parameter, since functions are anonymous, that is, they do not have a name.) The return value of the function is the result of the expression e.  Now we will think about what objects will exist during the execution of the program.  These are integers and functions.  We will create a set of types to describe the types of objects, using T to enumerate the set of types. <br><br><img src="https://habrastorage.org/files/ef7/83f/686/ef783f6868c449e58d33528b98c65add.png"><br><br>  In functional type <img src="https://habrastorage.org/files/8d1/9c0/307/8d19c03079a7452d8f57157fd0d6c849.png">  , T <sub>1</sub> is the parameter type, and T <sub>2 is</sub> the return type. <br>  The work of the type system is to predict what type of value the expression result will have.  For example, the expression - (5 + 2) must be of type Int, because the result - (5 + 2) is the number -3, which is an integer.  As in the case of syntax definition or operational semantics of a language, TNT theorist uses relationships and rules to define a type system.  We define the WellTyped relationship, which, as a first approximation, maps expressions to types.  For example, it will hold (- (5 + 2), Int) ‚àà WellTyped. <br>  However, since  The lambda calculus includes variables, we need some kind of analogue of the symbol table, a relationship, called a type environment, to keep track of which variables are of which type.  The Greek letter Œì (gamma) is commonly used for this purpose.  We must be able to create new types of environments from the old, with the ability to hide variables from external scopes.  To determine the mathematical apparatus for these possibilities, we assume that Œì ‚àñ x is a relation the same as Œì, except that any tuple starting with x will be excluded.  (Depending on the way the type system is defined, there can be a 0 or 1 tuple that starts with x, making the type environment a special kind of relation called a partial function.) We will write Œì, x: T for the operation Extending the type environment with the x variable, possibly overriding the previous definition, and defined as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb1/379/5ae/bb13795ae3a3887725ed8fb72874cdd8.png" alt="\ Gamma, x {:} T = (\ Gamma \ backslash x) \ cup \ {(x, T) \}" width="200" height="18"></div><br>  Let's pretend that <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/e99/cbb/1e5e99cbbcb9ff93fd0d939053a757ee.png" alt="\ Gamma_1 = \ {(\ mathtt {foo}, \ mathtt {Int}), (\ mathtt {g}, \ mathtt {Int} \ to \ mathtt {Int}) \}" width="274" height="19"></div><br>  Then <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/8fe/0f3/1818fe0f33c6f856a7bad6627d3105f5.png" alt="\ begin {align *} \ Gamma_1, \ mathtt {g} {:} \ mathtt {Int} &amp; = \ {(\ mathtt {foo}, \ mathtt {Int}), (\ mathtt {g}, \ mathtt { Int}) \} \\ \ Gamma_1, \ mathtt {f} {:} (\ mathtt {Int} {\ to} \ mathtt {Int}) {\ to} \ mathtt {Int} &amp; = \ {(\ mathtt {foo}, \ mathtt {Int}), (\ mathtt {g}, \ mathtt {Int} {\ to} \ mathtt {Int}), (\ mathtt {f}, (\ mathtt {Int} {\ to } \ mathtt {Int}) {\ to} \ mathtt {Int}) \} \ end {align *}"></div><br>  The type environment differs from the global symbol table in the compiler in that there can be more than one type environment, one for each scope.  In addition, we do not update the type environment; instead, we create a new environment that is slightly different from the old one.  From a programming point of view, the mathematical meta language that we use here is pure functional, i.e.  It contains no side effects.  The reader may worry that this leads to inefficiency, but remember that we are not writing a program here, we are writing a specification!  The greatest value for us is understandable.  And staying clean we can write more understandable things. <br>  Returning to the WellTyped relation, instead of containing tuples of two elements (2-tuples, pairs), it will contain tuples of three elements (3-tuples, triples) of the form (Œì, e, T).  Thus, we will attribute types to expressions in the context of a type environment.  We introduce one more abbreviation (TNT theorists love abbreviations!).  Will write <img src="https://habrastorage.org/files/91e/77e/9a7/91e77e9a7bd34dc8bf915c033ee4c79c.png">  instead of (Œì, e, T) ‚àà WellTyped.  Now we are ready to list the rules that define WellTyped. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/491/925/cc3/491925cc3120afcc0dcce1e0829ca1d3.png" alt="\ begin {gather *} \ frac {} {\ Gamma \ vdash i: \ mathtt {Int}} \ qquad \ frac {\ Gamma \ vdash e: \ mathtt {Int}} {\ Gamma \ vdash \ mathtt {-} e: \ mathtt {Int}} \ qquad \ frac {\ Gamma \ vdash e_1: \ mathtt {Int} \ quad \ Gamma \ vdash e_2: \ mathtt {Int}} {\ Gamma \ vdash e_1 \ mathtt {+} e_2 : \ mathtt {Int}} \\ [3ex] \ frac {(x, T) \ in \ Gamma} {\ Gamma \ vdash x: T} \ qquad \ frac {\ Gamma, x {:} T_1 \ vdash e : T_2} {\ Gamma \ vdash (\ lambda x {:} T_1. E): (T_1 \ to T_2)} \ qquad \ frac {\ Gamma \ vdash e_1: T \ to T '\ quad \ Gamma \ vdash e_2 : T} {\ Gamma \ vdash e_1 \, e_2: T '} \ end {gather *}"></div><br>  Let's summarize for the rules above.  Arithmetic operators work with integers.  Variables get their types from the environment.  Lambdas are functional types based on the type of their parameter and the output type of the result.  The body of the lambda is checked using the lexical scoping environment, extended with the parameter of this lambda.  And the use of the function does not violate the logic of the language as long as the type of the argument coincides with the type of the parameter. <br><br><h3>  Conclusion </h3><br>  This concludes this accelerated course on notations used in the theory of programming languages.  This post only describes the basics, but a lot of additional notations that you will need are variations discussed here.  Happy reading and feel free to ask questions in the comments. </div><p>Source: <a href="https://habr.com/ru/post/263951/">https://habr.com/ru/post/263951/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263935/index.html">Familiarity with the internal structure of the .NET Framework. Let's see how the CLR creates objects.</a></li>
<li><a href="../263939/index.html">How we spent a couple of days working on Perl acceleration</a></li>
<li><a href="../263943/index.html">Channel Status Protocols and Single-Zone OSPF (Part 1)</a></li>
<li><a href="../263945/index.html">The story of one clone</a></li>
<li><a href="../263947/index.html">Visualization of static and dynamic networks on R, part 2</a></li>
<li><a href="../263953/index.html">Visualization of static and dynamic networks on R, part 3</a></li>
<li><a href="../263957/index.html">The first Lean Poker tournament in Russia was held in Omsk</a></li>
<li><a href="../263959/index.html">Clear the code with free monads</a></li>
<li><a href="../263961/index.html">Scholarship government programs around the world. Part 1</a></li>
<li><a href="../263963/index.html">Multifactorial LastPass</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>