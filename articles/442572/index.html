<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using the Datapath Config Tool</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have to take the penultimate step in the practical development of working with UDB. Today we will be developing not using the automated UDB Editor,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using the Datapath Config Tool</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/fu/yo/23/fuyo230rbfhla_li8ryzzngttlw.jpeg"><br><br>  We have to take the penultimate step in the practical development of working with UDB.  Today we will be developing not using the automated UDB Editor, but in the semi-manual mode, using the Datapath Config Tool.  A very good tool for mastering this tool is AN82156 - PSoC 3, PSoC 4, and PSoC 5LP - Designing PSoC Creator Components with UDB Datapaths.  Actually, I myself learned from it. <br><a name="habracut"></a><br>  Perhaps, while reading our <a href="https://habr.com/ru/post/438818/">translations of the documentation on UDB</a> , someone tried to reproduce the knowledge from there in practice and noticed that not all the functionality described in the publications is available in the UDB Editor.  This is due to the fact that the developers did not place some particularly cumbersome mechanisms in the UDB Editor.  The authors of AN82156 claim that it‚Äôs impossible to do the following things through the UDB Editor: <br><br><ul><li>  organize parallel input and output data; </li><li>  organize dynamic FIFO management; </li><li>  realize the inverse of the clock signal FIFO; </li><li>  implement the CRC function; </li><li>  implement the PRS function; </li><li>  implement the selection of the incoming transfer; </li><li>  implement dynamic inbound transfer. </li></ul><br>  From myself, I add that I did not find how to implement a permutation of nibbles in the UDB Editor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If these functions are needed in a project, you will need to create your own code in the Verilog language.  I specifically used the word "create", not "write."  It is enough to know this programming language at the reading level.  I mean, you need to understand what design is needed for what.  And to be able to write from scratch is always useful, but for this article, this skill is not mandatory. <br><br>  As a solvable problem, I chose the semi-synthetic case.  In general, I decided to bring some data to the parallel port, and in particular, from what is at hand, the parallel port is in the text LCD display.  I pulled it out three years ago from the MZ3D 3D printer when I transferred it to the STM32.  Therefore, the case is semi-synthetic: today, such indicators usually have I2C input, and they do not need to connect through a pile of wires in real life.  However, parallel ports for modern LCDs are also available, so everyone can use them to repeat the experiment. <br><br>  Consider the display enablement scheme taken from the reprap.org site (it was not easy, my provider blocks this site, as well as a number of other technical ones, arguing that he lives on the same IP with someone blocked). <br><br><img src="https://habrastorage.org/webt/0x/th/ry/0xthryzxadx_9guzmhdyhrxnzty.png"><br><br>  Great scheme!  First, I do not need to think about reading: the data in the LCD can only be written (the R / W line is grounded and not available on the connector).  Secondly, the data goes in a 4-bit format, which means that we can not only work out parallel output, but also check the operation of the nibbling permutation function. <br><br><h2>  Project creation </h2><br>  So, run PSoC Creator and select <b>File-&gt; New-&gt; Project</b> : <br><br><img src="https://habrastorage.org/webt/pv/ma/tv/pvmatvfviveyo4fa822osy45p2c.png"><br><br>  Next, I choose my breadboard: <br><br><img src="https://habrastorage.org/webt/dv/st/hi/dvsthib82j6ynrdxc0sk-5j20nk.png"><br><br>  Next is an empty diagram: <br><br><img src="https://habrastorage.org/webt/oi/fx/vv/oifxvvsf0qye7j-mdyoxmbfux4q.png"><br><br>  I will name the project <b>LCDTest2</b> : <br><br><img src="https://habrastorage.org/webt/qs/3f/rl/qs3frlgxrnzqzqrzzfryptvjfqq.png"><br><br>  Now, as before, go to the <b>Components</b> tab: <br><br><img src="https://habrastorage.org/webt/wq/nb/bo/wqnbboubijieyovk7akrat6piik.png"><br><br>  And, selecting the project, press the right mouse button, then select <b>Add Component Item</b> . <br><br><img src="https://habrastorage.org/webt/hi/fu/hv/hifuhvearnltnfz2dvmhwtzgw4o.png"><br><br>  And here it is necessary to choose the <b>Symbol Wizard</b> .  Give the name ... Well, let's say, <b>LCD4bit</b> . <br><br><img src="https://habrastorage.org/webt/59/f0/g3/59f0g3lya8ado4kcxgj6lcsxggk.png"><br><br>  I have assigned the following ports to the symbol: <br><br><img src="https://habrastorage.org/webt/6a/jr/uo/6ajruo1io2jusjunhameiumtb20.png"><br><br>  <b>clk</b> is the clock input.  Ports with an LCD prefix are standard LCD ports.  <b>hungry</b> - outputs that tell the DMA block that there is free space in the FIFO, the idea was considered in an article about <a href="https://habr.com/ru/post/429882/">controlling RGB LEDs</a> .  Click OK, we get the symbol. <br><br><img src="https://habrastorage.org/webt/ze/fq/5z/zefq5z65eq0i4mq21y2d3jip7t4.png"><br><br>  Now, based on this symbol, you should generate a Verilog template.  Click the right mouse button in the vicinity of the symbol and select <b>Generate Verilog</b> in the context menu. <br><br><img src="https://habrastorage.org/webt/h9/k7/oo/h9k7oogp_wqsdfugdg-8bdr_hru.png"><br><br>  We have a template shown in the figure below (in the text form, it still does not make any sense): <br><br><img src="https://habrastorage.org/webt/ax/t9/k-/axt9k-s-zfi2kfd7qdz9pe-zlqq.png"><br><br>  We have created a module and some sections.  But so far they have not created a Datapath.  To add it, go to the project tree, select the <b>LCD4bit.v</b> file, click the right mouse button and in the appeared context menu select the <b>Datapath Config Tool</b> : <br><br><img src="https://habrastorage.org/webt/z2/1g/5w/z21g5wom4_-yq_nmcjlhvb3irg0.png"><br><br>  A window opens in front of us, which I will show only partially: <br><br><img src="https://habrastorage.org/webt/m0/fz/9i/m0fz9idl6xt5rimcittxpme2iea.png"><br><br>  Please love and favor, editor Datapath.  It contains all the bits that were described in the translation of the company documentation.  But there are so many of these bits that in the early days I looked at him, but I was afraid to do anything.  I will look and see and come out.  And only after some time, having become accustomed, I began to try to do something.  Actually, that's why I brought only part of the window.  Why scare everyone ahead of time?  In the meantime, we just need to create a Datapath, so we select the menu item <b>Edit-&gt; New Datapath</b> : <br><br><img src="https://habrastorage.org/webt/-n/dx/vj/-ndxvjk_wrpdjucuq0_c3jcqfai.png"><br><br>  Which option to choose in the dialog that appears? <br><br><img src="https://habrastorage.org/webt/wf/ma/kf/wfmakfepho5l4h4nxffpua7wgok.png"><br><br>  The question is a bit more serious than it seems.  Let me even highlight the next paragraph, so that no one comes across (I got caught myself, and then I saw questions from the network that came across, and no one answered them properly, but the answer is in <b>AN82156</b> , you just need to read not diagonally, since there it is written short discreet phrase). <br><blockquote>  If you plan to work with parallel data, then you must choose the option CY_PSOC3_DP.  No other option will contain ports for connecting parallel data. </blockquote>  So.  Let the instance we have name LCD_DP: <br><br><img src="https://habrastorage.org/webt/tf/a3/hs/tfa3hsi-mu2ljvyeukwmprwlm_4.png"><br><br>  Click OK and for now close the <b>Datapath Config Tool</b> , agreeing to save the result.  We will come back here later. <br><br>  Our Verilog code has expanded.  Now it has a datapath.  The beginning is completely unreadable.  It's not scary, it is configured by the <b>Datapath Config Tool</b> . <br><br><img src="https://habrastorage.org/webt/tz/d9/ur/tzd9urfa66hsfic2w9gsn6tkysu.png"><br><br>  And we will rule the end of the description of Datapath.  Our site looks like this <div class="spoiler">  <b class="spoiler_title">(from this place it makes sense to bring everything in text form).</b> <div class="spoiler_text"><pre><code class="plaintext hljs">)) LCD_DP( /* input */ .reset(1'b0), /* input */ .clk(1'b0), /* input [02:00] */ .cs_addr(3'b0), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0), /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(), /* output */ .f0_blk_stat(), /* output */ .f1_bus_stat(), /* output */ .f1_blk_stat(), /* input */ .ci(1'b0), // Carry in from previous stage /* output */ .co(), // Carry out to next stage /* input */ .sir(1'b0), // Shift in from right side /* output */ .sor(), // Shift out to right side /* input */ .sil(1'b0), // Shift in from left side /* output */ .sol(), // Shift out to left side /* input */ .msbi(1'b0), // MSB chain in /* output */ .msbo(), // MSB chain out /* input [01:00] */ .cei(2'b0), // Compare equal in from prev stage /* output [01:00] */ .ceo(), // Compare equal out to next stage /* input [01:00] */ .cli(2'b0), // Compare less than in from prv stage /* output [01:00] */ .clo(), // Compare less than out to next stage /* input [01:00] */ .zi(2'b0), // Zero detect in from previous stage /* output [01:00] */ .zo(), // Zero detect out to next stage /* input [01:00] */ .fi(2'b0), // 0xFF detect in from previous stage /* output [01:00] */ .fo(), // 0xFF detect out to next stage /* input [01:00] */ .capi(2'b0), // Software capture from previous stage /* output [01:00] */ .capo(), // Software capture to next stage /* input */ .cfbi(1'b0), // CRC Feedback in from previous stage /* output */ .cfbo(), // CRC Feedback out to next stage /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po() // Parallel data port );</code> </pre> <br></div></div><br>  Fearfully?  Now we will understand what is what - will cease to be scary.  In fact, there are three distinct groups in this text.  Let's recall the translation of the documentation.  What did the datapath look like in the picture?  I will immediately mark in the figure the places to which the groups "1", "2" and "3" belong. <br><br><img src="https://habrastorage.org/webt/ji/xe/5x/jixe5x_fxqpx6kgybrjmakagpw4.png"><br><br>  Actually, the first group of ports in the verilog code is the inputs.  Compare the names at the output of the multiplexer of the inputs (‚Äú1‚Äù in the figure) and the names of the signals in the code. <br><br>  Now all inputs are zeroed.  We will need to connect a clock input and we will be able to forward up to six input lines, as we did in the UDB Editor.  These inputs are: <br><br><pre> <code class="plaintext hljs"> /* input */ .reset(1'b0), /* input */ .clk(1'b0), /* input [02:00] */ .cs_addr(3'b0), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0),</code> </pre><br>  The second group is exits.  The names in the code also coincide with the names of the inputs of the output multiplexer "2": <br><br><pre> <code class="plaintext hljs"> /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(), /* output */ .f0_blk_stat(), /* output */ .f1_bus_stat(), /* output */ .f1_blk_stat(),</code> </pre><br>  The third group is only for this type of Datapath (for the rest it is absent, therefore there are no parallel data).  These are internal Datapath signals, through which you can independently produce chaining or other useful actions.  The names in the code also coincide with the names of the internal signals scattered throughout the figure.  We through one of them (the last one in the list, his name is <b>po</b> ) will output parallel data directly to the legs of the chip. <br><br><pre> <code class="plaintext hljs"> /* input */ .ci(1'b0), // Carry in from previous stage /* output */ .co(), // Carry out to next stage /* input */ .sir(1'b0), // Shift in from right side /* output */ .sor(), // Shift out to right side /* input */ .sil(1'b0), // Shift in from left side /* output */ .sol(), // Shift out to left side /* input */ .msbi(1'b0), // MSB chain in /* output */ .msbo(), // MSB chain out /* input [01:00] */ .cei(2'b0), // Compare equal in from prev stage /* output [01:00] */ .ceo(), // Compare equal out to next stage /* input [01:00] */ .cli(2'b0), // Compare less than in from prv stage /* output [01:00] */ .clo(), // Compare less than out to next stage /* input [01:00] */ .zi(2'b0), // Zero detect in from previous stage /* output [01:00] */ .zo(), // Zero detect out to next stage /* input [01:00] */ .fi(2'b0), // 0xFF detect in from previous stage /* output [01:00] */ .fo(), // 0xFF detect out to next stage /* input [01:00] */ .capi(2'b0), // Software capture from previous stage /* output [01:00] */ .capo(), // Software capture to next stage /* input */ .cfbi(1'b0), // CRC Feedback in from previous stage /* output */ .cfbo(), // CRC Feedback out to next stage /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po() // Parallel data port );</code> </pre><br>  So.  As we work, we will have to connect part of these inputs and outputs to our own entities, and the rest will just be left in the form in which we created them. <br><br><h2>  Using UDB Editor as a reference </h2><br>  And here we got a blank, we know where and what we have to write.  It remains to understand what exactly we will enter there.  It so happened that I do not use Verilog every day, so I remember everything in general terms, and writing from scratch for me is always a stressful situation.  When the project is already underway - it all comes to mind, but if after a couple of months of inactivity start something from scratch, of course, I do not remember the details of the syntax of this particular language.  Therefore, I propose to ask the development environment to help us. <br><br>  UDB Editor for self-control builds Verilog code.  We take advantage of the fact that components that are not involved in the main circuit are not compiled, so we can easily create an auxiliary component in the UDB Editor, and it will not fall into the output code.  We will draw an automaton there, we will make a rough setup of the inputs and outputs of Datapath, and then simply transfer the automatically created text to our verilog module and creatively refine everything.  It's much easier than remembering the verilog syntax details and writing everything from scratch (although, who constantly use Verilog, it will of course be easier to write from scratch: creative refinement, as we will soon see, is simple, but requires time). <br><br>  So, we start to make an auxiliary component.  With a familiar hand movement we add a new element to the project: <br><br><img src="https://habrastorage.org/webt/to/d2/fg/tod2fgx1opcdho2edizges-vr3q.png"><br><br>  This will be a UDB document, let's call it <b>UDBhelper</b> : <br><br><img src="https://habrastorage.org/webt/j3/wt/iu/j3wtiuj2htdr-ct4f7m_3z497oi.png"><br><br>  It's time to think about the machine, which we place on the created sheet.  To do this, we need to consider what kind of time diagram we need to form with it: <br><br><img src="https://habrastorage.org/webt/rh/zj/da/rhzjdasl8ioia8n8okjuuaieft4.png"><br><br><img src="https://habrastorage.org/webt/dy/3a/0z/dy3a0zmkacoa4tvgaugebovdhqy.png"><br><br>  So.  You must first set the RS signal (since R / W is soldered to zero by hardware).  Next, you should wait for tAS, then raise the signal E and set the data (setting data on the positive edge E is not limited).  The data must be on the bus no less than tDSW, after which the signal E should be dropped. The data must remain on the bus for at least tDHW and the RS at least tAH. <br><br>  RS is a ‚Äúcommand or data‚Äù flag.  If RS is zero, then the command is written, if the unit is data. <br><br>  I suggest sending commands via <b>FIFO0</b> , and <b>sending</b> data through <b>FIFO1</b> .  In the context of the current task, this does not contradict anything.  Then the state machine proposed by me will have the following form: <br><br><img src="https://habrastorage.org/webt/jn/6y/6j/jn6y6jnzllwbwgmslak7nif1xmu.png"><br><br>  In the <b>Idle</b> state, the machine is in as long as none of the FIFOs have data.  If there is data in <b>FIFO0</b> , it goes to the state <b>LoadF0</b> , where in the future it will receive data from <b>FIFO0</b> to A0. <br><br>  While the commands are being transmitted, the data should not be sent.  Therefore, the condition for receiving data will be lower in priority than the condition for receiving commands. <br><br><img src="https://habrastorage.org/webt/og/gn/fl/oggnfl3tcjcxa8pzu64qcj3yzpa.png"><br><br>  Data is received in A1 in the <b>LoadF1</b> state (from <b>FIFO1,</b> it can only get into register A1 and cannot get into register A0), and then copied from A1 to A0 in state <b>A1toA0</b> . <br><br>  Whatever way we go to the location of the arrows, we have data in A0.  They are already output to the parallel port.  We cock E (in the <b>E_UP1</b> state), we drop E (in the <b>E_DOWN1</b> state).  Next, we will have a state for exchanging nibbles ( <b>SWAP</b> ), after which E rises again ( <b>E_UP2</b> ).  With this I have exhausted eight states that can be encoded with three bits.  And we remember that the Datapath dynamic configuration RAM has only three address inputs.  One could apply some tricks, but the article and so it turns out great.  Therefore, just the second time E will be dropped in the <b>Idle</b> state.  Then eight states will be enough for us. <br><br>  On the sheet we also put the Datapath and assign its inputs and outputs in the way already familiar from the previous articles.  Here are the inputs: <br><br><img src="https://habrastorage.org/webt/ct/fn/0j/ctfn0jvexwfycfrdovbnatwv7ze.png"><br><br>  Here are the outputs: <br><br><img src="https://habrastorage.org/webt/ct/mj/gd/ctmjgdzfvx-mz8qnzwbp6undlau.png"><br><br>  Nothing new, everything has already been described in previous articles of the cycle.  So, we have a blank, on the basis of which we can make something of our own.  However, to make sure that everything is going, we need to bring our system to the top level of the project, otherwise there will be no errors.  And with the primary experiences without errors will not work.  Therefore, we will do another auxiliary action. <br><br>  The description of how the scheme is made goes beyond the description of working with UDB.  I'll just show you what scheme I got.  There is only one DMA block: when sending commands to the LCD, it is necessary to withstand long pauses, so it is still easier to do this programmatically.  For other applications, you can simply put the second DMA block by analogy, using the signal <b>hungry0</b> . <br><br><img src="https://habrastorage.org/webt/mz/zd/g8/mzzdg80tinx_ffjjigxypmehj0w.png"><br><br>  In order to accurately meet the time frame, I chose a clock frequency equal to one megahertz.  It would be possible to take the frequency and higher, but the data is transmitted over long wires in conditions of high interference, so the time to install the data before and after the gate is better to take with a margin.  If someone repeats my experiments on the same breadboard - do not use port P3.2: a capacitor is soldered on the board to this leg.  I killed half an hour, until I found out why the impulse E, which I first connected there, is not forming.  I threw it on P3.1 - everything worked right away.  My data bus goes to P3.7-P3.4, RS goes to P3.3, so E initially went to P3.2 ... <br><br>  Here you go.  Now, if you try to compile the project, we get quite predictable errors <br><br><img src="https://habrastorage.org/webt/az/tm/fb/aztmfbvzsl52ghanjovqpva5_7o.png"><br><br>  So the system is trying to collect something.  But she has nothing to collect yet.  We start copying the code.  To do this, in the UDB Editor, switch to the Verilog tab (this tab is located below the window with the UDB Editor sheet): <br><br><img src="https://habrastorage.org/webt/kg/tk/fy/kgtkfyn1tssdt4-cjydawzl7vnw.png"><br><br>  What is there familiar?  At the very end of the text is the body of the machine.  Let's start the transfer from it. <br><br><div class="spoiler">  <b class="spoiler_title">Also place it under the datapath:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== State Machine: SM ==================== */ always @ (posedge clock) begin : Idle_state_logic case(SM) Idle : begin if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; end end LoadF0 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Up1 ; end end E_Up1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Down1 ; end end E_Down1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= SWAP ; end end SWAP : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_UP2 ; end end E_UP2 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= Idle ; end end LoadF1 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= A1toA0 ; end end A1toA0 : begin if (( 1'b1 ) == 1'b1) begin SM &lt;= E_Up1 ; end end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  On top of this code are declarations (names for states, chains for Datapath, a register encoding the state of the machine).  We transfer them to the appropriate <div class="spoiler">  <b class="spoiler_title">section of our code:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== Wire and Register Declarations ==================== */ localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111; wire hungry0; wire F0empty; wire hungry1; wire F1empty; wire Datapath_1_d0_load; wire Datapath_1_d1_load; wire Datapath_1_f0_load; wire Datapath_1_f1_load; wire Datapath_1_route_si; wire Datapath_1_route_ci; wire [2:0] Datapath_1_select; reg [2:0] SM;</code> </pre><br></div></div><br>  Well <br><br><div class="spoiler">  <b class="spoiler_title">signal binding site is transferable:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">/* ==================== Assignment of Combinatorial Variables ==================== */ assign Datapath_1_d0_load = (1'b0); assign Datapath_1_d1_load = (1'b0); assign Datapath_1_f0_load = (1'b0); assign Datapath_1_f1_load = (1'b0); assign Datapath_1_route_si = (1'b0); assign Datapath_1_route_ci = (1'b0); assign Datapath_1_select[0] = (SM[0]); assign Datapath_1_select[1] = (SM[1]); assign Datapath_1_select[2] = (SM[2]);</code> </pre><br></div></div><br>  It's time to connect the Datapath.  The code transferred from the UDB Editor is good for machine editing, but not very good for manual editing.  Circuits are created there that are connected at one end to the inputs of the Datapath, and the other to the constants.  But in the code created by the <b>Datapath Configuration Tool</b> (which does everything for manual work), all inputs are already connected to zero constants directly.  So I will connect only those lines that are not constants, but I will cut everything that relates to forwarding of constants from the transferred text.  The connection turned out this way (the places that I edited relative to the automatically created in the Datapath Configuration Tool are highlighted in color): <br><br><img src="https://habrastorage.org/webt/-3/gk/fd/-3gkfd3bhnnc7wygbr6wpqoscyo.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">)) LCD_DP( /* input */ .reset(1'b0), /* input */ .clk(clk), /* input [02:00] */ .cs_addr(SM), /* input */ .route_si(1'b0), /* input */ .route_ci(1'b0), /* input */ .f0_load(1'b0), /* input */ .f1_load(1'b0), /* input */ .d0_load(1'b0), /* input */ .d1_load(1'b0), /* output */ .ce0(), /* output */ .cl0(), /* output */ .z0(), /* output */ .ff0(), /* output */ .ce1(), /* output */ .cl1(), /* output */ .z1(), /* output */ .ff1(), /* output */ .ov_msb(), /* output */ .co_msb(), /* output */ .cmsb(), /* output */ .so(), /* output */ .f0_bus_stat(hungry0), /* output */ .f0_blk_stat(F0empty), /* output */ .f1_bus_stat(hungry1), /* output */ .f1_blk_stat(F1empty),</code> </pre><br></div></div><br>  Parallel data is a bit more complicated.  Datapath has an eight-bit port, and only four of them need to be brought out.  Therefore, we start the auxiliary circuit and connect only its half to the output: <br><br><pre> <code class="plaintext hljs">wire [7:0] tempBus; assign LCD_D = tempBus[7:4];</code> </pre><br>  And we connect everything like this: <br><br><img src="https://habrastorage.org/webt/km/aq/_a/kmaq_abi2kkprp406kne413j5u0.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> /* input [07:00] */ .pi(8'b0), // Parallel data port /* output [07:00] */ .po( tempBus) // Parallel data port );</code> </pre><br></div></div><br>  We try to build (Shift + F6 or through the menu item <b>Build-&gt; Generate Application</b> ).  We get the error: <br><br><img src="https://habrastorage.org/webt/kw/ox/as/kwoxasreij4-snkxyvc63iqozxq.png"><br><br>  We have ports <b>hungry0</b> and <b>hungry1</b> (appeared when creating a component), as well as chains of the same name (appeared when dragging from a sample).  Simply remove these circuits (leaving the ports).  And somewhere the <b>clock</b> signal leaked, and here this chain is called <b>clk</b> . <br><br>  After removing all the extra circuits (those that initially sent zero constants to the inputs of Datapath, as well as <b>hungry0</b> and <b>hungry1</b> ), we get the code for the beginning of our file: <br><br><pre> <code class="plaintext hljs">// Your code goes here /* ==================== Wire and Register Declarations ==================== */ localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111; wire F0empty; wire F1empty; reg [2:0] SM; /* ==================== Assignment of Combinatorial Variables ==================== */ wire [7:0] tempBus; assign LCD_D = tempBus[7:4];</code> </pre><br>  And when replacing <b>clock</b> with <b>clk</b> in the body of the machine, I will also throw out all the lines that are good for autogeneration, but for manual editing, they only create confusion (all comparisons that give an <b>TRUE</b> absolute result, etc.).  In particular, in the example below, about half of the lines can be crossed out (and some <b>begin / end</b> are optional, sometimes they will be needed, because we will add actions, I highlighted them in color): <br><br><img src="https://habrastorage.org/webt/9s/e9/t1/9se9t15zkc1hux1qrpga3jbh7cm.png"><br><br>  After combing by the above principle (and replacing <b>clock</b> with <b>clk</b> ), such a body remains <br><br><div class="spoiler">  <b class="spoiler_title">(it has become shorter, which means it is easier to read):</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">always @ (posedge clk) begin : Idle_state_logic case(SM) Idle : begin if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; end end LoadF0 : begin SM &lt;= E_Up1 ; end E_Up1 : begin SM &lt;= E_Down1 ; end E_Down1 : begin SM &lt;= SWAP ; end SWAP : begin SM &lt;= E_UP2 ; end E_UP2 : begin SM &lt;= Idle ; end LoadF1 : begin SM &lt;= A1toA0 ; end A1toA0 : begin SM &lt;= E_Up1 ; end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  Now we are told during compilation that the <b>LCD_E</b> and <b>LCD_RS circuits are</b> not connected. <br><br>  Actually, this is true: <br><br><img src="https://habrastorage.org/webt/cz/da/h7/czdah7nfkzmou2mr8-omzs_-hby.png"><br><br>  It's time to add a finite state machine action.  Let's replace the declarations of the corresponding non-connected port chains with <b>reg</b> , since we will write them in the body of the machine (this is the syntax of the Verilog language, if we write, the data must click, it needs a trigger, and it is given by the keyword <b>reg</b> ): <br><br><img src="https://habrastorage.org/webt/l5/vq/uj/l5vqujn7yirpf4dkorxzevy9ij4.png"><br><div class="spoiler">  <b class="spoiler_title">Same text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module LCD4bit ( output hungry0, output hungry1, output [3:0] LCD_D, output reg LCD_E, output reg LCD_RS, input clk );</code> </pre><br></div></div><br>  And fill the machine actions.  I have already spoken logic above when I looked at the transition graph of the automaton, so I will show only the result: <br><br><img src="https://habrastorage.org/webt/ij/t1/5i/ijt15itzdfznooyvlgz0sjlk5t4.png"><br><div class="spoiler">  <b class="spoiler_title">Same text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">always @ (posedge clk) begin : Idle_state_logic case(SM) Idle : begin LCD_E &lt;= 0; if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; LCD_RS &lt;= 0; end else if (( !F1empty ) == 1'b1) begin SM &lt;= LoadF1 ; LCD_RS &lt;= 1; end end LoadF0 : begin SM &lt;= E_Up1 ; end E_Up1 : begin SM &lt;= E_Down1 ; LCD_E &lt;= 1'b1; end E_Down1 : begin SM &lt;= SWAP ; LCD_E &lt;= 1'b0; end SWAP : begin SM &lt;= E_UP2 ; end E_UP2 : begin SM &lt;= Idle ; LCD_E &lt;= 1; end LoadF1 : begin SM &lt;= A1toA0 ; end A1toA0 : begin SM &lt;= E_Up1 ; end default : begin SM &lt;= Idle; end endcase end</code> </pre><br></div></div><br>  From this moment on, the project begins to be built.  But he will not work yet.  So far, I famously said: ‚ÄúIn this state, we will load the register from the FIFO‚Äù, ‚ÄúThis will copy A1 into A0‚Äù, ‚ÄúThis will rearrange nibbles‚Äù.  In general, I said a lot, but there was no action yet.  It's time to execute them.  We look, as at us states were coded: <br><br><pre> <code class="plaintext hljs">localparam [2:0] Idle = 3'b000; localparam [2:0] LoadF0 = 3'b001; localparam [2:0] LoadF1 = 3'b010; localparam [2:0] E_Up1 = 3'b100; localparam [2:0] A1toA0 = 3'b011; localparam [2:0] E_Down1 = 3'b101; localparam [2:0] SWAP = 3'b110; localparam [2:0] E_UP2 = 3'b111;</code> </pre><br>  <b>Reopen the Datapath Configuration Tool</b> : <br><br><img src="https://habrastorage.org/webt/eh/oh/sz/ehohszogw7vzyiup9cjumf4b3ii.png"><br><br>  And we begin to edit the lines <b>CFGRAM</b> .  When editing, keep the Datapath diagram in front of your eyes, namely: <br><br><img src="https://habrastorage.org/webt/cz/xr/vu/czxrvuaul7vkqilrqinrgzpu1fy.png"><br><br>  The red frames in the figure below (and the arrows in the figure above) highlighted the corrected sections (and the data path) for the <b>LoadF0</b> state (code 001, that is, <b>Reg1</b> ).  I also entered the comments manually.  The contents of F0 should go to A0. <br><br><img src="https://habrastorage.org/webt/4z/zv/kh/4zzvkhchg55gnp-39oag_d-bkt8.png"><br><br>  With green frames and arrows, I marked the settings and the path for the state of LoadF1 (code 010 - <b>Reg2</b> ). <br><br>  With blue frames and arrows, I marked the settings and the path for the state A1toA0 (code 011 - <b>Reg3</b> ). <br><br>  With purple frames and arrows, I marked the settings and the path for the SWAP state (code 110 - <b>Reg6</b> ). <br><br>  Finally, the orange arrows indicate the parallel data path.  And no action is taken for them.  They always come out of the <b>SRCA</b> .  We almost always have A0 selected as the <b>SRCA</b> : the data comes out of A0.  Here, to redirect input data, we would have to perform a lot of auxiliary actions, but we don‚Äôt accept any data, so here we don‚Äôt need these actions, and everyone will find their list in <b>AN82156</b> .  Also, we do not need to edit any static Datapath settings, so we close the <b>Datapath Config Tool</b> . <br><br>  Everything.  The conceived hardware is complete.  Getting to the development of C code.  To do this, go to the <b>Source</b> tab and edit the file main.c. <br><br><img src="https://habrastorage.org/webt/fp/ia/7s/fpia7s4zyzaxy8mzmqxktib-obw.png"><br><br>  The standard initialization of the LCD and the output of the ‚ÄúABC‚Äù characters look like this (remember, the commands go to <b>FIFO0</b> , the documentation requires inserting pauses between commands, and the data goes to <b>FIFO1</b> , I didn‚Äôt find anything between the data pauses): <br><br><pre> <code class="plaintext hljs"> volatile uint8_t* pFIFO0 = (uint8_t*) LCD4bit_1_LCD_DP__F0_REG; volatile uint8_t* pFIFO1 = (uint8_t*) LCD4bit_1_LCD_DP__F1_REG; pFIFO0[0] = 0x33; CyDelay (5); pFIFO0[0] = 0x33; CyDelay (100); pFIFO0[0] = 0x33; CyDelay (5); pFIFO0[0] = 0x20; CyDelay (5); pFIFO0[0] = 0x0C; //   CyDelay (50); pFIFO0[0] = 0x01; //   CyDelay (50); pFIFO1[0] = 'A'; pFIFO1[0] = 'B'; pFIFO1[0] = 'C';</code> </pre><br>  What?  Why is there only the first character on the screen? <br><br><img src="https://habrastorage.org/webt/3g/tq/sr/3gtqsrr050bqbhaqi2ke9g1pg0w.png"><br><br>  And if you add delays between the output, everything is fine: <br><br><img src="https://habrastorage.org/webt/3b/he/2a/3bhe2a1_ioou2gktkqfzydumrne.png"><br><br>  Oscilloscope for such work is not enough channels.  We check the work on the logic analyzer.  The process of recording data is as follows. <br><br><img src="https://habrastorage.org/webt/yr/y_/_j/yry__jhgasihbzmmrrr2cnsylaq.png"><br><br>  All data is in place (three pairs of parcels).  Time to install and snap data is allocated in sufficient volume.  In general, in terms of time diagrams - everything is done right.  The scientific problem is solved, the desired time diagrams are formed.  Here is engineering - no.  Blame it all - the slowness of the processor installed in the LCD.  Between bytes, you need to add delays. <br><br>  We will form delays using a seven-bit counter, at the same time we will practice adding it to such a system.  Let we will be in the Idle state not less than a certain specified time, and the seven-bit counter will measure us this time.  Again, we will not write, but create code.  Therefore, we again go to the auxiliary component of the UDB Editor and add a counter to the sheet, adjusting its parameters as follows: <br><br><img src="https://habrastorage.org/webt/gq/8c/qw/gq8cqwl0liu7mv9gpgm8-wngom0.png"><br><br>  This counter will always work ( <b>Enable is set</b> to 1).  But it will be loaded when the machine is in the <b>E_UP2</b> state (after which we immediately fall into the <b>Idle</b> state).  The line <b>Count7_1_tc will be</b> set to 1 when the counter counts to zero, which we will make an additional condition for exiting the <b>Idle</b> state.  The figure also contains the period value, but we will not find it in the Verilog code.  It will have to be entered into the C code.  But first we transfer the automatically generated Verilog code by switching to the Verilog tab.  First of all, the counter should be connected (we see this code at the beginning of the file and move it to the beginning too): <br><br><pre> <code class="plaintext hljs">`define CY_BLK_DIR "$CYPRESS_DIR\..\psoc\content\CyComponentLibrary\CyComponentLibrary.cylib\Count7_v1_0" `include "$CYPRESS_DIR\..\psoc\content\CyComponentLibrary\CyComponentLibrary.cylib\Count7_v1_0\Count7_v1_0.v"</code> </pre><br>  How creative refinement of the lines and constants is performed has already been described, so I will simply show the result.  Here are the chains and assignments added as a result (the rest asked for constants, so I threw them out): <br><br><pre> <code class="plaintext hljs">wire Count7_1_load; wire Count7_1_tc; assign Count7_1_load = (SM==E_UP2);</code> </pre><br>  But the counter itself, placed at the end of the file.  All constants are assigned to ports right in this ad: <br><br><pre> <code class="plaintext hljs"> Count7_v1_0 Count7_1 ( .en(1'b1), .load(Count7_1_load), .clock(clk), .reset(1'b0), .cnt(), .tc(Count7_1_tc)); defparam Count7_1.EnableSignal = 1; defparam Count7_1.LoadSignal = 1;</code> </pre><br>  To enable this counter to work, the machine adds an additional condition to exit the <b>Idle</b> state: <br><br><img src="https://habrastorage.org/webt/pc/it/pd/pcitpdmqenlvq8pblarf3uh5h84.png"><br><div class="spoiler">  <b class="spoiler_title">Same text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> case(SM) Idle : begin LCD_E &lt;= 0; if (( !F0empty ) == 1'b1) begin SM &lt;= LoadF0 ; LCD_RS &lt;= 0; end else if (( !F1empty &amp;Count7_1_tc ) == 1'b1) begin SM &lt;= LoadF1 ; LCD_RS &lt;= 1; end end</code> </pre><br></div></div><br>  The API for the counter added in this way is not created, so we add two magic lines to the <b>main</b> function, which I formed in the image and similarity of what I saw in the API from past projects (the first line sets the load value of the account, the Load, the second starts the counter) <br><br><pre> <code class="plaintext hljs"> *((uint8_t*)LCD4bit_1_Count7_1_Counter7__PERIOD_REG) = 0x20; *((uint8_t*)LCD4bit_1_Count7_1_Counter7__CONTROL_AUX_CTL_REG) |= 0x20; // Start</code> </pre><br>  The analyzer shows that in the modified case of delay there is: <br><br><img src="https://habrastorage.org/webt/ui/ey/ax/uieyax5yt3f0kpkhyyoikiishmq.png"><br><br>  The LCD also has all three characters. <br><br>  But the programmatic output of characters in real life is unacceptable.  If you simply add them to the FIFO, an overflow will occur.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To wait for the FIFO to be emptied is to create large delays for the processor core. </font><font style="vertical-align: inherit;">The processor operates at 72 MHz, and the data is output in 7-8 clock cycles at a frequency of 1 MHz. </font><font style="vertical-align: inherit;">Therefore, in real life, the text should be displayed using DMA. </font><font style="vertical-align: inherit;">This is where the ‚ÄúLaunched and forgotten‚Äù principle comes in handy. </font><font style="vertical-align: inherit;">All delays for the timing diagram will be generated by the UDB, and the DMA controller will determine the readiness of the FIFO to receive data. </font><font style="vertical-align: inherit;">From the processor core is required only to form a line in memory and configure the DMA, after which it can be engaged in other tasks without worrying about output to the LCD.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add this code:</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> static const char line[] = "This is a line"; /* Defines for DMA_D */ #define DMA_D_BYTES_PER_BURST 1 #define DMA_D_REQUEST_PER_BURST 1 /* Variable declarations for DMA_D */ /* Move these variable declarations to the top of the function */ uint8 DMA_D_Chan; uint8 DMA_D_TD[1]; /* DMA Configuration for DMA_D */ DMA_D_Chan = DMA_D_DmaInitialize(DMA_D_BYTES_PER_BURST, DMA_D_REQUEST_PER_BURST, HI16(line), HI16(LCD4bit_1_LCD_DP__F1_REG)); DMA_D_TD[0] = CyDmaTdAllocate(); CyDmaTdSetConfiguration(DMA_D_TD[0], sizeof(line)-1, CY_DMA_DISABLE_TD, CY_DMA_TD_INC_SRC_ADR); CyDmaTdSetAddress(DMA_D_TD[0], LO16((uint32)line), LO16((uint32)LCD4bit_1_LCD_DP__F1_REG)); CyDmaChSetInitialTd(DMA_D_Chan, DMA_D_TD[0]); CyDmaChEnable(DMA_D_Chan, 1);</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On the screen we have: </font></font><br><br><img src="https://habrastorage.org/webt/i7/ny/vi/i7nyvipk7tg8w_jdflryw2s39uk.png"><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On a semi-synthetic, but close to real-world, example, we mastered the mechanism for developing code for UDB using an alternative mechanism ‚Äî the Datapath Config Tool. </font><font style="vertical-align: inherit;">This mechanism, unlike the UDB Editor, gives access to absolutely all the UDB control capabilities, but working with it is more complicated than with the UDB Editor. </font><font style="vertical-align: inherit;">Nevertheless, the method proposed by the author of the article makes it possible not to write code from scratch, but simply to create it, based on auxiliary code created by the same UDB Editor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resulting test project when writing an article can be found </font></font><a href="https://yadi.sk/d/6jdMomUH7_hXfA"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/442572/">https://habr.com/ru/post/442572/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442558/index.html">"If the product is not needed, no matter how you pack it, there will be no sense": how technology companies work on interfaces</a></li>
<li><a href="../442560/index.html">Mash: multithreading, coroutines, async & wait</a></li>
<li><a href="../442562/index.html">How to cool the equipment in the data center - three new technologies</a></li>
<li><a href="../442568/index.html">Security Week 10: NVIDIA driver vulnerabilities</a></li>
<li><a href="../442570/index.html">Sigma rules. Craft or new standard for SOC</a></li>
<li><a href="../442574/index.html">Created the basis for a generalized theory of neural networks</a></li>
<li><a href="../442576/index.html">Long live overclockers: how liquid cooling has become dominant in data centers</a></li>
<li><a href="../442578/index.html">Linux 5.0 release</a></li>
<li><a href="../442580/index.html">Reverse engineering of a binary format on the example of Korg .SNG files</a></li>
<li><a href="../442582/index.html">How we tried mobbing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>