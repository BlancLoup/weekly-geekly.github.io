<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Core Data + Swift for the smallest: minimum necessary (part 3)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the final part of the article about Core Data , the previous parts are available here: Part 1 and Part 2 . 

 In this article, we will turn to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Core Data + Swift for the smallest: minimum necessary (part 3)</h1><div class="post__text post__text-html js-mediator-article"> This is the final part of the article about <b>Core Data</b> , the previous parts are available here: <a href="https://habrahabr.ru/post/303512/">Part 1</a> and <a href="https://habrahabr.ru/post/303798/">Part 2</a> . <br><br>  In this article, we will turn to face the user and work on the interface part; <b>NSFetchRequest</b> and <b>NSFetchedResultsController</b> will help us in this.  This part was quite large, but I see no reason to split it up into several publications.  More accurately, under the cut a lot of code and pictures. <br><a name="habracut"></a><br>  The interface is an ambiguous thing and, depending on the requirements for the product, can significantly change.  In this article I will not give him too much time, more precisely, I will devote very little (I mean following the <i>Guidelines</i> and the like).  My task in this part of the article is to show how <b><code>Core Data</code></b> can fit organically into the iOS controls.  Therefore, I will use for this purpose such an interface, using which the interaction of controls and <b><code>Core Data</code></b> will look simpler and clearer.  It is obvious that in the real application of the interface part it will be necessary to devote much more time. <br><br><h4>  Directories </h4><br>  Before we begin, let's <b><code>AppDelegate.swift</code></b> initial view to the application delegate module ( <b><code>AppDelegate.swift</code></b> ), in which we experimented in the last part of the article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// AppDelegate.swift // core-data-habrahabr-swift import UIKit import CoreData @UIApplicationMain class AppDelegate: UIResponder, UIApplicationDelegate { var window: UIWindow? func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool { return true } func applicationWillTerminate(application: UIApplication) { CoreDataManager.instance.saveContext() } }</span></span></code> </pre><br>  Let's start with Storyboard: <br><ul><li>  add a few buttons to the <b>View</b> - we will have two directories ("Customers" and "Services"), one document ("Order") and one report on documents </li><li>  add <b>Navigation Controller</b> ( <b><code>Editor\Embed In\Navigation Controller</code></b> menu) </li><li>  Add a new <b>Table View Controller</b> with a Title (Title) <b><code>Customers</code></b> </li><li>  connect the added <b>Table View Controller</b> with the corresponding button of the main menu ( <b><code>Action Segue\Show</code></b> ) </li></ul><br><br><img src="https://habrastorage.org/files/f55/91d/ffd/f5591dffdd404ca8bffd6c41a9b00924.png"><br><br>  Now you need to add your class to the <b>Table View Controller</b> : <br><ul><li>  <b>File \ New \ File</b> menu <b>...</b> </li><li>  as a template, choose <b>Cocoa Class</b> <br><img src="https://habrastorage.org/files/12f/c94/b68/12fc94b68773464d92e6ab41fb1b8a8d.png"><br><br></li><li>  select <b><code>UITableViewController</code></b> as the parent class and specify the name of our class - <b><code>CustomersTableViewController</code></b> <img src="https://habrastorage.org/files/2cb/3f8/315/2cb3f831596d4da5845aff680359430f.png"><br><br></li><li>  choose where to store the file and click <b>Create</b> </li></ul><br>  We are not forgetting to indicate this class created by us to our <b>Table View Controller</b> ( <code><b>Identity Inspector\Custom Class\Class</b></code> ). <br><img src="https://habrastorage.org/files/d9b/30e/974/d9b30e97453b4d12865745a76360a157.png"><br><br>  I will not use <b>Prototype Cells here</b> and create a ‚Äúcustom‚Äù class for table cells (to focus on other things), so let's set the number of such cells to zero ( <code><b>Attributes Inspector\Table View\Prototype Cells</b></code> ). <br><img src="https://habrastorage.org/files/0c7/8b1/4b0/0c78b14b058941c1980fa69aba0ddefe.png"><br><br>  Now we need to define a data source in order to implement the <b>Table View Data Source</b> protocol.  In the last part we met with <b>NSFetchRequest</b> and, at first glance, it seems to be suitable for this purpose.  With it, you can get a list of all objects in the form of an array, which, in fact, we need.  But we want not only to look at the list of customers, we want to add, delete and edit them.  In this case, we will have to track all these changes manually and each time, again manually, update our list.  It doesn't sound very much, does it?  But there is another option - <b>NSFetchedResultsController</b> , it is very similar to <b>NSFetchRequest</b> , but it not only returns an array of objects we need at the time of the request, but continues to monitor all records: if any record changes, it will tell us about it, if any. Some records will be loaded in the background through another managed context - it will also inform us about this.  We will only have to handle this event. <br><br>  Let's implement the <b>NSFetchedResultsController</b> in our module.  I will first give all the code, and then comment on it. <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// CustomersTableViewController.swift // core-data-habrahabr-swift import UIKit import CoreData class CustomersTableViewController: UITableViewController { var fetchedResultsController:NSFetchedResultsController = { let fetchRequest = NSFetchRequest(entityName: "Customer") let sortDescriptor = NSSortDescriptor(key: "name", ascending: true) fetchRequest.sortDescriptors = [sortDescriptor] let fetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: CoreDataManager.instance.managedObjectContext, sectionNameKeyPath: nil, cacheName: nil) return fetchedResultsController }() override func viewDidLoad() { super.viewDidLoad() do { try fetchedResultsController.performFetch() } catch { print(error) } } // MARK: - Table View Data Source override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { if let sections = fetchedResultsController.sections { return sections[section].numberOfObjects } else { return 0 } } override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let customer = fetchedResultsController.objectAtIndexPath(indexPath) as! Customer let cell = UITableViewCell() cell.textLabel?.text = customer.name return cell } }</span></span></code> </pre><br>  In the variable definition section, we create a <b>fetchedResultsController</b> object of type <b><code>NSFetchedResultsController</code></b> .  As you can see, it is created based on <b><code>NSFetchRequest</code></b> (I created NSFetchRequest based on the ‚ÄúCustomer‚Äù entity and set the sort by Customer name).  Then we create the <b><code>NSFetchedResultsController</code></b> itself, passing in its <b><code>NSFetchRequest</code></b> constructor and the managed context we need, we will not use additional constructor parameters (sectionNameKeyPath, cacheName) here. <br><br>  Then, when loading our <b>View Controller</b> ( <b><code>func viewDidLoad()</code></b> ), we run <b>fetchedResultsController</b> : <br><pre> <code class="objectivec hljs"> try fetchedResultsController.performFetch()</code> </pre><br>  We also need to override two functions to implement the <b>Table View Data Source</b> : <br><ul><li>  in the first function, we return the number of objects in the current section (in fact, we do not use sections here, so all objects will be in one single section) </li><li>  in the second, we programmatically construct a cell for each object and return it. </li></ul><br>  Let's check!  If we start the application now and go to our <b><code>¬´Customers¬ª</code></b> menu, we will see all of our customers who were added in the last part of the article.  It wasn't too hard, was it? <br><br><img src="https://habrastorage.org/files/a25/c24/01d/a25c2401d39e485ab20613a6a5931276.png"><img src="https://habrastorage.org/files/aa3/523/5ea/aa35235ea0f74a4fa1b9489f3935cf5a.png"><br><br>  Before proceeding, let's optimize something a bit - creating an <b>NSFetchedResultsController</b> object <b>is</b> not concise, and we will also need to create it for our other entities.  In this case, in essence, only the name of the entity and, possibly, the name of the sort field will change.  In order not to engage in "copy-paste", let's move out the creation of this object in the <b>CoreDataManager</b> . <br><br><pre> <code class="objectivec hljs">import CoreData import Foundation <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CoreDataManager { <span class="hljs-comment"><span class="hljs-comment">// Singleton static let instance = CoreDataManager() // Entity for Name func entityForName(entityName: String) -&gt; NSEntityDescription { return NSEntityDescription.entityForName(entityName, inManagedObjectContext: self.managedObjectContext)! } // Fetched Results Controller for Entity Name func fetchedResultsController(entityName: String, keyForSort: String) -&gt; NSFetchedResultsController { let fetchRequest = NSFetchRequest(entityName: entityName) let sortDescriptor = NSSortDescriptor(key: keyForSort, ascending: true) fetchRequest.sortDescriptors = [sortDescriptor] let fetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: CoreDataManager.instance.managedObjectContext, sectionNameKeyPath: nil, cacheName: nil) return fetchedResultsController } // MARK: - Core Data stack // ...</span></span></code> </pre><br>  In view of this, the definition of fetchedResultsController changes to the following: <br><br><pre> <code class="objectivec hljs"> var fetchedResultsController = CoreDataManager.instance.fetchedResultsController(<span class="hljs-string"><span class="hljs-string">"Customer"</span></span>, keyForSort: <span class="hljs-string"><span class="hljs-string">"name"</span></span>)</code> </pre><br>  Now we need to make sure that when choosing a Customer, a ‚Äúcard‚Äù is opened with all its data, which, if necessary, can be edited.  Let's add another <b>View Controller</b> for this (let‚Äôs give it the title <b><code>¬´Customer¬ª</code></b> ) and connect it to our <b>Table View Controller</b> . <br><br><img src="https://habrastorage.org/files/87c/efa/dbe/87cefadbe9cf47fe997d8cb1eb00a7b3.png"><br><br>  For the type of transition between controllers, select <b><code>Present Modally</code></b> . <br><br><img src="https://habrastorage.org/files/52d/8e8/4ea/52d8e84eadae44f9a7c6ad5d04d2d8b4.png"><br><br>  We will also need to address by name this <b>Segue</b> , let's specify the name - <b><code>customersToCustomer</code></b> . <br><br><img src="https://habrastorage.org/files/c1a/187/99a/c1a18799a6e249af95e26901361e7dcf.png"><br><br>  We need our own class for this <b>View Controller</b> - everything is similar to what we did for the <b>Table View Controller</b> , only as the parent class we select - <b><code>UIViewController</code></b> , the class name is <b><code>CustomerViewController</code></b> . <br><br><img src="https://habrastorage.org/files/4fe/ad3/3a5/4fead33a58b14fe5bef3dfdaf135e350.png"><br><br>  And we specify this class for our new <b>View Controller</b> . <br><br><img src="https://habrastorage.org/files/62a/eba/777/62aeba77773d4aa09e550aa36debd6c8.png"><br><br>  Now add a <b>Navigation Bar</b> with two buttons ( <b>Save</b> - to save changes and <b>Cancel</b> - to cancel).  We also need two text fields for displaying and editing information ( <b>name</b> and <b>info</b> ).  Make two <b>Actions</b> (for Save and Cancel) and two <b>Outlets</b> (for name and info). <br><br><img src="https://habrastorage.org/files/90f/ada/1cc/90fada1cc91c4f91b21af13031557c4d.png"><br><br>  The interface of our "card" of the Customer is ready, now we need to write some code.  The logic will be as follows: when switching to the ‚Äúcard‚Äù of the Customer from the list of Customers, we will transfer the <b>customer</b> object (Customer) based on the selected row of the list.  When opening a ‚Äúcard‚Äù, data from this object will be loaded into interface elements ( <b><code>name</code></b> , <b>info</b> ), and when the object is saved, on the contrary, the contents of the interface elements will be transferred to the fields of the saved object. <br><br>  Also, we need to take into account the fact that we have a required field - <b>name</b> .  If the user tries to save the Customer with an empty name, he will receive a critical error.  To prevent this, let's add validation of the stored data: if the data is not correct, then we will show the corresponding warning and block the recording of such an object.  The user must either enter the correct data or refuse to record such an object. <br><br>  And the last thing we need to take into account here: for sure, we want to not only edit existing Customers, but also add new ones.  We will do this as follows: in the list of Customers we will add a button to create a new Customer, which will open our "card" by transferring <b>nil</b> to it.  And when saving the data of the ‚Äúcard‚Äù of the Customer, we will check if the <b>customer</b> object has not yet been created (that is, to enter a new Customer), then we will immediately create it. <br><br>  Thus, we get about the following code. <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// CustomerViewController.swift // core-data-habrahabr-swift import UIKit class CustomerViewController: UIViewController { var customer: Customer? @IBAction func cancel(sender: AnyObject) { dismissViewControllerAnimated(true, completion: nil) } @IBAction func save(sender: AnyObject) { if saveCustomer() { dismissViewControllerAnimated(true, completion: nil) } } @IBOutlet weak var nameTextField: UITextField! @IBOutlet weak var infoTextField: UITextField! override func viewDidLoad() { super.viewDidLoad() // Reading object if let customer = customer { nameTextField.text = customer.name infoTextField.text = customer.info } } func saveCustomer() -&gt; Bool { // Validation of required fields if nameTextField.text!.isEmpty { let alert = UIAlertController(title: "Validation error", message: "Input the name of the Customer!", preferredStyle: .Alert) alert.addAction(UIAlertAction(title: "OK", style: .Cancel, handler: nil)) self.presentViewController(alert, animated: true, completion: nil) return false } // Creating object if customer == nil { customer = Customer() } // Saving object if let customer = customer { customer.name = nameTextField.text customer.info = infoTextField.text CoreDataManager.instance.saveContext() } return true } }</span></span></code> </pre><br>  Now let's go back to the <b>Table View Controller</b> and add a button to create a new customer ( <b><code>Navigation Item + Bar Button Item</code></b> , similar to the Customer card).  And create an <b>Action</b> for this button named <b><code>AddCustomer</code></b> . <br><br><img src="https://habrastorage.org/files/8d5/a22/a4e/8d5a22a4e5224d59b6479f333b8639e5.png"><br><br>  This Action will open a ‚Äúcard‚Äù to create a new Customer, transferring <b>nil</b> to it. <br><br><pre> <code class="objectivec hljs"> @IBAction func AddCustomer(sender: AnyObject) { performSegueWithIdentifier(<span class="hljs-string"><span class="hljs-string">"customersToCustomer"</span></span>, sender: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre><br>  It remains to make sure that when choosing an existing Customer, its ‚Äúcard‚Äù opens.  For this we need two procedures. <br><br><pre> <code class="objectivec hljs"> override func tableView(tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, didSelectRowAtIndexPath indexPath: <span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>) { let customer = fetchedResultsController.objectAtIndexPath(indexPath) as? Customer performSegueWithIdentifier(<span class="hljs-string"><span class="hljs-string">"customersToCustomer"</span></span>, sender: customer) } override func prepareForSegue(segue: <span class="hljs-built_in"><span class="hljs-built_in">UIStoryboardSegue</span></span>, sender: AnyObject?) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"customersToCustomer"</span></span> { let controller = segue.destinationViewController as! CustomerViewController controller.customer = sender as? Customer } }</code> </pre><br>  In the first procedure (when selecting the list line) we ‚Äúread‚Äù the current Customer, and in the second (when moving from the list to the ‚Äúcard‚Äù), we assign a reference to the selected <b><code>customer</code></b> our ‚Äúcard‚Äù customer variable so that when opening it we can read all object data. <br><br>  Let's now launch our application and make sure that everything works as it should. <br><br><img src="https://habrastorage.org/files/eac/86e/249/eac86e2492f44703b77cf22a479a8d40.png"><br><br>  The application works, we can enter new customers, edit existing ones, but the information in the list is not automatically updated and we do not have a mechanism to delete an unnecessary (or mistakenly entered) Customer.  Let's fix it. <br><br>  Since we are using <b>NSFetchedResultsController</b> , which ‚Äúknows‚Äù about all these changes, we just need to ‚Äúlisten‚Äù to it.  To do this, you must implement the delegate protocol <b>NSFetchedResultsControllerDelegate</b> .  Let's announce that we implement this protocol: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CustomersTableViewController: <span class="hljs-built_in"><span class="hljs-built_in">UITableViewController</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">NSFetchedResultsControllerDelegate</span></span> {</code> </pre><br>  Declare yourself a delegate to <b>NSFetchedResultsController</b> : <br><br><pre> <code class="objectivec hljs"> override func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() fetchedResultsController.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { try fetchedResultsController.performFetch() } catch { print(error) } }</code> </pre><br>  And add the following implementation of this protocol: <br><br><pre> <code class="objectivec hljs"> <span class="hljs-comment"><span class="hljs-comment">// MARK: - Fetched Results Controller Delegate func controllerWillChangeContent(controller: NSFetchedResultsController) { tableView.beginUpdates() } func controller(controller: NSFetchedResultsController, didChangeObject anObject: AnyObject, atIndexPath indexPath: NSIndexPath?, forChangeType type: NSFetchedResultsChangeType, newIndexPath: NSIndexPath?) { switch type { case .Insert: if let indexPath = newIndexPath { tableView.insertRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } case .Update: if let indexPath = indexPath { let customer = fetchedResultsController.objectAtIndexPath(indexPath) as! Customer let cell = tableView.cellForRowAtIndexPath(indexPath) cell!.textLabel?.text = customer.name } case .Move: if let indexPath = indexPath { tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } if let newIndexPath = newIndexPath { tableView.insertRowsAtIndexPaths([newIndexPath], withRowAnimation: .Automatic) } case .Delete: if let indexPath = indexPath { tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } } } func controllerDidChangeContent(controller: NSFetchedResultsController) { tableView.endUpdates() }</span></span></code> </pre><br>  Despite the relatively large volume - it is quite simple.  Here we get information about which object and how it has changed, and, depending on the type of change, we perform various actions: <br><ul><li>  <b>Insert</b> (add) - insert a new line at the specified index (the line is added not just to the end of the list, but to its place in the list in accordance with the specified sorting) </li><li>  <b>Update</b> - the object data has changed, we get a row from our list at the specified index and update information about it </li><li>  <b>Move</b> (move) - the order of the lines has changed (for example, the Customer has been renamed and it is now located in accordance with the sorting in a different place), delete the line from where it was and add it by the new index </li><li>  <b>Delete</b> (delete) - delete the line at the specified index. </li></ul><br>  We also have two ‚Äúhelper‚Äù functions, <b><code>controllerWillChangeContent</code></b> and <b><code>controllerDidChangeContent</code></b> , which, respectively, inform about the beginning and end of the data change.  Using these functions, we inform our <b><code>Table View</code></b> that now we will change something in the data that it displays (this is necessary for its correct operation). <br><br>  It remains only to implement the removal of the customer.  This is done quite simply, we need to override just one small procedure. <br><br><pre> <code class="objectivec hljs">override func tableView(tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, commitEditingStyle editingStyle: <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCellEditingStyle</span></span>, forRowAtIndexPath indexPath: <span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> editingStyle == .Delete { let managedObject = fetchedResultsController.objectAtIndexPath(indexPath) as! <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span> CoreDataManager.instance.managedObjectContext.deleteObject(managedObject) CoreDataManager.instance.saveContext() } }</code> </pre><br>  When a delete command is received, we retrieve the current object by index and pass it to the managed context for deletion.  Note that the type of the object to be deleted must be <b><code>NSManagedObject</code></b> . <br><br>  This completes the work with the reference book "Customers".  Let's run the application and check its work. <br><br><img src="https://habrastorage.org/files/962/568/b38/962568b38981404db5e9122744c9ff33.png"><img src="https://habrastorage.org/files/835/1ca/1e9/8351ca1e93b04453a415617ca42aa7a2.png"><br><br>  As you see, nothing supercomplex, <b>Core Data</b> combines perfectly with standard interface elements. <br><br><div class="spoiler">  <b class="spoiler_title">The text of the module CustomersTableViewController.swift</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// CustomersTableViewController.swift // core-data-habrahabr-swift import UIKit import CoreData class CustomersTableViewController: UITableViewController, NSFetchedResultsControllerDelegate { var fetchedResultsController = CoreDataManager.instance.fetchedResultsController("Customer", keyForSort: "name") override func viewDidLoad() { super.viewDidLoad() fetchedResultsController.delegate = self do { try fetchedResultsController.performFetch() } catch { print(error) } } @IBAction func AddCustomer(sender: AnyObject) { performSegueWithIdentifier("customersToCustomer", sender: nil) } // MARK: - Table View Data Source override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { if let sections = fetchedResultsController.sections { return sections[section].numberOfObjects } else { return 0 } } override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let customer = fetchedResultsController.objectAtIndexPath(indexPath) as! Customer let cell = UITableViewCell() cell.textLabel?.text = customer.name return cell } // MARK: - Table View Delegate override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { if editingStyle == .Delete { let managedObject = fetchedResultsController.objectAtIndexPath(indexPath) as! NSManagedObject CoreDataManager.instance.managedObjectContext.deleteObject(managedObject) CoreDataManager.instance.saveContext() } } override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { let customer = fetchedResultsController.objectAtIndexPath(indexPath) as? Customer performSegueWithIdentifier("customersToCustomer", sender: customer) } override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { if segue.identifier == "customersToCustomer" { let controller = segue.destinationViewController as! CustomerViewController controller.customer = sender as? Customer } } // MARK: - Fetched Results Controller Delegate func controllerWillChangeContent(controller: NSFetchedResultsController) { tableView.beginUpdates() } func controller(controller: NSFetchedResultsController, didChangeObject anObject: AnyObject, atIndexPath indexPath: NSIndexPath?, forChangeType type: NSFetchedResultsChangeType, newIndexPath: NSIndexPath?) { switch type { case .Insert: if let indexPath = newIndexPath { tableView.insertRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } case .Update: if let indexPath = indexPath { let customer = fetchedResultsController.objectAtIndexPath(indexPath) as! Customer let cell = tableView.cellForRowAtIndexPath(indexPath) cell!.textLabel?.text = customer.name } case .Move: if let indexPath = indexPath { tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } if let newIndexPath = newIndexPath { tableView.insertRowsAtIndexPaths([newIndexPath], withRowAnimation: .Automatic) } case .Delete: if let indexPath = indexPath { tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } } } func controllerDidChangeContent(controller: NSFetchedResultsController) { tableView.endUpdates() } }</span></span></code> </pre><br></div></div><br><br><h4>  Directory "Services" </h4><br>  The directory of services we have has the same structure and logic of work as the directory of customers.  The differences are minimal, so I will not describe everything in detail here, but simply give a brief procedure (I'm sure that you can easily do everything on your own according to this summary): <br><ul><li>  create a new <b>Table View Controller</b> and link it to the <code><b>¬´Services¬ª</b></code> button </li><li>  create and assign a new class <b><code>ServicesTableViewController</code></b> for it (based on <b><code>UITableViewController</code></b> ) </li><li>  we import ( <b><code>import</code></b> ) <b><code>CoreData</code></b> , add <b><code>fetchedResultsController</code></b> (based on the <b><code>Service</code></b> entity) and launch the controller when the controller loads </li><li>  We add two procedures to implement <b>Table View Data Source</b> , the first one returns the number of rows, the second one returns the string with information about the object at the specified index </li><li>  we create a new <b>View Controller</b> to display the ‚Äúcard‚Äù of the service and place interface elements on it (all similar to the customer‚Äôs ‚Äúcard‚Äù) </li><li>  create and assign a new class <b><code>ServiceViewController</code></b> (based on <b><code>UIViewController</code></b> ) for this controller </li><li>  create two <b>Action</b> (buttons <b><code>Save</code></b> and <b><code>Cancel</code></b> ) and two <b>Outlet</b> ( <b><code>name</code></b> and <b><code>info</code></b> fields) </li><li>  we add the necessary code (we declare the <b><code>service</code></b> variable, we register the procedures for loading and saving the object, we don‚Äôt forget about checking the data before writing) </li><li>  Add a link between <b><code>ServicesTableViewController</code></b> and <b><code>ServiceViewController</code></b> named <b><code>servicesToService</code></b> ( <b><code>Segue \ Present Modally</code></b> ) </li><li>  return to <b><code>ServicesTableViewController</code></b> and add the <b>Add</b> button to add a new service ( <b><code>Navigation Item \ Bar Button Item</code></b> ) and create an <b>Action</b> for it called <b><code>AddService</code></b> </li><li>  prescribe the code necessary for the transition to the card of the new ‚Äúservice‚Äù and implement the <b>Table View Delegate</b> methods (go to the ‚Äúcard‚Äù of the selected service) </li><li>  implement the <b><code>NSFetchedResultsControllerDelegate</code></b> protocol <b><code>NSFetchedResultsControllerDelegate</code></b> and declare the current class as a delegate </li><li>  all check! </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">ServicesTableViewController.swift module text</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// ServicesTableViewController.swift // core-data-habrahabr-swift import UIKit import CoreData class ServicesTableViewController: UITableViewController, NSFetchedResultsControllerDelegate { var fetchedResultsController = CoreDataManager.instance.fetchedResultsController("Service", keyForSort: "name") @IBAction func AddService(sender: AnyObject) { performSegueWithIdentifier("servicesToService", sender: nil) } override func viewDidLoad() { super.viewDidLoad() fetchedResultsController.delegate = self do { try fetchedResultsController.performFetch() } catch { print(error) } } // MARK: - Table View Data Source override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { if let sections = fetchedResultsController.sections { return sections[section].numberOfObjects } else { return 0 } } override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let service = fetchedResultsController.objectAtIndexPath(indexPath) as! Service let cell = UITableViewCell() cell.textLabel?.text = service.name return cell } // MARK: - Table View Delegate override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { if editingStyle == .Delete { let managedObject = fetchedResultsController.objectAtIndexPath(indexPath) as! NSManagedObject CoreDataManager.instance.managedObjectContext.deleteObject(managedObject) CoreDataManager.instance.saveContext() } } override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { let service = fetchedResultsController.objectAtIndexPath(indexPath) as? Service performSegueWithIdentifier("servicesToService", sender: service) } override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { if segue.identifier == "servicesToService" { let controller = segue.destinationViewController as! ServiceViewController controller.service = sender as? Service } } // MARK: - Fetched Results Controller Delegate func controllerWillChangeContent(controller: NSFetchedResultsController) { tableView.beginUpdates() } func controller(controller: NSFetchedResultsController, didChangeObject anObject: AnyObject, atIndexPath indexPath: NSIndexPath?, forChangeType type: NSFetchedResultsChangeType, newIndexPath: NSIndexPath?) { switch type { case .Insert: if let indexPath = newIndexPath { tableView.insertRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } case .Update: if let indexPath = indexPath { let service = fetchedResultsController.objectAtIndexPath(indexPath) as! Service let cell = tableView.cellForRowAtIndexPath(indexPath) cell!.textLabel?.text = service.name } case .Move: if let indexPath = indexPath { tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } if let newIndexPath = newIndexPath { tableView.insertRowsAtIndexPaths([newIndexPath], withRowAnimation: .Automatic) } case .Delete: if let indexPath = indexPath { tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } } } func controllerDidChangeContent(controller: NSFetchedResultsController) { tableView.endUpdates() } }</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Text module ServiceViewController.swift</font></font></b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// ServiceViewController.swift // core-data-habrahabr-swift import UIKit class ServiceViewController: UIViewController { @IBOutlet weak var nameTextField: UITextField! @IBOutlet weak var infoTextField: UITextField! @IBAction func cancel(sender: AnyObject) { dismissViewControllerAnimated(true, completion: nil) } @IBAction func save(sender: AnyObject) { if saveService() { dismissViewControllerAnimated(true, completion: nil) } } var service: Service? override func viewDidLoad() { super.viewDidLoad() // Reading object if let service = service { nameTextField.text = service.name infoTextField.text = service.info } } func saveService() -&gt; Bool { // Validation of required fields if nameTextField.text!.isEmpty { let alert = UIAlertController(title: "Validation error", message: "Input the name of the Service!", preferredStyle: .Alert) alert.addAction(UIAlertAction(title: "OK", style: .Cancel, handler: nil)) self.presentViewController(alert, animated: true, completion: nil) return false } // Creating object if service == nil { service = Service() } // Saving object if let service = service { service.name = nameTextField.text service.info = infoTextField.text CoreDataManager.instance.saveContext() } return true } }</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xcode</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/4b6/349/685/4b634968531b403a841b6bf61e0f7348.png"><br><br><img src="https://habrastorage.org/files/b46/d3d/930/b46d3d930aaa44c9aa3bb9575b2359a0.png"><br><br><img src="https://habrastorage.org/files/e2d/185/779/e2d1857791964e02b00794a291aace41.png"><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It should get something like this: </font></font><br><br><img src="https://habrastorage.org/files/c9c/132/bc1/c9c132bc145042ab9433d06dc872dbb7.png"><img src="https://habrastorage.org/files/b6b/a8f/1b8/b6ba8f1b84574429b36c3061a49e121e.png"><br><br><h4>  Document </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything will be a little more complicated with the document, since each document, firstly, is represented by two different entities, and, secondly, there are interrelations, that is, it is necessary to ensure the choice of meaning in some way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with a simple and familiar one - let's create a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with a list of documents and a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to display the document itself (for now, no details, only a blank). </font><font style="vertical-align: inherit;">I will not repeat - all the same algorithm as the reference books. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create two new controllers ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the document list and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the document itself): </font></font><br><br><img src="https://habrastorage.org/files/bc7/005/512/bc7005512c7d4028ba606f02dfcf7cbe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Action</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , create </font></font><b><code>fetchedResultsController</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and implement protocols:</font></font><br><br><img src="https://habrastorage.org/files/329/1ed/2e9/3291ed2e9691450fb097235164538552.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Making a blank for the document itself: </font></font><br><br><img src="https://habrastorage.org/files/30e/daf/df7/30edafdf7f2641319c700b470a66bd9b.png"><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The text of the OrdersTableViewController.swift module</font></font></b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// OrdersTableViewController.swift // core-data-habrahabr-swift import UIKit import CoreData class OrdersTableViewController: UITableViewController, NSFetchedResultsControllerDelegate { var fetchedResultsController = CoreDataManager.instance.fetchedResultsController("Order", keyForSort: "date") @IBAction func AddOrder(sender: AnyObject) { performSegueWithIdentifier("ordersToOrder", sender: nil) } override func viewDidLoad() { super.viewDidLoad() fetchedResultsController.delegate = self do { try fetchedResultsController.performFetch() } catch { print(error) } } // MARK: - Table View Data Source override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { if let sections = fetchedResultsController.sections { return sections[section].numberOfObjects } else { return 0 } } override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let cell = UITableViewCell() let order = fetchedResultsController.objectAtIndexPath(indexPath) as! Order configCell(cell, order: order) return cell } func configCell(cell: UITableViewCell, order: Order) { let formatter = NSDateFormatter() formatter.dateFormat = "MMM d, yyyy" let nameOfCustomer = (order.customer == nil) ? "-- Unknown --" : (order.customer!.name!) cell.textLabel?.text = formatter.stringFromDate(order.date) + "\t" + nameOfCustomer } // MARK: - Table View Delegate override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { if editingStyle == .Delete { let managedObject = fetchedResultsController.objectAtIndexPath(indexPath) as! NSManagedObject CoreDataManager.instance.managedObjectContext.deleteObject(managedObject) CoreDataManager.instance.saveContext() } } override func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { let order = fetchedResultsController.objectAtIndexPath(indexPath) as? Order performSegueWithIdentifier("ordersToOrder", sender: order) } override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { if segue.identifier == "ordersToOrder" { let controller = segue.destinationViewController as! OrderViewController controller.order = sender as? Order } } // MARK: - Fetched Results Controller Delegate func controllerWillChangeContent(controller: NSFetchedResultsController) { tableView.beginUpdates() } func controller(controller: NSFetchedResultsController, didChangeObject anObject: AnyObject, atIndexPath indexPath: NSIndexPath?, forChangeType type: NSFetchedResultsChangeType, newIndexPath: NSIndexPath?) { switch type { case .Insert: if let indexPath = newIndexPath { tableView.insertRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } case .Update: if let indexPath = indexPath { let order = fetchedResultsController.objectAtIndexPath(indexPath) as! Order let cell = tableView.cellForRowAtIndexPath(indexPath) configCell(cell!, order: order) } case .Move: if let indexPath = indexPath { tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } if let newIndexPath = newIndexPath { tableView.insertRowsAtIndexPaths([newIndexPath], withRowAnimation: .Automatic) } case .Delete: if let indexPath = indexPath { tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } } } func controllerDidChangeContent(controller: NSFetchedResultsController) { tableView.endUpdates() } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A few notes: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when creating a </font></font><b><code>fetchedResultsController</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">field for sorting, we specify as ‚Äú </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">date</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù, that is, the documents will be sorted by their date</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A separate auxiliary function is used to construct the cell. </font></font><b><code>configCell</code></b> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">since the connection between our document and the Customer is established as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one-to-one</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we can access it immediately "through the dot", which we do when constructing the cell text.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this, the document log will be finished, it remains to make the document itself. </font><font style="vertical-align: inherit;">It should be noted that all three sections (two of our reference books and a document) turned out to be very similar (from the point of view of implementation) and the question arises whether it is advisable to use different classes and controllers for them instead of one universal one. </font><font style="vertical-align: inherit;">This approach is also possible, but the similarity of our controllers is due to a very simple data model, in real-life applications, entities, as a rule, still noticeably differ and, as a result, controllers and interface solutions also look completely different. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We turn to the most interesting - the document. </font><font style="vertical-align: inherit;">Let's reflect all the interface elements we need:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Document Date - </font><b><font style="vertical-align: inherit;">Date Picker</font></b><font style="vertical-align: inherit;"> is for this.</font></font><b><font style="vertical-align: inherit;"></font></b> </li><li>  ‚Äî    :          (  )     </li><li>   ‚Äî  <b>Switch</b> </li><li>   ‚Äî   </li><li>   ‚Äî   <b>Table View</b> .          ,   ¬´¬ª ,       . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Should get something like this (design, of course, it sucks, but this is not the main goal we have now different): </font></font><br><br><img src="https://habrastorage.org/files/30e/254/2fe/30e2542fe4e14f759ea425fa1056c461.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to somehow organize the Client selection process: we have to open a list of customers, so the user can choose the right and then pass selected object back to our controller so we can use it in the document. Usually this is done using the delegation mechanism, that is, the creation of the necessary protocol and its implementation. But we will go the other way - I will use the context capture with the help of a closure here (I will not talk in detail about the mechanism itself, since there is a </font></font><a href="https://habrahabr.ru/post/258873/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">good article dedicated to just this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). It is not much more difficult, if at all more difficult, but it is faster implemented and looks much more elegant.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considering that in the future we will need to choose Services as well, similarly to the Customer, it would be possible to create a separate universal controller to select values ‚Äã‚Äãfrom the list, but to save time, let's use the ready-made controllers we created (list of Customers and Services list ). </font><font style="vertical-align: inherit;">To get started, let's connect the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Controller of</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> our document with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table View Controller of the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> list of Customers using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segue</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/files/2d1/0d3/b3f/2d10d3b3f43b433bb358fd537f0aa282.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And we will register a call of this transition on the button of the choice of the Customer.</font></font><br><br><pre> <code class="objectivec hljs"> @IBAction func choiceCustomer(sender: AnyObject) { performSegueWithIdentifier(<span class="hljs-string"><span class="hljs-string">"orderToCustomers"</span></span>, sender: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, in order to implement context capture, we need to make small changes to our controller, which is responsible for displaying the list of counterparties ( </font></font><b><code>CustomersTableViewController.swift</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">First you need to add a closure variable:</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// CustomersTableViewController.swift // core-data-habrahabr-swift import UIKit import CoreData class CustomersTableViewController: UITableViewController, NSFetchedResultsControllerDelegate { typealias Select = (Customer?) -&gt; () var didSelect: Select?</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And, secondly, change the procedure for selecting the current line of the list: </font></font><br><br><pre> <code class="objectivec hljs"> override func tableView(tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, didSelectRowAtIndexPath indexPath: <span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>) { let customer = fetchedResultsController.objectAtIndexPath(indexPath) as? Customer <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let dSelect = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.didSelect { dSelect(customer) dismissViewControllerAnimated(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { performSegueWithIdentifier(<span class="hljs-string"><span class="hljs-string">"customersToCustomer"</span></span>, sender: customer) } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pay attention to the logic: we use an optional closure variable, if it is not defined - then the list works as usual, in the mode of adding and editing data, if defined, then the list was called from the document to select the Customer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now go back to the document controller to implement the closure. </font><font style="vertical-align: inherit;">But before we define the procedures for loading and saving the document. </font><font style="vertical-align: inherit;">The logic of work here will be slightly different from working with reference books. </font><font style="vertical-align: inherit;">As we remember, when creating a new document, we transmit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the document object itself when opening a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not yet. </font><font style="vertical-align: inherit;">If, when working with reference books, this did not interfere with us and we created the object itself just before recording, then we will create it for the document right away, since when editing rows of the table part we will need to specify a link to a specific document. </font><font style="vertical-align: inherit;">In principle, nothing prevents us from using the same approach for reference books for uniformity, but in order to demonstrate different approaches, we will leave both options. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the procedure of ‚Äúreading‚Äù data into form elements will look like this:</font></font><br><pre> <code class="objectivec hljs"> override func viewDidLoad() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() <span class="hljs-comment"><span class="hljs-comment">// Creating object if order == nil { order = Order() order?.date = NSDate() } if let order = order { dataPicker.date = order.date switchMade.on = order.made switchPaid.on = order.paid textFieldCustomer.text = order.customer?.name } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note: when creating the object, I immediately assigned the document the current date (the designer </font></font><b><code>NSDate()</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the current date / time). </font><font style="vertical-align: inherit;">And the data recording procedure:</font></font><br><pre> <code class="objectivec hljs"> func saveOrder() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let order = order { order.date = dataPicker.date order.made = switchMade.on order.paid = switchPaid.on CoreDataManager.instance.saveContext() } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now let's finally implement the closure for the Customer sample, this is done quite simply: </font></font><br><pre> <code class="objectivec hljs"> override func prepareForSegue(segue: <span class="hljs-built_in"><span class="hljs-built_in">UIStoryboardSegue</span></span>, sender: AnyObject?) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"orderToCustomers"</span></span> { let viewController = segue.destinationViewController as! CustomersTableViewController viewController.didSelect = { [unowned <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (customer) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let customer = customer { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.order?.customer = customer <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textFieldCustomer.text = customer.name! } } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When switching to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table View Controller,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we define a handler, according to which, when choosing a Customer, we assign it to our document object, and also display the name of the Customer on the corresponding document control. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this mechanism, the choice of the customer is completed, let's make sure that everything works as it should. </font></font><br><br><img src="https://habrastorage.org/files/f55/e70/12c/f55e7012ccf7466e8d4bed5bd402059c.png"><img src="https://habrastorage.org/files/0a8/981/d4b/0a8981d4b392473eb02c1eba5f52a681.png"><img src="https://habrastorage.org/files/b41/c1c/8c5/b41c1c8c50934e05b256670f34aa14d1.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's take a tabular part. Here everything should be familiar. Obviously, you need to create </font></font><b><code>fetchedResultsController</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and implement protocols </font></font><b><code>NSFetchedResultsControllerDelegate</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><b><code>UITableViewDataSource</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><b><code>UITableViewDelegate</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, just a minute, if we use</font></font><b><code>fetchedResultsController</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, created in the same way as the previous one - we really get all the rows of the table part, but these will be the rows of all documents, and we need only the lines of the current document, the one with which the user works. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this we need to add the appropriate filter in </font></font><b><code>fetchRequest</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is done through the mechanism of predicates ( </font></font><b><code>NSPredicate</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">We will talk about it a little more at the end of the article, but for now let's just add for our document ( </font></font><b><code>Order.swift</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) a class function that will return the table part of the document as </font></font><b><code>NSFetchedResultsController</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="objectivec hljs"> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> func getRowsOfOrder(order: Order) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSFetchedResultsController</span></span> { let fetchRequest = <span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span>(entityName: <span class="hljs-string"><span class="hljs-string">"RowOfOrder"</span></span>) let sortDescriptor = <span class="hljs-built_in"><span class="hljs-built_in">NSSortDescriptor</span></span>(key: <span class="hljs-string"><span class="hljs-string">"service.name"</span></span>, ascending: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) fetchRequest.sortDescriptors = [sortDescriptor] let predicate = <span class="hljs-built_in"><span class="hljs-built_in">NSPredicate</span></span>(format: <span class="hljs-string"><span class="hljs-string">"%K == %@"</span></span>, <span class="hljs-string"><span class="hljs-string">"order"</span></span>, order) fetchRequest.predicate = predicate let fetchedResultsController = <span class="hljs-built_in"><span class="hljs-built_in">NSFetchedResultsController</span></span>(fetchRequest: fetchRequest, managedObjectContext: CoreDataManager.instance.managedObjectContext, sectionNameKeyPath: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, cacheName: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchedResultsController }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pay attention to this line of code: </font></font><br><br><pre> <code class="objectivec hljs">let sortDescriptor = <span class="hljs-built_in"><span class="hljs-built_in">NSSortDescriptor</span></span>(key: <span class="hljs-string"><span class="hljs-string">"service.name"</span></span>, ascending: <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we set as the sort key the nested field of the object (‚Äúthrough the point‚Äù). Isn't that a great opportunity? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now back in </font></font><b><code>OrderViewController.swift</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we need to declare a variable that will contain the tabular part and initialize it after initializing the document itself when loading the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// OrderViewController.swift // core-data-habrahabr-swift import UIKit import CoreData class OrderViewController: UIViewController { var order: Order? var table: NSFetchedResultsController? //‚Ä¶ override func viewDidLoad() { super.viewDidLoad() // Creating object if order == nil { order = Order() order?.date = NSDate() } if let order = order { dataPicker.date = order.date switchMade.on = order.made switchPaid.on = order.paid textFieldCustomer.text = order.customer?.name table = Order.getRowsOfOrder(order) table!.delegate = self do { try table!.performFetch() } catch { print(error) } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediately create a new </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to display the data line of the document and assign it a new class </font></font><b><code>RowOfOrderViewController</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Add the necessary navigation and control elements, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outlet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Action</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , implement the procedures for reading and writing the object. Also for the amount input field, set the numeric keypad ( </font></font><b><code>Keyboard Type = Number Pad</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><img src="https://habrastorage.org/files/295/e42/582/295e425822f345c8814bc84b9c17a090.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's add a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segue</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> named </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">orderToRowOfOrder</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (by connecting the document and the newly created </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and implement the delegates of the necessary protocols in our document. All the same as in previous controllers, there is nothing fundamentally new here (just below I will give the full text of the module).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, let's add a button to add rows to the table part of the document. </font><font style="vertical-align: inherit;">Here there is one nuance: if earlier, when creating a new object, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nil was</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> passed </font><font style="vertical-align: inherit;">, and the object itself was created in another controller, then in the case of a row of the table part, we somehow need to ‚Äúwrite‚Äù a specific document in it. </font><font style="vertical-align: inherit;">This can be done in different ways, depending on the logic of the program. </font><font style="vertical-align: inherit;">We will make the most obvious - we will pass not </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but the object ( </font></font><b><code>RowOfOrder</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), which we will immediately create and set in it a link to our document.</font></font><br><pre> <code class="objectivec hljs"> @IBAction func AddRowOfOrder(sender: AnyObject) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let order = order { let newRowOfOrder = RowOfOrder() newRowOfOrder.order = order performSegueWithIdentifier(<span class="hljs-string"><span class="hljs-string">"orderToRowOfOrder"</span></span>, sender: newRowOfOrder) } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Please note: since we have a defined reverse relationship between entities in the data model, we don‚Äôt need to worry about creating it, it will be added automatically. </font></font><br><br><img src="https://habrastorage.org/files/73c/73a/410/73c73a4103054a5ea3fbbfc19999a6fc.png"><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The text of the module OrderViewController.swift</font></font></b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// OrderViewController.swift // core-data-habrahabr-swift import UIKit import CoreData class OrderViewController: UIViewController, NSFetchedResultsControllerDelegate, UITableViewDataSource, UITableViewDelegate { var order: Order? var table: NSFetchedResultsController? @IBOutlet weak var dataPicker: UIDatePicker! @IBOutlet weak var textFieldCustomer: UITextField! @IBOutlet weak var tableView: UITableView! @IBAction func save(sender: AnyObject) { saveOrder() dismissViewControllerAnimated(true, completion: nil) } @IBAction func cancel(sender: AnyObject) { dismissViewControllerAnimated(true, completion: nil) } @IBAction func choiceCustomer(sender: AnyObject) { performSegueWithIdentifier("orderToCustomers", sender: nil) } @IBAction func AddRowOfOrder(sender: AnyObject) { if let order = order { let newRowOfOrder = RowOfOrder() newRowOfOrder.order = order performSegueWithIdentifier("orderToRowOfOrder", sender: newRowOfOrder) } } override func viewDidLoad() { super.viewDidLoad() tableView.dataSource = self tableView.delegate = self // Creating object if order == nil { order = Order() order!.date = NSDate() } if let order = order { dataPicker.date = order.date switchMade.on = order.made switchPaid.on = order.paid textFieldCustomer.text = order.customer?.name table = Order.getRowsOfOrder(order) table!.delegate = self do { try table!.performFetch() } catch { print(error) } } } func saveOrder() { if let order = order { order.date = dataPicker.date order.made = switchMade.on order.paid = switchPaid.on CoreDataManager.instance.saveContext() } } override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { switch segue.identifier! { case "orderToCustomers": let viewController = segue.destinationViewController as! CustomersTableViewController viewController.didSelect = { [unowned self] (customer) in if let customer = customer { self.order?.customer = customer self.textFieldCustomer.text = customer.name! } } case "orderToRowOfOrder": let controller = segue.destinationViewController as! RowOfOrderViewController controller.rowOfOrder = sender as? RowOfOrder default: break } } // MARK: - Table View Data Source func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { if let sections = table?.sections { return sections[section].numberOfObjects } else { return 0 } } func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let rowOfOrder = table?.objectAtIndexPath(indexPath) as! RowOfOrder let cell = UITableViewCell() let nameOfService = (rowOfOrder.service == nil) ? "-- Unknown --" : (rowOfOrder.service!.name!) cell.textLabel?.text = nameOfService + " - " + String(rowOfOrder.sum) return cell } // MARK: - Table View Delegate func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) { if editingStyle == .Delete { let managedObject = table?.objectAtIndexPath(indexPath) as! NSManagedObject CoreDataManager.instance.managedObjectContext.deleteObject(managedObject) CoreDataManager.instance.saveContext() } } func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) { let rowOfOrder = table?.objectAtIndexPath(indexPath) as! RowOfOrder performSegueWithIdentifier("orderToRowOfOrder", sender: rowOfOrder) } // MARK: - Fetched Results Controller Delegate func controllerWillChangeContent(controller: NSFetchedResultsController) { tableView.beginUpdates() } func controller(controller: NSFetchedResultsController, didChangeObject anObject: AnyObject, atIndexPath indexPath: NSIndexPath?, forChangeType type: NSFetchedResultsChangeType, newIndexPath: NSIndexPath?) { switch type { case .Insert: if let indexPath = newIndexPath { tableView.insertRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } case .Update: if let indexPath = indexPath { let rowOfOrder = table?.objectAtIndexPath(indexPath) as! RowOfOrder let cell = tableView.cellForRowAtIndexPath(indexPath)! let nameOfService = (rowOfOrder.service == nil) ? "-- Unknown --" : (rowOfOrder.service!.name!) cell.textLabel?.text = nameOfService + " - " + String(rowOfOrder.sum) } case .Move: if let indexPath = indexPath { tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } if let newIndexPath = newIndexPath { tableView.insertRowsAtIndexPaths([newIndexPath], withRowAnimation: .Automatic) } case .Delete: if let indexPath = indexPath { tableView.deleteRowsAtIndexPaths([indexPath], withRowAnimation: .Automatic) } } } func controllerDidChangeContent(controller: NSFetchedResultsController) { tableView.endUpdates() } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This completes the work directly with the document itself. </font><font style="vertical-align: inherit;">It remains to finish with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which displays information on the document line. </font><font style="vertical-align: inherit;">Here we will use the exact same logic as with the header of the document. </font><font style="vertical-align: inherit;">The choice of the Service will also be made through the capture context of the circuit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's first add a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segue</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with a name </font></font><b><code>rowOfOrderToServices</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that connects the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> document lines and a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with a list of Services. </font><font style="vertical-align: inherit;">We need to modify the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table View Controller a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit </font><font style="vertical-align: inherit;">so that we can use the closure. </font><font style="vertical-align: inherit;">First, add a closure variable:</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// ServicesTableViewController.swift // core-data-habrahabr-swift import UIKit import CoreData class ServicesTableViewController: UITableViewController, NSFetchedResultsControllerDelegate { typealias Select = (Service?) -&gt; () var didSelect: Select? // ‚Ä¶</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And, secondly, we will change the function of selecting the row of the list: </font></font><br><br><pre> <code class="objectivec hljs"> override func tableView(tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, didSelectRowAtIndexPath indexPath: <span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>) { let service = fetchedResultsController.objectAtIndexPath(indexPath) as? Service <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let dSelect = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.didSelect { dSelect(service) dismissViewControllerAnimated(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { performSegueWithIdentifier(<span class="hljs-string"><span class="hljs-string">"servicesToService"</span></span>, sender: service) } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Return back to </font></font><b><code>RowOfOrderViewController</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and implement the closure. </font><font style="vertical-align: inherit;">Here everything is based on the same principle as when choosing a customer.</font></font><br><pre> <code class="objectivec hljs"> @IBAction func choiceService(sender: AnyObject) { performSegueWithIdentifier(<span class="hljs-string"><span class="hljs-string">"rowOfOrderToServices"</span></span>, sender: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } override func prepareForSegue(segue: <span class="hljs-built_in"><span class="hljs-built_in">UIStoryboardSegue</span></span>, sender: AnyObject?) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"rowOfOrderToServices"</span></span> { let controller = segue.destinationViewController as! ServicesTableViewController controller.didSelect = {[unowned <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] (service) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let service = service { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.rowOfOrder!.service = service <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.textFieldService.text = service.name } } } }</code> </pre><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Text module RowOfOrderViewController.swift</font></font></b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// RowOfOrderViewController.swift // core-data-habrahabr-swift import UIKit class RowOfOrderViewController: UIViewController { var rowOfOrder: RowOfOrder? @IBAction func cancel(sender: AnyObject) { dismissViewControllerAnimated(true, completion: nil) } @IBAction func save(sender: AnyObject) { saveRow() dismissViewControllerAnimated(true, completion: nil) } @IBAction func choiceService(sender: AnyObject) { performSegueWithIdentifier("rowOfOrderToServices", sender: nil) } override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) { if segue.identifier == "rowOfOrderToServices" { let controller = segue.destinationViewController as! ServicesTableViewController controller.didSelect = {[unowned self] (service) in if let service = service { self.rowOfOrder!.service = service self.textFieldService.text = service.name } } } } @IBOutlet weak var textFieldService: UITextField! @IBOutlet weak var textFieldSum: UITextField! override func viewDidLoad() { super.viewDidLoad() if let rowOfOrder = rowOfOrder { textFieldService.text = rowOfOrder.service?.name textFieldSum.text = String(rowOfOrder.sum) } else { rowOfOrder = RowOfOrder() } } func saveRow() { if let rowOfOrder = rowOfOrder { rowOfOrder.sum = Float(textFieldSum.text!)! CoreDataManager.instance.saveContext() } } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, everything! </font><font style="vertical-align: inherit;">This completes the work with the document, let's check everything. </font></font><br><br><img src="https://habrastorage.org/files/def/fa5/9d8/deffa59d8e4e424aa8d076d8245657c7.png"><img src="https://habrastorage.org/files/181/6d2/9a9/1816d29a9581470bada1bfbe9fbe46ff.png"><img src="https://habrastorage.org/files/dfb/465/fcc/dfb465fcceca421e88e2b7cd023596d7.png"><img src="https://habrastorage.org/files/14b/05d/e1a/14b05de1a21f4cbf9d1ff8a76392105e.png"><img src="https://habrastorage.org/files/c1d/81c/f1e/c1d81cf1e9ea4964ad645d42ceba87ef.png"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Important note! </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We didn‚Äôt handle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> button clicks here </font><font style="vertical-align: inherit;">, which led to the following situation. </font><font style="vertical-align: inherit;">If we created a new document, and then decided not to save it and clicked </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , then it will remain hanging as a ‚Äúdraft‚Äù in our document journal, since from the current </font><b><font style="vertical-align: inherit;">Core Data</font></b><font style="vertical-align: inherit;"> context</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no one deleted it. </font><font style="vertical-align: inherit;">You can return to it and continue to fill out, or you can delete it forcibly. </font><font style="vertical-align: inherit;">But if you go back to the main menu, and then open the document journal again, there will be no drafts anymore, because when you open the journal, we read the data from the storage. </font><font style="vertical-align: inherit;">All the same applies to the lines of the document. </font><font style="vertical-align: inherit;">For our program, this behavior seems logical, well, at least - acceptable. </font><font style="vertical-align: inherit;">But perhaps this behavior is not at all what you want in your program. </font><font style="vertical-align: inherit;">In this case, you must implement your logic to respond to such events. </font><font style="vertical-align: inherit;">Do not forget that in any case, the behavior of the program should be absolutely clear and transparent for the user.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Document Report </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This section will be completely not big (in comparison with previous). </font><font style="vertical-align: inherit;">We have already managed to get acquainted with it a bit </font></font><b><code>NSFetchRequest</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, now let's take a closer look at it. </font><font style="vertical-align: inherit;">Let's immediately create a new </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table View Controller</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , create and assign a new class to it ( </font></font><b><code>ReportTableViewController</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">based on </font></font><b><code>UITableViewController</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><img src="https://habrastorage.org/files/858/a70/199/858a70199758404589c87519dcd4dd21.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We consider the work with </font></font><b><code>NSFetchRequest</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an example of a simple report that will display a list of documents executed but not paid for, sorted by date. </font><font style="vertical-align: inherit;">For this we will use two powerful tools that we have </font></font><b><code>NSFetchRequest</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><ul><li> <b><code>NSSortDescriptor</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - to sort the data </font></font></li><li> <b><code>NSPredicate</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - to set different selection conditions (filter). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Start by sorting the data, look at the following definition: </font></font><br><pre> <code class="objectivec hljs">var fetchRequest = <span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span>(entityName: <span class="hljs-string"><span class="hljs-string">"Order"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Sort Descriptor let sortDescriptor = NSSortDescriptor(key: "date", ascending: true) fetchRequest.sortDescriptors = [sortDescriptor] return fetchRequest }()</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we create a new data sorting object ( </font></font><b><code>NSSortDescriptor</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), passing it to the constructor a string containing the name of the sort field, and specify the desired sort direction ( </font></font><b><code>ascending</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><b><code>true</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ascending, </font></font><b><code>false</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- descending). </font><font style="vertical-align: inherit;">Notice that </font></font><b><code>NSFetchRequest</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we pass the sort object as an array to the object.</font></font> What does it mean?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, this is exactly - we can pass several sorting rules simultaneously in the form of an array. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also recall that as a sort field, you can specify composite fields ‚Äúthrough the point‚Äù (we did this when we sorted the rows of the table part of the document). </font><font style="vertical-align: inherit;">Let's add a second sorting object in order to sort the documents within the date by the name of the Customer.</font></font><br><pre> <code class="objectivec hljs"> var fetchRequest:<span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span> = { var fetchRequest = <span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span>(entityName: <span class="hljs-string"><span class="hljs-string">"Order"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Sort Descriptor let sortDescriptor1 = NSSortDescriptor(key: "date", ascending: true) let sortDescriptor2 = NSSortDescriptor(key: "customer.name", ascending: true) fetchRequest.sortDescriptors = [sortDescriptor1, sortDescriptor2] return fetchRequest }()</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually, this is all sorting. The only thing that still remind you - if you are actively using sorting, do not forget to think about the appropriateness of indexing the fields used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We turn to the mechanism of predicates. It uses a fairly simple syntax, which is a bit like SQL-like queries. The predicate is created and used as follows:</font></font><br><pre> <code class="objectivec hljs"> <span class="hljs-comment"><span class="hljs-comment">// Predicate let predicate = NSPredicate(format: "%K == %@", "made", true) fetchRequest.predicate = predicate</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A format string is passed to the constructor, followed by arguments. Depending on the format string, the number of parameters passed may vary. Let's take a closer look at the format string - it uses something like its own query language. " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% K</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " - means the name of the field (property) of the object, " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">% @</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " - the value of this field. Following are the arguments (actual values ‚Äã‚Äãthat need to be substituted into the selection), strictly in the same order of succession. That is, this format string means the following: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Order.made == true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use not only the operation </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">==</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; =</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! =</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and so on. </font><font style="vertical-align: inherit;">You can also use keywords such as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONTAINS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIKE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MATCHES</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BEGINSWITH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ENDSWITH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as well as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AND</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">You can also use regular expressions. </font><font style="vertical-align: inherit;">This is really a very powerful tool. </font><font style="vertical-align: inherit;">I will not list here all the possible options, they are well represented in the </font></font><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Predicates/Articles/pUsing.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">official documentation of Apple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">As arguments for the field name you can, as in</font></font><b><code>NSSortDescriptor</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, use composite fields ("through the point"). </font><font style="vertical-align: inherit;">But you cannot use several predicates at the same time; instead, you should use a more complex condition in a single predicate. </font><font style="vertical-align: inherit;">With this in mind, the final definition of the predicate in our report will be as follows:</font></font><br><pre> <code class="objectivec hljs"> var fetchRequest:<span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span> = { var fetchRequest = <span class="hljs-built_in"><span class="hljs-built_in">NSFetchRequest</span></span>(entityName: <span class="hljs-string"><span class="hljs-string">"Order"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Sort Descriptor let sortDescriptor1 = NSSortDescriptor(key: "date", ascending: true) let sortDescriptor2 = NSSortDescriptor(key: "customer.name", ascending: true) fetchRequest.sortDescriptors = [sortDescriptor1, sortDescriptor2] // Predicate let predicate = NSPredicate(format: "%K == %@ AND %K == %@", "made", true, "paid", false) fetchRequest.predicate = predicate return fetchRequest }()</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains only to implement the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UITableViewDataSource</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> protocol </font><font style="vertical-align: inherit;">(you already know how, nothing new here) and you can check it.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The text of the module ReportTableViewController.swift</font></font></b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// ReportTableViewController.swift // core-data-habrahabr-swift import UIKit import CoreData class ReportTableViewController: UITableViewController { var fetchRequest:NSFetchRequest = { var fetchRequest = NSFetchRequest(entityName: "Order") // Sort Descriptor let sortDescriptor1 = NSSortDescriptor(key: "date", ascending: true) let sortDescriptor2 = NSSortDescriptor(key: "customer.name", ascending: true) fetchRequest.sortDescriptors = [sortDescriptor1, sortDescriptor2] // Predicate let predicate = NSPredicate(format: "%K == %@ AND %K == %@", "made", true, "paid", false) fetchRequest.predicate = predicate return fetchRequest }() var report: [Order]? override func viewDidLoad() { super.viewDidLoad() do { report = try CoreDataManager.instance.managedObjectContext.executeFetchRequest(fetchRequest) as? [Order] } catch { print(error) } } // MARK: - Table View Data Source override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int { return 1 } override func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int { if let report = report { return report.count } else { return 0 } } override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell { let cell = UITableViewCell() if let report = report { let order = report[indexPath.row] let formatter = NSDateFormatter() formatter.dateFormat = "MMM d, yyyy" let nameOfCustomer = (order.customer == nil) ? "-- Unknown --" : (order.customer!.name!) cell.textLabel?.text = formatter.stringFromDate(order.date) + "\t" + nameOfCustomer } return cell } }</span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/files/3fe/f13/5ba/3fef135bab03462abf574c8a81ccfb3a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Everything works as it should, we received a list of documents according to the specified conditions. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Final Storyboard View</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/203/f66/543/203f665430974225a52c7cae9e04c69b.png"><br></div></div><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the example of a simple application, we examined all the main points of working with </font></font><b><code>Core Data</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and obtained, in a relatively short time, a fully functional application. </font><font style="vertical-align: inherit;">The design, of course, at least asks for refinement, but this publication had a different goal. </font><font style="vertical-align: inherit;">It is worth noting once again that all direct work with data, including the organization of the data warehouse and all possible checks for consistency, is hidden ‚Äúunder the hood‚Äù </font></font><b><code>Core Data</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we almost did not think about it, but worked with managed objects as with ordinary OOP objects. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope that I was able to quite clearly explain the basic techniques of working with </font></font><b><code>Core Data</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which, in my opinion, are necessary for any iOS developer. </font><font style="vertical-align: inherit;">It is great if you stopped being afraid and, at least a little bit, fell in love </font></font><b><code>Core Data</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font> Thanks for attention. <br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This project is on github</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/304586/">https://habr.com/ru/post/304586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304576/index.html">Standardization of records</a></li>
<li><a href="../304578/index.html">Automation in JunOS: writing scripts</a></li>
<li><a href="../304580/index.html">Security Week 26: Dumping data through a fan, iOS core decrypted, crypto-password on password archives</a></li>
<li><a href="../304582/index.html">The optimal solution for the organization of corporate cloud "turnkey"</a></li>
<li><a href="../304584/index.html">The official HTTP client for Yii 2 has been released</a></li>
<li><a href="../304590/index.html">Optimization of the web service tips for postal addresses and name</a></li>
<li><a href="../304594/index.html">systemd: getty-like service for htop</a></li>
<li><a href="../304596/index.html">Introducing 3CX v15 Release Candidate</a></li>
<li><a href="../304598/index.html">Design stages, mistakes and advantages</a></li>
<li><a href="../304600/index.html">We get a domain name, DNS and SSL certificate free then</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>