<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The transfer pattern scala.concurrent.Promise to the actor: usage features and alternatives</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of supporting various projects, I found myself several times in a situation in which, due to incorrect work with Promise there were pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The transfer pattern scala.concurrent.Promise to the actor: usage features and alternatives</h1><div class="post__text post__text-html js-mediator-article"><p> In the process of supporting various projects, I found myself several times in a situation in which, due to incorrect work with <code>Promise</code> there were problems in production.  Moreover, the pattern of this very wrong work was always the same, but it was hidden in different guises.  Moreover, the erroneous code was written by different people.  In addition, I haven‚Äôt really found a mention of the problem I want to cover in any article about working with <code>Promise</code> .  So I assume that many people forget about the problem, about which I will tell. </p><br><p>  Interesting to read a lot of examples of asynchronous code on Scala, with promises, futures and actors?  Welcome under the cut! </p><a name="habracut"></a><br><h2 id="nemnogo-o-future">  Little bit about the future </h2><br><p>  For a start, a little theory about <code>Future</code> as an introduction.  Those familiar with this type from the standard Scala library can safely skip this part. </p><br><p>  In Scala, <code>Future[T]</code> used to represent asynchronous computing.  Suppose we need to pull the value from the DBMS by key.  The synchronous signature for such a query would look something like this: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SyncKVStore</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">V</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>(key: <span class="hljs-type"><span class="hljs-type">K</span></span>): <span class="hljs-type"><span class="hljs-type">V</span></span> }</code> </pre> <br><p>  Then it could be used like this: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> store: <span class="hljs-type"><span class="hljs-type">SyncKVStore</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = ... <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = store.get(<span class="hljs-string"><span class="hljs-string">"1234"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// value   String</span></span></code> </pre> <br><p>  This approach has a drawback: the <code>get()</code> method can be blocking, and in view of the possible data transmission over the network for a relatively long time.  Let's try to make it non-blocking, then the treit will look like this: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">Future</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KVStore</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">V</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>(key: <span class="hljs-type"><span class="hljs-type">K</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">V</span></span>] }</code> </pre> <br><p>  It is possible that in order to correctly rewrite the implementation we will need to use an asynchronous driver for the DBMS we use.  For example, let's write the in-memory implementation on the map: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">ExecutionContext</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DummyKVStore</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">implicit ec: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ExecutionContext</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KVStore</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Future(...)       //      ExecutionContext def get(key: String): Future[String] = Future(map(key)) private val map = Map("1234" -&gt; "42", "42 -&gt; 13", "1a" -&gt; "b3") }</span></span></code> </pre> <br><p>  We can use the obtained value, for example, as follows: </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  -    ExecutionContext import scala.concurrent.ExecutionContext.Implicits.global val store = new DummyKVStore // map    ExecutionContext //        store.get("1234").map { value =&gt; log.info(value) //  DummyKVStore  42 }</span></span></code> </pre> <br><p>  Future has several useful asynchronous value processing methods, we will briefly describe some of them: </p><br><ul><li>  <code>map(f: A =&gt; B)</code> - upon completion of the futures, converts a successful result using the <code>f</code> function </li><li>  <code>flatMap(f: A =&gt; Future[B])</code> - also converts a successful result, but takes, in fact, an asynchronous function </li><li>  <code>foreach(f: A =&gt; Unit)</code> - upon successful completion, performs the function <code>f</code> , transferring to it the result of futures </li><li>  <code>onComplete(f: Try[A] =&gt; Unit)</code> is the same as <code>foreach</code> , but performs the function on any termination, including  with an error </li></ul><br><p>  It is also worth clarifying that all of these methods also accept the <code>implicit ec: ExecutionContext</code> parameter, which contains information about the execution context of the futures, as the name suggests. </p><br><p>  For more information about futures, you can read, for example, <a href="https://habrahabr.ru/post/233555/">here</a> . </p><br><h2 id="promise-eschyo-para-abzacev-teorii">  Promise: a couple more paragraphs of the theory </h2><br><p>  So what is a <code>Promise</code> ?  In fact, this is a typed write-once container containing futures: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p = <span class="hljs-type"><span class="hljs-type">Promise</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]() p.success(<span class="hljs-number"><span class="hljs-number">42</span></span>) p.future <span class="hljs-comment"><span class="hljs-comment">//  Future   42</span></span></code> </pre> <br><p>  It has many methods to complete the futures, for example: </p><br><ul><li>  <code>success(t: T)</code> - ends the futures with the result <code>t</code> </li><li>  <code>failure(e: Throwable)</code> - faylit futures with <code>e</code> </li><li>  <code>complete(try: Try[T])</code> - ends the futures if <code>try</code> - <code>Success</code> ;  feilit if failure </li><li>  <code>completeWith(future: Future[T])</code> - completes the internal futures when the <code>future</code> ends </li></ul><br><p>  Thus, promises can be used to create futures. </p><br><h2 id="promise-pogruzhaemsya-v-praktiku-ispolzovaniya">  Promise: immersed in the practice of using </h2><br><p>  Imagine that we want to implement our own asynchronous API on top of a ready-made asynchronous Java API on callbacks.  Since the result that we want to return in the futures is available only in a callback, we cannot directly use the <code>Future.apply()</code> method.  This is where <code>Promise</code> will help us.  In <a href="https://stackoverflow.com/a/13388618/5053865">this answer to SO,</a> there would seem to be a great example of using <code>Promise</code> in the real world: </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeHTTPCall</span></span></span></span>(request: <span class="hljs-type"><span class="hljs-type">Request</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Response</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p = <span class="hljs-type"><span class="hljs-type">Promise</span></span>[<span class="hljs-type"><span class="hljs-type">Response</span></span>]() registerOnCompleteCallback { buffer =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response = makeResponse(buffer) p.success(response) } p.future }</code> </pre> <br><p>  Well, we use this function in our new web service, for example, on Akka-HTTP.  First, let's connect the dependency to SBT: </p><br><pre> <code class="scala hljs">libraryDependencies += <span class="hljs-string"><span class="hljs-string">"com.typesafe.akka"</span></span> %% <span class="hljs-string"><span class="hljs-string">"akka-http"</span></span> % <span class="hljs-string"><span class="hljs-string">"10.0.10"</span></span></code> </pre> <br><p>  And write the service code: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.actor.<span class="hljs-type"><span class="hljs-type">ActorSystem</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.http.scaladsl.<span class="hljs-type"><span class="hljs-type">Http</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.http.scaladsl.server.<span class="hljs-type"><span class="hljs-type">Directives</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.http.scaladsl.marshalling.<span class="hljs-type"><span class="hljs-type">GenericMarshallers</span></span>.futureMarshaller <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">ExecutionContext</span></span>.<span class="hljs-type"><span class="hljs-type">Implicits</span></span>.global <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        Akka-HTTP implicit val system = ActorSystem() val store = new DummyKVStore val route = //   GET /value/$id (get &amp; path("value" / IntNumber)) { id =&gt; complete { for { value &lt;- store.get(id) response &lt;- makeHTTPCall(new RequestImpl(value)) } yield response } } Http().bindAndHandle(route, "localhost", 80) }</span></span></code> </pre> <br><p>  Note: the <code>complete()</code> method from Akka-HTTP can accept <code>Future[T]</code> , for this <code>futureMarshaller</code> imported.  He will respond to an HTTP request after the end of the futures. </p><br><p>  We also decided to drop a task, which will send the value for some key to all emails from our database via some HTTP API.  Moreover, it does this in a cycle: after the distribution is completed, all clients begin to do it again. </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allEmails</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendEmails</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> ec: <span class="hljs-type"><span class="hljs-type">ExecutionContext</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Unit</span></span>] = { <span class="hljs-type"><span class="hljs-type">Future</span></span>.sequence { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { email &lt;- allEmails } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { value &lt;- store.get(<span class="hljs-string"><span class="hljs-string">"42"</span></span>) response &lt;- makeHTTPCall(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SendMailRequest</span></span>(email, value)) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> response }.flatMap(_ =&gt; sendEmails) <span class="hljs-comment"><span class="hljs-comment">//          }</span></span></code> </pre> <br><p>  Put it all in production.  However, in a couple of days our API consumers come to us and complain about the periodic service rollbacks by timeout.  And after three days, we discover that the task has stopped sending mail!  What's the matter? </p><br><p>  In the log, we see the following spectra: </p><br><pre> <code class="hljs scala">some.<span class="hljs-keyword"><span class="hljs-keyword">package</span></span>.<span class="hljs-type"><span class="hljs-type">SomeException</span></span> at some.<span class="hljs-keyword"><span class="hljs-keyword">package</span></span>.makeResponse(...) at some.<span class="hljs-keyword"><span class="hljs-keyword">package</span></span>.$anonfun$makeHTTPCall$<span class="hljs-number"><span class="hljs-number">1</span></span>(...) ...</code> </pre> <br><p>  It turns out that the <code>makeResponse()</code> method <code>makeResponse()</code> thrown an exception.  Looking at the sources of <code>makeHTTPCall()</code> , you can see that in this case, the futures that it returns never end! </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p = <span class="hljs-type"><span class="hljs-type">Promise</span></span>[<span class="hljs-type"><span class="hljs-type">Response</span></span>] registerOnCompleteCallback(buffer =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response = makeResponse(buffer) <span class="hljs-comment"><span class="hljs-comment">//     p.success(response) //  success()   }) p.future</span></span></code> </pre> <br><p>  That is why our API fell off on a timeout, and the mailing cycle stopped working.  Alas, in Scala we cannot program without thinking that any function can return an event as <a href="https://twitter.com/jdegoes/status/932999912488235010">many want</a> ... </p><br><p>  So, we recall that the <code>Try.apply()</code> method can intercept exceptions and return <code>Success</code> with a value, or <code>Failure</code> with an exception thrown.  Fix the lambda body in a naive way and send a review to the code: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.util._ <span class="hljs-type"><span class="hljs-type">Try</span></span>(makeResponse(buffer)) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Success</span></span>(r) =&gt; p.success(r) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Failure</span></span>(e) =&gt; p.failure(e) }</code> </pre> <br><p>  However, the review tells us that the promise has a <code>complete()</code> method, which itself does the same thing that we wrote with our hands: </p><br><pre> <code class="scala hljs">p.complete(<span class="hljs-type"><span class="hljs-type">Try</span></span>(makeResponse(buffer))</code> </pre> <br><p>  So, what we learned about the <code>Promise</code> : </p><br><ol><li>  If the <code>Promise</code> declared at the beginning of the method, and its futures are returned at the end, this does not mean that this futures will ever end. </li><li>  It would be useful to consider <code>Promise</code> as a resource that must always be closed.  However, promis is usually declared and closed in different threads, so using it as a resource using any standard language constructs ( <code>try-finally</code> ), or even libraries ( <code>scala-arm</code> ) is problematic. </li></ol><br><p>  Perhaps someone will say that this is a far-fetched example and in real life no one forgets to close promises?  Well, for such skeptics, I have the answer in the form of several real bugs / PRs in Akka related to inter-promises that are uncomplicated in certain situations: </p><br><ol><li>  <a href="https://github.com/akka/akka/issues/23118">QueueSource does not complete onComplete future on abrupt termination</a> </li><li>  <a href="https://github.com/akka/akka/issues/23726">IgnoreSink doesn‚Äôt complete mat</a> </li><li>  <a href="https://github.com/akka/akka/pull/23533">Calling for a complete complementary future</a> </li></ol><br><p>  In addition, it is not always so simple and obvious, as in this example. </p><br><h2 id="posledniy-kusochek-teorii-nebolshoe-vvedenie-v-aktory">  The last piece of theory: a small introduction to the actors </h2><br><p>  Familiar with the actors can skip this part. </p><br><p>  We will need some knowledge of the Akka actors later on in this article.  Let's connect the akka-actor module to our project, an example for SBT: </p><br><pre> <code class="scala hljs">libraryDependencies += <span class="hljs-string"><span class="hljs-string">"com.typesafe.akka"</span></span> %% <span class="hljs-string"><span class="hljs-string">"akka-actor"</span></span> % <span class="hljs-string"><span class="hljs-string">"2.5.7"</span></span></code> </pre> <br><p>  Actor in Akka is an object with some behavior, asynchronously receiving messages.  By default, behavior is defined in the <code>receive</code> method: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.actor._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.actor.<span class="hljs-type"><span class="hljs-type">Actor</span></span>.<span class="hljs-type"><span class="hljs-type">Receive</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> log: <span class="hljs-type"><span class="hljs-type">Logger</span></span> = ourLogObject() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloRequest</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HelloActor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Receive --     def receive: Receive = { //    HelloRequest,    "hello!" case HelloRequest =&gt; log.info("hello!") } } //       val system = ActorSystem() //       val actor: ActorRef = system.actorOf(Props(new HelloActor)) //   "hello!"   actor ! HelloRequest</span></span></code> </pre> <br><p>  After creation, the actor is available not directly, but through a proxy called <code>ActorRef</code> .  Through this proxy, you can asynchronously send messages using the method <code>!</code>  (alias for <code>tell</code> ), and these messages will be processed by the method that determines the behavior of the actor.  Messages must be serializable, so often a <code>case object</code> created for messages (with no message parameters) or a <code>case class</code> .  The actor can process at most one message at a time, so it can be used as a synchronization primitive as well. </p><br><p>  There is one more important point: the actor can change its function of behavior, that is, in fact, the processing of messages.  To do this, you need to call the <code>context.become(newReceive)</code> method in the actor, where <code>newReceive</code> is a <code>Receive</code> type parameter.  After that, starting with the next message, the processing by the function <code>newReceive</code> will begin instead of the default <code>receive</code> . </p><br><h2 id="soedinyaem-chasti-patterna-peredayom-promis-v-aktor">  We connect parts of a pattern: we transfer promis to the actor </h2><br><p>  So let's move on to the next example. </p><br><p>  Suppose we need to write a client for some service.  For example, for booking.  Suppose we want to be able to get hotel information by id. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hotel</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-class"><span class="hljs-params">, name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, country: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookingClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHotel</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Hotel</span></span>] }</code> </pre> <br><p>  Now you need to define a method that will access the booking API and process the response.  For this we use the asynchronous HTTP client of the Akka-HTTP library.  Let's connect it by dependency: </p><br><pre> <code class="scala hljs">libraryDependencies ++= <span class="hljs-string"><span class="hljs-string">"com.typesafe.akka"</span></span> %% <span class="hljs-string"><span class="hljs-string">"akka-http"</span></span> % <span class="hljs-string"><span class="hljs-string">"10.0.10"</span></span></code> </pre> <br><p>  They want to run our method with a fairly large RPS for a short time, and the response time is not very important.  The Akka-HTTP client has a feature: <a href="http/client-side/pool-overflow.html">it does not allow to run more in parallel than akka.http.host-connection-pool.max-connections requests</a> .  We will use an extremely simple solution: we will make it so that all requests go through the actor, that is, into one stream (the actual solution was a bit more complicated, but it does not matter for our example).  Since we want to return the futures, we will create a promise and pass it to the actor, and then in the actor we compile it. </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// implicit system  materializer     Akka-HTTP; ec   Future.foreach() class HttpBookingClient(baseUri: String)(implicit system: ActorSystem, materializer: ActorMaterializer, ec: ExecutionContext) { override def getHotel(id: Long): Future[Hotel] = { val p = Promise[Hotel]() actor ! Request(id, p) p.future } private val actor = system.actorOf(Props(new ClientActor)) private case class Request(id: Long, p: Promise[Hotel]) private case object Completed private class ClientActor extends Actor { //   ,      override def receive: Receive = { case Request(id, p) =&gt; val uri = Uri(baseUri).withQuery(Query("id" -&gt; id.toString)) val eventual = Http().singleRequest(HttpRequest(uri = uri)) //        API eventual.foreach { response =&gt; p.completeWith { val unmarshalled = Unmarshal(response.entity) //       200,      response.status match { case StatusCodes.OK =&gt; //   Unmarshaller[Hotel], ,   akka-http-spray-json //          unmarshalled.to[Hotel] case _ =&gt; unmarshalled.to[String].flatMap(error =&gt; Future.failed(new Exception(error))) } }) } p.future.onComplete(_ =&gt; self ! Completed) //      running context.become(running) } //  ,       //      private def running: Receive = { case request: Request =&gt; //       ,   ;    self ! request case Completed =&gt; //       context.become(receive) } } }</span></span></code> </pre> <br><p>  And again, after putting it out, everything went well at first, but then we received a bug report with the heading "The <code>getHotel()</code> method returns incomplete futures".  Why did this happen?  It looks like we have foreseen everything, used the <code>completeWith()</code> method on the whole body of the lambda ... Nevertheless, under certain conditions, the futures still stick. </p><br><p>  The thing is that the lambda passed to the <code>foreach()</code> method will start only when the eventual <code>eventual</code> successfully complete.  Thus, if this futures spilled (for example, the grid fell off), the promis will never fail to complete! </p><br><p>  It can be assumed that the fix is ‚Äã‚Äãrelatively trivial: instead of <code>foreach()</code> you need to use <code>onComplete()</code> , and in the lambda passed to it, handle the error.  Like that: </p><br><pre> <code class="scala hljs">eventual.onComplete { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Success</span></span>(response) =&gt; <span class="hljs-comment"><span class="hljs-comment">//    ,     foreach... case Failure(e) =&gt; p.failure(e) }</span></span></code> </pre> <br><p>  This will solve the problem of sticking futures specifically because of the eventual <code>eventual</code> , but it does not solve all possible problems with sticking futures transmitted in this way. </p><br><p>  For the sake of simplicity, we will implement a simpler and at the same time more general example of the transfer of promis to the actor to complete the futures: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">arg: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, p: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Promise</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GimmeActor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actor: <span class="hljs-type"><span class="hljs-type">ActorRef</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span></span>(arg: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p = <span class="hljs-type"><span class="hljs-type">Promise</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]() actor ! <span class="hljs-type"><span class="hljs-type">Request</span></span>(arg, p) p.future } }</code> </pre> <br><p>  By the way, the <code>funcion()</code> body type construction is often found, for example, in Akka source code and other libraries.  In the same Akka you can find several dozen uses of <code>Promise</code> , written according to this pattern: </p><br><ol><li>  Create <code>Promise</code> </li><li>  Passing it with one of the arguments of the asynchronous function (moreover, in Akka sources, this is often just the <code>actor.tell()</code> call) </li><li>  Return the field to the <code>future</code> created <code>Promise</code> . </li></ol><br><p>  A couple of examples for clarity: </p><br><ol><li>  <a href="https://github.com/akka/akka/blob/20618844ec9674f8361be7b7c49d7207b92acc15/akka-remote/src/main/scala/akka/remote/artery/Control.scala">Here</a> in the L129 callback, the transfer of <code>p</code> to the actor takes place. </li><li>  And <a href="https://github.com/akka/akka/blob/20618844ec9674f8361be7b7c49d7207b92acc15/akka-cluster-sharding/src/main/scala/akka/cluster/sharding/RemoveInternalClusterShardingData.scala">here the</a> promise is sent directly in the parameters for creating the actor. </li></ol><br><p>  There are at least a couple of problems with this pattern. </p><br><ul><li>  Two examples of classes: </li></ul><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DoesntEvenKnowAboutRequest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Receive</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">PoisonPill</span></span> =&gt; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlesRequestWrongWay</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Receive</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Request</span></span>(arg, p) =&gt; } }</code> </pre> <br><p>  In both cases, the promise will obviously not be completed. </p><br><p>  On the one hand, it can be said that these examples are too synthetic.  On the other hand, the compiler does not protect us from such errors.  In addition, this problem must be remembered not only for actors, but also for the transfer of promises to ordinary asynchronous functions. </p><br><ul><li>  Let the implementation of the actor be written correctly and it always completes the promise when it receives the Request: </li></ul><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlwaysCompletesRequest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Receive</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Request</span></span>(arg, p) =&gt; p.success(<span class="hljs-string"><span class="hljs-string">"42"</span></span>) }</code> </pre> <br><p>  We are fine, our services using this actor work fine.  However, we decided to start the service on one server at the beginning. </p><br><p>  But now, the company is growing, the number of users too, and with it the number of requests to our actor.  At peak loads, the actor stopped keeping up with the flow of messages in the required time and we decided to do horizontal scaling: to run <code>AlwaysCompletesRequest</code> on different nodes in the cluster.  To organize a cluster, you need to use akka-cluster, however, for simplicity, we will not organize a cluster in the article, but simply turn to one remote actor <code>AlwaysCompletesRequest</code> . </p><br><p>  We need to create an <code>ActorSystem</code> with the support of akka-remote on both JVMs: accessing the actor and hosting it.  To do this, add the following configuration to the <code>application.conf</code> both services: </p><br><pre> <code class="scala hljs">akka { actor { provider = remote } remote { enabled-transports = [<span class="hljs-string"><span class="hljs-string">"akka.remote.netty.tcp"</span></span>] netty.tcp { hostname = <span class="hljs-string"><span class="hljs-string">"some-hostname"</span></span> port = <span class="hljs-number"><span class="hljs-number">2552</span></span> #     ;      -  } } }</code> </pre> <br><p>  You also need to add a dependence on akka-remote for both services, an example for SBT: </p><br><pre> <code class="scala hljs">libraryDependencies += <span class="hljs-string"><span class="hljs-string">"com.typesafe.akka"</span></span> %% <span class="hljs-string"><span class="hljs-string">"akka-remote"</span></span> % <span class="hljs-string"><span class="hljs-string">"2.5.7"</span></span></code> </pre> <br><p>  Now create an actor on the server: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> system = <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span>(<span class="hljs-string"><span class="hljs-string">"server"</span></span>) system.actorOf(<span class="hljs-type"><span class="hljs-type">Props</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AlwaysCompletesRequest</span></span>), <span class="hljs-string"><span class="hljs-string">"always-complete-actor"</span></span>)</code> </pre> <br><p>  Then get it on the client: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> system = <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span>(<span class="hljs-string"><span class="hljs-string">"client"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actor = system.actorSelection(<span class="hljs-string"><span class="hljs-string">"akka.tcp://server@some-hostname:2552/user/promise-actor"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> gimme = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">GimmeActor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actor: <span class="hljs-type"><span class="hljs-type">ActorRef</span></span> = actor } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> future = gimme.function(<span class="hljs-string"><span class="hljs-string">"give me 42, please!"</span></span>)</code> </pre> <br><p>  And we started the server together with the client ... And immediately got stuck futures! </p><br><p>  In the logs we see the following exception: </p><br><pre> <code class="scala hljs">akka.remote.<span class="hljs-type"><span class="hljs-type">MessageSerializer</span></span>$<span class="hljs-type"><span class="hljs-type">SerializationException</span></span>: <span class="hljs-type"><span class="hljs-type">Failed</span></span> to serialize remote message [<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">akka</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">actor</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActorSelectionMessage</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">serializer</span></span></span><span class="hljs-class"> [class akka.remote.serialization.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MessageContainerSerializer</span></span></span><span class="hljs-class">]. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Caused</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span></span>: java.io.<span class="hljs-type"><span class="hljs-type">NotSerializableException</span></span>: scala.concurrent.impl.<span class="hljs-type"><span class="hljs-type">CallbackRunnable</span></span></code> </pre> <br><p>  Thus, when we try to send a promise to a remote actor, we quite predictably received a promis serialization error.  In fact, even if we could serialize and transmit the promise, it would only be compressed on the remote JVM, and in our JVM it would remain stuck.  Thus, the transfer of promis to the actor works only with local message passing, that is, this pattern of sending promis to the actor does not scale well. </p><br><h2 id="varianty-resheniya-problem-patterna">  Pattern Problem Solution </h2><br><h3 id="zavershenie-po-taymautu">  Timed out </h3><br><p>  As the most obvious solution to the problem - timeless promise.  Through Akka, you can do this, for example, as follows: </p><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  .seconds import scala.concurrent.duration._ val system: ActorSystem = ... val timeout = 2.seconds //         system.scheduler.scheduleOnce(timeout)(p.tryFailure(new SomeTimeoutException))</span></span></code> </pre> <br><p>  The <code>Promise</code> methods that we discussed earlier are completed successfully only if the <code>Promise</code> not completed earlier.  If these methods are called already after the completion of the promise, they throw an <code>IllegalStateException</code> .  For cases when it is necessary to try to complete the promise, when it has probably already been completed, there are methods similar to those considered, but with the <code>try</code> prefix in the name.  They return <code>true</code> if they completed the promise themselves;  <code>false</code> if the promise was completed before calling this method. </p><br><p>  Also, as an option, you can fake on the timeout right inside the actor: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlwaysAlwaysCompletesRequest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Receive</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Request</span></span>(str, p) =&gt; p.completeWith(someFuture()) context.scheduler.scheduleOnce(timeout)(self ! <span class="hljs-type"><span class="hljs-type">Timeout</span></span>(p)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Timeout</span></span>(p) =&gt; p.tryFailure(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SomeTimeoutException</span></span>) } }</code> </pre> <br><p>  Of course, this option does not solve the problem of scalability. </p><br><h3 id="ask-pattern">  ask pattern </h3><br><p>  It was possible, of course, to do otherwise.  For example, use the ask-pattern, which requires the transmission of a timeout: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.pattern.ask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.util.<span class="hljs-type"><span class="hljs-type">Timeout</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">arg: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">arg: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> timeout = <span class="hljs-type"><span class="hljs-type">Timeout</span></span>(<span class="hljs-number"><span class="hljs-number">2.</span></span>seconds) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> any: <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>] = actor ? <span class="hljs-type"><span class="hljs-type">Request</span></span>(arg) <span class="hljs-comment"><span class="hljs-comment">// timeout    ? any.mapTo[String] }</span></span></code> </pre> <br><p>  In this case, the implementation of the actor should be somewhat different: instead of completing the promise, you need to respond to the message: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AlwaysCompletesRequest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Receive</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Request</span></span>(arg) =&gt; <span class="hljs-comment"><span class="hljs-comment">//   :       sender() ! "42" }</span></span></code> </pre> <br><p>  However, the ease of implementation is fraught with danger. </p><br><ol><li>  Now the futures "leaving" the actor are not type safe.  The compiler will be able to catch us by the hand if we try to close the promise with a value of the wrong type.  However, it will not protect us in the case of a conversion from <code>Any</code> . </li><li>  This argument may seem somewhat subjective, but I can not disagree with him.  It is often considered that <code>tell</code> design is usually easier to understand for an actor model. </li><li> <code>ask</code> " "  ,      akka-remote,    ,    ""    <code>ActorRef</code> (,     remote,    ).    <a href="https://doc.akka.io/docs/akka/2.4.20/java/untyped-actors.html">  Akka </a>  <code>tell</code>  ,   <code>ask</code> ,     . </li></ol><br><h3 id="ispolzovat-akka-typed">  Akka Typed </h3><br><p>    , ask-   ,     ,        .    Akka   ask-  <code>Future[Any]</code> . ,         ,       : </p><br><pre> <code class="scala hljs">(actor ? <span class="hljs-type"><span class="hljs-type">Request</span></span>(arg)).mapTo[<span class="hljs-type"><span class="hljs-type">String</span></span>]</code> </pre> <br><p>  ,     ,   <code>String</code> ,  .            Akka Typed.  : </p><br><pre> <code class="scala hljs">libraryDependencies += <span class="hljs-string"><span class="hljs-string">"com.typesafe.akka"</span></span> %% <span class="hljs-string"><span class="hljs-string">"akka-typed"</span></span> % <span class="hljs-string"><span class="hljs-string">"2.5.7"</span></span></code> </pre> <br><p>     ,    : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.typed._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.typed.scaladsl.<span class="hljs-type"><span class="hljs-type">Actor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.typed.scaladsl.<span class="hljs-type"><span class="hljs-type">AskPattern</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.util.<span class="hljs-type"><span class="hljs-type">Timeout</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.<span class="hljs-type"><span class="hljs-type">Future</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.duration._ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">arg: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, replyTo: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ActorRef</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeSafeActor</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Actor</span></span>.immutable[<span class="hljs-type"><span class="hljs-type">Request</span></span>] { (_, msg) =&gt; msg.replyTo ! <span class="hljs-string"><span class="hljs-string">"42"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    :        Actor.same } val system: ActorSystem[Request] = ActorSystem(typeSafeActor, "type-safe-actor") def function(arg: String): Future[String] = { implicit val timeout: Timeout = Timeout(2.seconds) system ? (Request(arg, _)) }</span></span></code> </pre> <br><p>    . ,       ,     2.  ,        - API   " ". </p><br><h3 id="perepisat-vsyo-v-tch-kod-klientov-na-aktory">  ,  ..  ,   </h3><br><p>         , , - ,        <code>ActorSystem</code> .     : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">hotel: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Hotel</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CallingActor</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">actor: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ActorRef</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Actor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Receive</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> response: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; doSomethingWithActorResponse(response) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> request: <span class="hljs-type"><span class="hljs-type">Request</span></span> =&gt; actor ! request <span class="hljs-comment"><span class="hljs-comment">//         } } //   class AlwaysCompletesRequest extends Actor { def receive: Receive = { case Request(arg) =&gt; //    sender() ! "42" }</span></span></code> </pre> <br><p>            ,        .    API     ,        . </p><br><h3 id="ostavit-vsyo-kak-est">  ,   </h3><br><p>    Akka    ,         .     ,    ,    ,      : <strong>  100%-,    100%-  ,   , </strong> .        ,     ,       .  ,  ,         ,       . </p><br><p>        ,        ,        ,     . ,               .     ,   : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Receive</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Request</span></span>(id, p) =&gt; p.completeWith(doRequest(id)) p.future.onComplete(self ! <span class="hljs-type"><span class="hljs-type">Completed</span></span>) context.become(running) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doRequest</span></span></span></span>(id: <span class="hljs-type"><span class="hljs-type">Long</span></span>): <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Hotel</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> uri = <span class="hljs-type"><span class="hljs-type">Uri</span></span>(baseUri).withQuery(<span class="hljs-type"><span class="hljs-type">Query</span></span>(<span class="hljs-string"><span class="hljs-string">"id"</span></span> -&gt; id.toString)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> eventual = <span class="hljs-type"><span class="hljs-type">Http</span></span>().singleRequest(<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>(<span class="hljs-type"><span class="hljs-type">Uri</span></span>(uri = uri))) eventual.flatMap { response =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> unmarshalled = <span class="hljs-type"><span class="hljs-type">Unmarshal</span></span>(response.entity) response.code <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">StatusCodes</span></span>.<span class="hljs-type"><span class="hljs-type">OK</span></span> =&gt; unmarshalled.to[<span class="hljs-type"><span class="hljs-type">Hotel</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-type"><span class="hljs-type">Future</span></span>.failed(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Exception</span></span>(unmarshalled.to[<span class="hljs-type"><span class="hljs-type">String</span></span>])) } } }</code> </pre> <br><p>       : </p><br><ol><li>      ; </li><li>     API      <code>flatMap</code> ,     <code>onComplete</code> ; </li><li>   -         Akka-HTTP. </li></ol><br><p>           ,     <code>actor.tell()</code> . </p><br><p>       : </p><br><ul><li>  ‚Äî       ,     JVM. </li><li> ask/tell ‚Äî  Akka,      . </li><li> : <br> <code>+</code> ‚Äî    ; <br> ¬± ‚Äî   , ,  ,  ;      ; <br> <code>-</code> ‚Äî        . </li><li>   ‚Äî     ( ). </li><li>   ‚Äî    API,      typed ask. </li><li>  API ‚Äî   :  ,    ,       . </li></ul><br><table><thead><tr><th></th><th>  </th><th> ask </th><th> typed ask </th><th>    </th><th> promise </th></tr></thead><tbody><tr><td>  </td><td>  - </td><td>  + </td><td>  + </td><td>  + </td><td>  - </td></tr><tr><td> ask/tell </td><td> tell </td><td> ask </td><td> ask </td><td> tell </td><td> tell </td></tr><tr><td>  </td><td> ¬± </td><td>  - </td><td>  + </td><td> ¬± </td><td> ¬± </td></tr><tr><td>   </td><td>  + </td><td>  + </td><td>  + </td><td>  + </td><td>  - </td></tr><tr><td>   </td><td>  + </td><td>  + </td><td>  - </td><td>  + </td><td>  + </td></tr><tr><td>  API </td><td>  + </td><td>  + </td><td>  + </td><td>  - </td><td>  + </td></tr></tbody></table><br><p>  ,   ,                . </p><br><p>    ,      ,     ,   ,  . ,     , : </p><br><ol><li>        ,     ; </li><li>           , ,   ,  ; </li><li>             . </li></ol><br><p> ,              . </p><br><p>   -          ,     ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/344692/">https://habr.com/ru/post/344692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344680/index.html">5-minute guide to esoteric programming languages: try to classify them</a></li>
<li><a href="../344682/index.html">Error on the site ... What to do?</a></li>
<li><a href="../344684/index.html">We learn the car to understand languages</a></li>
<li><a href="../344686/index.html">Tanchiki in the console, the second article: "It is time to redo everything!"</a></li>
<li><a href="../344690/index.html">Tutorial on the Unreal Engine. Part 5: How to create a simple game</a></li>
<li><a href="../344694/index.html">Deploy Parallels RAS to Microsoft Azure in half an hour</a></li>
<li><a href="../344696/index.html">Guide to writing secure PHP applications in 2018</a></li>
<li><a href="../344700/index.html">ATOL Online: a look from the data center</a></li>
<li><a href="../344702/index.html">What you need to know to become a system architect</a></li>
<li><a href="../344704/index.html">Installing the HA Master Kubernetes Cluster with Kubespray</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>