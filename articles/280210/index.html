<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About Go functionality</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How object oriented Go has been repeatedly and emotionally discussed. Now let's try to evaluate how functional it is. Note immediately that the compil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About Go functionality</h1><div class="post__text post__text-html js-mediator-article">  How object oriented Go has been repeatedly and emotionally discussed.  Now let's try to evaluate how functional it is.  Note immediately that the compiler does not optimize tail recursion.  Why?  ‚ÄúIt is not necessary in a language with cycles.  When a programmer writes a recursive code, he wants to represent the call stack or he writes a cycle. ‚ÄùNotes Russ Cox in his correspondence.  In the language, however, there are full-fledged lambda, closure, recursive types and a number of features.  Let's try to apply them in a functional manner.  The examples seem synthetic because firstly they are written immediately executed in the sandbox and written in a procedural language, secondly.  It is supposed to be familiar with both Go and functional programming, explanations are few but the code is commented. <br><a name="habracut"></a><br>  Closure, closure implemented in the language in the classical and full. <br>  For example, a lazy recursive sequence can be obtained as <br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(source </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, permutation </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// lambda source = permutation(source) // source return source } }</span></span></code> </pre> <br>  Simple variator for pseudo-random numbers <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mutate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">1664525</span></span>*j + <span class="hljs-number"><span class="hljs-number">1013904223</span></span>) % <span class="hljs-number"><span class="hljs-number">2147483647</span></span> }</code> </pre><br>  And here is our random number generator <br><pre> <code class="go hljs">next := produce(<span class="hljs-number"><span class="hljs-number">1</span></span>, mutate) next()</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Working example</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produce</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(source </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, permutation </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// lambda source = permutation(source) // source return source } } //     func mutate(j int) int { return (1664525*j + 1013904223) % 2147483647 } func main() { next := produce(1, mutate) //      fmt.Println(next()) fmt.Println(next()) fmt.Println(next()) fmt.Println(next()) fmt.Println(next()) }</span></span></code> </pre><br></div></div>  <a href="http://play.golang.org/p/fG9KWlyBjU">Try in sandbox</a> <br>  Currying.  currying, applying a function to one of the arguments is not generally implemented.  Particular problems are solved, however.  For example, the deferred call function of the standard library time has the signature <i>func AfterFunc (d Duration, f func ()) * Timer</i> takes the argument <i>func (),</i> and we would like to pass something more parameterized to <i>func (arg MyType)</i> .  And we can do it like this. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyType <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-comment"><span class="hljs-comment">//  func (arg MyType) JustPrint(){ //  fmt.Println(arg) }</span></span></code> </pre><br>  a method in Go is a function that takes the first argument of its beneficiary <br>  The expression <i>MyType.JustPrint</i> will give us this function with the signature <i>func (arg MyType)</i> , which we can apply to the argument <i>MyType.JustPrint ("Eat me")</i> <br>  In contrast, the expression <i>arg.JustPrint</i> will give us the <i>JustPrint</i> function applied to <i>arg</i> with the signature <i>func ()</i> which we can pass to our alarm clock <br><pre> <code class="go hljs">timer := time.AfterFunc(<span class="hljs-number"><span class="hljs-number">50</span></span> * time.Millisecond, arg.JustPrint)</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Working example</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MyType <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-comment"><span class="hljs-comment">//  func (arg MyType) JustPrint() { //  fmt.Println(arg) } func main() { arg := MyType("Hello") //  time.AfterFunc(50*time.Millisecond, arg.JustPrint) arg = "By" time.AfterFunc(75*time.Millisecond, arg.JustPrint) time.Sleep(100 * time.Millisecond) }</span></span></code> </pre><br></div></div>  <a href="http://play.golang.org/p/56adEsAaVt">Try in the sandbox.</a> <br>  Continuation, continuation as a first-class object is not implemented with the elegance that scneme has.  Meanwhile, the built-in function <i>panic () is an</i> approximate analogue of long_jump capable of interrupting calculations and returning the achieved result (for example, an error) to the place from which the call was made.  The construction of <i>panic (), defer recover (),</i> in addition to exception handling, can be used, for example, for end-to-end output from recursion that has gone too deep (as noted and done in the <i>encoding.json</i> package).  In this sense, the design is first class, not exclusive.  Exiting unnecessary recursion, it is worth emphasizing, this is a classic application of continuation. <br>  Here is a straightforward, not optimized (not to be used in production !!) recursive function giving n-th Fibonacci number as the sum of the previous ones. <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> } first := Fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) second := Fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first &gt; max { <span class="hljs-comment"><span class="hljs-comment">//     panic(second) //       } return first + second }</span></span></code> </pre><br>  So we will call it with the continuation (call / cc) wanting to get the n-th Fibonacci number, unless it is more than max <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallFib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  res = r.(int) //  } }() res = Fib(n) return }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">A working example.</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> } first := Fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) second := Fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first &gt; max { <span class="hljs-comment"><span class="hljs-comment">//     panic(second) //       } return first + second } func CallFib(n int) (res int) { defer func() { if r := recover(); r != nil { //  res = r.(int) //  } }() res = Fib(n) return } func main() { fmt.Println(CallFib(10)) //  fmt.Println(CallFib(100000)) // fmt.Println(" ") }</span></span></code> </pre><br></div></div>  <a href="http://play.golang.org/p/_szZS3BLQO">Try in the sandbox.</a> <br>  Monads in the understanding of Haskell procedural language is simply not needed.  In Go, meanwhile, recursive type declarations are completely allowed, and many just think of monads as structural recursion.  Rob Pike proposed the following definition of a state machine, a finite state machine. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> stateFn <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Machine)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stateFn</span></span></span></span></code> </pre><br>  where state is a function of the machine that produces actions and returns a new state. <br>  The work of such a machine is simple <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m Machine)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> state := start; state != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; { state = state(m) } }</code> </pre><br>  Doesn't remind Haskell State Monad. <br>  Let's write the minimum parser, and for what else the state machine is needed, which selects numbers from the incoming stream. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> stateFn <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*lexer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stateFn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lexer</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">struct</span></span></span></span> { *bufio.Reader <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  We need only two states <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lexText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *lexer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stateFn</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r, _, err := l.ReadRune(); err != io.EOF; r, _, err = l.ReadRune() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'0'</span></span> &lt;= r &amp;&amp; r &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   l.UnreadRune() return lexNumber //  } } return nil //  . } func lexNumber(l *lexer) stateFn { var s string for r, _, err := l.ReadRune(); err != io.EOF; r, _, err = l.ReadRune() { if '0' &gt; r || r &gt; '9' { //   num, _ := strconv.Atoi(s) return lexText //  } s += string(r) } num, _ := strconv.Atoi(s) return nil //  . }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">A working example.</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bufio"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"io"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> stateFn <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*lexer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stateFn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l *lexer)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> state := lexText; state != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; { state = state(l) } } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> lexer <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { *bufio.Reader <span class="hljs-comment"><span class="hljs-comment">//  ,   } var output = make(chan int) //  func lexText(l *lexer) stateFn { for r, _, err := l.ReadRune(); err != io.EOF; r, _, err = l.ReadRune() { if '0' &lt;= r &amp;&amp; r &lt;= '9' { //   l.UnreadRune() return lexNumber //  } } close(output) return nil //  . } func lexNumber(l *lexer) stateFn { var s string for r, _, err := l.ReadRune(); err != io.EOF; r, _, err = l.ReadRune() { if '0' &gt; r || r &gt; '9' { num, _ := strconv.Atoi(s) output &lt;- num //   return lexText //  } s += string(r) } num, _ := strconv.Atoi(s) output &lt;- num close(output) return nil //  . } func main() { var sum int a := "hell 3456 fgh 25 fghj 2128506 fgh 77" // ,     fmt.Println("  : ", a) rr := strings.NewReader(a) //    lexy := lexer{bufio.NewReader(rr)} go run(&amp;lexy) //    for nums := range output { fmt.Println(nums) sum += nums } fmt.Println("  : ", sum) }</span></span></code> </pre><br></div></div>  <a href="http://play.golang.org/p/h03ji7ioms">Try in the sandbox.</a> <br>  Reactive programming is difficult to formally describe.  This is something about streams and signals.  Go has both.  The standard library io offers interfaces <i>io.Reader</i> and <i>io.Writer</i> having the methods <i>Read ()</i> and <i>Write (),</i> respectively, and fairly harmoniously reflecting the idea of ‚Äã‚Äãthreads.  The file and network connection for example implement both interfaces.  You can use interfaces regardless of the data source, say <br><pre> <code class="go hljs">Decoder = NewDecoder(r io.Reader) err = Decoder.Decode(Message)</code> </pre><br>  will uniformly encode a file or for example a network connection. <br>  The idea of ‚Äã‚Äãsignals is embodied in the syntax of the language.  The <i>chan</i> (channel) type is equipped with the &lt;- message transfer operator, and the <i>select {case &lt;-chan}</i> unique construction allows you to select a channel that is ready for transmission from several. <br>  Let's write a very simple stream mixer. <br>  We take just strings as input streams. (We agreed to make the examples immediately executable in the sandbox, which limits the choice. It would be more interesting to read from the network connection. And the code can be almost unchanged.) <br><pre> <code class="go hljs">reader1 := strings.NewReader(<span class="hljs-string"><span class="hljs-string">"      "</span></span>) reader2 := strings.NewReader(<span class="hljs-string"><span class="hljs-string">"      "</span></span>)</code> </pre><br>  Weekend we take the standard output stream <br><pre> <code class="go hljs">writer := os.Stdout</code> </pre><br>  As control signals we use the timer channel. <br><pre> <code class="go hljs">stop := time.After(<span class="hljs-number"><span class="hljs-number">10000</span></span> * time.Millisecond) tick := time.Tick(<span class="hljs-number"><span class="hljs-number">150</span></span> * time.Millisecond) tack := time.Tick(<span class="hljs-number"><span class="hljs-number">200</span></span> * time.Millisecond)</code> </pre><br>  And our whole mixer <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-tick: io.CopyN(writer, reader1, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-tack: io.CopyN(writer, reader2, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-stop: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">A working example.</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"io"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"strings"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { stop := time.After(<span class="hljs-number"><span class="hljs-number">10000</span></span> * time.Millisecond) tick := time.Tick(<span class="hljs-number"><span class="hljs-number">150</span></span> * time.Millisecond) tack := time.Tick(<span class="hljs-number"><span class="hljs-number">200</span></span> * time.Millisecond) reader1 := strings.NewReader(<span class="hljs-string"><span class="hljs-string">"      "</span></span>) reader2 := strings.NewReader(<span class="hljs-string"><span class="hljs-string">"      "</span></span>) writer := os.Stdout <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-tick: io.CopyN(writer, reader1, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-tack: io.CopyN(writer, reader2, <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> &lt;-stop: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } }</code> </pre><br></div></div>  <a href="http://play.golang.org/p/8Nsr3RbXb4">Try in the sandbox.</a> </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/280210/">https://habr.com/ru/post/280210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280198/index.html">How to clean up the mailbox using a neural network. Part 1</a></li>
<li><a href="../280200/index.html">Directed Phishing - a Modern Security Threat</a></li>
<li><a href="../280204/index.html">A bit of Storage Class Memory</a></li>
<li><a href="../280206/index.html">How ESLint reacts to the situation with the removal of packages from NPM</a></li>
<li><a href="../280208/index.html">Distributed nature of Tox Messenger</a></li>
<li><a href="../280212/index.html">Do not miss js-error</a></li>
<li><a href="../280214/index.html">Silicon Framework - WebAPI on C ++</a></li>
<li><a href="../280216/index.html">Finger Math: The Mendo Engine and the Irnshaw Theorem</a></li>
<li><a href="../280218/index.html">Redis - which is faster, UNIX socket or TCP? What is more stable? + pconnect</a></li>
<li><a href="../280222/index.html">Automated testing of the basic accessibility of interfaces for Android applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>