<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell - Design</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="They say that every programmer should write at least one compiler in his life or invent some programming language. The design of a new language is not...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell - Design</h1><div class="post__text post__text-html js-mediator-article">  They say that every programmer should write at least one compiler in his life or invent some programming language.  The design of a new language is not an easy task, because you need to think through dozens of parameters that, like Lego cubes, should be well combined with each other.  One unfortunate decision can erase the fate of the language, when it has not even been published yet.  Hundreds of languages ‚Äã‚Äãlive in oblivion, pushed by elder brothers from the podium, but the world with a tenacity worthy of a better application gives birth to two or three new ones every year.  Time will tell if they even fall into the ‚Äúgroup of alternative worldviews‚Äù, or even become mainstream.  Fortunately, my language is not necessary, because it can not be programmed - they can only admire.  For this is the Haskell code visualization language, the design of which will be discussed in the article. <br><br><img src="https://habrastorage.org/storage2/682/0cb/c55/6820cbc557543f19897e2d0583aa7ad1.png"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Haskell is a great language.  It is very expressive and capacious.  The code turns out to be an order of magnitude more compact than the code in imperative languages ‚Äã‚Äã(C ++, Java, C #), despite the fact that it has less syntactic structures.  The pure functional nature of Haskell and its design make the code look like a mathematical notation.  Take for example the indicative (but not the best) version of factorial: <br><br><blockquote>  fact n <font color="#339933">|</font>  n <font color="#339933">==</font> <font>0</font> <font color="#339933">=</font> <font>1</font> <br>  <font color="#339933">|</font>  n <font color="#339933">&gt;</font> <font>0</font> <font color="#339933">=</font> n <font color="#339933">*</font> fact <font>(</font> n <font color="#339933">-</font> <font>1</font> <font>)</font> </blockquote><br><br>  These two lines perfectly recognize the recurrent factorial formula familiar from school: <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/553/47b/eac/55347beace3ad0f26a1668e281b6502e.png"><br><br>  Of course, a certain recursive factorial will not be much worse in any other language, which may raise doubts, is it really Haskell expressive. <br><br><blockquote>  <font color="#0000ff">int</font> fact <font color="#008000">(</font> <font color="#0000ff">int</font> n <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">if</font> <font color="#008000">(</font> n <font color="#000080">==</font> <font color="#0000dd">0</font> <font color="#008000">)</font> <font color="#0000ff">return</font> <font color="#0000dd">1</font> <font color="#008080">;</font> <br>  <font color="#0000ff">return</font> n <font color="#000040">*</font> fact <font color="#008000">(</font> n <font color="#000040">-</font> <font color="#0000dd">1</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> </blockquote><br><br>  The trick is that both functions are written in a functional style, so there is not much difference between them.  However, having regretted the stack, we could use a cycle in an imperative language, which already looks completely different: <br><br><blockquote>  <font color="#0000ff">int</font> fact <font color="#008000">(</font> <font color="#0000ff">int</font> n <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">int</font> f <font color="#000080">=</font> <font color="#0000dd">1</font> <font color="#008080">;</font> <br>  <font color="#0000ff">for</font> <font color="#008000">(</font> <font color="#0000ff">int</font> i <font color="#000080">=</font> <font color="#0000dd">2</font> <font color="#008080">;</font> i <font color="#000080">&lt;=</font> n <font color="#008080">;</font> <font color="#000040">++</font> i <font color="#008000">)</font> <br>  f <font color="#000040">*</font> <font color="#000080">=</font> i <font color="#008080">;</font> <br>  <font color="#0000ff">return</font> f <font color="#008080">;</font> <br>  <font color="#008000">}</font> </blockquote><br><br>  Programmers are well aware that the last two examples can be visualized using a flowchart: <br><br><img src="https://habrastorage.org/storage2/f20/1ae/244/f201ae2447a51e96fc09ca44f07556d0.png"><br><br>  The second scheme, in principle, describes what happens in the Haskell recursive code.  And although the flowcharts are visualization, they are still different from what I want: they show <i>what is happening</i> , and not <i>what it looks like</i> .  I want to transfer the code to the three-dimensional scene, so that the scene is beautiful, intuitive and, if possible, unusual.  The meaning of visualization is in this. <br><br>  When designing a language, you have to think about how to expand it later.  If you do wrong or inconvenient, there will be no room for new projects without destroying backward compatibility.  Stories such examples are known;  This cup has not passed even some very popular languages ‚Äã‚Äã(for example, Python 3.0, which is not compatible with earlier versions).  To a large extent, very small things, so to speak, syntax in small things affect the extensibility of design.  With successful parts, the whole language is built as one big and well thought out designer.  Haskell is one of them, which means that the visualization language should also hold a brand.  And here I can not even make a discount on the fact that the design of Haskell is known - I still have to overcome these difficulties from the very beginning.  Although in a sense, I, of course, easier. <br><br>  So, you need to think over the design of the graphic language, rather independent, but at the same time visual and aesthetically useful.  It is necessary to think over separate syntactic units, at the same time looking to a higher level - at their connection and at their meaning in the general outline.  Proceeding from the very factorial, I plan to someday come up with sketches, even for such Haskell code: <br><br><blockquote>  <font color="#5d478b">- | |</font>  <font color="#5d478b">Box side drawings.</font> <br>  <font color="#5d478b">- | |</font>  <font color="#5d478b">It should be used only in this module.</font> <br>  f <font color="#339933">::</font> PreparedTextureObjects <br>  <font color="#339933">-&gt;</font> GLfVertex3 <br>  <font color="#339933">-&gt;</font> <font>(</font> BoxSide <font color="#339933">,</font> QuadColorSpec <font>)</font> <br>  <font color="#339933">-&gt;</font> <font>(</font> <font>[</font> BoxSide <font>]</font> <font color="#339933">,</font> <font>[</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <font>]</font> <font>)</font> <br>  <font color="#339933">-&gt;</font> <font>(</font> <font>[</font> BoxSide <font>]</font> <font color="#339933">,</font> <font>[</font> <font color="#cccc00">IO</font> <font>(</font> <font>)</font> <font>]</font> <font>)</font> <br>  f texRes boxDim <font>(</font> side <font color="#339933">,</font> qColorSpec <font>)</font> <font>(</font> sList <font color="#339933">,</font> ioList <font>)</font> <font color="#339933">=</font> <font>let</font> <br>  boxIO <font color="#339933">=</font> <font>do</font> setQuadColorSpec texRes qColorSpec <br>  GL <font color="#339933">.</font>  renderPrimitive GL <font color="#339933">.</font>  Quads <font>(</font> boxSide boxDim side <font>)</font> <br>  <font>in</font> <font>(</font> side: sList <font color="#339933">,</font> boxIO: ioList <font>)</font> </blockquote><br><br>  Or for this: <br><br><blockquote>  <font>data</font> QuadColorSpec <font color="#339933">=</font> QuadTexture TextureName <br>  <font color="#339933">|</font>  QuadPlainColor GLfColor4 <br>  <font color="#339933">|</font>  NoQuadColorSpec <br>  <font>deriving</font> <font>(</font> <font color="#cccc00">Show</font> <font>)</font> <br><br>  <font>data</font> ObjectTextureSpec <font color="#339933">=</font> BoxTextureSpec <br>  <font>{</font> quadSideTexes <font color="#339933">::</font> <font>[</font> <font>(</font> BoxSide <font color="#339933">,</font> QuadColorSpec <font>)</font> <font>]</font> <br>  <font color="#339933">,</font> defQuadSideTex <font color="#339933">::</font> QuadColorSpec <br>  <font>}</font> <font>deriving</font> <font>(</font> <font color="#cccc00">Show</font> <font>)</font> <br><br>  <font>data</font> CornerCoord <font color="#339933">=</font> UR <font color="#339933">|</font>  DR <font color="#339933">|</font>  DL <font color="#339933">|</font>  UL <br>  <font>deriving</font> <font>(</font> <font color="#cccc00">Show</font> <font>)</font> </blockquote><br><br>  In the meantime, I have the factorial code, and the visualization language began with it: <br><br><blockquote>  fact n <font color="#339933">|</font>  n <font color="#339933">==</font> <font>0</font> <font color="#339933">=</font> <font>1</font> <br>  <font color="#339933">|</font>  n <font color="#339933">/ =</font> <font>0</font> <font color="#339933">=</font> fact <font>(</font> n <font color="#339933">-</font> <font>1</font> <font>)</font> <font color="#339933">*</font> n </blockquote><br><br>  Here we see several syntactic constructions: <br><br><table><tbody><tr><td>  function name </td><td></td><td>  fact </td></tr><tr><td>  Argument </td><td></td><td>  n </td></tr><tr><td>  2 security expressions </td><td></td><td>  |  n == 0 </td></tr><tr><td></td><td></td><td>  |  n / = 0 </td></tr><tr><td>  2 function bodies </td><td></td><td>  = 1 </td></tr><tr><td></td><td></td><td>  = fact (n - 1) * n </td></tr></tbody></table><br><br>  In turn, each function body is divided into a tree-like computational expression.  Take the second case.  Representing the elements of this tree in the form of boxes, we get the first rough version: <br><br><img src="https://habrastorage.org/storage2/b64/de4/233/b64de42337041085e35e4c5d5bb8a9a3.png"><br><br>  Immediately, the flaws appear.  You can imagine how the visualization of the code will grow if you add any more actions and expressions to the function body.  Why are there!  Expressions can themselves consist of expressions, and simply associating each element with a box will result in us simply getting a long and non-intuitive chain of boxes.  The solution "in the forehead" is not suitable here.  Recall a useful fact: a clear incarnation of a tree structure is a pyramid.  A computational expression can also be represented in this form, even in several ways: <br><br><img src="https://habrastorage.org/storage2/325/d51/4bb/325d514bb4fa46d1dce41657416d21f4.png"><br><img src="https://habrastorage.org/storage2/8ba/9d1/810/8ba9d18107d52d70673efb89f62a2754.png"><br><img src="https://habrastorage.org/storage2/590/c77/731/590c777317cb1f3a29d782e74c1dd84d.png"><br><br><br>  The last picture is subjectively prettier due to the characteristic pyramidal protrusions.  It would be possible to dwell on this form, but there is a feature among binary functions that they can be operators.  The difference between the operators and the functions is purely intuitive, but from the point of view of the language it is the same thing, it is simply written differently - in the functional and infix records: <br><br><blockquote>  isListElement x xs <font color="#339933">=</font> <font>elem</font> x xs <font color="#5d478b">- functional form</font> <br>  isListElement 'x xs <font color="#339933">=</font> x ` <font>elem`</font> xs <font color="#5d478b">- infix form</font> </blockquote><br><br>  The default operators are used in the infix notation, but the functional is also valid: <br><br><blockquote>  add a b <font color="#339933">=</font> a <font color="#339933">+</font> b <br>  add 'a b <font color="#339933">=</font> <font>(</font> <font color="#339933">+</font> <font>)</font> a b </blockquote><br><br>  And this fact can be easily displayed during visualization.  In the following sketch, in addition to highlighting the infix form, I increased the final syntactic units (variables and constants) twice: <br><br><img src="https://habrastorage.org/storage2/997/355/40c/99735540c70420331d8c78d0ee652d02.png"><br><br>  The height of the pyramid decreased, which is good, and it became clear where the infix notation was and where it was functional.  This approach becomes useful when setting up consecutive calculations: <br><br><blockquote>  add3 a b c <font color="#339933">=</font> a <font color="#339933">+</font> b <font color="#339933">+</font> c <br>  someF x y z <font color="#339933">=</font> x <font color="#339933">&gt;&gt; =</font> y <font color="#339933">&gt;&gt;</font> z </blockquote><br><br><img src="https://habrastorage.org/storage2/2bc/4be/7d7/2bc4be7d7876970ffa6a03906b88b23d.png"><br><img src="https://habrastorage.org/storage2/42b/1b5/a2f/42b1b5a2fdf4dd79a06ee3c32508bd02.png"><br><br>  And for functions with a large number of arguments, it is worth keeping the gap between the boxes. <br><br>  The sketches show that the length of the boxes depends on the name on the box and on the space occupied by the arguments.  There is nothing you can do: the inscription is needed, and you should not reduce it in size, otherwise we will lose uniformity.  This can be customized on a web page or in a document, and the code should look strictly, because it is easier to read.  Therefore, complex, massive computational expressions will also look impressive.  Let's look at the function for the Fibonacci numbers: <br><br><blockquote>  fibs <font color="#339933">=</font> <font>0</font> : <font>1</font> : <font>zipWith</font> <font>(</font> <font color="#339933">+</font> <font>)</font> fibs <font>(</font> <font>tail</font> fibs <font>)</font> </blockquote><br><br>  The expression (and it works too!) Looks very beautiful.  Let's try to build a sketch for it, remembering that the ‚Äúcolon‚Äù ‚Äã‚Äãsign, used twice, is written in infix form, and zipWith is a function that takes three arguments: (+), fibs and (tail fibs).  The problem here appears with a plus in brackets.  The sign is passed to another function as an argument, and for Haskell this is a normal and very useful phenomenon, known as the ‚Äúhigher order function.‚Äù  In addition, the operator + has both its own arguments bitten off, and this is already called a section.  According to our past rules, the + operator should be the final argument with an enlarged box.  In principle, this is normal: <br><br><img src="https://habrastorage.org/storage2/a08/7e7/f1b/a087e7f1b314ee40db76ad684c7041b9.png"><br><br>  But looking into the future, we can reflect on how sections and curried functions will look like in general.  Take for example such a little artificial code: <br><br><blockquote>  ops <font color="#339933">=</font> <font>[</font> <font>(</font> <font color="#339933">+</font> <font>)</font> <font color="#339933">,</font> <font>(</font> <font color="#339933">*</font> <font>)</font> <font color="#339933">,</font> <font>(</font> <font color="#339933">-</font> <font>)</font> <font>]</font> <br><br>  func x y op <font color="#339933">=</font> x `op` y <br><br>  result <font color="#339933">=</font> <font>map</font> <font>(</font> func <font>2</font> <font>3</font> <font>)</font> ops </blockquote><br><br>  Here are three functions: ops returns a list of operators, func - performs an action passed as op on the x and y arguments, and inside result all this is used and something is calculated.  To be honest, when executing, result will return the following list: [5, 6, -1], and it is easy to see how it turned out.  The map function (func 2 3) has been applied to all operators in the ops list.  In this case, we are interested in that (func 2 3) is a curried record, in which one argument remains vacant.  Operators in brackets are also curried (more correctly, truncated), everything has already been stolen from us ... that is, two arguments have been selected.  This is not reflected in the Haskell code, and a strange entry like this: <br><br><blockquote>  nullMap <font color="#339933">=</font> <font>map</font> <font>null</font> </blockquote><br><br>  may not tell us anything if we don‚Äôt know what the map and null functions do, and if the type signatures are not specified.  However, in the visualization we could clearly show that these functions require some more arguments.  It is enough to postulate that the arguments fit into the grooves of the functions, and the number of slots corresponds to arity.  Here is the result for the result and nullMap functions: <br><br><img src="https://habrastorage.org/storage2/c9a/a27/6cf/c9aa276cf2431759f93ac0e9ff6247ae.png"><br><img src="https://habrastorage.org/storage2/777/b41/a3c/777b41a3c0b3bfaa3b24272481c2fe6e.png"><br><br>  When designing computational expressions, the question of proportions still remains significant, and here a total revelry of fantasy is possible.  Parameters can be element height, the distance between the arguments, the length and depth of the empty groove, the height and length of the finite elements, the size of the pyramidal indent.  If you arm yourself with the knowledge of harmony, then, probably, it is worthwhile to bring the golden section in proportions.  It makes everything better! <br><br>  An important construction of any language is conditional transitions.  In Haskell, the if statement is also there, and it is such that the else statement must accompany it.  There can be no expression for which one of the alternatives is missing - in the world where everything is a function, the result should always be returned.  Below is the calculation of factorial with if (we, like last time, do not think that n can come negative): <br><br><blockquote>  fact n <font color="#339933">=</font> <font>if</font> n <font color="#339933">==</font> <font>0</font> <font>then</font> <font>1</font> <font>else</font> fact <font>(</font> n <font color="#339933">-</font> <font>1</font> <font>)</font> <font color="#339933">*</font> n </blockquote><br><br>  Here you can format the code in any way.  then and else are not sensitive to indents and can be located on a new line (only counting at least one whitespace character from the function function): <br><br><blockquote>  fact n <font color="#339933">=</font> <font>if</font> n <font color="#339933">==</font> <font>0</font> <br>  <font>then</font> <font>1</font> <br>  <font>else</font> fact <font>(</font> n <font color="#339933">-</font> <font>1</font> <font>)</font> <font color="#339933">*</font> n </blockquote><br><br>  Perhaps these permutations somehow help to come up with the design of this design.  The naive hyphenation of the words if, then, and else as the lowest layers of the pyramids intersects somewhat with the previous variant and confuses.  But if you separate them by some separate element, it will turn out to be more interesting.  Compare the following two options: <br><br><img src="https://habrastorage.org/storage2/6a4/43c/03d/6a443c03d8eaecd87204430fe3358ad9.png"><br><img src="https://habrastorage.org/storage2/135/8d6/dd4/1358d6dd496682bc29d4b2831dece6ee.png"><br><br>  By giving vent to fantasy, you can achieve some intuitiveness of the latter.  What is an if?  This is when a boolean expression is checked for truth, that is, for a match with True.  Constructors, puzzles and something else are built on the coincidence principle: there is a coincidence - the pin fits the slot;  no coincidence - well, sorry ... Let's try to bring this concept into the sketch: <br><br><img src="https://habrastorage.org/storage2/031/cc7/eed/031cc7eed869c7bf7aa815a42c906f7c.png"><br><img src="https://habrastorage.org/storage2/ec0/8d2/a21/ec08d2a2168bdc3bbf1d2fe9251813e7.png"><br><br>  It looks interesting and encourages to fantasize further.  You can experiment with position, shape, size, but you need to remember that if-then-else is an expression, and it will be used inside other expressions.  That is, since we limit ourselves in space for the sake of expressiveness, then the conditional operator should not go beyond certain empirical frameworks. <br><br>  Perhaps, for if-then-else, this is not difficult, and these syntactic elements, like goodies, will fit in any part of the expression, but here's a related case-design can be a hassle.  She is able to expand: the number of alternatives is unlimited.  Rewrite the factorial function: <br><br><blockquote>  fact n <font color="#339933">=</font> <font>case</font> n <font color="#339933">==</font> <font>0</font> <font>of</font> <br>  True <font color="#339933">-&gt;</font> <font>1</font> <br>  False <font color="#339933">-&gt;</font> fact <font>(</font> n <font color="#339933">-</font> <font>1</font> <font>)</font> <font color="#339933">*</font> n </blockquote><br><br>  There is something to think about.  A new semantics is added in the case-construction: pattern matching.  Here, I confess, I have not yet come up with a decent option.  But you can try by analogy with one of the latest if sketches: <br><br><img src="https://habrastorage.org/storage2/00c/e8e/b69/00ce8eb69c2459c5eb285a976bc49ff3.png"><br><br>  The meaning of the comparison with the sample is that on each of the cubes before the sign "-&gt;" there can be a rather large expression.  The possibilities are enormous: here there is a splitting of the lists, and an arbitrarily deep comparison with algebraic data types, and even ‚Äî with the extension of the View Patterns language ‚Äî a syntax that resembles functions.  I will show only a simple, fairly typical code, where pattern matching is used inside a case: <br><br><blockquote>  toHabrFormat <font>(</font> s <font color="#339933">,</font> <font>(</font> ch: <font>[</font> <font>]</font> <font>)</font> <font>)</font> <font color="#339933">=</font> s <font color="#339933">++</font> <font>[</font> ch <font>]</font> <br>  toHabrFormat a <font color="#339933">@</font> <font>(</font> s <font color="#339933">,</font> b <font color="#339933">@</font> <font>(</font> ch: inStr <font>)</font> <font>)</font> <font color="#339933">=</font> <font>let</font> formatted <font color="#339933">=</font> <font>(</font> <font>foldr1</font> <font>(</font> <font color="#339933">&lt;|&gt;</font> <font>)</font> formatters <font>)</font> a <br>  <font>in</font> <font>case</font> formatted <font>of</font> <br>  Just <font>(</font> res <font color="#339933">,</font> <font>[</font> <font>]</font> <font>)</font> <font color="#339933">-&gt;</font> res <br>  Just <font>(</font> res <font color="#339933">,</font> <font>(</font> r: rs <font>)</font> <font>)</font> <font color="#339933">-&gt;</font> toHabrFormat <font>(</font> res <font color="#339933">++</font> <font>[</font> r <font>]</font> <font color="#339933">,</font> rs <font>)</font> <br>  Nothing <font color="#339933">-&gt;</font> toHabrFormat <font>(</font> s <font color="#339933">++</font> <font>[</font> ch <font>]</font> <font color="#339933">,</font> inStr <font>)</font> </blockquote><br><br>  Apparently, while there is no clarity on how to represent algebraic data types, lists, tuples, etc., the case construction will be unconvincing. <br><br>  Now, nevertheless, we put aside computational expressions and try to complete the visualization of the factorial function with its name and security expressions. <br><br><blockquote>  fact n <font color="#339933">|</font>  n <font color="#339933">==</font> <font>0</font> <font color="#339933">=</font> <font>1</font> <br>  <font color="#339933">|</font>  n <font color="#339933">/ =</font> <font>0</font> <font color="#339933">=</font> fact <font>(</font> n <font color="#339933">-</font> <font>1</font> <font>)</font> <font color="#339933">*</font> n </blockquote><br><br>  About security expressions have something to say.  These are ordinary expressions, but they always return a boolean value ‚Äî True or False.  They serve as certain filters, as if not missing execution in the body, if the condition is not true.  Playing with this concept, you can come up with something like the notorious if.  We estimate the following option: <br><br><img src="https://habrastorage.org/storage2/3ec/1ef/e9a/3ec1efe9a818d57314d680f6f8c83eac.png"><br><br>  A box with equality (‚Äúbridge‚Äù) emerged from the desire to combine the guard expressions and the function body in the same way as in the code.  And this seems to be an interesting idea.  Developing, it grew into something more - into a visual separation of parts (the name of a function; guard expressions; a computational expression).  You can go further: put them on the platform, thereby outlining the space of each of the parts. <br><br><img src="https://habrastorage.org/storage2/a3f/270/285/a3f2702859176a4265dfe84a469520c9.png"><br><br>  In the code, the guard expression starts with the character '|'.  If it were not there, the code would look contradictory: <br><br><blockquote>  fact n n <font color="#339933">==</font> <font>0</font> <font color="#339933">=</font> <font>1</font> <br>  n <font color="#339933">/ =</font> <font>0</font> <font color="#339933">=</font> fact <font>(</font> n <font color="#339933">-</font> <font>1</font> <font>)</font> <font color="#339933">*</font> n </blockquote><br><br>  The compiler would not understand what the letters and symbols are after the word fact.  The vertical bar is a necessary element of syntax, and therefore we need to add it to the visualization.  It is logical to put something to the left of the platform with a boolean expression;  it could be, for example, a ‚Äúwall‚Äù: <br><br><img src="https://habrastorage.org/storage2/d27/b6e/5f1/d27b6e5f155089064cee18ae54b24648.png"><br><br>  But is it intuitive?  A solid box looks like an obstacle, a prohibition, and we need a condition, a variability.  If we present the progress in the form of a cube, then, moving from the name of the function to the guard expression, will simply collide with the wall - and none of the function bodies will be achieved.  In this reflection lies the key to a more intuitive option: what if you make a hole in the wall?  You can think of yourself this way: if the logical condition is true, the cube will pass through the hole and get where it is needed.  The direction of movement should also be visualized: let the bridges with arrows show it - they will also help to connect the right and left parts of the function: <br><br><img src="https://habrastorage.org/storage2/e41/a21/ada/e41a21ada83808fe62756c952a7c86a5.png"><br><br>  Much better!  Now visualize the function name with arguments.  Again, here we are dealing with pattern matching, and, in an amicable way, it would be worth combining it with arity.  Cutouts for the arguments we have learned to do, they will be useful here.  Without comparison with the sample, we would have this option: <br><br><img src="https://habrastorage.org/storage2/120/e67/89a/120e6789a5857ee778a644dfc9267982.png"><br><br>  So, the basis of the graphic language has been built, and we now roughly represent what it should look like.  For a clear picture, you still need to deal with such important things as algebraic data types, lists, tuples, and pattern matching.  When it‚Äôs done with them, ideas about what to do with type declarations, do-structures, list generators, as-samples, class types, class incarnations, and other great elements of Haskell syntax are likely to appear. <br><br>  Let's start with algebraic data types, lists, and pattern matching.  In the case example above, we tried to visualize the ADT and pattern matching.  Imagine that arity instead of cutouts is denoted by protrusions.  The picture with case, True and False will then be incorrect, because these two constructors have arity equal to zero.  However, the arity of Just is 1, - and it will have one overhang. <br><br><img src="https://habrastorage.org/storage2/d2b/119/943/d2b11994393086ee81b53f618f9365a3.png"><br><br>  Lists are created using the infix operator ":" (which is actually a type constructor, but this is another story [1]).  We already know how to visualize it.  Take a more complicated case, when there are both ‚Äúunimportant‚Äù elements and an empty list.  Here is a hypothetical code: <br><br><blockquote>  someFunc someList <font color="#339933">=</font> <font>case</font> someList <font>of</font> <br>  <font>(</font> x1: x2: <font color="#339933">_</font> : xs <font>)</font> <font color="#339933">-&gt;</font> Just <font>(</font> x1 <font color="#339933">,</font> x2 <font>)</font> <br>  <font>(</font> x1: <font>[</font> <font>]</font> <font>)</font> <font color="#339933">-&gt;</font> Just <font>(</font> x1 <font color="#339933">,</font> x1 <font>)</font> <br>  <font>[</font> <font>]</font> <font color="#339933">-&gt;</font> Nothing </blockquote><br><br>  Already the constructions of the Haskell language clearly demonstrate their essence.  An unimportant argument is replaced by an underscore, and an empty list with empty square brackets.  We take this into account when rendering.  Not visible in the formalism of the code only the differences between the arguments x1, x2 and xs from the first alternative.  Meanwhile, x1 and x2 are split elements of the front list, and xs is the rest of the possible empty list.  It would be useful to show the difference somehow. <br><br><img src="https://habrastorage.org/storage2/51f/230/e38/51f230e3834a355396f21caad29f2ff6.png"><br><img src="https://habrastorage.org/storage2/20a/df5/cbb/20adf5cbb473670ea17373a38bf798ac.png"><br><br>  Yes, the lists look very.  I especially like the ‚Äúunimportant‚Äù element.  What about tuples?  Well, there‚Äôs no need to be wise: just put each element of the tuple in the groove on the common board.  It is impossible to confuse with the function, since the tuple does not have a name, and its base is thinner.  For reliability, you can change the color. <br><br><img src="https://habrastorage.org/storage2/a56/4e7/2f6/a564e72f6a24d6e77de76ba7c9912c7b.png"><br><br>  Not such a difficult task was!  So, logically speaking, you can build a language for visualization.  It's okay if some designs will be changed beyond recognition through several versions.  Now, not touching on how to visualize the type declaration, I risk then discovering that they do not fit into the semi-prepared schema.  It is necessary to change something, to sacrifice something, but the general principles of visualization will remain the same.  Of course, there were vast spaces for fantasy.  I have not yet selected colors and shades, have not thought about fonts, and the shape of the elements can be improved in many ways.  There was even such an idea: make boxes with inscriptions made of glass, and put the inscription inside, and make it all sparkle with reflected light.  Perpetuate, so to speak, the code in the glass.  It would probably be something like this: <br><br><img src="https://habrastorage.org/storage2/682/0cb/c55/6820cbc557543f19897e2d0583aa7ad1.png"><br><br>  Beauty, which is to say.  And it already seems that the main costs here are to invent a design, and visualization can be quickly concocted in some graphic editor, but ... In reality, everything is somewhat more complicated, because a program is needed for visualization, and not a static 3D scene.  This is the program that I create in the ‚ÄúGraphServer‚Äù project.  The task is complicated by the fact that not all designs I came up with visualization;  already during the writing of this article, some constructions were strongly modified or invented.  But even that which is ready at the moment looks promising. <br><br>  This is a cross article.  On the creation of a server visualization, read the article <a href="http://habrahabr.ru/blogs/Haskell/138884/">"Haskell - Aesthetics</a> . <a href="http://habrahabr.ru/blogs/Haskell/138884/">"</a> <br><br>  PS I apologize for not quite high-quality pictures.  Habrastorage seems to be doing something with them. <br>  [1] - Fix for the following comment: <a href="http://it-talk.org/post76900.html">it-talk.org/post76900.html#p76900</a> </div><p>Source: <a href="https://habr.com/ru/post/139167/">https://habr.com/ru/post/139167/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../139158/index.html">3 minutes per month on Google+</a></li>
<li><a href="../139159/index.html">Sort text field as numbers and as strings simultaneously in MySQL</a></li>
<li><a href="../139163/index.html">Windows 8 Consumer Preview Review</a></li>
<li><a href="../139165/index.html">How to / Installing Zabbix-server (FreeBSD, PostgreSQL, Nginx)</a></li>
<li><a href="../139166/index.html">AssetManager: how to force the user to receive updated statics</a></li>
<li><a href="../139170/index.html">Laptop Batteries - Fantasy and Reality</a></li>
<li><a href="../139172/index.html">Microsoft pushes the Secure Boot equivalent on the ARM architecture</a></li>
<li><a href="../139173/index.html">Because I am an independent child</a></li>
<li><a href="../139175/index.html">Production of MTS 945 GLONASS is suspended</a></li>
<li><a href="../139176/index.html">Interception sessions in wireless networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>