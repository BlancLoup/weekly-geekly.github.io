<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Work with Talend Open Studio on the example of parsing a CSV file</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Collecting data from various sources, transforming for the purpose of unification or convenience is a fairly common task. Of course, in most cases you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Work with Talend Open Studio on the example of parsing a CSV file</h1><div class="post__text post__text-html js-mediator-article"> Collecting data from various sources, transforming for the purpose of unification or convenience is a fairly common task.  Of course, in most cases you can get by with your own decision, but in order to make it flexible and easily expandable you will have to spend a lot of time.  In this case, it is reasonable to take advantage of a ready-made solution.  Talend Open Studio (TOS) is one such solution. <br><br>  I was somewhat surprised by the lack of articles about working with TOS on Habr√©.  Perhaps there are reasons for this that are incomprehensible to me.  Anyway, I will try to fill this gap. <br><br>  Probably, when writing this article, I was unnecessarily detailed in some issues, so I hid some instructions under the spoiler. <br><a name="habracut"></a><br>  So TOS is an open source data integration solution.  The main tool for customizing the process of converting data to TOS is a special visual editor that allows you to add and customize individual data conversion nodes and the connections between them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      An interesting feature and a significant advantage of TOS, in my opinion, is the fact that TOS transforms our components and links into Java code.  In essence, we get a Java library with the ability to generate code based on a data conversion graph.  Plus, we can build the package and run it on any machine where there is Java and where TOS may be missing. <br>  Code generation gives us another plus - you can extend the TOS capabilities by writing your own code (there are even special tools for this). <br><br>  Separate holistic data conversion in Talend is called a job.  The task consists of subtasks, which, in turn, consist of components and relationships.  Components directly convert data or do input / output.  Links are of several types.  The primary means of exchanging data between components is flow connections.  The thread is very similar to the table in the database.  A stream has a scheme (names, types and attributes of fields) and data (field values).  Both the data itself and the flow scheme can be changed during processing.  Streams in TOS are not synchronized with each other.  They work independently of each other. <br><br>  Next, I'll try with an example to show how the data processing process is configured. <br><br>  Suppose we have a CSV file of the form: <br><br> <code>id,event_name,event_datetime,tag <br> 1,"Hello, world!",2017-01-10T18:00:00Z, <br> 2,"Event2",2017-01-10T19:00:00Z,tag1=q <br> 3,Event3,2017-01-10T20:00:00Z, <br> 4,"Hello, world!",2017-01-10T21:00:00Z,tag2=a <br> 5,Event2,2017-01-10T22:00:00Z, <br> ... <br></code> <br>  And we want to separate the data by different events (the event field). <br><br>  Before we start working with data, we need to create a task.  The creation process is not described because of its triviality. <br><br>  So the first thing we need to do is read and parse CSV.  To begin with, we will create a metadata record for our input CSV file - this will simplify further work (Metadata -&gt; File delimited).  Creating File delimited is more or less intuitive, so a detailed description is hidden under the spoiler. <br><br>  The only thing that deserves mentioning is the placement of quotation marks when substituting values ‚Äã‚Äãinto form fields.  This applies not only to creating a file delimited but also to most other fields in the forms.  The fact is that most of the values ‚Äã‚Äãin various fields will be substituted into Java code ‚Äúas is‚Äù, i.e.  must be a Java expression of a particular type.  If we set a string constant, we will have to write it in quotes.  This gives us additional flexibility.  It turns out that wherever a value is required, you can substitute the value of a parameter or expression. <br><br><div class="spoiler">  <b class="spoiler_title">Create File Delimited</b> <div class="spoiler_text"><img src="https://habrastorage.org/web/808/025/865/80802586551f438fb893d35894109bb2.PNG"><br><br>  Next, you need to set a name and select a file.  Choose our CSV file with input data. <br><br>  The next step is to configure the file parsing. <br><br><img src="https://habrastorage.org/web/15c/2c7/2f1/15c2c72f1ac042d181282a3880f995f2.PNG"><br><br>  Interesting fields: <br><br>  Field separator - we have a comma (comma). <br>  In the ‚ÄúEscape Char Settings‚Äù section, we are interested in the ‚ÄúText Enclosure‚Äù field.  Set the value of ‚Äú\‚Äù ‚Äù- i.e.  ‚ÄúDouble quote‚Äù.  Now all the text inside double quotes will be interpreted as a whole, even if there is a separator (comma) inside. <br>  On the right side, you can configure line skipping and restrictions.  We are not interested. <br>  Put a checkmark ‚ÄúSet header row as column names‚Äù because  we have column names in the first line.  These values ‚Äã‚Äãwill become field names. <br><br>  The ‚ÄúRefresh Preview‚Äù button will update the preview area.  Make sure that everything is in order and move on. <br><br>  Next, we are required to configure the scheme for the output stream.  A schema is a set of typed fields.  Each field can also be assigned some attributes. <br><br><img src="https://habrastorage.org/web/380/172/0f2/3801720f222a465d99a9c8be9e65ada5.PNG"><br><br>  Headings from a CSV file have become field names.  The type of each field is determined automatically based on the data in the file.  Here we are satisfied with everything, except for the date format.  The date in our file looks like this 2017-01-10T22: 00: 00Z and for its parsing you need the template "yyyy-MM-dd'T'HH: mm: ss'Z '".  Pay attention to quotes.  The fact is that most of the values ‚Äã‚Äãin various fields will be substituted into the java code ‚Äúas is‚Äù, i.e.  must be a Java expression of a particular type.  If we set a string constant, we will have to write it in quotes. <br><br>  Now we have a template parser for CSV files of a given format. <br></div></div><br>  Next, add the component that will be engaged in parsing.  The component we need is called tFileInputDelimited. <br><br><div class="spoiler">  <b class="spoiler_title">About adding components</b> <div class="spoiler_text">  Components can be found in the components menu (usually on the right) in the section (tFileInputDelimited in the ‚ÄúFile-&gt; Input‚Äù section) and dragging to the workspace, but you can do it easier: click at any point in the workspace and start typing the name of the component.  A tooltip appears with a list of components. <br><br><img src="https://habrastorage.org/web/e0d/d12/5e8/e0dd125e841040aaa49fce4400eb5190.PNG"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">About compounding components</b> <div class="spoiler_text">  Component can be selected by clicking on its icon.  A ‚Äútongue‚Äù ‚ÄúO‚Äù will appear next to the icon and information will also appear in the component‚Äôs current settings window.  The ‚Äútongue‚Äù ‚ÄúO‚Äù (output) is the output.  Pulling on it we can connect the component to another component. <br></div></div><br>  Next, configure our parser.  For the tFileInputDelimited component in the settings, set the ‚ÄúProperty type‚Äù to ‚ÄúRepository‚Äù and select the previously created template. <br><br>  Now the parser is configured to parse the files of the format we need and if we start the work, then in the logs we will see the contents of our source CSV file.  The problem is that if the parser is associated with a template, it is hard-tuned to a file in the template.  We cannot specify another file of the same format, which may not be very convenient when we do not know in advance what kind of file we are going to process. <br><br>  There are two ways out of this situation.  The first is to always replace the file from the template with the desired file.  The second is to untie the parser component and the pattern.  In this case, the parsing settings can be saved, but it is possible to set the input file.  The disadvantages of the first method are obvious, the disadvantages of the second include the lack of synchronization between the template and the parser.  If we change the template, we will need to manually synchronize the settings of the parser.  We will go the second way and untie the parser from the template.  To do this, return the value ‚ÄúBuild-In‚Äù in the field ‚ÄúProperty type‚Äù.  Settings are preserved, but the opportunity to change them. <br><br>  Change the name of the input file to the expression context.INPUT_CSV.  Notice that the name was in quotes (a string constant), and our expression is without quotes.  It is a context parameter.  You also need to create this parameter in the context tab.  For debugging, you can set a default value.  Context parameters can be specified as command line parameters (something like --context_param INPUT_CSV = path).  This refers to running the assembled Java package. <br><br>  Further.  We want to separate the data by event name. <br><br>  This will require a tMap component and several tFilterRow.  Let's limit ourselves to two tFilterRows for now.  we will select only two different events.  Connect them as shown in the picture: <br><br><img src="https://habrastorage.org/web/24c/7d6/199/24c7d61990eb4e9fbc989b58d9293298.PNG"><br><br>  When connecting tMap and tFilterRow, you will need to enter a name for the connection.  The name must be unique.  Next you need to configure the tMap component.  To do this, enter the Map Editor menu either by double clicking on the tMap icon, or by calling the editor from the component properties panel. <br><br>  In our case, we only need to ‚Äúcopy‚Äù the stream, so simply drag all the input data fields (left) into each of the output streams (right). <br><br><img src="https://habrastorage.org/web/86a/623/eb2/86a623eb21a94a78887c2bfd641055c5.PNG"><br><br>  In the section in the middle, you can set an internal variable (you can use it to generate new values, such as line numbers, or parameter substitutions).  An expression can be written in each cell of the editor.  In essence, what we have done is the substitution of values.  row1 in the screenshot is the name of the input stream.  Now our mapper will divide the input data into two streams. <br><br>  Setting up tFilterRow filters is nothing special. <br><br><div class="spoiler">  <b class="spoiler_title">About tFilterRow setup</b> <div class="spoiler_text">  Add an input column, select a condition type and enter a value.  We will set the filters on the event_name field.  One filter will check for equality (==) ‚ÄúHello, world!‚Äù (In quotes), and the second ‚ÄúEvent2‚Äù. <br><br>  The ‚ÄúFunction‚Äù parameter in the component settings sets the transformation of the input data and sets the conversion function F. Then the selection conditions will be: F (input_column) {comparator} value.  We do not have the function F, {comparator} is equality, and value is ‚ÄúHello, world!‚Äù.  We get in our case input_column == "Hello, world!". <br></div></div><br>  After the filters, we add a tLogRow pair, run it and see that the data is divided.  The only thing is that it is better to set the Mode for tLogRow to something other than ‚ÄúMain‚Äù, otherwise the data will be mixed. <br><br>  Instead of tLogRow, you can add any other data output component, for example tFileOutputDelimited to write to the CSV file, or a database component to write to the table. <br><br>  To work with the database there are many components.  Many of them have fields in the settings to configure access to the database.  However, if you intend to address the database a lot from different components, it is best to use the following scheme: <br><br><img src="https://habrastorage.org/web/dbb/c05/b7a/dbbc05b7a131452d94cdb993316cc0b2.PNG"><br><br>  The Connection component sets the database access parameters and establishes the connection.  The Close component is disconnected from the database.  In the middle block, where the single Commit component is in the figure, you can use the database without establishing new connections.  To do this, in the settings of components, select the ‚ÄúUse existing connection‚Äù option and select the required Connection component. <br><br>  It also uses another mechanism TOS - subtasks (subjob).  By creating subtasks, you can ensure that some parts of the task are completed before others begin.  In this example, the Commit component will not start until the connection is established.  OnSubjobOk is connected between subtasks (the Trigger option is available in the context menu of the component, inside which there is this connection).  There are other links, for example, ObSubjobError for error handling. <br><br>  Let's go back to our example with the CSV file. <br><br>  The tag field is not very suitable for writing to the database - tag2 = a.  Surely we will want to split a key-value pair into different fields in the database.  This can be done in different ways, but we will do this with the tJavaFlex component.  tJavaFlex is a component whose behavior can be described in the Java language.  There are three sections in its settings - the first is performed before data processing begins (initialization), the second is processing data and the third is performed after processing all data.  As with the rest of the components, there is a schema editor.  Remove the tag field from the data scheme at the output and add a couple of new ones - tag_name and tag_value (of type String). <br><br><img src="https://habrastorage.org/web/296/618/19a/29661819a73d4aca81d9b29406ac6474.png"><br><br>  Further, in the middle section of the component we write <br><pre> <code class="java hljs">row4.tag_name = <span class="hljs-string"><span class="hljs-string">""</span></span>; row4.tag_value = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(row2.tag.contains(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) { String[] parts = row2.tag.split(<span class="hljs-string"><span class="hljs-string">"="</span></span>); row4.tag_name = parts[<span class="hljs-number"><span class="hljs-number">0</span></span>]; row4.tag_value = parts[<span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre><br>  The code is trivial, and perhaps the only thing that needs to be explained is the row4.tag_value type constructions.  tag_value is the name of the field we created.  In the same way you can refer to other fields.  row4 is the name of the outgoing stream (row2 inbound).  They can be changed. <br><br><img src="https://habrastorage.org/web/287/c42/3f6/287c423f694a456fbb35d81e53ab7817.png"><br><br>  Thus, the tags will be divided into two fields.  However, you need to make sure that the ‚ÄúAuto-data distribution‚Äù checkbox is ticked in the tJavaFlex settings, otherwise all other data will disappear.  In essence, we simply added an additional transformation.  Other fields are identical in name and will be copied automatically. <br><br>  Next, I will talk about two slightly more complex and specific things. <br><br>  Suppose that we still want to put our data in a database.  Accordingly, we have an Event label with fields: the name of the event, the event identifier, the date of the event, and a link to the entry in the tag table.  In the tag table, two fields are a key and a value.  We want to add our key-value pair to the tag table only if it is not there.  And we also want to add a link between tags and events tables. <br>  Those.  we want: <br><br><ul><li>  check if there is such a key-value pair in the tags table and if not add </li><li>  get the id of the record in the database corresponding to our tag </li><li>  write event data, including the id of the entry in the tag table, into the event table </li></ul><br>  To add an entry only if it is not present in Postgres, you can use the construction of the form <br>  INSERT <br>  WHERE NOT EXISTS <br>  This can be done using the tPostgresqlRow component.  This component allows you to perform an arbitrary SQL query.  But we have to substitute real data into our query.  This can be done, for example, <br><br><pre> <code class="java hljs">String.format(<span class="hljs-string"><span class="hljs-string">" INSERT INTO tag(tag_name, tag_value) SELECT \'%s\', \'%s\' WHERE NOT EXISTS (SELECT * FROM tag WHERE tag_name = \'%s\' AND tag_value = \'%s\');"</span></span>, input_row.tag_name, input_row.tag_value, input_row.tag_name, input_row.tag_value)</code> </pre><br>  Yes, the parameters are listed twice the same (maybe I know Java too little).  Note that the semicolon at the end of the Java code is not needed. <br><br>  After that, you need to make a trivial query to get the id of the entry in the table. <br>  But in the case of Postgres, you can go a simpler way, and use the RETURNING id.  However, this mechanism returns the value only if the data is added.  But with the help of a subquery you can bypass this limitation.  Then our request is converted to something like this: <br><br><pre> <code class="java hljs">String.format(<span class="hljs-string"><span class="hljs-string">" WITH T1 AS ( SELECT * FROM tag WHERE tag_name = \'%s\' AND tag_value = \'%s\' ), T2 AS ( INSERT INTO tag(tag_name, tag_value) SELECT \'%s\', \'%s\' WHERE NOT EXISTS (SELECT * FROM T1) RETURNING tag_id ) SELECT tag_id FROM T1 UNION ALL SELECT tag_id FROM T2;"</span></span>, input_row.tag_name, input_row.tag_value, input_row.tag_name, input_row.tag_value)</code> </pre><br><div class="spoiler">  <b class="spoiler_title">How to get value from query</b> <div class="spoiler_text">  If the request should return values ‚Äã‚Äãin the tPostgresqlRow component, you need to enable the ‚ÄúPropagate QUERY's recordset‚Äù option (on the ‚ÄúAdvanced settings‚Äù tab), as well as in the outgoing stream, we need an Object type field that you need to specify as a field for data distribution.  To extract the data from the recordset we need the tParseRecordSet component.  In the settings in the ‚ÄúPrev.  Comp.  Column list ‚Äùyou need to select our field through which data is distributed.  Next, in the attribute table for the fields, enter the names of the fields returned by the query. <br>  You should have something like this: <br><br><img src="https://habrastorage.org/web/08a/24b/d58/08a24bd58410400198aef426b0ccac28.png"><br><br>  Those.  All our fields will automatically be set to the desired values, and the new dbtag_id field of type int will be taken from the query results using the ‚Äútag_id‚Äù key.  You can add everything to the event table using the same tPostgresqlRow or tProstgresqlOutput. <br><br>  The result is approximately the following scheme: <br><br><img src="https://habrastorage.org/web/57e/a20/bec/57ea20bec99647878022f18eef80279c.PNG"><br><br></div></div><br>  Separate consideration deserves the case when we have a need to create a closed structure.  TOS does not allow closed structures, even if they are not cyclic.  The fact is that data streams live by themselves, are not synchronized, and can carry a different number of records.  Surely, almost always you can do without the formation of closed contours.  To do this, it is necessary not to divide the threads and do everything in one.  But if you really want, then if you want you can bypass the restriction on the creation of closed structures.  We need the tHashInput and tHashOutput components. <br><br><div class="spoiler">  <b class="spoiler_title">How to find tHashInput and tHashOutput</b> <div class="spoiler_text">  By default, they are not displayed in the component panel and you will have to add them there first.  To do this, go to the menu File -&gt; Edit project properties -&gt; Designer -&gt; Palette Settings, then in the technical tab, find our components and add them to the working set. <br></div></div><br>  These components allow you to save streams in memory and then access them.  You can, of course, use a temporary file, but the hash is probably faster (if you have enough RAM). <br><br>  Add the tHashOutput component and the input stream we want to save.  A component can be configured to work independently, or to write data to another tHashOutput component.  In this case, the component will work like a union from sql, i.e.  the data will be recorded in one common stream. We will have to create a new subtask in which the merge will be performed.  Do not forget to add the OnSubjobOk link. <br><br>  For each stream, working individually, you need to create a component tHashInput.  This component has a drawback - even after specifying the tHashOutput component, from which data will be taken, the scheme will not be loaded automatically.  Further, all tHashInput need to be combined using tMap.  Only one stream will be marked as Main, the rest of the incoming flows will be synchronized, as well as the outgoing, the other incoming flows will be Lookup.  In addition, we need to set the connection between the threads, otherwise we will get a Cross Join. <br><br><img src="https://habrastorage.org/web/ef5/61b/dcb/ef561bdcbb9d476ebd7ede2c63b01d90.PNG"><br><br>  Now, despite the fact that there are many streams on the left side of the mapper, we can assume that we have one input stream and use any fields of any streams for mapping. <br><br>  That's all, thanks to all who read to the end. </div><p>Source: <a href="https://habr.com/ru/post/338352/">https://habr.com/ru/post/338352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338332/index.html">Overview of GUI Interfaces for Managing Docker Containers</a></li>
<li><a href="../338338/index.html">Kali Linux: Security Policy, Protecting Computers and Network Services</a></li>
<li><a href="../338344/index.html">Implementing code style in an existing project</a></li>
<li><a href="../338348/index.html">9 minutes on ICO: Overview of IPO for Business Alternatives</a></li>
<li><a href="../338350/index.html">How I created a profitable global SaaS project, from design to sales</a></li>
<li><a href="../338354/index.html">The category "Indie" appeared in the App Store. But it's not about that.</a></li>
<li><a href="../338356/index.html">The art of creating process diagrams</a></li>
<li><a href="../338358/index.html">Alien among his own: how to recruit to become part of the IT community</a></li>
<li><a href="../338360/index.html">Approximate search methods for nearest neighbors</a></li>
<li><a href="../338362/index.html">Create an ‚Äúexternal outline‚Äù of an ecosystem with independent developers: the results of the Skyeng API contest</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>