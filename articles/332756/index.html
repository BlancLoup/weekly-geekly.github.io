<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blockchain platform for trade contracts transactions based on smart contracts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 

- Briefly about goals and results 
- Tasks of a research project 
- The general scheme of the platform and the interaction of its elements 1...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blockchain platform for trade contracts transactions based on smart contracts</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text"><ul><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Briefly about goals and results</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Tasks of a research project</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">The general scheme of the platform and the interaction of its elements</a> <br><ol><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Architecture and interaction of platform components</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Practical implementation</a> </li></ol></li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Implementation of smart contracts for letter of credit</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Selection of platform components</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Infrastructure</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Integration of components</a> <br><ol><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Ethereum</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Swarm</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Storj.io</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">CryptoARM</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">External Request Provider</a> </li></ol></li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Detailed description of the implementation of the query provider</a> <br><ol><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Description of Contract Methods Requests Queue</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Description of required interface methods for Contracts</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Implementation example</a> </li></ol></li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">To the benefit of the community</a> <br><ol><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Calendar oracle</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">External Request Portal</a> </li></ol></li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Some comments on the experience of integrating third-party components.</a> <br><ol><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Ethereum</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Ethereum solidity</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Ethereum swarm</a> </li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">Storj.io</a> </li></ol></li><li>  <a href="https://habr.com/ru/company/raiffeisenbank/blog/332756/">The findings of the study</a> </li></ul><br></div></div><br>  On June 22, 2017, at <a href="https://spb.blockchainconf.world/ru">Blockchain &amp; Bitcoin Conference in St. Petersburg,</a> our blockchain analyst, Marina Smancer, reported on the results of a research project to create an integrated platform for trade financing transactions based on smart contracts. <br><br>  The 20-minute report format did not allow detailed technical aspects.  Therefore, Raiffeisenbank‚Äôs access to habrahabr is a great opportunity to talk about our results in all details. <br><br>  I note that the article is intended for the reader to understand the main aspects of the blockchain technology and the principles of operation of smart contracts.  Since the review on each topic is a volume for a separate article, we look forward to understanding the community. <br><a name="habracut"></a><br>  The first part will tell about the case with letters of credit, which we used, and how the platform was designed for the blockchain. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second part is most saturated with technical details: the implementation of the platform (selection and integration of its components) and smart contracts for the letter of credit will be considered in detail.  It will also describe step by step the process of settling the letter of credit through smart contracts. <br><br>  In the third part, a lot of code: separate methods of smart contracts, the specification of its own provider of external requests (oracle) and a bonus for the community: an open API for testing it.  Summarizing this section, we will talk about the problems with the components of the platform that we had to overcome. <br><br>  In the final, let us dwell on the results of the project with the letter of credit, and on what the study of the development of decentralized technologies has shown regarding their use in banking. <br><br>  We made the decision to highlight in detail our experience with the blockchain.  Blockchain is a story about interaction and collaboration.  A lot of projects appeared and developed thanks to the efforts of enthusiasts.  All technologies are new, and there are enough difficulties with their use.  We will be happy if our story becomes a useful source of knowledge. <br><br>  <i><a href="https://habrahabr.ru/users/gelbplaneten/" class="user_link">Gelbplaneten</a> actively participated in the preparation of the article <a href="https://habrahabr.ru/users/gelbplaneten/" class="user_link">.</a></i> <br><br><a name="Example"></a><h2>  Briefly about goals and results </h2><br>  At the end of 2016, the blockchain was in the zone of interest of our R &amp; D department.  It took some time to dive into the theory, after which we decided that it makes sense to make a practical implementation. <br><br>  We considered several areas of the banking business as potential options: from optimizing internal business processes to managing collateral for transactions.  In the area of ‚Äã‚Äãtrade finance, we found an immediate interest from corporate businesses and customers, so it was decided to work it out in detail. <br><br>  Specifically, we decided to stay on the letter of credit.  In its simplest form, it implements a fairly simple to understand logic, while covering many aspects of transactions from a selected area. <br><br><div class="spoiler">  <b class="spoiler_title">Letter of Credit: Theory and Business Process</b> <div class="spoiler_text">  If we abstract from the terms of trade finance, a letter of credit is a form of cashless payment.  The Bank undertakes to make a payment in favor of the Seller, if he presents documents on the execution of his part of the terms of the transaction. <br>  A letter of credit solves the problem of lack of trust between the Buyer and the Seller and reduces some of the risks: for example, those associated with the financial condition of the Buyer at the time of settlement. <br><img src="https://habrastorage.org/web/7f8/929/4f6/7f89294f60c74f0098165a19aea31d65.jpg"><br>  In a simplified form, the calculation algorithm can be represented as follows: <br><ol><li>  The parties enter into a contract for the supply of goods, which indicate the letter of credit as a method of payment. </li><li>  The buyer submits an application for opening a letter of credit to his bank. <br>  The bank carries out internal checks (for example, the availability of funds in the account).  If a positive result, the Bank issues a letter of credit. </li><li>  After issuing a letter of credit, the Bank notifies the Seller about the opening of a letter of credit under certain conditions.  The seller has the right to reject the letter of credit. </li><li>  When the goods are delivered, the Seller sends the documents specified in the terms of the letter of credit (invoice, trade invoice, etc.) for consideration by the Bank. </li><li>  The bank checks the documents and with a positive result makes the payment. </li></ol><br>  In this description, many points are simplified. </div></div><br>  The goal of the project is to investigate how technologically ready the blockchain is for real business cases from the field of trade finance.  This also applies to the maturity of technology in its pure form, and the ability to transfer the process from corporate business to the blockchain, while maintaining its level of complexity.  The second includes both the legal component for conducting transactions and the requirements for the reliability and security of the system. <br><br>  We focused on open solutions, in particular, public Ethereum was chosen as the blockchain.  Other technologies will be discussed in detail later in the article. <br><br>  As a result, we developed a software platform that combines blockchain, decentralized repositories, external data sources and an API level to internal bank systems into a comprehensive solution.  A detailed analysis of the most diverse applications of the blockchain in the bank, which we carried out before the launch of the project, helped design a modular and easily adaptable system.  And although we were developing, focusing on a very specific business case (letter of credit), the modularity of the platform allows it to be used for other business solutions that use standardized terms of transactions (stocks, bonds, registration of pledges, exchange derivatives). <br><br><a name="Example1"></a><h2>  Tasks of a research project </h2><br>  As already mentioned, the study was tasked to determine the possibility of implementing trade finance transactions in the existing blockchain-ecosystem.  By ecosystem we mean a set of technologies, including as a base both the implementation of the blockchain itself and various add-ons to them: interaction protocols and file exchange, libraries, distributed storages, etc. <br><br>  In this case, it was intended to use solutions that came out in a stable version or are at the readiness stage close to the implementation.  In the course of the study, it was intended to determine the conditions for successful integration of the selected technologies in a single platform together with the bank‚Äôs accounting systems, as well as to identify the obvious and hidden problems of such integration. <br><br>  To determine the necessary functionality for the implementation of the platform, the following initial conditions were set: <br><br><ul><li>  The execution of the transaction is accompanied by the exchange of documents between the parties. </li><li>  The main settlement of the transaction is made through ordinary (fiatnye) channels of calculation </li><li>  All transactions in a transaction must be as legally confirmed as possible, based on current regulatory documents and regulations (to ensure judicial practice ‚Äúright now‚Äù) </li><li>  All operations and transition signals between operations should be as automated as possible. </li></ul><br><a name="Example2"></a><h2>  The general scheme of the platform and the interaction of its elements </h2><br><a name="Example3"></a><h3>  Architecture and interaction of platform components </h3><br><br><img src="https://habrastorage.org/web/96d/23f/25a/96d23f25af7b492ead7e6e958cb41fc5.png" alt="image"><br><br>  The analysis of the baseline implies the need to use the following functional components: <br><br><ul><li>  Blockchain - as a trusted registry of transaction operations and a smart contract execution environment providing a transaction </li><li>  Decentralized file storage (DFS) - as a medium for storing and exchanging files associated with a transaction </li><li>  Certified CIPF - as a means of providing additional encryption, legally significant electronic signatures and protected timestamps.  In addition, it can be used to organize an additional virtual file access distribution layer if DFS does not support multi-user access mechanisms. </li><li>  Oracles and providers of external requests - for access to the accounting systems of the bank and sources of events of the outside world (registries, etc.) </li><li>  Document analyzers - for automatic analysis of documents submitted by the parties to confirm the terms of the transaction. </li></ul><br>  Considering that the basic calculations and analysis of documents in the realities of today are performed outside smart contracts, only data that they are able to process are transferred directly into smart contracts.  The remaining information (justifying and administrative documents) is attached in the form of ordinary (for manual processing) or formalized (for automatic processing) documents signed by a strengthened qualified electronic signature to ensure legal significance. <br><br>  In this case, the following logic may be assigned to the internal logic of a smart contract: <br><br><ul><li>  Ensuring that the status matrix is ‚Äã‚Äãfollowed according to the current status and the initiator of the switching transaction </li><li>  Date control for limiting the period within which documents can be submitted </li><li>  Handling the occurrence of pivot events coming from External Request Providers </li></ul><br>  The following registration information was associated with each user of the platform: <br><br><ul><li>  Unique identifier in the system </li><li>  Ethereum address from which the user sends transactions </li><li>  Address of the smart contract used to maintain a register of transactions owned or sent to the user (hereinafter referred to as the Mailbox) </li><li>  Identifier of the certificate of a strengthened qualified digital signature and its public key </li></ul><br>  <i>The simplest explanation of the concept of oracles:</i> <a href="https://blockchainhub.net/blockchain-oracles/">blockchainhub.net/blockchain-oracles</a> <br>  <i>There was no good article on DFS, I‚Äôll leave a link to the Swarm documentation:</i> <a href="https://swarm-guide.readthedocs.io/en/latest/introduction.html">swarm-guide.readthedocs.io/en/latest/introduction.html</a> <br>  <i>And Storj:</i> <a href="https://storj.io/">storj.io</a> <br><br><a name="Example4"></a><h2>  Practical implementation </h2><br>  The figure below shows the general scheme of the platform and the main data exchange flows between its functional components (with green marked ‚Äúalien‚Äù components, purple - certified, white - Bank software): <br><br><img src="https://habrastorage.org/web/d29/521/324/d295213249f34cb0b98522363bf366f2.png" alt="image"><br>  In the process of preparing and executing a transaction, the components of the platform interact as follows: <br><br><ul><li>  Client software (for example, client-bank or mobile bank).  Used to enter the initial information on the transaction, create the necessary smart contracts and manage the status of smart contracts at the manual stages of the business process.  It should be noted that the manual steps of a business process can be understood as those steps that require real ‚Äúpersonal‚Äù user actions - for example, attaching documents to a smart contract, and generally any steps at which changing the status of a smart contract is done without using its internal logic is outside the blockchain.  The latter case includes checking the documents attached to the smart contract on the bank's accounting systems, which can occur automatically, but outside the blockchain. <br><br></li><li>  The files attached to the smart contract are signed by a reinforced qualified EDS creator for his (the creator) unambiguous legally significant identification.  Further, the files are encrypted with the formation of a crypto package that can only be decrypted by the participants in the transaction.  The resulting crypto packet is placed in DFS, while the context of the smart contract is preserved in the hash of the source file, as well as the address (link, manifest) of the storage object given to DFS.  The address of the storage object allows you to extract the crypto packet from the DFS, decrypt it (the participants in the transaction) and process it properly. <br><br></li><li>  When processing transactions, a smart contract can use information from Broadcast oracles, for example, control the date of receipt of a transaction on a calendar, use currency rates, etc. <br><br></li><li> When switching to a certain status, a smart contract may send a specific request to an external request provider for an expected external event or an order to execute an external action.  When an external event ‚Äúordered‚Äù by a smart contract occurs, the Provider sends a transaction with event information to it.  According to the results of processing this transaction, the smart contract may switch to a new state or remain in the same condition pending the onset of subsequent events. <br><br></li><li>  Similar to external requests, when you attach certain formalized documents to a smart contract, a smart contract can send them to the Document Analyzer for analysis, and then wait for a transaction with the results of the analysis. </li></ul><br><a name="Example5"></a><h2>  Implementation of smart contracts for letter of credit </h2><br>  It was decided to start designing the platform in parallel with the development of a business case for implementation. <br><br>  A simplified scheme of the process on the blockchain is presented in the figure, and a detailed description of the process is given below. <br><br><img src="https://habrastorage.org/web/c53/7af/b3c/c537afb3caa948b5ba8c5bc10e9ebf78.png" alt="image"><br><br>  The participants in the transaction are the Buyer, the Seller and the Bank.  The buyer and the seller enter into a contract for the provision of certain services or goods, and the fact of their provision can be identified automatically.  For example, if a letter of credit is opened for settlements when transferring ownership of real estate, shares, shares, etc., information will be checked in submitted documents against information in external sources (for example, in the unified state register of real estate).  Further operational support of the transaction is carried out through the Platform. <br><br><ol><li>  The buyer creates a smart contract "Application for letter of credit" (hereinafter referred to as "Application"), which receives the status of <b>New</b> . <br><br>  The address of the Application is placed in the Mailboxes of the Buyer and the Bank. <br><br></li><li>  The buyer attaches to the Application a formalized document describing the details of the transaction and the necessary non-formalized documents, for example, a scanned copy of the contract for which the letter of credit is opened. <br><br>  After attaching all the necessary documents, the Buyer transfers the Application to <b>InBank</b> status. <br><br></li><li>  The bank automatically (for formalized ED) or with the use of experts (for unformalized ED) checks the transaction.  For example, a request is sent to the bank systems for checking client details in the client data catalog, for confirming the account balance and reserving funds for other checks (for example, checks for compliance, currency control, etc.) <br><br>  If the Bank has any claims regarding the content of the transaction or the attached documents, it refuses to accept the Application and establishes the status <b>Rejected</b> . <br><br>  If the Bank agrees to accept the application for execution, the <b>Confirmed</b> status shall be established. <br><br></li><li>  On the basis of a formalized ED describing the transaction, the Bank‚Äôs accounting systems perform the necessary manipulations (transfer of the amount of the letter of credit from the client account to the ‚Äúcoverage account‚Äù, charge-off, etc.) <br><br>  The Bank issues a smart contract "Letter of Credit" (hereinafter referred to as Letter of Credit), which receives the status of <b>New</b> . <br><br>  The address of the letter of credit is placed in the mailboxes of the Bank and the Seller. <br><br>  The Letter of Credit preserves the address of the Application, which allows you to automatically ‚Äúmirror‚Äù the key statuses of the Letter of Credit on the Application, so that the Buyer can monitor the status of the transaction. <br><br></li><li>  The Bank attaches to the Letter of Credit a formalized ED (automatically generated from the conditions of the Application) with a description of the details of the transaction, other necessary documents and establishes its <b>Released</b> status. <br><br>  The status of the L / C Application is also switched to <b>Released</b> . <br><br>  When switching to <b>Released</b> status, the Letter of Credit automatically places two requests into the External Request Provider's queue: <br><br><ul><li>  Request to control the expiration of the Letter of Credit (triggered when the current date exceeds the term of the Letter of Credit) </li><li>  Request to wait for the execution of the contract (the specific request template is determined by the content of the transaction) </li></ul></li><li>  The seller, after studying the issued Letter of Credit, may refuse to accept it: in this case, he transfers it to <b>Invalid</b> status, the letter of credit is canceled, and further manipulations with it become impossible. <br><br>  The status of the L / C Application is also switched to <b>Invalid</b> . <br><br></li><li>  If the event of expiration of the Letter of Credit is the first to be triggered, then it receives the status of <b>Overdue</b> and further manipulations with it become impossible. <br><br>  The status of the L / C Application is also switched to <b>Overdue</b> . <br><br>  In this case, automatic orders are sent to the accounting systems of the Bank to initiate transactions that correspond to the cancellation of the letter of credit (return of coverage, termination of the bank‚Äôs obligations, etc.) <br><br></li><li>  If the first event is the execution of the contract (or when the Seller attaches the ED, stipulated by the conditions of the Letter of Credit) - the Letter of Credit switches to <b>InBank</b> status.  When switching to <b>InBank</b> status, the <b>Letter of</b> Credit automatically places a request in the External Request Provider's queue to wait for payment and removes the expiration control request from the queue. <br><br>  The Bank, on the basis of a formalized ED attached to the Letter of Credit, makes a payment in favor of the Seller by submitting the order to its settlement system and executing the Payment outside the blockchain (information on the actual execution of the Payment is returned to the blockchain). <br><br></li><li>  After the execution of the payment execution event, the Letter of Credit switches to <b>Closed</b> status. <br><br>  The status of the L / C Application is also switched to <b>Closed</b> . <br><br></li><li>  The transaction is completed. </li></ol><br><a name="Example6"></a><h2>  Selection of platform components </h2><br>  When choosing the functional components of the platform, we focused on open solutions (Ethereum, Swarm, Storj).  This is due to the following advantages: <br><br><ul><li>  Presence of the developed and "self-supported" infrastructure </li><li>  Openness to users and the ability to control operations through alternative sources, not only through the interface offered by the bank </li><li>  High level of user confidence due to the presence of competitive consensus protocols and high-quality ‚Äúnon-tolerant‚Äù network of independent nodes </li></ul><br><img src="https://habrastorage.org/web/0ed/d1c/ff2/0edd1cff2f1444fc927424f471371c1b.png" alt="image"><br>  Thus, the choice was made in favor of the following implementations: <br><br><ul><li>  Blockchain and smart contracts - Ethereum and Solidity; </li><li>  Decentralized file storage - Swarm and Storj.io; </li><li>  Certified SKZI - CryptoPRO and CryptoARM; </li><li>  Broadcast Oracle - own development; </li><li>  External requests providers are proprietary; </li><li>  Document analyzer - at this stage it was decided not to consider, since the principle of interaction with it of a smart contract is generally similar to the Provider of external requests, and the resources of the research team are limited. </li></ul><br><a name="Example7"></a><h2>  Infrastructure </h2><br>  To deploy the necessary components: <br><br><ul><li>  Ethereum, Swarm and Storj.io client parts, </li><li>  SKZI, </li><li>  Provider external requests </li><li>  UI applications </li><li>  Integration Core Platform </li></ul><br>  2 servers were allocated. <br><br>  On the first server, the Ethereum node of the base blockchain of smart contracts was deployed.  Initially, the Ropsten test network was used as the base blockchain, but in the final stages we switched to a more stable Rinkeby.  The reason for this was the <a href="http://coinews.io/ru/category/2-ethereum/article/322-ddos-ataki-jefiriuma-vernulis%2527---teper%2527-v-testovoj-seti">March incident with the DDOS attack on Ropsten</a> , during which several days there were problems with the addition of transactions. <br><br>  On the second server, the infrastructure was deployed to work with the files: <br><br><ul><li>  DFS node Storj.io </li><li>  DFS Swarm with Ropston Ethereum </li><li>  SKZI CryptoPRO and CryptoARM </li></ul><br>  In addition, for reasons of convenience, the integration core of the platform was deployed there. <br><br>  The provider of external requests was deployed on each of the servers and could, if necessary, run on any of them. <br><br>  The UI application could be launched either on any of the servers, or use a special proxy protocol for working over the Internet. <br><br><a name="Example8"></a><h2>  Integration of components </h2><br><a name="Example9"></a><h3>  Ethereum </h3><br>  Integration with the Ethereum blockchain was carried out using the RPC API <a href="https://github.com/ethereum/wiki/wiki/JSON-RPC">JSON-RPC</a> , <a href="https://github.com/ethereum/go-ethereum/wiki/Management-APIs">Management-APIs</a> . <br><br>  There were no technical problems with its use. <br><br>  As an external arbitration resource, <a href="http://ropsten.etherscan.io/">ropsten.etherscan.io</a> or <a href="http://rinkeby.etherscan.io/">rinkeby.etherscan.io was used</a> , depending on the test network used. <br><br><a name="Example10"></a><h3>  Swarm </h3><br>  Integration with Swarm was carried out using the HTTP API: <a href="&amp;xid=17259,15700022,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjOfZDq7Twz0OwZk4i9sLTreYQCfw#the-">Swarm-guide</a> , <a href="https://gist.github.com/lmars/a37f3eaa129f95273c8c536e98920368">gist.github.com</a> . <br><br>  An HTTP <b>PUT / bzz</b> request was used to upload the file to SWARM <b>: $ PATH $</b> ($ PATH $ is the path to the downloaded file). <br><br>  in response to which came the 16th identifier of the manifest of the file that was used to extract it from the SWARM. <br><br>  To retrieve a file from SWARM, an HTTP <b>GET / bzzi</b> request was <b>used: / $ MANIFEST $ /</b> ($ MANIFEST $ is the hexadecimal identifier of the manifest of the extracted file). <br><br>  There were no problems with uploading / uploading files. <br><br>  Unfortunately, no external monitoring tool (such as Etherscan for Ethereum) was found for Swarm, which in some way made it difficult to evaluate the success of file manipulations. <br><br><a name="Example11"></a><h3>  Storj.io </h3><br>  Integration with Storj using the proposed API by the developer turned out to be extremely difficult and inconvenient.  As a result, the Storj node console was used to work with files. <br><br>  To download the file, use the <b>storj upload-file $ BUCKET $ $ PATH $</b> command (where $ BUCKET $ is the ‚Äúbasket‚Äù identifier, and $ PATH $ is the path to the file being downloaded). <br>  Upon successful upload, the identifier of the uploaded file was given in response. <br><br>  To upload the file, use the <b>storj</b> command <b>download-file $ BUCKET $ $ FILE $ $ PATH $</b> (where $ BUCKET $ is the ‚Äúbasket‚Äù identifier, $ FILE $ is the file identifier, and $ PATH $ is the path to the local copy of the file). <br><br>  The peculiarities of Storj include the fact that more than one file with the same name cannot be put into one ‚Äúbasket‚Äù, which requires the use of a mechanism for generating unique names when loading. <br><br>  You can use <a href="https://api.storj.io/">https://api.storj.io</a> as an external arbitration resource, which supports the API. <br><br><a name="Example12"></a><h3>  CryptoARM </h3><br>  Integration with CryptoARM was carried out using the COM-service it provides.  For quick implementation, integration scripts were written on vbs. <br><br><a name="Example13"></a><h3>  External Request Provider </h3><br>  The interaction of smart contracts with the External Requests Provider is performed as follows. <br><img src="https://habrastorage.org/web/73b/b2b/87a/73bb2b87ac8a4b8a8c74de2ec8a8f90d.png" alt="image"><br><br><a name="Example40"></a><a name="Example41"></a><a name="Example15"></a><br><div class="spoiler">  <b class="spoiler_title">Detailed description of the implementation of the query provider</b> <div class="spoiler_text">  Before describing the process, it is necessary to define some basic concepts: <br><ul><li>  <b>The request identifier</b> is a 32-character value (64-digit hex), which contains the first 20 (40 hex) characters of the contract address, and then arbitrary information that allows the contract to build a proper response to the request when it receives a response. </li><li>  <b>The response identifier</b> is a unique 32-character value (64-digit hex), which allows the External Request Provider to uniquely identify the response message. </li></ul><br><br>  To use the External Request Provider, the smart contract must support a special interface consisting of the following methods: <b>GetExternalRequest</b> , <b>SetExternalResponse</b> and <b>CheckExternalResponse</b> . <br><br>  The order of interaction of a <b>Contract</b> that wants to receive an ‚Äúoutside‚Äù answer to a certain request with the External Event Provider is as follows: <br><ol><li>  Contract by transaction through the <b>AddRequest</b> method sends the request identifier to the smart contract <b>RequestsQueue</b> , whose address is fixed. </li><li>  The external request provider (PRP) periodically polls the <b>RequestsQueue</b> smart contract via the <b>GetRequests</b> method and gets the current list of requests to be executed. </li><li>  Upon receipt of a new request, the PRS through the <b>GetExternalRequest</b> method <b>refers</b> to the Contract and receives the request parameters by the request ID: <br><ul><li>  Periodicity of request execution (for example, ‚ÄúDAILY 10:00‚Äù or ‚ÄúPERIOD 20‚Äù) </li><li>  Request pattern identifier (for example, "CALENDAR" or "DADATA_NAME_EXISTS") </li><li>  Additional parameters, if required (for example, the name of the organization for the ‚ÄúDADATA_NAME_EXISTS‚Äù template) </li></ul></li><li>  In the order of general management of the PVZ queue with the periodicity specified for this request, it polls external resources in accordance with the request template and the attached parameters. </li><li>  If, according to the logic embedded in the template, it is considered that the response to the request has been received, the EAP transmits it to the Contract via the <b>SetExternalResponse</b> method in conjunction with the request identifier and the response identifier. <br>  In this case, the Contract must perform the appropriate processing of the received response and record the response identifier for further control. </li><li>  Next, the PFH requests from the Contract via the <b>CheckExternalResponse</b> method whether the response was received and processed and what the fate of the corresponding request was. <br>  The contract may offer one of the following options: <br><ul><li>  FAIL - no response, not processed or incorrect - you must repeat the request and send the response </li><li>  REPEAT - the answer is accepted, it is necessary to continue the execution of the corresponding request with the same parameters </li><li>  DELETE - the answer is accepted, the request must be removed from the queue. </li><li>  DELETE_ALL - the answer is accepted, it is necessary to delete from the queue all requests received from this Contract </li></ul></li><li>  In the event that in the previous paragraph the Contract sent the answer DELETE (DELETE_ALL) - the PVZ deletes the request (s) from the <b>RequestsQueue</b> smart contract via the <b>DeleteRequest</b> method. </li></ol><br><br>  If necessary, the Contract itself can delete requests that have become unnecessary, using transactional methods DeleteRequest of the smart contract RequestsQueue. <br><br>  Here it is necessary to pay attention to the fact that the query template can use a rather complicated logic to interpret the response receiving event.  For example, the answer can be considered as received only if the request gave only a certain result - and only for this result will be sent a response to the Contract that ordered the request.  All other results will be ignored and the query will continue to be executed.  Similarly, a template may involve referring to several external sources at once and receiving from them a specific combination of private answers. <br><br>  To exclude "unauthorized" sources of requests, a smart queue contract contains a managed list of addresses that must be source (txn.origin) addresses of transactions queuing the request. <br><br><h3>  Description of Contract Methods Requests Queue </h3><br><br><table><tbody><tr><td>  <nobr>AddRequest</nobr> </td><td>  Add request to queue </td><td>  Input parameters: <br><ul><li>  Request ID (bytes32) </li></ul><br></td></tr><tr><td>  <nobr>DeleteRequest</nobr> </td><td>  Removing a request from a queue </td><td>  Input parameters: <br><ul><li>  Request ID (bytes32) </li></ul></td></tr><tr><td>  <nobr>CheckRequest</nobr> </td><td>  Check for a request in the queue </td><td>  Input parameters: <br><ul><li>  Request ID (bytes32) </li></ul><br></td></tr><tr><td>  <nobr>Getrequest</nobr> </td><td>  List the queue request IDs </td><td>  No input parameters. <br>  Output Parameters: <br><ul><li>  List of identifiers (bytes32 []) </li></ul><br></td></tr><tr><td>  <nobr>Addbank</nobr> </td><td>  Add an address to the list of authorized addresses </td><td>  Input parameters: <br><ul><li>  Address </li></ul><br></td></tr><tr><td>  <nobr>CheckBank</nobr> </td><td>  Check whether the address in the list of authorized addresses </td><td>  Input parameters: <br><ul><li>  Address </li></ul><br></td></tr></tbody></table><br><br><a name="Example42"></a><h3>  Description of required interface methods for Contracts </h3><br><br><table><tbody><tr><td>  <nobr>GetExternalRequest</nobr> </td><td>  Get query parameters </td><td>  Input parameters: <br><ul><li>  Request ID (bytes32) <br>  Output (as a bytes32 [] array): </li><li>  Timing specification (when or how often the request should be executed) </li><li>  Name of the query implementation pattern </li><li>  Request parameters (may be missing or there may be several) </li></ul><br></td></tr><tr><td>  <nobr>SetExternalResponse</nobr> </td><td>  Accept the response to the request </td><td>  Input parameters: <br><ul><li>  Response ID (bytes32) </li><li>  Request ID (bytes32) </li><li>  Response data (bytes32 array) </li></ul></td></tr><tr><td>  <nobr>CheckExternalResponse</nobr> </td><td>  Verify that the response to the request was processed </td><td>  Input parameters: <br><ul><li>  Response ID (bytes32) </li><li>  Request ID (bytes32) </li></ul><br>  Output: <br><ul><li>  Response processing status </li><li>  For response processing status, one of the following options is possible: </li><li>  FAIL - no response was received or processed. </li><li>  DELETE - response received and processed, delete request from the queue. </li><li>  DELETE_ALL - response is received and processed, <u>all requests from this contract are</u> deleted from the queue </li><li>  REPEAT - response received and processed, continue to execute the request </li></ul><br></td></tr></tbody></table><br><br><h3>  Implementation example </h3><br>  Below is an example of the implementation of the methods in the contract. <br>  The contract involved calls for two external requests ‚Äî a date delay (the OVERDUE pattern) and an organization‚Äôs registration check (DADATA_EXISTS_WAIT). <br>  Code that is not directly related to working with external queries is excluded. <br><br><h3>  Description of stored variables </h3><br> <code>bytes32 Status ; <br> bytes32 ExpireDate ; <br> bytes32 OrgName ; <br> address Queue ; <br> bytes32[] Request_1 ; <br> bytes32[] Request_2 ; <br> bytes32 Request_id_1 ; <br> bytes32 Request_id_2 ; <br> bytes32 Response_id_1 ; <br> bytes32 Response_id_2 ;</code> <br> <br><h3>  <u>Contract constructor</u> </h3><br> <code>function SomeContract(..., bytes32[] logics) <br> { <br> Owner =msg.sender ; <br> ExpireDate=logics[0] ; <br> OrgName =logics[1] ; <br> Status ="New" ; <br> Queue =0xd9b076d0b559f70782f379582bd3d54b85fc42cb ; <br> Request_1.length= 3 ; <br> Request_1[0] ="DAILY 00:10" ; <br> Request_1[1] ="OVERDUE" ; <br> Request_1[2] = ExpireDate ; <br> Request_2.length= 3 ; <br> Request_2[0] ="PERIOD 10" ; <br> Request_2[1] ="DADATA_EXISTS_WAIT" ; <br> Request_2[2] = OrgName ; <br> } <br></code> <br><h3>  <u>Registration of requests in the queue (in case of transition of the contract to the appropriate status)</u> </h3><br> <code>function SetStatus(bytes32 status_, ...) <br> { <br> address self_addr ; <br> Status=status_ ; <br> if(status_=="Released_") { <br> self_addr=this ; <br> Request_id_1=bytes32(bytes20(self_addr)) | "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x001" ; <br> Request_id_2=bytes32(bytes20(self_addr)) | "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x002" ; <br> Queue.call.gas(0x30000).value(0)(bytes4(sha3("AddRequest(bytes32)")), Request_id_1) ; <br> Queue.call.gas(0x30000).value(0)(bytes4(sha3("AddRequest(bytes32)")), Request_id_2) ; <br> } <br> } <br></code> <br><h3>  <u>Get query parameters</u> </h3><br> <code>function GetExternalRequest(bytes32 request_id_) constant returns (bytes32[] retVal) <br> { <br> if(request_id_==Request_id_1) return(Request_1) ; <br> if(request_id_==Request_id_2) return(Request_2) ; <br> }</code> <br> <br><h3>  <u>Accept the response to the request</u> </h3><br> <code>function SetExternalResponse(bytes32 response_id_, bytes32 request_id_, bytes32[] response_) <br> { <br> if(tx.origin!=Owner) return ; <br> if(Status!="Released_") return ; <br> if(request_id_==Request_id_1) { <br> Response_id_1=response_id_ ; <br> Status ="Overdue__" ; <br> } <br> if(request_id_==Request_id_2) { <br> Response_id_2=response_id_ ; <br> Status ="ToBank___" ; <br> } <br> }</code> <br> </div></div><br><br><a name="Example24"></a><h2>  To the benefit of the community </h2><br>  For those who want to try the technology of tracking external events and working with oracles and providers of external requests, we have deployed on the Ethereum Rinkeby network: <br><br><ul><li>  Calendar oracle (gives the current date in Moscow) </li><li>  External Request Portal </li></ul><br><a name="Example25"></a><h3>  <b>Calendar oracle</b> </h3><br>  The Oracle calendar is located in the Rinkeby test network at <b>79548a65e3ce179ec8d208c22ee84435dc34058f</b> and gives the current calendar date in Moscow in the format YYYY / MM / DD. <br><br>  An example of an appeal to the Oracle: <br><br> <code>contract Check_request <br> { <br> Calendar Oracle ; // - <br> bytes32 Date ; <br> function Check_request() <br> { <br> //  -    <br> Oracle=Calendar(0x79548a65e3ce179ec8d208c22ee84435dc34058f) ; <br> //     <br> Date=Oracle.GetDate() ; <br> } <br> } <br> <br> // <br> //       <br> // <br> contract Calendar <br> { <br> function GetDate() constant returns (bytes32 retVal) ; <br> }</code> <br> <br><a name="Example26"></a><h2>  External Request Portal </h2><br>  The queue of the smart contract of the External Requests Portal is located on the Rinkeby test network at <b>d9b076d0b559f70782f379582bd3d54b85fc42cb</b> . <br><br>  The protocol for interacting with the External Request Portal is described above.  The following query templates are currently open to the public: <br><br><ul><li>  OVERDUE - control of the delay of the date, the request parameter - the date of the delay in the format YYYY / MM / DD <br>  The event transaction is transmitted to the requesting smart contract at the time of detection of the delay date and contains the current date. </li><li>  WEATHER_TEMP - Current temperature request (via the portal <a href="http://api.openweathermap.org/">api.openweathermap.org</a> ), query parameter ‚Äî name of the city, for example, Moscow (details can be found on the source portal). <br>  The event transaction is transmitted to the requesting smart contract at the time of receiving the response from the source portal. </li></ul><br>  To access the External Requests Portal queue, you must tell us (in a comment or in a personal note) the address of the Ethereum account from which queuing transactions will be sent. <br>  It is advisable to apply 0.1 Ether to the transaction (this is free, we are in a test network) to debug the mechanism of paid services.  In Rinkeby, you can get air only with the help of a <a href="https://faucet.rinkeby.io/">faucet</a> , due to the lack of mining opportunities due to the PoA protocol. <br><br><a name="Example18"></a><h2>  Some comments on the experience of integrating third-party components. </h2><br><a name="Example19"></a><h3>  Ethereum </h3><br>  When implementing paid services for smart contracts, it would be extremely useful to be able to execute transactions at the expense of the ‚Äúaccepting‚Äù smart contract, and not at the expense of the transaction initiator (of course, if the smart contract is in any way agreed to this - for example , due to the mechanism of trusted addresses or something like that).  This will greatly simplify the mechanisms for calculating the ‚Äúservices‚Äù, since the initiator of the transaction also pays for the execution of the smart contract method, the cost of which (execution) cannot always be determined in advance. <br><br><a name="Example20"></a><h3>  Ethereum solidity </h3><br>  The development of non-trivial scenarios that interact with the "outside world" is greatly complicated by the lack of built-in functions for working with strings - concatenation, search, and fragment cutting. <br><br><a name="Example21"></a><h3>  Ethereum swarm </h3><br>  It is highly desirable to have, like the main Ethereum, a mechanism for confirming the download of a file to the Swarm (its distribution to other nodes) is similar to the confirmation of a transaction.  For it is unclear whether the file is saved somewhere outside your node or not. <br><br>  Building from sources and deploying a Swarm node for Windows is an extremely trivial task.  The developers have tested and prepared documentation only for linux and OSX, which they honestly admit. <br><br><a name="Example22"></a><h3>  Storj.io </h3><br>  Extremely difficult to use, too detailed API.  For simple integration, it is desirable to have an ‚Äúintegrated‚Äù API, similar to that implemented in Ethereum Swarm - put the file, extract the file. <br><br>  Missing multi-user file access.  That is, the file can be read only from under the account details under which it was recorded.  This leads to the fact that for the organization of multi-user file sharing it is necessary to actually ‚Äúdisclose‚Äù your account details, which, given the payment for the service, is not a good practice. <br><br><a name="Example23"></a><h2>  The findings of the study </h2><br>  At present, the components of the blockchain ecosystem that are productive or close to production can fully realize the functionality necessary to support the execution of trade finance transactions. <br><br>  Of course, there are certain non-technical issues that need to be resolved in order to be able to talk about the implementation of large projects for trade finance (and indeed many areas close to it in terms of objectives) on the blockchain. <br><br>  Firstly, the legal issues of transactions carried out through the blockchain, including the legal status of entries in the blockchain. <br><br>  Secondly, now in Russia, the use by banks of public blockchains is actually blocked by the position of the regulator in relation to cryptocurrencies: the ban on their use makes it impossible to pay a fee for adding a transaction (transaction fee).  Transactions in this case are needed not for settlement, but as a way to create smart contracts and interact with them. <br><br>  Thirdly, it is necessary to standardize the formats of electronic documents for the possibility of their automatic verification. <br><br>  Finally, the blockchain ecosystem needs to be saturated with sources of external events: oracles to various registries, information systems of banks and transport companies, etc.  This will help eliminate the need for manual entry of external events and make the execution of smart contracts truly automatic and depersonalized. <br><br>  It becomes obvious that in such projects the technical side is not the most significant part of the work.  Now that the development has been completed, we continue to work with lawyers and work with other banks on approaches to defining unified requirements for electronic document formats to automate the verification of their content. <br><br>  The case with the letter of credit allowed us to get both the technical base and the experience of implementing decentralized applications in the field of TF.  Now we are looking at several areas in which we are interested in making a pilot, we will tell about them later. <br><br>  Stay tuned! </div><p>Source: <a href="https://habr.com/ru/post/332756/">https://habr.com/ru/post/332756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332744/index.html">Why is there no Russian Amazon, or where is @ buried? Myths to close</a></li>
<li><a href="../332746/index.html">Hunting a red demon or satellite navigation direction finder</a></li>
<li><a href="../332748/index.html">Trading ASCII: Traditional Roguelike Early Access Sales Results</a></li>
<li><a href="../332750/index.html">Canvas & SVG: working with graphics</a></li>
<li><a href="../332754/index.html">Guide: Cucumber + Java</a></li>
<li><a href="../332760/index.html">Interview with Venmo developer Nina Zakharenko about Python and not only</a></li>
<li><a href="../332762/index.html">Post mortem</a></li>
<li><a href="../332766/index.html">Parallels Remote Application Server v.16.0: New Features and Functionality</a></li>
<li><a href="../332768/index.html">We write nice Node.js-API using async / await and Firebase database</a></li>
<li><a href="../332770/index.html">MicroFocus-Serena released version SBM 11.3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>