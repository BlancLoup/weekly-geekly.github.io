<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The evolution of garbage collection in Ruby. Rgenc</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Koichi: Ruby's garbage collector threshold is 8 MB. Why use such a small value? 
 Matz: Because 20 years ago I was working on a machine with 10 MB of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The evolution of garbage collection in Ruby. Rgenc</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <i>Koichi: Ruby's garbage collector threshold is 8 MB.</i>  <i>Why use such a small value?</i> <i><br></i>  <i>Matz: Because 20 years ago I was working on a machine with 10 MB of memory.</i> </blockquote><br>  The issue of performance has always been one of the most discussed and relevant in the Ruby community.  Whether it is a high load web site or a simple data backup script, the speed of work is their most important characteristic.  At the same time, knowledge of the possibilities and limitations of the development language is often an important source of ideas for optimization, it allows you to "squeeze" the maximum out of the system. <br><br>  The article focuses on one of the most strongly influencing parts of the Ruby language ‚Äî the garbage collector, the algorithms for its work, and the improvements made to its work in the latest versions of the language.  It will be about the most common, ‚Äúcanonical‚Äù implementation of Ruby - the so-called MRI or CRuby. <br><a name="habracut"></a><br><h4>  The basics </h4><br>  Garbage collection (GC) in programming languages ‚Äã‚Äãis a mechanism for automatic memory management without programmer intervention.  GC is not a specific feature of Ruby - a similar mechanism is used in a significant part of modern development languages: Java, Python, C #, and others.  MRI uses the classic Mark-and-Sweep garbage collection algorithm developed back in the 1960s. <br><br>  Ruby uses heaps to allocate memory for new objects.  The process of creating objects is interrupted when one of two conditions <code>malloc_limit</code> : the program's memory has run out or a certain allocation threshold has been reached - the so-called <code>malloc_limit</code> .  At this point, MRI starts garbage collection, more precisely its first, ‚Äúmark‚Äù phase. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d61/970/90d/d6197090dabb9847d45ab799f780c545.png" alt="image"></div><br>  The garbage collector goes through a tree of objects in the program's memory, starting with the ‚Äúroot‚Äù objects - these are global variables or internal structures of the language.  Running over the links of objects on each other, the garbage collector marks objects as used.  All data not marked as used in the mark-phase - ‚Äújunk‚Äù and the memory they occupy can be freed.  The release of memory from the "garbage" occurs in the second, sweep-phase GC. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Optimization of the garbage collector.  Ruby 1.9.3 and 2.0 </h4><br>  The classic Mark-and-Sweep algorithm has several disadvantages.  First of all, these are significant pauses in the program, during which the execution of useful user code stops and the garbage collector is running.  The longer such ‚Äústop-the-world‚Äù pauses, the slower the program works from the end user's point of view.  To reduce the length of pauses spent on garbage collection, the Lazy Sweep algorithm was implemented in Ruby 1.9.3.  Starting with this version of MRI, the sweep-stage of garbage collection does not end with the complete freeing of memory from unnecessary objects, but only frees up the amount of memory that is necessary to continue the execution of the program ‚Äî to create a new object.  When creating the next object, some memory is released again, and so on. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ce/bc4/d15/2cebc4d15142e62129ddceed41e12f3f.png"></div><br>  In Ruby 2.0, another garbage collector improvement has been integrated - Bitmap Marking GC.  This algorithm is aimed at Unix systems, which use the copy-on-write mechanism when creating child processes using <code>fork</code> .  The child process is created quickly, because its memory is only a ‚Äúmapping‚Äù of the memory of the corresponding parent process.  The real separation of the memory of the parent and child process occurs after writing any data to the common memory area.  Many popular Ruby libraries use <code>fork</code> , such as the popular Unicorn application server and the library for performing background tasks Resque.  However, the classic garbage collector in MRI did not fit well with the <code>fork</code> semantics, because during the mark phase I set the ‚Äúusability‚Äù flag on each object, thereby modifying a significant part of the heap, effectively leveling the advantages of the copy-on-write mechanism for Ruby processes.  In Ruby 2.0, the flags, whether objects are used or not, were moved to a separate structure ‚Äî a bit mask stored independently of the objects themselves.  This made it possible to significantly increase the amount of memory shared by the processes when <code>fork</code> and it is better to use the advantages of copy-on-write semantics. <br><br><h4>  malloc_limit  The problem is 8 MB. </h4><br>  The most important characteristic of the garbage collector is the <code>malloc_limit</code> parameter ‚Äî the memory allocation threshold, after which the GC is started.  However, the value of this characteristic by default was extremely small - 8 MB.  In modern systems, processing a request on a website can result in a sample of tens of megabytes of data from the database or reading large files.  In this case, garbage collection is performed too often, reducing the speed of the program. <br><br>  Partly to solve this problem, application server developers attempted to make the garbage collector's behavior more predictable and minimize the impact of GC on the speed of processing HTTP requests.  This has led to the emergence of technologies such as <a href="http://unicorn.bogomips.org/Unicorn/OobGC.html">Unicorn OobGC</a> and <a href="http://blog.phusion.nl/2013/01/22/phusion-passenger-4-technology-preview-out-of-band-work/">Passenger Out-of-Band Work</a> .  Both solutions disable garbage collection at the time of processing the request and force it to run after the request is processed by the server.  Such a mechanism is also not without flaws: GC can be launched more often than needed, if the requests are ‚Äúlightweight‚Äù, or, on the contrary, the process can ‚Äúeat‚Äù too much memory. <br><br>  The <code>malloc_limit</code> functionality was revised in Ruby 2.1 - the GC trigger threshold began to adapt to the behavior of the application, and the default value was increased to 16 MB.  Now <code>malloc_limit</code> automatically changes with massive memory allocation, with the result that the garbage collector runs much less frequently. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/b87/d1f/ad2b87d1fcbdfc1d7151f366e32189d7.png" alt="image"></div><br><h4>  Ruby 2.1.  Object Generations </h4><br>  The release of Ruby 2.1 was marked by significant changes in the algorithm of the GC.  The generation-based garbage collector has been integrated into the language.  His work is based on the hypothesis that most of the objects created in the program are ‚Äúdie young‚Äù.  Thus, the main activity of the garbage collector is associated with objects that have a short life cycle. <br><br>  In Ruby, the memory is divided into 2 generations of objects - the generation of young objects and the older generation, which includes objects that have survived at least one garbage collection.  In most cases, garbage collection is carried out only within the younger generation.  Only at the moment when the memory runs out - complete garbage collection is performed with the participation of both generations. <br><br>  An important problem with this approach are backlinks from the objects of the older generation to the objects of the younger generation. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/df1/56b/454df156bd1b742c1cd1a659f49c0212.png" alt="image"></div><br>  If you do not take into account the possibility of the emergence of such links, minor GC - garbage collection within the younger generation can mark the actually used objects as garbage.  To solve this problem, a special structure is used - Remember Set, in which problem links are remembered.  To determine whether such links appear, the reading barrier in the Ruby interpreter is used.  ‚ÄúAdult‚Äù objects from which references to objects of the younger generation are used as root for minor garbage collection. <br><br>  A significant limitation of garbage collection in MRI is the need to maintain backward compatibility with all the many C extensions developed for the language.  That is why the Ruby GC algorithm is called RGenGC - Restricted Generational GC.  The ‚Äúlimitation‚Äù of garbage collection is that all objects are divided into 2 types: shady objects are objects that are used or can be potentially used in C-extensions.  Accordingly, the garbage collector cannot safely move them between generations.  If such an object falls into the older generation, it will not be protected by a reading barrier, since the former semantics of the language did not require C-extensions to use such barriers.  As a result, there may be "problem" links described above. <br><br>  Shady objects do not participate in garbage collection for generations, only normal objects migrate between generations.  This solution made it possible to maintain compatibility with existing C-libraries and simplified the development of the garbage collector.  However, in turn, it excludes a significant number of objects from the work of the new garbage collector.  Nevertheless, according to the measurements of the RGenGC developers, the acceleration of the application performance when using the new garbage collector is about 10%. <br><br><h4>  Future plans </h4><br>  The garbage collector is one of the most dynamic parts of the language.  In the near future - bringing the number of generations of the language to three.  Of more global things, it is planned to introduce parallelism in the mark and sweep phases of garbage collection, which will make it possible to better use the capabilities of modern multi-core processors. <br><br><h5>  Additional sources of information </h5><br>  <a href="http://www.youtube.com/watch%3Fv%3DhVqoX4QE2O0">Presentation of Koichi Sasad at RubyConf 2013</a> <br>  <a href="http://patshaughnessy.net/ruby-under-a-microscope">The book Ruby Under a Microscope (2013)</a> </div><p>Source: <a href="https://habr.com/ru/post/208256/">https://habr.com/ru/post/208256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208240/index.html">Logic function recovery</a></li>
<li><a href="../208244/index.html">Parallel and distributed computing. Lectures from Yandex for those who want to spend the holidays with benefit</a></li>
<li><a href="../208246/index.html">New Google API for site verification</a></li>
<li><a href="../208250/index.html">Wi-Fi trap from the NSA can work up to 8 miles</a></li>
<li><a href="../208252/index.html">Voltage relay overview with control of current DigiTop VA-protector 63A</a></li>
<li><a href="../208258/index.html">How do we know what marketing is?</a></li>
<li><a href="../208262/index.html">Google has organized a car alliance</a></li>
<li><a href="../208264/index.html">10 potential SQL errors that programmers make</a></li>
<li><a href="../208266/index.html">Making homemade accessories for the Nintendo Wii</a></li>
<li><a href="../208268/index.html">As Robert Morris on 8 bits to 10,000 counted</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>