<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>HTTP / 2 Server Push is not as simple as I thought.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Photo found on Wikipedia 


 Hello! My name is Max Matiukhin, I work as a Badoo PHP programmer. We are constantly exploring various possibilities to s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>HTTP / 2 Server Push is not as simple as I thought.</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/635/c11/9bd/635c119bd66f4093a6ada83a9de738b7.jpg"><br>  <em>Photo found on <a href="">Wikipedia</a></em> </p><br><p>  <em>Hello!</em>  <em>My name is Max Matiukhin, I work as a Badoo PHP programmer.</em>  <em>We are constantly exploring various possibilities to speed up the work of our application and, of course, we share the most interesting finds in our blog on Habr√©.</em> </p><br><p>  <em>The second version of the HTTP protocol promises us a lot of improvements, and one of the interesting features of HTTP / 2 is support for push.</em>  <em>Theoretically, this feature allows you to speed up the loading of the application.</em>  <em>Recently, Jake Archibald wrote a large article in which he analyzed the features of push implementation in various browsers, and it turned out that there are quite a few such features.</em> </p><br><p>  <em><a href="https://habrahabr.ru/company/badoo/blog/329722/">We have already published a post</a> describing the basic HTTP / 2 Server Push functionality, and this one will be a good addition, telling how the reality with HTTP / 2 Server Push support in various browsers.</em> </p><a name="habracut"></a><br><p>  I have heard the phrase ‚ÄúHTTP / 2 Server Push cope with this‚Äù many times when it came to problems with loading the page, but I didn‚Äôt understand much about this topic and so I decided to get to the bottom. </p><br><p>  HTTP / 2 Server Push turned out to be more complex and low-level than I thought, but I was really surprised by how different its interaction with various browsers is - I always thought that it was a fully developed feature, ready for use in production. </p><br><p>  I do not want to say that HTTP / 2 Server Push is useless nonsense;  I think this is a really powerful tool that will get better over time.  But I no longer consider him a "silver bullet from a golden gun." </p><br><h3 id="shema-izvlecheniya-dannyh">  Data Extraction Scheme </h3><br><p>  Between your page and the target server there is a whole series of caches and functions that can intercept the request: </p><br><p> <a href=""><img src="https://habrastorage.org/web/0b7/730/ee9/0b7730ee975c49ba9425c4ee84bdb56c.png"></a> </p><br><p>  The above model resembles the flowcharts that are used to describe Git or its characteristic features.  Those who are familiar with the topic are convinced of the correctness of their knowledge, the rest are just scared.  I apologize if this is the case, and I hope the following sections will help you figure it out. </p><br><h3 id="kak-rabotaet-http2-server-push">  How HTTP / 2 Server Push works </h3><br><p><img src="https://habrastorage.org/web/493/8e4/d84/4938e4d845eb429eba23f310f1ad089f.png"></p><br><p>  <em><strong>Page:</strong> Hi, example.com, can I get your home page?</em>  <em>10:24</em> <br>  <em><strong>Server:</strong> Of course!</em>  <em>Oh, while it's being sent, here‚Äôs another style sheet, images, javascript and json.</em>  <em>10:24</em> <br>  <em><strong>Page:</strong> Wow, class!</em>  <em>10:24</em> <br>  <em><strong>Page:</strong> I‚Äôm reading HTML, and it looks like I‚Äôll need a sti table ... Oh, you already sent it to me, cool!</em>  <em>10:25</em> </p><br><p>  When responding to a request, the server may include additional resources, such as request headers, that the browser can match later.  They are in the cache until the browser requests a resource that matches the description. </p><br><p>  Increased productivity is due to the fact that resources are sent before the browser requests them.  Theoretically, this means that the page should load faster. </p><br><p>  That's almost everything I knew about HTTP / 2 Server Push.  It sounded pretty easy, but in fact it turned out to be quite not so easy ... </p><br><h3 id="chto-ugodno-mozhet-ispolzovat-push-kesh">  Anything can use push cache. </h3><br><p>  HTTP / 2 Server Push is a low-level network feature: everything that uses a network stack can use it. </p><br><p>  But any feature is useful if it is consistent and predictable.  I tested HTTP / 2 Server Push on these indicators, launching resources and trying to collect them using: </p><br><ul><li><code>fetch()</code> </li> <li> <code>XMLHttpRequest</code> </li> <li> <code>&lt;link rel="stylesheet" href="‚Ä¶"&gt;</code> </li> <li> <code>&lt;script src="‚Ä¶"&gt;</code> </li> <li> <code>&lt;iframe src="‚Ä¶"&gt;</code> </li> </ul><br><p>  I also limited the download speed of body from resources that were already running, to see if browsers could match resources that were not yet running.  A small test suite is available on <a href="http2-push-test">GitHub</a> . </p><br><p><img src="https://habrastorage.org/web/4d8/f3c/2c7/4d8f3c2c73ed4d29be998a0c6a710648.png"></p><br><ul><li>  Chrome is good support. </li><li>  Safari is bad support. </li><li>  Firefox is a good support. </li><li>  Edge is a good support. </li></ul><br><p>  <strong>Edge,</strong> when using <code>fetch (), XMLHttpRequest  &lt;iframe&gt;</code> did not retrieve the item from the push cache ( <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12142852/">description of the problem</a> ). </p><br><p>  <strong>Safari</strong> behaved in a strange way.  It is impossible to predict whether he will use the push cache or not.  Safari relies on the OS X network stack, whose source code is closed, but I believe that some of the bugs are specific to Safari.  It seems that it opens up too many connections, which ultimately distributed resources run.  This means that you only get into the cache if the request was lucky to use the same connection (this is beyond my comprehension ( <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D172639">problem description</a> )). </p><br><p>  All browsers (except Safari, when it is odd) will use matching running elements, even if they are still in the download process, and this is very good. </p><br><p>  Unfortunately, only Chrome supports developer tools, thanks to which on the network panel you can find out which items were extracted from the push cache. </p><br><h4 id="rekomendacii">  Recommendations </h4><br><p>  If the browser does not retrieve an item from the push cache, the speed will be less than if no push had ever been applied. </p><br><p>  Technology support in Edge leaves much to be desired, but we know exactly what methods do not work with push-caches.  You can define a User-Agent client and push only those resources for which it precisely supports push-cache. </p><br><p>  Safari's behavior is not deterministic, so you can hardly cover it with crutches.  You can simply disable HTTP / 2 Server Push for Safari users based on User-Agent. </p><br><h3 id="vy-mozhete-pushit-resursy-no-cache-i-no-store">  You can push no-cache and no-store resources </h3><br><p>  When using the HTTP cache, the element should have something like max-age so that the browser can use it without re-checking on the server ( <a href="https/jakearchibald.com/2016/caching-best-practices/">post about caching headers</a> ).  To use HTTP / 2 Server Push this is not required - when comparing elements, their ‚Äúfreshness‚Äù is not checked. </p><br><p><img src="https://habrastorage.org/web/635/436/cc6/635436cc66264697945bc80d7f1e632b.png"></p><br><ul><li>  Chrome is good support. </li><li>  Safari is good support. </li><li>  Firefox is a good support. </li><li>  Edge is good support. </li></ul><br><p>  All browsers behave the same. </p><br><h4 id="rekomendacii-1">  Recommendations </h4><br><p>  The performance of some single-page applications may suffer due to the fact that their rendering is blocked not only by JS, but also by some data (JSON, for example), which JS starts to extract immediately as it executes.  The best solution is server rendering.  However, if this is not possible, you can push JS and JSON along with the page. </p><br><p>  Given the aforementioned Edge and Safari problems, embedding JSON is a more reliable solution. </p><br><h3 id="brauzer-proveryaet-http2-push-kesh-v-poslednyuyu-ochered">  Browser checks HTTP / 2 push cache last </h3><br><p>  The launched elements are bound to an HTTP / 2 connection, that is, the browser will use them only if no response is received from the <a href="https/html.spec.whatwg.org/">image</a> cache, the preload cache, the service worker cache, and the HTTP cache before. </p><br><p><img src="https://habrastorage.org/web/8a3/ae2/81b/8a3ae281bd5540b4b763ad95ec1200a2.png"></p><br><ul><li>  Chrome is good support. </li><li>  Safari is good support. </li><li>  Firefox is a good support. </li><li>  Edge is good support. </li></ul><br><p>  All browsers behave the same. </p><br><h4 id="rekomendacii-2">  Recommendations </h4><br><p>  For information: let's say in the HTTP cache you have an item that is ‚Äúnew‚Äù in accordance with its max-age, and you push a newer item.  Then the latter will be ignored in favor of the first (unless the API for any reason bypasses the HTTP cache).  Just know about it. </p><br><p>  Knowing that cached items are related to an HTTP connection helped me understand the other behavioral features I encountered.  For example‚Ä¶ </p><br><h3 id="http-soedinenie-zakryvaetsya--proschay-push-kesh">  HTTP connection is closing - goodbye, push cache </h3><br><p>  The push cache is connected to an HTTP / 2 connection, so you will lose it if the connection is broken.  This happens even if the fired resource is actively cached. </p><br><p>  The push cache is outside the HTTP cache, so elements are not included in the HTTP cache until the browser requests them.  At this moment, they are retrieved from the push cache and are transferred via HTTP cache, service worker, etc. to the page. </p><br><p>  If the user has an unstable connection, then you can successfully push something, but the connection will be interrupted before the page receives the data.  We'll have to establish a new connection and reload the resource. </p><br><p><img src="https://habrastorage.org/web/da6/373/9d8/da63739d8f2841b091a18ce9f2b865a8.png"></p><br><ul><li>  Chrome is good support. </li><li>  Safari is good support. </li><li>  Firefox is a good support. </li><li>  Edge is good support. </li></ul><br><p>  All browsers behave the same. </p><br><h4 id="rekomendacii-3">  Recommendations </h4><br><p>  Do not rely on the fact that the items will be long in the cache.  Push is best used for urgent things, such that where it doesn‚Äôt take long to push and use. </p><br><h3 id="neskolko-stranic-mogut-ispolzovat-odno-i-to-zhe-http2-soedinenie">  Multiple pages can use the same HTTP / 2 connection </h3><br><p>  Each connection has its own push cache.  But since one connection can be used by several pages, they can also share one push cache. </p><br><p>  In practice, this means that if you push a resource along with a response related to navigation (for example, an HTML page), it will not only be available for this page (I will use the term ‚Äúpages‚Äù throughout the post, but in Actually, it means other contexts that can extract resources, for example, workers). </p><br><p><img src="https://habrastorage.org/web/f33/323/50c/f3332350c44a4356ab576adffb329f8d.png"></p><br><ul><li>  Chrome is good support. </li><li>  Safari is bad support. </li><li>  Firefox is a good support. </li><li>  Edge is a good support. </li></ul><br><p>  It seems that Edge for each tab uses a new connection ( <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12144186/">description of the problem</a> ). </p><br><p>  Safari unnecessarily creates multiple connections to the same source.  And I'm pretty sure that this is the reason for his strange behavior ( <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D172639">description of the problem</a> ). </p><br><h4 id="rekomendacii-4">  Recommendations </h4><br><p>  Keep this in mind when pushing things like JSON data along with the page ‚Äî you can't rely on the same page to catch them. </p><br><p>  But this behavior can turn into an advantage, since the resources that you use with the page can be picked up by the requests that are made by the installation service worker. </p><br><p>  Edge behaves suboptimally, but nothing to worry about.  Now, if it had the support of a service worker, then this could be a problem. </p><br><p>  And again, I would not advise Safari users to push resources. </p><br><h3 id="zaprosy-bez-dannyh-dlya-avtorizacii-ispolzuyut-otdelnoe-soedinenie">  Requests without data for authorization use a separate connection. </h3><br><p>  The term ‚Äúauthorization data‚Äù will appear more than once in this post.  It refers to the data sent by the browser used to identify a specific user.  These are usually cookies, but they can also be Basic HTTP authentication identifiers and connection level identifiers, such as client certificates. </p><br><p>  If you compare the HTTP / 2-connection with a phone call, then as soon as you introduce yourself, the call will no longer be anonymous, and this applies to what you said on the phone before you called yourself.  For confidentiality purposes, ‚Äúanonymous‚Äù requests set up a separate ‚Äúcall‚Äù to the browser. </p><br><p>  However, due to the fact that the push cache is connected to the connection, you can lose cached elements when executing requests without credentials (non-credentialed request).  For example, if you push a resource along with a page (request with credentials) and then retrieve it (fetch ()) (without credentials), a new connection will be established, and the pushed element will be lost. </p><br><p>  If a cross-origin stylesheet (with credentials) fills a certain font, then when the browser requests it (without credentials), the font will be lost in the push cache. </p><br><h4 id="rekomendacii-5">  Recommendations </h4><br><p>  Make sure your requests use the same authorization method.  In most cases, this means that requests contain credentials, since the page request is always executed with authorization data. </p><br><p>  To get credentials, use: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">fetch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">url</span></span>, {<span class="hljs-attribute"><span class="hljs-attribute">credentials</span></span>: include});</code> </pre> <br><p>  You cannot add authorization data to a font request using multiple sources, but you can remove it from the style sheet: </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"stylesheet"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"‚Ä¶"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">crossorigin</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  This means that the request for both the style sheet and the font will follow the same connection.  But if the stylesheet also applies background images, then such requests always come with authorization data, so you can get another connection as a result.  The only solution is to use a service worker who can configure each request. </p><br><p>  The developers claim that requests without credentials improve performance, since they do not need to send cookies.  However, it is necessary to compare them with a much higher cost to establish a new connection.  In addition, HTTP / 2 Sever Push can compress headers repeated in different requests, so cookies are not really a problem. </p><br><h3 id="vozmozhno-nado-izmenit-pravila">  You may need to change the rules. </h3><br><p>  Edge is the only browser that does not follow the rules.  It allows connection sharing using queries that contain or do not contain data for authorization.  Here I missed the usual row of browser icons because I wanted the specifications to be changed. </p><br><p>  If a page makes a request to its source without data for authorization, then it hardly makes sense to establish a separate connection.  The request is initiated by a resource containing authorization data that can be added to an ‚Äúanonymous‚Äù request via a URL (this is called ambient authority). </p><br><p>  I‚Äôm not quite sure about other cases, but if you make requests to the same server with or without authorization data, anonymity is lost due to browser ‚Äúfingerprints‚Äù.  If you want to study this issue in more detail, read the <a href="https://github.com/whatwg/fetch/issues/341">discussion on GitHub</a> , <a href="https://groups.google.com/forum/">the Mozilla mailing list,</a> and <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D1363284">the bug report in Firefox</a> . </p><br><h3 id="elementy-v-push-keshe-mogut-ispolzovatsya-tolko-odin-raz">  Items in push cache can only be used once. </h3><br><p>  If the browser used an element stored in the push cache, then the latter is removed from the cache.  It may be in the HTTP cache (depending on <a href="https://jakearchibald.com/2016/caching-best-practices/">header caching</a> ), but it will no longer be in the push cache. </p><br><p><img src="https://habrastorage.org/web/76a/6c9/3bd/76a6c93bd3e44307ad575dbc0793c0f4.png"></p><br><ul><li>  Chrome is good support. </li><li>  Safari is bad support. </li><li>  Firefox is a good support. </li><li>  Edge is good support. </li></ul><br><p>  Here Safari suffers from race conditions.  If the resource is extracted several times while it is being fired, then it will receive the fired element several times ( <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D172639">description of the problem</a> ).  If the resource is extracted twice after the push has ended, then it behaves correctly: for the first time it will be returned from the push cache, and in the second it will not be. </p><br><h4 id="rekomendacii-6">  Recommendations </h4><br><p>  If you decide to push something through to Safari users, then be prepared for an error when pushing no-cache resources (for example, JSON data).  Along with the answer, a random ID can be sent.  And, if you received the same ID twice, know that an error has occurred.  In this case, wait a second, and then try again. </p><br><p>  In any case, use caching headers or a service worker to cache running resources after they are retrieved if caching is undesirable (for example, one-time JSON samples). </p><br><h3 id="brauzer-mozhet-otmenit-push-dlya-elementov-esli-oni-u-nego-uzhe-est">  The browser can cancel push for items if it already has them. </h3><br><p>  When you push content, you do it without much interaction with the client, which means you can push through what the browser already has in one of its caches.  The HTTP / 2 specification allows the browser to interrupt incoming traffic using the <code>CANCEL</code> or <code>REFUSED_STREAM</code> code to avoid loss of bandwidth. </p><br><p><img src="https://habrastorage.org/web/0f4/f78/5fa/0f4f785fa9d34c6d89c5183557294649.png"></p><br><ul><li>  Chrome is a good support. </li><li>  Safari is good support. </li><li>  Firefox is bad support. </li><li>  Edge is good support. </li></ul><br><p>  The specification is not strict here, so my judgment is based on what is useful for developers. </p><br><p>  <strong>Chrome</strong> rejects push if the item is already contained in the push cache.  Rejection is done using <code>PROTOCOL_ERROR</code> , not <code>CANCEL</code> or <code>REFUSED_STREAM</code> , but this is not so important (description of the problem).  Unfortunately, it does not reject items that are already contained in the HTTP cache.  It seems that now this problem is almost solved, but I could not make sure of it ( <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D726725">description of the problem</a> ). </p><br><p>  <strong>Safari</strong> rejects push if the item is already contained in the push cache, but only if it is ‚Äúnew‚Äù according to the headers in the cache (for example, max-age) until the user refreshes the page.  Safari is different from Chrome, but I don‚Äôt think it‚Äôs ‚Äúwrong.‚Äù  Unfortunately, like Chrome, it does not reject elements that are already in the HTTP cache ( <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D232040">description of the problem</a> ). </p><br><p>  <strong>Firefox</strong> cancels push if the item is already contained in the push cache, but then it deletes the item and leaves nothing!  This makes it unreliable and complicates its protection ( <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D1368080">description of the problem</a> ).  Like the above browsers, Firefox does not reject elements that are already contained in the HTTP cache ( <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D1367551">description of the problem</a> ). </p><br><p>  Edge does not reject push if the element is already contained in the push cache, but does so if the element is in the HTTP cache. </p><br><h4 id="rekomendacii-7">  Recommendations </h4><br><p>  Unfortunately, even with perfect browser support, bandwidth and server I / O resources will be wasted before you get a cancellation message.  <a href="http-extensions/cache-digest.html">Cache Digest</a> can be the solution to the problem: the extension tells the server that it has already been cached. </p><br><p>  In addition, using a cookie, you can track whether cached resources are already pushed through to the user.  However, elements may disappear from the HTTP cache at the whim of the browser, while the cookie will be preserved.  So the presence of a cookie does not mean that the elements are still contained in the user's cache. </p><br><h3 id="elementy-v-push-keshe-dolzhny-byt-sopostavleny-s-ispolzovaniem-http-semantiki-a-ne-tolko-po-novizne">  Items in the push cache should be mapped using HTTP semantics, not just by ‚Äúnovelty‚Äù </h3><br><p>  We have already seen that ‚Äúnovelty‚Äù is not taken into account when it comes to matching items in the push cache (this is how no-store and no-cache are matched), and other matching mechanisms should be used instead.  I tested POST and Vary requests: Cookie. </p><br><p>  <strong>Update: The</strong> specification says that push requests "MUST be <a href="httpwg.org/specs/rfc7231.html">cacheable</a> , MUST be <a href="httpwg.org/specs/rfc7231.html">safe</a> and MUST NOT contain the body of the request."  I missed these definitions first.  POST requests do not fall under the definition of "secure", so browsers must reject them. </p><br><p><img src="https://habrastorage.org/web/c3d/b31/7fc/c3db317fc8c5449c9a3874f64137cb3e.png"></p><br><ul><li>  Chrome is bad support. </li><li>  Safari is good support. </li><li>  Firefox is bad support. </li><li>  Edge is bad support. </li></ul><br><p>  <strong>Chrome</strong> accepts POST push streams, but does not use them ( <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D727653">description of the problem</a> ).  It also ignores the Vary header when matching loaded items ( <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D554220">description of the problem</a> ), although the problem suggests that it works when using QUIC. </p><br><p>  <strong>Firefox</strong> rejects POST push streams, but also ignores the Vary header when matching launched elements ( <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D1368664">problem description</a> ). </p><br><p> <strong>Edge</strong>   POST push-    Vary ( <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12173342/"> </a> ). </p><br><p> <strong>Safari</strong> ,   Chrome,  POST push-,     ( <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D172706"> </a> ).    ,    Vary. </p><br><h4 id="rekomendacii-8">  Recommendations </h4><br><p>  ,    ,  Safari,    Vary   .  ,     :   JSON,    ,           ,      push-JSON   ,      . </p><br><p>    ,    ,     ID  .      ,     (    ). <br>  Chrome    <a href="https://www.w3.org/TR/clear-site-data/">   .</a> (Clear-Site-Data header),     .      push-,  HTTP/2-. </p><br><h3 id="vy-mozhete-pushit-elementy-drugim-istochnikam">       </h3><br><p>   developers.google.com/web        ,    ,  android.com       .     ,      HTTP. ,        android.com,    <code>NATIVE SUX ‚Äì PWA RULEZ</code> ,    omic Sans       . </p><br><p> ,       ‚Äì   Android.    ‚Ä¶ Android:   ,   . </p><br><p> -, ,     .       ,       ,      ¬´¬ª. </p><br><p>      developers.google.com,  ,        Google,     android.com. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/i9uXp64KUcw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  ,   ,  ,     android.com,   DNS  ,     IP-,    developers.google.com,      ,       push-. </p><br><p>       <a href="http-extensions/origin-frame.html">ORIGIN frame</a> ,  ,    , : ¬´,   -   android.com,    .     DNS¬ª.       ,         Firefox Nightly. </p><br><p>    CDN  -  ,      ,        .   .  ,    (  ,   )      HTTP/2 Server Push.           : </p><br><blockquote>    (tenant)        ,       ,       ( <a href="http2-spec/"> HTTP/2</a> ). </blockquote><p><img src="https://habrastorage.org/web/72c/5d3/2d5/72c5d32d50ce4363ab8555419932dc33.png"></p><br><p>    . </p><br><ul><li> Chrome ‚Äì  . </li><li> Safari ‚Äì  . </li><li> Firefox ‚Äì  . </li><li> Edge ‚Äì  . </li></ul><br><p> <strong>Chrome</strong>      ,      .     ,           IP-,     . Chrome    ORIGIN frame. </p><br><p> <strong>Safari</strong>      ,      ,        , -     . Safari    ORIGIN frame. </p><br><p> <strong>Firefox</strong>  push   .  Safari,       .     ,       . Firefox Nightly  ORIGIN frame. </p><br><p> <strong>Edge</strong>   push   .      ,       . Edge   ORIGIN frame. </p><br><h4 id="rekomendacii-9">  Recommendations </h4><br><p>        ,          ,    ORIGIN frame.       DNS,   . </p><br><p>   ,  push       ,       ,       ,   .     User-Agent   push    . </p><br><h3 id="push-protiv-preload"> Push  preload </h3><br><p>     ,         HTML: </p><br><pre> <code class="hljs pgsql">&lt;link rel="preload" href="https://fonts.example.com/font.woff2" <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>="font" crossorigin <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="font/woff2" &gt;</code> </pre> <br><p>   : </p><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">Link</span></span>: &lt;https://fonts.example.com/font.woff2&gt;; rel=preload; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>=font; crossorigin; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">=font/woff2</span></span></code> </pre> <br><p> ‚Ä¢ <code>href</code> ‚Äì  URL   . </p><br><ul><li> <code>as</code> ‚Äì <a href="https://fetch.spec.whatwg.org/"> </a> :         CSP-. </li><li> <code>crossorigin</code> ‚Äì   .  ,     CORS-. CORS-      ,   <code>crossorigin = ¬´use-credentials¬ª</code> . </li><li> <code>type</code> ‚Äì    .     ,   MIME-  . </li></ul><br><p>      ,   .     HTTP/2 Server Push: </p><br><ul><li>     ; </li><li>  no-cache  no-store    ; </li><li>              ; </li><li>       ,      HTTP-   ; </li><li>  ¬´¬ª,       HTTP-; </li><li>        . </li></ul><br><p>    . </p><br><p> <strong>  </strong> ,  ,      -,  HTTP,  HTTP/2    (   ). </p><br><p> <strong>       </strong> ( ),         ( -   HTTP),         .      ,             . </p><br><p> <strong>      </strong> ,     ,     . <br>  ,    ,      .            - ‚Äì       . </p><br><p><img src="https://habrastorage.org/web/ab0/5c7/c02/ab05c7c02eb54a919cd8a02a6104b305.png"></p><br><ul><li> Chrome ‚Äì  . </li><li> Safari ‚Äì  . </li><li> Firefox ‚Äì  . </li><li> Edge ‚Äì  . </li></ul><br><p> <strong>Chrome</strong>       API. , <code>fetch()</code>     . XHR  ,         ( <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D652228"> </a> ). </p><br><p> <strong>Safari</strong>        <a href="https://developer.apple.com/safari/technology-preview/">Technology Preview</a> .  <code>fetch()</code> ,  <code>XHR</code>      ( <a href="https://bugs.webkit.org/show_bug.cgi%3Fid%3D158720"> </a> ). </p><br><p> Firefox    ,         ( <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D1222633"> </a> ). </p><br><p> <strong>Edge</strong>    .  , <a href="https://wpdev.uservoice.com/forums/257854-microsoft-edge-developer/suggestions/7666725-preload">   </a> . </p><br><h3 id="rekomendacii-10">  Recommendations </h3><br><p>        ,   HTTP/2 Server Push,        ,    .        .    ,      .        ,  ,     . </p><br><p>       HTTP/2 Server Push.   ,  , ,    , ,  ,      - .      ,        ,       ,    ,  push,      . </p><br><h3 id="buduschee-http2-server-push">  HTTP/2 SERVER PUSH </h3><br><p>  HTTP/2 Server Push     .      , ,       (),      (),     CSS. ,  -   ,       ,    . </p><br><p>     ¬´¬ª ,       . , ,      CSS    ,      CSS,          ,      . </p><br><p>        (-        -  ),     ,    , ,  ,  ;     ,   . </p><br><h4 id="p-s">  PS </h4><br><p>      HTTP/2 Server Push,   ,   . HTTP/2 Server Push    ;       ,      . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331216/">https://habr.com/ru/post/331216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331206/index.html">The API from Watson and what these tools can give to your service or application</a></li>
<li><a href="../331208/index.html">A fistful of relays. Part 4. System commands or what can fit in 8 machine instructions?</a></li>
<li><a href="../331210/index.html">Self-registration of the second factor for two-factor authentication based on the RADIUS protocol</a></li>
<li><a href="../331212/index.html">Development kit from analytics to outsourced artists</a></li>
<li><a href="../331214/index.html">Automatic configuration of Cisco voice gateways and Eltex Asterisk provisioning</a></li>
<li><a href="../331220/index.html">The implementation of the algorithm A *</a></li>
<li><a href="../331222/index.html">No place to hide - how aggressive marketing services haunt you</a></li>
<li><a href="../331224/index.html">Translation of the Appium Essentials book. Chapter 1</a></li>
<li><a href="../331226/index.html">On the use of video cameras with character recognition on low-performance computing devices</a></li>
<li><a href="../331228/index.html">Debian 9: what's new</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>