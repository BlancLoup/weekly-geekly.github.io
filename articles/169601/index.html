<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ten things I can't stand in OOP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="God, at times I just hate object-oriented programming. 

 I guess I'm not the only one. Edsger Dijkstra's immortal words read: 
 ‚ÄúObject-oriented prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ten things I can't stand in OOP</h1><div class="post__text post__text-html js-mediator-article">  God, at times I just <i>hate</i> object-oriented programming. <br><br>  I guess I'm not the only one.  Edsger Dijkstra's immortal words read: <br><blockquote>  <i>‚ÄúObject-oriented programming is an extremely bad idea that only California could think of.‚Äù</i> </blockquote><br>  I usually don‚Äôt complain, but now I think it's time to look back and see what‚Äôs wrong with the PLO.  In this spirit, I prepared a modest list of <i>ten things that I can not stand in the PLO.</i> <br><a name="habracut"></a><br><br><h3>  1. The paradigm </h3><br>  What is the paradigm of object-oriented programming?  Is there a direct answer to this?  I heard so many different versions that I myself do not know now. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If we look at Smalltalk's ideas, we will encounter the mantra: ‚ÄúEverything is an object‚Äù.  In addition to variables.  And packages.  And primitives.  Numbers and classes are also not exactly objects, and so on.  Obviously, ‚Äúeverything is an object‚Äù cannot be the basis of a paradigm. <br><br>  What is fundamental to OOP?  Peter Wegner once <a href="http://dl.acm.org/citation.cfm%3Fdoid%3D38807.38823">suggested</a> that object-based programming is based on <i>objects, classes, and inheritance</i> .  However, each programming language supports them differently, or does not even support some of them by default.  Clearly, this is also not the paradigm of the PLO. <br><br>  Others assert that OOP is <i>Encapsulation, Abstraction, and Data Hiding</i> .  True, different sources will tell you that these are just different words to describe the same idea.  But others will say that these are three fundamentally different concepts. <br><br>  Since the mid-80s, several myths have been walking about OOP.  One of them, <i>the Reuse Myth</i> , says that OOP makes development more productive, so it allows you to inherit and extend the current code instead of writing it again each time.  Another is the Design Myth, which implies that analysis, design, and implementation smoothly follow from each other, because all of them <i>are objects</i> .  Of course, none of these myths can be the paradigm of the PLO. <br><br>  Let's take a look at other paradigms that allow solving programmer tasks in a certain way.  Procedural programming is often described as <i>programs = data + algorithms</i> .  Logical programming says: <i>programs = facts + rules</i> .  Functional programming, apparently, <i>programs = functions + functions</i> .  This suggests that OOP means <i>programs = objects + messages</i> .  Is it so?  I think that the main thing is lost here.  And the main thing is that OOP is not a paradigm, such as procedural, logical or functional programming.  Instead, the PLO says: ‚Äúfor each individual task you must develop your own paradigm‚Äù.  In other words, the paradigm of object-oriented design is: <i><b>‚ÄúProgramming is modeling‚Äù.</b></i> <br><br><h3>  2. Object-oriented programming languages </h3><br>  I also do not like the way everyone likes not to like other people's languages.  We like to divide the world into camps: braces versus square versus round ones. <br><br>  Here are some things that were said about our beloved SADN: <br><br><blockquote>  <i>‚ÄúC makes it easy to shoot yourself in the foot;</i>  <i>with C ++, it's harder to do, but when you do, you shoot your whole leg. ‚Äù</i> </blockquote>  That said Bjorn Straustrup, so all is well. <br><br><blockquote>  <i>‚ÄúI came up with the term 'object-oriented', and here‚Äôs what I‚Äôll tell you: I didn‚Äôt mean C ++.‚Äù</i> - Alan Kay. </blockquote><br><blockquote>  <i>‚ÄúIn C ++, only 2 things turned out wrong: the initial design and implementation.‚Äù</i> - Bertrand Meyer </blockquote><br><blockquote>  <i>‚ÄúInside C ++, there is a more compact and understandable language that is desperately trying to get out.‚Äù</i> - Bjorn Straustrup </blockquote><br><blockquote>  <i>‚ÄúC ++ is a story repeated like a tragedy.</i>  <i>Java is a story repeated like a farce. ‚Äù</i> - Scott McKay </blockquote><br><blockquote>  <i>‚ÄúJava, the best argument for SmallTalk after C ++.‚Äù</i> - Frank Winkler </blockquote><br><blockquote>  <i>‚ÄúIf Java had a real garbage collector, most programs would remove themselves during execution.‚Äù</i> - Robert Suel </blockquote><br>  And perhaps the most comprehensive sentence: <br><blockquote>  <i>‚ÄúThere are only 2 types of languages: those that everyone complains about and those that nobody uses.‚Äù</i> - Bjorn Straustrup </blockquote><br><br><h3>  3. Classes </h3><br>  Classes drive me crazy.  This may seem strange, so let me explain. <br><br>  Classes seem to be convenient.  Our brain perfectly classifies the information we receive from the outside world.  And it would be quite natural to classify everything in object-oriented programs. <br><br>  However, in the real world there are only objects.  <i>Classes exist only in our mind.</i>  Can you give at least one example from the real world that a class is a real, physical entity?  No I do not think so. <br><br>  And that's the problem.  Have you ever wondered why an object-oriented language program is so much more difficult to understand than a procedural one? <br><br>  In procedural programs, procedures call other procedures.  The procedural code shows ... procedures that call other procedures.  Everything is good and simple, right? <br><br>  In object-oriented programs, objects send messages to other objects.  Object-oriented code shows ... classes that inherit other classes.  Oh.  It seems that in OOP there is no connection between the source code and the executable program.  Our tools help us badly: IDEs show classes, not objects. <br><br>  I think this is why SmallTalkers like to program in debugger so much: the latter gives them a sense of control over the executable objects and allows them to be programmed directly. <br><br>  This is what I would like to say to the developers of the tools: please give us an IDE that will display objects instead of classes! <br><br><h3>  4. Methods </h3><br>  Honestly, I also hate methods. <br><br>  As we all understand, methods in good object-oriented programs should be short and elegant.  Many small methods are more convenient for development, understanding, reuse, and so on.  So what's the problem? <br><br>  We take into account the fact that we spend more time reading object-oriented code than writing it.  This is called performance: instead of spending hours writing a large amount of code, in order to add new functionality, we write only a few lines, but at the same time spend hours trying to figure <i>out exactly which</i> lines you need to write! <br><br>  One of the reasons why we spend so much time is because we have to scroll the code back and forth ... through a lot of small methods. <br><br>  This is also known as the <i>Lost in Space</i> syndrome and has been spoken of since the creation of the PLO.  To quote Adel Goldberg, <i>‚ÄúIn SmallTalk, everything happens somewhere else.‚Äù</i> <br><br>  I‚Äôm sure that today's code-oriented IDEs are to blame for this - given that object-oriented code doesn‚Äôt give any idea of ‚Äã‚Äãthe executable application, the IDE stands in our way instead of helping.  Another reason why SmallTalkers like to program in the debugger is that it helps them see well <i>what</i> objects <i>they</i> interact with.  Therefore, I think today <i>test-driven development (TDD)</i> is popular, allowing you to see the interaction of objects during development. <br><br>  And the matter is not in the PLO itself - we just did not understand (after more than 40 years) how to develop programs for it.  We have to ask ourselves: <i>why does the source code remain the predominant mapping in the IDE?</i> <br><br>  I want an IDE that will allow me to switch between code and executable application.  (For an idea of ‚Äã‚Äãthis idea, take a look at the <a href="http://seaside.st/">Seaside</a> web development platform site, which allows you to switch directly from the executable application to the editable source code) <br><br><h3>  5. Types </h3><br>  Okay, I admit: I am impatient and hate repeating words twice.  Types make me do it. <br><br>  Someone now probably thought: ‚ÄúBut how can you write in a typeless language.  You will never be sure that your code is correct. ‚Äù <br><br>  Of course, there are no ‚Äútypeless‚Äù languages ‚Äã‚Äã- they exist statically and dynamically typed.  Statically typed interfere with writing code in some cases.  In principle, there is nothing wrong with that. <br><br>  The problem with the types themselves, as we know them.  First, they give rise to a sense of false security.  The fact that your Java program is compiled does not mean that there are no errors in it (and even type errors). <br><br>  Secondly and most importantly, typification assumes that the world is constant, and the programs in it consist of unchanged parts, <i>and this is not so</i> .  Because of this, some useful types of programs (especially reflexive) become more difficult to write. <br><br>  Finally, typing does not do well with the fact <i>that there are different notions of types</i> .  There is no one omnipotent system.  Recall the suffering we experienced with generalizations in Java.  Many useful type systems are being developed, but we cannot extend Java to fit them all.  Gilad Brakha <a href="http://bracha.org/pluggableTypesPosition.pdf">proposed</a> to make the typing not only <i>optional</i> to run programs even if the typing is incorrect, but also <i>plug-in</i> , so that we can connect different type systems in different parts of our programs.  We need to think about this proposal, and at the same time how to adapt programming languages ‚Äã‚Äãand development environments to a variety of type systems. <br><br><h3>  6. Variability </h3><br><blockquote>  <i>‚ÄúChange is inevitable - unlike the little things from a vending machine.‚Äù</i> - Robert Galaguer </blockquote><br>  We all don't like to change, right?  And if so, why complain if things do not get better?  We know that useful programs must change, or they deteriorate over time. <br><br>  (By the way, do you know what the difference is between hardware and software? Iron worsens if you don‚Äôt keep it working.) <br><br>  Given that real programs must change, it is fair to assume that languages ‚Äã‚Äãand IDEs should support this.  I suggest you, however, to name at least one mechanism in programming languages ‚Äã‚Äãthat supports variability.  Those mechanisms that work with variability rather limit and control it. <br><br>  Our world is impermanent, but we feel good in it.  <i>The context</i> is what allows us to cope with change.  We adjust our behavior, our expectations to the context in which we are, but for some reason our programs break down if the context changes. <br><br>  I want to see this idea in object-oriented languages ‚Äã‚Äãand IDE.  Both the source code and the executable application must be able to adapt to the changing context.  I am sure that many design patterns and ideas (such as a <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2581%25D0%25B5%25D1%2582%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">visitor</a> and <a href="http://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">dependency injection</a> ) are just crutches that will disappear after the implementation of the context mechanism in the SNMP. <br><br><h3>  7. Design Patterns </h3><br>  Patterns.  I can not with them, I can not without them. <br><br>  Each design pattern makes your project more confusing. <br><br>  I said everything. <br><br><h3>  8. Methodologies </h3><br><blockquote>  <i>‚ÄúAll methodologies are based on fear.‚Äù</i> - Kent Beck </blockquote><br>  It seems that some of my students are working on the Chile Norris style Agile methodology: <br><br>  <i>‚ÄúChuck Norris is not engaged in iterative development.</i>  <i>Everything works out the first time, every time. ‚Äù</i> <br><br>  <i>‚ÄúChuck Norris does not write documentation.</i>  <i>He stares at the code until he says everything he needs to know. ‚Äù</i> <br><br><h3>  9. UML </h3><br>  Bertrand Meyer talks about what surprised him about why schematic programming languages ‚Äã‚Äãwere always so popular, until one day it dawned on him: <i>‚ÄúThe bubbles do not break!‚Äù</i> .  (Another saying belonging to Meyer: <i>‚ÄúAll you need is code‚Äù</i> ) <br><br>  It seems that with what is usually understood by development through modeling, something is also wrong: the code should not be <i>generated</i> from the model - the model should <i>be code</i> . <br><br>  By the way, FORTRAN was sold as a high-level language from which <i>source code</i> was generated.  And now the high-level language for us <i>is the</i> source code. <br><br>  I hope one day when we grow up, the <i>model</i> will be considered as source code. <br><br><h3>  10. Another new thing </h3><br>  And finally, the catchphrase I hate: <i>‚ÄúObjects are not enough.</i>  <i>Need more ... ‚Äù</i> .  All these years we needed frameworks, components, aspects, services (which, it seems, in a curious way brought us back to procedural programming!) <br><br>  If there <i>have</i> never been enough objects, why have they served us well all these years? <br><br><h3>  Conclusion? </h3><br>  25 years ago, we did not expect the ‚Äúnew‚Äù phenomenon of the PLO to live so long. <br>  We thought that OO-conferences such as <a href="http://en.wikipedia.org/wiki/European_Conference_on_Object-Oriented_Programming">ECOOP</a> , <a href="http://en.wikipedia.org/wiki/OOPSLA">OOPSLA will</a> exist for 5 years and then get lost in the mainstream. <br><br>  But it is too early to ignore OOP as part of the mainstream.  And the fact that scientific and industrial research in the field of object-oriented programming is still ongoing suggests that something important is happening that we do not fully understand. <br><br>  OOP allows you to simplify complex things through modeling, <b>but we still haven't mastered it</b> , perhaps because we can hardly distinguish between <i>significant and insignificant difficulties.</i> <br><br>  To move on, we need to focus on volatility and how OOP can contribute to volatility.  After so many years, we are still at the very beginning, trying to understand what the PLO can offer us. <br><br>  <b>Thanks for reading!</b> <br><br>  <i><b>Little about the author</b></i> <i><br><img src="https://habrastorage.org/storage2/9aa/286/f02/9aa286f02ba08d3cd49c00df3ed24206.jpg" align="left"></i>  <i><b>Oscar Nierstrasz</b> is a professor of Computer Science at the University of Bern, founder of the <a href="http://scg.unibe.ch/">Software Composition Group</a> , which explores the mechanisms that allow computer systems to be <i>more flexible</i> and better adapted to changing conditions.</i>  <i>(hence the author‚Äôs desire to introduce the mechanisms of variability in PL)</i> <i><br><br></i>  <i>An active participant in the PLO research community, participant and chairman of conferences such as <a href="http://en.wikipedia.org/wiki/European_Conference_on_Object-Oriented_Programming">ECOOP</a> , <a href="http://esec-fse.inf.ethz.ch/">ESEC</a> and <a href="http://www.modelsconference.org/">MODELS</a> .</i>  <i>(This article is just the speech of Oscar at the ECOOP 2010 conference).</i>  <i>Also chief editor of <a href="http://www.jot.fm/">The Journal of Object Technology</a> .</i> <i><br><br></i>  <i>He co-authored over 200 <a href="http://scg.unibe.ch/staff/oscar/onpubs">publications</a> and 2 books: <a href="http://scg.unibe.ch/download/oorp/">Object-Oriented Reengineering Patterns</a> and <a href="http://pharobyexample.org/">Pharo by Example</a> .</i>  <i>(both books, apparently, are not translated into Russian, but free and available for download at the links)</i> <i><br></i> </div><p>Source: <a href="https://habr.com/ru/post/169601/">https://habr.com/ru/post/169601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../169589/index.html">Surface Windows 8 Pro overview and comparison with RT</a></li>
<li><a href="../169591/index.html">Elastix communication with Panasonic TDE 200 and SIPGW16 v SIP card</a></li>
<li><a href="../169595/index.html">Children collected 3d printer</a></li>
<li><a href="../169597/index.html">Collecting electricity from the environment</a></li>
<li><a href="../169599/index.html">Inconsistent computer</a></li>
<li><a href="../169603/index.html">Ubuntu Phone will be available next week.</a></li>
<li><a href="../169605/index.html">Elastix as an automatic message recording system with sending them to performers</a></li>
<li><a href="../169607/index.html">Python in Europe under threat</a></li>
<li><a href="../169611/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ44 (February 9 - 15, 2013)</a></li>
<li><a href="../169613/index.html">Android 4.2.2 is available for some devices.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>