<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modeling objects for animation on Canvas</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quick and easy API, browser support is what makes Canvas appealing. But, as is often the case, simplicity is also a weakness. Without difficulty, for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modeling objects for animation on Canvas</h1><div class="post__text post__text-html js-mediator-article">  Quick and easy API, browser support is what makes Canvas appealing.  But, as is often the case, simplicity is also a weakness.  Without difficulty, for example, you can draw a rectangle, a circle, a line or hang an image.  But developing useful content on this simple basis is a bit more difficult. <br><br><img src="https://habrastorage.org/files/62c/728/741/62c7287419df4d5eacf1a0e5d6a88475.jpg" alt="Image - the power of canvas"><br><br>  On the example of game development, an approach to animation and control of a game object is shown. <br><a name="habracut"></a><br>  The motive to play around with the development of the game on Canvas were two of these examples: <br><ul><li>  <a href="http://www.html5canvastutorials.com/labs/html5-canvas-google-bouncing-balls/">Google of balls</a> . </li><li>  <a href="http://codepen.io/dissimulate/pen/KrAwx">Very natural mesh</a> ( <a href="http://habrahabr.ru/post/174659/">Programmer simulates the movement of tissue</a> ). </li></ul><br>  Examples are illustrative, but, after a couple of minutes chasing the balls and tearing half a dozen nets, the excitement was gone.  There is no plot, no goal, no sense - in the end, cool, but not interesting. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Prologue </h4><br>  Working with Canvas was described in the publication of the <a href="http://habrahabr.ru/post/258331/">HTML page on Canvas</a> .  In general, the exact same approach, including architecture and development tools, was applied here. <br><br>  Compatibility was tested on FF (Windows, Linux Mint), CR and IE (Windows).  Check on the available gadgets, too, was, but without a special result (about this at the end). <br><br>  GitHub code: <br>  <a href="https://github.com/apelserg/game_arcad_plain">Arcad</a> <br>  <a href="https://github.com/apelserg/game_spots_plain">Spots</a> <br>  <a href="https://github.com/apelserg/game_tens_plain">Tens</a> <br>  <a href="https://github.com/apelserg/game_tetr_plain">Tetr</a> <br><br>  GitHub demo (with offline mode): <br>  <a href="http://apelserg.github.io/game_arcad_plain/">Arcad</a> <br>  <a href="http://apelserg.github.io/game_spots_plain/">Spots</a> <br>  <a href="http://apelserg.github.io/game_tens_plain/">Tens</a> <br>  <a href="http://apelserg.github.io/game_tetr_plain/">Tetr</a> <br><br><h4>  Game is model management </h4><br>  The game consists of: game model, model management functional and model display functionality.  The ultimate essence of the game comes down to changing the model. <br><br>  The model consists of game objects.  Objects from basic primitives: rectangles, circles, lines. <br><br>  The model and the functionality that provides the dynamics of the model, do not know anything about how the model will be shown.  The Canvas functionality only knows how to display the static state of the model at the time of rendering.  In the process of drawing, model changes are not allowed.  Fortunately, this is not necessary to follow (provided by single-loop event loop-a). <br><br>  The Canvas API is native, and therefore fast, and can display a large number of base primitives in real time.  Therefore, the number (tens and even hundreds) of simple objects is not so critical for Canvas.  But complex computational objects implemented in JavaScript, this is something that should be avoided.  The same can be attributed to the implementation of algorithms for changing the model.  The simpler and easier they are (the more native, in this case, the Canvas API will be taken into account), the better.  If, according to the game, it is necessary to implement complex and / or time-consuming computational algorithms in it, then, for such purposes, you can use web workers (not discussed here). <br><br>  The design of the model must be considered carefully from the very beginning.  If the development process has to significantly change the model, this will entail reworking the control and display code. <br><br><h4>  Model development </h4><br>  Tetris made a good demo to test the approach (I'm not the first here). <br><br>  Model concept: <br><ul><li>  Blocks consisting of colored cells fall into the well and go into the common pool.  The filled pool row is deleted.  The game ends when the well is full and there is no free space for the new block. </li><li>  Blocks can be rotated and moved horizontally.  Rotation and movement is possible only in the free space of the well.  When the block is rotated and the well pool is filled, the color of the cells remains. </li><li>  The base object is a cell.  The cell has a pixel size.  This size is the main base, on the basis of which the entire rendering on the Canvas takes place. </li><li>  A well is a virtual grid consisting of cells.  Block and pool control - in changing the number of the column and row of cells in the well. </li></ul><br><br>  Description of the well and cell size: <br><pre><code class="javascript hljs">APELSERG.CONFIG.SET.CellSize = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      APELSERG.CONFIG.SET.WellColumn = 5; //      APELSERG.CONFIG.SET.WellRow = 20; //     </span></span></code> </pre> <br>  Base object (cell): <br><pre> <code class="javascript hljs">APELSERG.MODEL.Cell = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cellRow, cellCol, cellColor</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Row = cellRow; <span class="hljs-comment"><span class="hljs-comment">//     this.Col = cellCol; //     this.Color = cellColor; //  }</span></span></code> </pre><br>  Object (block): <br><pre> <code class="javascript hljs">APELSERG.MODEL.Block = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">blockType</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type = blockType; <span class="hljs-comment"><span class="hljs-comment">//     this.idx = 0; //     ( ) this.cells = [[], [], [], []]; //     }</span></span></code> </pre><br>  The redundancy of the block model is visible, but due to this, two tasks are solved: 1. a block with all states is formed at a time (it is easy to continue to control the block);  2. cell colors are preserved when the block is rotated. <br><br>  Blocks are created in game mode: <br><pre> <code class="javascript hljs">APELSERG.MODEL.GetNewBlock = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newBlock = APELSERG.CONFIG.PROC.NextBlock; <span class="hljs-comment"><span class="hljs-comment">//       APELSERG.CONFIG.PROC.NextBlock = APELSERG.MODEL.GetBlock(); //   -   if (!APELSERG.MODEL.CheckBlockCross(newBlock)) { // ,     APELSERG.CONFIG.PROC.GameStop = true; //   window.clearTimeout(APELSERG.CONFIG.PROC.TimeoutID); //   APELSERG.CONFIG.SetResult(); //   } return newBlock; }</span></span></code> </pre><br>  New unit: <br><pre> <code class="javascript hljs">APELSERG.MODEL.GetBlock = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blockType = APELSERG.MODEL.GetBlockType(); <span class="hljs-comment"><span class="hljs-comment">//     var newBlock = new APELSERG.MODEL.Block(blockType); //     var newColor = ""; //   var baseRow = 1; var baseCol = Math.round(APELSERG.CONFIG.SET.WellColumn / 2); switch (blockType) { case 101: //-- [1] newColor = APELSERG.MODEL.GetCellColor(); newBlock.cells[0][0] = new APELSERG.MODEL.Cell(baseRow, baseCol, newColor); newBlock.cells[1][0] = new APELSERG.MODEL.Cell(baseRow, baseCol, newColor); newBlock.cells[2][0] = new APELSERG.MODEL.Cell(baseRow, baseCol, newColor); newBlock.cells[3][0] = new APELSERG.MODEL.Cell(baseRow, baseCol, newColor); break; //     </span></span></code> </pre><br>  Here you can add blocks of any configuration.  The main thing is to assign a new type to the block and add this type to the array in the function APELSERG.MODEL.GetBlockType (). <br><br><h4>  Model management </h4><br>  Management takes place from the keyboard in a typical way: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'keydown'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ ... }</code> </pre><br>  Blocks fall on the timer (but not on window.requestAnimationFrame).  The APELSERG.CONFIG.SET.LevelTick array stores the time period value for the current level: <br><pre> <code class="javascript hljs">APELSERG.MAIN.Animation = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">makeStep</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (makeStep) { APELSERG.MODEL.BlockShift(<span class="hljs-string"><span class="hljs-string">'DOWN'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     -       } APELSERG.CANVA.WellRewrite(APELSERG.CONFIG.PROC.CellPool); if (!APELSERG.CONFIG.PROC.GameStop &amp;&amp; !APELSERG.CONFIG.PROC.GamePause) { APELSERG.MAIN.RequestAnimationFrame(function () { APELSERG.MAIN.Animation(true); }); } } APELSERG.MAIN.RequestAnimationFrame = function (callback) { if (APELSERG.CONFIG.PROC.FastDownFlag) { //    DOWN APELSERG.CONFIG.PROC.TimeoutID = window.setTimeout(callback, 10); } else { APELSERG.CONFIG.PROC.TimeoutID = window.setTimeout(callback, APELSERG.CONFIG.SET.LevelTick[APELSERG.CONFIG.SET.Level]); } }</span></span></code> </pre><br>  To check whether a block can move or rotate in a given direction, a virtual block is created and conditions are checked.  If the verification conditions are met, the real block is moved to a new location.  Check function: <br><pre> <code class="javascript hljs">APELSERG.MODEL.CheckBlockCross = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">block</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canShift = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">//--    //-- for (var n = 0 in block.cells[block.idx]) { if (block.cells[block.idx][n].Col &lt; 1 || block.cells[block.idx][n].Col &gt; APELSERG.CONFIG.SET.WellColumn || block.cells[block.idx][n].Row &lt; 1 || block.cells[block.idx][n].Row &gt; APELSERG.CONFIG.SET.WellRow) { canShift = false; break; } } //--    //-- if (canShift) { for (var n = 0 in block.cells[block.idx]) { for (var q = 0 in APELSERG.CONFIG.PROC.CellPool) { var cell = APELSERG.CONFIG.PROC.CellPool[q]; if (block.cells[block.idx][n].Col == cell.Col &amp;&amp; block.cells[block.idx][n].Row == cell.Row) { canShift = false; break; } } if (!canShift) { break; } } } return canShift; }</span></span></code> </pre><br>  Block offset occurs by simply assigning cell numbers: <br><pre> <code class="javascript hljs">APELSERG.MODEL.ShiftBlockColumn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">block, num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> block.cells) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> block.cells[x]) { block.cells[x][n].Col = block.cells[x][n].Col + num; } } }</code> </pre><br>  When the bottom is reached, the cells from the block are moved to the pool of the well with the function APELSERG.MODEL.DropBlockToPool ().  At the same time points are awarded. <br><br>  The functionality that is implemented, but, in my opinion, was not very successful (it is not in the settings): <br><ul><li>  APELSERG.CONFIG.PROC.FastDownFlag = false.  If set to true, the drop will not be instant, but visualized. </li><li>  APELSERG.CONFIG.SET.ShowFullRow = false.  If set to true, the filled row will be shown before deletion. </li><li>  APELSERG.CONFIG.SET.SlideToFloor = false.  If set to true, the block after the reset will "slide" on the floor and go to the pool only by the tick of the timer. </li></ul><br><br><h4>  Rendering on Canvas </h4><br>  The APELSERG.CANVA.WellRewrite () function is responsible for drawing the model on the Canvas.  It is very simple and well documented.  All it does is clear the Canvas and consistently draw the model primitives. <br><br><h4>  User interface </h4><br><h5>  Settings, Results, Help </h5><br>  After the model came to life, it became clear that for the holistic game of one revived model is not enough.  This is how the UI modules appeared: <br><ul><li>  APELSERG.UI.  To provide interfaces to settings, results and help. </li><li>  APELSERG.LANG.  To ensure easy localization. </li></ul><br>  This is a typical dynamic DOM, perhaps not the most successful (the code is simple, I will not describe). <br><br><h5>  Local storage </h5><br>  To maintain interest in the game, you need to store settings, results, and perhaps offline mode is useful.  For storage, localStorage is used.  Technologically, everything is implemented in a typical way, but it is useful to trace the connection with global objects APELSERG.CONFIG.SET and APELSERG.CONFIG.RESULT. <br><br>  A few notes: <br><ul><li>  Each domain uses its own localStorage. </li><li>  It is necessary to use localStorage.clear () with great care - it will clear all localStorage for the current domain. </li></ul><br>  The configuration is stored in two objects: <br><ul><li>  CONFIG.SET - static settings that are applied when the application starts (saved in localStorage). </li><li>  CONFIG.PROC - dynamic settings that are used during the operation of the application (not saved in localStorage). </li></ul><br>  The storage name must be unique and is formed from a combination of several static variables: <br><pre> <code class="javascript hljs">APELSERG.CONFIG.SET.Version = <span class="hljs-string"><span class="hljs-string">"0-1-0"</span></span> APELSERG.CONFIG.SET.LocalStorageName = <span class="hljs-string"><span class="hljs-string">"APELSERG-ArcadPlain"</span></span>; APELSERG.CONFIG.GetLocalStorageConfigName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> APELSERG.CONFIG.SET.LocalStorageName + <span class="hljs-string"><span class="hljs-string">"-Config-"</span></span> + APELSERG.CONFIG.SET.Version; }</code> </pre><br>  The configuration is saved when it changes.  This is done simply (even for a separate function is not drawn).  In the function APELSERG.UI.ApplySettings () (module UI), added two lines: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configName = APELSERG.CONFIG.GetLocalStorageConfigName(); localStorage[configName] = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(APELSERG.CONFIG.SET);</code> </pre><br>  When the application starts, the presence of the saved configuration in localStorage is checked and, if the configuration has been saved, it is restored: <br><pre> <code class="javascript hljs">APELSERG.CONFIG.GetConfigOnLoad = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (APELSERG.CONFIG.PROC.LoadFromWeb) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> configName = APELSERG.CONFIG.GetLocalStorageConfigName(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (localStorage[configName] !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { APELSERG.CONFIG.SET = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(localStorage[configName]); } } }</code> </pre><br>  LocalStorage may be empty or not used at all.  Empty localStorage happens: 1. at the first start;  2. if not saved;  3. if has been cleared.  Configuration cleaning may be needed mainly during the development process.  For example, the configuration has changed - variables have been added or removed, and the application continues to work, as if it does not see any changes, as the old configuration object is restored from the storage. <br><br>  If the application was launched from a local disk, the local storage is disabled.  This is done because browsers do not support this mode very well.  But the rest of the functionality of the application is preserved.  Starting from a local disk is controlled at startup: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.location.protocol == <span class="hljs-string"><span class="hljs-string">"file:"</span></span> ? APELSERG.CONFIG.PROC.LoadFromWeb = <span class="hljs-literal"><span class="hljs-literal">false</span></span> : APELSERG.CONFIG.PROC.LoadFromWeb = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Results are stored in APELSERG.CONFIG.RESULT.  Functionally, the storage of results is identical to the storage configuration. <br><br><h5>  Autonomous work </h5><br>  The offline mode (Application Cache or AppCache) allows you to continue working with the web application when the Internet is turned off.  In general terms, setting up different offline conditions can be quite complicated.  But, in our case, this is one of the simplest procedures. <br><br>  You need to prepare a manifest file for offline mode (game_arcad_plain.appcache.txt): <br><pre> CACHE MANIFEST
 # Ver 0.1.0
 # 001
 game_tetr_plain.htm
 game_tetr_plain_canva.js
 game_tetr_plain_config.js
 game_tetr_plain_lang.js
 game_tetr_plain_main.js
 game_tetr_plain_model.js
 game_tetr_plain_model_blocks.js
 game_tetr_plain_ui.js
</pre><br><br>  It is necessary to add a link to this file in the HTML element of the web page: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">manifest</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"game_arcad_plain.appcache.txt"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Thin moment with the extension "txt".  The ‚Äúappcache‚Äù or ‚Äúmanifest‚Äù extension is recommended with the text / cache-manifest MIME type.  The demo is done this way because it was curiously <s>lazy</s> . <br><br>  "# 001" is needed to reload files on the client at the initiative of the server.  If files are updated on the server, they will not get to the client until the manifest file changes.  And what can be changed in it?  - a comment on "# 002". <br><br><h4>  Other games </h4><br>  After the first game was developed, the rest of the games were stamped on the model.  80 percent of the code remained identical, and the changes concerned, basically, only models (the model and control code became simpler).  Therefore, to describe these games separately does not make sense, except for a few nuances: <br><ul><li>  Since there is a constantly moving object (ball) in these games, the animation is performed on window.requestAnimationFrame. </li><li>  The ball moves slower / faster not by changing the time interval, but by changing the coordinate increments in X and Y. The time intervals are not measured (and, in a good way, it would be necessary). </li><li>  Rebound is considered from the center of the ball, taking into account the diameter.  Acceleration and direction are randomly selected.  When moving back, the ball does not see the racket.  The thickness of the block / racket can not be thinner than the size of the ball, otherwise, at high speeds, there can be through-gaps. </li></ul><br><br><h4>  Brief test findings </h4><br>  What well: <br><ul><li>  Animation on Canvas is simple.  The model makes working with Canvas even easier. </li><li>  Local storage and battery life are easy to use. </li></ul><br><br>  What is not very good: <br><ul><li>  Canvas is not on friendly terms with touchscreens.  Even if the application reacts to the touchscreen, anyway, the behavior of a mouse click on a 20-inch display and a finger pointing at the screen of a smartphone will differ.  Therefore, demo games are intended mainly for use on desktop systems, and management is focused on the keyboard.  The positive thing is that having a relatively simple, working desktop application, you can proceed to its further adaptation. </li><li>  Canvas, periodically, lags a little.  There are no mechanisms for fighting. </li></ul><br><br><h4>  useful links </h4><br>  <a href="http://www.w3schools.com/html/html5_canvas.asp">HTML5 Canvas</a> <br>  <a href="http://www.w3schools.com/html/html5_webstorage.asp">HTML5 Local Storage</a> <br>  <a href="http://www.w3schools.com/html/html5_app_cache.asp">HTML5 Application Cache</a> </div><p>Source: <a href="https://habr.com/ru/post/259465/">https://habr.com/ru/post/259465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259453/index.html">STM32 training for the masses</a></li>
<li><a href="../259455/index.html">Attackers use Linux / Moose to compromise Linux-embedded systems, part 2</a></li>
<li><a href="../259457/index.html">How did jQuery start</a></li>
<li><a href="../259459/index.html">Understanding x64 support in WPE Pro</a></li>
<li><a href="../259463/index.html">We calculate gamemasters characters in World of Warcraft using Python</a></li>
<li><a href="../259467/index.html">How to write your NIF in Elixir</a></li>
<li><a href="../259469/index.html">Manage Windows computers from the Linux console</a></li>
<li><a href="../259471/index.html">API Jellyfish: write full text RSS</a></li>
<li><a href="../259473/index.html">Compass with PWM on the stm32f3discovery debug board</a></li>
<li><a href="../259475/index.html">Another language recognizer 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>