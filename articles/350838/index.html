<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study parallel computing with OpenMPI and a supercomputer on the example of hacking neighbor WiFi</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the time of writing the thesis, one of the research directions was parallelization of the search in the state space on computing clusters. I had ac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study parallel computing with OpenMPI and a supercomputer on the example of hacking neighbor WiFi</h1><div class="post__text post__text-html js-mediator-article"><p>  At the time of writing the thesis, one of the research directions was parallelization of the search in the state space on computing clusters.  I had access to a computing cluster, but there was no programming practice for clusters (or HPC - High Performance Computing).  Therefore, before moving on to the combat mission, I wanted to practice something simple.  But I am not a fan of abstract hello world without real practical problems, therefore such a task was quickly found. </p><br><p><img src="https://habrastorage.org/webt/vq/pg/l6/vqpgl6ya06oaeazplmfpqru80x0.png"></p><br><p>  Everyone knows that brute force is the most inefficient way to select passwords.  However, with the advent of supercomputers, it became possible to significantly speed up this process, since, as a rule, the search will be paralleled with virtually no overhead.  Therefore, in theory, a process with a linear coefficient can be accelerated on a cluster, i.e.  having 100 cores - speed up the process 1000 * k times (where 0.0 &lt;k &lt;= 1.0).  Is it in practice? </p><a name="habracut"></a><br><p>  Therefore, as a training exercise, the task was to check it.  A practical task was the organization of brute force passwords to WPA2 on a computing cluster.  Therefore, in this article I will describe the methodology used, the results of experiments and lay out the source codes written for this. </p><br><p>  It should be understood that the practical use of the problem being solved tends to zero, since no one will actually drive huge clusters, burning electricity worth hundreds of times more than the cost of the router and the annual subscription fee for the Internet, in order to find the password for this poor router.  But if you close your eyes to this and look at the <a href="https://en.wikipedia.org/wiki/Supercomputer">rating of supercomputers</a> , you can see that the top clusters include up to 6 million cores.  This means that if on a single-core machine a certain password is selected for 10 years, then such a cluster in the case of a spherical horse in a vacuum will deal with it in 10 <em>365</em> 24 <em>60</em> 60/6000000 = 53 seconds. </p><br><h1 id="kak-rabotaet-wpa2-avtorizaciya">  How WPA2 Authorization Works </h1><br><p>  There are enough resources on this topic in the open spaces of the network, so I will explain very briefly.  Suppose there is an access point and a client device nearby.  If the client wants to establish a connection, he initiates a sequence of packet exchange, during which he tells the password to the access point, and the point decides whether to grant him access or not.  If they "agree", then the connection is considered established. </p><br><p>  In order for an attacker to obtain an authorization password, it is necessary to fully listen to the exchange of messages between the access point and the client, and then pick up a hash from a specific field of a specific package (the so-called handshake).  It is in this package that the client tells his password. </p><br><p>  But how to catch the authorization process?  If we assume that we are breaking the neighbor's WiFi, then we must either wait until the neighbor comes out with the phone and comes back, or forcibly break the connection.  And there is such an opportunity.  To do this, send a request to disconnect the connection, to which the devices will eventually respond, and reconnection will occur.  For the user, this process will be invisible, and we will find the authorization process. </p><br><h1 id="instrumenty">  Instruments </h1><br><p>  The packages themselves can be caught by ‚Äúspecial‚Äù WiFi points, the drivers for which are available in the specialized <a href="https://www.kali.org/">Kali Linux distribution</a> , as are all the necessary tools.  On <a href="https://www.ebay.com/itm/USB-WiFi-Adapter-Kali-Linux-Aircrack-Compatible-Hack-WiFi-Network-2dBi-Antenna/292460548889%3Fhash%3Ditem441801d319:g:B~4AAOSwItJafJyz">ebay</a> or <a href="https://www.aliexpress.com/item/Atheros-AR9271-150Mbps-USB-WiFi-Adapter-with-5DBi-WiFi-Antenna-Ethernet-Adapter-For-Beini-ROS-Windows/32652651808.html">aliexpress,</a> you can find hundreds of suitable points, and compatibility should be checked on the OS website in advance (compatibility should be checked with the chip on which the point is based). </p><br><p>  However, for this work the greatest interest are the tools for processing a handshake package and selecting a password.  The most famous and advanced tool is <a href="https://www.aircrack-ng.org/">aircrack-ng</a> , which also has open source code.  We still need it, but this later. </p><br><p>  However, they are all designed to use a local processor or video card.  I have not found such a tool to run on a supercomputer, which means we don‚Äôt invent a bicycle and it's time to write it ourselves. </p><br><h1 id="perebor-po-alfavitu">  Alphabetical enumeration </h1><br><p>  Before something parallel, you need to make a semantic part - the search mechanism.  To do this, we introduce the concept of "alphabet" on the basis of which the search is carried out.  The alphabet is a non-repeating set of all characters that a password can make up.  Therefore, if the alphabet has N symbols, then any password can be represented as a number in the Nth numeral system, where each digit corresponds to a symbol with an identical sequence number. </p><br><pre><code class="hljs php">: abcdefgh (<span class="hljs-number"><span class="hljs-number">8</span></span> ,   ) <span class="hljs-number"><span class="hljs-number">00000</span></span> =&gt; aaaaa <span class="hljs-number"><span class="hljs-number">01070</span></span> =&gt; abaha <span class="hljs-number"><span class="hljs-number">11136</span></span> =&gt; bbbdg</code> </pre> <br><p>  Therefore, we will create the class key_manager, which will be initialized with a string alphabet. </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">key_manager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal_key_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">numeric_key_t</span></span>; key_manager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key_t</span></span> &amp; _alphabet); <span class="hljs-comment"><span class="hljs-comment">//     key_id_t get_key_id(const internal_key_t &amp; key) const; //     void to_internal(const key_t &amp; alpha_key, internal_key_t &amp; int_key) const; //       key_id_t get_key_id(const key_t &amp; alpha_key) const; };</span></span></code> </pre><br><p>  It will need methods for converting from internal representation (in numerical form) to string form and in the opposite direction.  In the opposite direction, you will need to convert if you need to start with some given password, and not a zero one, for example, if you need to continue the search, and not start over. </p><br><p>  At the same time, the numbers themselves will be stored in a special class, the so-called internal representation.  I do not want to lose readability and do it correctly, so we will make it in the form of a vector, where each element corresponds to a ‚Äúnumber‚Äù. </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">numeric_key_t</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>&gt; data; };</code> </pre> <br><p>  The ordinal identifier will be an integer, take as an example a 128-bit unsigned int. </p><br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">key_id_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">__uint128_t</span></span>;</code> </pre> <br><p>  Of course, if you do it in an entirely clever way, then you should write your class big_integer, but as part of my experiments, all the passwords fit into a 128-bit integer, so we will not waste time on things that will never be needed. </p><br><h1 id="arhitektura-poiskovogo-dvizhka">  Search Engine Architecture </h1><br><p>  The task of the search engine is to iterate over the range of keys, to tell whether the correct one is found, and if so, to return the found key.  But the engine doesn‚Äôt care what the passwords are for - for WiFi or md5, so we‚Äôll hide the implementation details inside the template. </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">brute_forcer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> key_manager { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key_length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> first, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> last, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; correctKeyId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; }</code> </pre> <br><p>  Inventory of this method, we simply write a loop that goes linearly from first to last, and if a suitable key is found, it will return true and write the identifier found in the correctKeyId. </p><br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">checker_t</span></span> = C; ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">checker_t</span></span> checker; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(checker(first, str_key, correctVal, correctKeyId)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br><p>  Thus, it becomes clear what the interface should be for a class that already "knows" what the password is being selected for.  In my version, I debugged this class on md5 before switching to wpa2, so you can find classes for both tasks in the repository.  Next, let's do the checker itself. </p><br><h1 id="proveryaem-parol">  We check the password </h1><br><p>  Let's start with a simple version for selecting a password for md5-hashes.  The corresponding class will be as simple as possible, it only needs one method, in which the actual check takes place: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">md5_crypter</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key_manager::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">key_id_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cur_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; code, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; correct_res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key_manager::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">key_id_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; correctId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res = (md5(code) == correct_res); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(res) correctId = cur_id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } };</code> </pre> <br><p>  The function std :: string md5 (std :: string) is used for this, which, on the basis of the given string, returns it md5.  Everything is as simple as possible, so now let's hook up the aircrack-ng fragments. </p><br><h1 id="podklyuchaem-aircrack">  We connect aircrack </h1><br><p>  The first difficulties come in getting the file with the handshake package.  Here I find it difficult to remember exactly how I received it, but it seems that patch airodump or aircrack, so that it preserves the desired fragment.  And maybe it was done by regular means.  In any case - in the repository is an example of such a package. </p><br><p>  Throwing away all unnecessary, for work we need the following structure: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ap_data_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> essid[<span class="hljs-number"><span class="hljs-number">36</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> bssid[<span class="hljs-number"><span class="hljs-number">6</span></span>]; WPA_hdsk hs; };</code> </pre> <br><p>  Which of the corresponding file can be considered as reading several fragments of the handshake file: </p><br><pre> <code class="hljs mel"> FILE * tmpFile = <span class="hljs-keyword"><span class="hljs-keyword">fopen</span></span>(file_name.c_str(), <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); ap_data_t ap_data; <span class="hljs-keyword"><span class="hljs-keyword">fread</span></span>(ap_data.essid, <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, tmpFile); <span class="hljs-keyword"><span class="hljs-keyword">fread</span></span>(ap_data.bssid, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, tmpFile); <span class="hljs-keyword"><span class="hljs-keyword">fread</span></span>(&amp;ap_data.hs, sizeof(struct WPA_hdsk), <span class="hljs-number"><span class="hljs-number">1</span></span>, tmpFile); <span class="hljs-keyword"><span class="hljs-keyword">fclose</span></span>(tmpFile);</code> </pre> <br><p>  Next, you need to perform some kind of preprocessing of this data in order not to repeat the calculations for each password (in the wpa2_crypter constructor), but here you can not really think about it, but simply transfer it from the aircrack.  The most interesting is in aircrack / sha1-sse2.h, in which there are functions calc_pmk and calc_4pmk, which perform useful calculations. </p><br><p>  Moreover, calc_4pmk is a version of calc_pmk, which, in the presence of an SSE2 processor, allows you to calculate as many as 4 keys in one step, thus speeding up the process 4 times.  Considering that now such an extension exists on almost all processors, it should definitely be used, even though this adds a slight complexity to the implementation. </p><br><p>  To do this, we add buffering to our wpa2_crypter class ‚Äî since brute_forcer will request one key, calculations will be run only for every 4th time.  And the data processing logic, again, is neatly transferable from aircrack, without changing anything.  As a result, the verification function is obtained as follows: </p><br><pre> <code class="hljs pgsql">value_t <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(typename key_manager::key_id_t cur_id, const std::string &amp; code, <span class="hljs-type"><span class="hljs-type">bool</span></span> , typename key_manager::key_id_t &amp; correctId) const { <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[localId].key_id = cur_id; memcpy(<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[localId].key, code.data(), code.size()); ++localId; if(localId == <span class="hljs-number"><span class="hljs-number">4</span></span>) { //     <span class="hljs-number"><span class="hljs-number">4</span></span>  //   calc_4pmk((<span class="hljs-type"><span class="hljs-type">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>].key, (<span class="hljs-type"><span class="hljs-type">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>].key, (<span class="hljs-type"><span class="hljs-type">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>].key, (<span class="hljs-type"><span class="hljs-type">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>].key, (<span class="hljs-type"><span class="hljs-type">char</span></span>*)apData.essid, <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>].pmk, <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>].pmk, <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>].pmk, <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>].pmk); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(unsigned j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; localId; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++){ pke[<span class="hljs-number"><span class="hljs-number">99</span></span>] = i; HMAC(EVP_sha1(), <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[j].pmk, <span class="hljs-number"><span class="hljs-number">32</span></span>, pke, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[j].ptk + i * <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); } HMAC(EVP_sha1(), <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[j].ptk, <span class="hljs-number"><span class="hljs-number">16</span></span>, apData.hs.eapol, apData.hs.eapol_size, <span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[j].mic, NULL); if(memcmp(<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span>[j].mic, apData.hs.keymic, <span class="hljs-number"><span class="hljs-number">16</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { //,    correctId = cur_id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } localId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><p>  For all non-multiple 4m requests - we say that the key does not fit.  And at 4m, if the key is found, then we return both the true and the key itself.  The buffer is accumulated in an array of 4 elements of the following type: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cache_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> key[<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> pmk[<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ptk[<span class="hljs-number"><span class="hljs-number">80</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> mic[<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> key_manager::<span class="hljs-keyword"><span class="hljs-keyword">key_id_t</span></span> key_id; };</code> </pre> <br><p>  As a matter of fact, the re-finder is ready.  In order to use it, perform the following actions: </p><br><pre> <code class="hljs lua">//    handshake- ap_data_t ap_data; //  ,      wpa2_crypter crypter(ap_data); //      brute_forcer&lt;wpa2_crypter&gt; bforcer(crypter, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"abcdefg123455..."</span></span>); //  <span class="hljs-number"><span class="hljs-number">1000</span></span>  std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> correct_key; bforcer(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>, correct_key);</code> </pre> <br><p>  However, aircrack can also count in one stream, but we don‚Äôt need it? </p><br><h1 id="arhitektura-parallelnosti">  Concurrency architecture </h1><br><p>  After studying the existing frameworks and software for organizing parallel computing installed on a cluster to which I had access, I decided to stop at <a href="https://www.open-mpi.org/">Open MPI</a> .  Work with him begins with the lines: </p><br><pre> <code class="hljs perl">//  <span class="hljs-keyword"><span class="hljs-keyword">fork</span></span> MPI::Init(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rank = MPI::COMM_WORLD.Get_rank(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = MPI::COMM_WORLD.Get_size(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ... //  MPI::Finalize();</code> </pre> <br><p>  On the Init () call, the processes will be split, after which the rank number of the calculator will be in rank, and the total number of calculators in size.  Processes can be run on different machines that make up a cluster, so you will have to forget about shared memory in an easy way - communication between processes comes with the help of two functions: </p><br><p>  MPI :: COMM_WORLD.Recv (&amp; res_task, sizeof (res_task), MPI :: CHAR, MPI_ANY_SOURCE, 0, status); </p><br><pre> <code class="hljs pgsql">//    MPI_Send( <span class="hljs-type"><span class="hljs-type">void</span></span>* data, <span class="hljs-type"><span class="hljs-type">int</span></span> count, MPI_Datatype datatype, <span class="hljs-type"><span class="hljs-type">int</span></span> destination, <span class="hljs-type"><span class="hljs-type">int</span></span> tag, MPI_Comm communicator) //     MPI_Recv( <span class="hljs-type"><span class="hljs-type">void</span></span>* data, <span class="hljs-type"><span class="hljs-type">int</span></span> count, MPI_Datatype datatype, <span class="hljs-type"><span class="hljs-type">int</span></span> source, <span class="hljs-type"><span class="hljs-type">int</span></span> tag, MPI_Comm communicator, MPI_Status* status)</code> </pre> <br><p>  More information about the interaction can be found <a href="http://mpitutorial.com/tutorials/mpi-send-and-receive/">here</a> .  And now let's invent the architecture of the parallel search engine. </p><br><p>  For good, given the specifics of the problem, it would be worth making the following architecture.  If there are N cores in a cluster, then every i-th core should check the keys with i + N * k identifiers, k = 0,1,2 ..., without interacting with each other.  Then the performance will be maximum.  But, as I said at the very beginning, the main task is to master the technology, therefore it is necessary to master the communication between the computers. </p><br><p>  Therefore, I chose a different architecture, where the processes are divided into two types, and here I will describe the most clear option, the version is implemented in the repository a little bit harder and faster, but still this is not the fastest option. </p><br><p>  To do this, conditionally divide the processes into 2 types - managers and workers.  The manager will send tasks to workers, and the workers will, in fact, count hashes.  For simplicity, the exchange between processes will be POD structs.  Schematically, you can imagine the processes in the following figure: </p><br><p><img src="https://habrastorage.org/webt/b-/8z/jo/b-8zjobcot3okyonfoet_zpzryy.png"></p><br><p>  Create, respectively, the controller and searcher classes, which we instantiate after identifying the process: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rank == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-function"><span class="hljs-function">controller </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ctrl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, start_key</span></span></span><span class="hljs-function">)</span></span>; ctrl.run(size - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-function"><span class="hljs-function">searcher </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">srch</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, rank</span></span></span><span class="hljs-function">)</span></span>; srch.run(); }</code> </pre> <br><p>  Objects searchers will wait for task messages, process them and send back reports messages.  The controller will only deal with sending tasks and checking the results.  Seriously, the controller can also do calculations during downtime, but for our example we will not complicate the architecture with this. </p><br><p>  Moreover, it is necessary to avoid situations when the worker thread counted the task, and did not have time to get new and idle.  This is achieved through the use of queues, and separation of the transport and computational flow in the simplest case with mutexes, although the good need to be done on conditional_variable.  Therefore, schematically, the data exchange between the controller and the workflow can be represented as follows: </p><br><p><img src="https://habrastorage.org/webt/wh/vy/zc/whvyzcuytelel3-oqd4voxj77hk.png"></p><br><p>  Instead of citing synchronized code snippets here, I refer to my own repository.  And we turn to the final part - the experiments. </p><br><h1 id="eksperimenty">  Experiments </h1><br><p>  It would seem that this is the most expected part of the article, but due to the simplicity of the problem being solved, the results completely coincide with the expected ones. </p><br><p>  For experiments, a handshake package was taken, which I took from my point, as well as a pair of neighbors.  By the way, the process is not very pleasant and deterministic, and it took more than an hour. </p><br><p>  On my packages I was convinced of the correctness of the work of the developed software, and on the neighbors already tried the technology in real conditions. </p><br><p>  In the above sources, I made a periodic output of debug information about the current speed, the number of scanned keys and the expected time to check the keys of the current length. </p><br><p>  At my disposal was a small supercomputer with 128 cores in total.  There was, of course, SSE in it, although for the purity of the experiment I turned it off - and received a speed 4 times less. </p><br><p>  The dynamics of the work itself is also quite expected - it takes a few seconds to disperse and collect statistics, after which the engine shows a stable brute force.  Depending on the number of cores, an approximately linear increase in speed is achieved (which is obvious), however, a simple controller core and careless synchronization of threads make themselves felt - the growth constant turned out to be in the region of 0.8‚Äì0.9. </p><br><p>  But the most interesting thing awaited me when I started the engine on the neighbor's key - not having managed to overclock all the cores, the password was already found ... it was the date of birth of someone from the neighbor's family.  On the one hand, I was disappointed, on the other - I still solved the initial problem. </p><br><p>  I don‚Äôt see the absolute values ‚Äã‚Äãof the speeds, because  You can try it on your available machines - all the sources are at the end of the article.  And knowing the coefficient of parallelism and the characteristics of the machine, you can quite accurately calculate what speed can be achieved. </p><br><h1 id="ishodniki">  Sources </h1><br><p>  The sources for the described implementation can be found in my <a href="https://github.com/ultrablox/ultra_crypt">github</a> repository.  The code was fully working, going under Linux and Mac OS.  But ... more than 2 years have passed, I do not know how much the API of the same Open MPI has changed. </p><br><p>  In the test / folder you can find an example of a handshake package compiled under the format used. </p><br><p>  The code itself is rather dirty, but due to the lack of practical value of the problem being solved, there was no sense in combing it either.  The project also does not develop due to the senselessness, but if someone liked the idea, or he saw why it can be used ... then take it and use it. </p><br><p>  The start-up line indicates the handshake file and, optionally, the start key, if you want to start with a non-zero element. </p><br><blockquote>  brute_wpa2 k aaa123aaab ap_Dom.hshk </blockquote><p>  Parameter parsing itself is in src / brute_wpa2.cpp, from it you can also understand how to set the first key identifier by a number, as well as set the chunk size. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  This article gives a small excursion into parallel programming on the example of the simplest practical problem and its fairly simple solution.  I accomplished the task I have set - not only having mastered the modern technologies of parallel programming, I got the skills to accomplish the combat task in my thesis, but also picked up the password from the neighboring WiFi.  True, I used them only once - to check the correctness, but it was still nice. </p><br><p>  But returning to the practical usefulness of the work done, in connection with the latest events, I would like to note the rush around the bitcoins.  Considering that the basis of WPA2 hacking is the calculation of SHA hashes, as in the mining of bitcoins, a new direction is opened for the development of this work.  Since mining <a href="https://en.bitcoin.it/wiki/ASIC">equipment has</a> been developed that can only count the necessary hashes, it is interesting to check how adaptable it is and how it is applicable for WPA2 hacking.  Of course, such chips are much more efficient than the latest general-purpose processors in the selection of hashes, so perhaps interesting results can be achieved here. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350838/">https://habr.com/ru/post/350838/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350828/index.html">The process of porting Linux device drivers</a></li>
<li><a href="../350830/index.html">Alan Kay: The future can not be built gradually</a></li>
<li><a href="../350832/index.html">6 interesting bugs that I encountered while making the game for VKontakte</a></li>
<li><a href="../350834/index.html">Chip Puzzle: an unbreakable processor will be developed for DARPA</a></li>
<li><a href="../350836/index.html">Descriptor graphics in MATLAB: the second horizontal axis</a></li>
<li><a href="../350840/index.html">Sentenced to Russian hackers who attacked US exchanges</a></li>
<li><a href="../350842/index.html">Experience in the development of a non-commercial project by the Junior</a></li>
<li><a href="../350844/index.html">Design by Introspection</a></li>
<li><a href="../350846/index.html">Using the render props template outside of the render</a></li>
<li><a href="../350848/index.html">Women in IT, an inside look</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>