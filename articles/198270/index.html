<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qt Meta System over Network. Part 1 - Properties</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With enviable regularity, I have the task of writing client-server applications using Qt. And I thought - why not simplify this process? In fact, why ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qt Meta System over Network. Part 1 - Properties</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/231/e13/1b3/231e131b3b76d10af2cc0bfa5c96b413.jpg" align="left"><br>  With enviable regularity, I have the task of writing client-server applications using Qt.  And I thought - why not simplify this process?  In fact, why reinvent a new protocol every time if you can use the usual signals and slots?  Something similar already exists, for example, D-Bus or QRemoteSignal, but they seemed to me not very convenient, and there are no some possibilities in them. <br><a name="habracut"></a><br>  Agree, it would be very convenient to write something like this: <br>  Computer 1: <br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      xValue net.addProprety("value", "xValue", object); //   net.addSignal("started", object, SIGNAL(started(int, QString))); //   net.addFunction("start", object, "method_name");</span></span></code> </pre> <br><br>  Computer 2: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     net.setProperty("value", 123); //    -  ,  QLineEdit net.bindProperty("value", lineEdit, "text"); //     net.connect(SIGNAL(started(int, QString)), object, SLOT(onStarted(int, QString))); //   ( ) bool ok; QVariant ret = net.call("start", QVariantList() &lt;&lt; "str1" &lt;&lt; 1, &amp;ok); //   (      ) net.call("start", QVariantList() &lt;&lt; "str1" &lt;&lt; 1, object, SLOT(startCalled(bool, QVariant)));</span></span></code> </pre><br>  net is an abstract network access interface <br><br>  It is also easy to write methods that make available immediately a whole list of properties or signals of an object.  And that is not all!  You can easily attach to all this Qt Quick.  In general, having figured out how to still learn about changing properties, catch signals, and execute any slots at runtime with any types, a lot can be done. <br>  Let's start with the simplest - properties. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  1. Properties </h4><br>  First, consider how to change any properties dynamically, and more importantly, to receive signals about their change in the form: &lt;property name, new value&gt; <br><br>  It is in the name of the property that the problem lies - if we connect the signal about the change of all properties to one slot, we will not be able to find out the name of the changed property.  We can only find out who sent this change using the sender () function, but the name of the property cannot be recognized in this way.  Here it immediately comes to mind to create for each property an object of some class that will store the name of the property, receive a signal about its change, and generate a new signal, but already with a name. <br><br><h5>  Method "in the forehead" </h5><br><pre> <code class="cpp hljs">Class Property { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Proprety(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;name) : m_name(name) {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">propertyChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QVariant &amp;newValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapped</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m_name, newValue)</span></span></span></span>; } signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapped</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;propertyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QVariant &amp;newValue)</span></span></span></span>; }</code> </pre><br>  Now, if we want to find out about changes in the p1, p2 properties of the object, we can write the following code: <br><pre> <code class="cpp hljs">PropertyMapper *m1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PropertyMapper(<span class="hljs-string"><span class="hljs-string">"p1"</span></span>); connect(object, SIGNAL(p1Changed(QVariant)), m1, SLOT(propertyChanged(QVariant)); PropertyMapper *m2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PropertyMapper(<span class="hljs-string"><span class="hljs-string">"p2"</span></span>); connect(object, SIGNAL(p2Changed(QVariant)), m2, SLOT(propertyChanged(QVariant));</code> </pre><br>  Next, simply connect to the signal PropertyMapper :: mapped and get signals with the name of the property and its new value.  But here you can immediately see obvious problems: a waste of memory and processor resources, as well as, perhaps more importantly, the inability to work with the properties of other types without creating additional slots for each type, transformations, etc.  In general, there is a much more elegant way to solve all these problems at once. <br><br><h5>  Advanced method </h5><br>  First, let's look at how the slot is called and how the QObject :: connect () function works. <br>  Slot call <br>  The Q_OBJECT macro added to the class declaration results (among other things) in adding the qt_metacall () method.  It is through it that slots are called, properties are set.  And all the checks for the existence of a slot, the casting of arguments are implemented in it.  The standard implementation looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Counter::qt_metacall(QMetaObject::Call _c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _id, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **_a) { _id = QObject::qt_metacall(_c, _id, _a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_id &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _id; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_c == QMetaObject::InvokeMetaMethod) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: valueChanged((*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(*)&gt;(_a[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: setValue((*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(*)&gt;(_a[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } _id -= <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _id; }</code> </pre><br><br><h6>  QObject :: connect </h6><br>  Briefly look at the actions performed by this function: <br>  1) The conversion of the names of signals and slots into a normalized form, i.e.  remove extra spaces, and some other transformations (more QMetaObject :: normalizedSignature ()) <br>  2) Type checking <br>  3) Calculation of slot indices and signals by their names using object-&gt; metaObject () -&gt; indexOfSlot (indexOfSignal) () <br>  4) And the most interesting thing is connecting the signal to the slot by index using QMetaObject :: connect (). <br>  I think many have already guessed what needs to be done - write your own implementation of qt_metacall and connect to the signal about a property change manually.  Let's start: <br><br>  PropertyMapper.h <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PropertyMapper</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject <span class="hljs-comment"><span class="hljs-comment">//     Q_OBJECT { public: PropertyMapper(QObject *mapToObject, const char *mapToMethod, QObject *parent = 0); int addProperty(const QString &amp;propertyName, const char *mappingPropertyName, QObject *mappingObject, bool isQuickProperty); void setMappedProperty(const QString &amp;name, const QVariant &amp;value); QVariant mappedProperty(const QString &amp;name) const; int qt_metacall(QMetaObject::Call call, int id, void **arguments); private: QObject *m_mapTo; const char *m_toMethod; QHash&lt;QString, int&gt; m_propertyIndices; typedef struct { QString name; QVariant::Type type; const char *mappingName; QObject *mappingObject; bool isQuickProperty; // need to call mappingObject-&gt;property to get value QVariant lastValue; } property_t; QList&lt;property_t&gt; m_properties; };</span></span></code> </pre><br>  I will not describe what all the fields are for, now everything will become clear.  Consider the key points in pieces (you can download the whole at the end of the article). <br><br>  Adding a property named propertyName, while all actions will occur with the mappingPropertyName property of the mappingObject object.  If we want to do this focus with the Qt Quick property, it is necessary to set isQuickProperty to true (it will become clear how this is done later). <br><br>  First, we check if there is a property with the same name.  (m_propertyIndices contains property_name_pairs and property_index): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PropertyMapper::addProperty(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;propertyName, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *mappingPropertyName, QObject *mappingObject, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isQuickProperty) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_propertyIndices.contains(propertyName)) { qWarning() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"can't create"</span></span> &lt;&lt; propertyName &lt;&lt; <span class="hljs-string"><span class="hljs-string">"property, already exist!"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  We get the index of the property, and then by the QMetaProperty index: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> propertyIdx = mappingObject-&gt;metaObject()-&gt;indexOfProperty(mappingPropertyName); QMetaProperty metaProperty = mappingObject-&gt;metaObject()-&gt;property(propertyIdx);</code> </pre><br>  Save information about the added property: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = m_properties.size(); m_propertyIndices[propertyName] = id; m_properties.push_back({propertyName, metaProperty.type(), mappingPropertyName, mappingObject, isQuickProperty, QVariant()});</code> </pre><br>  Now the most interesting thing is to get the index of the signal about a property change, and connect to it, the type checking is not performed, because  we save the property type (metaProperty.type ()) and we will bring to it the resulting property value: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signalId = metaProperty.notifySignalIndex(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signalId &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { qWarning() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"can't create"</span></span> &lt;&lt; propertyName &lt;&lt; <span class="hljs-string"><span class="hljs-string">"(notify signal doesn't exist)"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!QMetaObject::connect(mappingObject, signalId, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, id + metaObject()-&gt;methodCount())) { qWarning() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"can't connect to notify signal:"</span></span> &lt;&lt; mappingPropertyName; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; }</code> </pre><br><br>  And most importantly - qt_metacall (): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PropertyMapper::qt_metacall(QMetaObject::Call call, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **arguments) { <span class="hljs-comment"><span class="hljs-comment">// ,   ,  ,    id = QObject::qt_metacall(call, id, arguments); if (id &lt; 0 || call != QMetaObject::InvokeMetaMethod) return id; Q_ASSERT(id &lt; m_properties.size());</span></span></code> </pre><br>  Get the previously saved information about the property: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">property_t</span></span> &amp;p = m_properties[id];</code> </pre><br>  Focus with quick property:  The signal about changing the quick property is smthChanged ()  without the actual value, we get it manually.  And then we just call the method specified when creating a class object (we cannot generate a signal, because we did not add the Q_OBJECT macro, of course, we can do it without it, but why complicate things unnecessarily ...): <br><pre> <code class="cpp hljs"> QVariant value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p.isQuickProperty) { value = p.mappingObject-&gt;property(p.mappingName); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data = arguments[<span class="hljs-number"><span class="hljs-number">1</span></span>]; value = QVariant(p.type, data); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != p.lastValue) { p.lastValue = value; QMetaObject::invokeMethod(m_mapTo, m_toMethod, Q_ARG(QString, p.name), Q_ARG(QVariant, value)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  We also keep the last value of the property, this can not be done only if we have one client and one server, but if there are many participants, then changing the property from the outside can lead to an avalanche effect (namely, multiple installation of this property at the same time). value). <br><br>  A small example of use: <br><pre> <code class="cpp hljs">Reciever reciever; <span class="hljs-function"><span class="hljs-function">PropertyMapper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;reciever, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mapped"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Tester tester; mapper.addProperty(<span class="hljs-string"><span class="hljs-string">"value_m"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>, &amp;tester); mapper.addProperty(<span class="hljs-string"><span class="hljs-string">"name_m"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, &amp;tester); tester.setName(<span class="hljs-string"><span class="hljs-string">"Button1"</span></span>); tester.setValue(<span class="hljs-number"><span class="hljs-number">123</span></span>);</code> </pre><br>  Tester only contains two properties, and Reciever has the following method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Q_INVOKABLE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapped</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;propertyName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QVariant &amp;newValue)</span></span></span><span class="hljs-function"> </span></span>{ qDebug() &lt;&lt; propertyName &lt;&lt; newValue; }</code> </pre><br>  Run: <br><blockquote>  "Name_m" QVariant (QString, "Button1") <br>  "Value_m" QVariant (int, 123) </blockquote><br>  That's all for now :) <br><br>  <a href="">Whole class</a> </div><p>Source: <a href="https://habr.com/ru/post/198270/">https://habr.com/ru/post/198270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198254/index.html">Only a few will be left.</a></li>
<li><a href="../198256/index.html">From the experience of creating a programming circle for children</a></li>
<li><a href="../198264/index.html">Prevent participation in dns amplification attack or experience in writing nuclear code</a></li>
<li><a href="../198266/index.html">Algorithm for finding paths in the maze</a></li>
<li><a href="../198268/index.html">Algorithm for learning a multilayer neural network using the back propagation error (Backpropagation)</a></li>
<li><a href="../198272/index.html">Chelyabinsk meteorite: systematized photo and video materials</a></li>
<li><a href="../198274/index.html">Metaobject Protocol for Basic Perl 5</a></li>
<li><a href="../198276/index.html">Zabbix: Backing up a small base</a></li>
<li><a href="../198280/index.html">Babel and handlebars, it's time to make friends</a></li>
<li><a href="../198284/index.html">How to cheat Robokassu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>