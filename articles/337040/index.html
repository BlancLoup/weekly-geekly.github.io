<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄúRise of Machinery Learning‚Äù or combine a hobby in Data Science and analyzing the spectra of light bulbs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the final article of the cycle devoted to the study of Data Science from scratch , I shared my plans to combine my old and new hobby and place the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>‚ÄúRise of Machinery Learning‚Äù or combine a hobby in Data Science and analyzing the spectra of light bulbs</h1><div class="post__text post__text-html js-mediator-article">  In the final article of the cycle devoted to the study of <a href="https://habrahabr.ru/post/335214/">Data Science from scratch</a> , I shared my plans to combine my old and new hobby and place the result on Habr√©.  Since past articles have found a lively response from readers, I decided not to postpone it for long. <br><br>  So, for the past several years I have been busy in my spare time in questions related to lighting and most of all I am interested in the spectra of various light sources, like ‚Äúancestors‚Äù of the characteristics derived from them.  But not so long ago, I accidentally had another hobby - machine learning and data analysis, in this matter I am an absolute beginner, and in order to have fun, I periodically share my newfound experience and stuffed "bumps" <br><br>  This article is written in the style of <b>newbies to beginners</b> , so <b>experienced</b> readers are unlikely to get something new for themselves, and if there is a desire to solve the problem of classifying light sources according to spectra, then it <b>makes sense to immediately</b> <a href="https://github.com/bosonbeard/ML_light_sources_classification/tree/master/1st_spectrum_classification">get data from GitHub</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And for those who do not have a great experience, I will suggest continuing our joint training and this time try to take up the task of machine learning, which is called ‚Äúfor yourself‚Äù. <br><br>  We will go with you from trying to understand where you can apply even a little knowledge of ML (which can be obtained from basic books and courses), to solving the very task of classification itself and thinking about "what to do now with all this ?!" <br><br>  You are welcome all under the cat. <br><br><img src="https://habrastorage.org/web/dab/f53/7b1/dabf537b1c8c40408563e831932d4032.png"><br><a name="habracut"></a><br>  So, colleagues in front of us is a very important mission to find out how dangerous artificial intelligence is, is it time for us to blow up Skynet or can we spend a little more time watching videos with cats. <br><br>  In this article, we will, on the basis of approximately such images, determine what type of lamp the lamp is in: fluorescent or LED, or perhaps even the light of the sun and sky. <br><br><img src="https://habrastorage.org/web/e54/881/7db/e548817dba8f4aa69e7d23c1bfb32add.png"><br><br><h3>  Part 1. Briefing </h3><br>  Let's start with a rather <b>important point</b> , namely with the requirements for skills.  As in the previous articles, I share with you the experience that I managed to get myself and before starting the article it is important to understand that it can be useful to people with similar experiences.  As I said earlier, material is unlikely to be useful to experienced specialists. <br><br>  <i>Although they can certainly find some mistakes in it and tell me about it, so that I can correct them if possible.</i> <br><br>  This time, in order for the article not to cause you difficulties, we already need some basic skills, namely: <br><br><ol><li>  Understanding what Data Science is and why it is needed </li><li>  Minimal Python programming skills </li></ol><br>  If you have taken online courses or have read a self-instruction manual, I think this will be quite enough. <br><br>  <b>The second important point to</b> understand why we all do it? <br><br>  Indeed, if you just want to practice analyzing data and solving machine learning problems, then there are many wonderful tasks on Kagle, including those suitable for absolute beginners (for example, about Titanic). <br><br>  Most likely, these tasks will be more correct and in cases with tasks for beginners you will surely find more successful tutorials than in our case, so if you still do not itch your hands to ‚Äúinvent your own bike‚Äù or do not have enough skills, then it makes sense to practice Kagle ( <a href="https://habrahabr.ru/post/331992/">I wrote about this before</a> ). <br><br>  In the book <b>Data Science from Scratch</b> , closer to the end, the author suggested not dwelling on the materials of the book and coming up with a task on my own, while sharing my ideas, at that moment I thought: ‚ÄúOf course, you are so smart, but I have no idea what to do! ". <br>  In my opinion, this idea was very fair, because it is hard to learn from this book, something very useful in practice ( <a href="https://habrahabr.ru/post/331794/">for more details on this in the review</a> ).  And in the end, before sculpting dumplings, it probably makes sense to try them all the same, and it is advisable to try the good ones, so that is what it seeks. <br><br>  In the Specialization "Machine Learning and Data Analysis", through the eyes of a newbie in Data Science "on Coursera ( <a href="https://habrahabr.ru/post/335214/">review</a> ), there was something to try and get a hand on what, and after passing it, it became certain that now it‚Äôs not perfect, but You can collect and analyze data yourself. <br><br>  Summing up the chapter, I want to say, from a pedagogical point of view, I consider VERY useful and important the stage of self-setting the problem for machine learning, even if it is purely ‚Äúfake‚Äù.  That is why I decided to share my example with you. <br><br><h3>  Part 2. Do not learn to live help financially. </h3><br>  Let's address the question of where to get the material (data) for our research. <br>  In my opinion, the source itself is not so important, the main thing is that the subject matter is close to you and you can find more or less a sufficient amount of reliable data. <br><br>  Well, for example: <br><br>  1. You can classify your friends by text messages in the social.  networks (someone is silent, someone often uses keywords, someone puts a bunch of emoticons, and so on) <br><br>  2. Or, based on past data (well, for example, utility bills), you can predict how much hot water or electricity you will spend this November. <br><br>  3. And you can restore the relationship between the rating of the downloaded series and the number of "snacks" that you eat when viewing it. <br><br>  4. If you are a very angry person, try to solve the problem of the number of cats in your single friends <br><br>  5. If you have a hard time with personal experience and you do not store archives in yellowed folders, look at the domestic (or foreign) open data portals <a href="http://data.gov.ru/">data.gov.ru</a> or for Moscow <a href="https://data.mos.ru/">data.mos.ru</a> , for example, you can find the data in order to predict the <a href="https://data.mos.ru/opendata/7710474791-dannye-vyzovov-pojarnoy-slujby-po-ao-goroda-moskvy%3FpageNumber%3D1%26versionNumber%3D1%26releaseNumber%3D19">number of calls of firefighters in a particular district of Moscow</a> in the future, and then check in a couple of months. <br><br>  In our case, I did not need to go far for data.  There is a wonderful opensource project Public Lab, in which there is a subsection devoted to the <a href="https://spectralworkbench.org/dashboard">analysis of the spectrum of light sources</a> . <br><br>  Two words about him: <br><br>  The project proposes to assemble a spectroscope from available tools ( <a href="https://publiclab.org/wiki/foldable-spec">well, for example, from cardboard and DVD discs</a> ) and photograph the spectra. <br><br>  After you take a bunch of spectra images, it would be good to study them in more detail. To do this, they have a web interface on the site that allows you to load and process your spectrum a bit to get a digital view of it (for example, as a table). . <br><br>  All data is in the public domain, anyone can either download the spectrum to the portal or download data.  This openness has one big flaw, which we will need to take into account, but about it a little later <i>(just decided to introduce intrigue into the story)</i> . <br><br>  There are many pictures on the portal, though it‚Äôs important to remember that among the pictures you don‚Äôt have to be the spectra of light bulbs, for example, there can be light reflectance spectra of materials or light transmission spectra of various liquids. <br><br>  In any case, we have visual open data that are unified, structured and most importantly can be downloaded in a convenient format (for example, .csv), what else can you dream of? <br><br>  <i>(except a million dollars and a personal helicopter)</i> <br><br><h3>  Part 3. You must think like a car, live like a car, you yourself must become a machine! </h3><br>  Consider the data that we have and what we want to get in the end. <br><br>  <i>Hereinafter I will focus on the files in the format csv</i> <br><br>  So we have the distribution of radiation power (conditional) along the wavelength of the spectrum ( <a href="https://en.wikipedia.org/wiki/Spectral_power_distribution">spectral distribution of radiation density</a> ). <br><br>  In the data downloaded from the Public Lab there is an average value as well as broken down by the R, G, B channels, we will only be worried about the average. <br><br>  If you just simplify the description, then when passing through a diffraction grating or prism, the light splits into a rainbow, and if sunlight gives you a rainbow, as in the saying about the pheasant, then the light of poor-quality fluorescent lamps may look like a hockey player Ovechkin‚Äôs smile <i>(certainly charming, but with some spaces)</i> . <br><br>  It is precisely on the basis of this structure of the rainbow that we will classify the spectra. <br><br>  Since all algorithms and libraries for machine learning are written by living people (for the time being), in many respects they are a formalization of those things that we often do unconsciously when solving certain tasks. <br><br>  On the one hand, the data set that I have compiled for you is very simple - the classes are balanced, the signs have a more or less close scale, there are no obvious emissions, so some things that they write in the training materials I cannot demonstrate to you on it. <br><br>  On the other hand, who knows, maybe we are all robots?  Therefore, I will cover a couple of points that would be important to note, as if we had written a model for collecting data instead of doing it manually. <br><br>  To begin, let us recall the important points that are often talked about and written in educational materials: <br><br>  <b>Knowledge of the specifics</b> <br><br>  In the training materials they write that for machine learning it is important to have knowledge of the field of activity for which we are preparing the model.  And with this I fully agree, it is not enough to know all the algorithms and methods, to be able to use libraries.  Ignorance of some nuances can cover your model with a copper basin and reduce its value to zero. <br><br>  Let's turn to our case.  Remember I talked about the BIG minus of the openness of the platform (with all its advantages).  So, people can pour in any photographs of the spectra taken on instruments of any quality, and then process them as they will enter the head. <br>  The most important point to consider is the correct calibration of the spectrum. <br><br>  The mechanism is as follows: you photograph a characteristic object (a compact fluorescent lamp) and on the basis of it you get a scale of your distribution (based on two peaks of blue and green). <br><br>  It doesn‚Äôt sound very difficult, but you need to tamper a little, firstly, not everyone speaks English, and secondly, not everyone likes to read the instructions, therefore, even now the mechanism has been simplified (by adding a sample), but there is still a risk stumble on an improperly calibrated spectra.  In the end, the spectra can be loaded by children and some of them can be hard to figure out on their own. <br><br>  Therefore, on the one hand, we have a lot of simply uncalibrated images, on the other hand, a certain amount of incorrectly calibrated ones, which is much worse. <br><br>  For example, there is a photo under it there is a graph like something more or less meaningful (without noise), but naturally this is an incorrect calibration (turquoise should be around 500 nm, and orange around 600 nm.) <br><br><img src="https://habrastorage.org/web/f11/e26/80b/f11e2680bee84a66897e20482934a622.png"><br><br>  This is not the worst example, there are cases where poor calibration is present, but it is much less striking, but I just did not find them without thinking. <br><br>  The second point is that we don‚Äôt really know which spectra (which lamps), under what conditions and what the users photographed them, so at least it‚Äôs important to know that you shouldn‚Äôt trust the data to 100%.  Sometimes some spectra are suspicious. <br><br>  The third point, it is important to remember about the technical limitations, in most cases, this measuring circuit strongly cuts spectra in the red range of light, therefore, for example, data beyond 600 nm.  may not be less reliable and not the fact that they will correspond to the true spectra.  The situation is similar with violet (ultraviolet) light. <br><br>  The fourth point, part of the radiation in the spectra can be cut off, due to the high brightness of the images, this distorts the data and sometimes it can also be important.  Maybe there are some other nuances that I did not remember or do not know.  So, without knowing even these trifles, it would be possible to make mistakes when preparing the samples. <br><br>  <b>Signs and data selection</b> <br><br>  Regarding the signs, let the radiation power for each wavelength be our feature for the future model. <br><br>  Considering the above, it becomes clear that for classifying us there is not much point in taking the spectrum, in the range that the system gives (sometimes almost from 200 to 1000 nm), take the range from 390 to 690 even this is a bit redundant (because everywhere there is this data), but we don‚Äôt seem to lose anything significant. <br><br>  We divide the signs in steps of 1 nm.  Well, for example, 400, 401, 402 ... It would be possible to take a step less often, for example, 10 nm., but we will have a small sample and even 301 signs will not overload our computer when calculating.  In theory, increasing the pitch reduces the accuracy of the model, but also drastically reduces the pitch, for example, to 0.25 nm.  we do not much weather, and machine resources will eat. <br><br>  <b>Concerning the selection of spectra</b> <br><br>  Initially I wanted to make a larger sample with a large number of classes, but it stalled, as I said before, not all spectral images could be used due to poor calibration, noise, or doubts about the reliability. <br><br>  Therefore, in the end, we limit ourselves to three classes: daylight (sky, sun or all together), fluorescent lamps (both compact and tubular), and LED lamps (white with phosphor and based on RGB LEDs). <br><br>  I hope that everything that I have gathered to you is shining with white light (of various shades and of different quality). <br><br>  When collecting data, the problem with poor data calibration for fluorescent lamps was easy to solve; it was enough to calibrate them yourself.  But with daylight and LED lamps such a trick will not work (there is often a smooth spectrum), well, at that time I did not find incandescent lamps (calibrated) in sufficient quantities, but new data are actively added there if you consider it necessary to expand the sample and make the task more interesting. <br><br>  To make it easier to classify as a result, I made the sample uniform.  In the training set of 30 records of each class, in the control sample of 11 records. <br><br>  And even though I was a little tired and confused at the end, the sample should contain examples of different light sources, different lamps, different LEDs, etc. <br><br>  In this case, I combed the sample for you, but in a real sample, you may have to process the data yourself. <br><br>  Another point about the sample. <br><br>  There is such a thing in statistics as errors of the first kind and second kind.  In a very simplified presentation: you hypothesize that there is paper in the toilet, which means you don‚Äôt take it with you, so if in this situation you insure and take a roll with you in vain (a false positive is a mistake of the first kind), then not as scary as if you don‚Äôt grab a roll, and there will only be a cardboard ring (a mistake of the second kind). <br><br>  So, when choosing data, I tried to minimize the error of the second kind, it was not very scary for us to skip the normal spectrum, but accidentally taking an erroneous spectrum into the sample is clearly not what we need. <br><br>  But when solving the classification problem directly, any of the errors does not have a higher priority; when it is solved directly by the model, it is important for us that everything is absolutely predicted correctly and without reinsurance. <br><br>  This is what determines the sufficiency of the metrics accuracy. <br><br><h3>  Part 4. T-800 and T-1000 </h3><br>  Well, there was a lot of text, let's finally move on closer to the model. <br><br>  At <a href="https://github.com/bosonbeard/ML_light_sources_classification/tree/master/1st_spectrum_classification">https://github.com/bosonbeard/ML_light_sources_classification/tree/master/1st_spectrum_classification</a> located: <br><br><ul><li>  Train.csv training sample file </li><li>  Test sample file test.csv </li><li>  Two documents with file names (cut out columns), they will be useful to you if you want to check me and yourself, you can simply take the file name by substituting it to the link, for example, <a href="https://spectralworkbench.org/spectrums/9740">spectralworkbench.org/spectrums/9740</a> (where 9740 is the file number) </li><li>  And the file spectrum_classify_for_habrahabr.ipynb in which is represented in its entirety, the code that we will now consider with you. </li></ul><br>  I mean that you already have basic knowledge and you will have enough of them to understand my code far from the reference. <br><br>  Import libraries: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.ensemble <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> RandomForestClassifier <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.linear_model <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> LogisticRegression <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GridSearchCV <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.model_selection <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> StratifiedKFold <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.preprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MinMaxScaler, StandardScaler <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.pipeline <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pipeline <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.decomposition <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PCA <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.manifold <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TSNE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.cluster <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> DBSCAN <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sklearn.metrics <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> accuracy_score <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> IPython.display <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> display %matplotlib inline</code> </pre> <br>  Read the data: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#reading data train_df=pd.read_csv('train.csv',index_col=0) test_df=pd.read_csv('test.csv',index_col=0) print('train shape {0}, test shape {1}]'. format(train_df.shape, test_df.shape)) #divide the data and labels X_train=np.array(train_df.iloc[:,:-1]) X_test=np.array(test_df.iloc[:,:-1]) y_train=np.array(train_df['label']) y_test=np.array(test_df['label'])</span></span></code> </pre><br>  In this case, we use the pandas library and its dataframe class, which, to put it simply, gives us the functions that Excel would give, that is, work with tables. <br><br>  As I said earlier, in table 391 the column corresponds to the radiation power by wavelength, and the last column is the class label: 0 - LED, 1 - lum.  lamps.  2 - daylight. <br><br>  For further work, we immediately cut out 391 columns with signs and the last columns with labels into separate variables. <br><br>  In normal work, a decent analysis of the initial data usually goes on, but we have nothing to analyze, as I said, all classes are balanced and, in principle, do not need much additional scaling (although you can scale it out of curiosity). <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#draw classdistributions fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(12,5)) train_df.label.plot.hist(ax=axes[0],title='train data class distribution', bins=5,xticks=np.unique(train_df.label.values)) test_df.label.plot.hist(ax=axes[1],title='test data class distribution',bins=5,xticks=np.unique(test_df.label.values))</span></span></code> </pre><br>  For the sake of form, I derived 2 graphics, if you want you can do something else. <br><br><img src="https://habrastorage.org/web/8a7/319/364/8a73193642ac4b42835f1e7af4638e33.png"><br><br>  <b>Classification</b> <br><br>  Let's build our first model.  Take one of the most popular models - the random forest model (decisive trees). <br><br><pre> <code class="python hljs">rfc = RandomForestClassifier(n_estimators=<span class="hljs-number"><span class="hljs-number">30</span></span>, max_depth=<span class="hljs-number"><span class="hljs-number">5</span></span>, random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>, n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>) rfc.fit(X_train, y_train) pred_rfc=rfc.predict(X_test) print(<span class="hljs-string"><span class="hljs-string">"results (predict, real): \n"</span></span>,list(zip(pred_rfc,y_test))) print(<span class="hljs-string"><span class="hljs-string">"accuracy score= {0}"</span></span>.format(rfc.score(X_test,y_test)))</code> </pre><br>  Let's see the results. <br>  (predicted, actual): <br><br>  (2, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (1, 0), (0, 0), (2 , 0), (2, 0), (2, 0), (1, 1), (1, 1), (1, 1), (1, 1), (0, 1), (1, 1 ), (1, 1), (1, 1), (1, 1), (1, 1), (1, 1), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2) <br><br>  Accuracy prediction (share of correct answers) = 0.8181818181818182 <br><br>  It turns out we can hope that our model will be 8 out of 10 spectra correctly classified, which is already good. <br><br>  For the demonstration, we specifically took the best parameters for this model, let's try to sort through models with different parameters and select the best one based on the results of cross-checking. <br><br><pre> <code class="python hljs">%%time param_grid = {<span class="hljs-string"><span class="hljs-string">'n_estimators'</span></span>:[<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>], <span class="hljs-string"><span class="hljs-string">'max_depth'</span></span>:[<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>]} grid_search_rfc = GridSearchCV(RandomForestClassifier(random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>,n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>), param_grid, cv=<span class="hljs-number"><span class="hljs-number">7</span></span>) grid_search_rfc.fit(X_train, y_train) print(grid_search_rfc.best_params_,grid_search_rfc.best_score_) print(<span class="hljs-string"><span class="hljs-string">"best accuracy on cv: {:.2f}"</span></span>.format(grid_search_rfc.best_score_)) print(<span class="hljs-string"><span class="hljs-string">"accuracy on test data: {:.5f}"</span></span>.format(grid_search_rfc.score(X_test, y_test))) print(<span class="hljs-string"><span class="hljs-string">"best params: {}"</span></span>.format(grid_search_rfc.best_params_)) print(<span class="hljs-string"><span class="hljs-string">"results (predict, real): \n"</span></span>,list(zip(grid_search_rfc.best_estimator_.predict(X_test),y_test)))</code> </pre><br>  We get the following parameters: <br><br>  {'max_depth': 6, 'n_estimators': 30} 0.766666666667 <br>  best accuracy on cv: 0.77 <br>  accuracy on test data: 0.87879 <br>  best params: {'max_depth': 6, 'n_estimators': 30} <br><br>  (predicted, actual): <br><br>  [(0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), (0, 0), ( 2, 0), (2, 0), (2, 0), (1, 1), (1, 1), (1, 1), (1, 1), (0, 1), (1, 1), (1, 1), (1, 1), (1, 1), (1, 1), (1, 1), (2, 2), (2, 2), (2, 2) , (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2)] <br>  Wall time: 1min 6s <br><br>  That is, an increase of max_depth by 1 improves accuracy by 6%, which is not bad, despite the fact that the model with the number of trees (n_estimators), like ‚Äúyou will not spoil the porridge with oil,‚Äù the model decided that it is not worth further increasing their number (this saves resources). <br><br>  I think you can achieve better results if you search for more parameters (or increase the sample size), but in order to demonstrate that the calculation does not take much time, we will limit ourselves to what it is. <br><br>  So, you and I can start with our more advanced T-1000, so let's try to force something to classify our ‚ÄúIron Arnie‚Äù as a simpler <b>Logistic Regression</b> model. <br><br><pre> <code class="python hljs">logreg = LogisticRegression(penalty=<span class="hljs-string"><span class="hljs-string">'l2'</span></span>,random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>, C=<span class="hljs-number"><span class="hljs-number">1</span></span>, n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>) logreg.fit(X_train, y_train) pred_logreg = logreg.predict(X_test) print(<span class="hljs-string"><span class="hljs-string">"results (predict, real): \n"</span></span>,list(zip(pred_logreg,y_test))) print(<span class="hljs-string"><span class="hljs-string">"accuracy score= {0}"</span></span>.format(logreg.score(X_test,y_test)))</code> </pre><br>  As one would expect, the simpler model from the first approach gave a little worse result. <br><br>  results (predict, real): <br>  [(0, 0), (0, 0), (0, 0), (2, 0), (0, 0), (0, 0), (0, 0), (2, 0), ( 0, 0), (0, 0), (2, 0), (1, 1), (1, 1), (1, 1), (1, 1), (2, 1), (2, 1), (1, 1), (1, 1), (1, 1), (1, 1), (2, 1), (2, 2), (2, 2), (2, 2) , (0, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2)] <br>  accuracy score = 0.7878787878787878 <br><br>  We can play again with the parameters: <br><br><pre> <code class="python hljs">%%time param_grid = {<span class="hljs-string"><span class="hljs-string">'C'</span></span>:[<span class="hljs-number"><span class="hljs-number">0.00020</span></span>, <span class="hljs-number"><span class="hljs-number">0.0020</span></span>, <span class="hljs-number"><span class="hljs-number">0.020</span></span>, <span class="hljs-number"><span class="hljs-number">0.20</span></span>, <span class="hljs-number"><span class="hljs-number">1.2</span></span>], <span class="hljs-string"><span class="hljs-string">'penalty'</span></span>:[<span class="hljs-string"><span class="hljs-string">'l1'</span></span>,<span class="hljs-string"><span class="hljs-string">'l2'</span></span>]} grid_search_logr = GridSearchCV(LogisticRegression(random_state=<span class="hljs-number"><span class="hljs-number">42</span></span>,n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>), param_grid, cv=<span class="hljs-number"><span class="hljs-number">3</span></span>) grid_search_logr.fit(X_train, y_train) print(<span class="hljs-string"><span class="hljs-string">"best accuracy on cv: {:.2f}"</span></span>.format(grid_search_logr.best_score_)) print(<span class="hljs-string"><span class="hljs-string">"accuracy on test data: {:.5f}"</span></span>.format(grid_search_logr.score(X_test, y_test))) print(<span class="hljs-string"><span class="hljs-string">"best params: {}"</span></span>.format(grid_search_logr.best_params_)) print(<span class="hljs-string"><span class="hljs-string">"results (predict, real): \n"</span></span>,list(zip(grid_search_logr.best_estimator_.predict(X_test),y_test)))</code> </pre><br>  Results: <br><br>  best accuracy on cv: 0.79 <br>  accuracy on test data: 0.81818 <br>  best params: {'C': 0.02, 'penalty': 'l1'} <br>  (predicted, actual): <br>  [(0, 0), (0, 0), (0, 0), (2, 0), (0, 0), (0, 0), (0, 0), (0, 0), ( 0, 0), (0, 0), (2, 0), (1, 1), (1, 1), (1, 1), (1, 1), (2, 1), (2, 1), (1, 1), (1, 1), (1, 1), (1, 1), (2, 1), (2, 2), (2, 2), (2, 2) , (0, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2), (2, 2)] <br>  Wall time: 718 ms <br><br>  So, we have achieved a quality comparable to Random forest without fitting the parameters, but we have spent significantly less time.  It is seen precisely for this reason in the books they write that logistic regression is often used at the preliminary stages, when it is important to identify general patterns, and 5-7% of the weather will not be done right away. <br><br>  On the one hand, this could be the end, but let's also try to imagine that I, as a dishonest person, gave you data without any description and you need to try to understand something without having class marks. <br><br>  <b>Clustering</b> <br><br>  For clarity, let's set the colors.  I'm still a little cunning, in an amicable way, ‚Äúwe don‚Äôt know‚Äù that we have no more than three classes, but we really do know that, so we‚Äôll confine ourselves to three colors. <br><br><pre> <code class="python hljs">colors = [<span class="hljs-string"><span class="hljs-string">"#476A2A"</span></span>, <span class="hljs-string"><span class="hljs-string">"#535D8E"</span></span>, <span class="hljs-string"><span class="hljs-string">"#BD3430"</span></span>]</code> </pre> <br>  To begin with, we will try to look at our data, we have almost 400 signs and on the two-dimensional sheet of paper all of them probably will not be able to be displayed even by great magicians and wizards Amayak Hakobyan and Harry Potter, but thank God we have the magic of special libraries. <br><br>  To begin with, we will use the popular T-SNE algorithm (who is curious what it is, you can <a href="https://habrahabr.ru/post/267041/">read it here</a> ). <br><br>  The main thing for us is that the algorithm displays our data in a two-dimensional plane, and if, in reality, the data are well separable, then in a two-dimensional form they will also be well separable (it will be possible to draw lines and accurately divide the groups). <br><br>  Unfortunately, everything is not so good here.  Somewhere the data is grouped, but somewhere and mixed. <br><br>  And in principle, this is normal, again, we all <b>know the specifics of the issue</b> , which means that we <b>guess</b> that if the lamps are good, then in their own light they will look like real daylight, and therefore it is <b>difficult to separate the</b> data. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#T-SNE tsne = TSNE(random_state=42) d_tsne = tsne.fit_transform(X_train) plt.figure(figsize=(10, 10)) plt.xlim(d_tsne[:, 0].min(), d_tsne[:, 0].max() + 10) plt.ylim(d_tsne[:, 1].min(), d_tsne[:, 1].max() + 10) for i in range(len(X_train)): #  ,       plt.text(d_tsne[i, 0], d_tsne[i, 1], str(y_train[i]), color = colors[y_train[i]], fontdict={'weight': 'bold', 'size': 10}) plt.xlabel("t-SNE feature 0") plt.ylabel("t-SNE feature 1")</span></span></code> </pre><br><img src="https://habrastorage.org/web/2d3/6e2/80a/2d36e280a61d4b7d8920a1fbac5b273a.png"><br><br>  For safety, let's look at the results of the PCA algorithm ( <a href="https://habrahabr.ru/post/304214/">more details here</a> ). <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#PCA pca = PCA(n_components=2, random_state=42) pca.fit_transform(X_train) d_pca = pca.transform(X_train) plt.figure(figsize=(10, 10)) plt.xlim(d_pca[:, 0].min(), d_pca[:, 0].max() + 130) plt.ylim(d_pca[:, 1].min(), d_pca[:, 1].max() + 30) for i in range(len(X_train)): #  ,       plt.text(d_pca[i, 0], d_pca[i, 1], str(y_train[i]), color = colors[y_train[i]], fontdict={'weight': 'bold', 'size': 10}) plt.xlabel("1-st main comp.") plt.ylabel("2-nd main comp.")</span></span></code> </pre><br>  The results are similar. <br><br><img src="https://habrastorage.org/web/146/609/8bc/1466098bc2ec4f99933c919f7a6d8886.png"><br><br>  Well, now let's do direct clustering, there are a lot of algorithms, but for this example we will use the <b>DBSCAN</b> algorithm ( <a href="https://habrahabr.ru/post/322034/">details</a> ). <br><br>  This algorithm does not require to set the initial number of classes and in some cases allows you to guess well, but running ahead, we remember the pictures from above?  In our case it will be difficult.  Here is a DBSCAN variant that finds three classes (2 or 4 possible). <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#scale data scaler = MinMaxScaler() scaler.fit(X_test) X_scaled = scaler.transform(X_test) #clustering with DBSCAN dbscan = DBSCAN(min_samples=2, eps=2.22, n_jobs=-1) clusters = dbscan.fit_predict(X_scaled) print("Affiliation to clusters:\n{}".format(clusters)) print("\n results (Clustering, real): \n",list(zip(clusters,y_test))) print("\n accuracy_score: \n",accuracy_score(clusters,y_test))</span></span></code> </pre><br>  Affiliation to clusters: <br>  [-1 -1 0 -1 -1 0 0 -1 1 1 -1 2 2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 <br>  -1 1 1 1 -1 1 -1 1] <br><br>  results (clustering, fact): <br>  [(-1, 0), (-1, 0), (0, 0), (-1, 0), (-1, 0), (0, 0), (0, 0), (-1 , 0), (1, 0), (1, 0), (-1, 0), (2, 1), (2, 1), (-1, 1), (-1, 1), ( -1, 1), (-1, 1), (-1, 1), (2, 1), (-1, 1), (2, 1), (-1, 1), (-1, 2), (1, 2), (-1, 2), (-1, 2), (1, 2), (1, 2), (1, 2), (-1, 2), (1 , 2), (-1, 2), (1, 2)] <br><br>  accuracy_score: <br>  0.0909090909091 <br><br>  We get a terrible accuracy value of about 9%.  Something is wrong!  Of course, DBSCAN does not know which labels we gave classes, so in our case 1 is 2 and vice versa (a -1 is noise). <br><br>  Change the class labels and get: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap_class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lst, number_one,number_two )</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" The function is exchanging num1 and num2 in list and return new array """</span></span> lst_new=[] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lst: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> val == number_one: val = number_two <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> val == number_two: val = number_one lst_new.append(val ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> np.array(lst_new) y_changed=swap_class(clusters, <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) print(<span class="hljs-string"><span class="hljs-string">"\n results (Clustering, real): \n"</span></span>,list(zip(y_changed,y_test))) print(<span class="hljs-string"><span class="hljs-string">"\n accuracy_score: \n"</span></span>,accuracy_score(y_changed,y_test))</code> </pre><br>  results (clustering, fact): <br>  [(-1, 0), (-1, 0), (0, 0), (-1, 0), (-1, 0), (0, 0), (0, 0), (-1 , 0), (2, 0), (2, 0), (-1, 0), (1, 1), (1, 1), (-1, 1), (-1, 1), ( -1, 1), (-1, 1), (-1, 1), (1, 1), (-1, 1), (1, 1), (-1, 1), (-1, 2), (2, 2), (-1, 2), (-1, 2), (2, 2), (2, 2), (2, 2), (-1, 2), (2 , 2), (-1, 2), (2, 2)] <br><br>  accuracy_score: <br>  0.393939393939 <br><br>  Another thing is already 39% which is still better than if we were classified in a random way.  That's all machine learning, but for patient people at the end of the article there will be a bonus. <br><br><h3>  Part 5. Conclusion </h3><br>  Well, we have traveled the hard way from setting the problem to solving it, we confirmed in practice some of the truths that are found in Data Science textbooks. <br><br>  In fact, we didn‚Äôt necessarily have to be categorized by spectral distribution, it was possible to take derived attributes, for example, color rendering index and color temperature, but you can do it yourself if you want. <br><br>  It also certainly makes sense to add more data to the training and test sample, since the quality of training of the model is very strongly dependent on this (at least in this case, the difference between the sample of 20 and 30 samples was significant). <br><br>  What do you do with your research when you do it?  Well first, you can write an article on Habr :) <br><br>  And you may not be limited to Habrom, I remember 4 years ago I wrote an article, <a href="https://habrahabr.ru/post/184894/">‚ÄúHow to stop being a‚Äú blogger ‚Äùand feel like a‚Äú scientist ‚Äù</a> . <br><br>  Its meaning was that you can not stop at what has been achieved, as a rule, if you are able to write an article on Habr, then you can write to some scientific journal. <br>  What for?  Yes, simply because you can!  This situation is similar to the game of football, in the RFPL there are about 200 domestic footballers (this is from the ceiling, but I think not much more), and even less of our people play abroad, but in general much more people play football across the country. <br><br>  After all, there are amateur leagues.  Lovers do not get paid, and often play for fun.  So here I invite you to play in the "amateur" scientific league. <br><br>  In our case, if you do not have access to standing international journals, or at least VAK, do not be discouraged, even after the collapse of the RISC, there are places where your good article will be completely accepted, if you observe the formalities and scientific style of presentation, for example, at one of the conferences included in the <a href="https://moluch.ru/conf/">RSCI</a> , it is usually a pleasure to pay, but very budget. <br>  It will be even more useful to participate in the in-person <a href="http://mgsu.ru/science/Nauchniye_meropr/Novosti/">conference</a> , where you will have to defend your idea live. <br><br>  Who knows, maybe one day you will put your hand in your mouth and become our new hope for humanity. <br><br>  There is another use for your talents, you can analyze the data of budget structures and participate in public control, for sure if you dig deeper, there are obvious shoals in the accounts of dishonest people and organizations, and you can make our home better (or not) <br><br>  Or maybe you will find some more wonderful use of your hobby and wrap it in income, everything is in your hands. <br><br><h3>  Bonus  Manual forecast </h3><br>  Do not you think that the article remained a little understatement?  Something is missing?  Well, of course it is necessary to conduct an epic human-machine battle! <br><br>  Let's see who better classifies the spectra. <br><br>  Since I do not have this magic cat that guesses everything, I will have to do everything myself. <br><br><img src="https://habrastorage.org/web/869/5c8/448/8695c8448ec34ba5a72929ecb07681cf.png"><br><br>  We write for this a small function.  And build graphs for which I will predict. <br><br>  <i>Note</i>  <i>I cannot vouch for the quality of the code</i> <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_spec_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" the function takes a DataFrame and returns in random order the x-coordinate (wavelength), the power values for all light sources (the y-axis), and the matching to the original DataFrame positions. Use it for manual prediction. """</span></span> x=data.columns.values[:<span class="hljs-number"><span class="hljs-number">-1</span></span>] data_y=data.values y=list() pos=list() rows_count=data_y.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] index=range(<span class="hljs-number"><span class="hljs-number">0</span></span>,rows_count+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> rows_count&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>: rows_count=data_y.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>] i=np.random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>,data_y.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]) y.append(data_y[i][:<span class="hljs-number"><span class="hljs-number">-1</span></span>]) pos.append(index[i]) data_y=np.delete(data_y, i, <span class="hljs-number"><span class="hljs-number">0</span></span>) index=np.delete(index, i, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#print (len(data_y,)) return x, y, pos def get_match_labels(human_labels, pos_in_data_lebels): """ The function returns a match between the random data and the original DataFrame """ match=np.zeros(len(human_labels)) for h,p in zip (human_labels, pos_in_data_lebels): match[p]=h return match</span></span></code> </pre> <br>  By the way, here is another reference to the man-machine comparison from the 2nd chapter.  Frankly, I usually determine the spectra with a photograph of the spectrum and the graph itself at hand, and then the accuracy exceeds 90 and is nearing 100%, but we didn‚Äôt give spectra pictures to our model, which means we will have to be on equal terms with it. <br><br>  This situation is somewhat similar to the one when you are training a model on one set of attributes, and then in real data (or control) some of the signs are missing and the predictive power of the model is greatly reduced (mine has also decreased). <br><br>  And so take my word for it (or run. Ipynb file with GitHub) we get 33 graphics from the control sample, like these: <br><br><img src="https://habrastorage.org/web/5c9/cbb/f25/5c9cbbf25b2f4aefb202562fd1da723e.png"><br><br>  Then we manually enter the forecast, return the order order of the labels and see what happens. <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># my prediction, as an example man_ped=[0,1,2,0,1,1,2,0,0,1,0,1,1,2,0,0,2,1,1,0,1,1,0,0,0,0,1,2,1,0,2,0,2] man_pred_trans=get_match_labels(man_ped, pos) print("results (predict, real): \n",list(zip(man_pred_trans,y_test))) print("accuracy score= {0}".format(accuracy_score(man_pred_trans,y_test)))</span></span></code> </pre> <br>  Result (my prediction, fact.): <br><br>  [(0.0, 0), (0.0, 0), (0.0, 0), (1.0, 0), (0.0, 0), (0.0, 0), (0.0, 0), (0.0, 0), ( 0.0, 0), (0.0, 0), (0.0, 0), (1.0, 1), (1.0, 1), (1.0, 1), (1.0, 1), (1.0, 1), (1.0, 1), (1.0, 1), (1.0, 1), (1.0, 1), (1.0, 1), (1.0, 1), (0.0, 2), (2.0, 2), (2.0, 2) , (2.0, 2), (2.0, 2), (2.0, 2), (0.0, 2), (0.0, 2), (2.0, 2), (2.0, 2), (0.0, 2)] <br>  accuracy score = 0.8484848484848485 <br><br>  Of course, I am biased, at least because I know that there are no more than 11 labels in each class in the control sample, but I tried not to cheat. <br><br>  So, in my first attempt, I got 84% with a little, something between a logistic regression and Random Forest, and the computer went around me in the last position. <br><br>  Remember at the beginning of the article I mentioned that some of the spectra can be cut off?  It was precisely this that let me down, without a photo, I didn‚Äôt notice it and incorrectly classified the cut spectrum only according to the schedule, but the computer coped and got its 87%. <br><br>  If we consider that I have not shone this skill of determining spectra by eye for more than one day, and the model has been trained for a minute or so, then perhaps it‚Äôs time to fear the uprising of the machines? <br><br><img src="https://habrastorage.org/web/d86/48f/e50/d8648fe507f04fecb1a1ac07932c9892.jpg"></div><p>Source: <a href="https://habr.com/ru/post/337040/">https://habr.com/ru/post/337040/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337028/index.html">Bayes Summer | Deep | Bayes Summer School Materials in In-Depth Learning</a></li>
<li><a href="../337030/index.html">How recursion works - explanation in flowcharts and video</a></li>
<li><a href="../337034/index.html">Call for free using ENUMER blockchain service</a></li>
<li><a href="../337036/index.html">Wolfenstein 3D pixel-by-pixel fill</a></li>
<li><a href="../337038/index.html">JavaScript scopes</a></li>
<li><a href="../337042/index.html">How JS Works: Overview of the Engine, Runtime Mechanisms, Call Stack</a></li>
<li><a href="../337044/index.html">We write GraphQL API server on Yii2 with a client on Polymer + Apollo. Part 2. Client</a></li>
<li><a href="../337046/index.html">We write GraphQL API server on Yii2 with a client on Polymer + Apollo. Part 3. Mutations</a></li>
<li><a href="../337048/index.html">Sir, your team is not a team</a></li>
<li><a href="../337050/index.html">Nuxt.js: 28 kilobytes good for web developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>