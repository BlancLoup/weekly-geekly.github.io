<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FP on Scala: Invariant Functor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article discusses 


- As such an abstraction of category theory as an invariant functor (Invariant Functor), which is sometimes called an Exponen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FP on Scala: Invariant Functor</h1><div class="post__text post__text-html js-mediator-article">  The article discusses <br><ul><li>  As such an abstraction of category theory as an <b>invariant functor</b> (Invariant Functor), which is sometimes called an Exponential Functor, is expressed in Scala. </li><li>  Two rules ( <b>Identity Law</b> , <b>Composition Law</b> ), which each invariant functor is supposed to follow. </li><li>  An example of an <b>invariant state functor</b> (Value Holder) is given. </li><li>  An example of an <b>invariant functor-relation</b> between elements of a set (semigroup) is given. </li></ul><br>  The publication is a continuation of <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">FP on Scala: What is a functor?</a>  which addressed the following issues <br><ul><li>  What is the relationship between <b>category theory</b> , <b>Haskell</b> and <b>Scala</b> . </li><li>  What is a <b>covariant functor</b> . </li><li>  What is a <b>contravariant functor</b> . </li></ul><br>  Content <br><ul><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/267087/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/267087/">What is Invariant Functor?</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/267087/">Invariant Functor - Identity Law</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/267087/">Invariant Functor - Composition Law</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/267087/">Example # 1: Value Holder</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/267087/">Example # 2: Semigroup</a> </li><li>  <a href="http://habrahabr.ru/company/golovachcourses/blog/267087/">Invariant functor in libraries</a> </li></ul><br><a name="habracut"></a><br>  If you want to immerse yourself in the world of Scala, mathematics and functional programming - try the online course <a href="https://www.udemy.com/scala-for-java-developers-ru/%3FcouponCode%3DHABR-INVARIANT-FUNCTOR">Scala for Java Developers</a> (video + tests, for only 25% of the price! The number of reference coupons is limited!). <br><br><a name="0"></a><br><h3>  Introduction </h3><br>  Let me remind you of the main points of the <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">previous article</a> : <br><ul><li>  There is no need to know category theory to understand categorical abstractions within the framework of functional programming.  Moreover, category theory does not give good examples. </li><li>  Implementations of categorical abstractions in Scala came from Haskell.  It is useful to be able to read the source code of a more mature Haskell, in order to recruit examples for a younger Scala. </li><li>  The main categorical libraries ( <a href="https://github.com/scalaz/scalaz">Scalaz</a> , <a href="https://github.com/non/cats">Cats</a> ) use <b>generics of higher kind</b> to express categorical abstractions.  However, this language mechanism (which is not present in either Java or C #) is used to construct reusable abstractions.  "Piece" idioms can be implemented with minimal means. </li><li>  A covariant functor is a data source. </li><li>  A contravariant functor is a data receiver. </li></ul>  . <br>  But still, the author <b>strongly recommends</b> reading the <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">previous article</a> . <br><br><a name="10"></a><br><h3>  What is Invariant Functor? </h3><br>  An invariant functor is a covariant and contravariant ‚Äúin one bottle‚Äù functor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the form of a signature, this can be expressed as follows. <br><pre><code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invariant</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xmap</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>, g: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Invariant</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] }</code> </pre> <br>  That is, to obtain a new invariant functor, we need to provide the mappings required by both the covariant functor ( <b>f: T =&gt; R</b> ) and contravariant ( <b>g: R =&gt; T</b> ). <br><br>  Or graphically <br><pre>      + --------------------------------------- +
    R |  T + ------ + T |  R 
   -----&gt; f: R =&gt; T -----&gt; C [T] -----&gt; g: T =&gt; R -----&gt;
      |  + ------ + |
      + --------------------------------------- +
</pre><br><br>  That is, ‚Äútranslated‚Äù <b>Invariant [R] is</b> ‚Äúreduced‚Äù to the original <b>Invariant [T]</b> using a pair of mutually inverse transformations <b>f</b> and <b>g</b> that ‚Äúwait‚Äù for the data ‚Äúat the input‚Äù and ‚Äúat the output‚Äù. <br><br><a name="11"></a><br><h3>  Invariant Functor - Identity Law </h3><br>  Invariant Functor (along with Covariant Functor and Contravariant Functor) is also obliged to follow a couple of similar rules.  And the first rule (Identity Law) says: for any invariant functor <b>fun [T]</b> , IdentityLaw.case0 (fun) must be identically equal to IdentityLaw.case1 (fun). <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IdentityLaw</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case0</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Invariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Invariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = fun <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case1</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Invariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>]): <span class="hljs-type"><span class="hljs-type">Invariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] = fun.xmap(x =&gt; x, x =&gt; x) }</code> </pre><br>  The meaning of the rule becomes clear if you turn to the meaning of the <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Identity Law for the Covariant Functor</a> and the <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Identity Law for the Contravariant Functor</a> . <br><br><a name="12"></a><br><h3>  Invariant Functor - Composition Law </h3><br>  The second rule (Composition Law) says: for any invariant functor <b>fun [T]</b> and any functions <b>f1: T =&gt; R</b> , <b>g1: R =&gt; T</b> , <b>f2: R =&gt; Q</b> , <b>g2: Q =&gt; R</b> , CompositionLaw should be executed. case0 (fun, f1, g1, f2, g2) is identically equal to CompositionLaw.case1 (fun, f1, g1, f2, g2). <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositionLaw</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case0</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">Q</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Invariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], f1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>, g1: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>, f2: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Q</span></span>, g2: <span class="hljs-type"><span class="hljs-type">Q</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>): <span class="hljs-type"><span class="hljs-type">Invariant</span></span>[<span class="hljs-type"><span class="hljs-type">Q</span></span>] = fun.xmap(f1, g1).xmap(f2, g2) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">case1</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>, <span class="hljs-type"><span class="hljs-type">R</span></span>, <span class="hljs-type"><span class="hljs-type">Q</span></span>](fun: <span class="hljs-type"><span class="hljs-type">Invariant</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>], f1: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>, g1: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>, f2: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Q</span></span>, g2: <span class="hljs-type"><span class="hljs-type">Q</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>): <span class="hljs-type"><span class="hljs-type">Invariant</span></span>[<span class="hljs-type"><span class="hljs-type">Q</span></span>] = fun.xmap(f2 compose f1, g1 compose g2) }</code> </pre><br>  The meaning of the rule becomes clear if you turn to the meaning of the <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Composition Law for the Covariant Functor</a> and the <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">Composition Law for the Contravariant Functor</a> . <br><br><a name="20"></a><br><h3>  Example # 1: Value Holder </h3><br>  From the previous article, it follows that the covariant and contravariant functors are two ‚Äúcontainer half‚Äù (this is a metaphor, it is more accurate to consider the signature + rules).  So, if an invariant (exponential) functor is both, then for example you can take the simplest of the containers - value holder. <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Holder</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ self =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span></span>(arg: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xmap</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>, g: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Holder</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Holder</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span></span>(arg: <span class="hljs-type"><span class="hljs-type">R</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = self.put(g(arg)) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">R</span></span> = f(self.get) } }</code> </pre><br><br>  For example, value holder for strings. <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrHolder</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">var value: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = null</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Holder</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span></span>(arg: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = {value = arg} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = value }</code> </pre><br><br>  Demonstration <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-type"><span class="hljs-type">Integer</span></span>.parseInt(_, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> g: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-type"><span class="hljs-type">Integer</span></span>.toHexString <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s: <span class="hljs-type"><span class="hljs-type">Holder</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">StrHolder</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> k: <span class="hljs-type"><span class="hljs-type">Holder</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = s xmap (f, g) k put <span class="hljs-number"><span class="hljs-number">100500</span></span> println(k get) } &gt;&gt; <span class="hljs-number"><span class="hljs-number">100500</span></span></code> </pre><br>  We have an Int container, which stores them in a string hex format. <br><br>  Well, why do we need the simplest value holder?  We can increase its functionality in several directions. <br><ul><li>  You can attach data (version, put / get log, ...). </li><li>  You can intercept calls (for synchronization, logging of put / get calls, proxying to remote sources, ...). </li></ul><br>  <b>Note:</b> note that the rules of the invariant functor prevent the xmap operations from being counted, but not others (put, get)!  You can log in the internal state calls put / get / ..., but not xmap. <br>  <b>Task:</b> Implement this logic. <br><br><a name="21"></a><br><h3>  Example # 2: Semigroup </h3><br>  It is important to note that the covariant and contravariant functors are precisely the sources and receivers of data that work according to certain rules (Identity Law, Composition Law), and not the ‚Äúhalf container‚Äù.  We are not required to <b>store</b> data (make it part of our state), we just have to have their arguments and return values ‚Äã‚Äãof the methods.  But if we do not store them, then the put and get operations should ‚Äúbe performed simultaneously,‚Äù that is  we are looking for structures whose type parameter T is present in both the arguments and the return value. <br><br>  Our examples can be <b>not states, but processes</b> !  Note that what is a process (method) can express the relationship between elements). <br><br>  Let me remind you of the basic algebraic terminology (we need the simplest relations between the elements of a set that give an invariant functor. Quite simply, the simplest is, of course, an equivalence relation and order, but <a href="http://habrahabr.ru/company/golovachcourses/blog/266905/">according to the previous article</a> , they are contravariant functors). <br><br>  <b>A groupoid (groupoid)</b> is a set provided with a single binary operation (T # T =&gt; T, T is a type of elements of a groupoid, # is an operation symbol), which does not take it beyond the limits of the set. <br><br>  <b>A semigroup (semigroup)</b> is a groupoid whose operation is associative ((a # b) # c == a # (b # c) for all a, b, and c). <br><br>  <b>A monoid</b> is a semigroup with a neutral element (there exists an element 'e' such that a # e == e # a == a, for any a). <br><br><table><tbody><tr><th>  Set with operation </th><th>  Groupoid </th><th>  Semigroup </th><th>  Monoid </th></tr><tr><td>  Int and '+' </td><td>  + </td><td>  + </td><td>  + </td></tr><tr><td>  Int and '-' </td><td>  + </td><td>  - </td><td>  - </td></tr><tr><td>  Int and '*' </td><td>  + </td><td>  + </td><td>  + </td></tr><tr><td>  Int and '/' </td><td>  - </td><td>  - </td><td>  - </td></tr><tr><td>  String and '+' </td><td>  + </td><td>  + </td><td>  + </td></tr><tr><td>  String (without "") and '+' </td><td>  + </td><td>  + </td><td>  - </td></tr></tbody></table><br>  Remarks <br><ol><li>  Int cannot be divided by 0, ArithmeticException - the result is not Int. </li><li>  Addition and multiplication are associative, subtraction and division are not. </li><li>  For the Int semigroup, the neutral element is '0'. </li><li>  For the Int semigroup, by multiplication, the neutral element is '1'. </li><li>  In the concatenated strings, the neutral element is the empty string (""). </li></ol><br><br>  Imagine a semigroup (or groupoid, in Scala, checking the associativity cannot be carried to the compilation stage anyway) in the form of a trait, which is parameterized by the type of the element and contains its operation as a method <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Semi</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|+|</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">T</span></span>, y: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> }</code> </pre><br><br>  A semigroup is an invariant (exponential) functor. <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Semi</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ self =&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|+|</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">T</span></span>, y: <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xmap</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>](f: <span class="hljs-type"><span class="hljs-type">T</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">R</span></span>, g: <span class="hljs-type"><span class="hljs-type">R</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>): <span class="hljs-type"><span class="hljs-type">Semi</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Semi</span></span>[<span class="hljs-type"><span class="hljs-type">R</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|+|</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">R</span></span>, y: <span class="hljs-type"><span class="hljs-type">R</span></span>): <span class="hljs-type"><span class="hljs-type">R</span></span> = f(self |+| (g(x), g(y))) } }</code> </pre><br><br>  Express the semigroup of strings by concatenation <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SemiStr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Semi</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">]</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|+|</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">String</span></span>, y: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = x + y }</code> </pre><br><br>  Consider the transition from a semigroup of strings by concatenation to a <b>‚Äúsemigroup of integers by concatenation</b> <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SemiDemo10</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = _.toInt <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> g: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = _.toString <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-type"><span class="hljs-type">Semi</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SemiStr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-type"><span class="hljs-type">Semi</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = x xmap (f, g) println(y.|+|(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>)) } &gt;&gt; <span class="hljs-number"><span class="hljs-number">100500</span></span></code> </pre><br>  We constructed a semigroup in integers (Semi [Int]) in which the binary operation is reduced to the concatenation of string representations of the number in the decimal number system (100 | + | 500 =&gt; "100" | + | "500" =&gt; "100500" =&gt; 100,500). <br><br>  If the previous example is too banal, then look at the following <br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SemiDemo16</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> f: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-type"><span class="hljs-type">Integer</span></span>.parseInt(_, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> g: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-type"><span class="hljs-type">Integer</span></span>.toHexString <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-type"><span class="hljs-type">Semi</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SemiStr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-type"><span class="hljs-type">Semi</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = x xmap (f, g) println(y.|+|(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) } &gt;&gt; <span class="hljs-number"><span class="hljs-number">170</span></span></code> </pre><br>  We constructed a semigroup in integers (Semi [Int]) in which the binary operation reduces to the concatenation of string representations of a number <b>in hexadecimal</b> numbering system (10 | + | 10 =&gt; "A" | + | "A" =&gt; "AA" =&gt; 10 * 16 + 10 = 170).  It can be verified that such an operation on Int is still associative (we ignore the case of int overflow and negative numbers, sorry). <br><br>  <a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/InvariantFunctor.scala">In the Scalaz library, they also believe that a semigroup and a monoid are invariant functors</a> . <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> scalaz <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InvariantFunctor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** Semigroup is an invariant functor. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> semigroupInvariantFunctor: <span class="hljs-type"><span class="hljs-type">InvariantFunctor</span></span>[<span class="hljs-type"><span class="hljs-type">Semigroup</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">InvariantFunctor</span></span>[<span class="hljs-type"><span class="hljs-type">Semigroup</span></span>] {...} <span class="hljs-comment"><span class="hljs-comment">/** Monoid is an invariant functor. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> monoidInvariantFunctor: <span class="hljs-type"><span class="hljs-type">InvariantFunctor</span></span>[<span class="hljs-type"><span class="hljs-type">Monoid</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">InvariantFunctor</span></span>[<span class="hljs-type"><span class="hljs-type">Monoid</span></span>] {...} ... }</code> </pre><br><br><a name="30"></a><br><h3>  Invariant functor in libraries </h3><br>  The best way to learn Scala and FP is to read the source code of professionals on Scala and FP. <br><br>  <b>Scalaz</b> is the most popular and mature of libraries that implement abstractions from category theory.  In many ways, the design is taken from Haskell = <a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/InvariantFunctor.scala">scalaz</a> . <a href="https://github.com/scalaz/scalaz/blob/series/7.1.x/core/src/main/scala/scalaz/InvariantFunctor.scala">InvariantFunctor libraries</a> <br><br>  <b>Cats</b> is an attempt to re-implement categorical abstractions (which I did not like Scalaz - I do not know) = <a href="https://github.com/non/cats/blob/master/core/src/main/scala/cats/functor/Invariant.scala">cats.functor.Invariant</a> <br><br>  <b>Play JSON library</b> includes an <a href="https://github.com/playframework/playframework/blob/master/framework/src/play-functional/src/main/scala/play/api/libs/functional/Functors.scala%3Fsource%3Dc">invariant functor</a> , it is discussed <a href="http://stackoverflow.com/questions/21714825/create-writes-and-format-of-case-class/">here</a> and <a href="http://stackoverflow.com/questions/21990112/play-json-invariantfunctor">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/267087/">https://habr.com/ru/post/267087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267075/index.html">Parsing the Digit Recognizer Challenge Kaggle Competitions</a></li>
<li><a href="../267079/index.html">Isn't it time for relational databases to fall into the dustbin of history?</a></li>
<li><a href="../267081/index.html">The results of the contest for the design of Mail.Ru mailing app on Dribbble</a></li>
<li><a href="../267083/index.html">How to improve resiliency of billing: The experience of "Hydra"</a></li>
<li><a href="../267085/index.html">How to optimize the online store. Part 1. Automatic calling of incoming leads</a></li>
<li><a href="../267091/index.html">The evolution of network communication methods. Part I</a></li>
<li><a href="../267093/index.html">Microsoft has released a major update for Windows RT</a></li>
<li><a href="../267095/index.html">Nginx: protect url one-time password</a></li>
<li><a href="../267097/index.html">Deploy Nginx Flask Application Using Gunicorn</a></li>
<li><a href="../267099/index.html">Malware Odlanor specializes in compromising poker players</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>