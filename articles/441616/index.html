<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Educational program on the launch of Istio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Istio Service Mesh 


 We have been Namely for a year now as Istio. He then just left. The performance in the Kubernetes cluster dropped dramatically,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Educational program on the launch of Istio</h1><div class="post__text post__text-html js-mediator-article"><p> <a href=""><img src="https://habrastorage.org/webt/sh/m2/ja/shm2jainigjyhqewoqvi4cxdlg0.jpeg"></a> <br>  <em>Istio Service Mesh</em> </p><br><p>  We have been Namely for a year now as Istio.  He then just left.  The performance in the Kubernetes cluster dropped dramatically, we wanted distributed tracing, and we took Istio to run Jaeger and figure it out.  Service mesh is so cool to fit into our infrastructure that we decided to invest in this tool. </p><br><p>  I had to suffer, but we studied it far and wide.  This is the first post in the series where I will cover how Istio integrates with Kubernetes and what we learned about its work.  Sometimes we will wander into the technical jungle, but not very far.  Next will be more posts. </p><a name="habracut"></a><br><h3 id="chto-takoe-istio">  What is Istio? </h3><br><p>  Istio is a service mesh configuration tool.  It reads the Kubernetes cluster status and updates to the L7 proxy (HTTP and gRPC), which are implemented as sidecars in Kubernetes subsets.  These sidecar s are Envoy containers that read the configuration from the Istio Pilot API (and the gRPC service) and route traffic through it.  With the powerful L7 proxy under the hood, we can use metrics, traces, repeat logic, circuit breaker, load balancing, and canary deployments. </p><br><h3 id="nachnem-s-nachala-kubernetes">  Let's start from the beginning: Kubernetes </h3><br><p>  In Kubernetes, we create it under c using deployment or StatefulSet.  Or it may just be ‚Äúvanilla‚Äù under without a high level controller.  Then Kubernetes struggles to maintain the desired state - creates pods in the cluster on the node, makes sure that they are started and restarted.  When the sub is created, Kubernetes goes through the API life cycle, makes sure that every step will be successful, and only then finally creates a sub on the cluster. </p><br><p>  API Life Cycle Stages: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/dl/dc/t5/dldct5fzrxubc5c1z3zt2m7lchu.png"></a> <br>  <em>Thank you Banzai Cloud for the cool picture.</em> </p><br><p>  One of the stages is modifying the admission web scrolls.  This is a separate part of the life cycle in Kubernetes, where resources are customized before committing to the etcd repository ‚Äî the source of truth for the Kubernetes configuration.  And here Istio creates his magic. </p><br><h3 id="modificiruyuschie-vebhuki-dopuska">  Modifying webcam admissions </h3><br><p> When a sub is created (through <code>kubectl</code> or <code>Deployment</code> ), it goes through this life cycle, and modifying access webbooks change it before being released into the big world. </p><br><p>  During the installation of Istio, istio-sidecar-injector is added as a configuration resource for modifying webbucks: </p><br><pre> <code class="plaintext hljs">$ kubectl get mutatingwebhookconfiguration NAME AGE istio-sidecar-injector 87d</code> </pre> <br><p>  And configuration: </p><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: labels: app: istio-sidecar-injector chart: sidecarInjectorWebhook-1.0.4 heritage: Tiller name: istio-sidecar-injector webhooks: - clientConfig: caBundle: redacted service: name: istio-sidecar-injector namespace: istio-system path: /inject failurePolicy: Fail name: sidecar-injector.istio.io namespaceSelector: matchLabels: istio-injection: enabled rules: - apiGroups: - "" apiVersions: - v1 operations: - CREATE resources: - pods</code> </pre> <br><p>  It says that Kubernetes should send all the events of the creation of podov to the <code>istio-sidecar-injector</code> in the <code>istio-system</code> , if the namespace has the label <code>istio-injection=enabled</code> .  The injector includes two more containers in the PodSpec: one temporary for setting proxy rules and one for proxying itself.  The sidecar injector inserts these containers in a pattern from the <code>istio-sidecar-injector</code> configuration map.  This process is also called sidecaring. </p><br><h3 id="sidecar-pody">  Sidecar pods </h3><br><p>  Sidecar's are the tricks of our magician Istio.  Istio turns it up so cleverly that it‚Äôs magic from the side, if you don‚Äôt know the details.  And to know them is useful if you suddenly need to debug network requests. </p><br><h3 id="init--i-proksi-konteynery">  Init and Proxy Containers </h3><br><p>  In Kubernetes there are temporary one-time init-containers that can be run up to the main ones.  They combine resources, transfer databases, or, as is the case with Istio, set up network rules. </p><br><p>  Istio uses Envoy to proxy all requests to feeds to the right routes.  For this, Istio creates <code>iptables</code> rules, and they send inbound and outbound traffic directly to Envoy, and it carefully proxies traffic to the destination.  Traffic makes a little detour, but you have distributed tracing, query metrics, and policy enforcement.  In this file from the Istio repository, you <a href="">can see</a> how Istio creates iptables rules. </p><br><p>  <a href="">@jimmysongio</a> drew an excellent communication scheme between iptables rules and Envoy proxy: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/yl/3m/yc/yl3myca7qv4esodpj8a7iwsp6bc.jpeg"></a> <br>  <em>Traffic Envoy ‚Äì Envoy</em> </p><br><p>  Envoy receives all incoming and all outgoing traffic, so all traffic generally moves inside Envoy, as in the diagram.  Istio Proxy is another container that is added to all pods modified by the Istio sidecar-injector.  This container starts the Envoy process, which receives all traffic from the pod (with some exceptions, such as traffic from your Kubernetes cluster). </p><br><p>  The Envoy process detects all routes through the Envoy v2 API, which implements Istio. </p><br><h3 id="envoy-i-pilot">  Envoy and Pilot </h3><br><p>  Envoy itself has no logic to detect the flows and services in the cluster.  This is a data plane and it needs a control plane to guide.  The Envoy configuration parameter requests the service host or port to obtain this configuration via the gRPC API.  Istio, through its Pilot service, fulfills the requirements for the gRPC API.  Envoy connects to this API based on the sidecar configuration implemented through the modifying webhook.  The API has all the traffic rules Envoy needs to discover and route to the cluster.  This is the service mesh. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/lr/kn/bz/lrknbzkkjqescnkyh6k1voy_nyk.png"></a> <br>  <em>Data exchange "under &lt;-&gt; Pilot"</em> </p><br><p>  Pilot connects to the Kubernetes cluster, reads the cluster status and waits for updates.  He keeps track of the bogs, services and endpoints in the Kubernetes cluster, to then give the desired configuration to all Envoy sidecar-am connected to the Pilot.  This is the bridge between Kubernetes and Envoy. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/fg/no/hj/fgnohjdngxbyn8kj5u_udcvl6x0.png"></a> <br>  <em>From Pilot to Kubernetes</em> </p><br><p>  When pods, services, or endpoints are created or updated in Kubernetes, Pilot finds out about it and sends the desired configuration to all connected Envoy instances. </p><br><h3 id="kakaya-konfiguraciya-otpravlyaetsya">  What configuration is sent? </h3><br><p>  What configuration does Envoy get from Istio Pilot? </p><br><p>  By default, Kubernetes solves your network issues using a <code>sevice</code> (service) that controls the <code>endpoint</code> .  The list of endpoints can be opened with the command: </p><br><pre> <code class="plaintext hljs">kubectl get endpoints</code> </pre> <br><p>  This is a list of all IP and ports in the cluster and their addressees (usually these are created from the deployment).  Istio is important to know in order to configure and send route information to Envoy. </p><br><h3 id="servisy-proslushivateli-i-marshruty">  Services, listeners and routes </h3><br><p>  When you create a service in a Kubernetes cluster, you enable shortcuts, which will select all suitable scams.  When you send traffic to an IP service, Kubernetes selects for this traffic.  For example, the command </p><br><pre> <code class="plaintext hljs">curl my-service.default.svc.cluster.local:3000</code> </pre> <br><p>  will first find the virtual IP assigned to the <code>my-service</code> in the <code>default</code> namespace, and this IP will forward the traffic to that which corresponds to the service label. </p><br><p>  Istio and Envoy slightly change this logic.  Istio configures Envoy based on services and endpoints in the Kubernetes cluster and uses Envoy's smart routing and load balancing features to bypass the Kubernetes service.  Instead of proxying one IP, the Envoy connects directly to the IP hearth.  <strong>To do this, Istio compares the Kubernetes configuration with the Envoy configuration</strong> . </p><br><p>  The terms Kubernetes, Istio and Envoy are slightly different, and it is not immediately clear what they eat with. </p><br><h3 id="servisy">  Services </h3><br><p>  The service in Kubernetes is mapped to a <strong>cluster</strong> in Envoy.  The Envoy cluster contains a list of <strong>endpoints</strong> , that is, the IP (or hostnames) of the instances to handle requests.  To see the list of clusters configured in the Istio sidecar sub-run, launch <code>istioctl proxy-config cluster &lt; &gt;</code> .  This command shows the current state of affairs in terms of presentation.  Here is an example from our environment: </p><br><pre> <code class="plaintext hljs">$ istioctl proxy-config cluster taxparams-6777cf899c-wwhr7 -n applications SERVICE FQDN PORT SUBSET DIRECTION TYPE BlackHoleCluster - - - STATIC accounts-grpc-gw.applications.svc.cluster.local 80 - outbound EDS accounts-grpc-public.applications.svc.cluster.local 50051 - outbound EDS addressvalidator.applications.svc.cluster.local 50051 - outbound EDS</code> </pre> <br><p>  All the same services are in this namespace: </p><br><pre> <code class="plaintext hljs">$ kubectl get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) accounts-grpc-gw ClusterIP 10.3.0.91 &lt;none&gt; 80/TCP accounts-grpc-public ClusterIP 10.3.0.202 &lt;none&gt; 50051/TCP addressvalidator ClusterIP 10.3.0.56 &lt;none&gt; 50051/TCP</code> </pre> <br><p>  How does Istio know which protocol uses the service?  Configures protocols for service manifests by the <code>name</code> field in the port entry. </p><br><pre> <code class="plaintext hljs">$ kubectl get service accounts-grpc-public -o yaml apiVersion: v1 kind: Service metadata: name: accounts-grpc-public spec: ports: - name: grpc port: 50051 protocol: TCP targetPort: 50051</code> </pre> <br><p>  If there is <code>grpc</code> or <code>grpc</code> prefix, Istio configures the HTTP2 protocol for the service.  We have learned the hard way how Istio uses the name of the port when we mess up the proxy configs because we didn‚Äôt specify http or grpc prefixes ... </p><br><p>  If you use kubectl and the admin port forwarding page in Envoy, you can see that account-grpc-public endpoints are implemented by Pilot as a cluster in Envoy with HTTP2 protocol.  This confirms our assumptions: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward otherpod-dc56885ff-dqc6t 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... - cluster: circuit_breakers: thresholds: - {} connect_timeout: 1s eds_cluster_config: eds_config: ads: {} service_name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local http2_protocol_options: max_concurrent_streams: 1073741824 name: outbound|50051||accounts-grpc-public.applications.svc.cluster.local type: EDS ...</code> </pre> <br><p>  Port 15000 is the <a href="https://www.envoyproxy.io/docs/envoy/latest/operations/admin">Envoy admin page</a> , available on every sidecar. </p><br><h3 id="proslushivateli">  Listeners </h3><br><p>  Listeners recognize Kubernetes endpoints to allow traffic to go.  The address verification service has one endpoint here: </p><br><pre> <code class="plaintext hljs">$ kubectl get ep addressvalidator -o yaml apiVersion: v1 kind: Endpoints metadata: name: addressvalidator subsets: - addresses: - ip: 10.2.26.243 nodeName: ip-10-205-35-230.ec2.internal targetRef: kind: Pod name: addressvalidator-64885ccb76-87l4d namespace: applications ports: - name: grpc port: 50051 protocol: TCP</code> </pre> <br><p>  Therefore, for checking the address one listener on port 50051: </p><br><pre> <code class="plaintext hljs">$ kubectl -n applications port-forward addressvalidator-64885ccb76-87l4d 15000:15000 &amp; $ curl http://localhost:15000/config_dump | yq r - ... dynamic_active_listeners: - version_info: 2019-01-13T18:39:43Z/651 listener: name: 10.2.26.243_50051 address: socket_address: address: 10.2.26.243 port_value: 50051 filter_chains: - filter_chain_match: transport_protocol: raw_buffer ...</code> </pre> <br><h3 id="marshruty">  Routes </h3><br><p>  In Istio, instead of the standard Kubernetes Ingress object, a more abstract and effective custom resource is <code>VirtualService</code> - <code>VirtualService</code> .  VirtualService maps routes to upstream clusters, tying them to the gateway.  This is how to use Kubernetes Ingress with an Ingress Controller. </p><br><p>  In Namely, we use the Istio Ingress-Gateway for all internal GRPC traffic: </p><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: grpc-gateway spec: selector: istio: ingressgateway servers: - hosts: - '*' port: name: http2 number: 80 protocol: HTTP2 --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: grpc-gateway spec: gateways: - grpc-gateway hosts: - '*' http: - match: - uri: prefix: /namely.address_validator.AddressValidator retries: attempts: 3 perTryTimeout: 2s route: - destination: host: addressvalidator port: number: 50051</code> </pre> <br><p>  At first glance, the example can not figure out anything.  It is not visible here, but the Istio-IngressGateway patch records which endpoints are needed, based on the <code>istio: ingressgateway</code> .  In this example, IngressGateway sends traffic for all domains on port 80 using HTTP2 protocol.  VirtualService implements the routes for this gateway, matches the <code>/namely.address_validator.AddressValidator</code> prefix and sends <code>/namely.address_validator.AddressValidator</code> to the upstream service via port 50051 with a retry rule after two seconds. </p><br><p>  If you redirect the Istio-IngressGateway port and see the Envoy configuration, we'll see what VirtualService does: </p><br><pre> <code class="plaintext hljs">$ kubectl -n istio-system port-forward istio-ingressgateway-7477597868-rldb5 15000 ... - match: prefix: /namely.address_validator.AddressValidator route: cluster: outbound|50051||addressvalidator.applications.svc.cluster.local timeout: 0s retry_policy: retry_on: 5xx,connect-failure,refused-stream num_retries: 3 per_try_timeout: 2s max_grpc_timeout: 0s decorator: operation: addressvalidator.applications.svc.cluster.local:50051/namely.address_validator.AddressValidator* ...</code> </pre> <br><h3 id="chto-my-guglili-kopayas-v-istio">  What we googled, digging in Istio </h3><br><p>  <strong>Error 503 or 404 occurs</strong> </p><br><p>  The reasons are different, but usually these are: </p><br><ul><li>  Sidecar-s of the application can not communicate with the Pilot (check that the Pilot is running). </li><li>  Incorrect protocol specified in the Kubernetes service manifest. </li><li>  The VirtualService / Envoy configuration records the route in the wrong upstream cluster.  Start with an edge service, where you expect incoming traffic, and examine the Envoy logs.  Or use something like Jaeger to find errors. </li></ul><br><p>  <strong>What does NR / UH / UF mean in Istio proxy logs?</strong> </p><br><ul><li>  NR - No Route. </li><li>  UH - Upstream Unhealthy (inoperative upstream). </li><li>  UF - Upstream Failure (upstream failure). </li></ul><br><p>  Read more <a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/access_log">on the Envoy website</a> . </p><br><p>  <strong>For high availability with Istio</strong> </p><br><ul><li>  Add NodeAffinity to Istio components to evenly distribute hearths across different availability zones and increase the minimum number of replicas. </li><li>  Launch a new version of Kubernetes with Horizontal Pod Autoscaling.  The most important scrolls will be scaled depending on the load. </li></ul><br><p>  <strong>Why is Cronjob not terminating?</strong> </p><br><p>  When the main workload is completed, the sidecar-container continues to work.  To work around the problem, disable sidecar in cronjobs by adding the <code>sidecar.istio.io/inject: ‚Äúfalse‚Äù</code> annotation in PodSpec. </p><br><p>  <strong>How to install Istio?</strong> </p><br><p>  We use Spinnaker for Deployments, but usually we take the latest Helm charts, conjure over them, use the <code>helm template -f values.yml</code> and commit the files in Github to see the changes before applying them through <code>kubectl apply -f -</code> .  This is in order not to accidentally change the CRD or API in different versions. </p><br><p>  Thanks to <a href="https://medium.com/%40bobbytables">Bobby Tables</a> and <a href="https://medium.com/%40mhamrah">Michael Hamrah</a> for help writing the post. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/441616/">https://habr.com/ru/post/441616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441602/index.html">Why a classic automatic car is impossible and has no commercial prospects</a></li>
<li><a href="../441604/index.html">China's national observation systems: a source of not only data, but also a steady income</a></li>
<li><a href="../441606/index.html">Almost reliable solutions</a></li>
<li><a href="../441608/index.html">Duality - easy and fast engine for igrostroya under Windows (Extras.)</a></li>
<li><a href="../441610/index.html">LED lies of unprecedented scale</a></li>
<li><a href="../441618/index.html">Creating a Bottom Navigation Bar at Kotlin using Anko</a></li>
<li><a href="../441620/index.html">Project "Prometheus": search for fires using AI</a></li>
<li><a href="../441626/index.html">Seminar on Industrial 3D Printing: March 1, at the Caliber Technopark</a></li>
<li><a href="../441628/index.html">Rating of IT employers in St. Petersburg and Moscow 2018: results of a survey of developers</a></li>
<li><a href="../441632/index.html">March 1 - Teamlead Meetup: on employee assessment and motivation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>