<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Top 20 errors when working with multithreading in C ++ and ways to avoid them</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I bring to your attention a translation of the article ‚ÄúTop 20 C ++ multithreading mistakes‚Äù by Deb Haldar. 


 Scene from the movie "The lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Top 20 errors when working with multithreading in C ++ and ways to avoid them</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I bring to your attention a translation of the article <a href="https://www.acodersjourney.com/top-20-cplusplus-multithreading-mistakes/">‚ÄúTop 20 C ++ multithreading mistakes‚Äù</a> by Deb Haldar. <br><br><img src="https://habrastorage.org/webt/wi/a8/4v/wia84vtxrf1vqym4rwoynnvtfw0.jpeg" title="KDPV.  Scene from the film ‚ÄúThe loop of time (2012)‚Äù"><br>  <i>Scene from the movie "The loop of time" (2012)</i> <br><br>  Multithreading is one of the most difficult areas in programming, especially in C ++.  Over the years of development I have made many mistakes.  Fortunately, most of them have been identified on code review and testing.  Nonetheless, some somehow skipped over to the productive, and we had to rule the exploited systems, which is always expensive. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article I tried to categorize all the errors that I know with possible solutions.  If you know any other pitfalls, or have suggestions for solving the described errors, please leave your comments below the article. <br><a name="habracut"></a><br><h3>  Error 1: Do not use join () to wait for background threads before terminating the application. </h3><br>  If you forget to join a stream ( <a href="https://en.cppreference.com/w/cpp/thread/thread/join">join ()</a> ) or <a href="https://en.cppreference.com/w/cpp/thread/thread/detach">detach</a> it ( <a href="https://en.cppreference.com/w/cpp/thread/thread/detach">detach ()</a> ) (make it not joinable) before the end of the program, this will lead to an abnormal termination.  (Translated words will be joined in the context of <i>join ()</i> and detached in the context of <i>detach ()</i> , although this is not entirely correct. In fact, <i>join ()</i> is the point at which one thread of execution waits until the end of the other, and no connection or union of threads occurs. [comment of the translator]). <br><br>  In the example below, we forgot to <i>join ()</i> the t1 stream in the main thread: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//t1.join(); //     join-     </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  Why did the program crash ?!  Because at the end of the <i>main ()</i> function, the variable t1 went out of scope and the thread destructor was called.  The destructor checks whether the stream t1 is <i>joinable</i> .  A thread is <i>joinable</i> if it has not been detached.  In this case, <a href="https://en.cppreference.com/w/cpp/error/terminate">std :: terminate</a> is called in its destructor.  This is what the MSVC ++ compiler does, for example. <br><br> <code>~thread <font color="#008000">(</font> <font color="#008000">)</font> _NOEXCEPT <br> <font color="#008000">{</font> <font color="#666666">// clean up</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> joinable <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> XSTD terminate <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  There are two ways to fix the problem depending on the task: <br><br>  1. Call <i>join () of</i> stream t1 in the main thread: <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//  join  t1,        </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  2. Detach the stream t1 from the main stream, allow it to continue working as a ‚Äúdemonized‚Äù stream: <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   t1   </font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Mistake number 2: Try to attach a stream that was previously detached. </h3><br>  If at some point in the program you have a <i>detachable</i> flow, you cannot attach it back to the main flow.  This is a very obvious mistake.  The problem is that you can unpin the stream, and then write a few hundred lines of code and try to reattach it.  After all, who remembers that he wrote 300 lines back, right? <br><br>  The problem is that it will not cause a compilation error; instead, the program will crash at startup.  For example: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">// CRASH !!!</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  The solution is to always check the <i>joinable ()</i> flow before attempting to attach it to the calling thread. <br><br> <code><font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">detach</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//..... 100  - </font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> t1. <font color="#007788">joinable</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  Error 3: Misunderstanding that std :: thread :: join () blocks the calling thread of execution </h3><br>  In real-world applications, you may often need to allocate ‚Äúlong-playing‚Äù operations for processing network I / O or waiting for a user to press a button, etc., into a separate thread.  A call to <i>join ()</i> for such worker threads (for example, a UI draw thread) can cause the user interface to hang.  There are more suitable ways of implementation. <br><br>  For example, in a GUI application, a workflow can send a UI message to a thread when completed.  The UI thread has its own event loop, such as: moving the mouse, pressing keys, etc.  This loop can also receive messages from worker threads and respond to them without the need to call the <i>join ()</i> blocking method. <br><br>  For this very reason, almost all user interactions are asynchronous in the Microsoft <a href="https://msdn.microsoft.com/en-us/magazine/mt745094.aspx">WinRT</a> platform, and synchronous alternatives are not available.  These decisions were made to ensure that developers use an API that provides the best use experience for end users.  You can refer to the " <a href="https://www.amazon.com/Modern-C-Windows-Store-Apps/dp/0989020800/ref%3Dsr_1_19%3Fie%3DUTF8%26qid%3D1503240778%26sr%3D8-19%26keywords%3DModern%2BC%252B%252B">Modern C ++ and Windows Store Apps</a> " manual for more information on this topic. <br><br><h3>  Error # 4: Assume that the arguments of the stream function are passed by reference by default. </h3><br>  The arguments to the stream function are by default passed by value.  If you need to make changes to the passed arguments, you must pass them by reference using the function <a href="https://en.cppreference.com/w/cpp/utility/functional/ref">std :: ref ()</a> . <br><br>  Under the spoiler, examples from another <a href="https://www.acodersjourney.com/c11-multithreading-tutorial-via-faq-thread-management-basics/">C ++ 11 article Multithreading Tutorial via Q &amp; A - Thread Management Basics (Deb Haldar)</a> , illustrating the transfer of parameters [approx.  translator]. <br><br><div class="spoiler">  <b class="spoiler_title">more details:</b> <div class="spoiler_text">  When executing code: <br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, targetCity <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  It will be displayed in the terminal: <br> <code>Changing The Target City To Metropolis <br> Current Target City is Star City</code> <br> <br>  As you can see, the value of the <i>targetCity</i> variable received by the function called in the stream has not changed by reference. <br><br>  Rewrite the code using <i>std :: ref ()</i> to pass the argument: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;functional&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> ChangeCurrentMissileTarget <font color="#008000">(</font> string <font color="#000040">&amp;</font> targetCity <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> targetCity <font color="#000080">=</font> <font color="#FF0000">"Metropolis"</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" Changing The Target City To "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> string targetCity <font color="#000080">=</font> <font color="#FF0000">"Star City"</font> <font color="#008080">;</font> <br> thread t1 <font color="#008000">(</font> ChangeCurrentMissileTarget, std <font color="#008080">::</font> <font color="#007788">ref</font> <font color="#008000">(</font> targetCity <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Current Target City is "</font> <font color="#000080">&lt;&lt;</font> targetCity <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  It will be displayed: <br> <code>Changing The Target City To Metropolis <br> Current Target City is Metropolis</code> <br> <br>  Changes made in the new thread will affect the value of the <i>targetCity</i> variable declared and initialized in the <i>main</i> function. <br></div></div><br><h3>  Error # 5: Do not protect shared data and resources using a critical section (for example, a mutex) </h3><br>  In a multithreaded environment, usually more than one stream competes for resources and shared data.  Often this leads to an undefined state for resources and data, except when access to them is protected by some mechanism that allows only one execution thread to perform operations on them at a time. <br><br>  In the example below, <i>std :: cout</i> is a shared resource with which 6 threads work (t1-t5 + main). <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t3 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Moon"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> CallHome <font color="#008000">(</font> <font color="#FF0000">"Hello from Main/Earth"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> thread t4 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Uranus"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t5 <font color="#008000">(</font> CallHome, <font color="#FF0000">"Hello from Neptune"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t3. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t4. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t5. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  If we execute this program, we get the output: <br><br> <code>Thread 0x1000fb5c0 says Hello from Main/Earth <br> Thread Thread Thread 0x700005bd20000x700005b4f000 says says Thread Thread Hello from Pluto0x700005c55000Hello from Jupiter says 0x700005d5b000Hello from Moon <br> 0x700005cd8000 says says Hello from Uranus <br> <br> Hello from Neptune <br></code> <br><br>  This is because five threads simultaneously access the output stream in a random order.  To make the output more specific, you need to protect access to the shared resource with <a href="https://ru.cppreference.com/w/cpp/thread/mutex">std :: mutex</a> .  Simply change the <i>CallHome ()</i> function so that it captures the mutex before using <i>std :: cout</i> and releases it after. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Error # 6: Forget to release the lock after exiting the critical section </h3><br>  In the previous paragraph, you saw how to protect the critical section with a mutex.  However, calling the <i>lock ()</i> and <i>unlock ()</i> methods directly on the mutex is not the preferred option because you may forget to release the lock that is being held.  What happens next?  All other threads that are waiting for the resource to be released will be blocked indefinitely and the program may hang. <br><br>  In our synthetic example, if you forgot to unblock the mutex in the call to the <i>CallHome ()</i> function, the first message from the t1 stream will be output to the standard stream and the program will hang.  This is due to the fact that the t1 thread has received a mutex lock, while the remaining threads are waiting for this lock to be released. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#666666">//mu.unlock();     </font> <br> <font color="#008000">}</font></code> <br> <br>  Below is the output of this code - the program is frozen, outputting a single message to the terminal, and does not end: <br><br> <code>Thread 0x700005986000 says Hello from Pluto <br> <br></code> <br><br>  Such errors often occur, which is why it is undesirable to use the <i>lock () / unlock ()</i> methods directly from the mutex.  Instead, use the template class <a href="https://en.cppreference.com/w/cpp/thread/lock_guard">std :: lock_guard</a> , which uses the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B5%25D1%2581%25D1%2583%25D1%2580%25D1%2581%25D0%25B0_%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">RAII</a> idiom to control the lock lifetime.  When the <i>lock_guard</i> object is created, it tries to take over the mutex.  When the program goes out of the <i>lock_guard</i> object, the destructor is called, which frees the mutex. <br><br>  <i>Rewrite the CallHome ()</i> function using the object's <i>std :: lock_guard</i> : <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   </font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#666666">//  lock_guard    </font></code> <br> <br><h3>  Mistake number 7: Make the size of the critical section larger than necessary. </h3><br>  When one thread runs inside the critical section, all others trying to enter it are essentially blocked.  We need to keep the minimum number of instructions in the critical section as possible.  For illustration, here is an example of a bad code with a large critical section: <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//    lock_guard    mu </font></code> <br> <br>  The <i>ReadFifyThousandRecords ()</i> method does not modify the data.  There is no reason to do it under lock.  If this method is executed for 10 seconds, reading 50 thousand lines from the database, all other threads will be blocked for the entire period without any need.  This can seriously affect the performance of the program. <br><br>  The correct solution would be to keep only <i>std :: cout</i> in the critical section. <br><br> <code><font color="#0000ff">void</font> CallHome <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> ReadFifyThousandRecords <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//         ..    </font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//   ,    std::cout</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> <font color="#008000">}</font> <font color="#666666">//     lock_guard    mu </font></code> <br> <br><h3>  Mistake number 8: Taking several locks in a different order. </h3><br><br>  This is one of the most common causes of <a href="https://en.wikipedia.org/wiki/Deadlock">deadlock</a> , a situation in which threads end up endlessly blocked due to waiting for access to resources blocked by other threads.  Consider an example: <br><br><table><tbody><tr><th>  stream 1 </th><th>  stream 2 </th></tr><tr><td>  lock A </td><td>  lock B </td></tr><tr><td>  // ... some operations </td><td>  // ... some operations </td></tr><tr><td>  lock B </td><td>  lock A </td></tr><tr><td>  // ... some other operations </td><td>  // ... some other operations </td></tr><tr><td>  unlock B </td><td>  unlock A </td></tr><tr><td>  unlock A </td><td>  unlock B </td></tr></tbody></table><br>  There may be a situation in which stream 1 will try to seize lock B and will be blocked, because stream 2 has already captured it.  At the same time, the second thread tries to capture lock A, but cannot do this, because it was captured by the first thread.  Thread 1 cannot release lock A until it locks lock B, etc.  In other words, the program will freeze. <br><br>  This code example will help you reproduce the <i>deadlock</i> : <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;string&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muA <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> muB <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th1 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">//  - </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> CallHome_Th2 <font color="#008000">(</font> string message <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> muB. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#666666">// -  </font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muA. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread "</font> <font color="#000080">&lt;&lt;</font> this_thread <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" says "</font> <font color="#000080">&lt;&lt;</font> message <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <br> muA. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> muB. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> CallHome_Th1, <font color="#FF0000">"Hello from Jupiter"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> thread t2 <font color="#008000">(</font> CallHome_Th2, <font color="#FF0000">"Hello from Pluto"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> t2. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></code> <br> <br>  If you run this code, it will hang.  If you go deeper into the debugger in the threads window, you will see that the first thread (called from <i>CallHome_Th1 ()</i> ) is trying to get a mutex B lock, while thread 2 (called from <i>CallHome_Th2 ()</i> ) is trying to block mutex A. None of the threads can not achieve success, which leads to a mutual blocking! <br><br> <a href=""><img src="https://habrastorage.org/webt/ud/kf/a5/udkfa53cvuh8xsrn8lljglb09fa.png"></a> <br>  (the picture is clickable) <br><br>  What can you do about it?  The best solution would be to restructure the code in such a way that the lock is locked every time in the same order. <br><br>  Depending on the situation, you can use other strategies: <br><br>  1. Use the wrapper <a href="https://en.cppreference.com/w/cpp/thread/scoped_lock">class std :: scoped_lock</a> to jointly capture multiple locks: <br><br> <code>std <font color="#008080">::</font> <font color="#007788">scoped_lock</font> lock <font color="#008000">{</font> muA, muB <font color="#008000">}</font> <font color="#008080">;</font></code> <br> <br>  2. Use the class <a href="https://en.cppreference.com/w/cpp/thread/timed_mutex">std :: timed_mutex</a> , in which you can specify a timeout after which the lock will be released if the resource is not available. <br><br> <code>std <font color="#008080">::</font> <font color="#007788">timed_mutex</font> m <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> DoSome <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> timeout <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> m. <font color="#007788">try_lock_for</font> <font color="#008000">(</font> timeout <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": acquire mutex successfully"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> m. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#0000ff">else</font> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">get_id</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">": can't  acquire mutex, do something else"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font></code> <br> <br><h3>  Mistake 9: Trying to seize the std :: mutex lock twice. </h3><br>  Attempting to lock the lock twice will result in unspecified behavior.  In most debugging implementations, this will lead to crashing.  For example, in the code below, <i>LaunchRocket () will</i> block the mutex and then call <i>StartThruster ()</i> .  What is curious is that in the above code you will not encounter this problem during normal program operation; a problem occurs only when an exception is thrown, which is accompanied by indefinite behavior or the program crash. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <font color="#339900">#include &lt;mutex&gt;</font> <br> <br> std <font color="#008080">::</font> <font color="#007788">mutex</font> mu <font color="#008080">;</font> <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">int</font> counter <font color="#000080">=</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#666666">// - </font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching rocket"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">lock_guard</font> <font color="#000080">&lt;</font> std <font color="#008080">::</font> <font color="#007788">mutex</font> <font color="#000080">&gt;</font> lock <font color="#008000">(</font> mu <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> StartThruster <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  To eliminate this problem, you need to correct the code in such a way as to exclude the re-taking of previously obtained locks.  You can use <a href="https://en.cppreference.com/w/cpp/thread/recursive_mutex">std :: recursive_mutex</a> as a crutch solution, but this solution almost always indicates a bad program architecture. <br><br><h3>  Mistake # 10: Use mutexes when std :: atomic types are enough </h3><br><br>  When you need to change simple data types, such as a boolean value or an integer counter, using <a href="https://en.cppreference.com/w/cpp/atomic/atomic">std: atomic</a> will usually give you better performance than using mutexes. <br><br>  For example, instead of using the following construct: <br><br> <code><font color="#0000ff">int</font> counter <font color="#008080">;</font> <br> ... <br> mu. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> counter <font color="#000040">++</font> <font color="#008080">;</font> <br> mu. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br></code> <br><br>  It is better to declare a variable as <i>std :: atomic</i> : <br><br> <code>std <font color="#008080">::</font> <font color="#007788">atomic</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> counter <font color="#008080">;</font> <br> ... <br> <font color="#007788">counter</font> <font color="#000040">++</font> <font color="#008080">;</font></code> <br> <br>  For a detailed comparison of mutex and atomic, see the article <a href="https://www.arangodb.com/2015/02/comparing-atomic-mutex-rwlocks/">‚ÄúComparison: Lockless programming with atomics in C ++ 11 vs.</a>  <a href="https://www.arangodb.com/2015/02/comparing-atomic-mutex-rwlocks/">mutex and RW-locks ¬ª</a> <br><br><h3>  Mistake # 11: Create and destroy a large number of threads directly, instead of using a pool of free threads. </h3><br>  Creating and destroying threads is a costly operation in terms of CPU time.  Imagine an attempt to create a stream while the system performs resource-intensive computational operations, for example, drawing graphics or calculating game physics.  An approach often used for such tasks is to create a pool of pre-allocated threads that can handle routine tasks, such as writing to disk or sending data over the network during the entire life cycle of a process. <br><br>  Another advantage of the thread pool, compared to spawning and destroying threads yourself, is that you do not need to worry about <a href="https://software.intel.com/en-us/vtune-amplifier-help-thread-oversubscription">thread oversubscription</a> (a situation in which the number of threads exceeds the number of available cores and much of the processor time is spent on context switching [approx. translator]).  This may affect system performance. <br><br>  In addition, the use of the pool saves us from the torments of managing the life cycle of threads, which ultimately results in a more compact code with fewer errors. <br><br>  The two most popular libraries that implement thread pools are: <a href="https://www.amazon.com/Intel-Threading-Building-Blocks-Parallelism/dp/0596514808/ref%3Dsr_1_1%3Fie%3DUTF8%26qid%3D1502746643%26sr%3D8-1%26keywords%3Dthread%2Bbuilding%2Bblock">Intel Thread Building Blocks (TBB)</a> and <a href="https://msdn.microsoft.com/en-us/library/dd492418.aspx">Microsoft Parallel Patterns Library (PPL)</a> . <br><br><h3>  Mistake # 12: Do not handle exceptions that occur in background threads. </h3><br>  Exceptions thrown in one stream cannot be processed in another stream.  Let's imagine that we have a function that throws an exception.  If we execute this function in a separate thread, branched from the main thread of execution, and expect that we will catch any exception thrown from the additional thread, this will not work.  Consider an example: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> teptr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  When executing this program, a crash will occur, however, the catch block in main () will not execute and will not handle the exception thrown in stream t1. <br><br>  The solution to this problem is to use the opportunity from C ++ 11: <a href="https://en.cppreference.com/w/cpp/error/exception_ptr">std :: exception_ptr</a> is used to handle the exception thrown in the background thread.  Here are the steps you need to take: <br><br><ul><li>  Create a global instance of the class <i>std :: exception_ptr</i> , initialized with <i>nullptr</i> </li><li>  Inside a function that runs in a separate thread, handle all exceptions and set the value of <a href="https://en.cppreference.com/w/cpp/error/current_exception">std :: current_exception () to the</a> global variable <i>std :: exception_ptr</i> declared in the previous step </li><li>  Inside the main thread, check the value of a global variable. </li><li>  If the value is set, use the function <a href="https://en.cppreference.com/w/cpp/error/rethrow_exception">std :: rethrow_exception (exception_ptr p)</a> to call the previously caught exception again, passing it by reference as a parameter </li></ul><br>  The exception is recalled by reference not in the thread in which it was created, so this feature is great for handling exceptions in different threads. <br><br>  The code below achieves safe handling of the exception thrown in the background thread. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include&lt;iostream&gt;</font> <br> <font color="#339900">#include&lt;thread&gt;</font> <br> <font color="#339900">#include&lt;exception&gt;</font> <br> <font color="#339900">#include&lt;stdexcept&gt;</font> <br> <br> <font color="#0000ff">static</font> std <font color="#008080">::</font> <font color="#007788">exception_ptr</font> globalExceptionPtr <font color="#000080">=</font> <font color="#0000ff">nullptr</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">milliseconds</font> <font color="#008000">(</font> <font color="#0000dd">100</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> globalExceptionPtr <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">current_exception</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">thread</font> t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">rethrow_exception</font> <font color="#008000">(</font> globalExceptionPtr <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">exception</font> <font color="#000040">&amp;</font> ex <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Thread exited with exception: "</font> <font color="#000080">&lt;&lt;</font> ex. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">" <font color="#000099">\n</font> "</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  Error 13: Use threads to simulate asynchronous operation, instead of using std :: async </h3><br>  If you need the code to run asynchronously, i.e.  without locking the main thread, the best choice would be to use <a href="https://en.cppreference.com/w/cpp/thread/async">std :: async ()</a> .  This is equivalent to creating a stream and passing the necessary code to be executed into this stream via a pointer to a function or parameter in the form of a lambda function.  However, in the latter case, you need to monitor the creation, attachment / detachment of this stream, as well as the handling of all exceptions that may occur in this stream.  If you use <i>std :: async ()</i> , you save yourself from these problems, and also sharply reduce your chances of getting into the <i>deadlock</i> . <br><br>  Another significant advantage of using <i>std :: async</i> is the ability to get the result of an asynchronous operation back to the calling thread using the <a href="https://en.cppreference.com/w/cpp/thread/future">std :: future</a> object.  Imagine that we have a <i>ConjureMagic ()</i> function that returns an int.  We can start an asynchronous operation that will set the value in the future in the <i>future</i> object when the task is completed, and we can extract the result of the execution from this object in the execution flow from which the operation was called. <br><br> <code><font color="#666666">//        future</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> asyncResult2 <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> <font color="#000040">&amp;</font> ConjureMagic <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//...  -   future   </font> <br> <br> <font color="#666666">//     future</font> <br> <font color="#0000ff">int</font> v <font color="#000080">=</font> asyncResult2. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Getting the result back from the running thread to the caller is more cumbersome.  Two ways are possible: <br><br><ol><li>  Passing a reference to the output variable to the stream in which it will save the result. </li><li>  Store the result in a field variable of the workflow object that can be read as soon as the thread completes execution. </li></ol><br>  <a href="https://www.amazon.com/Optimized-Proven-Techniques-Heightened-Performance/dp/1491922060/ref%3Dsr_1_1%3Fs%3Dbooks%26ie%3DUTF8%26qid%3D1502553402%26sr%3D1-1">Kurt Guntheroth</a> found that in terms of performance, the overhead of creating a thread is 14 times more than using <i>async</i> . <br><br>  Bottom line: use <i>std :: async ()</i> by default until you find strong arguments for using <i>std :: thread</i> directly. <br><br><h3>  Error 14: Do not use std :: launch :: async if asynchrony is required </h3><br>  The <i>std :: async ()</i> function is not quite the correct name, because by default it may not be executed asynchronously! <br><br>  There are two <i>std :: async</i> execution policies: <br><br><ol><li>  <i>std :: launch :: async</i> : the transferred function starts to run immediately in a separate thread </li><li>  <i>std :: launch :: deferred</i> : the passed function does not start right away, its launch is postponed until calls to <i>get ()</i> or <i>wait () are made</i> on the <i>std :: future</i> object that will be returned from the call to <i>std :: async</i> .  In the place where these methods are called, the function will be executed synchronously. </li></ol><br>  When we call <i>std :: async ()</i> with default parameters, it starts up with a combination of these two parameters, which in fact leads to unpredictable behavior.  There are a number of other difficulties associated with using <i>std: async ()</i> with a default startup policy: <br><br><ul><li>  inability to predict the correctness of access to local variables of the stream </li><li>  an asynchronous task may not start at all due to the fact that calls to <i>get ()</i> and <i>wait ()</i> methods may not be called during program execution </li><li>  when used in loops in which the exit condition waits for the std :: future object to be ready, these loops may never end, because std :: future, returned by a call to std :: async, can start in a pending state. </li></ul><br>  To avoid all these difficulties, <b>always</b> call <i>std :: async</i> with the launch policy <i>std :: launch :: async</i> . <br><br>  Do not do this: <br><br> <code><font color="#666666">//  myFunction  std::async     </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  Instead, do this: <br><br> <code><font color="#666666">//  myFunction </font> <br> <font color="#0000ff">auto</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , myFunction <font color="#008000">)</font> <font color="#008080">;</font></code> <br> <br>  In more detail this moment is considered in Scott Meyers' book Effective and Modern C ++. <br><br><h3>  Error 15: Call the get () method of the std :: future object in a block of code whose execution time is critical </h3><br>  The code below handles the result obtained from the <i>std :: future</i> object of the asynchronous operation.  However, the <i>while loop</i> will be blocked until an asynchronous operation is completed (in this case for 10 seconds).  If you want to use this loop to display information on the screen, this can lead to unpleasant user interface rendering delays. <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <font color="#666666">//  -   Val</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br>  <b>Note</b> : Another problem with the above code is that it tries to access the <i>std :: future</i> object a second time, although the state of the object's <i>std :: future</i> was retrieved on the first iteration of the loop and cannot be re-received. <br><br>  The correct solution would be to check the validity of the object's <i>std :: future</i> before calling the <i>get ()</i> method.  Thus, we do not block the completion of an asynchronous task and do not try to re-interrogate an already retrieved <i>std :: future</i> object. <br><br>  This code snippet allows you to achieve this: <br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">this_thread</font> <font color="#008080">::</font> <font color="#007788">sleep_for</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">chrono</font> <font color="#008080">::</font> <font color="#007788">seconds</font> <font color="#008000">(</font> <font color="#0000dd">10</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     </font> <br> <font color="#0000ff">while</font> <font color="#008000">(</font> <font color="#0000ff">true</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#666666">//     </font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Rendering Data"</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> val <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <font color="#666666">//    10 </font> <br> <br> <font color="#666666">//   -   Val</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  ‚Ññ16:  ,  ,    ,        std::future::get() </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine that we have the following code snippet, what do you think will be the result of a call to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: future :: get ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">If you assume that the program will fall - you are absolutely right! </font><font style="vertical-align: inherit;">The exception thrown in an asynchronous operation is thrown only when the </font><i><font style="vertical-align: inherit;">get ()</font></i><font style="vertical-align: inherit;"> method is invoked </font><font style="vertical-align: inherit;">on the </font><i><font style="vertical-align: inherit;">std :: future object</font></i><font style="vertical-align: inherit;"> . And if the </font><i><font style="vertical-align: inherit;">get ()</font></i><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">is not called, the exception will be ignored and thrown when the </font><i><font style="vertical-align: inherit;">std :: future</font></i><font style="vertical-align: inherit;"> object goes out of scope. </font><font style="vertical-align: inherit;">If your asynchronous operation can throw an exception, then you should always wrap the call to </font><i><font style="vertical-align: inherit;">std :: future :: get ()</font></i><font style="vertical-align: inherit;"> in the </font><i><font style="vertical-align: inherit;">try / catch</font></i><font style="vertical-align: inherit;"> block. An example of how this might look like:</font></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;future&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#007788">future</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> <font color="#000080">&gt;</font> myFuture <font color="#000080">=</font> std <font color="#008080">::</font> <font color="#007788">async</font> <font color="#008000">(</font> std <font color="#008080">::</font> <font color="#007788">launch</font> <font color="#008080">::</font> <font color="#007788">async</font> , <font color="#008000">[</font> <font color="#008000">]</font> <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">throw</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#008000">(</font> <font color="#FF0000">"Catch me in MAIN"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">8</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> myFuture. <font color="#007788">valid</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">try</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">int</font> result <font color="#000080">=</font> myFuture. <font color="#007788">get</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">catch</font> <font color="#008000">(</font> <font color="#0000ff">const</font> std <font color="#008080">::</font> <font color="#007788">runtime_error</font> <font color="#000040">&amp;</font> e <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> std <font color="#008080">::</font> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Async task threw exception: "</font> <font color="#000080">&lt;&lt;</font> e. <font color="#007788">what</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#000080">&lt;&lt;</font> std <font color="#008080">::</font> <font color="#007788">endl</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><h3>  ‚Ññ17:  std::async,        </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async () is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sufficient in most cases, there are situations in which you may need careful control over the execution of your code in the stream. For example, if you want to bind a specific thread to a specific processor core in a multiprocessor system (for example, Xbox). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above code fragment sets the thread binding to the 5th processor core in the system. </font><font style="vertical-align: inherit;">This is possible thanks to the </font><a href="https://en.cppreference.com/w/cpp/thread/thread/native_handle"><font style="vertical-align: inherit;">native_handle ()</font></a><font style="vertical-align: inherit;"> method of the </font><i><font style="vertical-align: inherit;">std :: thread</font></i><font style="vertical-align: inherit;"> object </font><font style="vertical-align: inherit;">, and passing it to the </font><a href="https://msdn.microsoft.com/en-us/library/ms684852(v%3Dvs.85).aspx"><font style="vertical-align: inherit;">Win32 API</font></a><font style="vertical-align: inherit;"> threading function </font><font style="vertical-align: inherit;">. There are many other features provided through the Win32 streaming API that are not available in </font><i><font style="vertical-align: inherit;">std :: thread</font></i><font style="vertical-align: inherit;"> or </font><i><font style="vertical-align: inherit;">std :: async ()</font></i><font style="vertical-align: inherit;"> . When working through</font></font><br><br> <code><font color="#339900">#include "stdafx.h"</font> <br> <font color="#339900">#include &lt;windows.h&gt;</font> <br> <font color="#339900">#include &lt;iostream&gt;</font> <br> <font color="#339900">#include &lt;thread&gt;</font> <br> <br> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> std <font color="#008080">;</font> <br> <br> <font color="#0000ff">void</font> LaunchRocket <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000dd">cout</font> <font color="#000080">&lt;&lt;</font> <font color="#FF0000">"Launching Rocket"</font> <font color="#000080">&lt;&lt;</font> endl <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">int</font> main <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> thread t1 <font color="#008000">(</font> LaunchRocket <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> DWORD result <font color="#000080">=</font> <font color="#008080">::</font> <font color="#007788">SetThreadIdealProcessor</font> <font color="#008000">(</font> t1. <font color="#007788">native_handle</font> <font color="#008000">(</font> <font color="#008000">)</font> , <font color="#0000dd">5</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> t1. <font color="#007788">join</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">return</font> <font color="#0000dd">0</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br></code> <br><br><font style="vertical-align: inherit;"></font><a href="https://en.cppreference.com/w/cpp/thread/thread/native_handle"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://msdn.microsoft.com/en-us/library/ms684852(v%3Dvs.85).aspx"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: async ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> these basic platform functions are not available, which makes this method unsuitable for more complex tasks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatively, create </font></font><a href="https://en.cppreference.com/w/cpp/thread/packaged_task"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: packaged_task</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and move it to the desired execution thread after setting the properties of the flow.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mistake # 18: Create much more ‚Äúrunning‚Äù threads than available cores. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From an architectural point of view, streams can be classified into two groups: ‚Äúrunning‚Äù and ‚Äúwaiting‚Äù. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Running threads recycle 100% of the kernel time on which they are running. When more than one running thread is allocated per core, processor utilization efficiency drops. We do not get performance gains if we run more than one running thread on a single processor core ‚Äî in fact, performance drops due to additional context switches.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waiting threads recycle only a few clock ticks on which they run while waiting for system events or network I / O, etc. In this case, most of the available processor time of the kernel remains unused. One waiting thread can process data, while the others wait for events to trigger ‚Äî which is why it is advantageous to distribute several waiting threads to one core. Planning multiple waiting threads per core can provide much better program performance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, how to understand how many threads the system supports? Use the </font></font><a href="https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: thread :: hardware_concurrency ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">. This function usually returns the number of processor cores, but takes into account cores that behave like two or more logical cores due to</font></font><a href="https://ru.wikipedia.org/wiki/Hyper-threading"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hyper-trading</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You must use the resulting value of the target platform to plan the maximum number of concurrently running threads of your program. You can also assign one core for all pending threads, and use the remaining number of cores for the threads that are running. For example, in a quad-core system, use one core for ALL pending threads, and for the other three cores - three running threads. Depending on the performance of your thread scheduler, some of your executable threads may switch context (due to page access failures, etc.), leaving the kernel inactive for some time. If you observe this situation during profiling, you should create a slightly larger number of threads to execute than the number of cores and adjust this value for your system.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Error 19: Using the volatile keyword for synchronization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><a href="https://en.cppreference.com/w/cpp/language/cv"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volatile</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keyword </font><font style="vertical-align: inherit;">before specifying the type of a variable does not make operations with this variable atomic or thread-safe. </font><font style="vertical-align: inherit;">What you probably want is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: atomic</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See the discussion on </font></font><a href="https://stackoverflow.com/questions/4557979/when-to-use-volatile-with-multi-threading"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for details.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mistake number 20: Using Lock Free architecture, except when absolutely necessary </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In complexity, there is something that every engineer likes. Creating programs that work without locks (lock free) sounds very tempting compared to conventional synchronization mechanisms such as mutex, condition variables, asynchrony, etc. However, every experienced C ++ developer I spoke with adhered to that the use of non-blocking programming as a source is a type of premature optimization that can go sideways at the most inopportune moment (think of a malfunction in the operating system when you do not have a full heap dump!)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my career in C ++, there was only one situation that required unlocked code execution, because we worked in a system with limited resources, where each transaction in our component should take no more than 10 microseconds. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before you think about using a non-blocking approach, please answer three questions:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Have you tried to design the architecture of your system so that it does not need a synchronization mechanism? </font><font style="vertical-align: inherit;">As a rule, the best synchronization is the lack of synchronization.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you need synchronization, have you profiled your code to understand performance characteristics? </font><font style="vertical-align: inherit;">If so, have you tried to optimize bottlenecks?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Can you scale horizontally instead of vertically? </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summarizing, for normal application development, please consider programming without blocking only when you have exhausted all other alternatives. </font><font style="vertical-align: inherit;">Another way to look at this is that if you are still making some of the above 19 errors, you should probably stay away from non-blocking programming. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[From. </font><font style="vertical-align: inherit;">translator: Many thanks to the user </font></font><a href="https://habr.com/ru/users/vovo4k/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vovo4K</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for help in preparing this article.]</font></font></div><p>Source: <a href="https://habr.com/ru/post/443406/">https://habr.com/ru/post/443406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443390/index.html">Australian English features</a></li>
<li><a href="../443392/index.html">The history of saving in games: from passwords on paper to clouds</a></li>
<li><a href="../443398/index.html">Implementing ERP in industrial enterprises: Alevtina Svetozarovna and Excel against severe architects and an English factory</a></li>
<li><a href="../443402/index.html">How to make code review faster and more efficiently</a></li>
<li><a href="../443404/index.html">The new goal of NASA to search for extraterrestrial civilizations: technology signs</a></li>
<li><a href="../443408/index.html">Photons, quanta and the Fock state: manipulations with a radio-frequency resonator at the quantum level</a></li>
<li><a href="../443412/index.html">Why programmers continue to use verbose Java, although there is a concise Python</a></li>
<li><a href="../443416/index.html">Winnti: Supply Chain Attack - Asian Game Developers at Gunpoint</a></li>
<li><a href="../443418/index.html">Software Testing Methods</a></li>
<li><a href="../443422/index.html">Flexible data storage in MySQL (JSON)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>