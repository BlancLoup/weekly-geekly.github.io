<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part 4: Database</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the fourth article in the series where I describe my experience of writing a Python web application using the Flask mic framework. 

 The purp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part 4: Database</h1><div class="post__text post__text-html js-mediator-article">  This is the fourth article in the series where I describe my experience of writing a Python web application using the Flask mic framework. <br><br>  The purpose of this guide is to develop a fairly functional microblog application, which I decided to call microblog, in the absence of originality. <br><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/post/193242/">Part 1: Hello, World!</a> <br>  <a href="http://habrahabr.ru/post/193260/">Part 2: Templates</a> <br>  <a href="http://habrahabr.ru/post/194062/">Part 3: Forms</a> <br>  <a href="http://habrahabr.ru/post/196810/">Part 4: Database</a> <br>  <a href="http://habrahabr.ru/post/222983/">Part 5: User Login</a> <br>  <a href="http://habrahabr.ru/post/223375/">Part 6: Profile Page and Avatars</a> <br>  <a href="http://habrahabr.ru/post/223783/">Part 7: Unit Testing</a> <br>  <a href="http://habrahabr.ru/post/230643/">Part 8: Subscribers, Contacts and Friends</a> <br>  <a href="http://habrahabr.ru/post/230897/">Part 9: Pagination</a> <br>  <a href="http://habrahabr.ru/post/234613/">Part 10: Full Text Search</a> <br>  <a href="http://habrahabr.ru/post/234737/">Part 11: Email Support</a> <br>  <a href="http://habrahabr.ru/post/234785/">Part 12: Reconstruction</a> <br>  <a href="http://habrahabr.ru/post/236753/">Part 13: Date and Time</a> <br>  <a href="http://habrahabr.ru/post/236861/">Part 14: I18n and L10n</a> <br>  <a href="http://habrahabr.ru/post/237065/">Part 15: Ajax</a> <br>  <a href="http://habrahabr.ru/post/237317/">Part 16: Debugging, Testing, and Profiling</a> <br>  <a href="http://habrahabr.ru/post/237489/">Part 17: Deploying to Linux (even to Raspberry Pi!)</a> <br>  <a href="http://habrahabr.ru/post/237517/">Part 18: Deploying to Heroku Cloud</a> <br></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Brief repetition </h4><br>  In the previous section, we created our login form complete with submission and validation. <br><br>  In this article, we intend to create our database and raise it so that we can write our users there. <br><br>  To follow this part, your microblog application must be the way we left it at the end of the previous one.  Please make sure the application is installed and working. <br><a name="habracut"></a><br><h4>  Run Python scripts from the command line </h4><br>  In this part we are going to write several scripts that will simplify the management of our database.  Before we begin, let's look at how Python scripts are executed from the command line. <br><br>  If you are a Linux or OS X user, then scripts need to be given permissions to execute: <br><pre><code class="bash hljs">chmod a+x script.py</code> </pre> <br><br>  The script has a shebang line ( <i><b>Note:</b> In Unix, if the first two bytes of the executable file are "#!", The kernel treats the file as a script, and not as machine code. The word after "!" the first space) is used as the path to the interpreter.</i> ), which determines which interpreter should be used.  The script with the issued execution rights and the shebang line can be easily run like this: <br><pre> <code class="bash hljs">./script.py &lt;&gt;</code> </pre><br><br>  On Windows, however, this does not work, and instead you should pass the script as an argument to the selected Python interpreter: <br><pre> <code class="bash hljs">flask\Scripts\python script.py &lt;&gt;</code> </pre><br><br>  To avoid having to enter the path to the interpreter, you can add your microblog \ flask \ Scripts directory to the system PATH, making sure that it [the path to the interpreter] is written to your regular interpreter. <br><br>  For the sake of brevity, this guide will continue to use the Linux / OS X syntax. If you are a Windows user, do not forget to change the syntax accordingly. <br><br><h4>  Flask Databases </h4><br>  To manage our application, we will use the <code>Flask-SQLAlchemy</code> extension.  This extension provides a wrapper for the <code>SQLAlchemy</code> project, which is an ORM or Object-relational mapping. <br><br>  ORM allows database applications to work with objects instead of tables or SQL.  Operations are performed on objects, and then transparently translated into database commands using ORM.  In fact, this means that we will not study SQL in this guide, but let Flask-SQLAlchemy speak SQL for us. <br><br><h4>  Migrations </h4><br>  Most of the manuals that I have seen affect the creation and use of the database, but the problems of updating the database due to the growth of the application are not properly addressed.  Usually, all this ends with the removal of the old database and the creation of a new one each time you need to update, losing all the data.  And if the data cannot be easily recreated, then you may have to write export and import scripts yourself. <br><br>  Fortunately, we have a much better option. <br><br>  We are going to use <code>SQLAlchemy-migrate</code> to track the database update for us.  This will add a bit of work to run the database, but this is a small price to never worry about manually migrating the database. <br><br>  Enough theory, it's time to get started! <br><br><h4>  Configuration </h4><br>  For our small application we will use <code>sqlite</code> .  These databases are the most suitable choice for small applications, as each database is stored in a separate file. <br><br>  We have a couple of items that we add to the configuration file (the config.py file): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os basedir = os.path.abspath(os.path.dirname(__file__)) SQLALCHEMY_DATABASE_URI = <span class="hljs-string"><span class="hljs-string">'sqlite:///'</span></span> + os.path.join(basedir, <span class="hljs-string"><span class="hljs-string">'app.db'</span></span>) SQLALCHEMY_MIGRATE_REPO = os.path.join(basedir, <span class="hljs-string"><span class="hljs-string">'db_repository'</span></span>)</code> </pre><br><br>  <code>SQLALCHEMY_DATABASE_URI</code> required for the <code>Flask-SQLAlchemy</code> extension.  This is the path to the file with our database. <br><br>  <code>SQLALCHEMY_MIGRATE_REPO</code> is the folder where we will store the <code>SQLAlchemy-migrate.</code> files <code>SQLAlchemy-migrate.</code> <br><br>  Finally, when we initialize our application, we also need to initialize our database.  Here is our updated init file (app / __ init__.py file): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flask <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask.ext.sqlalchemy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> SQLAlchemy app = Flask(__name__) app.config.from_object(<span class="hljs-string"><span class="hljs-string">'config'</span></span>) db = SQLAlchemy(app) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> views, models</code> </pre><br><br>  Notice the two changes we made in our init script.  Now we create a <code>db</code> object, which will be our database, and we also import a new module called <code>models</code> .  We will write this module further. <br><br><h4>  Database model </h4><br>  The data that we will store in our database will be presented with a set of classes that are referred to as a database of models.  The ORM layer will make the necessary translations to match the objects created from these classes with the rows in the appropriate database table. <br><br>  Let's start by creating a model that will describe our users.  Using the <a href="http://ondras.zarovi.cz/sql/demo">WWW SQL Designer tool</a> , I made the following charts to draw a table of our users: <br><img src="https://habrastorage.org/getpro/habr/post_images/220/701/c47/220701c47ddff57734884e904c6fd0df.png"><br><br>  The <code>id</code> field is usually for all models, it is used as the primary key.  Each user in the database will be associated with a unique <code>id</code> value stored in this field.  Fortunately, this is done for us automatically, we just need to provide the <code>id</code> field. <br><br>  The <code>nickname</code> and <code>email</code> fields are defined as strings (or <code>VARCHAR</code> in database jargon), and they have a maximum length that allows our database to optimize space utilization. <br><br>  The <code>role</code> field is an integer number that we will use to keep track of which users are administrators and who are not. <br><br>  Now we have decided on how we want to see our table.  To translate all this into code is quite simple (file app / models.py): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> db ROLE_USER = <span class="hljs-number"><span class="hljs-number">0</span></span> ROLE_ADMIN = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(db.Model)</span></span></span><span class="hljs-class">:</span></span> id = db.Column(db.Integer, primary_key = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) nickname = db.Column(db.String(<span class="hljs-number"><span class="hljs-number">64</span></span>), index = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, unique = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) email = db.Column(db.String(<span class="hljs-number"><span class="hljs-number">120</span></span>), index = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, unique = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) role = db.Column(db.SmallInteger, default = ROLE_USER) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;User %r&gt;'</span></span> % (self.nickname)</code> </pre><br><br>  The <code>User</code> class we just created contains several fields defined as class variables.  Fields are created as instances of the <code>db.Column</code> class, which takes a field type as an argument, plus other optional arguments that allow us, for example, to specify which fields are unique and indexed. <br><br>  The <code>__repr__</code> method tells Python how to output objects of this class.  We will use it for debugging. <br><br><h4>  Database creation </h4><br>  We are done with the configuration and model, now we are ready to create a file with our database.  The <code>SQLAlchemy-migrate</code> package comes with command line tools and an API for creating databases that will allow for easy updates in the future, which we will do.  I find the command line tools inconvenient to use, so instead of them I wrote my own set of small Python scripts that invoke the migrations API. <br><br>  Here is the script that creates the database (db_create.py file): <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!flask/bin/python from migrate.versioning import api from config import SQLALCHEMY_DATABASE_URI from config import SQLALCHEMY_MIGRATE_REPO from app import db import os.path db.create_all() if not os.path.exists(SQLALCHEMY_MIGRATE_REPO): api.create(SQLALCHEMY_MIGRATE_REPO, 'database repository') api.version_control(SQLALCHEMY_DATABASE_URI, SQLALCHEMY_MIGRATE_REPO) else: api.version_control(SQLALCHEMY_DATABASE_URI, SQLALCHEMY_MIGRATE_REPO, api.version(SQLALCHEMY_MIGRATE_REPO))</span></span></code> </pre><br><br>  I note that the script is completely universal.  All specific paths are imported from the configuration file.  When you start your own project, you can simply copy the script to the folder of the new application, and it will immediately work. <br><br>  To create a database, you just need to run the script (remember that if you are on Windows, then the command is slightly different): <br><pre> <code class="bash hljs">./db_create.py</code> </pre><br><br>  After entering the command, you will receive a new <code>app.db</code> file.  This is an empty sqlite database that initially supports migration.  You also have a <code>db_repository</code> directory with several files inside.  At this point, <code>SQLAlchemy-migrate</code> stores its data files.  I note that we do not recreate the repository, if it has already been created.  This will allow us to recreate the databases from the existing repository, if necessary. <br><br><h4>  Our first migration </h4><br>  Now we have defined our model, which we can embed in our database.  We will look at any changes in the database structure of the migration application, so this is our first one that will lead us from an empty database to a database that can store users. <br><br>  To start the migration, I use another helper script (db_migrate.py file): <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!flask/bin/python import imp from migrate.versioning import api from app import db from config import SQLALCHEMY_DATABASE_URI from config import SQLALCHEMY_MIGRATE_REPO migration = SQLALCHEMY_MIGRATE_REPO + '/versions/%03d_migration.py' % (api.db_version(SQLALCHEMY_DATABASE_URI, SQLALCHEMY_MIGRATE_REPO) + 1) tmp_module = imp.new_module('old_model') old_model = api.create_model(SQLALCHEMY_DATABASE_URI, SQLALCHEMY_MIGRATE_REPO) exec old_model in tmp_module.__dict__ script = api.make_update_script_for_model(SQLALCHEMY_DATABASE_URI, SQLALCHEMY_MIGRATE_REPO, tmp_module.meta, db.metadata) open(migration, "wt").write(script) api.upgrade(SQLALCHEMY_DATABASE_URI, SQLALCHEMY_MIGRATE_REPO) print 'New migration saved as ' + migration print 'Current database version: ' + str(api.db_version(SQLALCHEMY_DATABASE_URI, SQLALCHEMY_MIGRATE_REPO))</span></span></code> </pre><br><br>  The script looks complicated, but in fact it does a bit.  The way to create a <code>SQLAlchemy-migrate</code> migration is to compare the structure of our database (obtained from the <code>app.db</code> file) and the structure of our model (obtained from the <code>models.py</code> file).  The differences between them are recorded as a migration script within the repository.  The migration script knows how to apply the migration or cancel it, so it will always be possible to update or ‚Äúroll back‚Äù the database format. <br><br>  While I had no problems with the automatic generation of migrations by the above script, I could observe that at times it was difficult to determine just by comparing the old and the new format, what changes were made.  To simplify the work of <code>SQLAlchemy-migrate</code> in defining changes, I never rename existing fields, limiting changes by adding / removing models or fields, changing the types of fields created.  And I always look at the generated migration script to make sure it is correct. <br><br>  It goes without saying that you should never try to migrate your database without having a backup, in case something goes wrong.  Also, never run migration for the first time on a production base, always make sure that the migration works correctly, on a developer base. <br><br>  So let's go ahead and record our migration: <br><pre> <code class="python hljs">./db_migrate.py</code> </pre><br><br>  And the script will output: <br><pre> <code class="bash hljs">New migration saved as db_repository/versions/001_migration.py Current database version: 1</code> </pre><br><br>  The script shows where the migration script was saved, and also displays the current version of the database.  The empty database had version 0, after migration with the inclusion of users, we have version 1. <br><br><h4>  Upgrade and Downgrade Database </h4><br>  Now you may be wondering why it is so important to go through additional efforts in recording migrations of the database. <br><br>  Imagine that you have an application on your work computer, and you also have a copy in use that is deployed on a production server. <br><br>  Let's say that for the next release of your application, you must enter a change in your models, for example, you need to add a new table.  Without migrations, you would need to figure out how to change the format of your database on the work computer, then again on your server, and this would require a lot of work. <br><br>  If you have support for migrations of DB, when you are ready to release a new version of the application to your production server, then you just need to record a new migration, copy the migration scripts to your server and run a simple script that applies your changes.  Upgrading the database can be done with this small Python script (db_upgrade.py file): <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!flask/bin/python from migrate.versioning import api from config import SQLALCHEMY_DATABASE_URI from config import SQLALCHEMY_MIGRATE_REPO v = api.db_version(SQLALCHEMY_DATABASE_URI, SQLALCHEMY_MIGRATE_REPO) api.downgrade(SQLALCHEMY_DATABASE_URI, SQLALCHEMY_MIGRATE_REPO, v - 1) print 'Current database version: ' + str(api.db_version(SQLALCHEMY_DATABASE_URI, SQLALCHEMY_MIGRATE_REPO))</span></span></code> </pre><br><br>  This script will lower the database by one revision.  You can run it multiple times to revert to multiple revisions. <br><br><h4>  Database connections </h4><br>  Relational databases are good at storing links between data items.  Consider the case in which a user writes a post to a blog.  He will have an entry in the user table, and the post will be added to the post table.  The most effective way to write down who wrote this post is to link two related records. <br><br>  After the connection is established between the user and the post, there are two types of requests that we may need.  The most trivial is when you have a post and you need to know which user wrote it.  A slightly more complicated question is the opposite of this.  If you have a user, then you may need to get all the entries written by him.  <code>Flask-SQLAlchemy</code> will help us with both types of queries. <br><br>  Expand our database to store posts so that we can see the connections in action.  To do this, we will return to our design tool DB and create a table of records: <br><img src="https://habrastorage.org/getpro/habr/post_images/aa3/cff/63d/aa3cff63d109e4418fab6fda82f958ed.png"><br><br>  In our table of records will be: id, text of the record and date.  Nothing new.  But the <code>user_id</code> field deserves an explanation. <br><br>  We decided that we want to link the users and the records they write.  The method of implementation is the addition of a field in a post that contains the id of the user who wrote it.  This id is called a foreign key.  Our design tool DB shows foreign keys as the relationship between the key and the id field to which it refers.  This type of communication is called one-to-many (one-to-many), one user writes many posts. <br><br>  Let's change our model to reflect these changes (app / models.py): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> db ROLE_USER = <span class="hljs-number"><span class="hljs-number">0</span></span> ROLE_ADMIN = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(db.Model)</span></span></span><span class="hljs-class">:</span></span> id = db.Column(db.Integer, primary_key = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) nickname = db.Column(db.String(<span class="hljs-number"><span class="hljs-number">64</span></span>), unique = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) email = db.Column(db.String(<span class="hljs-number"><span class="hljs-number">120</span></span>), unique = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) role = db.Column(db.SmallInteger, default = ROLE_USER) posts = db.relationship(<span class="hljs-string"><span class="hljs-string">'Post'</span></span>, backref = <span class="hljs-string"><span class="hljs-string">'author'</span></span>, lazy = <span class="hljs-string"><span class="hljs-string">'dynamic'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;User %r&gt;'</span></span> % (self.nickname) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(db.Model)</span></span></span><span class="hljs-class">:</span></span> id = db.Column(db.Integer, primary_key = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) body = db.Column(db.String(<span class="hljs-number"><span class="hljs-number">140</span></span>)) timestamp = db.Column(db.DateTime) user_id = db.Column(db.Integer, db.ForeignKey(<span class="hljs-string"><span class="hljs-string">'user.id'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;Post %r&gt;'</span></span> % (self.body)</code> </pre><br><br>  We have added a class <code>Post</code> , which will represent the blog entries written by users.  The <code>user_id</code> field in the Post class will be initialized as a foreign key, so <code>Flask-SQLAlchemy</code> knows that this field will be associated with the user. <br><br>  Notice that we also added a new <code>posts</code> field to the <code>User</code> class, which is done like a <code>db.relationship</code> field.  In fact, this is not a DB field, so it is not on our diagram.  For one-to-many <code>db.relationship</code> field <code>db.relationship</code> usually defined on the ‚Äúone‚Äù side.  Through this link, we get a <code>user.posts</code> user, which gives us a list of all user entries.  The first argument, <code>db.relationship</code> refers to the ‚Äúmany‚Äù class in this connection.  The <code>backref</code> argument defines a field that will be added to objects of the "many" class, pointing to the "one" object.  In our case, this means that we can use <code>post.author</code> to get the <code>User</code> instance that created this record.  Do not worry if these details do not make sense to you, we will see examples at the end of this article. <br><br>  Let's write another migration with this change.  Just run: <br><pre> <code class="bash hljs">./db_migrate.py</code> </pre><br><br>  And the script will return: <br><pre> <code class="bash hljs">New migration saved as db_repository/versions/002_migration.py Current database version: 2</code> </pre><br><br>  You do not need to record every small change in the database model as a separate migration, usually the migration is recorded at the release points.  Here we make more migrations than necessary just to show how the migration system works. <br><br><h4>  Start time </h4><br>  We spent a lot of time determining our database, but have not yet seen how it works.  While in our application there is no bd code, we will use our new database in the Python interpreter. <br><br>  Run Python.  On Linux or OS X: <br><pre> <code class="bash hljs">flask/bin/python</code> </pre><br><br>  Or on Windows: <br><pre> <code class="bash hljs">flask\Scripts\python</code> </pre><br><br>  We write the following: <br><pre> <code class="bash hljs">&gt;&gt;&gt; from app import db, models &gt;&gt;&gt;</code> </pre><br><br>  This will cause our database and model memory. <br><br>  Create a new user: <br><pre> <code class="bash hljs">&gt;&gt;&gt; u = models.User(nickname=<span class="hljs-string"><span class="hljs-string">'john'</span></span>, email=<span class="hljs-string"><span class="hljs-string">'john@email.com'</span></span>, role=models.ROLE_USER) &gt;&gt;&gt; db.session.add(u) &gt;&gt;&gt; db.session.commit() &gt;&gt;&gt;</code> </pre><br><br>  Changes in the database are made in the context of the current session.  Multiple changes can be collected in a session, and once they are all registered, you can issue one <code>db.session.commit()</code> that automatically records all changes.  If there is an error while working in the session, the call to <code>db.session.rollback()</code> will return the database to the state before the session is started.  If neither commit nor rollback are called, the system will, by default, roll back the session.  Sessions ensure that the database never stays in an inconsistent state. <br><br>  Add another user: <br><pre> <code class="bash hljs">&gt;&gt;&gt; u = models.User(nickname=<span class="hljs-string"><span class="hljs-string">'susan'</span></span>, email=<span class="hljs-string"><span class="hljs-string">'susan@email.com'</span></span>, role=models.ROLE_USER) &gt;&gt;&gt; db.session.add(u) &gt;&gt;&gt; db.session.commit() &gt;&gt;&gt;</code> </pre><br><br>  Now we can request all our users: <br><pre> <code class="bash hljs">&gt;&gt;&gt; users = models.User.query.all() &gt;&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> users [&lt;User u<span class="hljs-string"><span class="hljs-string">'john'</span></span>&gt;, &lt;User u<span class="hljs-string"><span class="hljs-string">'susan'</span></span>&gt;] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> users: ... <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> u.id,u.nickname ... 1 john 2 susan &gt;&gt;&gt;</code> </pre><br><br>  To do this, we used a custom query that is available for all class models.  Notice how a user id was automatically set for us. <br><br>  Here is another query option.  If we know the user id, we can find the user‚Äôs data as follows: <br><pre> <code class="bash hljs">&gt;&gt;&gt; u = models.User.query.get(1) &gt;&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> u &lt;User u<span class="hljs-string"><span class="hljs-string">'john'</span></span>&gt; &gt;&gt;&gt;</code> </pre><br><br>  Now add a blog entry: <br><pre> <code class="bash hljs">&gt;&gt;&gt; import datetime &gt;&gt;&gt; u = models.User.query.get(1) &gt;&gt;&gt; p = models.Post(body=<span class="hljs-string"><span class="hljs-string">'my first post!'</span></span>, timestamp=datetime.datetime.utcnow(), author=u) &gt;&gt;&gt; db.session.add(p) &gt;&gt;&gt; db.session.commit()</code> </pre><br><br>  Here we set our date in the UTC time zone.  All timestamps stored in our database will be in UTC.  We can have users from all over the world and need to use a single unit of time.  In the future, the guide will show how to display the time in a custom time zone. <br><br>  You may have noticed that we did not set the <code>user_id</code> field in the <code>Post</code> class.  Instead, we store a <code>User</code> object inside our <code>author</code> field.  This virtual field was added by Flask-SQLAlchemy to help with relationships, we defined the name of this field in the backref argument in our model's db.relationship.  With this information, the ORM layer will know how to fill in user_id for us. <br><br>  To end this session, let's look at a few more queries to the database, what can we do: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#     &gt;&gt;&gt; u = models.User.query.get(1) &gt;&gt;&gt; print u &lt;User u'john'&gt; &gt;&gt;&gt; posts = u.posts.all() &gt;&gt;&gt; print posts [&lt;Post u'my first post!'&gt;] #     &gt;&gt;&gt; for p in posts: ... print p.id,p.author.nickname,p.body ... 1 john my first post! #    &gt;&gt;&gt; u = models.User.query.get(2) &gt;&gt;&gt; print u &lt;User u'susan'&gt; &gt;&gt;&gt; print u.posts.all() [] #        &gt;&gt;&gt; print models.User.query.order_by('nickname desc').all() [&lt;User u'susan'&gt;, &lt;User u'john'&gt;] &gt;&gt;&gt;</span></span></code> </pre><br><br>  The Flask-SQLAlchemy documentation is the best place to explore the many options available for querying DB. <br><br>  Before you finish, let's delete the test users and the entries created to start with a clean database in the next chapter: <br><pre> <code class="bash hljs">&gt;&gt;&gt; users = models.User.query.all() &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> users: ... db.session.delete(u) ... &gt;&gt;&gt; posts = models.Post.query.all() &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> posts: ... db.session.delete(p) ... &gt;&gt;&gt; db.session.commit() &gt;&gt;&gt;</code> </pre><br><br><h4>  Conclusion </h4><br>  This is a long guide.  We have learned the basics of working with DB, but have not yet embedded it in our application.  In the next part, we will apply everything that we have learned about databases, in practice, when we consider our login system. <br><br>  Meanwhile, if you do not write the application with us, you can download it in the current version: <br>  <a href="">microblog-0.4.zip</a> <br><br>  Please note that I did not include the database in the zip archive above, but the repository with the migrations there.  To create a new database, simply use db_create.py, then db_upgrade.py, to update the database to the latest revision. <br><br>  Hope to see you! <br><br>  Miguel. </div><p>Source: <a href="https://habr.com/ru/post/196810/">https://habr.com/ru/post/196810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196756/index.html">Listen! - new cloud player for Google Chrome with support for VKontakte and LastFM</a></li>
<li><a href="../196798/index.html">Integrating clouds - create a site-to-site connection between Amazon Web Services and Windows Azure</a></li>
<li><a href="../196802/index.html">Forward for ideas</a></li>
<li><a href="../196806/index.html">2 "simple" questions on Java</a></li>
<li><a href="../196808/index.html">Giant touchscreen Fox News</a></li>
<li><a href="../196812/index.html">Tablet processor - let's talk about Bay Trail</a></li>
<li><a href="../196814/index.html">A short excursion to the opening of the robotics laboratory at the Lyceum in Moscow or the answer to habraposta</a></li>
<li><a href="../196816/index.html">Optimization of web environment on the Jelastic platform for PHP projects</a></li>
<li><a href="../196820/index.html">To entrust the production of electronics: from its own factory to the fabless company</a></li>
<li><a href="../196826/index.html">Lego Specifications Game in Ciklum Odessa, October 16</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>