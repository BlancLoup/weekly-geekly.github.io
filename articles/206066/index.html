<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fuzzy dynamic text search? Not so scary</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is a strong opinion that fuzzy search in dynamics (online) 
 inaccessible due to its incredible complexity. 
 Next, we will dispel this annoying...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fuzzy dynamic text search? Not so scary</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/132/9fd/1f6/1329fd1f6566c35ae7238856584e78f5.jpg" alt="Vladimir Rumyantsev - adventures of St. Petersburg ... cat"><br>  There is a strong opinion that fuzzy search in dynamics (online) <br>  inaccessible due to its incredible complexity. <br>  Next, we will dispel this annoying delusion and show <br>  that build your own search engine with tolerable performance <br>  Not so little data is available to everyone. <br><a name="habracut"></a><br>  The main ideas are: <br><ul><li>  For vocabulary search using trigrams </li><li>  Data storage we trust the DBMS </li><li>  To increase the speed of dictionary search, the dictionary is always in memory. </li><li>  To keep the dictionary up to date, we use triggers. </li></ul><br>  <b>Test data</b> <br>  For the experiments, we take a little Pushkin and Dostoevsky, the ‚ÄúDivine Comedy‚Äù Alighieri and also ‚ÄúWar and Peace‚Äù by Tolstoy in the English translation (source - <a href="http://www.lib.ru/">www.lib.ru</a> &amp; <a href="http://www.gutenberg.org/">www.gutenberg.org</a> ).  Only 18 MB in utf8 encoding. <br>  Each non-empty line of text becomes one record in our database. <br>  If the string is long, it is broken by 800 words. <br>  Total out ~ 160 thousand records <br><br>  <b>DBMS</b> <br>  As <a href="http://habrahabr.ru/post/196682/">before</a> , we will use <a href="http://virtuoso.openlinksw.com/dataspace/doc/dav/wiki/Main/">OpenLink Virtuoso</a> version 7.0.0.  Only one C-plugin can not do, because  functionality available for plugins is not enough.  You will have to connect the server as an OEM shared library (libvirtuoso-t) and at the same time conjure a little with the list of exported functions. <br><br>  <b>Data schema</b> <br>  First, the dictionary: <pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> MRC_WORDS ( WD_ID <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, WD_ITSELF <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>, WD_COUNT <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> (WD_ID));</code> </pre>  Each entry contains the word itself, its identifier and its frequency of occurrence.  Updating the frequency with each text insertion is too expensive, so it changes in memory and is recorded periodically.  Alternatively, it can be updated "by krone".  This frequency may be useful for ranking, but now we will not use it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Trigrams: <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> MRC_TRIPLES ( TR_ID <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>, TR_DATA <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>, TR_WORDID <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>(TR_DATA, TR_WORDID, TR_ID));</code> </pre>  Each entry contains the trigram itself, the identifier of the word from which it came, and a unique identifier in the event that the trigram was encountered in the word several times (Ex: 'Even with a <i>cue</i> ') <br><br>  Lists of occurrence: <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> MRC_DATA ( DT_WORDID <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, DT_OID <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, DT_COL <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, DT_POSITION <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>(DT_WORDID, DT_OID, DT_COL, DT_POSITION));</code> </pre>  Here we store where a word in which position met. <br><br>  Actually the data: <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> MRC_TEXT ( TX_ID <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">identity</span></span>, TX_AUTHOR <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>, TX_SUBJ <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>, TX_STRING <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>, TX_LONG_STRING <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>, TX_TS <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>, primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span> (TX_ID));</code> </pre>  All data in our test problem is stored in one table, in three columns - author, product and text.  If the text is longer than 500 characters, it falls into the blob.  In real life, of course, texts can appear in different tables and our index will turn out to be multiple tables.  How to deal with it is written <a href="http://habrahabr.ru/post/201474/">here</a> . <br><br>  <b>Insert trigger</b> <br>  We will hide the entire indexation inside the trigger on the insert: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> MRC_TEXT_I <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> MRC_TEXT { <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> wordid <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>; str := coalesce(TX_STRING, cast(blob_to_string(TX_LONG_STRING)as nvarchar)); MRC_PROCESS_STR_I(str, TX_ID, 1); str := TX_SUBJ; MRC_PROCESS_STR_I(str, TX_ID, 2); str := TX_AUTHOR; MRC_PROCESS_STR_I(str, TX_ID, 3); };</code> </pre>  Those.  we call the <i>MRC_PROCESS_STR_I</i> function three times for each of the indexed fields: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> MRC_PROCESS_STR_I( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">col</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">str</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> vec <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>; vec := nv_split(str); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> wordid <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>; if (vec &lt;&gt; 0 and vec is not null) { n := length(vec); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; i := 0; while (i &lt; n) { wordid := treat_nword(vec[i])); if (wordid &gt; 0) { <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> MRC_DATA (DT_WORDID, DT_OID, DT_COL, DT_POSITION) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (wordid, <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">col</span></span>, i); } i := i + 1; } } } };</code> </pre>  Here we split the string into individual words using the <i>nv_split</i> function, process each word with a <i>treat_nword,</i> and write data about each word into the <i>MRC_DATA</i> table. <br>  The <i>nv_split</i> and <i>treat_nword mentioned</i> are written (for this task) in C and are accessible via the plug-in interface. <br>  With the first, everything is clear, and the second must parse the word into trigrams, write them into the appropriate table, write the word into the table of words, and update the dictionary in memory. <br><br>  <b>Dictionary in memory</b> <br>  Consists of the following entities: <br><ul><li>  <i>ht_dict_</i> - hash-map, which knows how to get its number from the utf8 representation of a word </li><li>  <i>ht_dict_by_id_</i> - hash-map, which by its word number is obtained by its descriptor </li><li>  <i>ht_triples_</i> - hash-map, in which, by the utf8 value of the trigram, we get the head of the list of all identifiers of the words in which this trigram is encountered </li></ul>  Separately, it should be noted that when splitting a word into trigrams, spaces are added to the beginning and end of the word, thus providing bonuses for the correct beginning and / or end of the word. <br><br>  <b>Vocabulary Search</b> <br>  The result of the dictionary search is a list of candidates and their similarity to the submitted sample. <br>  The algorithm is as follows: <ul><li>  we normalize a word, for example, we reduce to an uppercase </li><li>  add spaces to the beginning and end of the word and break what happened into trigrams </li><li>  for each trigram we find a list of words where she met </li><li>  and for each such word we increase the reference count </li><li>  after processing the trigrams, we leave only words for which the number of links is above a certain threshold, <br>  the threshold in this case is half of the maximum number of links + 1 </li><li>  for all the remaining words, we calculate their similarity to the original word, in this case the Levenshtein distance is used with an additional bonus for the correct beginning of the word </li><li>  sort the list of words by ids </li></ul><br>  <b>Structural Search</b> <br>  The task of the structural search in our case is based on the lists of candidates issued by the dictionary search to form a list of identifiers of records in which the candidates of all the original words met. <br>  As long as there is relatively little data, like, for example, with us, you can not particularly care about the amount of allocated memory and simply load all the identifiers of strings for vocabulary candidates of interest.  So: <br><ul><li>  For each query word we have a list of candidates. </li><li>  find the identifiers of all the records where these candidates met and are listed </li><li>  sort the list </li><li>  intersect the lists of all the source words and get the result - a list of record identifiers, where all the source words met </li></ul>  Suppose there are too many data to hold in memory all identifiers.  In this case, we: <br><ul><li>  Using the fact that the lists of occurrences are sorted by DT_WORDID, DT_OID, ..., we can cheaply download data not entirely, but only in a range of identifiers </li><li>  sort this partial data </li><li>  cross lists, getting partial results </li><li>  get on to the next batch </li></ul>  We note separately that if any vocabulary candidate is found everywhere more than once, it is possible that this rubbish word should simply be ignored. <br><br>  <b>Ranging</b> <br>  We will use a rather primitive ranking scheme: <br><ul><li>  the vocabulary part of the estimate ( <i>SCORE</i> ) will be obtained by multiplying the normalized estimates for individual hits </li><li>  the positional part of the assessment ( <i>POS</i> ) will be obtained by averaging the absolute distances of the position of the current hit from the position of the previous one (meaning the position of the hit word in the text of the record) </li><li>  final score is <i>SCORE / (1 + sqrt (POS / 5))</i> </li></ul><br>  <b>Search through PL / SQL</b> <br>  To organize the flow of primary identifiers to use our search in regular SQL, we need the following procedure and procedural view to access it: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> MRC_QUERY_STRING_ALL ( <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">query</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> vec <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">len</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; result_names('oid','score'); vec := query_phrase(query); if (vec &lt;&gt; 0 and vec is not null) { len := length(vec); <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; i := 0; while(i&lt;len) { <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>; oid := vec[i]; result (oid, vec[i + 1]); i := i + 2; } } }; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> v_query_phrase_all <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MRC_QUERY_STRING_ALL(<span class="hljs-keyword"><span class="hljs-keyword">str</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">oid</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, score <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>);</code> </pre><br>  The request may now look like: <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.TX_ID, a.TX_TS, b.score, a.TX_AUTHOR, a.TX_SUBJ, <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span> (a.TX_STRING, blob_to_string(TX_LONG_STRING)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> MRC_TEXT <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a, v_query_phrase_all <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b.str = <span class="hljs-string"><span class="hljs-string">'Posting Date'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> a.TX_ID = b.oid;</code> </pre>  The <i>query_phrase</i> function <i>used</i> is With an extension and performs all of the low-level activity mentioned above. <br><br>  <b>Benchmark</b> <br>  i7-3612QM, Win64. <br>  Filling 160,254 records takes 3 minutes 2 seconds or 1.14 ms to write. <br>  To test the search, we will look for the first two words in each record, a total of 160,254 search queries in 1, 2 and 4 threads.  We will search only for the number of records found, in order not to take into account the time for lifting and passing lines.  Requests are executed through the native ODBC interface, TCP / IP through localhost. <br><table><tbody><tr><th>  N threads </th><th>  Total time </th><th>  1 request </th></tr><tr><td>  one </td><td>  11'7 " </td><td>  4.16 ms </td></tr><tr><td>  2 </td><td>  11'57 '' </td><td>  4.47 ms </td></tr><tr><td>  four </td><td>  14'51 </td><td>  5.61 ms </td></tr></tbody></table>  <b><s>Conclusions</s> Morality</b> <br>  Create, invent, try!  (C) Mayakovsky <br><br>  <b>PS</b> : <br><div class="spoiler">  <b class="spoiler_title">Texts With features, suddenly someone come in handy</b> <div class="spoiler_text">  #include &lt;stdio.h&gt; <br>  #include &lt;stdlib.h&gt; <br>  #include &lt;string.h&gt; <br><br>  #include &lt;libutil.h&gt; <br><br>  #ifdef WIN32 <br>  #include &lt;crtdbg.h&gt; <br>  #endif <br><br>  #include "sqlnode.h" <br>  #include "sqlbif.h" <br>  #include "wi.h" <br>  #include "Dk.h" <br><br>  #include &lt;math.h&gt; <br>  #include "caseutils.h" <br>  #include "list_sort.h" <br>  #include &lt;assert.h&gt; <br><br>  // # include &lt;ksrvext.h&gt; <br><br>  static id_hash_t * ht_dict_ = NULL; <br>  static dk_hash_t * ht_dict_by_id_ = NULL; <br>  static id_hash_t * ht_triples_ = NULL; <br>  static dk_mutex_t * dict_mtx_ = NULL; <br><br>  struct dict_item_s { <br>  char * word_; <br>  size_t id_; <br>  size_t count_; <br>  size_t attr_; <br>  }; <br>  typedef struct dict_item_s dict_item_t; <br><br>  struct triple_item_s { <br>  size_t wordid_; <br>  struct triple_item_s * next_; <br>  }; <br>  typedef struct triple_item_s triple_item_t; <br><br>  struct triple_head_s { <br>  lenmem_t lm_; <br>  wchar_t data_ [4]; <br>  triple_item_t * list_; <br>  }; <br>  typedef struct triple_head_s triple_head_t; <br><br>  const wchar_t seps_ [] = L ",. \ t \ r \ n '\" = *!% ^ :; ~ `&lt;&gt; + |?"; <br>  const wchar_t glues_ [] = L "() &amp; @ # $: {} / \\ - [] _"; <br><br>  size_t next_wordid (caddr_t * qst) <br>  { <br>  size_t _id = 0; <br>  query_instance_t * q = (query_instance_t *) qst; <br>  client_connection_t * cli = q-&gt; qi_client; <br>  query_t * stmt = NULL; <br>  local_cursor_t * lc = NULL; <br>  caddr_t lerr = NULL; <br>  caddr_t * err = &amp; lerr; <br>  char buf [1024]; <br>  sprintf (buf, "select sequence_next ('MRC_WORD_ID')"); <br>  if (NULL == (stmt = sql_compile (buf, cli, err, 0))) <br>  goto end; <br><br>  if (NULL! = (* err = <br>  qr_rec_exec (stmt, cli, &amp; lc, (query_instance_t *) qst, NULL, <br>  0))) <br>  goto end; <br><br>  end: <br>  if (lc) <br>  { <br>  lc_next (lc); <br>  _id = (size_t) unbox (lc_nth_col (lc, 0)); <br>  } <br>  if (lc) <br>  { <br>  lc_free (lc); <br>  lc = NULL; <br>  } <br>  if (stmt) <br>  { <br>  qr_free (stmt); <br>  stmt = NULL; <br>  } <br>  return _id; <br>  } <br><br>  size_t store_triple (caddr_t * qst, size_t wordid, const wchar_t * triple) <br>  { <br>  query_instance_t * q = (query_instance_t *) qst; <br>  client_connection_t * cli = q-&gt; qi_client; <br>  query_t * stmt = NULL; <br>  local_cursor_t * lc = NULL; <br>  caddr_t lerr = NULL; <br>  caddr_t * err = &amp; lerr; <br>  char buf [1024]; <br>  wchar_t wlt [4]; <br>  wcsncpy (wlt, triple, 3); <br>  wlt [3] = 0; <br><br>  sprintf (buf, "--utf8_execs = yes \ n insert into MRC_TRIPLES (TR_DATA, TR_WORDID) values ‚Äã‚Äã(?,?)"); <br>  if (NULL == (stmt = sql_compile (buf, cli, err, 0))) <br>  goto end; <br><br>  if (NULL! = (* err = <br>  qr_rec_exec (stmt, cli, &amp; lc, (query_instance_t *) qst, NULL, 2, <br>  ": 0", box_wide_string (wlt), QRP_RAW, <br>  ": 1", box_num (wordid), QRP_RAW <br>  ))) <br>  goto end; <br>  { <br>  char ** place = NULL; <br><br>  triple_item_t * pitem = (triple_item_t *) dk_alloc_box_zero (sizeof (triple_item_t), DV_BIN); <br>  triple_head_t * phead = (triple_head_t *) dk_alloc_box_zero (sizeof (triple_head_t), DV_BIN); <br><br>  phead-&gt; lm_.lm_length = sizeof (phead-&gt; data_); <br>  phead-&gt; lm_.lm_memblock = (char *) phead-&gt; data_; <br>  memcpy (phead-&gt; data_, wlt, sizeof (phead-&gt; data_)); <br><br>  pitem-&gt; wordid_ = wordid; <br><br>  place = (char **) id_hash_get (ht_triples_, (caddr_t) &amp; phead-&gt; lm_); <br>  if (place) <br>  { <br>  triple_head_t * ohead = * (triple_head_t **) place; <br>  pitem-&gt; next_ = ohead-&gt; list_; <br>  ohead-&gt; list_ = pitem; <br>  } <br>  else <br>  { <br>  id_hash_set (ht_triples_, (caddr_t) (&amp; phead-&gt; lm_), (caddr_t) &amp; phead); <br>  pitem-&gt; next_ = pitem; <br>  } <br>  } <br><br>  end: <br>  if (lc) <br>  { <br>  lc_free (lc); <br>  lc = NULL; <br>  } <br>  if (stmt) <br>  { <br>  qr_free (stmt); <br>  stmt = NULL; <br>  } <br>  return 0; <br>  } <br><br>  wchar_t ** <br>  nv_split (wchar_t * tmp) <br>  { <br>  wchar_t ** arr = NULL; <br>  size_t len ‚Äã‚Äã= wcslen (tmp); <br>  size_t ix = 0; <br>  size_t i; <br>  size_t cnt = 0; <br>  for (i = 0; i &lt;len; i ++) <br>  { <br>  if (NULL! = wcschr (seps_, tmp [i])) <br>  { <br>  tmp [ix ++] = 0; <br>  cnt ++; <br>  } <br>  else <br>  { <br>  if (NULL == wcschr (glues_, tmp [i])) <br>  tmp [ix ++] = mrc_toupper (tmp [i]); <br>  } <br>  } <br>  tmp [ix] = 0; <br>  cnt = 0; <br>  for (i = 0; i &lt;len; i ++) <br>  { <br>  if (tmp [i]) <br>  { <br>  cnt ++; <br>  while (i &lt;len &amp;&amp; 0! = tmp [++ i]); <br>  } <br>  } <br>  if (cnt) <br>  { <br>  / * And allocate a vector of once or twice of that many elements.  * / <br>  arr = dk_alloc_box ((cnt * sizeof (caddr_t)), DV_ARRAY_OF_POINTER); <br><br>  ix = 0; <br>  for (i = 0; i &lt;len; i ++) <br>  { <br>  if (0! = tmp [i]) <br>  { <br>  int loclen = wcslen (tmp + i); <br>  ((caddr_t *) arr) [ix] = ((char *) dk_alloc_box_zero ((loclen + 1) * sizeof (wchar_t), DV_LONG_WIDE)); <br>  memcpy (((caddr_t *) arr) [ix ++], tmp + i, (loclen + 1) * sizeof (wchar_t)); <br>  while (i &lt;len &amp;&amp; 0! = tmp [++ i]); <br>  } <br>  } <br>  } <br>  return arr; <br>  } <br><br>  caddr_t <br>  bif_nv_split (caddr_t * qst, caddr_t * err_ret, state_slot_t ** args) <br>  { <br>  char * me = "nv_split"; <br>  caddr_t arr = NULL; <br>  caddr_t arg = bif_arg_unrdf (qst, args, 0, me); <br>  dtp_t dtp = DV_TYPE_OF (arg); <br>  if (DV_DB_NULL == dtp || NULL == arg) <br>  { <br>  return (NULL); <br>  } <br>  if (IS_STRING_DTP (dtp)) <br>  { <br>  wchar_t * wide = box_utf8_as_wide_char (arg, NULL, strlen (arg), 0, DV_WIDE); <br>  arr = (caddr_t) nv_split (wide); <br>  dk_free_box (wide); <br>  return arr; <br>  } <br>  if (IS_WIDE_STRING_DTP (dtp)) <br>  { <br>  wchar_t * tmp = wcsdup ((const wchar_t *) arg); <br>  arr = (caddr_t) nv_split (tmp); <br>  free (tmp); <br>  return arr; <br>  } <br><br>  { <br>  sqlr_new_error ("22023", "SR007", <br>  ‚ÄúFunction% s needs a nvstring or NULL as argument,‚Äû <br>  ‚ÄúNot an arg of type% s (% d)‚Äù, <br>  me, 1, dv_type_title (dtp), dtp); <br>  } <br>  return arr; <br>  } <br><br>  caddr_t <br>  bif_treat_nword (caddr_t * qst, caddr_t * err_ret, state_slot_t ** args) <br>  { <br>  char * me = "treat_nword"; <br>  caddr_t arg = bif_arg_unrdf (qst, args, 0, me); <br>  int len; <br>  const wchar_t * wide = (const wchar_t *) arg; <br>  const wchar_t * newwide = NULL; <br>  wchar_t * tmpbuf; <br>  size_t wordid = 0; <br>  dtp_t dtp = DV_TYPE_OF (arg); <br>  if (DV_DB_NULL == dtp) <br>  { <br>  return (NULL); <br>  } <br>  if (! IS_WIDE_STRING_DTP (dtp)) <br>  { <br>  sqlr_new_error ("22023", "SR007", <br>  ‚ÄúFunction% s needs a nvstring or NULL as argument,‚Äû <br>  ‚ÄúNot an arg of type% s (% d)‚Äù, <br>  me, 1, dv_type_title (dtp), dtp); <br>  } <br>  len = wcslen (wide); <br>  tmpbuf = (wchar_t *) _ alloca (sizeof (wchar_t) * (len + 3)); <br>  tmpbuf [0] = L "; <br>  wcscpy (tmpbuf + 1, wide); <br>  tmpbuf [len + 1] = L "; <br>  tmpbuf [len + 2] = 0; <br>  newwide = tmpbuf; <br><br>  mutex_enter (dict_mtx_); <br>  { <br>  char * utf8 = box_wide_as_utf8_char ((const char *) wide, len, DV_LONG_STRING); <br>  char ** place = NULL; <br><br>  place = (char **) id_hash_get (ht_dict_, (caddr_t) &amp; utf8); <br>  if (place) <br>  { <br>  dict_item_t * pitem = * (dict_item_t **) place; <br>  pitem-&gt; count _ ++; <br>  dk_free_box (utf8); <br>  wordid = pitem-&gt; id_; <br>  } <br>  else <br>  { <br>  query_instance_t * q = (query_instance_t *) qst; <br>  client_connection_t * cli = q-&gt; qi_client; <br>  query_t * stmt = NULL; <br>  local_cursor_t * lc = NULL; <br>  caddr_t lerr = NULL; <br>  caddr_t * err = &amp; lerr; <br>  char buf [1024]; <br><br>  dict_item_t * pitem = dk_alloc_box_zero (sizeof (dict_item_t), DV_BIN); <br>  pitem-&gt; word_ = utf8; <br>  pitem-&gt; count_ = 1; <br>  wordid = next_wordid (qst); <br>  pitem-&gt; id_ = wordid; <br>  id_hash_set (ht_dict_, (caddr_t) &amp; utf8, (caddr_t) &amp; pitem); <br>  sethash ((void *) wordid, ht_dict_by_id_, (void *) pitem); <br><br>  sprintf (buf, "--utf8_execs = yes \ n insert into MRC_WORDS (WD_ITSELF, WD_ID) values ‚Äã‚Äã(?,?)"); <br>  // cast (charset_recode ('% s', 'UTF-8', '_WIDE_') as nvarchar)) ", wordid, utf8); <br>  if (NULL! = (stmt = sql_compile (buf, cli, err, 0))) <br>  { <br>  * err = <br>  qr_rec_exec (stmt, cli, &amp; lc, (query_instance_t *) qst, NULL, 2, <br>  ": 0", box_wide_string (newwide), QRP_RAW, <br>  ": 1", box_num (wordid), QRP_RAW <br>  ); <br>  // * err = qr_rec_exec (stmt, cli, &amp; lc, (query_instance_t *) qst, NULL, 0); <br>  } <br>  if (lc) <br>  lc_free (lc); <br>  if (stmt) <br>  qr_free (stmt); <br><br>  { <br>  int len ‚Äã‚Äã= wcslen (newwide); <br>  int i; <br>  for (i = 0; i &lt;len-2; i ++) <br>  { <br>  store_triple (qst, wordid, newwide + i); <br>  } <br>  } <br>  } <br>  } <br>  mutex_leave (dict_mtx_); <br>  return box_num (wordid); <br>  } <br><br>  int64 <br>  box2long (caddr_t arg) <br>  { <br>  dtp_t dtp = DV_TYPE_OF (arg); <br>  if (dtp == DV_SHORT_INT || dtp == DV_LONG_INT) <br>  return (int64) (unbox (arg)); <br>  else if (dtp == DV_SINGLE_FLOAT) <br>  return (int64) (unbox_float (arg)); <br>  else if (dtp == DV_DOUBLE_FLOAT) <br>  return (int64) (unbox_double (arg)); <br>  else if (dtp == DV_NUMERIC) <br>  { <br>  int64 dt; <br>  numeric_to_int64 ((numeric_t) arg, &amp; dt); <br>  return dt; <br>  } <br>  else if (dtp == DV_DB_NULL) <br>  return (int64) (0); <br>  assert (0); <br>  return 0; <br>  } <br><br>  void flush_dict () <br>  { <br>  char ** key = NULL; <br>  char ** val = NULL; <br>  id_hash_iterator_t hit; <br>  id_hash_iterator (&amp; hit, ht_dict_); <br>  while (hit_next (&amp; hit, (caddr_t *) &amp; key, (caddr_t *) &amp; val)) <br>  { <br>  dk_free_box (* key); <br>  dk_free_box (* val); <br>  } <br>  id_hash_clear (ht_dict_); <br>  } <br><br>  void flush_triples () <br>  { <br>  char ** key = NULL; <br>  char ** val = NULL; <br>  id_hash_iterator_t hit; <br>  id_hash_iterator (&amp; hit, ht_triples_); <br>  while (hit_next (&amp; hit, (caddr_t *) &amp; key, (caddr_t *) &amp; val)) <br>  { <br>  triple_head_t * phead = * (triple_head_t **) val; <br>  triple_item_t * pit = phead-&gt; list_; <br><br>  while (pit) <br>  { <br>  triple_item_t * tmp = pit-&gt; next_; <br>  dk_free_box (pit); <br>  pit = tmp; <br>  } <br>  dk_free_box (* val); <br>  } <br>  id_hash_clear (ht_triples_); <br>  } <br><br>  size_t reload_triples (query_instance_t * qst) <br>  { <br>  client_connection_t * cli = qst-&gt; qi_client; <br>  query_t * stmt = NULL; <br>  local_cursor_t * lc = NULL; <br>  caddr_t lerr = NULL; <br>  caddr_t * err = &amp; lerr; <br>  char buf [1024]; <br><br>  flush_triples (); <br><br>  sprintf (buf, "select TR_DATA, TR_WORDID from MRC_TRIPLES"); <br>  if (NULL! = (stmt = sql_compile (buf, cli, err, 0))) <br>  { <br>  * err = qr_rec_exec (stmt, cli, &amp; lc, (query_instance_t *) qst, NULL, 0); <br>  if (lc) <br>  { <br>  int64 id = 0; <br>  caddr_t tmp = 0; <br>  int64 cnt = 0; <br>  char * utf8 = NULL; <br>  char ** place = NULL; <br>  lenmem_t lm; <br>  triple_head_t * phead = NULL; <br>  triple_head_t * ohead = NULL; <br>  triple_item_t * pitem = NULL; <br><br>  while (lc_next (lc)) <br>  { <br>  if (lc-&gt; lc_error) <br>  { <br>  * err = box_copy_tree (lc-&gt; lc_error); <br>  break; <br>  } <br>  id = box2long (lc_nth_col (lc, 1)); <br>  tmp = lc_nth_col (lc, 0); <br><br>  pitem = (triple_item_t *) dk_alloc_box_zero (sizeof (triple_item_t), DV_BIN); <br>  pitem-&gt; wordid_ = (size_t) id; <br><br>  lm.lm_length = sizeof (phead-&gt; data_); <br>  lm.lm_memblock = (caddr_t) tmp; <br><br>  place = (char **) id_hash_get (ht_triples_, (caddr_t) &amp; lm); <br>  if (place) <br>  { <br>  ohead = * (triple_head_t **) place; <br>  pitem-&gt; next_ = ohead-&gt; list_; <br>  ohead-&gt; list_ = pitem; <br>  } <br>  else <br>  { <br>  phead = (triple_head_t *) dk_alloc_box_zero (sizeof (triple_head_t), DV_BIN); <br>  phead-&gt; list_ = pitem; <br>  phead-&gt; lm_.lm_length = sizeof (phead-&gt; data_); <br>  phead-&gt; lm_.lm_memblock = (caddr_t) phead-&gt; data_; <br>  memcpy (phead-&gt; data_, tmp, sizeof (phead-&gt; data_)); <br><br>  pitem-&gt; next_ = NULL; <br>  id_hash_set (ht_triples_, (caddr_t) &amp; phead-&gt; lm_, (caddr_t) &amp; phead); <br>  } <br>  } <br>  } <br>  } <br>  if (lc) <br>  lc_free (lc); <br>  if (stmt) <br>  qr_free (stmt); <br><br>  return 0; <br>  } <br><br>  caddr_t <br>  bif_reload_dict (caddr_t * qst, caddr_t * err_ret, state_slot_t ** args) <br>  { <br>  query_instance_t * q = (query_instance_t *) qst; <br>  client_connection_t * cli = q-&gt; qi_client; <br>  query_t * stmt = NULL; <br>  local_cursor_t * lc = NULL; <br>  caddr_t lerr = NULL; <br>  caddr_t * err = &amp; lerr; <br>  char buf [1024]; <br><br>  mutex_enter (dict_mtx_); <br>  flush_dict (); <br><br>  sprintf (buf, "select WD_ID, WD_ITSELF, WD_COUNT from MRC_WORDS"); <br>  if (NULL! = (stmt = sql_compile (buf, cli, err, 0))) <br>  { <br>  * err = qr_rec_exec (stmt, cli, &amp; lc, (query_instance_t *) qst, NULL, 0); <br>  if (lc) <br>  { <br>  int64 id = 0; <br>  caddr_t tmp = 0; <br>  int64 cnt = 0; <br>  char * utf8 = NULL; <br>  char ** place = NULL; <br>  size_t maxid = 0; <br><br>  while (lc_next (lc)) <br>  { <br>  if (lc-&gt; lc_error) <br>  { <br>  * err = box_copy_tree (lc-&gt; lc_error); <br>  break; <br>  } <br>  id = box2long (lc_nth_col (lc, 0)); <br>  tmp = lc_nth_col (lc, 1); <br>  cnt = box2long (lc_nth_col (lc, 2)); <br>  utf8 = box_wide_as_utf8_char (tmp, box_length (tmp) / sizeof (wchar_t) - 1, DV_LONG_STRING); <br><br>  place = (char **) id_hash_get (ht_dict_, (caddr_t) &amp; utf8); <br>  if (place) <br>  { <br>  assert (0); <br>  } <br>  else <br>  { <br>  dict_item_t * pitem = dk_alloc_box_zero (sizeof (dict_item_t), DV_BIN); <br>  pitem-&gt; word_ = utf8; <br>  pitem-&gt; count_ = 1; <br>  pitem-&gt; id_ = (size_t) id; <br>  if (maxid &lt;id) <br>  maxid = id; <br>  id_hash_set (ht_dict_, (caddr_t) &amp; utf8, (caddr_t) &amp; pitem); <br>  sethash ((void *) id, ht_dict_by_id_, (void *) pitem); <br>  } <br>  } <br>  } <br>  } <br>  if (lc) <br>  lc_free (lc); <br>  if (stmt) <br>  qr_free (stmt); <br><br>  reload_triples (q); <br><br>  mutex_leave (dict_mtx_); <br>  return 0; <br>  } <br><br>  // ------------------------------------------------ --------------------------- <br>  // l_dist_raw () <br>  // static / local function !!! <br>  // <br>  // Purpose: Calculate the distance for the two strings (words). <br>  // <br>  // Inputs: char * str1, * str2 - input strings (words) to compair <br>  // int len1, len2 - amd str2 <br>  // respectively or MAX_LDIST_LEN. <br>  // NOTE!  No error checking is done. <br>  // Array overflow <br>  // if either is out of range. <br>  // Outputs: none <br>  // <br>  // Returns: L Distance value is returned <br>  // <br>  // Note, there are two options immediately after this comment header that <br>  // are only used by this function. <br>  // <br>  // (values ‚Äã‚Äãin all CAPS are defined in the LDIST.H header file) <br>  // <br>  // ------------------------------------------------ --------------------------- <br>  #define MAX_LDIST_LEN 40 // max word len to compair <br>  #define MIN3 (a, b, c) (a &lt;b? \ <br>  (a &lt;c? a: c): \ <br>  (b &lt;c? b: c)) <br><br>  int <br>  l_dist_raw (const wchar_t * str1, const wchar_t * str2, int len1, int len2) <br>  { <br>  int arr1 [MAX_LDIST_LEN + 1]; <br>  int arr2 [MAX_LDIST_LEN + 1]; <br>  int i, j; <br>  if (len1&gt; MAX_LDIST_LEN) <br>  len1 = MAX_LDIST_LEN; <br>  if (len2&gt; MAX_LDIST_LEN) <br>  len2 = MAX_LDIST_LEN; <br>  for (i = 0; i &lt;= len2; i ++) <br>  arr1 [i] = i; <br><br>  for (i = 1; i &lt;= len1; i ++) <br>  { <br>  arr2 [0] = i; <br>  for (j = 1; j &lt;= len2; j ++) <br>  { <br>  int score = (str1 [i-1] == str2 [j-1])? 0: 1; <br>  int i1 = arr2 [j-1] +1; <br>  int i2 = arr1 [j] +1; <br>  int i3 = arr1 [j-1] + score; <br>  arr2 [j] = MIN3 (i1, i2, i3); // arr2 [j-1] +1, arr1 [j] +1, arr1 [j] + score); <br>  // d [(j-1) * n + i] +1, d [j * n + i-1] +1, d [(j-1) * n + i-1] + cost); <br>  } <br>  memcpy (arr1, arr2, sizeof (int) * (len2 + 1)); <br>  } <br>  return arr2 [len2]; <br>  } <br><br>  struct ipair_s { <br>  ptrlong id_; <br>  ptrlong len_; <br>  ptrlong pos_; <br>  ptrlong score_; <br>  }; <br>  typedef struct ipair_s ipair_t; <br><br>  int <br>  cmp_pairs (const void * a, const void * b) <br>  { <br>  const ipair_t * pa = * (const ipair_t **) a; <br>  const ipair_t * pb = * (const ipair_t **) b; <br>  if (pb-&gt; id_ == pa-&gt; id_) <br>  return pa-&gt; score_ - pb-&gt; score_; <br>  return pa-&gt; id_ - pb-&gt; id_; <br>  } <br><br>  int compare_by_id (const void * a, const void * b, const void * arg) <br>  { <br>  ipair_t * pa = (ipair_t *) a; <br>  ipair_t * pb = (ipair_t *) b; <br>  return pa-&gt; id_ - pb-&gt; id_; <br>  } <br><br>  int compare_by_score (const void * a, const void * b, const void * arg) <br>  { <br>  ipair_t * pa = (ipair_t *) a; <br>  ipair_t * pb = (ipair_t *) b; <br>  return pb-&gt; score_ - pa-&gt; score_; <br>  } <br><br>  dk_set_t <br>  load_oid_list (ipair_t ** words, query_instance_t * q, mem_pool_t * mp) <br>  { <br>  client_connection_t * cli = q-&gt; qi_client; <br>  / * static * / query_t * stmt = NULL; <br>  local_cursor_t * lc = NULL; <br>  caddr_t lerr = NULL; <br>  caddr_t * err = &amp; lerr; <br>  dk_set_t out_list = NULL; <br>  char buf [1024]; <br>  dk_set_t pairs_list = NULL; <br>  ipair_t * item = NULL; <br>  size_t i = 0; <br>  size_t len ‚Äã‚Äã= box_length (words) / sizeof (ipair_t *); <br>  size_t cnt = 0; <br><br>  if (NULL == stmt) <br>  { <br>  sprintf (buf, ‚Äúselect DT_OID, DT_POSITION from MRC_DATA where DT_WORDID =?‚Äû); <br>  if (NULL == (stmt = sql_compile_static (buf, / * bootstrap _ * / cli, err, 0))) <br>  return NULL; <br>  } <br>  for (i = 0; i &lt;len; i ++) <br>  { <br>  size_t id; <br>  ipair_t * pair = words [i]; <br>  // printf (‚Äú\ n ---% d ----- \ n‚Äù, pair-&gt; id_); <br>  * err = qr_rec_exec (stmt, cli, &amp; lc, (query_instance_t *) q, NULL, 1, <br>  ": 0", box_num (pair-&gt; id_), QRP_RAW); <br>  if (NULL == lc) <br>  continue; <br><br>  while (lc_next (lc)) <br>  { <br>  if (lc-&gt; lc_error) <br>  { <br>  * err = box_copy_tree (lc-&gt; lc_error); <br>  break; <br>  } <br>  id = box2long (lc_nth_col (lc, 0)); <br>  item = (ipair_t *) mp_alloc_box (mp, sizeof (ipair_t), DV_ARRAY_OF_LONG); <br>  item-&gt; id_ = id; <br>  item-&gt; len_ = pair-&gt; len_; <br>  item-&gt; pos_ = box2long (lc_nth_col (lc, 1)); <br>  item-&gt; score_ = pair-&gt; score_; <br>  mp_set_push (mp, &amp; pairs_list, item); <br>  cnt ++; <br>  // printf ("% d", id); <br>  } <br>  if (lc) <br>  lc_free (lc); <br>  } <br>  if (stmt) <br>  qr_free (stmt); <br><br>  // if (stmt) <br>  // qr_free (stmt); <br>  // printf ("+% d +", cnt); <br>  return list_sort (pairs_list, compare_by_id, NULL); <br>  } <br><br>  ipair_t ** <br>  get_word_candidates (wchar_t * arg) <br>  { <br>  ipair_t ** res = NULL; <br>  dk_set_t ids_list = NULL; <br>  caddr_t arr = NULL; <br><br>  { <br>  dk_hash_t * ht_ids = NULL; <br>  int maxcount = 1; <br>  size_t i; <br><br>  wchar_t * word = (wchar_t *) arg; <br>  wchar_t * pbuf = NULL; <br>  size_t isnum = ((* word)&gt; = L'0 '&amp;&amp; (* word) &lt;= L'9'); <br>  size_t len ‚Äã‚Äã= wcslen (word); <br>  // int slen = len; <br>  if (len &lt;3 &amp;&amp;! isnum) <br>  { <br>  return NULL; <br>  } <br>  word = (wchar_t *) box_copy (word); <br>  mrc_toupper_str (word); <br><br>  pbuf = (wchar_t *) _ alloca (sizeof (wchar_t) * (len + 3)); <br>  pbuf [0] = L "; <br>  wcscpy (pbuf + 1, word); <br>  pbuf [len + 1] = L "; <br>  pbuf [len + 2] = L '\ 0'; <br><br>  ht_ids = hash_table_allocate (101); <br><br>  mutex_enter (dict_mtx_); <br>  for (i = 0; i &lt;(len); i ++) <br>  { <br>  char ** place = NULL; <br>  lenmem_t lm; <br>  triple_head_t * phead = NULL; <br>  triple_item_t * pitem = NULL; <br>  wchar_t trbuf [4]; <br>  trbuf [0] = mrc_toupper (pbuf [i]); <br>  trbuf [1] = mrc_toupper (pbuf [i + 1]); <br>  trbuf [2] = mrc_toupper (pbuf [i + 2]); <br>  trbuf [3] = L '\ 0'; <br><br>  lm.lm_length = sizeof (phead-&gt; data_); <br>  lm.lm_memblock = (caddr_t) trbuf; <br><br>  place = (char **) id_hash_get (ht_triples_, (caddr_t) &amp; lm); <br>  if (place) <br>  { <br>  phead = * (triple_head_t **) place; <br>  pitem = phead-&gt; list_; <br>  while (pitem) <br>  { <br>  int wordid = pitem-&gt; wordid_; <br><br>  int ptr = (int) gethash ((void *) wordid, ht_ids); <br>  if (0 == ptr) <br>  sethash ((void *) wordid, ht_ids, (void *) 1); <br>  else <br>  { <br>  sethash ((void *) wordid, ht_ids, (void *) (++ ptr)); <br>  if (ptr&gt; maxcount) <br>  maxcount = ptr; <br>  } <br><br>  pitem = pitem-&gt; next_; <br>  } <br>  } <br>  } <br>  mutex_leave (dict_mtx_); <br><br>  { <br>  dk_set_t pairs_list = NULL; <br>  int nids = 0; <br>  int mx = maxcount; <br>  int nallids = ht_ids-&gt; ht_count; <br>  void * key, * val; <br>  dk_hash_iterator_t hit; <br><br>  maxcount = (maxcount + 1) / 2; <br>  if (maxcount&gt; = len) <br>  maxcount = len - 1; <br>  for (dk_hash_iterator (&amp; hit, ht_ids); <br>  dk_hit_next (&amp; hit, (void **) &amp; key, (void **) &amp; val); <br>  / * * /) <br>  { <br>  int wordid = (int) key; <br>  int cnt = (int) val; <br>  if (cnt&gt; = maxcount) <br>  { <br>  dict_item_t * pptr = (dict_item_t *) gethash ((void *) wordid, ht_dict_by_id_); <br>  if (pptr) <br>  { <br>  ipair_t * item = NULL; <br>  wchar_t buf [128]; <br>  size_t lbuf, dist, score; <br>  box_utf8_as_wide_char ((caddr_t) pptr-&gt; word_, (caddr_t) buf, strlen (pptr-&gt; word_), 127, DV_WIDE); <br>  lbuf = wcslen (buf); <br>  dist = l_dist_raw (word, buf, len, lbuf); <br>  score = 100 - (dist * 100) / ((len&gt; lbuf)? len: lbuf); <br>  // score = 100 - (dist * 200) / (len + lbuf); <br>  if (word [0]! = buf [0]) <br>  score = (score * 3) &gt;&gt; 2; <br>  // score = 100 - (dist * 100) / ((len&gt; lbuf)? len: lbuf); <br>  // wprintf (L "% s -&gt;% s (% d) \ n", word, buf, score); <br>  item = (ipair_t *) dk_alloc_box (sizeof (ipair_t), DV_ARRAY_OF_LONG); <br>  item-&gt; id_ = wordid; <br>  item-&gt; len_ = lbuf; <br>  item-&gt; score_ = score; <br>  dk_set_push (&amp; pairs_list, item); <br>  nids ++; <br>  } <br>  assert (pptr); <br>  } <br>  } <br>  if (pairs_list) <br>  { <br>  res = (ipair_t **) dk_set_to_array (pairs_list); <br>  dk_set_free (pairs_list); <br>  assert (nids == box_length (res) / sizeof (void *)); <br>  qsort (res, nids, sizeof (void *), cmp_pairs); <br>  } <br>  } <br>  hash_table_free (ht_ids); <br>  dk_free_box (word); <br>  } <br>  return res; <br>  } <br><br>  caddr_t <br>  bif_get_word_candidates (caddr_t * qst, caddr_t * err_ret, state_slot_t ** args) <br>  { <br>  char * me = "get_word_candidates"; <br>  ipair_t ** res = NULL; <br>  dk_set_t ids_list = NULL; <br>  caddr_t arr = NULL; <br>  caddr_t arg = bif_arg_unrdf (qst, args, 0, me); <br>  dtp_t dtp = DV_TYPE_OF (arg); <br>  if (DV_DB_NULL == dtp) <br>  { <br>  return (NULL); <br>  } <br>  if (! IS_WIDE_STRING_DTP (dtp)) <br>  { <br>  sqlr_new_error ("22023", "SR007", <br>  ‚ÄúFunction% s needs a nvstring or NULL as argument,‚Äû <br>  ‚ÄúNot an arg of type% s (% d)‚Äù, <br>  me, 1, dv_type_title (dtp), dtp); <br>  } <br><br>  if (0 == ht_dict _-&gt; ht_count) <br>  { <br>  bif_reload_dict (qst, err_ret, args); <br>  } <br><br>  res = get_word_candidates ((wchar_t *) arg); <br><br>  ids_list = load_oid_list (res, (query_instance_t *) qst, NULL); <br>  DO_SET (ipair_t *, item, &amp; ids_list) <br>  { <br>  // printf ("% d", item-&gt; id_); <br>  dk_free_box (item); <br>  } <br>  END_DO_SET (); <br><br>  return (caddr_t) res; <br>  } <br><br>  caddr_t <br>  bif_calc_similarity (caddr_t * qst, caddr_t * err_ret, state_slot_t ** args) <br>  { <br>  char * me = "calc_similarity"; <br>  caddr_t arg1 = bif_arg_unrdf (qst, args, 0, me); <br>  caddr_t arg2 = bif_arg_unrdf (qst, args, 1, me); <br>  dtp_t dtp1 = DV_TYPE_OF (arg1); <br>  dtp_t dtp2 = DV_TYPE_OF (arg2); <br>  if (DV_DB_NULL == dtp1 || DV_DB_NULL == dtp2) <br>  { <br>  return (NULL); <br>  } <br>  if ((! IS_WIDE_STRING_DTP (dtp1)) || (! IS_WIDE_STRING_DTP (dtp2))) <br>  { <br>  sqlr_new_error ("22023", "SR007", <br>  ‚ÄúFunction% s needs a nvstring or NULL as arguments,‚Äû); <br>  } <br>  { <br>  wchar_t * str1 = (wchar_t *) arg1; <br>  wchar_t * str2 = (wchar_t *) arg2; <br>  int l1 = wcslen (str1); <br>  int l2 = wcslen (str2); <br>  int dist = l_dist_raw (str1, str2, l1, l2); <br>  int score = 100 - (dist * 100) / ((l1&gt; l2)? l1: l2); <br>  if (str1 [0]! = str2 [0]) <br>  score = (score * 3) &gt;&gt; 2; <br>  return score; <br>  } <br>  } <br>  static int g_cnt = 0; <br>  #if defined WIN32 &amp;&amp; defined (_DEBUG) <br>  static _CrtMemState checkPt1; <br>  #endif <br><br>  long sqrt_long (long r) <br>  { <br>  long t, b, c = 0; <br>  assert (r&gt; = 0); <br><br>  for (b = 0x10000000; b! = 0; b &gt;&gt; = 2) <br>  { <br>  t = c + b; <br>  c &gt;&gt; = 1; <br>  if (t &lt;= r) <br>  { <br>  r - = t; <br>  c + = b; <br>  } <br>  } <br>  return ¬©; <br>  } <br><br>  caddr_t <br>  bif_query_phrase (caddr_t * qst, caddr_t * err_ret, state_slot_t ** args) <br>  { <br>  char * me = ‚Äúquery_phrase‚Äù; <br>  wchar_t ** words = NULL; <br>  ptrlong * res = NULL; <br>  wchar_t * tmp = NULL; <br>  dk_set_t ids_list = NULL; <br>  caddr_t arr = NULL; <br>  caddr_t arg = bif_arg_unrdf (qst, args, 0, me); <br>  dtp_t dtp = DV_TYPE_OF (arg); <br>  int len ‚Äã‚Äã= 0; <br>  mem_pool_t * mp = mem_pool_alloc (); <br><br>  #if 0 // defined WIN32 &amp;&amp; defined (_DEBUG) <br>  _CrtCheckMemory (); <br>  _CrtMemCheckpoint (&amp; checkPt1); <br>  #endif <br><br>  // if (0 == (g_cnt% 1000)) <br>  // printf ("% d", g_cnt); <br>  ++ g_cnt; <br>  if (DV_DB_NULL == dtp) <br>  { <br>  return (NULL); <br>  } <br>  if (IS_STRING_DTP (dtp)) <br>  { <br>  tmp = box_utf8_as_wide_char (arg, NULL, strlen (arg), 0, DV_WIDE); <br>  words = nv_split (tmp); <br>  dk_free_box (tmp); <br>  } <br>  else if (IS_WIDE_STRING_DTP (dtp)) <br>  { <br>  tmp = wcsdup ((const wchar_t *) arg); <br>  words = nv_split (tmp); <br>  free (tmp); <br>  } <br>  else <br>  { <br>  sqlr_new_error ("22023", "SR007", <br>  ‚ÄúFunction% s needs a nvstring or NULL as argument,‚Äû <br>  ‚ÄúNot an arg of type% s (% d)‚Äù, <br>  me, 1, dv_type_title (dtp), dtp); <br>  } <br><br>  if (0 == ht_dict _-&gt; ht_count) <br>  { <br>  bif_reload_dict (qst, err_ret, args); <br>  } <br><br>  // mutex_enter (dict_mtx_); <br><br>  if (words) <br>  { <br>  size_t niters = box_length (words) / sizeof (void *); <br>  dk_set_t results = NULL; <br>  dk_set_t * iter_holders = mp_alloc_box (mp, niters * sizeof (dk_set_t), DV_ARRAY_OF_POINTER); <br>  dk_set_t * iters = mp_alloc_box (mp, niters * sizeof (dk_set_t), DV_ARRAY_OF_POINTER); <br>  size_t i = 0; <br>  size_t ix = 0; <br>  size_t cnt = 0; <br>  size_t cnt1 = 0; <br>  for (i = 0; i &lt;niters; i ++) <br>  { <br>  ipair_t ** res = get_word_candidates ((wchar_t *) words [i]); <br>  if (res) <br>  { <br>  iter_holders [ix] = load_oid_list (res, (query_instance_t *) qst, mp); <br>  iters [ix] = iter_holders [ix]; <br>  ix ++; <br>  dk_free_tree (res); <br>  } <br>  } <br>  niters = ix; <br><br>  if (niters) <br>  { <br>  int64 min_elem = 0; <br>  int fin = 0; <br>  for (;! fin;) <br>  { <br>  int bfound = 1; <br>  size_t div = 1; <br>  size_t score = 1; <br>  size_t sumpos = 0; <br>  size_t oldpos = 0; <br><br>  if (! iters [0]) <br>  break; <br>  min_elem = ((ipair_t *) iters [0] -&gt; data) -&gt; id_; <br>  for (i = 0; i &lt;niters; i ++) <br>  { <br>  if (iters [i]) <br>  { <br> ipair_t *ptr = (ipair_t *)iters[i]-&gt;data; <br> div *= 100; <br> score *= ptr-&gt;score_; <br> if (i) <br>  { <br> sumpos += abs (oldpos ‚Äî ptr-&gt;pos_); <br>  } <br> oldpos = ptr-&gt;pos_; <br> if (ptr-&gt;id_ != min_elem) <br>  { <br> bfound = 0; <br>  } <br> if (ptr-&gt;id_ &lt; min_elem) <br>  { <br> min_elem = ptr-&gt;id_; <br>  } <br>  } <br>  } <br> if (bfound) <br>  { <br> ipair_t *item = mp_alloc_box(mp, sizeof(ipair_t), DV_BIN); <br> div /= 100; <br> score /= div; <br> if (niters &gt; 1) <br> sumpos /= (niters ‚Äî 1); <br> item-&gt;id_ = min_elem; <br> item-&gt;score_ = score/(1 + (sqrt_long(((100*sumpos)/5))/10)); <br> mp_set_push(mp, &amp;results, item); <br> cnt1++; <br><br> //printf (¬´FOUND:%I64d %d\n¬ª, min_elem, score); <br>  } <br> for (i = 0; i &lt;niters; i++) <br>  { <br> int bf = bfound; <br> while (iters[i] &amp;&amp; (bf || min_elem == ((ipair_t *)iters[i]-&gt;data)-&gt;id_)) <br>  { <br> bf = 0; <br> iters[i] = iters[i]-&gt;next; <br>  } <br> if (!iters[i]) <br>  { <br> fin = 1; <br>  break; <br>  } <br>  } <br>  } <br>  } <br><br> for (i = 0; i &lt;niters; i++) <br>  { <br> DO_SET (ipair_t *, item, &amp;iter_holders[i]) <br>  { <br>  cnt ++; <br> //dk_free_box(item); <br>  } <br> END_DO_SET (); <br>  } <br> //dk_free_box (iters); <br> //dk_free_box (iter_holders); <br><br> //printf ("-%d-", cnt); <br> len = dk_set_length(results); <br> //if (len &gt; 100) <br>  { <br> results = list_sort (results, compare_by_score, NULL); <br>  i = 0; <br> DO_SET (ipair_t *, entry, &amp;results) <br>  { <br> entry-&gt;len_ = (i &gt;= 100)? 0:1; <br>  i ++; <br>  } <br> END_DO_SET(); <br> len = (len&gt;100)?100:len; <br>  } <br> //results = list_sort (results, compare_by_id, NULL); <br>  i = 0; <br> res = dk_alloc_box(len * 2 * sizeof(ptrlong), DV_ARRAY_OF_LONG); <br> DO_SET (ipair_t *, entry, &amp;results) <br>  { <br> if (entry-&gt;len_) <br>  { <br> res[i++] = (entry-&gt;id_); <br> res[i++] = (entry-&gt;score_); <br>  } <br> //dk_free_box(entry); <br> cnt1--; <br>  } <br> END_DO_SET(); <br> //dk_set_free (results); <br> dk_free_tree (words); <br> //printf("(%d)", cnt1); <br>  } <br> //mutex_leave (dict_mtx_); <br> mp_free (mp); <br><br> #if 0//defined WIN32 &amp;&amp; defined (_DEBUG) <br> // _CrtMemDumpAllObjectsSince( NULL ); <br> _CrtMemDumpAllObjectsSince( &amp;checkPt1 ); <br> _CrtMemCheckpoint( &amp;checkPt1 ); <br> _CrtMemDumpStatistics( &amp;checkPt1 ); <br> _CrtCheckMemory( ); <br>  #endif <br> return (caddr_t)res; <br>  } <br><br>  void <br> init_dict (void) <br>  { <br> dict_mtx_ = mutex_allocate (); <br> ht_dict_ = id_hash_allocate (2039, sizeof (caddr_t), sizeof (caddr_t), strhash, strhashcmp); <br> ht_triples_ = id_hash_allocate (2039, sizeof (lenmem_t), sizeof (caddr_t), lenmemhash, lenmemhashcmp); <br> ht_dict_by_id_ = hash_table_allocate (2039); <br><br> bif_define (¬´nv_split¬ª, bif_nv_split); <br> bif_define (¬´treat_nword¬ª, bif_treat_nword); <br> bif_define (¬´calc_similarity¬ª, bif_calc_similarity); <br> bif_define (¬´reload_dict¬ª, bif_reload_dict); <br> bif_define (¬´get_word_candidates¬ª, bif_get_word_candidates); <br> bif_define (¬´query_phrase¬ª, bif_query_phrase); <br>  } <br><br> void finit_dict() <br>  { <br> flush_triples(); <br> flush_dict(); <br><br> hash_table_free (ht_dict_by_id_); <br> id_hash_free (ht_triples_); <br> id_hash_free (ht_dict_); <br> mutex_free (dict_mtx_); <br>  } <br><br> extern int f_foreground; <br><br>  int <br> main (int argc, char *argv[]) <br>  { <br> /*f_foreground = 1; <br> * FIXME: this could not be done in that way; this is a GPF on WIN32 and <br> * copy on write on linux; a fuinction from the shared object must be used <br> * to set it <br>  * / <br> #ifdef MALLOC_DEBUG <br> dbg_malloc_enable(); <br>  #endif <br> build_set_special_server_model (¬´Mircalo¬ª); <br> VirtuosoServerSetInitHook (init_dict); <br> return VirtuosoServerMain (argc, argv); <br>  } <br></div></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : as an illustration, the work of Vladimir Rumyantsev, the image of which is taken </font></font><a href="http://blogs.privet.ru/community/Cultural_groups/103537706"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is </font><a href="http://blogs.privet.ru/community/Cultural_groups/103537706"><font style="vertical-align: inherit;">used</font></a><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/206066/">https://habr.com/ru/post/206066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206050/index.html">How to compile build of Unity3D project for IOS on Windows?</a></li>
<li><a href="../206056/index.html">Is bitcoin money?</a></li>
<li><a href="../206058/index.html">Machine learning and data analysis. Lecture for the Small ShAD Yandex</a></li>
<li><a href="../206060/index.html">Cybiko Xtreme - social communicator for pupils and students</a></li>
<li><a href="../206064/index.html">Secrets of buttons in Android. Part 2: Layout Refactoring</a></li>
<li><a href="../206068/index.html">Google bought Boston Dynamics</a></li>
<li><a href="../206072/index.html">After the update, the Bittorrent Sync daemon no longer works as a root user.</a></li>
<li><a href="../206074/index.html">Making Christmas toys from LED strips</a></li>
<li><a href="../206076/index.html">The digest of interesting materials from the world of web development and IT for the last week No. 87 (December 7 - 14, 2013)</a></li>
<li><a href="../206078/index.html">Chinese lunar rover successfully sunk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>