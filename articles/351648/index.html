<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Triton vs Kao's Toy Project. We continue a good tradition</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will discuss SMT solvers. It so happened that a good tradition appeared in the research materials devoted to this topic. Already several ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Triton vs Kao's Toy Project. We continue a good tradition</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/dj/ox/-l/djox-lliv7yj-n2nyiph9oloyt8.jpeg"></p><br><p>  This article will discuss SMT solvers.  It so happened that a good tradition appeared in the research materials devoted to this topic.  Already several times, different researchers have chosen the same example as the experimental algorithm for SMT solvers - the <a href="https://tuts4you.com/e107_plugins/download/download.php%3Fview.3293">cracks that were invented once by a person with the nickname kao</a> .  Well, let's continue this tradition and try to use another symbolic tool to solve this cracks - <a href="https://triton.quarkslab.com/">Triton</a> . </p><a name="habracut"></a><br><h2 id="para-slov-pro-smt-reshateli">  A couple of words about SMT-solvers </h2><br><blockquote>  The task of satisfiability of formulas in theories (SMT) is the task of satisfiability for logical formulas taking into account the theories underlying them.  Examples of such theories for SMT formulas are: theories of integers and real numbers, the theory of lists, arrays, bit vectors, etc. - <a href="https://ru.wikipedia.org/wiki/SMT">wikipedia</a> </blockquote><p>  The SMT task is an extension of the SAT task (the Boolean satisfiability problem or the Propositional Satisfiability Problem, in the English-language literature it is called the SATISFIABILITY or SAT, in Russian literature it is sometimes called EX). </p><br><p>  Another quote from Wikipedia: </p><br><blockquote>  An instance of the SAT task is a boolean formula consisting only of variable names, parentheses, and AND, OR, and HE operations.  The problem is the following: is it possible to assign all the variables found in the formula the values ‚Äã‚Äã"false" and "true" so that the formula becomes true.  - <a href="https://ru.wikipedia.org/wiki/SMT">wikipedia</a> </blockquote><p>  Since SMT solvers work with different theories, it becomes possible to use them for algorithms in traditional processor architectures.  Thus, SMT solvers solve two problems: </p><br><ul><li>  to answer the question whether the data is possible output values ‚Äã‚Äãof the algorithm with the given input values; </li><li>  to determine at what input values ‚Äã‚Äãthe result of the algorithm will be the given output values. </li></ul><br><p>  SMT solvers have applied applications in various fields of science and technology.  There are separate tools for solving SMT formulas, for example, <a href="https://github.com/Z3Prover/z3">Z3</a> , <a href="http://minisat.se/">miniSAT</a> , <a href="https://github.com/CVC4/CVC4">CVC4</a> , etc., and for representing algorithms in machine language in the <a href="http://smtlib.cs.uiowa.edu/language.shtml">syntax of an SMT formula</a> , for example, <a href="https://github.com/BinaryAnalysisPlatform/bap/">BAP</a> , <a href="http://radare.org/r/">radare2,</a> or <a href="http://angr.io/">angr</a> .  The tools are constantly being improved, the API is becoming more powerful, and now just a few clicks are enough to apply the entire SMT mathematical apparatus in reverse engineering tasks. </p><br><p>  Note also that there are several types of symbolic execution.  Static symbolic execution (SSE, Static symbolic execution) is based only on symbolic variables and uses only symbolic formulas.  Dynamic symbolic execution (DSE, Dynamic symbolic execution), also called concolic execution, uses symbolic computations along with specific values ‚Äã‚Äãof numerical variables during program execution.  In this paper we will use only static symbolic execution. </p><br><h2 id="istoriya-kryakmi-kaos-toy-project">  Quack history Kao's Toy Project </h2><br><p>  Cracks Kao's Toy Project is extremely simple.  In one window, it displays some hexadecimal sequence and offers to enter a key that is valid for the sequence. </p><br><p><img src="https://habrastorage.org/webt/ok/kv/ek/okkvekjt8e_g8cisq2z2lct9di8.png"></p><br><p>  His story can be presented as the following chronicle: </p><br><p>  <strong>03/04/2012 - <a href="https://tuts4you.com/e107_plugins/download/download.php%3Fview.3293">Kao's Toy Project and Algebraic Cryptanalysis</a> - dcoder, andrewl - Algebraic Cryptanalysis, SAT</strong> </p><br><p>  The first work devoted to this quack, appeared in 2012.  In it, a person with the nickname dcoder published a solution using algebraic cryptanalysis, and the co-author of this work andrewl successfully applied the SAT solver. </p><br><p>  <strong>03/06/2012 - Rolf Rolles - z3, Self-Writing Converter</strong> </p><br><p>  Then the famous researcher Rolf Rolles first applied the SMT solver to the solution.  First, he manually compiled a formula in Z3, and then presented in OCaml a tool for automatically generating a formula from an intermediate representation of machine code.  The intermediate language he used was developed by himself. </p><br><blockquote>  I used an BitBlaze and BAP, but I wrote my own IR translator rather than using VEX.  My implementation is written with the open-source framework.  - <a href="http://www.openrce.org/blog/view/2049/%255Bvideo%255D_Semi-Automated_Input_Crafting_by_Symbolic_Execution,_with_an_Application_to_Automatic_Key_Generator_Generation">openrce.org</a> </blockquote><p>  <strong>11.2013 - <a href="http://www.slideshare.net/DefconRussia/georgy-nosenko-an-introduction-to-the-use-smt-solvers-for-software-security">SMT Solvers for Software Security</a> - Georgy Nosenko - BAP, z3</strong> </p><br><p>  Then came the work of my colleague Georgy Nosenko, where the BAP framework and the same solver Z3 were already used to generate the formula. </p><br><p>  <strong>03.2015 - <a href="http://blog.cr4.sh/2015/03/automated-algebraic-cryptanalysis-with.html">Automated algebraic cryptanalysis with OpenREIL and Z3</a> - Cr4sh - OpenREIL, z3</strong> </p><br><p>  Dmitry Oleksyuk, also known as Cr4sh, in his study used the conversion into the intermediate language OpenREIL with the subsequent generation of the formula in Z3. </p><br><p>  <strong>04.2016 - Extreme Coders Blog - Solr</strong> </p><br><p>  And finally, another work appeared in 2016, and it describes the solution using the framework angr.  Angr uses the intermediate language VEX and the claripy library for symbolic performance. </p><br><p>  At the SMT arena, another player has now appeared - Triton, and we will use it in this paper to solve the famous quacks. </p><br><h2 id="tritonhttpstritonquarkslabcom">  <a href="https://triton.quarkslab.com/">Triton</a> </h2><br><p>  Triton was created by <a href="https://quarkslab.com/">Quarkslab</a> , which created many interesting tools for reverse engineering. </p><br><p>  First, a little about how Triton works.  In the course of his work, he performs the following actions: </p><br><ol><li>  parses the trace of the binary code execution and generates an abstract syntax tree of the code taking into account all the side effects of machine instructions; </li><li>  bypasses the abstract syntax tree and generates an SMT formula in SMT-LIB format; </li><li>  Solves a formula with the solver z3. </li></ol><br><p>  When building an abstract syntax tree, Triton does not use an intermediate representation of machine code (unlike bap or angr), and currently supports only work with x86 and x86-64 architectures. </p><br><p>  Triton can work in one of two modes.  In the first one, online mode, the execution trace is recorded using a special tracer, which is part of Triton and uses the <a href="https://software.intel.com/en-us/node/256675/docs">DBI framework pin</a> .  In the second - offline mode - the track is recorded by external means.  The route must contain a sequence of instructions and their opcodes.  In the second case, it is already necessary to independently create the initial context, that is, to determine the values ‚Äã‚Äãof the registers and the memory used. </p><br><p>  The API that Triton provides is very rich and ... very unstable.  Since the advent of the API has changed four times already, of course, not retaining backward compatibility.  Because of this, the code of old tools using Triton must be rewritten to run on new versions.  The nice thing is that the API has binding for Python.  There are several examples in the repository that demonstrate the use of API in C ++ and Python, thanks to which it is quite easy to deal with it. </p><br><p>  So let's get down to the solution. </p><br><h2 id="reshenie">  Decision </h2><br><p>  First we need to find the algorithm by which the entered key is checked.  Skimming through the code, we see that the generated sequence is actually eight 32-bit integers, and lies in memory sequentially in the little-endian representation, while the window is shown as big-endian.  We learn that the key has the format XXXXXXXX-XXXXXXXX, where X is a hexadecimal digit.  If the key is entered in this format, the verification procedure is called.  So it looks like in the IDA Pro disassembler. </p><br><p><img src="https://habrastorage.org/webt/d5/d1/m9/d5d1m9mryp5k78xv9zszfm-phxe.png"></p><br><p>  The verification procedure first initializes the input data: cipher is a 32-byte source sequence in little-endian view, String1 is the buffer for the output sequence after conversion, in the edx and ebx registers there are two key halves, represented as 32-bit integers.  Next comes the conversion algorithm itself - 32 cycles with xor and rol operations - and then the resulting string from the String1 buffer is compared with the string ‚Äú0how4zdy81jpe5xfu92kar6cgiq3lst7‚Äù.  If they are identical, the key is considered valid. </p><br><p>  Thus, the following problem is formed for the SMT solver: to determine on which input values ‚Äã‚Äãof the edx and ebx registers a given hexadecimal sequence after the execution of the algorithm is converted into the string ‚Äú0how4zdy81jpe5xfu92kar6cgiq3lst7‚Äù. </p><br><p>  Since cracks are written for Windows, the Triton tracer is not suitable, because it is supplied only compiled for Linux.  You can, of course, try to compile it yourself for Windows, but these are still adventures.  Therefore, we will use offline mode and Triton's Binding for Python. </p><br><p>  First we introduce the necessary constants: </p><br><pre><code class="python hljs">ADDR_CIPHER = <span class="hljs-number"><span class="hljs-number">0x4093A8</span></span> ADDR_TEXT = <span class="hljs-number"><span class="hljs-number">0x409185</span></span> ADDR_EBP = <span class="hljs-number"><span class="hljs-number">0x18f980</span></span> TEXT = <span class="hljs-string"><span class="hljs-string">"0how4zdy81jpe5xfu92kar6cgiq3lst7"</span></span> cipher = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  and perform the initial initialization: </p><br><pre> <code class="python hljs">ctx = TritonContext() ctx.setArchitecture(ARCH.X86) ctx.setConcreteRegisterValue(ctx.registers.ebp, ADDR_EBP) ctx.setConcreteRegisterValue(ctx.registers.esp, <span class="hljs-number"><span class="hljs-number">0x18f95b</span></span>) ctx.setConcreteRegisterValue(ctx.registers.eip, <span class="hljs-number"><span class="hljs-number">0x4010ec</span></span>) ctx.setConcreteMemoryAreaValue(ADDR_CIPHER, cipher) ctx.setConcreteMemoryAreaValue(ADDR_TEXT, list(map(ord, TEXT))) edx = ctx.convertRegisterToSymbolicVariable(ctx.getRegister(REG.X86.EDX)) ebx = ctx.convertRegisterToSymbolicVariable(ctx.getRegister(REG.X86.EBX)) keys = [ctx.convertMemoryToSymbolicVariable(MemoryAccess(ADDR_EBP<span class="hljs-number"><span class="hljs-number">-0x21</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">32</span></span>)]</code> </pre> <br><p>  During initialization, we create the context, set the architecture, initialize the registers and memory, and of course, create character variables: the edx and ebx registers and the buffer for the transformed sequence, the values ‚Äã‚Äãof which will be constrained in the formula. </p><br><p>  Now we create the execution trace.  To do this, offline download the binary code: </p><br><pre> <code class="python hljs">code = {<span class="hljs-number"><span class="hljs-number">0x4010EC</span></span>: <span class="hljs-string"><span class="hljs-string">'\x55'</span></span>, <span class="hljs-comment"><span class="hljs-comment"># push ebp 0x4010ED: '\x8b\xec', # mov ebp, esp 0x4010EF: '\x83\xc4\xdc', # add esp, -24h 0x4010F2: '\xb9\x20\x00\x00\x00', # mov ecx, 20h 0x4010F7: '\xbe\xa8\x93\x40\x00', # mov esi, offset cipher 0x4010FC: '\x8d\x7d\xdf', # lea edi, [ebp+string1] 0x4010FF: '\x8b\x55\x08', # mov edx, [ebp+arg_0] 0x401102: '\x8b\x5d\x0c', # mov ebx, [ebp+arg_4] # loc_401105: 0x401105: '\xac', # lodsb 0x401106: '\x2a\xc3', # sub al, bl 0x401108: '\x32\xc2', # xor al, dl 0x40110A: '\xaa', # stosb 0x40110B: '\xd1\xc2', # rol edx, 1 0x40110D: '\xd1\xc3', # rol ebx, 1 0x40110F: '\xe2\xf4'} # loop loc_401105</span></span></code> </pre> <br><p>  and start processing instructions: </p><br><pre> <code class="python hljs">ip = <span class="hljs-number"><span class="hljs-number">0x4010ec</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ip &lt; <span class="hljs-number"><span class="hljs-number">0x401111</span></span>: inst = Instruction() inst.setOpcode(code[ip]) inst.setAddress(ip) ctx.processing(inst) ip = ctx.buildSymbolicRegister(ctx.registers.eip).evaluate()</code> </pre> <br><p>  During the processing of instructions, Triton translates them into symbolic form and adds the resulting symbolic instructions to the context.  In this code, we also use the symbolic emulation of the ip register to calculate the next instruction in the order of execution. </p><br><p>  After that, it remains to introduce into the context the necessary restrictions on the values ‚Äã‚Äãof variables.  We have this condition for the equality of the converted string with the string ‚Äú0how4zdy81jpe5xfu92kar6cgiq3lst7‚Äù, which we placed in the TEXT constant. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">32</span></span>): r_ast = ast.bv(ord(TEXT[i]), <span class="hljs-number"><span class="hljs-number">8</span></span>) l_id = ctx.getSymbolicMemoryId(ADDR_EBP<span class="hljs-number"><span class="hljs-number">-0x21</span></span> + i) l_ast = ctx.getAstFromId(l_id) ex = ast.equal(l_ast, r_ast) expr.append(ex) expr = ast.land(expr)</code> </pre> <br><p>  Constraints are defined as nodes of an abstract syntax tree (ASD).  In our cycle, an ASD node is created for one character from a string and an ASD node for one element of the transformed sequence.  Then a new ASD node is created with the operation of comparing these two nodes.  Since we need to ensure that the equality conditions for all elements are fulfilled simultaneously, after receiving them in a cycle, they are combined into one SDA under the logical AND operation, expr = ast.land (expr). </p><br><p>  Everything is ready to calculate the solution.  We obtain the data model for the symbol formula with the given constraints expr. </p><br><pre> <code class="python hljs">model = ctx.getModel(expr)</code> </pre> <br><p>  You can download the entire keygen script <a href="https://github.com/pickecat/kao_triton/blob/master/keygen_v1.py">from here</a> . </p><br><p>  Run the script and ... nothing happens.  Debugging shows that execution loops through the processing of instructions, and it quickly becomes clear that the loop instruction is not being processed.  It turns out that Triton <a href="https://triton.quarkslab.com/documentation/doxygen/SMT_Semantics_Supported_page.html">does not even know this instruction</a> .  How to deal with this problem?  You can add the semantics of the new instruction to the Triton source code and rebuild it.  But we have already noted that rebuilding on Windows is a rather painstaking job.  Hmm, well, let's not get upset right away, and try to redo our code.  You can try to replace the loop with the same set of instructions in action, for example: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">dec</span></span> ecx jz <span class="hljs-number"><span class="hljs-number">0401105</span></span>h</code> </pre> <br><p>  And you can try to expand the loop manually, and do not process the block with the loop inside, but only the body of the loop as many times as recorded in the ecx register, that is, 32. Then the code will look like this: </p><br><pre> <code class="python hljs">code = [<span class="hljs-string"><span class="hljs-string">'\xac'</span></span>, <span class="hljs-comment"><span class="hljs-comment"># lodsb '\x2a\xc3', # sub al, bl '\x32\xc2', # xor al, dl '\xaa', # stosb '\xd1\xc2', # rol edx, 1 '\xd1\xc3'] # rol ebx, 1 ctx.setConcreteRegisterValue(ctx.registers.esi, ADDR_CIPHER) ctx.setConcreteRegisterValue(ctx.registers.edi, ADDR_EBP - 0x21) ctx.setConcreteRegisterValue(ctx.registers.eip, 0x401105) ctx.setConcreteMemoryAreaValue(ADDR_CIPHER, cipher) ctx.setConcreteMemoryAreaValue(ADDR_TEXT, list(map(ord, TEXT))) edx = ctx.convertRegisterToSymbolicVariable(ctx.registers.edx) ebx = ctx.convertRegisterToSymbolicVariable(ctx.registers.ebx) ip = 0x401105 for i in xrange(32): for c in code: inst = Instruction() inst.setOpcode(c) inst.setAddress(ip) ctx.processing(inst) ip = ctx.buildSymbolicRegister(ctx.registers.eip).evaluate()</span></span></code> </pre> <br><p>  So, we launch a new version.  At this time, processing is performed entirely and successfully reaches the calculation of the model in which it is immersed, as expected, for a while.  We are waiting ... waiting ... waiting for a very long time.  I did not wait.  This time, the problem is in the function of calculating the model, and here the error may not be so easy to detect.  It can be assumed that the resulting formula is very large, and its calculation can indeed take a very long time.  To verify this, reduce the number of iterations in the loop where the processing takes place.  Indeed, with a smaller number of iterations, the result is given.  By the selection method, it was found that the upper limit of the number of iterations, at which the calculations take the foreseeable time, on an experienced laptop is 12. Yes, this is very small, and as they increase, time grows exponentially.  32 iterations are much more than 12, and it seems that even if you rewrite the code in C ++, it will still be unacceptably long to calculate the model. </p><br><p>  If you try to look in debugging, what takes so much time in the getModel function, we will see that these are recursive calls to <code>triton::ast::TritonToZ3Ast::convert</code> . </p><br><p><img src="https://habrastorage.org/webt/vp/qk/t7/vpqkt7wubhwxanhspngzifrgzg4.png"></p><br><p>  As written in the documentation, Triton uses its custom ASD tree: </p><br><blockquote>  An abstract syntax tree (AST) is a representation of a grammar as tree.  Triton uses a custom AST for its expressions.  AST is available at each program point.  - <a href="https://triton.quarkslab.com/documentation/doxygen/py_AstContext_page.html">Triton documentation</a> </blockquote><p>  This function converts Triton's ASD into an expression for z3. <br>  You can try to look at the expressions that make up Triton's SDA.  Add the following lines before getting the model: </p><br><pre> <code class="python hljs">tsym = ctx.getSymbolicExpressions() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ek <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(tsym.keys()): e = tsym[ek].getAst() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> str(e)</code> </pre> <br><p>  After that, Triton‚Äôs expressions will appear in the console: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">0</span></span> = SymVar_0 <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">1</span></span> = SymVar_1 <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">2</span></span> = SymVar_33 ; Byte reference <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">3</span></span> = (concat ((_ extract <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>) (_ bv0 <span class="hljs-number"><span class="hljs-number">32</span></span>)) (_ bv29 <span class="hljs-number"><span class="hljs-number">8</span></span>)) ; LODSB operation <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">4</span></span> = (ite (= (_ bv0 <span class="hljs-number"><span class="hljs-number">1</span></span>) (_ bv0 <span class="hljs-number"><span class="hljs-number">1</span></span>)) (bvadd (_ bv4232104 <span class="hljs-number"><span class="hljs-number">32</span></span>) (_ bv1 <span class="hljs-number"><span class="hljs-number">32</span></span>)) (bvsub (_ bv4232104 <span class="hljs-number"><span class="hljs-number">32</span></span>) (_ bv1 <span class="hljs-number"><span class="hljs-number">32</span></span>))) ; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">5</span></span> = (_ bv4198662 <span class="hljs-number"><span class="hljs-number">32</span></span>) ; Program Counter <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">6</span></span> = (concat ((_ extract <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">3</span></span>) (bvsub ((_ extract <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">3</span></span>) ((_ extract <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">1</span></span>))) ; SUB operation <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>!<span class="hljs-number"><span class="hljs-number">7</span></span> = (ite (= (_ bv16 <span class="hljs-number"><span class="hljs-number">8</span></span>) (bvand (_ bv16 <span class="hljs-number"><span class="hljs-number">8</span></span>) (bvxor ((_ extract <span class="hljs-number"><span class="hljs-number">7</span></span> ‚Ä¶</code> </pre> <br><p>  To get expressions in the SMT-LIB syntax, you need to add another call. </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> ctx.unrollAst(e)</code> </pre> <br><p>  In this place - <code>unrollAst</code> - the same conversion of Triton's expressions into SMT-LIB expressions takes place, and here you will not wait for completion either, as with the getModel function. <br>  Those familiar with the SMT-LIB syntax will notice that Triton's expressions are SMT-LIB expressions, only in the form of SSA (Single Static Assignment).  There is no variable assignment operation in SMT-LIB - they are replaced by the let function operator.  But what if you try to independently convert the Triton syntax into the SMT-LIB syntax without deploying the SDA, but replacing the SSA form with a form with let operators, and then try to feed it with z3py?  It sounds rather cumbersome and redundant, but it is necessary to get out of this situation, until the developers have finished Triton. </p><br><p>  So, with the resulting expression, we perform the following actions: </p><br><ul><li>  Declare variables in the SMT-LIB syntax; </li><li>  Replace assignment statements with let statements; </li><li>  The resulting expressions are combined into a general formula in SMT-LIB. </li></ul><br><p>  The result is a conversion function from the Triton syntax to the SMT-LIB syntax.  Of course, it is not universal, but, at least, it works for our task. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx, asserts)</span></span></span><span class="hljs-function">:</span></span> zsym = <span class="hljs-string"><span class="hljs-string">""</span></span> tsym = ctx.getSymbolicExpressions() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ek <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(tsym.keys()): e = tsym[ek].getAst() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.getKind() == AST_NODE.VARIABLE: zsym += <span class="hljs-string"><span class="hljs-string">"(declare-fun ref!%d () (_ BitVec %d))\n"</span></span> % (ek, e.getBitvectorSize()) nodes = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ek <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(tsym.keys()): e = tsym[ek].getAst() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.getKind() &lt;&gt; AST_NODE.VARIABLE: nodes.append(<span class="hljs-string"><span class="hljs-string">"let ((ref!%d %s))"</span></span> % (ek, e)) <span class="hljs-comment"><span class="hljs-comment"># print reduce(lambda x, y: "%s (%s)" % (x, y), reversed(nodes)) def fold(x, y): if not isinstance(y, list): raise TypeError if len(y) == 1: return y[0] return "%s\n(%s)" % (x, fold(y[0], y[1:])) nodes = ["assert"] + nodes nodes[-1] += '\n' + str(asserts) zsym = zsym + '(' + fold(nodes[0], nodes[1:]) + ')' return zsym</span></span></code> </pre> <br><p>  The result of the function must be sent to the z3py solver for calculation. </p><br><pre> <code class="python hljs">s = z3.Solver() cs = z3.parse_smt2_string(expr) s.assert_exprs(cs) s.check() m = s.model() edx, ebx = m.decls()</code> </pre> <br><p>  Now the edx and ebx variables store objects of the class <code>z3.z3.FuncDeclRef</code> .  We get their numerical representation, and since transformations to quacks are performed after they have been poked with each other, they must also be poxorized. </p><br><pre> <code class="python hljs">edx, ebx = m[edx].as_long(), m[ebx].as_long() <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%x-%x"</span></span> % (edx, edx ^ ebx)</code> </pre> <br><p>  The code for the second version can also be taken from the <a href="https://github.com/pickecat/kao_triton/blob/master/keygen_v2.py">githab</a> . </p><br><p>  So, we get a string that you just need to copy in the input field in the crack window.  Itching to do it already. </p><br><p><img src="https://habrastorage.org/webt/gx/wz/_r/gxwz_rx5kh66ypcgxumkrecb5hg.png"></p><br><p><img src="https://habrastorage.org/webt/tw/gp/io/twgpioxv_xd3otvqv6xn2wivgxw.png"></p><br><p><img src="https://habrastorage.org/webt/xs/ch/7k/xsch7ko7tlxdbajk15yyzmiyqai.png"></p><br><p>  Hooray!  Our keygen works correctly. </p><br><h2 id="poncehttpsgithubcomillera88ponce">  <a href="https://github.com/illera88/Ponce">Ponce</a> </h2><br><p>  On the basis of Triton built another cool tool - Ponce plugin for IDA Pro.  It allows you to do very tempting things - symbolic execution and taint analysis right in the IDA disassembler.  Unfortunately, due to the presence of loop instructions in our cracks, we cannot check Ponce on it.  Maybe there are people who want to add a loop to Triton?  :) Or there is another option.  Since kao cracks comes with source code in assembler, you can replace the loop there with the aforementioned similar set of instructions.  Then you can use Ponce and feel its power.  For an interested reader, this will be a cool task. </p><br><h2 id="vyvody">  findings </h2><br><p>  Frankly, Triton did not cope with the task.  But let's not be too strict: it is easy to add the loop instruction yourself, and the conversion of the formula, judging by the build history, the developers <a href="https://ci.appveyor.com/project/JonathanSalwan/triton/history">have already begun to do iterative</a> . </p><br><p><img src="https://habrastorage.org/webt/7u/ei/qw/7ueiqw9logthrn_3wcruonabcw0.png"></p><br><p>  Modern reverse engineering and search for vulnerabilities in software without symbolic execution are a thing of the past.  This is proved, for example, by automatic systems for finding vulnerabilities and generating exploits created during the DARPA Cyber ‚Äã‚ÄãGrand Challenge contest.  Therefore, tools such as Triton, are now in great demand.  As they develop, they become more and more simple to use, so that the symbolic execution becomes a very accessible and effective tool in the work of the researcher. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/351648/">https://habr.com/ru/post/351648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351634/index.html">Quantum Computing: Reference Materials</a></li>
<li><a href="../351636/index.html">We speed up the time of assembly and delivery of java web applications</a></li>
<li><a href="../351638/index.html">ComputerVision and what it eat</a></li>
<li><a href="../351644/index.html">Amazon will launch internal accounts for customers without bank cards</a></li>
<li><a href="../351646/index.html">Difficulties of registering on Skype without a phone</a></li>
<li><a href="../351650/index.html">Digest news from the world of PostgreSQL. Issue number 4</a></li>
<li><a href="../351652/index.html">Release Yii 2.0.15 and database extensions with fixed vulnerabilities</a></li>
<li><a href="../351654/index.html">Marvin Minsky "The Emotion Machine": Introduction</a></li>
<li><a href="../351656/index.html">Recreating the water effect of Super Mario Sunshine for Nintendo GameCube</a></li>
<li><a href="../351658/index.html">How I parsed the C-Tree DB, developed 34 years ago</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>