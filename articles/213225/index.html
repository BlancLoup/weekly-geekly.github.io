<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ garbage collector</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I conceived this article for a long time. It will be about the simplest copying garbage collector in C ++. It has quite a lot of restriction...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ garbage collector</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I conceived this article for a long time.  It will be about the simplest copying garbage collector in C ++.  It has quite a lot of restrictions (the part does not interfere, some can be circumvented if you aim to write some serious library, and for something it would be nice to have rudimentary support from the language), but the code in it is just over 100 lines.  Interested please under the cat.  There is a minimum of PLO, simple patterns and terrible magic rituals with pointers. <br><a name="habracut"></a><br>  Start over.  What is a garbage collector and what is it for? <br><br>  A garbage collector (Gargabe Collector, GC) is such a way to manage resources, usually RAM, allocated on the heap.  The essence is simple - the programmer asks the garbage collector to allocate a piece of memory to him, and he himself already determines when he becomes unnecessary and can be released.  This solves most problems with memory leaks, although it makes it impossible to heroically exalt segmentation errors.  What a pity. <br><br>  Garbage collectors are of two kinds - conservative and copying. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Something like the first type is implemented in the last standard.  The mechanism shared_ptr allows you to abandon the explicit use of the operators new and delete.  It considers references that point to an object and gets rid of it when their number becomes zero.  Problems with this approach arise when many small objects are created with a short but not the same lifespan.  As a result, the heap turns into a bloody mess of valid objects and rags of free memory of several dozen bytes.  Because of this, the creation of new objects begins to take forever and the native code begins to envy Python. <br><br>  To solve this problem - heap fragmentation - a second type of collector was invented - copying.  For the time being, his strategy of dealing with garbage is contemplation.  When it becomes too much, he does the following: <br>  1. Copies all the necessary data to another area of ‚Äã‚Äãmemory. <br>  2. Changes all pointers to actual ones. <br>  3. Frees all memory that is no longer in use. <br><br>  At once I‚Äôll clarify that I didn‚Äôt look closely at a single garbage collection algorithm, nor how the ‚Äúadult‚Äù GC libraries for C ++ work.  Probably, the algorithm, which I will now describe, has a name, perhaps a nominal one, but here I will manage without references to sources. <br><br>  To identify the objects that the program still needs, I suggest treating memory as a regular graph.  Then the ‚Äúliving‚Äù objects after garbage collection will be those that are accessible through a chain of pointers.  Here questions arise.  First, as for any possible object that a programmer can ask to create, determine where he has pointers.  The first way is using template magic for each class of objects to create its own allocator.  A terrible idea for many reasons.  The second is to write in the header of each object all the information that is needed for the operation of the GC (oh, yes, for classes with virtual functions this implementation is not appropriate. I have a couple of ideas, if necessary). <br><br>  The title can also be used in many ways.  Mine is the simplest one that can exist at all (for implementation, but not use).  First, each object that plans to be created through the garbage collector must have this structure at the beginning of its definition: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { STRUCT_SZ = <span class="hljs-number"><span class="hljs-number">0</span></span>, REF_COUNT = <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gcHeader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gcData[<span class="hljs-number"><span class="hljs-number">2</span></span>]; gcHeader* post_gcAddress; }; };</code> </pre> <br>  Secondly, right after the heading, and nowhere else, all the pointers, which also belong to the garbage collector, should go.  Accordingly, their number will be stored in gcData [REF_COUNT].  This is one of the limitations that my implementation imposes.  GcData [STRUCT_SZ] will store the size of the structure in bytes.  I will reveal the purpose of the pointer later.  Conveniently, the size of the structure was equal to the size of the pointer (now 2014, folks!). <br><br>  Great, now we can bypass all our memory.  The question is where to start the traversal.  The only memory area that is 100% available to us at any time is the stack.  The problem is the same as with pointers in structures - we have no idea which bunch of bytes points to a GC object.  Therefore, you need to write down the location of each such pointer explicitly. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;gcHeader**&gt; referencesStack; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stackRef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: T* ref; stackRef(){ ref = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; referencesStack.push_back(<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;gcHeader**&gt;(&amp;ref)); } ~stackRef(){ referencesStack.pop_back(); } };</code> </pre><br>  The stackRef class is simple.  When initialized, it only adds its address to the stack of links.  The destructor, accordingly, deletes the irrelevant address from the same stack.  The work of the call stack and constructors with destructors is synchronized, so there will be no anomalies. <br><br>  In the class, you need to redefine a bunch of operators - dereferencing, assignment, etc, but it will make sense to do this no sooner than the guys from the Boost Foundation will contact me. <br><br>  Auxiliary structures are ready.  You can go to the memory allocation. <br><br>  A cool feature of this way of managing resources is exactly the way they are allocated.  The standard C ++ C ++ allocator has to update the lists of free blocks after each delete, and after new find the appropriate block among the blocks, then split it into two small blocks, and then something else that modern allocators do there.  In the case of a garbage collector, the delete operation is simply not needed, so that all the occupied memory will go in one solid block.  To create a new object, you only need to increase the size of this block, i.e., move one pointer.  A simple operation that is performed in O (1).  It really ceased to seem such a great idea, because it provokes a bunch of assemblies when it would be possible to simply reuse the unnecessary memory, but for now you can stop there. <br><br>  We divide the memory controlled by the garbage collector into pieces of 4 kilobytes and link them to the list.  In fact, a little more than 4 kilobytes, but this is a question of my laziness. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CHUNK_SIZE = <span class="hljs-number"><span class="hljs-number">4096</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OVERDRAFT = <span class="hljs-number"><span class="hljs-number">128</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ACTUAL_SIZE = CHUNK_SIZE + OVERDRAFT; <span class="hljs-comment"><span class="hljs-comment">//      15  ,  -   . struct gcChunk { gcChunk* next; char data[ACTUAL_SIZE];//     . }; gcChunk* firstChunk; gcChunk* currentChunk; int chunkCount; int currentOffset;</span></span></code> </pre><br>  firstChunk is the beginning of the list, currentChunk is the last created block of memory.  urrentOffset - the beginning of a free memory segment relative to currentChunk. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gcHeader* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcRawAlloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> refCount)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt; CHUNK_SIZE)<span class="hljs-comment"><span class="hljs-comment">//  proof of concept,      return nullptr; if (currentOffset + size &gt; CHUNK_SIZE){ //     list&lt;gcChunk&gt;  STL,   ,       . ++chunkCount; currentChunk-&gt;next = new gcChunk(); currentChunk = currentChunk-&gt;next; currentChunk-&gt;next = nullptr; currentOffset = 0; } gcHeader* new_obj = reinterpret_cast&lt;gcHeader*&gt;(&amp;(currentChunk-&gt;data[currentOffset])); new_obj-&gt;gcData[STRUCT_SZ] = size; new_obj-&gt;gcData[REF_COUNT] = (refCount &lt;&lt; 1)| 1; currentOffset += size; if (currentOffset % 4)//  4 .  ,    , ..         . currentOffset += 4 - currentOffset % 4; return new_obj;//        ,       ,    ‚Äî   . }</span></span></code> </pre><br><br>  There are more unobvious moments here.  We analyze the 12th line. <br>  At this stage, it is more convenient for us not to think about exactly which type of the new object.  We know for sure that it has our gcHeader, and that‚Äôs enough for now. <br>  After we allocate memory for a new object, we need to initialize its header.  What can mean mysterious assignment <br><br><pre> <code class="cpp hljs">temp-&gt;gcData[REF_COUNT] = (refCount &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>)| <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  ? <br><br>  To do this, look again at the title definition. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gcHeader</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gcData[<span class="hljs-number"><span class="hljs-number">2</span></span>]; gcHeader* post_gcAddress; }; };</code> </pre><br><br>  The union keyword means that the gcData array and the post_gcAddress pointer are located at the same address.  This is useful for saving memory, but the problem is that C ++ does not remember how the data in the union was used last time ‚Äî as an array, or as a reference.  This feature of processor architectures, such as the need for data alignment, helps. <br><br>  In short, any variables longer than one byte must be located at addresses that are multiples of the machine word in bytes.  Disruption of alignment on modern processors slows down the work of the program, and the old ARMs generally refuse to work in such conditions.  As a result, 2 or 3 low bits of the pointer can be used at any time at the discretion of the programmer.  For example, when implementing red-black trees, the last bit is often used instead of a boolean variable. <br><br>  This is the same thing.  If the low-order bit is one, then these eight bytes are guaranteed to be an array of two int.  You can, for example, use another bit to indicate to the garbage collector, something like "this is a reference to a polymorphic object, it has a vtable pointer, do not rub it." <br><br>  Well, a small wrapper over the function so that the use of the allocator does not cause much pain. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gcAlloc</span></span></span><span class="hljs-class">(){</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T*&gt;(gcRawAlloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), T::refCount)); }</code> </pre>  Here it is necessary to put emplace new so that objects with constructors are correctly initialized.  As you can see, the class of the object we want to create must have a static constant refCount.  It can be calculated automatically using an external preprocessor.  Otherwise, I see at least three ways to shoot myself a leg. <br><br>  Before using this function, you need to initialize the heap. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ firstChunk = currentChunk = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> gcChunk; firstChunk-&gt;next = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; currentOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; chunkCount = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  It's time to look at the implementation of the garbage collection itself. <br><br>  The first function, gcCollect, should start the heap from scratch, not forgetting to save pointers to the old list.  These lines almost repeat initialization. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcCollect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//execvp("rm", "cppgc.cpp");//       . gcChunk* newFirstChunk = currentChunk = new gcChunk; currentChunk-&gt;next = nullptr; currentOffset = 0; chunkCount = 1;</span></span></code> </pre><br><br>  Next, we begin the build process with each pointer that is stored on the stack. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = referencesStack.begin();i != referencesStack.end(); ++i ) gcMove(*i);</code> </pre><br><br>  And now just freeing unnecessary memory. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,       ,     gcChunk iter = firstChunk; firstChunk = newFirstChunk; while (iter != nullptr){ gcChunk* t = iter-&gt;next; delete[] iter; iter = t; } }</span></span></code> </pre><br><br>  Note that delete is called only for large blocks of memory.  Thus, destructors of objects in the garbage collector will never be called.  This is not a problem for classes where destructors only free memory, but there is no possibility, for example, to automatically close connections and file descriptors.  Mark &amp; ‚Äã‚ÄãSweep algorithms can help with this, but writing them is much more difficult. <br><br>  The final touch is the gcMove function. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gcHeader a)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a.gcData[REF_COUNT] &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcMove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gcHeader** current)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*current == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPointer(**current)){<span class="hljs-comment"><span class="hljs-comment">//    .   ,    . (*current) = (*current)-&gt;post_gcAddress; return; } gcHeader* new_obj = gcRawAlloc((*current)-&gt;gcData[STRUCT_SZ], (*current)-&gt;gcData[REF_COUNT]); memcpy(new_obj, (*current), sizeof(char) * (*current)-&gt;gcData[STRUCT_SZ]); gcHeader** iterator = reinterpret_cast&lt;gcHeader**&gt;(new_obj) + 1; (*current)-&gt;post_gcAddress = new_obj; (*current) = new_obj; int refCount = new_obj-&gt;gcData[REF_COUNT] &gt;&gt; 1; for (int i = 0; i &lt; refCount; ++i, ++iterator) gcMove(iterator); }</span></span></code> </pre><br><br>  Let's sort the function from the middle.  We need the ability to redirect links, so a <i>pointer to a pointer</i> to the data is passed to the function. <br><br>  GC allocates the object the necessary amount of memory in the new heap (it knows how much from the header) and copies all the data from the old incarnation to the new one.  Then he writes a new address of the object in the old title.  Now, if the object is pointed to by several references, the algorithm will be able to determine that the object has already been moved once (the low-order bit, guaranteed, 0) and will not copy it once again afterwards.  It remains to redirect the old pointer to a new copy of the object. <br>  Now, you need to deal with the pointers of the object itself.  You need to do the same with them.  Line <br><br><pre> <code class="cpp hljs">gcHeader** iterator = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;gcHeader**&gt;(temp) + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><br>  gets a pointer to the first link in the structure (if there is one, of course).  Remember that sizeof (gcHeader) == sizeof (void *).  Otherwise, it will take a couple more lines. <br>  What to do next, the question is already controversial.  I simply recursively call the gcMove function for each pointer.  Such an algorithm corresponds to bypassing the graph <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B2_%25D0%25B3%25D0%25BB%25D1%2583%25D0%25B1%25D0%25B8%25D0%25BD%25D1%2583">in depth</a> .  However, this is not the best choice. <br>  The killer feature of copying garbage collectors for me is the ability to maintain link locality.  In short, objects that refer to each other, and in the memory should also be as close as possible.  So the processor will be able to more efficiently use its cache memory. <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  You can conduct an experiment.  Create a linked list and start inserting elements into arbitrary places.  And then - just go around and print the entire list.  Most likely, the C ++ program will perform the last stage longer than Java or C # after the forced garbage collection.  This is due to the fact that in the case of C ++, the processor will constantly stop at the cache misses and wait for the data from the slow RAM to arrive.  In the case of Java, this will be practically a traversal of the whole array. </div></div><br><br>  My GC does not know how.  I chose to crawl in depth because of the simplicity.  It is advisable to move objects in the order of walking <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2580%25D0%25B8%25D0%25BD%25D1%2583">wide</a> .  It will be very cool to be confused and to line up objects in memory in accordance with the statistics of calls to them, as <a href="http://arxiv.org/abs/cs.DS/0211010">in this algorithm</a> , in order to achieve the optimal number of misses. <br><br>  That's all.  It remains to demonstrate the work with the collector. <br><br>  As an example, take the simplest <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0">search tree</a> . <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">searchTree</span></span></span><span class="hljs-class"> {</span></span> gcHeader gc; searchTree* left; searchTree* right; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> key; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> refCount = <span class="hljs-number"><span class="hljs-number">2</span></span>; };</code> </pre><br><br>  As already mentioned, there should be a header at the beginning, and after the title all pointers to objects of our heap. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(searchTree* &amp;target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>){ target = gcAlloc&lt;searchTree&gt;(); target-&gt;left = target-&gt;right = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; target-&gt;key = key; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target-&gt;key == key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target-&gt;key &lt; key) stAdd(target-&gt;left, key); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stAdd(target-&gt;right, key); }</code> </pre><br><br>  The usual addition to the tree.  Notice how gcAlloc is used. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">searchTree* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stFind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(searchTree* target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || target-&gt;key == key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target-&gt;key &lt; key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stFind(target-&gt;left, key); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stFind(target-&gt;right, key); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(searchTree* t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indent = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; indent; ++i) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; t &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span> &lt;&lt; t-&gt;key &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; stPrint(t-&gt;left, indent + <span class="hljs-number"><span class="hljs-number">1</span></span>); stPrint(t-&gt;right, indent + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stCut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(searchTree* &amp;target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> || target-&gt;key == key){ target = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target-&gt;key &lt; key) stCut(target-&gt;left, key); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stCut(target-&gt;right, key); }</code> </pre><br><br>  stFind returns a reference to the subtree with the necessary key, stPrint prints out the keys and addresses of the subtree, stCut clips the subtree in which the desired key is stored. <br><br>  Finally, the main. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ gcInit(); stackRef&lt;searchTree&gt; root; stAdd(root.ref, <span class="hljs-number"><span class="hljs-number">2</span></span>); stAdd(root.ref, <span class="hljs-number"><span class="hljs-number">1</span></span>); stAdd(root.ref, <span class="hljs-number"><span class="hljs-number">3</span></span>); stAdd(root.ref, <span class="hljs-number"><span class="hljs-number">6</span></span>); stAdd(root.ref, <span class="hljs-number"><span class="hljs-number">5</span></span>); stAdd(root.ref, <span class="hljs-number"><span class="hljs-number">4</span></span>); stAdd(root.ref, <span class="hljs-number"><span class="hljs-number">8</span></span>); stackRef&lt;searchTree&gt; additionalRef; additionalRef.ref = stFind(root.ref, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Before GC"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; additionalRef.ref &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span> &lt;&lt; currentOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; stPrint(root.ref); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; gcCollect(); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"After GC"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; additionalRef.ref &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span> &lt;&lt; currentOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; stPrint(root.ref); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; stCut(root.ref, <span class="hljs-number"><span class="hljs-number">5</span></span>); gcCollect(); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Deleted some elements and GC'd."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; additionalRef.ref &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span> &lt;&lt; currentOffset &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; stPrint(root.ref); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br><pre> <code class="cpp hljs">Before GC <span class="hljs-number"><span class="hljs-number">0xd92058</span></span> <span class="hljs-number"><span class="hljs-number">224</span></span> <span class="hljs-number"><span class="hljs-number">0xd92018</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0xd92058</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">0xd92078</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">0xd920d8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">0xd92098</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">0xd920b8</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0xd92038</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> After GC <span class="hljs-number"><span class="hljs-number">0xd93108</span></span> <span class="hljs-number"><span class="hljs-number">224</span></span> <span class="hljs-number"><span class="hljs-number">0xd930e8</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0xd93108</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">0xd93128</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">0xd93148</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">0xd93168</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">0xd93188</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0xd931a8</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Deleted some elements <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> GC'd. <span class="hljs-number"><span class="hljs-number">0xd92038</span></span> <span class="hljs-number"><span class="hljs-number">160</span></span> <span class="hljs-number"><span class="hljs-number">0xd92018</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0xd92038</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">0xd92058</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">0xd92078</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">0xd92098</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  As you can see, working with structures for the programmer does not change much.  What's going on here: <br>  1. We randomly fill the search tree. <br>  2. Create another stack reference to one of the elements to check how the GC responds to multiple references to a single object. <br>  3. Print the tree, additionalReference and currentOffset. <br>  4. Empty the cause garbage collection. <br>  5. We print the tree again.  All pointers that are needed - have changed. <br>  6. We prune one subtree and call garbage collection again.  Everything works fine again.  Notice the currentOffset has decreased, and the root of the tree has returned to the same address where it was located for the first time. <br><br><h5>  findings <br></h5><br>  So, in C ++, you can use the Garbage Collector.  Moreover, it is quite a pretty one, in my zamylenny eyes, and even with a minimum overhead.  I will try to list everything that needs to be done so that it is really convenient and useful. <br>  First - the organizational moments. <br><br>  1. Global variables are, of course, not cool at all.  It is necessary to arrange everything as a human class and / or C ++ allocator. <br>  2. To force a cheder into each class is almost sadism.  You just need to give inheritance from the abstract class, which should have two methods - getSize and getLayout.  The latter should return a reference to the array, in which the relative coordinates of all pointers are stored (the idea with ‚Äúall references are at the beginning‚Äù is not at all suitable for something serious).  This array should definitely be filled in automatically, but I still have no idea how to do this. <br><br>  The next question is automatic build.  When the idea of ‚Äã‚ÄãGC itself was put forward, no one meant that someone would actually invoke something like the gcCollect function all the time, everything should happen by itself.  But C ++ is a special case.  It is famous for the fact that the entire flow of execution under the nose, or at least predictable.  The capricious Garbage Collector of any other language here is almost an ideological crime.  So, it should have at least two modes: <br><br>  1. Transparent. <br>  2. Throw an exception after exhausting a certain quota of memory.  Here it is up to the programmer to decide whether to get out or allocate memory forcefully. <br><br>  And one more question.  Multithreading  It's all bad.  To start garbage collection, you need to suspend all threads, so as not to break anything.  As a result, you have to write half the JVM.  The best solution seems to me his absence.  For each thread, you can simply create your own dedicated GC, and if you need to transfer something to another subprocess, nobody has canceled the usual shared_ptr.  Without shared memory, life is usually much more fun. <br><br>  Finish on a sad note.  Such a garbage collector is totally incompatible with any ready-made library.  Their objects will not be able to provide the necessary data.  Despite the fact that std :: list, std :: map and std :: set will only benefit if you rewrite them specifically for GC, redoing N gigabytes of Boost sources, for example, is completely hopeless.  However, for dealing with fragmentation in the case of small objects, such a thing seems to me very useful. <br><br>  You can download and play <a href="https://code.google.com/p/sourcesforhabrahabr/">from here</a> . </div><p>Source: <a href="https://habr.com/ru/post/213225/">https://habr.com/ru/post/213225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213215/index.html">Warm tube sound</a></li>
<li><a href="../213217/index.html">The response of different companies to the vulnerabilities of their resources</a></li>
<li><a href="../213219/index.html">Bethesda announced the imminent release of the beta version of the new part of Doom</a></li>
<li><a href="../213221/index.html">Why March 11th Kuka will lose to Timo Boll</a></li>
<li><a href="../213223/index.html">Why is Windows not installed on MacBook Air 2013 via BootCamp?</a></li>
<li><a href="../213227/index.html">Ideal 404 error page, or how to keep the user on the site?</a></li>
<li><a href="../213231/index.html">Nokia Treasure Tag: smart tags guarding your stuff</a></li>
<li><a href="../213233/index.html">UnionTest / KORAD UT3005EP Laboratory Programmable Linear Power Supply & Calibration / Control</a></li>
<li><a href="../213235/index.html">How we did a car tracker</a></li>
<li><a href="../213237/index.html">As we brought the smart outlet to the level of a mass product</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>