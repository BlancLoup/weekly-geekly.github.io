<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SOINN - self-learning algorithm for robots</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Post number 1. What is SOINN 


 SOINN is a self-organizing incremental neural network. The structure and algorithm of such a neural network seems to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SOINN - self-learning algorithm for robots</h1><div class="post__text post__text-html js-mediator-article"> <b>Post number 1.</b>  <b>What is SOINN</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/176/97a/44c/17697a44cd347a829547b87610a5bd78.jpg" alt="robot SOINN"><br>  SOINN is a self-organizing incremental neural network.  The structure and algorithm of such a neural network seems to have worked well in the Japanese laboratory Hasegawa (site - <a href="http://haselab.info/">haselab.info</a> ), because it was eventually taken as a basis and the further development of algorithms of artificial intelligence went through small modifications and add-ins to the SOINN network. <br><br>  The core network SOINN consists of two layers.  The network receives the input vector and on the first layer after training creates a node (neuron) - the defining class for the input data.  If the input vector is similar to the existing class (the measure of similarity is determined by the learning algorithm settings), then the two most similar neurons of the first layer are connected by a link, or if the input vector is not similar to one existing class, then the first layer creates a new neuron that defines the current class.  Very similar neurons of the first layer, combined by a link, are defined as one class.  The first layer is the input layer for the second layer, and according to a similar algorithm, with a few exceptions, classes are created in the second layer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On the basis of SOINN such networks are created as (the network name and the description of the network from its creators are presented below): <br><a name="habracut"></a><br>  ESOINN - expansion of the SOINN neural network is trained online without third-party intervention and without setting a learning task.  This is an improved version of the SOINN network for on-line uncontrolled classification and training topology.  1 - this network consists of one layer as opposed to two layers in SOINN;  2 - its clusters with high density of overlap;  3 - it uses fewer parameters than SOINN;  and 4 - it is more stable than SOINN.  Experiments on demo data and real data also show that ESOINN works better than SOINN. <br><br>  ASC data classifier based on SOINN.  It automatically determines the number of prototypes and assimilates new information without deleting the information already stored.  It is resistant to noisy data, the classification is very fast.  In the experiment, we use both demo data and real data sets to illustrate ASC.  In addition, we compare ASC with other results based on classifiers, taking into account its classification of errors, compression and speed of classification.  The results show that ASC has better performance and is a very effective classifier ( <a href="http://www.sciencedirect.com/science/article/pii/S089360800800141X">Reference to the original</a> ). <br><br>  GAM - General Associative Memory (GAM) is a system that combines the functions of another type of associative memory (AM).  GAM is a network consisting of three layers: an input layer, a memory layer, and an associative layer.  The input layer accepts input vectors.  A memory layer saves input to similar classes.  The associative layer builds associative connections between classes.  GAM can store and call binary or non-binary information, build many-to-many associations, store and recall both static data and a temporary sequence of information.  May recall information even if it has incomplete input data or noisy data.  Experiments using real-time binary data using static data and time sequence data show that GAM is an efficient system.  In experiments using human-like robots, it demonstrates that GAM can solve real problems and build connections between data structures with different sizes ( <a href="http://www.sciencedirect.com/science/article/pii/S092523121200834X">Reference to the original</a> ). <br><br>  <b>The new</b> STAR-SOINN (STAtistical Recognition - Self-Organizing and Incremental Neural Networks) - to build a smart robot, we must develop the psychic system of an autonomous robot that consistently and quickly learns from man, his environment and the Internet.  Therefore, we offer the STAR-SOINN network - this is an ultra-fast, multi-modal network that learns in real time and has the ability to additionally learn via the Internet.  We conducted experiments to evaluate this teaching method and compared the results with other teaching methods.  The result shows that recognition accuracy is higher than a system that simply adds conditions.  In addition, the proposed method can work very quickly (for about 1 second to study an object, 25 milliseconds, for object recognition).  The algorithm was able to identify the attributes of "unknown" objects by searching for the attribute information of known objects.  Finally, we decided that this system potentially becomes the base technology for future robots. <br><br>  SOIAM - modification SOINN for associative memory. <br><br>  SOINN-PBR - modification of SOINN to create rules using conditions if -&gt; then (if-then) <br><br>  AMD (Autonomous Mental Development) - a robot using this algorithm to learn to solve various problems. <br><br>  <b>The block diagram of the SOINN algorithm can be found</b> <a href="https://sites.google.com/site/algorithmsoinn/Files-store">here.</a> <br><br>  A link to the magazine in pdf format, where a description of several SOINN networks in English is given and where I made notes in Russian (I packed the rar archive, the original magazine size was 20 mb ( <a href="https://docs.google.com/viewer%3Fa%3Dv%26pid%3Dsites%26srcid%3DZGVmYXVsdGRvbWFpbnxhbGdvcml0aG1zb2lubnxneDoxNGRlZDM4MTdmM2QzOGI4">read online</a> ), the archive size was 13 mb ( <a href="">download archive</a> ). <br><br>  Link to another magazine in pdf format, which describes several varieties of SOINN networks in English and where I made notes in Russian (I packed the rar archive, the original journal size was 4mb ( <a href="https://docs.google.com/viewer%3Fa%3Dv%26pid%3Dsites%26srcid%3DZGVmYXVsdGRvbWFpbnxhbGdvcml0aG1zb2lubnxneDpiOTZlMjYwYTdlM2FhZDM">read online</a> ), the archive size was 2.5mb ( <a href="">download archive</a> ). <br><br>  In the Russian-language Internet about the SOINN network, there are only a couple of articles that the robot, working according to this algorithm, finds solutions to the problems and if it is not explained how to solve the problem, then it connects to the Internet and looks for a solution there.  But I did not find examples of the operation of the algorithm and codes.  Only there was one article on robocraft where a small example of the operation of the basic algorithm of the SOINN network in conjunction with OpenCV is given.  If someone experimented with the SOINN network, it would be interesting to look at the code, if possible. <br><br>  Back in 2006, a method of gradual (increasing) learning was proposed, called the self-organizing growing neural network (SOINN), in order to try to implement unsupervised learning (self-study without a teacher).  SOINN does a good job of processing non-stationary data online, reports the number of defined clusters, and represents the topological structure of the input data, taking into account the probability of the probability distribution density.  Hasagawa, who proposed a version of the SOINN network, compared the results of his network operation with the GNG network (expanding neural gas) and the result of the SOINN network was better than that of the GNG network. <br><br>  There were such problems with the SOINN network: <br>  1. Due to the fact that it consisted of two processing layers, that the user had to take part in the network.  The user had to decide when to stop learning the first layer and when to start acquiring knowledge in the second layer. <br>  2. If the groups have high density, then the network coped well with their recognition, but if the network of the group partially overlapped, then the network thought it was one group and united them. <br><br>  To solve these problems and simplify the network architecture, a SOINN-based network with increased self-organization was proposed and called ESOINN. <br><habracut><br><br>  SOINN Short Review. <br>  Soinn consists of a network with two layers.  The first layer studies the distribution density of the input data and uses the nodes and the connections between them to represent the result of the data distribution.  The second layer searches for data in the first layer with the lowest distribution density and identifies groups for them and uses fewer nodes than the first layer to provide the topological structure of the data under study.  When learning of the second layer is completed, SOINN reports the number of found groups and assigns the input data to the group most suitable for it.  The first and second layers work on the same algorithm. <br><br>  When the input vector is applied to the network, it finds the closest node (winner) and the second closest node (second winner) to the input vector.  Using threshold similarity criteria, the network determines whether the input vector belongs to the same group as the winner and the second winner.  The first layer of SOINN adaptively updates the similarity threshold for each node separately, because the criterion for the distribution of input data is not known in advance. <br><br>  If a certain node i has neighboring nodes, then the similarity threshold Ti is calculated using the maximum distance between this node i and its neighboring nodes. <br><br>  FORMULA 1A <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DT%7Bi%7D%26space%3B%3D%26space%3Bmax%5Cleft%26space%3B%5C%7C%26space%3BW%7Bi%7D%26space%3B-%26space%3BW%7Bs%7D%26space%3B%5Cright%26space%3B%5C%7C"><img src="https://habrastorage.org/getpro/habr/post_images/aac/e18/6cc/aace186cce4e258bb2c95e4dfceb8b05.gif" title="T {i} = max \ left \ |  W {i} - W {s} \ right \ |"></a> <br>  Here, Ti (similarity threshold) is the distance to the most distant neighbor of node i.  Wi is the weight of node i, Ws is the weight of neighboring node i <br><br>  If node i does not have neighboring nodes, then the similarity threshold Ti is calculated as the distance between the vector i and the closest vector to it available in the network. <br><br>  Formula 1B <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DT%7Bi%7D%26space%3B%3D%26space%3Bmin%5Cleft%26space%3B%5C%7C%26space%3BW%7Bi%7D%26space%3B-%26space%3BW%7Bn%7D%26space%3B%5Cright%26space%3B%5C%7C"><img src="https://habrastorage.org/getpro/habr/post_images/708/491/368/7084913684b456f99dcec4b550e9e251.gif" title="T {i} = min \ left \ |  W {i} - W {n} \ right \ |"></a> <br>  Here, Wn is the weight of any host except the node i <br><br>  If the distance between the input vector and the winner or the second winner is greater than the similarity threshold of the winner or the second winner, respectively, then the input vector is inserted into the network as a new node and now represents the first node of the new class.  This insert is called an insert between classes, because this insert creates a generation of a new class, even if a new class can be classified in the future as any of the already existing classes. <br><br>  If the input vector is defined as belonging to one cluster as the winner or the second winner, and if there are no links connecting the winner and the second winner, then connect the winner and the second winner using the connection and set the age of this connection to zero;  further increase the age of all ties connected to the winner by 1. <br>  Then we update the weight of the vector of the winner and his neighbors nodes.  We use node i with input data to find the winner node and in the node variable ‚Äî Win_Number ‚Äî we show how many times node i was the winner. <br><br>  Change the weight of the winner according to the formula: <br><br>  Formula 1C <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DW%7Bwin%7D%26space%3B%3D%26space%3B%5Cfrac%7B1%7D%7BC%7Bwin%7D%7D%26space%3B%5Cleft%26space%3B%5C%7C%26space%3BW%7Bi%7D%26space%3B-%26space%3BW%7Bwin%7D%26space%3B%5Cright%26space%3B%5C%7C"><img src="https://habrastorage.org/getpro/habr/post_images/698/892/bdf/698892bdf5a2abf0791136506e46315a.gif" title="W {win} = \ frac {1} {C {win}} \ left \ |  W {i} - W {win} \ right \ |"></a> <br>  where Wwin is the winner's weight, Cwin is the number of victories of the winner, Wi is the weight of the input vector <br><br>  Change the weights of all the neighbors of the winner according to the formula: <br><br>  Formula 1D <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DW%7Bswin%7D%26space%3B%3D%26space%3B%5Cfrac%7B1%7D%7B100C%7Bwin%7D%7D%26space%3B%5Cleft%26space%3B%5C%7C%26space%3BW%7Bi%7D%26space%3B-%26space%3BW%7Bswin%7D%26space%3B%5Cright%26space%3B%5C%7C"><img src="https://habrastorage.org/getpro/habr/post_images/574/8b1/f7b/5748b1f7b6f738bf2d7cd0323b10ac11.gif" title="W {swin} = \ frac {1} {100C {win}} \ left \ |  W {i} - W {swin} \ right \ |"></a> <br>  where Wswin is the winner‚Äôs neighbor weight, Cwin is the number of victories won, Wi is the weight of the input vector <br><br>  If the age of the connection between the nodes is greater than the preset parameter Maximal_expression_connection, then we delete this connection. <br>  When, during the iterative network learning, the preset Time-of-Learning parameter has come to an end, then SOINN realizes that the time for learning is over, it inserts a new node to a point in the topological map, where the accumulated error is the longest.  Cancel node insertion if the insert cannot reduce the size of the error.  This insert is called an insert within the class because the insert occurs within the class.  Also, no new class will be created during this insertion.  Then SOINN finds nodes whose number of neighbors is less than or equal to one and removes such nodes, based on the assumption that such nodes lie in a region of low density.  Such nodes are called noise nodes (noisy nodes). <br><br>  In fact, because the similarity threshold of the first layer of SOINN is updated adaptively, the accumulation error will not be high.  Therefore, an insert within a class is of little use.  Insertion within the class for the first layer is not needed. <br>  After the expiration of the iterative learning time of the first layer, the learning results of the first layer are fed as input to the second layer.  The second layer uses the same learning algorithm as in the first layer.  For the second layer, the similarity threshold (Ti) is constant.  It is calculated using the distance within the class and the distance between the classes.  With a large constant similarity threshold, unlike the first layer, the accumulated error for nodes of the second layer will be very high, and here the insertion within the class plays a big role in the learning process.  With a large constant similarity threshold, the second layer can also remove some noisy nodes that remain unremoved during the training of the first layer. <br><br>  The two-layer SOINN network has the following disadvantages: <br>  It is difficult to choose when to stop learning the first layer and start learning the second layer; <br><br>  If the results of the study of the first layer were changed, all the studied results of the second layer will be destroyed, thus reclassification of the second layer will be required.  The second layer of SOINN is not suitable for gradual online learning. <br><br>  Insertion within the class is necessary for the second layer, but it requires many user-defined parameters. <br>  SOINN is unstable - it cannot separate high-density classes that partially overlap each other. <br><br>  In order to get rid of the aforementioned drawbacks, the developers removed the second layer of SOINN and changed some methods to help a single layer get better classification results than a two-layer SOINN.  Such a network is called ESOINN. <br>  ESOINN accepts data on a single layer.  For insertion between classes, the same algorithm is used as for SOINN.  When creating a connection between the nodes, ESOINN adds the condition whether to create a connection. <br><br>  After the expiration of the Timer_Tutorial timer, ESOINN separates the nodes into different subclasses and removes the links that lie in the overlapped areas.  ESOINN does not use inserts within a class. <br><br>  Removing the second layer makes ESOINN more suitable for continuous (incremental) online learning than double-layer SOINN.  It also removes the difficulty of choosing when to finish the first layer and start the second layer.  Refusal to insert within the class removes five parameters from the network that were necessary for the implementation of such an insert, and the understanding of the network operation algorithm is simplified. <br><br>  <b>ESOINN operation algorithm</b> <br><br>  Overlapping classes (partial superposition of classes on each other).  Let us discuss how to determine the density of a node, using what method one can find the overlap of one class by another, whether it is necessary to build a connection between the winner and the second winner.  The density of the spatial distribution of nodes in the overlapped region is lower than in the center of the class. <br><br>  <b>Knot density</b> <br>  The density of a node is determined by the local accumulation of the number of examples (input data).  If there are many input samples near the node, then the density of the node is considered high, if the input examples near the node are not large, then the density of the node is considered low.  Therefore, at the time when the network is studying, we must count how many times the node was the winner in the variable was the winner, which will show the density of this node.  You can determine the density of a node by using an algorithm like SOINN.  Here the following problems appear: <br>  1. There will be numerous nodes that lie in areas of high density.  In an area with a high density, the chance for a node to be a winner will not be significantly higher than in an area with a low density.  Consequently, we cannot simply use a node's winner in order to measure its density. <br>  2. In the growing tasks of learning, some nodes created at earlier stages will not be winners again over time.  Using the definition of "winner", such nodes can be evaluated as low-density nodes at a later stage of training. <br>  ESOINN uses a new definition of density to help solve the problems described above.  The basic idea is the same as in the local accumulation of the number of input examples (data), but we define a ‚Äúpoint‚Äù occupying the space of ‚Äúnumbers‚Äù and use the average of the accumulated points of a node to describe the density of this node.  Unlike the winner, who binds himself to only one special node, the relationship between the nodes is considered here when we calculate the point P of the node.  First we calculate the average distance. <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%7Bd%7Bi%7D%7D%5E%7B-%7D"><img src="https://habrastorage.org/getpro/habr/post_images/3b2/c6b/6bc/3b2c6b6bceb48c2dd6f84f7b21876142.gif" title="{d {i}} ^ {-}"></a>  node i from its neighbors. <br><br>  FORMULA 1 <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dd_i%5E-%26space%3B%3D%26space%3B%5Cfrac%7B1%7D%7Bm%7D%26space%3B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%26space%3B%5Cleft%26space%3B%5C%7C%26space%3BW_i%26space%3B-%26space%3BW_j%26space%3B%5Cright%26space%3B%5C%7C"><img src="https://habrastorage.org/getpro/habr/post_images/3c0/212/bd9/3c0212bd90b84c4e60b25adeff41a595.gif" title="d_i ^ - = \ frac {1} {m} \ sum_ {i = 1} ^ {m} \ left \ |  W_i - W_j \ right \ |"></a> <br>  Where m is the number of neighbors of node i, Wi is the weight of vector of node i, Wj is the weight of vector of neighbor of node i <br><br>  Then we calculate the POINT of the node i as follows: <br><br>  Formula 2 <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DP%7Bi%7D%3D%5Cfrac%7B1%7D%7B(1%26plus%3B%7Bd%7Bi%7D%7D%5E%7B-%7D)%5E%7B2%7D%7D"><img src="https://habrastorage.org/getpro/habr/post_images/16c/a5a/e02/16ca5ae02921bea8786fbf259df85836.gif" title="P {i} = \ frac {1} {(1+ {d {i}} ^ {-}) ^ {2}}"></a>  if node i is the winner <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DP%7Bi%7D%3D0"><img src="https://habrastorage.org/getpro/habr/post_images/ccb/7c5/90b/ccb7c590b45b9578fc65ab29e37a3b14.gif" title="P {i} = 0"></a>  if node i is not a winner <br>  From the definition of a POINT, we see that if the average distance from node i to its neighbors is large, then the number of nodes in this area is small.  Consequently, the distribution of nodes is rare and the density in this area will be low.  Thus, we give the low POINT to the node i.  If the average distance is small, it means that the number of nodes in this area is high and the density in this area will be high.  Therefore, we give a high POINT to the node i.  For one iteration, we only calculate POINTS for node i, when node i is a winner.  The POINTS of other nodes in this iteration are 0. Therefore, for one iteration, the accumulated POINTS of the winner will be changed, but the accumulated POINTS of the other nodes remain unchanged. <br>  The accumulation of DOTS Si is calculated as the sum of DOTS for node i during its training period. <br><br>  Formula 3 <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DS_i%26space%3B%3D%26space%3B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D(%5Csum_%7Bk%3D1%7D%5E%7Bsig%7D%26space%3Bp_i)"><img src="https://habrastorage.org/getpro/habr/post_images/f69/423/fd4/f69423fd412616442fae73e28e4f0b0b.gif" title="S_i = \ sum_ {i = 1} ^ {n} (\ sum_ {k = 1} ^ {sig} p_i)"></a> <br>  Here, sig is the number of input signals during one training period.  n - shows the time of the training period (which can be calculated as LT / sig, where LT is the average total number of input signals). <br>  Therefore, we take the average accumulated POINT (density) of node i <br><br>  Formula 4 <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dh_%7Bi%7D%3D%7Bs_%7Bi%7D%7D%5E%7B-%7D%3D%5Cfrac%7B1%7D%7BN%7Ds_%7Bi%7D%3D%5Cfrac%7B1%7D%7BN%7D%26space%3B%5Csum_%7Bi%3D1%7D%5E%7Bn%7D(%5Csum_%7Bk%3D1%7D%5E%7Bsig%7D%26space%3Bp_%7Bi%7D%26space%3B)"><img src="https://habrastorage.org/getpro/habr/post_images/fe1/bc3/f96/fe1bc3f96b31a4baa52a47f799284d81.gif" title="h_ {i} = {s_ {i}} ^ {-} = \ frac {1} {N} s_ {i} = \ frac {1} {N} \ sum_ {i = 1} ^ {n} (\ sum_ {k = 1} ^ {sig} p_ {i})"></a> <br>  Here N represents the number of periods when the accumulated points of Si are greater than 0. Note that N is not necessarily equal to n.  We do not use n to take the space N because, for increasing learning during a certain period of learning, the accumulated DOTS Si will be equal to 0. If we use n to calculate the average accumulated DOTS, then the density of some of the old nodes studied will decrease.  Using N to calculate the average of accumulated DOTS, even during lifelong learning, the density of old studied nodes will remain unchanged if no new signals close to these nodes are applied to the system.  However, for some applications it is necessary that the very old information studied was forgotten.  In such cases, we must use n to take the space N. Thus, we can study new knowledge and forget very old knowledge.  In order for all the learned knowledge to remain in the network, you need to take N to determine the density of the node. <br><br>  <b>Search for overlapping areas between classes.</b> <br>  Regarding the definition of density, the easiest way to find covered areas is to look for areas with a low density.  Some methods, such as GCS and SOINN, use this technique to identify overlapped areas.  However, this technique cannot guarantee that a region with a low density is precisely an overlapped region.  For example, for some class that follows the Gaussian distribution, the density at the class boundary will be low.  The overlay includes some of the boundaries of the overlapped classes.  Therefore, the overlap density should be greater than in the overlapped boundary region.  To solve this problem, ESOINN does not use the lowest density rule, but rather creates a new technique to find the overlapped area. <br>  In SOINN, after a period of study, if there is overlap between the classes, all nodes of such classes are connected to form one class.  Our goal is to find an overlapped area in a complex class (which includes many groups), to avoid building new connections between different classes, and thus effectively separate overlapped classes. <br>  To detect an overlapped area, you first need to divide the complex class into several subclasses, using the following rule: <br><br>  <b>Algorithm 1. Division of the composite class into subclasses</b> <br>  1. We will call a node the vertex of a subclass if the node has a maximum local density.  Find all the vertices in the complex class and give each vertex a different label. <br>  2. We classify all other nodes with the same label of the subclass as at their vertices. <br>  3. Each node lies in the overlapped area if the connected nodes have different subclass labels. <br>  This method seems reasonable, but for the actual problem it will lead to several problems.  For example, there are two classes in which the density distribution of nodes is not smooth, but rather similar to the presence of noise.  With algorithm 1, these two classes will be divided into too many subclasses and many overlapping areas will be detected.  You need to smooth the input data before dividing a complex class into subclasses. <br><img src="https://habrastorage.org/getpro/habr/post_images/ed2/42e/9c1/ed242e9c16b9a0f4f7456e9299d27acf.jpg" alt="image"><br>  Picture 1 <br><br>  In Figure 1, two non-smoothed input classes. <br>  Take subclass A and subclass B from figure 1. Suppose that the density of the vertex of the subclass A is Amax, and the density of the vertex of the subclass B is Bmax.  We merge subclasses A and B into one class if the following condition is met: <br>  If a <br><br>  Formula 5 <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dmin(h_%7Bwin%7D,h_%7Bswin%7D)%26space%3B%253E%26space%3BL_%7BA%7DA_%7Bmax%7D"><img src="https://habrastorage.org/getpro/habr/post_images/193/403/7a6/1934037a679facb1617fa1ca53e4db58.gif" title="min (h_ {win}, h_ {swin})> L_ {A} A_ {max}"></a> <br>  Or <br><br>  Formula 6 <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dmin(h_%7Bwin%7D,h_%7Bswin%7D)%26space%3B%253E%26space%3BL_%7BB%7DB_%7Bmax%7D"><img src="https://habrastorage.org/getpro/habr/post_images/c8d/fda/6ec/c8dfda6ec484edbe7697974b8aac501f.gif" title="min (h_ {win}, h_ {swin})> L_ {B} B_ {max}"></a> <br>  Here, the winner and the second winner lie in the overlap area between subclasses A and B. In fact, L is a parameter that belongs to [0,1] which can be calculated automatically using the threshold function. <br><br>  Formula 7 <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DL_%7BA%7D%3D%5Cbegin%7Bcases%7D%26space%3B%26%26space%3B%5Ctext%7B%26space%3B0.0%26space%3Bif%26space%3B%7D%26space%3B2.0%26space%3Bmean_%7BA%7D%5Cgeq%26space%3BA_%7Bmax%7D%26space%3B%5C%5C%26space%3B%26%26space%3B%5Ctext%7B%26space%3B0.5%26space%3Bif%26space%3B%7D%26space%3B3.0%26space%3Bmean_%7BA%7D%26space%3B%5Cgeq%26space%3BA_%7Bmax%7D%253E%26space%3B2.0%26space%3Bmean_%7BA%7D%26space%3B%5C%5C%26space%3B%26%26space%3B%5Ctext%7B%26space%3B1.0%26space%3Bif%26space%3B%7D%26space%3BA_%7Bmax%7D%253E%26space%3B3.0%26space%3Bmean_%7BA%7D%26space%3B%5C%5C%26space%3B%5Cend%7Bcases%7D"><img src="https://habrastorage.org/getpro/habr/post_images/50f/e9f/5da/50fe9f5da5f9ac80e4b45a1eff701c51.gif" title="L_ {A} = \ begin {cases} &amp; \ text {0.0 if} 2.0 mean_ {A} \ geq A_ {max} \\ &amp; \ text {0.5 if} 3.0 mean_ {A} \ geq A_ {max}> 2.0 mean_ {A} \\ &amp; \ text {1.0 if} A_ {max}> 3.0 mean_ {A} \\ \ end {cases}"></a> <br>  Here <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dmean_%7BA%7D"><img src="https://habrastorage.org/getpro/habr/post_images/301/47c/666/30147c6663c1d8e8b364db2c1cee615e.gif" title="mean_ {A}"></a>  is the average density of nodes in the subclass. <br><br>  Formula 8 <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dmean_A%26space%3B%3D%26space%3B%5Cfrac%7B1%7D%7BN_A%7D%5Csum_%7Bi%5Cin%26space%3BA%7D%5E%7B%26space%3B%7Dh_i"><img src="https://habrastorage.org/getpro/habr/post_images/78e/5e5/603/78e5e5603cf715c84fb77ed882828713.gif" title="mean_A = \ frac {1} {N_A} \ sum_ {i \ in A} ^ {} h_i"></a> <br>  Here N is the number of nodes in subclass A. <br>  Thus, by dividing a composite class into different subclasses and then combining them without overlapping the subclasses into one subclass, one can find an overlapped area within the composite class.  After we find the overlapped area, we remove the bonds between the nodes that belong to different subclasses and separate the overlapping classes. <br><br>  <b>Algorithm 2. Creating links between nodes</b> <br>  1. Connect two nodes with a link if the winner and the second winner are new nodes (it is not yet defined to which subclass these nodes belong) <br>  2. Connect two nodes with a link if the winner and the second winner belong to the same subclass. <br>  3. If the winner belongs to subclass A, and the second winner belongs to subclass B. If formulas 5 and 6 are fulfilled, connect these nodes with a link and combine subclasses A and B. Otherwise, we will not connect these nodes with a link, and if the connection between these nodes is already exists, then delete it. <br>  We use algorithm 2, if the winner and the second winner belong to different subclasses, ESOINN in this case gives the two nodes the opportunity to be connected by a link.  We can do so in order to limit the effects of noise during the division of subclasses and try to smooth out the oscillations of the subclasses.  Subclasses can still be related to each other (for example, subclass A and subclass B in Figure 1) if the two subclasses are erroneously divided. <br>  Algorithm 2 shows that the result of ESOINN will be more stable than that of the SOINN network, because even with low overlap density, SOINN will sometimes separate different classes correctly, and sometimes will recognize different classes as one class.  Using the smoothing method, ESOINN can stably separate such overlapped classes.  ESOINN also solves the problem of excessive separation. <br><br>  <b>Node removal due to noise</b> <br>  To remove nodes caused by noise, SOINN removes nodes in regions with very low probable densities.  SOINN uses the following strategy: if the number of input signals generated so far is a multiple of the parameter <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Clambda"><img src="https://habrastorage.org/getpro/habr/post_images/286/968/6cd/2869686cdc21c4508b2bd1325d1f6d22.gif" title="\ lambda"></a>  , delete the nodes that have only one neighboring node or there are no neighboring nodes at all.  For one-dimensional input data and a low noise data set, SOINN uses a local accumulation of the number of candidate node signals for deletion to control the deletion behavior.  In addition, in the two-layer structure of the network SOINN, the second layer helps to remove nodes caused by noise. <br>  For ESOINN, we use almost the same technique of removing nodes as a result of noise, like that of SOINN.  If the number of input signals generated so far is a multiple of the parameter <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Clambda"><img src="https://habrastorage.org/getpro/habr/post_images/286/968/6cd/2869686cdc21c4508b2bd1325d1f6d22.gif" title="\ lambda"></a>  , then we delete such nodes whose topological neighbors have 2 or less than two (&lt;= 2).  The difference between ESOINN and SOINN is that we also remove nodes with two topological neighbors.  We use local accumulation of POINT and various control parameters C1 (for two neighboring nodes) and C2 (for one neighboring node) to select the behavior of deleting nodes.      ,   ESOINN               ,       SOINN.  SOINN      .   ESOINN,       .    1          . <br><br> <b>    </b> <br>      1   2        .     1     5,  5    3,   3    2.        1   2      . <br>       ,         .            ,          .    ,              .      ,       .         ,    SOINN. <br><br> <b> 3.     </b> <br> 1.     . <br> 2.      i    .   i        Ci <br> 3.        ,      i.                 i. <br> 4.    2   ,           . <br><br>      ,       ESOINN <br><br>  4.      ESOINN <br> 1.    ,             .     ,   ‚äÇ√ó <br> 2.      <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cxi%26space%3B%5Cin%26space%3BR%5E%7Bn%7D"><img src="https://habrastorage.org/getpro/habr/post_images/21a/e5a/349/21ae5a3493aae9047387873f0d96fcb0.gif" title="\xi \in R^{n}"></a> <br> 3.    () a1     ( ) a2  : <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Da_%7B1%7D%3Darg%5C:%26space%3Bmin_%7Ba%5Cin%26space%3BA%7D%5Cleft%26space%3B%5C%7C%26space%3B%5Cxi%26space%3B-%26space%3BW_a%26space%3B%5Cright%26space%3B%5C%7C"><img src="https://habrastorage.org/getpro/habr/post_images/5ea/11b/047/5ea11b047c9dc7f8cacf548143da889e.gif" title="a_{1}=arg\: min_{a\in A}\left \| \xi - W_a \right \|"></a> <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Da_%7B2%7D%3Darg%5C:%26space%3Bmin_%7Ba%5Cin%26space%3BA%5Csetminus%26space%3B%5Cleft%26space%3B%5C%7B%26space%3Ba_1%26space%3B%5Cright%26space%3B%5C%7D%7D%5Cleft%26space%3B%5C%7C%26space%3B%5Cxi%26space%3B-%26space%3BW_a%26space%3B%5Cright%26space%3B%5C%7C"><img src="https://habrastorage.org/getpro/habr/post_images/1a2/732/80b/1a273280b221f1d85adb0a9af5fcf950.gif" title="a_{2}=arg\: min_{a\in A\setminus \left \{ a_1 \right \}}\left \| \xi - W_a \right \|"></a> <br><br>    Œæ  a1  a2     <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DT_%7Ba_1%7D"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/7d6/cec/e0f7d6cec8e9c401fcf70038a0086b5e.gif" title="T_{a_1}"></a>  or <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DT_%7Ba_2%7D"><img src="https://habrastorage.org/getpro/habr/post_images/705/5bd/01a/7055bd01ac6b5504fb2673839d9fde56.gif" title="T_{a_2}"></a>      ,           2     .  T    1  1 <br> 4.       a1  1 <br> 5.   2           a1  a2. <br> )    :     a1  a2 ,      0;     a1  a2  ,      a1  a2       0. <br> )      :     a1  a2 ,      a1  a2. <br> 6.      4. <br> 7.  1      <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DM_%7Ba_1%7D"><img src="https://habrastorage.org/getpro/habr/post_images/327/12b/be0/32712bbe0ad82950c830b3d77b4ae27e.gif" title="M_{a_1}"></a>  , <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DM_%7Ba_1%7D(t%26plus%3B1)%3DM_%7Ba_1%7D(t)%26plus%3B1"><img src="https://habrastorage.org/getpro/habr/post_images/344/8a1/017/3448a10175efa9ed6af58cd4a474549d.gif" title="M_{a_1}(t+1)=M_{a_1}(t)+1"></a> <br> 8.          <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cepsilon%26space%3B_1(t)"><img src="https://habrastorage.org/getpro/habr/post_images/1ae/065/6e7/1ae0656e76ba74b8565b1191ac51971a.gif" title="\epsilon _1(t)"></a>  and <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cepsilon%26space%3B_2(t)"><img src="https://habrastorage.org/getpro/habr/post_images/3d3/617/2ec/3d36172ec48e88d366668548bf2bdee4.gif" title="\epsilon _2(t)"></a>     . <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cbigtriangleup%26space%3BW_%7Ba_1%7D%3D%5Cepsilon%26space%3B_1(M_%7Ba_1%7D)(%5Cxi%26space%3B-%26space%3BW_%7Ba_1%7D)"><img src="https://habrastorage.org/getpro/habr/post_images/019/6e6/7c6/0196e67c6d3391aceda9b903e376837a.gif" title="\bigtriangleup W_{a_1}=\epsilon _1(M_{a_1})(\xi - W_{a_1})"></a> <br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cbigtriangleup%26space%3BW_%7Bi%7D%3D%5Cepsilon%26space%3B_2(M_%7Ba_1%7D)(%5Cxi%26space%3B-%26space%3BW_%7Bi%7D)"><img src="https://habrastorage.org/getpro/habr/post_images/eb2/33a/159/eb233a1595bd37353db2c7099f289181.gif" title="\bigtriangleup W_{i}=\epsilon _2(M_{a_1})(\xi - W_{i})"></a>     i  a1 <br>         SOINN      <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cepsilon%26space%3B_1(t)%3D%5Cfrac%7B1%7D%7Bt%7D"><img src="https://habrastorage.org/getpro/habr/post_images/b6c/595/be5/b6c595be5f2b30675283f359833d339b.gif" title="\epsilon _1(t)=\frac{1}{t}"></a>  and <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3D%5Cepsilon%26space%3B_2(t)%3D%5Cfrac%7B1%7D%7B100t%7D"><img src="https://habrastorage.org/getpro/habr/post_images/84e/d1e/583/84ed1e583718414f95812d6905e3fba6.gif" title="\epsilon _2(t)=\frac{1}{100t}"></a> <br> 9.  ,        <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dage_%7Bmax%7D"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/cc8/67a/d4ccc867a29f3aa13cddb84baa444fe6.gif" title="age_{max}"></a>    . <br> 10.          Œª: <br> )         1 <br> )        : <br> 1.     ,   a   ,  <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dh_%7Ba%7D%253C%26space%3BC_1%5Csum_%7Bj%3D1%7D%5E%7BN_A%7Dh_j/N_A"><img src="https://habrastorage.org/getpro/habr/post_images/56a/eeb/970/56aeeb97025129c019519096712b8415.gif" title="h_{a}< C_1\sum_{j=1}^{N_A}h_j/N_A"></a> ,    a. <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3DN_A"><img src="https://habrastorage.org/getpro/habr/post_images/eed/204/741/eed2047417a358b4e71276ba3d40d50d.gif" title="N_A"></a> ‚Äì       . <br> 2.      ,        <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dh_a%26space%3B%253C%26space%3BC_2%5Csum_%7Bj%3D1%7D%5E%7BN_A%7D%26space%3Bh_j/N_A"><img src="https://habrastorage.org/getpro/habr/post_images/392/de6/a56/392de6a56c264484770848ad7d73d13d.gif" title="h_a < C_2\sum_{j=1}^{N_A} h_j/N_A"></a> ,    . <br> 3.     ,      ,    . <br> 11.    ,        3;    ,         . <br> 12.    2          . <br><br>    ,          .                         .      ,       Œª   .   ,   .      Œª      .  ,   ,       .          ;         .              ,        .                   .              ,                   .        ;         . ,     ,        . <br><br> <b>    ESOINN</b> <br><br> <b>  </b> . <br><br>         ‚Ññ 1   Hasegawa    SOINN.      ,      .       10% .    ,         ,  SOINN ,    .      .               .       ,  ,       ‚Ññ 1     ( 1).         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b91/70f/c02/b9170fc02ae45b72ab92910f54536440.jpg" alt="image"><br>  1.   ‚Ññ 1 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f65/4b2/a96/f654b2a96c772b972792c31beba4442d.jpg" alt="image"><br>  2. ESOINN     ‚Ññ 1 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/063/e1b/39a/063e1b39afdff4cd0b66d61c7f5523f6.jpg" alt="image"><br>  3. ESOINN      ‚Ññ 1 <br><br>    ESOINN     .    Œª=100, <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dage_%7Bmax%7D"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/cc8/67a/d4ccc867a29f3aa13cddb84baa444fe6.gif" title="age_{max}"></a> =100, c1=0.001  c2=1.  2     ;  3     .    ESOINN           . ESOINN          SOINN     . <br>       ‚Ññ 2 ( 4),        ,    SOINN   ESOINN.   10%     .       ,      ,         .              .      ,  ,   .               1.  10000  ,       2.    10000  ,      3    .  ,    ,         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/452/b58/4d6/452b584d61132fd726b2f04cc44ab53b.jpg" alt="image"><br>  4.   ‚Ññ 2 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef5/73b/d08/ef573bd085de93aeeb6a0dc0b1bf7503.jpg" alt="image"><br>  5. SOINN      ‚Ññ 2 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cbf/faa/f0c/cbffaaf0cdc453d01b684104a9843e8f.jpg" alt="image"><br>  6. SOINN       ‚Ññ 2 <br><br>  5  6   SOINN (   :  Œª=200, <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dage_%7Bmax%7D"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/cc8/67a/d4ccc867a29f3aa13cddb84baa444fe6.gif" title="age_{max}"></a> =50,  c =1   ,       Shen, F., &amp; Hasegawa, O. (2006a). An incremental network for on-line unsupervised classification and topology learning. Neural Networks, 19, 90‚Äì106.)    SOINN         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/543/5ff/e62/5435ffe62cc6ef19de59c6b1ec47673a.jpg" alt="image"><br>  7. ESOINN      ‚Ññ 2 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9c/c65/315/a9cc65315fe1e054e8bdec99aca6b7f7.jpg" alt="image"><br>  8. ESOINN       ‚Ññ 2 <br><br>  7  8   ESOINN (  :  Œª=200, <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dage_%7Bmax%7D"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/cc8/67a/d4ccc867a29f3aa13cddb84baa444fe6.gif" title="age_{max}"></a> =50, c1=0.001  c2=1).       SOINN, ESOINN        .  ,               .      ‚Ññ 2 ,  ESOINN        ,  SOINN. <br><br> <b> </b> <br><br>       10   AT&amp;T_FACE  ;      10  ( 9).     92112 ,       256  .       . ,   92112,      2328    .        2328  width=4, q=2   2328   ( 10) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/788/a38/c43/788a38c43bbbfc643d69078085ca0b87.jpg" alt="image"><br>  9.    <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d61/800/cba/d61800cba95f44b5a4415c065b03e72c.jpg" alt="image"><br>  10.       <br><br>   ,      .             1,  1000  ,        2   .    :  Œª=25, <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dage_%7Bmax%7D"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/cc8/67a/d4ccc867a29f3aa13cddb84baa444fe6.gif" title="age_{max}"></a> =25, c1=0.0  c2=1.0.   , ESOINN        10      ( )  .                  .    SOINN,          (90%     86%   ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/119/751/711/1197517111657ae6ee3b6657a33a73a3.jpg" alt="image"><br>  11.    <br><br>    SOINN  ESOINN,   1000          .     11   SOINN,     11 ‚Äì   ESOINN.     SOINN (2-16)  ,   ESOINN (6-14);     10  SOINN     ESOINN,   ,  ESOINN  ,  SOINN. <br>     ,   Optical Recognition of Handwritten Digits database (optdigits) ( <a href="http://www.ics.uci.edu/">www.ics.uci.edu</a> Àúmlearn/MLRepository.html )   SOINN  ESOINN.      10  ( )  43 ,  30          13  ‚Äì   .     3823 ,      1797 .    64. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b17/be8/f9f/b17be8f9f521f9810c9dd24bcb8d0480.jpg" alt="image"><br>  12.   .  SOINN,  ESOINN <br><br> -,       SOINN (  Œª=200, <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dage_%7Bmax%7D"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/cc8/67a/d4ccc867a29f3aa13cddb84baa444fe6.gif" title="age_{max}"></a> =50,  c =1.0       ).    SOINN    10 . ,   12,      SOINN.      SOINN    .        92,2%;        90,4%.   100    SOINN.     6  13    (  ). <br>       ESOINN.    (Œª=200, <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dage_%7Bmax%7D"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/cc8/67a/d4ccc867a29f3aa13cddb84baa444fe6.gif" title="age_{max}"></a> =50, c1=0.001  c2=1), ESOINN    12 .    12      ESOINN. ESOINN   1       9    ,           1  1'      9  9'. SOINN   ,     1'  9'. ESOINN       1  1' (9  9'),      . <br>       ESOINN       .        94,3%         95,8%.   100    ESOINN.     10  13   . <br>       ,    ESOINN     ,  SOINN. ESOINN          SOINN. <br><br>  <b>Conclusion</b> <br><br>           ESOINN,     SOINN.     SOINN, ESOINN    . ESOINN      ()  .   ESOINN        ,         .  ESOINN          .    ESOINN         SOINN.    , ESOINN     SOINN. <br><br>         ,   Learning Vector Quantization (LVQ).              .          ,            .                 ,         ,       . ESOINN  SOINN     ,       ,  ESOINN     .       .    ESOINN      . <br><br> <b>- ESOINN  </b> <a href="https://sites.google.com/site/algorithmsoinn/Files-store"></a> <br><br>       ESOINN  1,8 . ( <a href="https://docs.google.com/viewer%3Fa%3Dv%26pid%3Dsites%26srcid%3DZGVmYXVsdGRvbWFpbnxhbGdvcml0aG1zb2lubnxneDo2ODU2NzRjZGMyOGI2ODBm"> </a> ) <br><br>       ESOINN   ,       .    . <br>   Github    SOINN  ++ ( <a href="https://github.com/mitmul/SOINN_CPP"></a> ) <br>        SOINN    OpenCV ( <a href="http://robocraft.ru/blog/algorithm/578.html"> SOINN  </a> ) </habracut></div><p>Source: <a href="https://habr.com/ru/post/188230/">https://habr.com/ru/post/188230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../188214/index.html">Method for quickly calculating the IPv4 network address by mask</a></li>
<li><a href="../188218/index.html">Attracting audiences - do-it-yourself affiliate program</a></li>
<li><a href="../188222/index.html">Struts2 is under attack or CVE-2013-2115</a></li>
<li><a href="../188224/index.html">Visual overview of optical transmitters</a></li>
<li><a href="../188226/index.html">New sensory material for measuring strain, humidity, temperature, pressure ... and then what?</a></li>
<li><a href="../188232/index.html">New kind of mozilla vlc plugin</a></li>
<li><a href="../188236/index.html">SIM-cards of passengers of the Moscow metro will be subjected to contactless reading</a></li>
<li><a href="../188238/index.html">Recover Apache Derby without backup</a></li>
<li><a href="../188240/index.html">AWS: Cloudwatch + SNS</a></li>
<li><a href="../188242/index.html">Search through sphinx in django 1.6 admin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>