<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We program "Megaprocessor"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Geektimes in the summer there was an article about the Megaprocessor - a processor of discrete transistors and LEDs, which weighs half a ton and oc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We program "Megaprocessor"</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f56/393/8e3/f563938e3ab5f796b19c8f2e452906c6.gif" align="left">  On Geektimes in the summer there was <a href="https://geektimes.ru/post/278410/">an article about the Megaprocessor</a> - a processor of discrete transistors and LEDs, which weighs half a ton and occupies the entire living room in an ordinary townhouse near Cambridge.  I decided to take advantage of my geographical proximity to this megaproject, and program something presentable for it - for example, to sport my <a href="https://habrahabr.ru/post/276371/">previous</a> Digital Rain program for Megaprocessor. <br><br>  System commands Megaprocessor <a href="http://www.megaprocessor.com/instruction_set.pdf">described on the developer's site</a> . <br><br>  Most commands consist of one byte, followed by an immediate operand (one or two bytes).  There are only four general-purpose registers (R0-R3), while they are not equal: for example, for memory access commands, the address must be either in R2 or in R3;  and the operand is in one of the two remaining registers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Programmers accustomed to the x86 or ARM command system, the Megaprocessor command set will seem extremely poor: there is no indirect addressing "base + offset", no direct operands for arithmetic commands (except <code>addq ¬±1</code> , <code>addq ¬±2</code> ).  But there are a couple of unexpected possibilities: a separate <code>sqrt</code> command, and the <code>.wt</code> mode for shift commands, which replaces the result with the sum of the extended bits.  Thus you can, for example, a pair of commands <code>ld.b r1, #15; lsr.wt r0, r1</code>  <code>ld.b r1, #15; lsr.wt r0, r1</code> calculate the number of single bits in <code>r0</code> (a question so much favored by job interviewers!).  The ln mnemonic for a command that loads an immediate value into the register (instead of the mnemonic <code>mov</code> usual for x86 or ARM) indicates the way it is executed: in fact, from the point of view of the processor, <code>ld.b r1, (pc++)</code> is executed. <br><br>  So let's get started. <br><a name="habracut"></a><br>  The program for Megaprocessor starts (at address 0) from the interrupt vector table.  Each of the four vectors has four bytes.  Starting at address 0x10, the actual program code can be located.  Of the 64KB address space, the entire first half (up to the address 0x8000) can be used by the code;  addresses 0xA000-0xA0FF correspond to the ‚Äúdisplay‚Äù - a discrete memory, each bit of which is equipped with an LED indicator.  <a href="https://habrahabr.ru/users/marks/" class="user_link">marks was</a> wrong when writing ‚ÄúThe memory capacity is 256 bytes.‚Äù is the amount of ‚Äúvideo memory‚Äù, and not the main memory for the code and data. <br><br>  Of the four interrupt vectors in our program, only the <code>reset</code> vector is used, and in the remaining vectors there is a ‚Äústub‚Äù from one <code>reti</code> instruction.  (For x86 or ARM programmers, the return command from the interrupt handler is familiar under the <code>iret</code> mnemonic.) None of these interrupts in our program can happen anyway, so even the stubs could not be set for them. <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>: jmp <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; nop; ext_int: reti; nop; nop; nop; div_zero: reti; nop; nop; nop; illegal: reti; nop; nop; nop;</code> </pre><br>  First of all, after the launch, you need to initialize the stack and variables.  Let the stack grow downwards, starting at address 0x2000 - this is enough for us with a large margin.  Variables will need only two: <code>seed</code> for the current RNG value, and the <code>position</code> array of 32 values ‚Äã‚Äã‚Äî one for each ‚Äúdisplay column‚Äù ‚Äîto keep track of where ‚Äúdrop‚Äù crawls in this column.  We initialize the array with just 32 random bytes.  The <code>jsr</code> command ‚Äî subroutine call ‚Äî matches the <code>call</code> in x86 or <code>bl</code> in ARM. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">start</span></span>: ld.w r0, #<span class="hljs-number"><span class="hljs-number">0x2000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> sp, r0; // <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> random positions ld.b r1, #<span class="hljs-number"><span class="hljs-number">32</span></span>; init_loop: jsr rand; // <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r0 ld.b r2, #position; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r2, r1; st.b (r2), r0; addq r1, #<span class="hljs-number"><span class="hljs-number">-1</span></span>; bne init_loop;</code> </pre> <br>  Since it is impossible to write a byte at the address <code>(#position + r1)</code> one command, you first have to calculate the address <code>(#position + r1)</code> separate addition command. <br><br>  The main part of the program is an infinite loop in which we go from right to left along each ‚Äúdisplay column‚Äù and move the ‚Äúdrop‚Äù in it one position down.  The low two bits of the ‚Äúdrop‚Äù denote its color (3 - ‚Äúlit‚Äù; 0, 1 or 2 - ‚Äúnot lit‚Äù), the remaining six bits - the coordinate (0..63), therefore ‚Äúshifting down‚Äù means adding 4. How only the ‚Äúdrop‚Äù crawled to the bottom of the ‚Äúdisplay‚Äù (the value exceeded 255), replacing it with a new random byte. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">busy_loop</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ld</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#32</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">next_col</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ld</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#position</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">ld</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span>, (<span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">addq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#2</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">addq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#2</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">btst</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#8</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">beq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">save</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">jsr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rand</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">save</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">st</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.b</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">addq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#-1</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">bmi</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">busy_loop</span></span>;</code> </pre> <br>  It is impossible to <code>addq r0, #2</code> 4 with one command, so we repeat <code>addq r0, #2</code> twice, and then check the eighth bit of the result to determine if it has exceeded the value of 255. If it has exceeded, then save the new random value to the <code>position</code> array;  otherwise, save the old one, incremented by 4. The conditional branch command <code>bmi</code> moves to the beginning of the <code>busy_loop</code> cycle if the result of the last action is negative, i.e.  after processing the zero column. <br><br>  How will we generate random numbers?  <a href="https://en.wikipedia.org/wiki/RANDU">RANDU</a> , which I used in 32-bit ‚ÄúDigital Rain‚Äù, is no longer suitable: Megaprocessor is able to multiply only 16-bit numbers;  therefore, from the <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">list of simple RNGs,</a> we take one, where the factor is 16-bit.  I liked the RNG labeled ‚ÄúTurbo Pascal‚Äù. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">rand</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ld</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.w</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">seed</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">ld</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.w</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#33797</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">mulu</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">addq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#1</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">st</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.w</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">seed</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">move</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span>;</code> </pre> <br>  This simple and nice RNG returns the generated value to r0, but unfortunately it spoils the values ‚Äã‚Äãof all the other registers.  Note that in both cases, when we call <code>rand</code> , we have the index of the ‚Äúdisplay column‚Äù in <code>r1</code> , and it needs to be saved and restored;  and then in <code>r2</code> should be an offset <code>(#position + r1)</code> .  So you can put this offset into <code>rand</code> calculation: <br><br><pre> <code class="hljs pgsql">rand: push r1; // ! ld.w r0, seed; ld.w r1, #<span class="hljs-number"><span class="hljs-number">33797</span></span>; mulu; addq r2, #<span class="hljs-number"><span class="hljs-number">1</span></span>; st.w seed, r2; pop r1; // ! <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> r0, r2; ld.b r2, #position; // ! <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r2, r1; // ! ret; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>: ld.w r0, #<span class="hljs-number"><span class="hljs-number">0x2000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> sp, r0; // <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> random positions ld.b r1, #<span class="hljs-number"><span class="hljs-number">32</span></span>; init_loop: jsr rand; st.b (r2), r0; addq r1, #<span class="hljs-number"><span class="hljs-number">-1</span></span>; bne init_loop; busy_loop: ld.b r1, #<span class="hljs-number"><span class="hljs-number">32</span></span>; next_col: ld.b r2, #position; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r2, r1; ld.b r0, (r2); addq r0, #<span class="hljs-number"><span class="hljs-number">2</span></span>; addq r0, #<span class="hljs-number"><span class="hljs-number">2</span></span>; btst r0, #<span class="hljs-number"><span class="hljs-number">8</span></span>; beq save; jsr rand; save: st.b (r2), r0; addq r1, #<span class="hljs-number"><span class="hljs-number">-1</span></span>; bmi busy_loop;</code> </pre><br>  The last trick here is that calculating <code>ld.b r2, #position; add r2, r1;</code> <code>ld.b r2, #position; add r2, r1;</code>  at the beginning of the <code>next_col</code> cycle, <code>next_col</code> can replace it by jumping into the <code>rand</code> subroutine: <br><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>: push r1; ld.w r0, <span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>; ld.w r1, #<span class="hljs-number"><span class="hljs-number">33797</span></span>; mulu; addq r2, #<span class="hljs-number"><span class="hljs-number">1</span></span>; st.w <span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>, r2; pop r1; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> r0, r2; add_position: ld.b r2, #position; add r2, r1; ret; start: &lt;...&gt; busy_loop: ld.b r1, #<span class="hljs-number"><span class="hljs-number">32</span></span>; next_col: jsr add_position; <span class="hljs-comment"><span class="hljs-comment">// ! ld.b r0, (r2); addq r0, #2; addq r0, #2; btst r0, #8; beq save; jsr rand; save: st.b (r2), r0; addq r1, #-1; bmi busy_loop;</span></span></code> </pre><br>  Now the most interesting thing is the second half of the <code>next_col</code> cycle, which will draw the ‚Äúdrop‚Äù on the display. <br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> r3, r1; // x (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>f) lsr r3, #<span class="hljs-number"><span class="hljs-number">3</span></span>; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>) ld.b r2, #<span class="hljs-number"><span class="hljs-number">0xfc</span></span>; // y mask <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r2, r0; // y * <span class="hljs-number"><span class="hljs-number">4</span></span> (<span class="hljs-number"><span class="hljs-number">0.</span></span>.fc) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r3, r2; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> screen ld.w r2, #<span class="hljs-number"><span class="hljs-number">0xa000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r3, r2; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memory ld.b r2, #<span class="hljs-number"><span class="hljs-number">2</span></span>; lsr.wt r0, r2; ld.b r2, #<span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r2, r1; // <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> byte (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.7</span></span>) lsl r2, #<span class="hljs-number"><span class="hljs-number">1</span></span>; lsr r0, #<span class="hljs-number"><span class="hljs-number">2</span></span>; roxr r2, #<span class="hljs-number"><span class="hljs-number">1</span></span>; ld.b r0, (r3); // <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> now apply test r2; bpl blank; bset r0, r2; jmp apply; blank: bclr r0, r2; apply: st.b (r3), r0; jmp next_col;</code> </pre><br>  In order to ‚Äúignite‚Äù or ‚Äúextinguish‚Äù the desired bit, the first step is to calculate the address of the corresponding byte of the ‚Äúvideo memory‚Äù.  Since our ‚Äúcolumn‚Äù number is stored in <code>r1</code> , and the position and ‚Äúcolor‚Äù of a drop is in <code>r0</code> , the byte address is calculated as <code>(r1 &gt;&gt; 3) + (r0 &amp; 0xfc) + 0xa000</code> .  After that, the commands <code>ld.b r2, #2; lsr.wt r0, r2;</code> <code>ld.b r2, #2; lsr.wt r0, r2;</code>  we determine the color of the drop: if both lower bits in <code>r0</code> have been set, then as a result of these commands in <code>r0</code> will be a value of 2;  otherwise, the value is 0 or 1. Finally, in the three lower bits of <code>r2</code> we memorize the number of the required bit of the ‚Äúvideo memory‚Äù, and ‚Äúpush‚Äù into the high bit of <code>r2</code> color of the drop with the sequence <code>lsl r2, #1; lsr r0, #2; roxr r2, #1;</code> <code>lsl r2, #1; lsr r0, #2; roxr r2, #1;</code>  - the second command pushes the color bit from <code>r0</code> to the CF flag, and the last (cyclic right shift with CF) pushes this bit into <code>r2</code> .  When the registers are not enough for all the necessary values, you have to be clever!  Finally, a byte is retrieved from the ‚Äúvideo memory‚Äù at the desired address, and depending on the color bit, this byte is either set or the required bit is reset.  The <code>bset</code> and <code>bclr</code> use only the lower bits of their second operand, so the color bit in the high bit <code>r2</code> does not interfere with them.  We check this high bit with the sequence <code>test r2; bpl blank;</code> <code>test r2; bpl blank;</code>  - the conditional jump command <code>bpl</code> performs the jump if the result of the last action is positive, i.e.  bit color shot. <br><br>  And that's what comes out of it: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/VmX2x2rygFY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">Complete code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>: jmp <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; nop; ext_int: reti; nop; nop; nop; div_zero: reti; nop; nop; nop; illegal: reti; nop; nop; nop; rand: push r1; ld.w r0, seed; ld.w r1, #<span class="hljs-number"><span class="hljs-number">33797</span></span>; mulu; addq r2, #<span class="hljs-number"><span class="hljs-number">1</span></span>; st.w seed, r2; pop r1; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> r0, r2; add_position: ld.b r2, #position; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r2, r1; ret; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>: ld.w r0, #<span class="hljs-number"><span class="hljs-number">0x2000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> sp, r0; // <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> random positions ld.b r1, #<span class="hljs-number"><span class="hljs-number">32</span></span>; init_loop: jsr rand; st.b (r2), r0; addq r1, #<span class="hljs-number"><span class="hljs-number">-1</span></span>; bne init_loop; busy_loop: ld.b r1, #<span class="hljs-number"><span class="hljs-number">32</span></span>; next_col: jsr add_position; ld.b r0, (r2); addq r0, #<span class="hljs-number"><span class="hljs-number">2</span></span>; addq r0, #<span class="hljs-number"><span class="hljs-number">2</span></span>; btst r0, #<span class="hljs-number"><span class="hljs-number">8</span></span>; beq save; jsr rand; save: st.b (r2), r0; addq r1, #<span class="hljs-number"><span class="hljs-number">-1</span></span>; bmi busy_loop; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> r3, r1; // x (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>f) lsr r3, #<span class="hljs-number"><span class="hljs-number">3</span></span>; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>) ld.b r2, #<span class="hljs-number"><span class="hljs-number">0xfc</span></span>; // y mask <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r2, r0; // y * <span class="hljs-number"><span class="hljs-number">4</span></span> (<span class="hljs-number"><span class="hljs-number">0.</span></span>.fc) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r3, r2; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> screen ld.w r2, #<span class="hljs-number"><span class="hljs-number">0xa000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r3, r2; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memory ld.b r2, #<span class="hljs-number"><span class="hljs-number">2</span></span>; lsr.wt r0, r2; ld.b r2, #<span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r2, r1; // <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> byte (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.7</span></span>) lsl r2, #<span class="hljs-number"><span class="hljs-number">1</span></span>; lsr r0, #<span class="hljs-number"><span class="hljs-number">2</span></span>; roxr r2, #<span class="hljs-number"><span class="hljs-number">1</span></span>; ld.b r0, (r3); // <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> now apply test r2; bpl blank; bset r0, r2; jmp apply; blank: bclr r0, r2; apply: st.b (r3), r0; jmp next_col; seed: dw <span class="hljs-number"><span class="hljs-number">1</span></span>; position:;</code> </pre></div></div><br>  There was a final touch: to make the "drops" blink, as on the GIF-KDPV.  In fact, this means that the program will work twice as slowly: at each iteration of the cycle, the <code>busy_loop</code> will first light and then extinguish each drop.  On the lighting semi-iteration, it will be necessary to set two bits of video memory: for the current position of the ‚Äúdrop‚Äù and for the previous one (canceled by the last semi-iteration). <br><br>  So, the ‚Äúdrop‚Äù must be ignited if a) the two lower bits of its value are both set;  b) we are on the igniting half-littering  - and extinguish in all other cases.  The easiest way to do all this is to replace the command sequence that defines the color of the drop ( <code>ld.b r2, #2; lsr.wt r0, r2;</code> ) with the fixed value <code>#2</code> with the <code>flag</code> variable, which will have the value 2 on the igniting half-iteration, and 1 on extinguishing: <br><br><pre> <code class="hljs pgsql">busy_loop: ld.b r1, #<span class="hljs-number"><span class="hljs-number">3</span></span>; // ! ld.b r2, flag; // ! sub r1, r2; // ! st.b flag, r1; // ! ld.b r1, #<span class="hljs-number"><span class="hljs-number">32</span></span>; next_col: jsr add_position; ld.b r0, (r2); ld.b r3, flag; // ! lsr r3, #<span class="hljs-number"><span class="hljs-number">1</span></span>; // ! lsl r3, #<span class="hljs-number"><span class="hljs-number">2</span></span>; // ! <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r0, r3; // ! btst r0, #<span class="hljs-number"><span class="hljs-number">8</span></span>; beq save; jsr rand; save: st.b (r2), r0; addq r1, #<span class="hljs-number"><span class="hljs-number">-1</span></span>; bmi busy_loop; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> r3, r1; // x (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>f) lsr r3, #<span class="hljs-number"><span class="hljs-number">3</span></span>; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>) ld.b r2, #<span class="hljs-number"><span class="hljs-number">0xfc</span></span>; // y mask <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r2, r0; // y * <span class="hljs-number"><span class="hljs-number">4</span></span> (<span class="hljs-number"><span class="hljs-number">0.</span></span>.fc) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r3, r2; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> screen ld.w r2, #<span class="hljs-number"><span class="hljs-number">0xa000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r3, r2; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memory ld.b r2, flag; // ! lsr.wt r0, r2;</code> </pre><br>  At the beginning of the <code>busy_loop</code> loop <code>busy_loop</code> we subtract the current <code>flag</code> value from 3, i.e.  change 2 by 1, and 1 by 2. Instead of moving the ‚Äúdrop‚Äù down at each iteration ( <code>addq r0, #2; addq r0, #2;</code> ), we add to <code>r0</code> value <code>(flag &gt;&gt; 1) &lt;&lt; 2</code> , t .  4 on igniting semi-iteration, and 0 on quenching. <br><br>  The last thing left to add is to set one more bit on the lighting half-lit, in a byte at offset -4 from the ‚Äúdrop‚Äù itself: <br><br><pre> <code class="hljs erlang-repl"> // and now apply test r2; bpl blank; bset r0, r2; st.b (r3), r0; // ! addq r3, #-<span class="hljs-number"><span class="hljs-number">2</span></span>; // ! addq r3, #-<span class="hljs-number"><span class="hljs-number">2</span></span>; // ! btst r3, #<span class="hljs-number"><span class="hljs-number">8</span></span>; // ! bne next_col; // ! ld.b r0, (r3); // ! bset r0, r2; // ! jmp apply; blank: bclr r0, r2; apply: st.b (r3), r0; jmp next_col;</code> </pre><br>  Check <code>btst r3, #8; bne next_col;</code> <code>btst r3, #8; bne next_col;</code>  ensures that we do not go beyond the top edge of the "display" and do not try to write something at 0x9FFx. <br><br>  Now the drops are flashing as intended: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvX4qIG3lfw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">Complete code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">reset</span></span>: jmp <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; nop; ext_int: reti; nop; nop; nop; div_zero: reti; nop; nop; nop; illegal: reti; nop; nop; nop; rand: push r1; ld.w r0, seed; ld.w r1, #<span class="hljs-number"><span class="hljs-number">33797</span></span>; mulu; addq r2, #<span class="hljs-number"><span class="hljs-number">1</span></span>; st.w seed, r2; pop r1; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> r0, r2; add_position: ld.b r2, #position; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r2, r1; ret; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>: ld.w r0, #<span class="hljs-number"><span class="hljs-number">0x2000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> sp, r0; // <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> random positions ld.b r1, #<span class="hljs-number"><span class="hljs-number">32</span></span>; init_loop: jsr rand; st.b (r2), r0; addq r1, #<span class="hljs-number"><span class="hljs-number">-1</span></span>; bne init_loop; busy_loop: ld.b r1, #<span class="hljs-number"><span class="hljs-number">3</span></span>; ld.b r2, flag; sub r1, r2; st.b flag, r1; ld.b r1, #<span class="hljs-number"><span class="hljs-number">32</span></span>; next_col: jsr add_position; ld.b r0, (r2); ld.b r3, flag; lsr r3, #<span class="hljs-number"><span class="hljs-number">1</span></span>; lsl r3, #<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r0, r3; btst r0, #<span class="hljs-number"><span class="hljs-number">8</span></span>; beq save; jsr rand; save: st.b (r2), r0; addq r1, #<span class="hljs-number"><span class="hljs-number">-1</span></span>; bmi busy_loop; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> r3, r1; // x (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>f) lsr r3, #<span class="hljs-number"><span class="hljs-number">3</span></span>; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>) ld.b r2, #<span class="hljs-number"><span class="hljs-number">0xfc</span></span>; // y mask <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r2, r0; // y * <span class="hljs-number"><span class="hljs-number">4</span></span> (<span class="hljs-number"><span class="hljs-number">0.</span></span>.fc) <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r3, r2; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> screen ld.w r2, #<span class="hljs-number"><span class="hljs-number">0xa000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> r3, r2; // byte addr <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memory ld.b r2, flag; lsr.wt r0, r2; ld.b r2, #<span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> r2, r1; // <span class="hljs-type"><span class="hljs-type">bit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> byte (<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.7</span></span>) lsl r2, #<span class="hljs-number"><span class="hljs-number">1</span></span>; lsr r0, #<span class="hljs-number"><span class="hljs-number">2</span></span>; roxr r2, #<span class="hljs-number"><span class="hljs-number">1</span></span>; ld.b r0, (r3); // <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> now apply test r2; bpl blank; bset r0, r2; st.b (r3), r0; addq r3, #<span class="hljs-number"><span class="hljs-number">-2</span></span>; addq r3, #<span class="hljs-number"><span class="hljs-number">-2</span></span>; btst r3, #<span class="hljs-number"><span class="hljs-number">8</span></span>; bne next_col; ld.b r0, (r3); bset r0, r2; jmp apply; blank: bclr r0, r2; apply: st.b (r3), r0; jmp next_col; seed: dw <span class="hljs-number"><span class="hljs-number">1</span></span>; flag: db <span class="hljs-number"><span class="hljs-number">2</span></span>; position:;</code> </pre></div></div><br>  Now, in order to try to launch your own program on Megaprocessor, you need to agree with its creator about a visit to his home;  but in a month, according to him, Megaprocessor will move to the <a href="http://www.computinghistory.org.uk/">Cambridge Computer History Center</a> , and will be available to the general public five days a week. <br><br>  Successes in megaprogramming! </div><p>Source: <a href="https://habr.com/ru/post/309654/">https://habr.com/ru/post/309654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309644/index.html">Baruch Sadogursky and Kirill Tolkachev about DevOps on jug.msk.ru</a></li>
<li><a href="../309646/index.html">Cable Management and PUE: How are they connected?</a></li>
<li><a href="../309648/index.html">WaveNet: a new model for generating human speech and music</a></li>
<li><a href="../309650/index.html">Happy programmer's day: 10 myths about magicians of codes and numbers</a></li>
<li><a href="../309652/index.html">Identification of road network problems using Yandex.Probok. Lecture in Yandex</a></li>
<li><a href="../309656/index.html">44 most popular projects on Product Hunt over the summer of 2016</a></li>
<li><a href="../309658/index.html">Qualification of fellow programmers: expectation and reality</a></li>
<li><a href="../309660/index.html">Plug-and-Get-Security I, TLS Security in the Grove of Domains</a></li>
<li><a href="../309666/index.html">IBM Watson got the job of a weather scientist</a></li>
<li><a href="../309668/index.html">How to become a designer. The main mistake and the necessary skills. Personal experience of employees Mail.Ru Group, Badoo, Trood</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>