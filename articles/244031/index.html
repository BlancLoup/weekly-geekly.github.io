<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Protect .net applications from prying eyes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúHow to protect the code of your .net application?‚Äù Is one of those questions that can be often heard in various forums. 

 The most common option is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Protect .net applications from prying eyes</h1><div class="post__text post__text-html js-mediator-article">  ‚ÄúHow to protect the code of your .net application?‚Äù Is one of those questions that can be often heard in various forums. <br><br>  The most common option is obfuscation.  On the one hand, it is easy to use, but on the other, it does not reliably hide the source code.  I will offer my own version, well suited for utilities, the use of which is assumed by the author himself (or authorized representatives), whose code is undesirable to show. <br><br>  Protection will be based on encrypting assemblies with a symmetric key and dynamically decrypting them during application operation.  The encryption key will be determined by the user at the deployment stage and entered as a password at startup. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's break everything into stages: <br><ol><li>  Preliminary work </li><li>  Password entry </li><li>  Decryption builds </li><li>  Override Assembly Downloads </li><li>  Application launch </li><li>  Cherry on the cake </li><li>  Additional project settings </li></ol><br>  And a separate item will go: <br><ol><li>  Deploying and encrypting builds </li></ol><br><a name="habracut"></a><br><h4>  Preliminary work </h4><br>  Since we need to somehow decipher the application before launch, we will make a wrapper that will take on this ungrateful work. <br><br>  The wrapper will be a regular console application. <br><br><h4>  Password entry </h4><br>  The entered password must be stored somewhere.  Usually, strings are used for these purposes, but in .net they are immutable, which means that the entered password can be easily pulled out by the debugger.  To avoid this, we use the special class SecureString (System.Security namespace), which stores its data in encrypted form. <br><div class="spoiler">  <b class="spoiler_title">Read the password</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadPassword</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ConsoleKeyInfo consoleKey = Console.ReadKey(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (consoleKey.Key != ConsoleKey.Enter) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (consoleKey.Key == ConsoleKey.Escape) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } _password.AppendChar(consoleKey.KeyChar); consoleKey = Console.ReadKey(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _password.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br></div></div><br>  When you enter the screen will not display the input characters, and after pressing Enter, the input will end. <br>  _password is a class field in which the password entered by the user is stored. <br><br><h4>  Decryption builds </h4><br>  Encryption is divided into two types: symmetric and asymmetric.  In the symmetric one, the same key is used for encryption and decryption, and the asymmetric one is different. <br><br>  Since we do not need different keys, we will focus on symmetric encryption. <br><br>  To decrypt something encrypted, we need three components: <br><ul><li>  Encrypted data; </li><li>  The key with which they are encrypted; </li><li>  The initialization vector (IV) is the unclassified data that was used for the first encryption step. </li></ul><br>  Since the initialization vector is not secret, it can be stored together with encrypted data. <br><br>  To facilitate the work, we write a special class CryptedData: <br><div class="spoiler">  <b class="spoiler_title">Class CryptedData</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CryptedData</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public byte[] IV { get; set; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public byte[] EncryptedSource { get; set; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">          . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public byte[] ToArray() { using (MemoryStream ms = new MemoryStream()) { Store(ms); return ms.ToArray(); } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">        . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="output"&gt;</span></span></span><span class="hljs-comment">,     .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public void Store(Stream output) { Validate(this); if (!output.CanWrite) { throw new ArgumentException("    ", "output"); } using (BinaryWriter bw = new BinaryWriter(output)) { bw.Write(IV.Length); bw.Write(IV); bw.Write(EncryptedSource.Length); bw.Write(EncryptedSource); } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">      . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="input"&gt;</span></span></span><span class="hljs-comment">   .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public static CryptedData Create(Stream input) { if (!input.CanRead) { throw new ArgumentException("    ", "input"); } CryptedData data = new CryptedData(); using (BinaryReader reader = new BinaryReader(input)) { int ivLength = reader.ReadInt32(); data.IV = reader.ReadBytes(ivLength); int sourceLength = reader.ReadInt32(); data.EncryptedSource = reader.ReadBytes(sourceLength); } Validate(data); return data; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="data"&gt;</span></span></span><span class="hljs-comment">,   .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private static void Validate(CryptedData data) { if (data.IV == null || data.IV.Length == 0) { throw new ArgumentException("IV    "); } if (data.IV.Length &gt; byte.MaxValue) { throw new ArgumentException(" IV     " + byte.MaxValue); } if (data.EncryptedSource == null || data.EncryptedSource.Length == 0) { throw new ArgumentException("Souce    "); } } }</span></span></code> </pre><br></div></div><br>  We will encrypt using the AES algorithm.  For convenience, create a low-level wrapper: <br><div class="spoiler">  <b class="spoiler_title">AesCryptography class</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AesCryptography</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> internal static byte[] CreateIv() { using (AesManaged aes = new AesManaged()) { aes.GenerateIV(); return aes.IV; } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="source"&gt;</span></span></span><span class="hljs-comment">.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="key"&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="iv"&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> internal static byte[] Encrypt(byte[] source, byte[] key, byte[] iv) { Validate(source, key, iv); using (AesManaged aes = new AesManaged()) { using (ICryptoTransform transform = aes.CreateEncryptor(key, iv)) { using (MemoryStream ms = new MemoryStream()) { using (CryptoStream cs = new CryptoStream(ms, transform, CryptoStreamMode.Write)) { cs.Write(source, 0, source.Length); } byte[] encryptedBytes = ms.ToArray(); return encryptedBytes; } } } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="source"&gt;</span></span></span><span class="hljs-comment">  .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="key"&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="iv"&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> internal static byte[] Decrypt(byte[] source, byte[] key, byte[] iv) { Validate(source, key, iv); using (AesManaged aes = new AesManaged()) { using (ICryptoTransform transform = aes.CreateDecryptor(key, iv)) { using (MemoryStream ms = new MemoryStream(source)) { using (CryptoStream cs = new CryptoStream(ms, transform, CryptoStreamMode.Read)) { List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment"> bytes = new List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;byte&gt;</span></span></span><span class="hljs-comment">(1024); int b; while ((b = cs.ReadByte()) != -1) { bytes.Add((byte)b); } return bytes.ToArray(); } } } } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="source"&gt;</span></span></span><span class="hljs-comment">.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="key"&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="iv"&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private static void Validate(byte[] source, byte[] key, byte[] iv) { if (source == null) { throw new ArgumentNullException("source"); } else if (source.Length == 0) { throw new ArgumentException("    ", "source"); } if (key == null) { throw new ArgumentNullException("key"); } else if (key.Length == 0) { throw new ArgumentException("    ", "key"); } if (key.Length.IsOneOf(16, 24, 32) == false) { throw new ArgumentException("    128, 192  256  (16, 24, 32 )", "key"); } if (iv == null) { throw new ArgumentNullException("iv"); } else if (iv.Length != 16) { throw new ArgumentException("     128  (16 )", "iv"); } } public static bool IsOneOf</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(this T value, params T[] values) { return value.IsOneOf(values as IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">); } public static bool IsOneOf</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(this T value, IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> values) { if (values == null) { throw new ArgumentNullException("values"); } foreach (T t in values) { if (Equals(t, value)) { return true; } } return false; } }</span></span></code> </pre><br></div></div><br>  Add another level of abstraction, for greater modularity: <br><div class="spoiler">  <b class="spoiler_title">CryptographyHelper class</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CryptographyHelper</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="source"&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="password"&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public static CryptedData Encrypt(byte[] source, SecureString password) { byte[] iv = AesCryptography.CreateIv(); byte[] key = GetKey(password); byte[] encrypted = AesCryptography.Encrypt(source, key, iv); return new CryptedData() { EncryptedSource = encrypted, IV = iv }; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="data"&gt;</span></span></span><span class="hljs-comment">,   .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="password"&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment"> .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public static byte[] Decrypt(CryptedData data, SecureString password) { byte[] key = GetKey(password); byte[] decrypted = AesCryptography.Decrypt(data.EncryptedSource, key, data.IV); return decrypted; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="key"&gt;</span></span></span><span class="hljs-comment">,   .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> private static byte[] GetKey(SecureString key) { using (InsecureString insecure = new InsecureString(key)) { using (SHA256Managed sha256 = new SHA256Managed()) { byte[] rawKey = new byte[key.Length]; int i = 0; foreach (char c in insecure) { rawKey[i++] = Convert.ToByte(c); } byte[] hashedKey = sha256.ComputeHash(rawKey); Array.Clear(rawKey, 0, rawKey.Length); return hashedKey; } } } }</span></span></code> </pre><br></div></div><br>  The last method, GetKey, contains a bit of magic. <br><br>  The first point is that the key length must be equal to 128, 192 or 256 bits.  And as a password to start can be a string of arbitrary length.  Therefore, simply hash the password string with sha256 and get the desired length. <br><br>  The second magic is more awesome and connected with SecureString.  This class is only available for writing, and to get its contents we need to use unsafe code: <br><div class="spoiler">  <b class="spoiler_title">Class InsecureString</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">CLSCompliant(false)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InsecureString</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span>, <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">char</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsecureString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SecureString secureString</span></span></span><span class="hljs-function">)</span></span> { _secureString = secureString; Initialize(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SecureString _secureString; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GCHandle _gcHandle; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !DEBUG [DebuggerHidden] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> private void Initialize() { unsafe { // We are about to create an unencrypted version of our sensitive string and store it in memory. // Don't let anyone (GC) make a copy. // To do this, create a new gc handle so we can "pin" the memory. // The gc handle will be pinned and later, we will put info in this string. _gcHandle = new GCHandle(); // insecurePointer will be temporarily used to access the SecureString IntPtr insecurePointer = IntPtr.Zero; RuntimeHelpers.TryCode code = delegate { // create a new string of appropriate length that is filled with 0's Value = new string((char)0, _secureString.Length); // Even though we are in the ExecuteCodeWithGuaranteedCleanup, processing can be interupted. // We need to make sure nothing happens between when memory is allocated and // when _gcHandle has been assigned the value. Otherwise, we can't cleanup later. // PrepareConstrainedRegions is better than a try/catch. Not even a threadexception will interupt this processing. // A CER is not the same as ExecuteCodeWithGuaranteedCleanup. A CER does not have a cleanup. Action alloc = delegate { _gcHandle = GCHandle.Alloc(Value, GCHandleType.Pinned); }; ExecuteInConstrainedRegion(alloc); // Even though we are in the ExecuteCodeWithGuaranteedCleanup, processing can be interupted. // We need to make sure nothing happens between when memory is allocated and // when insecurePointer has been assigned the value. Otherwise, we can't cleanup later. // PrepareConstrainedRegions is better than a try/catch. Not even a threadexception will interupt this processing. // A CER is not the same as ExecuteCodeWithGuaranteedCleanup. A CER does not have a cleanup. Action toBSTR = delegate { insecurePointer = Marshal.SecureStringToBSTR(_secureString); }; ExecuteInConstrainedRegion(toBSTR); // get a pointer to our new "pinned" string char* value = (char*)_gcHandle.AddrOfPinnedObject(); // get a pointer to the unencrypted string char* charPointer = (char*)insecurePointer; // copy for (int i = 0; i &lt; _secureString.Length; i++) { value[i] = charPointer[i]; } }; RuntimeHelpers.CleanupCode cleanup = delegate { // insecurePointer was temporarily used to access the securestring // set the string to all 0's and then clean it up. this is important. // this prevents sniffers from seeing the sensitive info as it is cleaned up. </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (insecurePointer != IntPtr.Zero) { Marshal.ZeroFreeBSTR(insecurePointer); } }; // Better than a try/catch. Not even a threadexception will bypass the cleanup code RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(code, cleanup, null); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> !DEBUG [DebuggerHidden] #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> public void Dispose() { unsafe { // we have created an insecurestring </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_gcHandle.IsAllocated) { // get the address of our gchandle and set all chars to 0's char* insecurePointer = (char*)_gcHandle.AddrOfPinnedObject(); for (int i = 0; i &lt; _secureString.Length; i++) { insecurePointer[i] = (char)0; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> DEBUG string disposed = "¬°DISPOSED¬°"; disposed = disposed.Substring(0, Math.Min(disposed.Length, _secureString.Length)); for (int i = 0; i &lt; disposed.Length; ++i) { insecurePointer[i] = disposed[i]; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> _gcHandle.Free(); } } } public IEnumerator&lt;char&gt; GetEnumerator() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (_gcHandle.IsAllocated) { return Value.GetEnumerator(); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { return new List&lt;char&gt;().GetEnumerator(); } } IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); } private static void ExecuteInConstrainedRegion(Action action) { RuntimeHelpers.PrepareConstrainedRegions(); try { } finally { action(); } } }</span></span></code> </pre><br></div></div><br>  What happens in this code? <br><ol><li>  Two pieces of code are prepared, one main, which does all the work, the second - the cleanup code in the case of an exception; </li><li>  The main code creates a new string in which the value of the SecureString will be stored and which will be forcibly cleared in the Dispose method; </li><li>  Copies data from the SecureString to the internal string via pointers and locks the internal string for the garbage collector; </li><li>  Through the internal string, we can get the securestring data. </li></ol><br>  In the Dispose method, the internal string is rubbed through pointers. <br><br>  It is important to keep the InsecureString instance‚Äôs window of life as short as possible in order to minimize the risk of the debugger reading the data of the protected string. <br><br>  The hashing described above helps in this, since we need an InsecureString instance only to get the hash, and then we work with the hash itself, from which we can‚Äôt pull out the original value of SecureString. <br><br><h4>  Override Assembly Downloads </h4><br>  Since we plan to use encrypted assemblies, we need to change the standard mechanism for loading them. <br>  The application domain (AppDomain) is responsible for loading assemblies, through the special AssemblyResolve event. <br><div class="spoiler">  <b class="spoiler_title">AssemblyResolve Handler</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEventArgs args) { string[] fileParts = args.Name.Split(",".ToCharArray()); string assemblyPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, fileParts[0] + ".edll"); string symbolsPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, fileParts[0] + ".epdb"); byte[] assemblyBytes = null, symbolsBytes = null; if (File.Exists(assemblyPath)) { assemblyBytes = DecryptFile(assemblyPath); } if (File.Exists(symbolsPath)) { symbolsBytes = DecryptFile(symbolsPath); } return Assembly.Load(assemblyBytes, symbolsBytes); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="path"&gt;</span></span></span><span class="hljs-comment">  .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-comment">  .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> private static byte[] DecryptFile(string path) { CryptedData data; using (FileStream fs = File.OpenRead(path)) { data = CryptedData.Create(fs); } byte[] bytes = CryptographyHelper.Decrypt(data, _password); return bytes; }</span></span></code> </pre><br></div></div><br><br>  Since by the time they enter Main they may already be needed, we will redefine the mechanism earlier in the type constructor.  In the same place, for convenience, we will fasten handling of exceptions: <br><div class="spoiler">  <b class="spoiler_title">Connection handler</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Program</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { AppDomain.CurrentDomain.UnhandledException += (sender, eventArgs) =&gt; Console.WriteLine(eventArgs.ExceptionObject.ToString()); AppDomain.CurrentDomain.AssemblyResolve += CurrentDomainOnAssemblyResolve; _password = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureString(); }</code> </pre><br></div></div><br><h4>  Application launch </h4><br>  With the launch of all quite simple: <br><div class="spoiler">  <b class="spoiler_title">Application launch</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunApplication</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SetConsoleWindowVisibility(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); App app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App(); MainWindow window = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MainWindow(); app.Run(window); }</code> </pre><br></div></div><br><h4>  Cherry on the cake </h4><br>  There are two things left: <br><ol><li>  Hide the console window before the application appears; </li><li>  Masking the very existence of the application </li></ol><br><h5>  Hiding the console window </h5><br>  We will need to import a couple of unmanaged methods. <br><div class="spoiler">  <b class="spoiler_title">We connect external functions</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"user32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindWindow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lpClassName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lpWindowName</span></span></span><span class="hljs-function">)</span></span>; [DllImport(<span class="hljs-string"><span class="hljs-string">"user32.dll"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowWindow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr hWnd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nCmdShow</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br></div></div><br>  and hide the window itself <br><div class="spoiler">  <b class="spoiler_title">Hide console</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="visible"&gt;</span></span></span><span class="hljs-comment">  .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> private static void SetConsoleWindowVisibility(bool visible) { IntPtr hWnd = FindWindow(null, Console.Title); if (hWnd != IntPtr.Zero) { if (visible) ShowWindow(hWnd, 1); //1 = SW_SHOWNORMAL else ShowWindow(hWnd, 0); //0 = SW_HIDE } }</span></span></code> </pre><br></div></div><br><h5>  Masking application </h5><br>  We can mask our application by issuing an error immediately after launch. <br><div class="spoiler">  <b class="spoiler_title">Main (string [] args)</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">STAThread</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     try { ArgumentException ex = new ArgumentException("There is not enough data to start application"); throw ex; } catch (ArgumentException ex) { Console.WriteLine(ex.ToString()); Console.WriteLine("Press Esc to exit"); } if (!ReadPassword()) return; RunApplication(); }</span></span></code> </pre><br></div></div><br>  It is clear that this will not work against the disassembler, but it will withdraw the idlers. <br><br><h4>  Additional project settings </h4><br>  In order to work correctly, an insecure code must be enabled in the bootloader assembly.  The easiest way to do this is through project settings. <br><br><img src="https://habrastorage.org/files/d7d/74b/20a/d7d74b20a8b647bcbe0efc9526bb9230.png"><br><br><h4>  Deploying and encrypting builds </h4><br>  We need to encrypt the assembly immediately after compilation.  Let's write a couple of functions for this: <br><div class="spoiler">  <b class="spoiler_title">Assembly Encryption</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">      . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private static void EncryptAssemblies() { Wiper wiper = new Wiper(); foreach (string file in Directory.GetFiles(AppDomain.CurrentDomain.BaseDirectory, "*.dll")) { byte[] source = File.ReadAllBytes(file); CryptedData crypted = CryptographyHelper.Encrypt(source, _password); string resultPath = Path.Combine(Path.GetDirectoryName(file), Path.GetFileNameWithoutExtension(file) + ".edll"); File.WriteAllBytes(resultPath, crypted.ToArray()); //   wiper.WipeFile(file, 3); //File.Delete(file); } string currentAssemblyName = Assembly.GetEntryAssembly().GetName().Name; foreach (string file in Directory.GetFiles(AppDomain.CurrentDomain.BaseDirectory, "*.pdb")) { if (Path.GetFileNameWithoutExtension(file) == currentAssemblyName) continue; byte[] source = File.ReadAllBytes(file); CryptedData crypted = CryptographyHelper.Encrypt(source, _password); string resultPath = Path.Combine(Path.GetDirectoryName(file), Path.GetFileNameWithoutExtension(file) + ".epdb"); File.WriteAllBytes(resultPath, crypted.ToArray()); //   wiper.WipeFile(file, 3); } }</span></span></code> </pre><br></div></div><br>  In order to wipe the original file, we use the auxiliary class Wiper, which in several passes overwrites the file with random data and then deletes it. <br><div class="spoiler">  <b class="spoiler_title">Class wiper</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Wiper</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Deletes a file in a secure way by overwriting it with </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> random garbage data n times. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="filename"&gt;</span></span></span><span class="hljs-comment">Full path of the file to be deleted</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="timesToWrite"&gt;</span></span></span><span class="hljs-comment">Specifies the number of times the file should be overwritten</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public void WipeFile(string filename, int timesToWrite) { if (File.Exists(filename)) { // Set the files attributes to normal in case it's read-only. File.SetAttributes(filename, FileAttributes.Normal); // Calculate the total number of sectors in the file. double sectors = Math.Ceiling(new FileInfo(filename).Length / 512.0); // Create a dummy-buffer the size of a sector. byte[] dummyBuffer = new byte[512]; // Create a cryptographic Random Number Generator. // This is what I use to create the garbage data. using (RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider()) { // Open a FileStream to the file. FileStream inputStream = new FileStream(filename, FileMode.Open); for (int currentPass = 0; currentPass </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; timesToWrite; currentPass++) { // Go to the beginning of the stream inputStream.Position = 0; // Loop all sectors for (int sectorsWritten = 0; sectorsWritten &lt; sectors; sectorsWritten++) { // Fill the dummy-buffer with random data rng.GetBytes(dummyBuffer); // Write it to the stream inputStream.Write(dummyBuffer, 0, dummyBuffer.Length); } } // Truncate the file to 0 bytes. // This will hide the original file-length if you try to recover the file. inputStream.SetLength(0); // Close the stream. inputStream.Close(); // As an extra precaution I change the dates of the file so the // original dates are hidden if you try to recover the file. DateTime dt = new DateTime(2037, 1, 1, 0, 0, 0); File.SetCreationTime(filename, dt); File.SetLastAccessTime(filename, dt); File.SetLastWriteTime(filename, dt); File.SetCreationTimeUtc(filename, dt); File.SetLastAccessTimeUtc(filename, dt); File.SetLastWriteTimeUtc(filename, dt); // Finally, delete the file File.Delete(filename); } } } }</span></span></span></span></code> </pre><br></div></div><br><h4>  Afterword </h4><br>  Obviously a weak point of such protection is the need to know the password to anyone who will use the application. <br>  It is also important to understand that the assembly code can be accessed by the disassembler when using the application. <br><br>  But if there is a need to hide what the utility does, which you yourself use, from prying eyes, this approach justifies itself. <br><br><h4>  Materials </h4><br><ul><li>  <a href="https://github.com/hmspns/EncryptedAssemblies">Project source code on github</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/244031/">https://habr.com/ru/post/244031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244015/index.html">Configuring Beans with Annotations: Solving the Inheritance Problem for Annotation Interfaces</a></li>
<li><a href="../244017/index.html">Pseudo-practical example of closures and decorators</a></li>
<li><a href="../244023/index.html">CryptSync and GnuPG - customization options and inability to use</a></li>
<li><a href="../244027/index.html">We analyze the proxying methods based on HAProxy</a></li>
<li><a href="../244029/index.html">Corporate software: main trends and why they are important</a></li>
<li><a href="../244033/index.html">HP 9830B Recovery</a></li>
<li><a href="../244035/index.html">Overview of Microsoft Azure platform updates for October-November</a></li>
<li><a href="../244037/index.html">SSL certificates: everyone, everyone, and let no one leave offended</a></li>
<li><a href="../244039/index.html">DCLady 2014 Industry Competition</a></li>
<li><a href="../244041/index.html">Expressive JavaScript: Event handling</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>