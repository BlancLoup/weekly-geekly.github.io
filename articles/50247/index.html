<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The data structures in memcached / memcacheDB. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The continuation of the article about data structures in memcached. In this final part, we will look at three more data structures: an event log, an a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The data structures in memcached / memcacheDB. Part 2</h1><div class="post__text post__text-html js-mediator-article">  The continuation of the <a href="http://habrahabr.ru/blogs/webdev/50243/">article</a> about data structures in memcached.  In this final part, we will look at three more data structures: an event log, an array, and a table. <br><a name="habracut"></a><br><h2>  Event log </h2><br><h3>  Task </h3><br>  The task of this data structure is to store events that occurred in a distributed system in the last T seconds.  Each event has a moment in time when it occurred, the rest of the event is determined by the logic of the application. <br><br>  Operations on the event log: <br><br><ul><li>  add a message to the event log (should be as fast as possible); </li><li>  receive events that occurred in the time period from Tmin to Tmax (should be effective, but is called less often than adding); </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Decision </h3><br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">time</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""         (, UNIX Epoch). @return:     @rtype: C{int} """</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Event</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">""" ,    . """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">when</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""  ,    (). """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""  . @return:   @rtype: C{str} """</span></span> @static <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deserialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(serialized)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   . @param serialized:       @type serialized: C{str} @return:    @rtype: C{list(Event)} """</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MCEventLog</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MemcacheObject)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, mc, name, timeChunk=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">, numChunks=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" . @param name:    @type name: C{str} @param timeChunk:       @type timeChunk: C{int} @param numChunks:      @type numChunks: C{int} """</span></span> super(MCEventLog, self).__init__(mc) self.keyTemplate = <span class="hljs-string"><span class="hljs-string">'messagelog'</span></span> + name + <span class="hljs-string"><span class="hljs-string">'_%d'</span></span>; self.timeChunk = timeChunk self.numChunks = numChunks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, event)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    . @param event:  @type event: L{Event} """</span></span> serialized = event.serialize() key = self.keyTemplate % (event.when() // self.timeChunk % self.numChunks) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self.mc.append(key, serialized) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self.mc.add(key, serialized, self.timeChunk * (self.numChunks<span class="hljs-number"><span class="hljs-number">-1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, first=None, last=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""        (  ). @param first:     @type first: C{int} @param last:     @type last: C{int} @return:   @rtype: C{list(Event)} """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> last <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> last &gt; time(): last = time() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> last &lt; first <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (last-first) &gt; self.timeChunk * (self.numChunks<span class="hljs-number"><span class="hljs-number">-1</span></span>): first = time() ‚Äî self.timeChunk * (self.numChunks<span class="hljs-number"><span class="hljs-number">-1</span></span>) firstKey = first / self.timeChunk % self.numChunks lastKey = last / self.timeChunk % self.numChunks <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstKey &lt; lastKey: keyRange = range(firstKey, lastKey+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: keyRange = range(firstKey, self.numChunks) + range(<span class="hljs-number"><span class="hljs-number">0</span></span>, lastKey+<span class="hljs-number"><span class="hljs-number">1</span></span>) keys = [self.keyTemplate % n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keyRange] result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keys: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: events = Event.deserialize(self.mc.get(key)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> result.extend(filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> e: e.when() &gt;= first <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.when() &lt;= last, l)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre> <br><br><h3>  Discussion </h3><br>  The main idea of ‚Äã‚Äãthe event log is a ring buffer consisting of <code>numChunks</code> keys in memcached.  Each key is active (that is, supplemented with values) for <code>timeChunk</code> seconds, after which the next key becomes active (if the last key was active, this role goes to the first key).  Full buffer cycle, i.e.  the time period between two uses of a single key is <code>numChunks * timeChunk</code> seconds, and the lifetime of each key is <code>(numChunks - 1) * timeChunk</code> seconds, so any time you create a key modulo <code>timeChunk</code> by the time of next use the key is guaranteed to be destroyed.  Thus, the capacity of the event log (or the time period for which events are saved) is <code>(numChunks - 1) * timeChunk</code> seconds.  Such a partitioning of the log into keys allows, upon receiving events from the log, to remove only those keys that correspond to the time interval of interest to us. <br><br>  The choice of the <code>timeChunk</code> and <code>numChunks</code> depends on the application of the event log: first, the desired period of event storage is determined, then, according to the frequency of events, the <code>timeChunk</code> value is selected so that the size of each key of the event log is relatively small (for example, 10-20Kb).  From these considerations, we can find the value of the second parameter, <code>numChunks</code> . <br><br>  The example uses some class <code>Event</code> , which has the only interesting property for us - the time when the event occurred.  In the event log <code>put</code> method, it is assumed that the event <code>event</code> passed as a parameter occurred ‚Äúrecently‚Äù, that is, no more than <code>(numChunks - 1) * timeChunk</code> seconds (log capacity <code>event.when()</code> passed since <code>event.when()</code> ).  During <code>put</code> operation, the key is calculated, into which information about the event should be placed, in accordance with its timestamp.  After that, with the help of the technique already familiar with the previous examples, the key is either created or a serialized event representation is added to the value of the existing key. <br><br>  The <code>fetch</code> method calculates a potential set of log keys that can contain events that occurred during the time interval from <code>first</code> to <code>last</code> .  If the time frames are not set, <code>last</code> is considered to be equal to the current time, and <code>first</code> - to the time, separated from the current by the capacity of the log.  The set of keys is calculated taking into account the ring structure of the method, after which the corresponding keys are selected, the events recorded in them are deserialized and additional filtering is performed to hit the <code>[first, last]</code> segment. <br><br>  The above method signature allows successive calls to output new events from the log: <br><br><ol><li>  The first time is to call <code>events = fetch()</code> .  Calculated <code>lastSeen</code> as <code>max(events.when())</code> . </li><li>  All subsequent calls are as follows: <code>events = fetch(first=lastSeen)</code> , while <br>  <code>lastSeen</code> recalculated each time. </li></ol><br><br><h2>  Array </h2><br><h3>  Task 1 </h3><br>  An array stores a list of values ‚Äã‚Äãof an arbitrary type, the list is relatively rarely updated, and the entire list is received much more often. <br><br>  Array operations: <br><br><ul><li>  change array (rare operation); </li><li>  get the entire array (frequent operation). </li></ul><br><br><h3>  Solution 1 </h3><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serializeArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""     . """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deserializeArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""     . """</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MCArray1</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MemcacheObject)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, mc, name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" . @param name:   @type name: C{str} """</span></span> super(MCArray1, self).__init__(mc) self.lock = MCLock(name) self.key = <span class="hljs-string"><span class="hljs-string">'array'</span></span> + name <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    . @return:  @rtype: C{list} """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deserializeArray(self.mc.get(self.key)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, add_elems=[], delete_elems=[])</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""   ,      . @param add_elems: ,    @type add_elems: C{list} @param delete_elems: ,    @type delete_elems: C{list} """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.lock.try_lock(): <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: array = deserializeArray(self.mc.get(self.key)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: array = [] array = filter(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> e: e <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> delete_elems, array) + add_elems self.mc.set(self.key, serializeArray(array), <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: self.lock.unlock()</code> </pre><br><br><h3>  Talk 1 </h3><br>  The above solution actually has nothing to do with arrays, but can be applied to any data structure.  It is based on the reader-writer model, when there are many readers and relatively few writers.  Readers at any time using the <code>fetch</code> method receive the contents of the array, while it is important that the ‚Äúwriter‚Äù <code>hange</code> records the contents of a single memcached command, that is, due to the internal atomicity of <code>get</code> and <code>set</code> operations in memcached and despite the lack of synchronization between the <code>fetch</code> and <code>hange</code> , the <code>fetch</code> result will always be consistent: this will be the value before or after the next change.  Writers are blocked from simultaneously modifying an array using the <code>MCLock</code> lock described above. <br><br>  In this situation, it would be possible to avoid using locks and use the <code>gets</code> , <code>cas</code> and <code>add</code> commands from the memcached protocol to ensure that the changes are atomic using the <code>change</code> function. <br><br><h3>  Task 2 </h3><br>  An array stores a list of values ‚Äã‚Äãof a certain type; an operation of the form ‚Äúadd value to an array‚Äù often occurs.  Relatively rare array is requested entirely.  For ease of implementation, an array of integers will be considered in the future, although the data type is not significant for solving the problem. <br><br>  Array operations: <br><br><ul><li>  add value to the array (frequent operation); </li><li>  get the whole array. </li></ul><br><br><h3>  Solution 2 </h3><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serializeInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       (str). """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deserializeIntArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       . """</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MCArray2</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MemcacheObject)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, mc, name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" . @param name:   @type name: C{str} """</span></span> super(MCArray2, self).__init__(mc) self.key = <span class="hljs-string"><span class="hljs-string">'array'</span></span> + name <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    . @return:  @rtype: C{list} """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deserializeIntArray(self.mc.get(self.key)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, element)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    . @param element: ,      @type element: C{int} """</span></span> element = serializeInt(element) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self.mc.append(self.key, element) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self.mc.add(self.key, element, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre><br><br><h3>  Talk 2 </h3><br>  This implementation practically repeats the similar code for the event log, only simplified due to the presence of only one key.  Compared with the first implementation of the ‚Äúarray‚Äù data type, the number of memcached operations has decreased, all processes that change the array can be executed without delay (no locks).  As in the first variant, the presence of duplicates is not checked when adding an element to an array (it can be both good and bad, depending on the application). <br><br>  The following improvements (or extensions) of the described example are possible: <br><br><ul><li>  using several keys to store an array instead of one; distributing elements to keys using hashing;  this option will allow you to limit the size of each key, provided that the array is large (contains many elements); </li><li>  implementation in the same style of operation of removing an element from an array, then the array can be represented <br>  how the ‚Äúdelete‚Äù and ‚Äúadd‚Äù sequence of operations, such as a serialized view <br>  <code>+1 +3 +4 -3 +5</code> will form an array after deserialization <code>[1, 4, 5]</code> ;  with how <br>  the operation of adding an element as well as deletion will result in adding bytes to the end <br>  serialized view (atomic operation <code>append</code> ). </li></ul><br><br><h2>  Table </h2><br><h3>  Task </h3><br>  It is necessary to store multiple lines.  Set operations: <br><br><ul><li>  checking that a string belongs to a set (the most frequent operation); </li><li>  getting a whole set, adding an item, deleting an item is a rare operation. </li></ul><br><br>  You can consider this data structure as a table in which you can quickly find the desired row.  Or as a hash stored in distributed memory. <br><br><h3>  Decision </h3><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serializeArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""     . """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deserializeArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(str)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""     . """</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MCTable</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MemcacheObject)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, mc, name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" . @param name:   @type name: C{str} """</span></span> super(MCTable, self).__init__(mc) self.lock = MCLock(name) self.key = <span class="hljs-string"><span class="hljs-string">'table'</span></span> + name <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">has</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""     . @param key:  @type key: C{str} @rtype: C{bool} """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self.mc.get(self.key + <span class="hljs-string"><span class="hljs-string">'_v_'</span></span> + key) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""     . @return:   @rtype: C{list(str)} """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deserializeArray(self.mc.get(self.key + <span class="hljs-string"><span class="hljs-string">'_keys'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    . @param key:  @type key: C{str} """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.lock.try_lock(): <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: array = deserializeArray(self.mc.get(self.key + <span class="hljs-string"><span class="hljs-string">'_keys'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: array = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> array: array.append(key) self.mc.set(self.key + <span class="hljs-string"><span class="hljs-string">'_v_'</span></span> + key, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) self.mc.set(self.key + <span class="hljs-string"><span class="hljs-string">'_keys'</span></span>, serializeArray(array), <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: self.lock.unlock() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, key)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    .    add(). """</span></span></code> </pre><br><br><h3>  Discussion </h3><br>  Generally speaking, memcached is a huge hash table, although it lacks one operation that is necessary for our data structure: getting a list of keys.  Therefore, the implementation of the table uses separate keys to store each element of the table, and separately another key to store a list of all its elements.  The implementation of the storage of the list of all elements actually coincides with the implementation of ‚Äúarray 1‚Äù.  To serialize access to the list of all elements, blocking is used, and the <code>fetch</code> and <code>add</code> methods are not synchronized with each other, since  the list of all elements changes atomically and when we read the key we always get some consistent state. <br><br>  The check for the presence of a key in the table is performed as quickly as possible: the presence of the corresponding key in memcached is checked.  Any change to the list of items always takes place simultaneously in the key storing the entire list, and in separate keys for each item (which are used only for verification). <br><br>  Based on the above scheme, you can implement a full-fledged hash, when the associated value is stored for each table element, this value will need to be written only to separate keys corresponding to the elements, and the list of elements will not contain values. <br><br><h2>  Conclusion </h2><br>  So, here is a list of "tricks" or "tricks" described in this article: <br><br><ul><li>  atomic operations using memcached ( <code>add</code> / <code>set</code> pair, etc.); </li><li>  blocking; </li><li>  shadow keys; </li><li>  ring buffer with automatic "death" of keys; </li><li>  lock and reader-writer model. </li></ul><br><br>  The article did not address the issues of memcached-specific optimization, for example, the use of multi-get requests.  This was done deliberately so as not to overload the source code and the story.  In many situations, the examples above should be considered more like pseudocode than as an example of an ideal implementation in Python. <br><br>  If you find a mistake, you want to offer a clearer, more optimal solution to the tasks, you want to offer an implementation for some other data structure, I will be happy for comments and criticism. </div><p>Source: <a href="https://habr.com/ru/post/50247/">https://habr.com/ru/post/50247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../50235/index.html">Bash and twitter</a></li>
<li><a href="../50238/index.html">Nice little thing in gmail</a></li>
<li><a href="../50240/index.html">Introducing FreeSWITCH Part Two</a></li>
<li><a href="../50241/index.html">CUDA: right off the bat</a></li>
<li><a href="../50243/index.html">The data structures in memcached / memcacheDB. Part 1</a></li>
<li><a href="../50249/index.html">Attacks on wireless networks. Part 2</a></li>
<li><a href="../50253/index.html">Yandex competitor has a competitor (Kiev)</a></li>
<li><a href="../50254/index.html">Search for the approach to the presentation of ideas</a></li>
<li><a href="../50255/index.html">"Space tourists" will not be able to fly to the ISS after 2009</a></li>
<li><a href="../50256/index.html">Video rip. Part 1-1. DVD preparation. vStrip</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>