<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Concurrent programming for beginners in the Elixir / Erlang VM YaP using the example of the ‚ÄúEuler's horse‚Äù task</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 A little more than a year ago I did a very important act in my life - I downloaded the first program in my life from the Microsoft IDE ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Concurrent programming for beginners in the Elixir / Erlang VM YaP using the example of the ‚ÄúEuler's horse‚Äù task</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/cbe/e97/fa6/cbee97fa6b4645f0896de606d5b0813e.jpeg"><br><br><h1>  Introduction </h1><br>  A little more than a year ago I did a very important act in my life - I downloaded the first program in my life from the Microsoft IDE Visual Studio website and wrote, strangely enough, ‚ÄúHello, World!‚Äù.  Over the next six months, I read the well-known Stroustrup book, got a job as a junior C ++ developer, tried to write in Lua, Python, but did not achieve any significant success - my libraries did not work, programs hardly compiled and fell at runtime, pointers indicated not to those areas of memory (which, by the way, has always flowed away somewhere), and attempts to use more than one thread (C ++ 11!) led to memory damage and deadlock.  About how the code looked, it is better just to remain silent. <br><br>  What is it for me?  In addition, in my personal opinion / experience, imperative languages, due to their peculiarities, are completely inappropriate for novice developers.  Without knowledge of industrial programming patterns, any information about the operation of the operating system and elementary code culture, it is very difficult to write something bearable on them.  They give too much freedom and space for crutches and bicycles, while functional languages ‚Äã‚Äãseverely restricting the developer in some things leave him not many opportunities to write bad code, forcing him to think and develop. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      About six months ago, I realized that it was time to change something, and after half an hour of searching on the Internet I found the specifications of the YaR Erlang.  In the article, the author presented Erlang as a ‚Äúwonderful pill‚Äù from all my problems described above, and in general, for the most part, he turned out to be right.  So I started to program on Erlang, and then on Elixir. <br><br><h1>  Elixir language </h1><br>  Elixir is a language built on top of Erlang, the result of the compilation is Erlang VM bytecode.  It favorably differs from Erlang by the simplicity of its syntax and powerful tools for meta-programming (people familiar with Lisp immediately recognize the quote-unquote constructs).  Accordingly, all Erlang functionality, any of its modules and, most importantly, the OTP framework are available for use. <br><br>  The data types are the same as in Erlang.  Data is immutable, the result of actions with them is new data.  In Elixir, as in many functional languages, the principle of "Everything - expression" works.  Any expression will return a value. <br><br>  YP Elixir has an excellent interpreter, which is installed along with the language, you can try out examples in it. <br><a name="habracut"></a><br><h2>  Basic data types </h2><br>  <i>int, float</i> <br><pre><code class="ruby hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; 2 3 / 2 # =&gt; 1.5 1.0 + 3 # =&gt; 4.0</span></span></code> </pre> <br><br>  <i>binary</i> <br><pre> <code class="ruby hljs"><span class="hljs-string"><span class="hljs-string">"Hello"</span></span>&lt;&gt;<span class="hljs-string"><span class="hljs-string">" World!"</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; "Hello World!" "Hello #{World!}" # =&gt; "Hello World!" """ hello """ # =&gt; "hello\n"</span></span></code> </pre><br><br>  <i>atom</i> <br>  A constant that represents only its value and nothing more.  There is no separate logical type: true, false, nil are also atoms, just for them there are corresponding conventions in the language. <br><pre> <code class="ruby hljs">is_atom(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; true is_atom(:true) # =&gt; true is_atom(:hello) # =&gt; true</span></span></code> </pre><br><br>  <i>list</i> <br><pre> <code class="ruby hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-string"><span class="hljs-string">"five"</span></span>]++[<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"seven"</span></span>] <span class="hljs-comment"><span class="hljs-comment"># =&gt; [1, 2, 3, 4, "five", 6, "seven"] [1,1,2,3,4]--[1,2,3,5] # =&gt; [1, 4]</span></span></code> </pre><br>  For historical reasons, the lines in Erlang are presented in the form of a list, and not in the form of a binary (in Elixir, like vice versa), and therefore the list can also be represented as <br><pre> <code class="ruby hljs">is_list <span class="hljs-string"><span class="hljs-string">'this is list'</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; true 'lst'++[10000] # =&gt; [108, 115, 116, 10000]</span></span></code> </pre><br><br>  <i>tuple</i> <br>  Something like list, the difference in the organization of data storage in memory, and accordingly in the library tools for working with data. <br><pre> <code class="ruby hljs">{<span class="hljs-symbol"><span class="hljs-symbol">:hello</span></span>, <span class="hljs-string"><span class="hljs-string">"world"</span></span>}</code> </pre><br><br>  <i>map</i> <br><pre> <code class="ruby hljs"><span class="hljs-string"><span class="hljs-string">%{2 =&gt; 2, :c =&gt; {1, 2, 3}</span></span>, <span class="hljs-string"><span class="hljs-string">"key1"</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>} <span class="hljs-comment"><span class="hljs-comment">#      ,  ,     %{a: 1, b: 3, c: "qweqwe"}</span></span></code> </pre><br><br>  <i>PID</i> <br>  VM process ID Erlang.  The interactive shell of the interpreter is also a process, so we use the self function, which returns the PID of the process from which it was called. <br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; #PID&lt;0.95.0&gt; (     )</span></span></code> </pre><br><br>  It is possible to explicitly do transforms of some types. <br><pre> <code class="ruby hljs"><span class="hljs-symbol"><span class="hljs-symbol">:erlang</span></span>.tuple_to_list {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-comment"><span class="hljs-comment"># =&gt; [1, 2, 3] :erlang.integer_to_binary 123 # =&gt; "123" :erlang.binary_to_list "abc" # =&gt; :abc</span></span></code> </pre><br><br>  Also, one of the advantages of the language is that any term can be completely painlessly converted to binary and vice versa.  Serialization of any data in one line. <br><pre> <code class="ruby hljs">res = <span class="hljs-symbol"><span class="hljs-symbol">:erlang</span></span>.term_to_binary [<span class="hljs-symbol"><span class="hljs-symbol">:hello</span></span>, {<span class="hljs-string"><span class="hljs-string">"world"</span></span>, <span class="hljs-string"><span class="hljs-string">'!!!'</span></span>}] <span class="hljs-comment"><span class="hljs-comment"># =&gt; &lt;&lt;131, 108, 0, 0, 0, 2, 100, 0, 5, 104, 101, 108, 108, 111, 104, 2, 109, 0, 0, 0, 5, 119, 111, 114, 108, 100, 107, 0, 3, 33, 33, 33, 106&gt;&gt; :erlang.binary_to_term res # =&gt; [:hello, {"world", '!!!'}]</span></span></code> </pre><br><br><h2>  Pattern matching </h2><br><br>  Data can be locally assigned to variables (global variables and shared memory are not and cannot be here) <br><pre> <code class="ruby hljs">x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; 1 #  x  c 1 x # =&gt; 1 #         (  ) x = 1+x # =&gt; 2</span></span></code> </pre><br><br>  But to do this is absolutely not necessary.  The code is easier, more beautiful and more expressive if you <b>do not use variables at all</b> .  Strictly speaking, the "=" operator in the Elixir language is not an assignment in the usual sense for imperative languages.  Here there is a pattern matching (pattern matching).  Its essence is easier to show by example <br><pre> <code class="ruby hljs"><span class="hljs-string"><span class="hljs-string">%{a: x, b: 1}</span></span> = <span class="hljs-string"><span class="hljs-string">%{a: 1, b: 1}</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; %{a: 1, b: 1} %{a: x, b: 1} = %{a: 1, b: 2} # =&gt; ** (MatchError) no match of right hand side value: %{a: 1, b: 2} %{a: x, b: 1} = %{b: 1} # =&gt; ** (MatchError) no match of right hand side value: %{b: 1}</span></span></code> </pre><br><br>  In terms of imperative languages, pattern matching is a combination of comparison and assignment: the elements of a structure connected to a value to the left of = are compared with the corresponding elements of the structure to the right of =, and not connected - are associated with the corresponding values ‚Äã‚Äãof the structure's elements on the right .  It is logical that the structure on the right cannot have elements unrelated to any value.  If one of the comparisons returns false, an exception is thrown. <br><br>  Pattern matching can also (and should) be done on binary data. <br><pre> <code class="ruby hljs">&lt;&lt; a <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: binary-size(<span class="hljs-number"><span class="hljs-number">5</span></span>), rest <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>: binary <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>= <span class="hljs-string"><span class="hljs-string">"hello, world"</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; "hello, world" a # =&gt; "hello" rest # =&gt; ", world"</span></span></code> </pre><br><br>  By the way, pay attention to this example: <br><pre> <code class="ruby hljs">x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; 1 x == 1 # =&gt; true %{a: x, b: y} = %{a: 12, b: 1} # =&gt; %{a: 12, b: 1} x # =&gt; 12</span></span></code> </pre><br><br>  Pattern matching was successful, there is no exception.  Although it would seem, x should be associated with 1, and 1! = 12. In this sense, Elixir differs from more stringent functional languages ‚Äã‚Äã(including Erlang), which is why using pattern matching inside functions often leads to confusion and clutter. code;  this should be avoided.  The real power of pattern matching can only be felt if used in function declarations and case expressions. <br><br><h2>  Functions and modules </h2><br>  The language is functional, therefore the main expressive means of the language is function.  Functions can be taken as functions as arguments and returned as values.  Functions are defined inside modules, modules can also be defined inside other modules. <br><br><pre> <code class="ruby hljs">defmodule Some <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> defp priv_func(arg) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> arg&lt;&gt;<span class="hljs-string"><span class="hljs-string">"Hello from priv_func!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pub_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> is_binary(arg) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> arg&lt;&gt;priv_func(<span class="hljs-string"><span class="hljs-string">"Hello from pub_func!\n"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  To define a public function that can be called outside of this module ‚Äî you need to use def, and defp allows you to redistribute a function that is available only inside this module (see how much simpler it is compared to Erlang).  After the function name and arguments, there can be expressions called guard expressions (look at the definition of pub_func), they allow you to narrow the scope of the function (in the mathematical sense). <br><br><pre> <code class="ruby hljs">Some.pub_func <span class="hljs-string"><span class="hljs-string">"Hello from shell!\n"</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; "Hello from shell!\nHello from pub_func!\nHello from priv_func!" Some.pub_func 1 # =&gt; ** (FunctionClauseError) no function clause matching in Some.pub_func/1 Some.priv_func "Hello" # =&gt; ** (UndefinedFunctionError) undefined function: Some.priv_func/1 Some.priv_func("Hello")</span></span></code> </pre><br><br>  There are 2 almost equivalent ways to define a lambda (anonymous function) in the Elixir language: <br><br><pre> <code class="ruby hljs">sum = &amp;(&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>+&amp;<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; &amp;:erlang.+/2 sum.(1,2) # =&gt; 3 sum = fn(x,y) -&gt; x + y end # =&gt; #Function&lt;12.106461118/2 in :erl_eval.expr/5&gt; sum.(1,2) # =&gt; 3</span></span></code> </pre><br><br>  As you can see from the example, a call to a lambda differs from a call to a normal function only by the ‚Äú.‚Äù  Functions can be passed as arguments not only lambdas, but also ordinary functions.  To do this, put a ‚Äú&amp;‚Äù sign in front of the function name, and then specify its arity. <br><br><pre> <code class="ruby hljs">defmodule Some <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg1, arg2, func)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> func.(arg1, arg2) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg1, arg2)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> arg1 / arg2 <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> sum = &amp;(&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>+&amp;<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment"># =&gt; &amp;:erlang.+/2 Some.actor(1,2,sum) # =&gt; 3 Some.actor(3,4, &amp;Some.div/2 ) # =&gt; 0.75</span></span></code> </pre><br><br>  Detailed documentation on the Yap Elixir and its standard modules can be read <a href="http://elixir-lang.org/">here</a> , and on Erlang / OTP <a href="http://www.erlang.org/">here</a> . <br><br><h1>  Solution of the problem ‚ÄúEuler's horse‚Äù </h1><br>  When I first started learning C ++ and was preparing for the entrance exams to the master's degree at the VMK (naively believing that they would learn how to code cool), in one of the options for the entrance exams I came across this task.  Then I could not solve it.  For some reason, yesterday she remembered me again, and, throwing a decision in an hour, decided to write this article. <br><br>  In general, the essence: ‚ÄúThere is a square chessboard of arbitrary size, a knight stands on it in an arbitrary cell, there are no other pieces on the board.  It is necessary to pass a horse through all the cells of a chessboard, having been in each one exactly once, or to prove that this cannot be done. ‚Äù <br><br>  Since there are no specific conditions determining the size of the board and the starting position of the knight, it is quite difficult, tedious and not rational to make abstract mathematical conclusions here, so the most obvious solution is brute force. <br><br>  To begin with, we will define the data structures that we will operate on in our functions.  This will allow to achieve a higher level of abstraction and significantly simplify the solution.  In addition, the structures thus defined make the code more deterministic. <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># structs of data defmodule Position do defstruct first: 1, second: 1 end defmodule GameState do defstruct current_pos: %Position{}, path: [] end</span></span></code> </pre><br><br>  Position - the position of the horse on the board at any time.  Here we consider the two-dimensional case, but as will be seen later, the functional code is designed in such a way that this solution can be very easily generalized for a space of any dimension. <br>  GameState - the current state of the game, is uniquely determined by the current position and the distance traveled. <br>  As you can see, we define defaults for structure fields, so we get something like a class constructor.  The structures in Elixir are based on the map data type, and are very similar in usage / syntax. <br><br><pre> <code class="ruby hljs">defmodule Some <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> defstruct <span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> res = %Some{} <span class="hljs-comment"><span class="hljs-comment"># =&gt; %Some{a: 1, b: nil} is_map res # =&gt; true Map.keys res # =&gt; [:__struct__, :a, :b] Map.values res # =&gt; [Some, 1, nil]</span></span></code> </pre><br><br>  Next, we write the solution in general.  The init / 1 function takes the size of the edge (in this case, the side of the square) of the board as an argument, randomly determines the starting position of the knight (and the game state accordingly), informs the user about it using the function inform_user_about_beginning / 1, then calls the game / 2 function, which returns many possible workarounds, and then the show_game_results / 2 function, which tells the user about the results.  Pay attention to the operator "|&gt;".  It simply passes the expression on the left as the first argument of the function on the right.  The problem is solved, it remains to determine the functions that are not yet defined. <br><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(limit)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (is_integer(limit) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (limit &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:random</span></span>.seed(<span class="hljs-symbol"><span class="hljs-symbol">:erlang</span></span>.now) [ %GameState{ <span class="hljs-symbol"><span class="hljs-symbol">current_pos:</span></span> %Position{ <span class="hljs-symbol"><span class="hljs-symbol">first:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:random</span></span>.uniform(limit), <span class="hljs-symbol"><span class="hljs-symbol">second:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:random</span></span>.uniform(limit)} <span class="hljs-params"><span class="hljs-params">|&gt; inform_user_about_beginning } ] |</span></span>&gt; game(limit) <span class="hljs-params"><span class="hljs-params">|&gt; show_game_results(limit) </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span></span></code> </pre><br><br>  For the function inform_user_about_beginning, I think everything is clear - it takes an argument, displays it on the screen and returns it. <br><br><pre> <code class="ruby hljs">defp inform_user_about_beginning info <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> IO.puts <span class="hljs-string"><span class="hljs-string">"Hello, user, we begin from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{inspect info}</span></span></span><span class="hljs-string">"</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  The show_game_results function is a bit more complicated.  As a result of our algorithm, we need to get a list of possible workarounds.  Naturally, we want to see different messages for the empty and non-empty list.  Instead of if-else or case expressions inside one function, in this case it is better to write two separate clauses for the show_game_results / 2 function.  This simplifies the code, makes it more visual and readable.  The general rule is this: when a function is called, clauses for a given function begin to get over, in the order in which they are written out in the code.  In this case, pattern matching of all the arguments of the function in the given clause and the corresponding arguments passed from the outside is performed.  If pattern matching succeeds, the function returns the expression of this clause, if not, the next clause is taken.  If no clause came up, an exception is thrown. <br><br><pre> <code class="ruby hljs">defp show_game_results([], limit) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> IO.puts <span class="hljs-string"><span class="hljs-string">"FAIL. This is no any way to go through desk </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{limit}</span></span></span><span class="hljs-string">x</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{limit}</span></span></span><span class="hljs-string"> from this position."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp show_game_results([%GameState{<span class="hljs-symbol"><span class="hljs-symbol">current_pos:</span></span> current_pos, <span class="hljs-symbol"><span class="hljs-symbol">path:</span></span> path} <span class="hljs-params"><span class="hljs-params">| rest_way], limit) </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">do</span></span></span><span class="hljs-params"> """ SUCCESS! There are #{length(rest_way)+1} ways to go through desk #{limit}x#{limit} from this position. Here one of them: """ |</span></span>&gt; IO.puts Enum.each( path++[current_pos] , &amp;(IO.puts <span class="hljs-string"><span class="hljs-string">"\t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{inspect &amp;</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Pay attention to the second clause, it uses a split list on the head and tail, typical of FP.  In this case, the purpose of such a partition is to get the first workaround from the list of found workarounds right in the function argument, saving yourself from having to do it somewhere in the function body.  In Elixir, both in and in Erlang, the list can either be empty ([]), or be split into head and tail, where the tail is a list. <br><br><pre> <code class="ruby hljs">lst = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-comment"><span class="hljs-comment"># =&gt; [1, 2, 3] [a | rest] = lst # =&gt; [1, 2, 3] a # =&gt; 1 rest # =&gt; [2, 3] lst2 = [0 | lst] # =&gt; [0, 1, 2, 3] [first|rest] = [0] # =&gt; [0] first # =&gt; 0 rest # =&gt; []</span></span></code> </pre><br><br>  Also at the end of the second clause is a higher order function.  In fact, the function Enum.each / 2 here passes through all the elements of the list and applies to each element a function which it itself takes as the second argument (in this case it simply displays on the screen).  Further in the text there will be several more functions from the Enum module, so that there are no questions about this at once I briefly describe how they work: <br><br><pre> <code class="ruby hljs">Enum.map( lst, func/<span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-comment"><span class="hljs-comment">#  ,    func(el),  el -   lst Enum.filter(lst, func/1) #      lst,   func(el) == true Enum.reduce( lst, res, func/2 ) #   Enum.reduce(rest, func(el, res), func/2),  [el | rest] = lst,  Enum.reduce([], some_res, func/2) == some_res</span></span></code> </pre><br><br>  Now we define the missing game / 2 function.  If we get an empty list of possible game states (and therefore workarounds), we have nothing left to do with it except to return.  If the list is not empty, we check whether the end of the detour has reached the end, and depending on this, either we return the list of the detour paths, or continue the detour. <br><br><pre> <code class="ruby hljs">defp game([], _limit) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp game(lst, limit) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> game_over?(lst, limit) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; lst <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; Enum.map(lst, &amp;(generate_new_list_and_game_next(&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>, limit))) <span class="hljs-params"><span class="hljs-params">|&gt; List.flatten </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span><span class="hljs-params"> </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span><span class="hljs-params"> defp game_over?([%GameState{path: path}|</span></span> _rest], limit) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> length(path) == (limit*limit - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  In the second clause of the game / 2 function, there is a case expression.  At first glance, it resembles a switch switch, but in reality, case is, by its nature, practically the same as the usual function in the Elixir language.  The bottom line is: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> _1 -&gt; _1 _2 -&gt; _2 ... _n -&gt; _n <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  The serial pattern matching of each clause is made starting with the first with the result of executing the expression 0, and if it passed successfully, the case returns the expression corresponding to this clause.  If no clause came up, it should be an exception. <br><br>  Next, we need to define the function generate_new_list_and_game_next / 2, which will accept the state of the game at step n, convert it to the list of game states at step n + 1 (after all, from any cell, the knight can make a move from 0 to 8 for any number of cells, depending on the state in step n), and then pass this list to the game / 2 function.  To write this function, you first need to know how the knight walks.  Regardless of the initial conditions, all possible movements of the knight are known to us even before the algorithm starts working (for a queen, for example, this is not true - in this case, the set of possible movements is related to the size of the board).  Therefore, the work of calculating all theoretically possible moves of a horse can (and should) be placed in the compile-time.  To do this, we write in a separate module the function make_permutations / 4.  The first def does not contain a do-end block and is used to enter default arguments. <br><br><pre> <code class="ruby hljs">defmodule Permutations <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_permutations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( input_set, perm_size, condition, result \\ [])</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_permutations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _input_set, perm_size, condition, result )</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (length(result) == perm_size) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> condition.(result) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; List.to_tuple(result) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-symbol"><span class="hljs-symbol">:failed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_permutations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( input_set, perm_size, condition, result )</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (length(input_set)+length(result) &gt;= perm_size) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Enum.map( input_set, fn(input_el) -&gt; make_permutations( input_set--[input_el], perm_size, condition, result++[input_el] ) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ) <span class="hljs-params"><span class="hljs-params">|&gt; List.flatten |</span></span>&gt; Enum.filter(&amp;(&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> != <span class="hljs-symbol"><span class="hljs-symbol">:failed</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  In the function make_permutations / 4, we simply get all permutations of elements from the set input_set of length perm_size, which satisfy the condition condition. <br>  And in the module in which we want to use the result of specific calculations, we simply write: <br><br><pre> <code class="ruby hljs">@horse_ways Permutations.make_permutations([-<span class="hljs-number"><span class="hljs-number">1</span></span>, -<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>, fn(lst) -&gt; Enum.reduce(lst, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;(abs(&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)+&amp;<span class="hljs-number"><span class="hljs-number">2</span></span>)) == <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> )</code> </pre><br><br>  @ - module attribute designation.  The expression accepted by the module attribute is calculated when the module is compiled. <br>  Now we are ready to write the missing code.  Here everything is completely trivial, and the names of functions and arguments speak for themselves. <br><br><pre> <code class="ruby hljs"> defp generate_new_list_and_game_next(game_state = %GameState{<span class="hljs-symbol"><span class="hljs-symbol">current_pos:</span></span> current_pos}, limit) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @horse_ways <span class="hljs-params"><span class="hljs-params">|&gt; Enum.map( &amp;(generate_new_position(current_pos, &amp;1)) ) |</span></span>&gt; Enum.filter(&amp;( can_go_here?(game_state, &amp;<span class="hljs-number"><span class="hljs-number">1</span></span>, limit) )) <span class="hljs-params"><span class="hljs-params">|&gt; Enum.map(&amp;( go_here(game_state, &amp;1) )) |</span></span>&gt; game(limit) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp generate_new_position( %Position{<span class="hljs-symbol"><span class="hljs-symbol">first:</span></span> first, <span class="hljs-symbol"><span class="hljs-symbol">second:</span></span> second}, {delta1, delta2} ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %Position{<span class="hljs-symbol"><span class="hljs-symbol">first:</span></span> (first+delta1), <span class="hljs-symbol"><span class="hljs-symbol">second:</span></span> (second+delta2)} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp can_go_here?( %GameState{<span class="hljs-symbol"><span class="hljs-symbol">current_pos:</span></span> current_pos, <span class="hljs-symbol"><span class="hljs-symbol">path:</span></span> path}, prompt = %Position{<span class="hljs-symbol"><span class="hljs-symbol">first:</span></span> first, <span class="hljs-symbol"><span class="hljs-symbol">second:</span></span> second}, limit ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(prompt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [current_pos <span class="hljs-params"><span class="hljs-params">| path]) </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">and</span></span></span><span class="hljs-params"> Enum.all?([first, second], &amp;( (&amp;1 &lt;= limit) </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">and</span></span></span><span class="hljs-params"> (&amp;1 &gt; 0) )) </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span><span class="hljs-params"> defp go_here( %GameState{current_pos: current_pos, path: path}, prompt ) </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">do</span></span></span><span class="hljs-params"> %GameState{current_pos: prompt, path: path++[current_pos]} </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span></span></code> </pre><br>  Full listing: <br><div class="spoiler">  <b class="spoiler_title">full listing</b> <div class="spoiler_text"><pre> <code class="ruby hljs">defmodule Permutations <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_permutations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( input_set, perm_size, condition, result \\ [])</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_permutations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _input_set, perm_size, condition, result )</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (length(result) == perm_size) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> condition.(result) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; List.to_tuple(result) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; <span class="hljs-symbol"><span class="hljs-symbol">:failed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_permutations</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( input_set, perm_size, condition, result )</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (length(input_set)+length(result) &gt;= perm_size) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Enum.map( input_set, fn(input_el) -&gt; make_permutations( input_set--[input_el], perm_size, condition, result++[input_el] ) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ) <span class="hljs-params"><span class="hljs-params">|&gt; List.flatten |</span></span>&gt; Enum.filter(&amp;(&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> != <span class="hljs-symbol"><span class="hljs-symbol">:failed</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defmodule Horse.Solution <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">######################### ### compile-time work ### ######################### </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@horse</span></span></span><span class="hljs-comment">_ways Permutations.make_permutations([-1, -2, 1, 2], 2, fn(lst) -&gt; Enum.reduce(lst, 0, &amp;(abs(&amp;1)+&amp;2)) == 3 end ) # structs of data defmodule Position do defstruct first: 1, second: 1 end defmodule GameState do defstruct current_pos: %Position{}, path: [] end #################### ### runtime work ### #################### def init(limit) when (is_integer(limit) and (limit &gt; 0)) do :random.seed(:erlang.now) [ %GameState{current_pos: %Position{ first: :random.uniform(limit), second: :random.uniform(limit)} |&gt; inform_user_about_beginning } ] |&gt; game(limit) |&gt; show_game_results(limit) end defp inform_user_about_beginning info do IO.puts "Hello, user, we begin from #{inspect info}" info end defp game([], _limit) do [] end defp game(lst, limit) do case game_over?(lst, limit) do true -&gt; lst false -&gt; Enum.map(lst, &amp;(generate_new_list_and_game_next(&amp;1, limit))) |&gt; List.flatten end end defp game_over?([%GameState{path: path}| _rest], limit) do length(path) == (limit*limit - 1) end defp generate_new_list_and_game_next(game_state = %GameState{current_pos: current_pos}, limit) do </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@horse</span></span></span><span class="hljs-comment">_ways |&gt; Enum.map( &amp;(generate_new_position(current_pos, &amp;1)) ) |&gt; Enum.filter(&amp;( can_go_here?(game_state, &amp;1, limit) )) |&gt; Enum.map(&amp;( go_here(game_state, &amp;1) )) |&gt; game(limit) end defp generate_new_position( %Position{first: first, second: second}, {delta1, delta2} ) do %Position{first: (first+delta1), second: (second+delta2)} end defp can_go_here?( %GameState{current_pos: current_pos, path: path}, prompt = %Position{first: first, second: second}, limit ) do not(prompt in [current_pos | path]) and Enum.all?([first, second], &amp;( (&amp;1 &lt;= limit) and (&amp;1 &gt; 0) )) end defp go_here( %GameState{current_pos: current_pos, path: path}, prompt ) do %GameState{current_pos: prompt, path: path++[current_pos]} end defp show_game_results([], limit) do IO.puts "FAIL. This is no any way to go through desk #{limit}x#{limit} from this position." end defp show_game_results([%GameState{current_pos: current_pos, path: path} | rest_way], limit) do """ SUCCESS! There are #{length(rest_way)+1} ways to go through desk #{limit}x#{limit} from this position. Here one of them: """ |&gt; IO.puts Enum.each( path++[current_pos] , &amp;(IO.puts "\t#{inspect &amp;1}") ) end end</span></span></code> </pre><br></div></div><br><br>  Let's try to run.  It should turn out something like this: <br><br><img src="https://habrastorage.org/files/37f/103/927/37f103927619444c894facafb2ead812.png" alt="image"><br><br>  Or such, if not lucky with the initial conditions: <br><br><img src="https://habrastorage.org/files/fde/667/563/fde6675630304343baa52cf617c77bf6.png" alt="image"><br><br>  How quickly did you get the result for the 5x5 board?  And 6x6?  Not very fast.  As the top shows us, Erlang VM loads only one core. <br><br><img src="https://habrastorage.org/files/c13/01f/602/c1301f6023d2403e8d1787d0bfb7563e.png" alt="image"><br><br>  Time for parallelization of calculations. <br><br><h1>  Parallel optimization of problem solving </h1><br><br>  Creating a new process in Erlang VM is easy.  The spawn and spawn_link functions launch a function in the new process that is taken as the argument and returns the PID of the child process.  The process terminates after this function returns a value.  Using spawn_link is generally more preferable, since in this case, if there was an exception in the child process, it will be forwarded to the parent process, and vice versa, which makes program execution more deterministic. <br><br><pre> <code class="ruby hljs">spawn_link fn() -&gt; IO.puts <span class="hljs-string"><span class="hljs-string">"hello from </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{inspect </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment"># =&gt; #PID&lt;0.80.0&gt; spawn_link fn() -&gt; 109 / 0 end # =&gt; ** (EXIT from #PID&lt;0.76.0&gt;) an exception was raised spawn fn() -&gt; 109 / 0 end # =&gt; #PID&lt;0.85.0&gt;</span></span></code> </pre><br><br>  The obvious place to optimize is the Enum.map/2 function anywhere in our code ‚Äî all you need to do is to process each element of the list in a separate process, and then compile a new list from the obtained values.  Why is this not implemented directly in the core of the language? <br>  The first possible reason is that in the general case no one guarantees that a pure function will be passed to Enum.map.  Alas, sometimes it matters in what order to do the calculations.  Such "dirty" functions, the result of which (in a global sense) depends not only on arguments, but must be avoided, but if it cannot be avoided, it can at least be localized. <br>  The second possible reason is the limited number of processes.  If we allow such a hypothetical parallel-running Enum.map to be somehow called recursively, then the number of processes will start to grow like an avalanche.  Erlang virtual machine in this regard is a very stable thing, and the processes themselves are very cheap.  But everything in this world has a limit. <br>  However, right now we will write our own, parallel (and correctly), working Enum.map (although the purity of the functions transferred to Enum.map will remain on the conscience of the one who will use it). <br><br>  Formally, processes in Erlang VM do not have shared data, they are completely isolated, and can only send messages to each other asynchronously.  The message can be any Erlang term.  Messages are sent by the send / 2 function, and are received using receive-expressions that are very similar to case expressions.  The difference is that if a suitable clause was not found for the receive expression (i.e. there are no messages of the expected types in the mailbox), the exception is not thrown, but the expression ‚Äúfreezes‚Äù until a suitable message arrives (it is also possible to specify a certain timeout ). <br><br><pre> <code class="ruby hljs">defmodule Some <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiver</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IO</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">puts</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiver</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiver</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">please</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">die</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IO</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">puts</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OK</span></span></span><span class="hljs-function"> ... " </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">child</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spawn_link</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&amp;</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Some</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiver</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">/</span></span></span><span class="hljs-function">0 </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment"># =&gt; #PID&lt;0.182.0&gt; send child, "hello" # =&gt;   hello from receiver send child, "some message" # =&gt;      send child, "hello" # =&gt;   hello from receiver send child, "please, die" # =&gt;   OK ...</span></span></span></span></code> </pre><br><br>  As you can see, everything is very simple.  But there is one "but" about which we have already spoken.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erlang VM can support simultaneously thousands, tens and even hundreds of thousands of processes. But this number is all the same of course, and this must be taken into account. For such accounting, we need one for the entire Erlang VM process counter. It is arranged very simply - when accepting the corresponding messages from other processes, it should be able to magnify by 1, decrease by 1, or send its value to the process that requested this value. How to store the state of an abstract object in functional languages ‚Äã‚Äãwhere there are no shared memory and global variables? The correct answer is recursion.</font></font><br><br><pre> <code class="ruby hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_enum_control_system</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-function"> \\ 1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">%</span></span></span><span class="hljs-function">{ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sender</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">query</span></span></span><span class="hljs-function">: :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_number</span></span></span><span class="hljs-function">} </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sender</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_enum_control_system</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-function"> :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_enum_control_system</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">+</span></span></span><span class="hljs-function">1 :</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_enum_control_system</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">number</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-function">1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IO</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">puts</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WARNING!</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unexpected</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_enum_control_system</span></span></span><span class="hljs-function">: </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#{inspect some}" parallel_enum_control_system number end end</span></span></span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But it is inconvenient to transfer the PID of the process counter to each process that wants to send a message to the process counter. Especially considering that ParallelEnum.map can (and in our case will) indirectly call itself recursively. We will register its PID under some name (pseudonym) and we will send messages using an alias. In the listing below you can see what happens when you call ParallelEnum.map - if the process under the name of the process counter is not registered, start it and register it. I use if instead of case in order to emphasize that the result that this expression returns in this case is not important, and the expression is executed solely for the sake of side-effect. Note also that instead of spawn_link, spawn is used here.</font></font> This is not an accident.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that initially we did not make any assumptions about where, when and by whom the ParallelEnum.map/2 function will be used. </font><font style="vertical-align: inherit;">If somewhere in Erlang VM 2 ParallelEnum.map/2 functions are performed simultaneously, and one of them for some reason throws an exception, then the counter-process will fall, creating obvious prerequisites for unpredicted behavior and for ‚Äúhealthy‚Äù process, which is simply not fortunate enough at the moment to perform the function ParallelEnum.map/2. </font><font style="vertical-align: inherit;">That is why the process counter should not be linked (linked) with any other process.</font></font><br><br><pre> <code class="ruby hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lst</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">limit</span></span></span><span class="hljs-function"> \\ 2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">:erlang</span></span></span></span><span class="hljs-function"><span class="hljs-params">.whereis(@controller)</span></span></span></span> == <span class="hljs-symbol"><span class="hljs-symbol">:undefined</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:erlang</span></span>.register( @controller, spawn(ParallelEnum, <span class="hljs-symbol"><span class="hljs-symbol">:parallel_enum_control_system</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>]) ) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> Enum.map(lst, &amp;(try_make_child(&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>, func, limit))) <span class="hljs-params"><span class="hljs-params">|&gt; Enum.map( &amp;collect_results/1 ) </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the if-expression, in the body of the ParallelEnum.map/2 function is the classic map-reduce (for some irony, the map-map is formally here, but do not rush to conclusions). </font><font style="vertical-align: inherit;">So, according to </font></font><a href="https://ru.wikipedia.org/wiki/MapReduce"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikipedia,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this pattern consists of two steps.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step Map </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the Map step, we check the number of running processes related to ParallelEnum according to the counter process. </font><font style="vertical-align: inherit;">If the specified limit for the number of processes is not exceeded, we create a child process, transfer to it our PID (so that it can return the results to us), as well as a function with arguments that the workflow must perform. </font><font style="vertical-align: inherit;">If the limit is exceeded, the parent process executes the expression itself.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few words about why we use the IntermediateResult structure. </font><font style="vertical-align: inherit;">If there were no restrictions on the number of processes, we could simply compile a list of the PIDs of the child processes and then wait for the responses from them in turn. </font><font style="vertical-align: inherit;">But due to the restriction, the parent process in some cases will have to do the work itself, and this structure will help us at the reduce step to understand whether to wait for the results from the child process.</font></font><br><br><pre> <code class="ruby hljs"> defmodule IntermediateResult <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> defstruct <span class="hljs-symbol"><span class="hljs-symbol">child_pid:</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">my_own_result:</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp try_make_child(arg, func, limit) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (get_number_of_processes &lt; limit) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; %IntermediateResult{<span class="hljs-symbol"><span class="hljs-symbol">child_pid:</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">my_own_result:</span></span> func.(arg)} <span class="hljs-comment"><span class="hljs-comment"># in this case do work yourself haha true -&gt; %IntermediateResult{child_pid: spawn_link(ParallelEnum, :worker, [self, func, arg]), my_own_result: nil} end end defp get_number_of_processes do send </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@controller</span></span></span><span class="hljs-comment">, %{ from: self, query: :get_number } receive do num when is_integer(num) -&gt; num end end</span></span></code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The working process </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is absolutely nothing complicated here: right after launch, we send an increment signal to the counter, perform the function, send the results to the spawning process, and before completing, send the decrement signal to the counter. </font></font><br><br><pre> <code class="ruby hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(daddy, func, arg)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> send @controller, <span class="hljs-symbol"><span class="hljs-symbol">:increment</span></span> send daddy, <span class="hljs-string"><span class="hljs-string">%{ from: self, result: func.(arg)}</span></span> send @controller, <span class="hljs-symbol"><span class="hljs-symbol">:decrement</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduce step </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, too, everything is pretty transparent. </font><font style="vertical-align: inherit;">The IntermediateResult structure obtained after the map step unequivocally shows what needs to be done at the reduce step ‚Äî take the ready result (in case the parent process did the work itself), or wait for the message with the result from the child process.</font></font><br><br><pre> <code class="ruby hljs"> defp collect_results( %IntermediateResult{<span class="hljs-symbol"><span class="hljs-symbol">child_pid:</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">my_own_result:</span></span> result}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp collect_results( %IntermediateResult{<span class="hljs-symbol"><span class="hljs-symbol">child_pid:</span></span> pid, <span class="hljs-symbol"><span class="hljs-symbol">my_own_result:</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> receive <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-string"><span class="hljs-string">%{ from: incoming_pid, result: result}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (incoming_pid == pid) -&gt; result <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now it remains to replace the Enum.map function with the ParallelEnum.map function, for example, in the game function, and it's done. </font><font style="vertical-align: inherit;">The final version of the code can be found </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Performance tests </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the problem ‚ÄúEuler's horse‚Äù is solved and the solution is optimized. </font><font style="vertical-align: inherit;">Now everything works quickly and loads all processor cores to its fullest. </font></font><br><br><img src="https://habrastorage.org/files/6ea/f13/8bd/6eaf138bd7094c689628b455c01caa7e.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time for tests. </font><font style="vertical-align: inherit;">During the discussion of parallel optimization, almost nothing was said about what the limitation of the number of processes for this task should be. </font><font style="vertical-align: inherit;">We will slightly change our functions from the Horse.Solution module in order to be able to uniquely specify the required number of processes and the initial position of the horse (for definiteness). </font><font style="vertical-align: inherit;">And let's test the execution time of the Horse.Solution.init function for a 5x5 board, starting position 1.1 and different values ‚Äã‚Äãof the maximum number of processes using this function:</font></font><br><br><pre> <code class="ruby hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_of_performance</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enum</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">..</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fn(num)</span></span></span></span> -&gt; test_of_performance_process(num) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ) Enum.each( [<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">75</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">150</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">250</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>], fn(num) -&gt; test_of_performance_process(num) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ) <span class="hljs-comment"><span class="hljs-comment"># to test this, add +P 100000000 flag when starting iex Enum.each( [10000, 50000, 100000, 500000, 1000000, 5000000, 10000000], fn(num) -&gt; test_of_performance_process(num) end ) end defp test_of_performance_process(num) do {res, _} = :timer.tc( fn() -&gt; init(5, num, %Position{}) end ) File.write "./test_results", "#{num} #{res}\n", [:append] end</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Measurements showed a minimum of time (maximum performance) on the number of working processes 24. </font></font><br><br><img src="https://habrastorage.org/files/921/257/aae/921257aaee8c4e78a4bd5f2cc19917f9.jpg" alt="image"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Why so much </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After all, the kernels on our local machine are much smaller. </font><font style="vertical-align: inherit;">Because Erlang VM processes are not OS processes in the usual sense of the word. </font><font style="vertical-align: inherit;">It does not even flow. </font><font style="vertical-align: inherit;">A vitreal machine fully encapsulates them in itself, and evenly distributes the load across the processor cores (if possible).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Why so little </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erlang VM processes cost very few resources, but still cost. As the number of processes increases, the total overhead also grows; moreover, evenly distributing the load on the processor cores at around 24 processes, the virtual machine cannot ‚Äúeven more evenly‚Äù distribute the load - here it rests on the physical limitations of the real processor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our particular case, it is still worth remembering about the process counter. When a parent process decides whether to create a child process or do the work itself, it requests from the counter process the number of processes already running. Here he needs not only to send a message to the counter, but also to wait for a response from him. Process - one counter. Work processes - hundreds of thousands. I think everything is clear.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why productivity started to grow again after marking 1,000,000 processes is a mystery to me.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erlang is a unique phenomenon in the world of multi-threaded programming. In 1987, when there wasn‚Äôt even Java, but I thought I could only dream about simple multithreaded programming in C ++ - the developers at Ericsson had already written fault-tolerant programs for use in telecommunications. The Erlang language and its virtual machine were created for purely utilitarian purposes - to solve specific telecom tasks, over the years of its existence, the language evolved on real tasks (unlike, for example, Haskell). In the process of development, it was ‚Äúovergrown‚Äù with a multitude of well-functioning and documented libraries, the OTP (Open Telecom Platform) framework appeared. OTP for Erlang is more than, say Qt for C ++.Remember about the send function and receive-expression? In Erlang VM, there is actually only asynchronous interprocess communication. For large projects, writing such low-level code is not very convenient, OTP has tools that encapsulate low-level details and provide a very simple, convenient and intuitive interface - there is not only asynchronous exchange, but, for example, synchronous, error handling tools / falls and more. In this article I did not use OTP just because it is a topic for a separate large article. For stability and fault tolerance, Erlang VM has no equal - remember, when we tested the performance for a different number of processes, the last value was 10,000,000! At the same time, performance, of course, fell compared to 24, but in no way fatal way. Yes, arithmetic in Erlang VM is "tug",but as they say, if you want fast arithmetic, Fortran is in your hands. With this figure I just wanted to say that for Erlang VM you can write programs in which you need to simultaneously serve</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">really a lot of</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> processes. </font><font style="vertical-align: inherit;">As an example, a web server or something similar comes to mind. </font><font style="vertical-align: inherit;">In addition, the performance of Erlang VM is very good, in principle it is soft-realtime. </font><font style="vertical-align: inherit;">In general, the Erlang / Elixir + OTP YaP can become your indispensable assistant for writing stable, distributed and very reliable programs.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UPD: Lisp version </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A couple of days ago I decided to join simultaneously with Lisp and JVM, and rewrote this task in the Clojure language. </font><font style="vertical-align: inherit;">Actually about the elegance / readability of the code here you can argue endlessly, but the fact that the speed of work here is also quite acceptable. </font></font><br><br><img src="https://habrastorage.org/files/c21/01a/7cc/c2101a7cc3d54687b36a2cfc8daf07d4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code is </font></font><a href="https://github.com/timCF/hello_jvm_world/tree/master/src/hello_jvm_world"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For those who want to still understand where Elixir actually grows legs - I advise you to get acquainted with some Lisp dialect, really a lot falls into place.</font></font></div><p>Source: <a href="https://habr.com/ru/post/233637/">https://habr.com/ru/post/233637/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../233625/index.html">Madrobots goes to war: how do we open a point in "Mega"</a></li>
<li><a href="../233627/index.html">Smart Watch Moto360 lit up in BestBuy prices with a price of $ 249.99</a></li>
<li><a href="../233629/index.html">NASA presented a prototype origami system for spacecraft photovoltaic cells</a></li>
<li><a href="../233631/index.html">Search for a path through NavMesh in ActionScript - CrossBridge port Recast Navigation</a></li>
<li><a href="../233635/index.html">Interesting facts about the work of technical support</a></li>
<li><a href="../233639/index.html">Is communal paradise available for everyone? The story of the sad end</a></li>
<li><a href="../233641/index.html">Wind turbine from 3D printer: AirEnergy3D</a></li>
<li><a href="../233643/index.html">Memcached in PHP Kohana and its testing</a></li>
<li><a href="../233645/index.html">DBLookupComboBox in FireMonkey, or a crutch for a red monkey</a></li>
<li><a href="../233647/index.html">Enter fractional values ‚Äã‚Äãwithout changing the layout</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>