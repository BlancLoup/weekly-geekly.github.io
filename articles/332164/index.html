<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to procedural animation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this series of articles we will introduce inverse kinematics in video games. Before we begin our journey, I‚Äôll talk about a few games that use proc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to procedural animation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/08a/fd1/81d/08afd181dda5f1f4bb11da01d0ad7442.png" alt="image"><br><br>  In this series of articles we will introduce <strong>inverse kinematics</strong> in video games.  Before we begin our journey, I‚Äôll talk about a few games that use <strong>procedural animations</strong> and how they differ from traditional resource-based animations. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/5a4/2cf/37b/5a42cf37b278c9d4376f496bf64d2faf.gif"></div></div><br>  The series will consist of the following parts: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Part 1. Introduction to procedural animation </li><li>  Part 2. Mathematics of direct kinematics </li><li>  Part 3. Realization of direct kinematics </li><li>  <a href="https://habrahabr.ru/post/332198/">Part 4. Introduction to Gradient Descent</a> </li><li>  <a href="https://habrahabr.ru/post/332198/">Part 5. Inverse kinematics for a robotic arm</a> </li><li>  <a href="https://habrahabr.ru/post/332198/">Part 6. Inverse kinematics of tentacles</a> </li><li>  <s>Part 7. Inverse kinematics of spider legs</s> </li></ul><a name="habracut"></a><br><h2>  Part 1. Introduction to procedural animation </h2><br>  In most games, character animations are ‚Äústatic.‚Äù  When a character moves on the screen, the artist creates a specific movement.  They are handcrafted or recorded using motion capture.  Animations in this case are pre-created <strong>resources</strong> .  When a character needs to perform another action, another animation is required.  This way of implementing character movement is fairly standard for the games industry.  There are large and detailed collections of animations in which there are the most commonly used behaviors, such as walking, jumping, and shooting.  Traditional animations dominate the gaming industry, but they have equivalent alternatives.  I want to introduce you to the concept of <strong>procedural animations</strong> . <br><br>  The main idea here is that the moments of the character's state can be generated procedurally.  In one of the most standard techniques for generating procedural animations, physics simulation is used.  Therefore, it is often called <strong>physical animation</strong> ( <a href="https://en.wikipedia.org/wiki/Physically_based_animation">Wikipedia</a> ).  A typical example is water.  You can animate it manually or use animation that takes into account the <strong>dynamics of liquids</strong> . <br><br>  Below we will discuss a very specific subtype of physical animations in which rigid body simulation is used.  The same type of simulation is commonly used in game engines, such as Unity and Unreal.  Let's see how this simple principle is used in games to create physical animations. <br><br><h3>  Ragdoll physics </h3><br>  At the very basis of physical animations lies the principle of the possibility of simulating the movement of characters.  By recreating the processes and limitations that govern the human body, one can get closer to creating realistic behaviors.  One of the simplest but effective ways to create procedural animations is the use <strong>of ragdoll physics (ragdoll, ragdoll)</strong> ( <a href="https://ru.wikipedia.org/wiki/Ragdoll-%25D1%2584%25D0%25B8%25D0%25B7%25D0%25B8%25D0%25BA%25D0%25B0">Wikipedia</a> ).  The idea is to create a humanoid body and connect all its links with joints to recreate the degrees of freedom demonstrated by the real prototype.  Just using the physics of solids and limiting joints, you can simulate the fall of the human body.  This not only allows you to save money on the "death animation".  It also allows you to create characters that fall realistically and interact with environments.  Such a task is almost impossible to solve with the help of only a ready-made set of animations, regardless of its accuracy. <br><br>  The biggest drawback of Ragdolls is their huge unpredictability, which often leads to very funny behaviors. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/ffa/5d3/2b9/ffa5d32b98132542c129f69741ce77b4.gif"></div></div><br>  Today, ragdolls are very familiar in games.  Unity has a simple <a href="https://docs.unity3d.com/Manual/wizard-RagdollWizard.html">Ragdoll Wizard</a> tool that allows you to quickly turn a humanoid model into a ragdoll. <br><br><h3>  Solid body simulations </h3><br>  The main problem of ragdolls is the lack of motion control.  If you connect parts of the body with joints, the character can neither walk nor jump.  He will only fall.  However, there are situations in which a mixed approach can be used. <br><br>  In a <a href="https://www.rockpapershotgun.com/2016/09/23/how-grow-home-uses-maths-to-generate-a-personality/">How Grow Home Uses Maths To Generate Personality</a> article, game journalist <a href="https://twitter.com/rotational">Alex Wiltshire (Alex Wiltshire)</a> talks with Ubisoft representatives about the game <strong>Grow Home</strong> .  One of the main features of the game is the way the main character moves, Bud (BUD).  The game has no ready-made animations, at least in the <em>traditional</em> sense.  When a player moves, the position of the legs and arms is controlled by a code.  Parts of the body are subject to the same restrictions as Ragdoll, which causes them to create compelling animations. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Ajp3cx1HACM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A similar principle is also widely used in <a href="http://store.steampowered.com/app/312520/">Rain World</a> .  Each animal in the game has a body consisting of several colliders.  Some of them are controlled by code, others are controlled by joints.  This can be seen in the animation below.  The end points of the wings of a bird of prey move programmatically, the remaining bones are connected by hinges.  Endpoint control automatically creates a smooth animation that you could not otherwise achieve. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/dc6/183/814/dc6183814afae4c4f72b02a05abf0d2c.gif"></div></div><br>  In both Grow Home and Rain World, procedural animations are used to increase the realism of the characters.  However, controllers do not rely on these animations.  In the game <a href="http://store.steampowered.com/app/285900/">Gang Beasts,</a> this concept is developed even further.  The game fully approves of loose movements resulting from the use of ragdoll physics.  The result was funny characters with unpredictable movements. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/bad/c94/376/badc94376e4fc437cd2d2218c68086b2.gif"></div></div><br><h3>  Inverse kinematics </h3><br>  Simulations of a rigid body allow you to simplify the creation of animations.  We indicate where the hands and legs of Bud should be, and the physics engine does the rest.  This very simple approach works with simple characters, but it often lacks realism.  In simulations of a solid body, only parameters such as gravity and mass are taken into account, but they lack knowledge of the context.  In many cases, it is required to create something that acts not only under the influence of restrictions caused by gravity and connections. <br><br>  The next step in creating procedural animations is known as <strong>inverse kinematics</strong> .  For any type of ragdoll, inverse kinematics calculates how to move it to achieve the desired goal.  In Grow Home and Rain World, physics itself determines how gravitated compounds should move.  Inverse kinematics makes them move in the right phases. <br><br>  One of the first indie games in which this concept was actively used was <a href="http://futureproofgames.com/games/majesty/">The Majesty Of Color</a> Studio <a href="https://twitter.com/playfutureproof">Future Proof Games</a> .  In it, the player controls the tentacle of the sea creature.  Unlike the wing of the bird from the Rain World, this tentacle is not just driven by hinges.  Each segment is rotated so that the end point of the tentacle reaches the desired point.  If only a rigid body simulation was used in this animation, then the tentacle would seem to be ‚Äúpinned‚Äù to this point, like a piece of rope. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/f90/e3d/f82/f90e3df82ed1e96c6cc4767465c29e05.gif"></div></div><br>  Inverse kinematics can be used to solve a variety of problems.  The most standard is the natural movement of humanoid characters to certain objects.  Instead of using pre-defined animations, the developers simply indicate the goal that the hand must achieve.  All the rest is done by inverse kinematics, which finds the most natural way of moving the joints of the hand.  If only a rigid body simulation was used, then the movement would be convulsive, it would seem that parts of the body are simply being dragged. <br><br>  In the Unity animation editor called <strong>Mechanim</strong> there is a tool ( <a href="https://docs.unity3d.com/Manual/InverseKinematics.html">Unity help</a> ) that allows the developer to use inverse kinematics for humanoid characters. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08a/fd1/81d/08afd181dda5f1f4bb11da01d0ad7442.png"><br><br>  In the rest of this series of articles, I will focus on solving the problem of inverse kinematics.  We will figure out how you can control a robotic arm or a monster's tentacle. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/1ac/bf6/27f/1acbf627fbf4b87362ca98c3c8507d3a.gif"></div></div><br><h2>  Part 2. Mathematics of direct kinematics </h2><br>  Now we begin the journey into the world of <strong>inverse kinematics</strong> .  There are many ways to solve this problem, but they all start with <strong>direct kinematics</strong> . <br><br>  Inverse kinematics takes a point in space and tells us how to move your hand to reach it.  Direct kinematics solves the opposite <em>dual</em> problem.  Knowing how we will move our hand, she tells us which point in space the hand will reach. <br><br><h3>  Robotic arm </h3><br>  Inverse kinematics was originally used to control <strong>robotic arms</strong> .  Therefore, in this series of articles will be used assumptions and terminology of robotics.  However, this does not limit the possible applications of inverse kinematics.  You can use it for human hands, paws, spiders and tentacles. <br><br>  First, let's start with a demonstration of what we understand by the term ‚Äúrobot manipulator‚Äù: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8eb/b8d/98e/8ebb8d98e17465b915982a08a001d75a.png"><br><br>  The image above shows a standard robotic arm made from ‚Äúlinks‚Äù (limbs) connected by ‚Äújoints‚Äù (joints).  Since the robot shown in the image has five independent joints, it is believed that it has five <strong>degrees of freedom</strong> .  Each joint is controlled by the engine, allowing you to move the link attached to the joint at a certain angle. <br><br>  To consider a more general example, we can draw a joint scheme.  In this article, we will assume that each joint can only rotate along one axis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01f/93f/99c/01f93f99c33fc35eb0a5c0b1a78d1e9f.png"></div><br><br>  A tool attached to the end of a robotic arm is called an <strong>end link</strong> .  Depending on the context, it may or may not be considered one degree of freedom.  In this article, the final link will not be taken into account, because we will focus only on the movement to reach the desired point. <br><br><h3>  Direct kinematics </h3><br>  In this example, each joint can rotate along one axis.  Therefore, the state of each joint is measured as an angle.  By turning each joint at a certain angle, we allow the end link to reach different points in space.  Determining where the final link is located at known angles of articulation is called <strong>direct kinematics</strong> . <br><br>  Direct kinematics is a ‚Äúsimple‚Äù problem.  It means that for each set of angles there is one single result that can be calculated without any uncertainties.  Determining how the robotic arm moves depending on the data we transmit is a necessary step to find the inverse problem of inverse kinematics. <br><br><h3>  Geometric interpretation </h3><br>  Before we start writing code, we need to understand the mathematical constructions behind the direct kinematics.  But first of all we need to understand what it means spatially and geometrically. <br><br>  Since it‚Äôs not so easy to visualize turns in 3D, let's start with a simple manipulator in 2D space.  The robot arm has a ‚Äústarting position‚Äù - this is a configuration in which all the joints are turned at their ‚Äúzero angle‚Äù. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5a/e2d/c95/c5ae2dc955c908123087a7cc9184d8d8.png"></div><br><br>  The diagram above shows a manipulator with three degrees of freedom.  Each joint is turned to the position of its zero angle, that is, the robot is in the initial position.  We can see how this configuration changes when the articulation is turned. <img src="https://habrastorage.org/getpro/habr/post_images/6c6/c1b/d41/6c6c1bd4124fcb103b75143f84b9d97d.png">  on <img src="https://habrastorage.org/getpro/habr/post_images/247/13e/dcb/24713edcbaf7a747d6eb2f7249c7b711.png">  degrees  It leads to the corresponding movement of the whole chain of joints and links attached to <img src="https://habrastorage.org/getpro/habr/post_images/6c6/c1b/d41/6c6c1bd4124fcb103b75143f84b9d97d.png">  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9eb/1a6/76e/9eb1a676eacc7593a928f75bc9d15190.png"></div><br><br>  It is important to note that the engines attached to the other joints have not moved yet.  Each joint contributes to the local rotation of a straight chain of links.  The diagram below shows the configuration change when turning the second joint on <img src="https://habrastorage.org/getpro/habr/post_images/a3d/f35/bfb/a3df35bfb983320e4886f942f10f2dbf.png">  degrees <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a37/7cf/047/a377cf047308615e2ae2029398ea2c4a.png"></div><br><br>  Position <img src="https://habrastorage.org/getpro/habr/post_images/8d2/b98/8eb/8d2b988eb924e81b8221eb30a5507ffb.png">  determines only <img src="https://habrastorage.org/getpro/habr/post_images/247/13e/dcb/24713edcbaf7a747d6eb2f7249c7b711.png">  and on <img src="https://habrastorage.org/getpro/habr/post_images/979/9ff/98c/9799ff98cfa8ea188d61e7d68f240943.png">  impact already and <img src="https://habrastorage.org/getpro/habr/post_images/247/13e/dcb/24713edcbaf7a747d6eb2f7249c7b711.png">  and <img src="https://habrastorage.org/getpro/habr/post_images/a3d/f35/bfb/a3df35bfb983320e4886f942f10f2dbf.png">  .  The coordinate coordinate system (red and blue arrows) is oriented according to the sum of the turns of the earlier chain of connections to which it is attached. <br><br><h3>  Maths </h3><br>  From the previous schemes it is obvious that in order to solve the problem of direct kinematics, we need to calculate the position of the nested (subordinate) objects during their rotation. <br><br>  Let's see how to calculate it on the example of two joints.  Having found a solution for two elements, we can repeat this process to solve chains of any length. <br><br>  Let's start with the simple case when the first joint is in its initial position.  It means that <img src="https://habrastorage.org/getpro/habr/post_images/998/317/2c8/9983172c89e011396c1f0af11af5319e.png">  as in the diagram below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/d4a/f7d/27dd4af7d1390d3c88a2eedae0cf56dd.png"></div><br><br>  It means that: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/395/0a6/eb63950a688e1640100a33c261eff2dc.png"></div><br><br>  When <img src="https://habrastorage.org/getpro/habr/post_images/247/13e/dcb/24713edcbaf7a747d6eb2f7249c7b711.png">  not zero, we just need to rotate the distance vector at the pivot point <img src="https://habrastorage.org/getpro/habr/post_images/aa0/056/a93/aa0056a939b231c40891e65ecee2f57b.png">  around <img src="https://habrastorage.org/getpro/habr/post_images/6c6/c1b/d41/6c6c1bd4124fcb103b75143f84b9d97d.png">  on <img src="https://habrastorage.org/getpro/habr/post_images/247/13e/dcb/24713edcbaf7a747d6eb2f7249c7b711.png">  degrees: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/1d4/2e9/edb1d42e9d0a09dc6f043a6a4083eb00.png"></div><br><br>  Mathematically, this can be written as: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46c/efa/74f/46cefa74f3cb8b935011c84e04bfbb6c.png"></div><br><br>  Below we will learn how to use the <code>AngleAxis</code> function ( <a href="https://docs.unity3d.com/ScriptReference/Quaternion.AngleAxis.html">Unity documentation</a> ) without <code>AngleAxis</code> around with trigonometry. <br><br>  Reproducing the same logic, we can get an equation for <img src="https://habrastorage.org/getpro/habr/post_images/979/9ff/98c/9799ff98cfa8ea188d61e7d68f240943.png">  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/80a/aee/19f80aaee6fae1e11f317b6658372e28.png"></div><br><br>  And finally, the general equation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/294/5d9/dfc/2945d9dfc5c01b27fd4391697f57c476.png"></div><br>  In the next part of the article, we will see how this equation is <em>conveniently</em> implemented in C # code. <br><br><div class="spoiler">  <b class="spoiler_title">Direct kinematics in 2D</b> <div class="spoiler_text">  If you are familiar with rotation in 2D, then this can be done trigonometrically: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/499/beb/653/499beb653451770eae01180fa8a26747.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a0/437/274/9a043727430ccff1bb7934778e5da610.png"></div><br><br>  About the derivation of the equation can be read in my article <a href="http://www.alanzucconi.com/%3Fp%3D4275">A Gentle Primer on 2D Rotations</a> . </div></div><br><div class="spoiler">  <b class="spoiler_title">What about the Denavit-Hartenberg matrix?</b> <div class="spoiler_text">  If you have engineering knowledge, you could solve this problem differently.  The problems of direct and inverse kinematics are widely known, and there are several standardized approaches to solve them.  One of them is binding to each joint of four parameters, called <strong>Denavit-Hartenberg parameters</strong> ( <a href="https://en.wikipedia.org/wiki/Denavit%25E2%2580%2593Hartenberg_parameters">Wikipedia</a> ).  It is convenient to work with them in a matrix format and they are excellently suited for analytically solving the problem of inverse kinematics. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b4/1ba/65e/8b41ba65e81d24ad194fad3cd4a51a3d.png"><br><br>  However, in this article we do not use them.  Solving the Denavit-Hartenberg matrix requires more math than many programmers want to understand.  The approach I have chosen uses <strong>gradient descent</strong> , which is a more general optimization algorithm. </div></div><br><h3>  Part 3. Realization of direct kinematics </h3><br>  In this part we will continue to solve the problem of <strong>direct kinematics</strong> .  Having found the mathematical solution in the last part, now we will learn how to implement it in C # code for Unity.  In the next part, ‚ÄúIntroduction to Gradient Descent,‚Äù we finally show the theoretical rationale for solving the problem of <strong>inverse kinematics</strong> . <br><br><h3>  Introduction </h3><br>  In the previous section, we formalized the movement of a robotic arm.  We started with a simple example of three joints.  In their initial positions, they have the configuration shown below: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5a/e2d/c95/c5ae2dc955c908123087a7cc9184d8d8.png"></div><br><br>  Various <img src="https://habrastorage.org/getpro/habr/post_images/6bc/29b/cca/6bc29bccaded8344850ef0dc4051c64b.png">  The diagram represents Cartesian coordinates, or <img src="https://habrastorage.org/getpro/habr/post_images/d13/604/93b/d1360493b88534024e76ea8ccff089bb.png">  -th joint.  <em>Local angles</em> defining rotation relative to the starting positions are labeled as <img src="https://habrastorage.org/getpro/habr/post_images/ff2/6ef/e7f/ff26efe7f94a181ffa1f0a65f9274b43.png">  . <br><br>  When turning the joints, we see the following picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a37/7cf/047/a377cf047308615e2ae2029398ea2c4a.png"></div><br><br>  The behavior of this system can be summarized by the following statements: <br><br><ul><li>  <strong>Rotate</strong>  <em>Global twist</em> <img src="https://habrastorage.org/getpro/habr/post_images/1ab/f31/c25/1abf31c2566751ec25846e095fd0f41b.png">  articulations are the sum of the turns of all previous articulations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1df/a20/ffb/1dfa20ffbfff5128587b7195859cbaad.png"></div></li><li>  <strong>Position</strong>  <em>Global position</em> <img src="https://habrastorage.org/getpro/habr/post_images/6bc/29b/cca/6bc29bccaded8344850ef0dc4051c64b.png">  articulation is given as: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/294/5d9/dfc/2945d9dfc5c01b27fd4391697f57c476.png"></div></li></ul><br>  In view of the foregoing, we can begin to invent a possible way to implement these behaviors in Unity. <br><br><h3>  GameObject Hierarchy </h3><br>  In Unity, there is already a way to implement all of the above requirements: <strong>parenting</strong> .  If you make a game object a child of another, it automatically inherits position, rotation, and scale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a98/128/151/a98128151194b3070ca96bf34b38b9f1.gif"></div><br>  If rigging is familiar to you, it will not surprise you.  The bones, which are the joints of a humanoid character, also have a parental system, in which turns and movements are inherited.  The image from <a href="https://michaelarbuthnot.wordpress.com/2015/07/23/tutorial-unity-animation-3-character-setup/">Unity Animation 3: Character Setup by</a> Michael Erbetnot shows an obvious example of this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/299/5b6/9a6/2995b69a64a5d90759c0611c9bb4c643.jpg"></div><br><br>  When creating a hierarchy of connections, it is necessary to make sure that when all local Euler angles are zero, the robot arm is in the initial position.  For a humanoid character, this is usually the <strong>standard T-shaped pose</strong> shown in the image above. <br><br><h3>  Implementation </h3><br>  The ability to create child components in Unity <em>de facto</em> solves the problem of direct kinematics.  Unfortunately, this is not enough.  In the next part of the series of articles we will see that we really need a way to check the position of the final link <em>without</em> moving the robotic arm.  This will force us to implement this basic Unity feature in our own way. <br><br>  The first step is to save information about each of the joints of the robot arm.  This can be achieved using a script, for example <code>RobotJoint</code> from the following example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RobotJoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Axis; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 StartOffset; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { StartOffset = transform.localPosition; } }</code> </pre> <br>  To simplify the calculations, we assume that each joint can only rotate along its own local axis: X, Y, or Z. We denote this by the variable <code>Axis</code> , which takes the value <code>1</code> for the coordinate relative to the axis of rotation.  If the joint rotates along the Y axis, then <code>Axis</code> will look like <code>(0,1,0)</code> .  We will see how this allows us to get rid of constructions with <code>IF</code> . <br><br>  Let's create the <code>ForwardKinematics</code> function.  It gets an array of <code>angles</code> <code>float</code> numbers.  The name speaks for itself: <code>angles[i]</code> contains the value of the local rotation of the ith joint.  The function returns the position of the final link in global coordinates. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForwardKinematics</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> [] angles</span></span></span><span class="hljs-function">)</span></span> { ... }</code> </pre> <br>  The code is a simple C # implementation of the above position equation.  The <code>rotate</code> functions are implemented through the convenient <code>Quaternion.AngleAxis</code> function. <br><br><pre> <code class="cs hljs">Vector3 prevPoint = Joints[<span class="hljs-number"><span class="hljs-number">0</span></span>].transform.position; Quaternion rotation = Quaternion.identity; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; Joints.Length; i++) { <span class="hljs-comment"><span class="hljs-comment">//      rotation *= Quaternion.AngleAxis(angles[i - 1], Joints[i - 1].Axis); Vector3 nextPoint = prevPoint + rotation * Joints[i].StartOffset; prevPoint = nextPoint; } return prevPoint;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Need help with quaternions?</b> <div class="spoiler_text">  Turns in Unity are often described through Euler angles.  These are three numbers that correspond to the rotation of an object along the X, Y, and Z axes. Euler angles denote <strong>roll (roll)</strong> , <strong>pitch (pitch),</strong> and <strong>yaw (yaw) of the</strong> object in space.  However, from a mathematical point of view, using Euler angles can lead to rather unpleasant problems. <br><br>  Working with corners is more convenient with <strong>quaternions</strong> .  Quaternions are mathematical objects that can be used to describe <em>turns</em> .  In contrast, Euler angles describe the <em>orientation</em> .  Quaternion describes the path that you need to go from one orientation to another.  From a technical point of view, this is too great a simplification, but for our article it is more than enough. <br><br><h4>  Rotations ‚áî Quaternions </h4><br>  Quaternion can be represented as a turn.  The rotation of an object in space is, from a mathematical point of view, an analogue of multiplying its position by a quaternion.  You can use the <code>Quaternion.AngleAxis</code> function to create a rotation around a fixed point in Unity.  String <code>Quaternion.AngleAxis(angle, axis);</code>  creates a quaternion that describes the rotation around the axis <code>axis</code> by <code>angle</code> degrees.  In this context, the value of <code>Axis</code> can be <code>(1,0,0)</code> , <code>(0,1,0)</code> or <code>(0,0,1)</code> , which means, respectively, X, Y or Z. This explains why we created the variable <code>Axis</code> in the <code>RobotJoint</code> class. <br><br><h4>  Adding rotations  multiplication of quaternions </h4><br>  When multiplying two quaternions, a new quaternion is created, which includes both rotations.  At each iteration of the <code>for</code> loop, the <code>rotation</code> variable is multiplied by the current quaternion.  This means that it will include all the turns of all joints. <br><br><h4>  Quaternion * vector = rotated vector </h4><br>  Finally, quaternions are used in this line: <br><br><pre> <code class="cs hljs">Vector3 nextPoint = prevPoint + rotation * Joints[i].StartOffset;</code> </pre> <br>  It fully corresponds to the following entry: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/294/5d9/dfc/2945d9dfc5c01b27fd4391697f57c476.png"></div><br><br>  The product of a quaternion and a vector applies rotation. </div></div><br>  <i>[Ending follows.</i>  <i>In the second article, we will look at inverse kinematics.]</i> </div><p>Source: <a href="https://habr.com/ru/post/332164/">https://habr.com/ru/post/332164/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332142/index.html">Game control models in the context of incomplete information</a></li>
<li><a href="../332144/index.html">LibGDX + Scene2d (we program on Kotlin). Part 0</a></li>
<li><a href="../332146/index.html">Redux business logic</a></li>
<li><a href="../332160/index.html">Docker 17.06 and Kubernetes 1.7: key innovations</a></li>
<li><a href="../332162/index.html">FinWin-2017: competition fintech projects and the latest trends in the banking sector</a></li>
<li><a href="../332166/index.html">We simulate device control with actor</a></li>
<li><a href="../332168/index.html">Three years of successful provision of public rental services of virtual machines with Apache CloudStack</a></li>
<li><a href="../332172/index.html">5 free assets for Unity3D, which will facilitate the development process</a></li>
<li><a href="../332174/index.html">Updating document.title in the background tab</a></li>
<li><a href="../332176/index.html">Programming Contest: JSDash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>