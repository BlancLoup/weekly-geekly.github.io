<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Finding errors in the GCC compiler code using the PVS-Studio analyzer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I regularly check various open projects to demonstrate the capabilities of the PVS-Studio static code analyzer (C, C ++, C #). It's time for the GCC c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Finding errors in the GCC compiler code using the PVS-Studio analyzer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/944/ae5/914/944ae591472069d6a82d2a42dbcbf7f6.png" alt="Gcc" align="left">  I regularly check various open projects to demonstrate the capabilities of the PVS-Studio static code analyzer (C, C ++, C #).  It's time for the GCC compiler.  Undoubtedly, GCC is a very high-quality and tested project, so finding at least a few mistakes in it is already a great achievement for any tool.  To my delight, PVS-Studio has coped with this task.  No one is immune from typos and inattention.  That is why PVS-Studio can become your additional line of defense on the front of the endless war with bugs. <br><a name="habracut"></a><br><h2>  Gcc </h2><br>  <a href="https://gcc.gnu.org/">The GNU Compiler Collection</a> (commonly abbreviated as GCC) is a set of compilers for various programming languages ‚Äã‚Äãdeveloped by the GNU project.  GCC is free software, distributed by the free software foundation under the GNU GPL and the GNU LGPL, and is a key component of the GNU toolchain.  The project is written in C and C ++. <br><br>  The GCC compiler has good in-built diagnostics that help identify many errors at the compilation stage.  Naturally, GCC is collected using GCC and, accordingly, it can detect errors in its own code.  Additionally, the GCC source code is <a href="https://scan.coverity.com/projects/gcc">checked</a> using the Coverity analyzer.  And in general, I think GCC was tested by enthusiasts with the help of many analyzers and other tools.  This makes finding errors in GCC a big challenge for the PVS-Studio code analyzer. <br><br>  The trunk version from the <a href="">git repository</a> was taken for analysis: (git) commit 00a7fcca6a4657b6cf203824beda1e89f751354b svn + ssh: //gcc.gnu.org/svn/gcc/trunk@238976 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Note.  The article was delayed with the release, and perhaps some errors have already been fixed.  But it does not matter: new errors constantly appear, old ones disappear.  The main thing - the article shows that static analysis can help programmers to detect errors after they appear. <br><br><h2>  Anticipating the discussion </h2><br>  As I said in the introduction, I consider GCC a project with high quality code.  I am sure many will want to argue.  As an example, I will quote from Wikipedia in Russian: <br><br>  <i>Some OpenBSD developers, such as Theo de Raadt and Otto Moerbeek, have <a href="http://www.thejemreport.com/content/view/369/"><i>criticized</i></a> GCC, calling it "cumbersome, buggy, slow, and generating bad code."</i> <br><br>  I consider such statements unfounded.  Yes, it is possible that the GCC code contains many macros that make it difficult to read.  But I can‚Äôt agree with the statement about its buggy.  If GCC was buggy, nothing would work anywhere.  Just remember how many programs they compile and work successfully.  The creators of GCC do a tremendous, challenging job with great professionalism.  Thanks to them.  I am glad that I can test the work of PVS-Studio on such a high-quality project. <br><br>  For those who say that the Clang compiler code is still better, let me remind you: PVS-Studio also found errors in it: <a href="http://www.viva64.com/ru/b/0108/">1</a> , <a href="http://www.viva64.com/ru/b/0155/">2</a> . <br><br><h2>  PVS-Studio </h2><br>  I checked the GCC code using the Alpha-version of the PVS-Studio for Linux analyzer.  We plan to start issuing the Beta-version of the analyzer to mid-September 2016 to interested programmers.  You will find instructions on how to be one of the first to try the Beta-version of PVS-Studio for Linux on your project in the article " <a href="http://www.viva64.com/ru/b/0415/">PVS-Studio admits love for Linux</a> ". <br><br>  If you read this article much later than September 2016 and want to try PVS-Studio for Linux, then I invite you to the product page: <a href="http://www.viva64.com/ru/pvs-studio/">http://www.viva64.com/ru/pvs-studio/</a> <br><br><h2>  Test results </h2><br>  We got to the most interesting section, which, I think, our regular readers are looking forward to.  Consider the code sections where the analyzer found errors or extremely suspicious moments. <br><br>  Unfortunately, I can not give the compiler a complete report.  It still has too much garbage (false positives) due to the fact that the analyzer is not fully ready to meet with the Linux world.  It is necessary to do the work to reduce the number of false warnings on the standard constructions used.  I will try to explain with one simple example.  Many diagnostics should not swear expressions related to <i>assert</i> macros.  These macros are very creative and you need to teach the analyzer not to pay attention to them.  But the fact is that the <i>assert</i> macro is defined in very different ways, and the analyzer must be trained in all typical variants. <br><br>  Therefore, developers of GCC, please wait for at least Beta-version of the analyzer.  I don't want to spoil the impression with a report generated by the unfinished version. <br><br><h3>  Classic (Copy-Paste) </h3><br>  We will start with the most classic and common error that is detected using the <a href="http://www.viva64.com/ru/d/0090/">V501</a> diagnostic.  As a rule, such errors appear due to carelessness during Copy-Paste or are simply misprints made when typing a new code. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dw_val_equal_p</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dw_val_node *a, dw_val_node *b)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> dw_val_class_vms_delta: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span> (a-&gt;v.val_vms_delta.lbl1, b-&gt;v.val_vms_delta.lbl1) &amp;&amp; !<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span> (a-&gt;v.val_vms_delta.lbl1, b-&gt;v.val_vms_delta.lbl1)); .... }</code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> V501 There are identical sub-expressions '! Strcmp (a-&gt; v.val_vms_delta.lbl1, b-&gt; v.val_vms_delta.lbl1)' to the left and the right of the '&amp;&amp;' operator.  dwarf2out.c 1428 <br><br>  Quickly seeing errors is problematic and you should take a close look.  That is why the error was not detected during code reviews and refactoring. <br><br>  The <i>strcmp</i> function compares the same strings twice.  It seems to me that the second time it was necessary to compare not members of the <i>lbl1</i> class, but <i>lbl2</i> .  Then the correct code should look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span> (a-&gt;v.val_vms_delta.lbl1, b-&gt;v.val_vms_delta.lbl1) &amp;&amp; !<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span> (a-&gt;v.val_vms_delta.lbl2, b-&gt;v.val_vms_delta.lbl2));</code> </pre> <br>  I want to note that the code given in the article is slightly formatted so that it takes up little space on the X axis. In fact, the code looks like this: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/380/894/b75/380894b75227c04d5cdeee46fdbc2868.png" alt="Bad code formatting"></p><br><br>  Errors, perhaps, could have been avoided if we use the ‚Äútable‚Äù code alignment.  For example, an error would be easier to notice if you format the code like this: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c6d/172/471/c6d172471d106aef1bc5c29c0f776c7f.png" alt="Tabular formatting code"></p><br><br>  I considered this approach in more detail in the e-book ‚Äú <a href="http://www.viva64.com/ru/b/0391/">The Main Question of Programming, Refactoring, and All That</a> ‚Äù (see Chapter 13: Align the same type code with a ‚Äútable‚Äù).  I recommend everyone who cares about the quality of their code to get acquainted with the link given here. <br><br>  Let's consider another mistake that, I am sure, appeared due to Copy-Paste: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">host_detect_local_cpu</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> has_avx512vl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> has_avx512ifma = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... has_avx512dq = ebx &amp; bit_AVX512DQ; has_avx512bw = ebx &amp; bit_AVX512BW; has_avx512vl = ebx &amp; bit_AVX512VL; <span class="hljs-comment"><span class="hljs-comment">// &lt;= has_avx512vl = ebx &amp; bit_AVX512IFMA; // &lt;= .... }</span></span></code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/d/0108/">V519</a> The 'has_avx512vl' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 500, 501. driver-i386.c 501 <br><br>  The variable <i>has_avx512vl</i> twice in a row recorded various values.  This makes no sense.  I studied the code and found the variable <i>has_avx512ifma</i> .  Most likely, it should be initialized by the expression <i>ebx &amp; bit_AVX512IFMA</i> .  Then the correct code should be: <br><br><pre> <code class="cpp hljs">has_avx512vl = ebx &amp; bit_AVX512VL; has_avx512ifma = ebx &amp; bit_AVX512IFMA;</code> </pre> <br><h3>  Typo </h3><br>  I will continue the test of your attentiveness.  Look at the code and, without looking below, try to find the error. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ubsan_use_new_style_p</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">location_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> loc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loc == UNKNOWN_LOCATION) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; expanded_location xloc = expand_location (loc); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xloc.file == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span> (xloc.file, <span class="hljs-string"><span class="hljs-string">"\1"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span> || xloc.file == <span class="hljs-string"><span class="hljs-string">'\0'</span></span> || xloc.file[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\xff'</span></span> || xloc.file[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\xff'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/d/0117/">V528</a> It is odd that the pointer to 'char' type is compared with the '\ 0' value.  Probably meant: * xloc.file == '\ 0'.  ubsan.c 1472 <br><br>  Here, the programmer accidentally forgot to dereference the pointer in the <i>xloc.file == '\ 0'</i> expression.  As a result, the pointer is simply compared with 0, i.e.  with <i>null</i> .  This has no effect, since previously such a check has already been performed: <i>xloc.file == NULL</i> . <br><br>  It‚Äôs good that the programmer wrote the terminal zero as '\ 0'.  This helps to quickly understand that the code is wrong and how to fix it.  I also wrote about this in the <a href="http://www.viva64.com/ru/b/0391/">book</a> (see chapter N9: Use the literal '\ 0' for the terminal zero). <br><br>  The correct code is: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xloc.file == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span> (xloc.file, <span class="hljs-string"><span class="hljs-string">"\1"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span> || xloc.file[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\0'</span></span> || xloc.file[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\xff'</span></span> || xloc.file[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\xff'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Although, let's improve the code a little more.  I recommend formatting the expression as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( xloc.file == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span> (xloc.file, <span class="hljs-string"><span class="hljs-string">"\1"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span> || xloc.file[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\0'</span></span> || xloc.file[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\xff'</span></span> || xloc.file[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\xff'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Pay attention: now, if we make the same mistake, the chance to notice it will be slightly higher: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( xloc.file == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span> (xloc.file, <span class="hljs-string"><span class="hljs-string">"\1"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span> || xloc.file == <span class="hljs-string"><span class="hljs-string">'\0'</span></span> || xloc.file[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'\xff'</span></span> || xloc.file[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'\xff'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><h3>  Potential null pointer dereference </h3><br>  This section could also be called "the one hundred thousandth example of why macros are bad."  I really do not like macros and always urge to use them less.  Macros make it difficult to read the code, provoke errors, complicate the work of static analyzers.  As it seemed to me from a short conversation with the GCC code, its authors are very fond of macros.  I was tortured to learn what a particular macro is revealed in and perhaps that is why I missed a lot of interesting errors.  I admit, I am sometimes lazy.  But I will demonstrate a couple of errors related to macros. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">odr_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_odr_type</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tree type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> insert)</span></span></span><span class="hljs-function"> </span></span>{ .... odr_types[val-&gt;id] = <span class="hljs-number"><span class="hljs-number">0</span></span>; gcc_assert (val-&gt;derived_types.length() == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (odr_types_ptr) val-&gt;id = odr_types.length (); .... }</code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/d/0205/">V595</a> The 'odr_types_ptr' pointer was used against nullptr.  Check lines: 2135, 2139. ipa-devirt.c 2135 <br><br>  See an error here?  I think not, and the message of the analyzer does not bring clarity.  The thing is that <i>odr_types</i> is not a variable name, but a macro, declared as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> odr_types (*odr_types_ptr)</span></span></code> </pre> <br>  If you expand the macro and remove all irrelevant, we get the following code: <br><br><pre> <code class="cpp hljs">(*odr_types_ptr)[val-&gt;id] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (odr_types_ptr)</code> </pre> <br>  In the beginning, the pointer is dereferenced, and then checked.  It is difficult to say whether this will lead to trouble in practice or not.  It all depends on whether there can be a situation when the pointer will really be equal to <i>nullptr</i> .  If such a situation is impossible, then remove the extra check, which will mislead people who support the code and the code analyzer.  If the pointer can be null, then this is a serious mistake that requires even more attention and correction. <br><br>  Consider another similar case: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sd_iterator_cond</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sd_iterator_def *it_ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dep_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dep_ptr)</span></span></span><span class="hljs-function"> </span></span>{ .... it_ptr-&gt;linkp = &amp;DEPS_LIST_FIRST (<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... }</code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> V595 The 'list' pointer was used before it was verified against nullptr.  Check lines: 1627, 1629. sched-int.h 1627 <br><br>  To see the error, we again need to show the macro device: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEPS_LIST_FIRST(L) ((L)-&gt;first)</span></span></code> </pre> <br>  We open the macro and get: <br><br><pre> <code class="cpp hljs">it_ptr-&gt;linkp = &amp;((<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>)-&gt;first); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;</code> </pre> <br>  And now many will exclaim: ‚ÄúStop, stop!  There is no error.  We after all simply receive the pointer on a member of a class.  No null pointer dereference is here.  Yes, maybe the code is not accurate, but there is no error here! ‚Äù. <br><br>  It is not that simple.  This is where undefined behavior arises.  And the fact that such code can work in practice is just luck.  In fact, it is impossible to write like that.  For example, an optimizing compiler, upon seeing <i>list-&gt; first,</i> can remove an <i>if (list)</i> check.  Since we executed the <i>-&gt;</i> operator, it means that the pointer is not equal to <i>nullptr</i> .  If so, then you do not need to check the pointer. <br><br>  I wrote a whole article on this topic: " <a href="http://www.viva64.com/ru/b/0306/">Dereferencing a null pointer leads to undefined behavior</a> ."  There is just considered a similar case.  Before you argue, I ask you to carefully read this article. <br><br>  However, the considered situation is really complicated and not obvious.  I admit that I may still be wrong and there is no error here.  However, so far nobody has been able to prove it to me.  It will be interesting to hear the comments of the GCC developers if they pay attention to this article.  They must know exactly how the compiler works and whether such code should be interpreted as erroneous or not. <br><br><h3>  Using a destroyed array </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_hsa_symbol</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *f, hsa_symbol *symbol)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol-&gt;m_name) name = symbol-&gt;m_name; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">64</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span> (buf, <span class="hljs-string"><span class="hljs-string">"__%s_%i"</span></span>, hsa_seg_name (symbol-&gt;m_segment), symbol-&gt;m_name_number); name = buf; } <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span> (f, <span class="hljs-string"><span class="hljs-string">"align(%u) %s_%s %s"</span></span>, hsa_byte_alignment (symbol-&gt;m_align), hsa_seg_name(symbol-&gt;m_segment), hsa_type_name(symbol-&gt;m_type &amp; ~BRIG_TYPE_ARRAY_MASK), name); .... }</code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/d/0096/">V507</a> Pointer to local array 'buf' is stored outside.  Such a pointer will become invalid.  hsa-dump.c 704 <br><br>  The string is formed in the temporary buffer <i>buf</i> .  The address of this temporary buffer is stored in the variable <i>name</i> and is used later in the function body.  The error is that after writing the buffer to the <i>name</i> variable, this buffer will be destroyed. <br><br>  You cannot use a pointer to a destroyed buffer.  Formally, we are dealing with uncertain behavior.  In practice, this code can work quite well.  The correct work of the program is one of the options for the manifestation of uncertain behavior. <br><br>  In any case, this code contains an error and needs to be fixed.  The code can work for the reason that the compiler may find it unnecessary to use a temporary buffer for the subsequent storage of other variables or arrays.  And then, although the array created on the stack is considered to be destroyed, in fact no one can touch it, and the function will correctly perform its work.  That's just such luck at any time may end and the code that worked for 10 years, suddenly, when switching to a new version of the compiler, begins to behave in an amazing way. <br><br>  To correct the error, it is enough to declare an array <i>buf</i> in the same scope as the <i>name</i> pointer: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_hsa_symbol</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *f, hsa_symbol *symbol)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... }</code> </pre> <br><h3>  Performing the same actions, regardless of the condition </h3><br>  The analyzer has detected a section of code that I definitely cannot identify as erroneous.  However, it is extremely suspicious to perform a check, and then, regardless of its result, perform the same actions.  Of course, perhaps this is a reserve for the future and so far everything is correct, but it is clearly worth checking out this piece of code. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_through_all_blocks</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> may_peel_loop_headers)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* Case 1, threading from outside to inside the loop after we'd already threaded through the header. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((*path)[<span class="hljs-number"><span class="hljs-number">0</span></span>]-&gt;e-&gt;dest-&gt;loop_father != path-&gt;last ()-&gt;e-&gt;src-&gt;loop_father) { delete_jump_thread_path (path); e-&gt;aux = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ei_next (&amp;ei); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { delete_jump_thread_path (path); e-&gt;aux = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ei_next (&amp;ei); } .... }</code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/d/0112/">V523</a> The 'then' statement is equivalent to the 'else' statement.  tree-ssa-threadupdate.c 2596 <br><br>  If this code is erroneous, I, unfortunately, can‚Äôt guess how to fix it.  This is the case when you need to be familiar with the project to make edits. <br><br><h3>  Redundant expression of the form (A == 1 || A! = 2) </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alter_output_for_subst_insn</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rtx insn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *insn_out, *sp ; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *old_out, *new_out, *cp; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, new_len; insn_out = XTMPL (insn, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alt &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || *insn_out == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || *insn_out != <span class="hljs-string"><span class="hljs-string">'@'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> insn_out; .... }</code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/d/0194/">V590</a> Consider inspecting this expression.  The expression is misprint.  gensupport.c 1640 <br><br>  We are interested in the condition: (alt &lt;2 || * insn_out == '*' || * insn_out! = '@') <br><br>  It can be abbreviated to: (alt &lt;2 || * insn_out! = '@') <br><br>  I would venture to suggest that the <i>! =</i> Operator should be replaced with <i>==</i> .  Then the code will take a more meaningful view: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alt &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || *insn_out == <span class="hljs-string"><span class="hljs-string">'*'</span></span> || *insn_out == <span class="hljs-string"><span class="hljs-string">'@'</span></span>)</code> </pre> <br><h3>  Zeroing the wrong pointer </h3><br>  Consider a function that frees up resources: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free_original_copy_tables</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ gcc_assert (original_copy_bb_pool); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> bb_copy; bb_copy = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> bb_original; bb_copy = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> loop_copy; loop_copy = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> original_copy_bb_pool; original_copy_bb_pool = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> V519 The 'bb_copy' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 1076, 1078. cfg.c 1078 <br><br>  Pay attention to these 4 lines of code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> bb_copy; bb_copy = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> bb_original; bb_copy = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br>  Randomly double pointer <i>bb_copy</i> .  The correct option is: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> bb_copy; bb_copy = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> bb_original; bb_original = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre> <br><h3>  Assert that won't check anything </h3><br>  An incorrect condition that is an argument to the macro <i>gcc_assert</i> will not affect the correctness of the program, but will complicate the search for an error, if one occurs.  Consider the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">output_loc_operands</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dw_loc_descr_ref loc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> for_eh_or_skip)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> die_offset = get_ref_die_offset (val1-&gt;v.val_die_ref.die); .... gcc_assert (die_offset &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; die_offset &lt;= (loc-&gt;dw_loc_opc == DW_OP_call2) ? <span class="hljs-number"><span class="hljs-number">0xffff</span></span> : <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>); .... }</code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> <a href="http://www.viva64.com/ru/d/0091/">V502</a> Perhaps the '?:' Operator works in a different way than it was expected.  The '?:' Operator has a lower limit than the '&lt;=' operator.  dwarf2out.c 2053 <br><br>  The priority of the ternary operator <i>?:</i> Lower than that of the comparison operator <i>&lt;=</i> .  This means that we are dealing with a condition of the form: <br><br><pre> <code class="cpp hljs">die_offset &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ((die_offset &lt;= (loc-&gt;dw_loc_opc == DW_OP_call2)) ? <span class="hljs-number"><span class="hljs-number">0xffff</span></span> : <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>);</code> </pre> <br>  Thus, the second operand of the <i>&amp;&amp;</i> operator can take the value <i>0xffff</i> or <i>0xffffffff</i> .  Both of these values ‚Äã‚Äãindicate true, so the expression can be simplified to: <br><br><pre> <code class="cpp hljs">(die_offset &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  This is clearly not what the programmer intended.  To remedy this, add a pair of parentheses: <br><br><pre> <code class="cpp hljs">gcc_assert (die_offset &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; die_offset &lt;= ((loc-&gt;dw_loc_opc == DW_OP_call2) ? <span class="hljs-number"><span class="hljs-number">0xffff</span></span> : <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>));</code> </pre> <br>  Operator <i>?:</i> Very cunning and it is better not to use it in complex expressions.  It is very easy to make a mistake.  We have <a href="http://www.viva64.com/ru/examples/V502/">collected a</a> large number of examples of such errors found by the PVS-Studio analyzer in various open source projects.  More information about the operator <i>?:</i> I wrote in the already mentioned <a href="http://www.viva64.com/ru/b/0391/">book</a> (see Chapter N4: Fear the operator?: And enclose it in parentheses). <br><br><h3>  It seems to have forgotten about the "cost" </h3><br>  The <i>alg_hash_entry</i> structure <i>is</i> declared as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alg_hash_entry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> HOST_WIDE_INT t; machine_mode mode; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> alg_code alg; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mult_cost</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cost</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> speed; };</code> </pre> <br>  In the <i>synth_mult</i> function <i>, the</i> programmer decided to check if this is the object he needs.  For this, it needs to compare the structure fields.  However, it seems there is a mistake in this place: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">synth_mult</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alg_hash_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_ptr</span></span></span><span class="hljs-class">;</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entry_ptr-&gt;t == t &amp;&amp; entry_ptr-&gt;mode == mode &amp;&amp; entry_ptr-&gt;mode == mode &amp;&amp; entry_ptr-&gt;speed == speed &amp;&amp; entry_ptr-&gt;alg != alg_unknown) { .... }</code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> V501 There are identical sub-expressions' entry_ptr-&gt; mode == mode 'to the left and' operator.  expmed.c 2573 <br><br>  The <i>mode is</i> checked twice in a row, but there is no <i>cost</i> check.  Perhaps one of the comparisons you just need to remove, and perhaps you need to compare the <i>cost</i> .  It's hard for me to judge, but the code is clearly worth fixing. <br><br><h3>  Duplicate assignments </h3><br>  The following parts of the code, in my opinion, are not dangerous and it seems that duplicate assignment can be simply deleted. <br><br>  <b>Case N1</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">type_p </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_structure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> typekind kind)</span></span></span><span class="hljs-function"> </span></span>{ .... structures = s; <span class="hljs-comment"><span class="hljs-comment">// &lt;= s-&gt;kind = kind; s-&gt;ustag = name; structures = s; // &lt;= return s; }</span></span></code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> V519 The 'structures' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 842, 845. gengtype.c 845 <br><br>  <b>Case N2</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> rtx </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ix86_expand_sse_pcmpistr</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, nargs; .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> V8DI_FTYPE_V8DI_V8DI_V8DI_INT_UQI: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> V16SI_FTYPE_V16SI_V16SI_V16SI_INT_UHI: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> V2DF_FTYPE_V2DF_V2DF_V2DI_INT_UQI: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> V4SF_FTYPE_V4SF_V4SF_V4SI_INT_UQI: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> V8SF_FTYPE_V8SF_V8SF_V8SI_INT_UQI: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> V8SI_FTYPE_V8SI_V8SI_V8SI_INT_UQI: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> V4DF_FTYPE_V4DF_V4DF_V4DI_INT_UQI: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> V4DI_FTYPE_V4DI_V4DI_V4DI_INT_UQI: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> V4SI_FTYPE_V4SI_V4SI_V4SI_INT_UQI: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> V2DI_FTYPE_V2DI_V2DI_V2DI_INT_UQI: nargs = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= nargs = 5; // &lt;= mask_pos = 1; nargs_constant = 1; break; .... }</span></span></code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> V519 The 'nargs' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 39951, 39952. i386.c 39952 <br><br>  <b>Case N3</b> <br><br>  The latter case is more strange than the rest.  Perhaps there is some kind of mistake.  Variable <i>steptype</i> value is assigned 2 or 3 times.  This is suspicious. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cand_value_at</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ aff_tree step, delta, nit; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iv</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iv</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cand</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iv</span></span></span><span class="hljs-class">;</span></span> tree type = TREE_TYPE (iv-&gt;base); tree steptype = type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= if (POINTER_TYPE_P (type)) steptype = sizetype; // &lt;= steptype = unsigned_type_for (type); // &lt;= .... }</span></span></code> </pre> <br>  <b>PVS-Studio analyzer warning:</b> V519 The 'steptype' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 5173, 5174. tree-ssa-loop-ivopts.c 5174 <br><br><h2>  Conclusion </h2><br>  I'm glad I wrote this article.  Now I have something to respond to comments like ‚ÄúPVS-Studio is not needed, since GCC gives all the same warnings‚Äù.  As you can see, PVS-Studio is a very powerful tool and is superior in diagnostic capabilities to GCC.  I do not deny that excellent diagnostics are implemented in GCC.  This compiler, if properly configured, does reveal many problems in the code.  But PVS-Studio is a specialized and rapidly developing tool, which means it will always be better to identify errors in the code than compilers do. <br><br>  I invite you to get acquainted with the checks of other well-known open source projects by visiting <a href="http://www.viva64.com/ru/inspections/">this section of</a> our site.  And also, those who use Twitter, follow me <a href="https://twitter.com/Code_Analysis">@Code_Analysis</a> .  I regularly publish links to interesting articles on programming in C and C ++, as well as talking about new achievements of our analyzer. <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0425/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey karpov.  <a href="http://www.viva64.com/en/b/0425/">Bugs found in GCC with the help of PVS-Studio</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. </div></div></div><p>Source: <a href="https://habr.com/ru/post/308946/">https://habr.com/ru/post/308946/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308934/index.html">New practical courses on JavaScript and ES6</a></li>
<li><a href="../308936/index.html">UDL support</a></li>
<li><a href="../308938/index.html">Errors of questionnaires. Error 2: questionnaire wording. 13 cases of misunderstanding and manipulation in the survey (part 1)</a></li>
<li><a href="../308940/index.html">iKnow Review Analyzer (iKRA)</a></li>
<li><a href="../308944/index.html">Check the speed of the promis</a></li>
<li><a href="../308948/index.html">How to use UrlManager to set up routing and create ‚Äúfriendly‚Äù URLs</a></li>
<li><a href="../308950/index.html">Half-HA cluster PostgreSQL on Windows 2012</a></li>
<li><a href="../308952/index.html">Porting a portfolio from Brainstorage to Freelansim</a></li>
<li><a href="../308954/index.html">How-to: interactive writing guide</a></li>
<li><a href="../308956/index.html">Microsoft Azure StorSimple: easy access to hybrid cloud. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>