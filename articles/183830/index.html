<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Argument numbering of the variadic template, or what the modest pair hides</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mastering the C ++ 11 standard is a process that cannot be abrupt. Studying a new language construct requires not only memorizing the syntax, but also...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Argument numbering of the variadic template, or what the modest pair hides</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="http://geekshowblog.org/wp-content/uploads/2013/03/c-11.png"></div><br><br>  Mastering the C ++ 11 standard is a process that cannot be abrupt.  Studying a new language construct requires not only memorizing the syntax, but also understanding its purpose and typical methods of application.  An important tool in training is a prettier STL, which can often open its eyes to the existence of very interesting and necessary features.  And knowing that some thing is possible and implemented in the STL, getting to the method of implementation is not difficult. <br><br>  One of the curious examples associated with the updated and improved class <i>pair</i> , and will be discussed in the article. <br>  The new standard has added such a seemingly simple thing as a <a href="http://en.cppreference.com/w/cpp/utility/pair">pair</a> , convenience and versatility.  If earlier, the types that were part of the pair were subject to rather severe requirements, now you can make almost anything into a pair.  In particular, the restriction on the design of such types has been removed.  Now it is not necessary to use copy or even move operations, it is possible to create a pair by directly constructing members (such an operation is called emplace, "placement", and in C ++ 11 it is supported by STL containers), using non-trivial constructors. <br><a name="habracut"></a><br>  ... And here, as they say, more.  How can we call the <i>pair</i> constructor and pass it two sets of arguments, so that he understands which arguments to give to which constructor?  Among the usual designers associated with copying or moving members or the whole <i>pair</i> , we see this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args2</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">piecewise_construct_t</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Args1...&gt; first_args, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;Args2...&gt; second_args );</code> </pre> <br><br>  <i>piecewise_construct_t</i> is just an empty type that will help us signal that we want to create a <i>pair piece</i> by piece, passing arguments to the <i>first</i> and <i>second</i> constructors.  In this we will be helped by a constant of this type called <i>piecewise_construct</i> .  Well, then we specify two sets of arguments, wrapping them in tuples ( <a href="http://en.cppreference.com/w/cpp/utility/tuple">tuple</a> , the <a href="http://en.cppreference.com/w/cpp/utility/tuple/make_tuple">make_tuple</a> function will help in their creation).  For those readers who have forgotten or do not know what it is, I recall: a tuple is a collection of an arbitrary number of values ‚Äã‚Äãof an arbitrary type.  In C ++, with its strict type control, tuples are implemented using templates with a variable number of arguments ( <a href="http://habrahabr.ru/post/101430/">variadic template</a> ). <br><br>  Well, the problem seems to have been successfully solved: the tuples act as ‚Äúpackages‚Äù of arguments for the <i>first</i> and <i>second</i> constructors.  At this stage, a programmer who is familiar with the standard's novelties may ask: ‚ÄúBy the way, how do you unpack data from tuples?‚Äù The documentation gives us the only way: the <a href="http://en.cppreference.com/w/cpp/utility/tuple/get">get</a> function, which specifies the element index in the tuple as a template parameter. <br><br>  How do our arguments get into the constructor?  Retrieving data from a tuple one at a time is easy.  It's easy to retrieve them recursively.  But how to fit all the values ‚Äã‚Äãin the function call (in this case, the constructor)? <br>  Here is useful unpacking variadic-templates.  However, you need to unpack not the list of <i>tuple</i> types, but the list of indices.  Which first you need to make more. <br><br>  Let's start with the main thing: let's add a new index to the existing list.  Obviously, if the numbering starts from 0, then the new index will be equal to the size of the input list.  We need a structure that we parameterize with a list of indices: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indices&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackIndices</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//     Indices  ,  sizeof ... (Indices) };</span></span></code> </pre> <br><br>  The result, which is a list of integer compile-time constants and at the same time template arguments, cannot be stored by itself, but the type parameterized by these arguments can be stored.  And we just have a suitable candidate for this type of role: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indices&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackIndices</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> PackIndices&lt;Indices... , <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> ... (Indices)&gt; next; };</code> </pre> <br><br>  Now we will make a recursive generator that creates a list of indices of length <b>N.</b>  This is done by simply adding the last index to the list with a length of <b>N-1</b> : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePackIndices</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CreatePackIndices&lt;N<span class="hljs-number"><span class="hljs-number">-1</span></span>&gt;::type::next type; };</code> </pre> <br><br>  ... and stop the recursion: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePackIndices</span></span></span><span class="hljs-class">&lt;0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> PackIndices&lt;&gt; type; };</code> </pre> <br><br>  Having gotten a way to create a list of indexes, let's unpack the tuple into the constructor's parameters.  For simplicity, consider first the construction of only one object, <i>first</i> . <br><br>  Using the <i>args</i> tuple and the <i>Indices</i> index list, unpacking should look basically like this: <br><br><pre> <code class="hljs lisp">first(<span class="hljs-name"><span class="hljs-name">std</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:get&lt;Indices&gt;</span></span>(<span class="hljs-name"><span class="hljs-name">args</span></span>)...)</code> </pre> <br><br>  To access the <i>Indices</i> , it is necessary that the context in which we decompress (that is, the <i>pair</i> constructor) is parameterized by this list.  This means that we will need to create a second template constructor with all the necessary parameters.  Here, by the way, there will be another new C ++ 11, delegation of constructors, which allows you to call an alternative constructor in the initialization list.  And since we still make calls to functions, we will use automatic output of the type of the arguments: pass an anonymous <i>PackIndices</i> object to the auxiliary constructor.  As a result, we get such a one-legged <i>pair</i> : <br><br><pre> <code class="hljs ruby">template&lt;typename T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> { // ,   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class">&lt;typename ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgTypes</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Indices</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::tuple</span></span></span><span class="hljs-class">&lt;ArgTypes...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_args</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackIndices</span></span></span><span class="hljs-class">&lt;Indices...&gt;): </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::get</span></span></span><span class="hljs-class">&lt;Indices&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_args</span></span></span><span class="hljs-class">)...) {} </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class">: // ,   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class">&lt;typename ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgTypes</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::piecewise_construct_t</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::tuple</span></span></span><span class="hljs-class">&lt;ArgTypes...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_args</span></span></span><span class="hljs-class">): </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_args</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePackIndices</span></span></span><span class="hljs-class">&lt;sizeof ... (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgTypes</span></span></span><span class="hljs-class">)&gt;::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">()) {} </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">;</span></span> };</code> </pre> <br><br>  This is the time to recall <a href="http://thbecker.net/articles/rvalue_references/section_07.html">perfect forwarding</a> - the mechanism necessary for correctly passing arguments to nested calls without changing their types.  The updated STL provides a <a href="http://en.cppreference.com/w/cpp/utility/forward">forward</a> function, which will have to be applied to each argument and, in addition, parameterized by the type of the argument.  Fortunately, the creators of the new standard provided for such a clever thing as the <i><u>simultaneous</u></i> unpacking of several sets of arguments.  Since <i>ArgTypes</i> and <i>Indices</i> obviously have the same length, you can safely add the call <i>forward</i> to the decompression pattern: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... ArgTypes, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> ... Indices&gt; pair(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;ArgTypes...&gt;&amp; first_args, PackIndices&lt;Indices...&gt;): first(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;ArgTypes&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::get&lt;Indices&gt;(first_args))...) {}</code> </pre> <br><br>  After going all the way from the values ‚Äã‚Äãin <i>make_tuple</i> to the parameters of the constructor, put the <i>pair</i> on both legs: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs ruby">template&lt;typename T1, typename T2&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class"> { // ,   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class">&lt;typename ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgTypes1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Indices1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgTypes2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Indices2</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::tuple</span></span></span><span class="hljs-class">&lt;ArgTypes1...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_args</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::tuple</span></span></span><span class="hljs-class">&lt;ArgTypes2...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second_args</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackIndices</span></span></span><span class="hljs-class">&lt;Indices1...&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PackIndices</span></span></span><span class="hljs-class">&lt;Indices2...&gt;): </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::forward</span></span></span><span class="hljs-class">&lt;ArgTypes1&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::get</span></span></span><span class="hljs-class">&lt;Indices1&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_args</span></span></span><span class="hljs-class">))...), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::forward</span></span></span><span class="hljs-class">&lt;ArgTypes2&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::get</span></span></span><span class="hljs-class">&lt;Indices2&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second_args</span></span></span><span class="hljs-class">))...) {} </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class">: // ,   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class">&lt;typename ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgTypes1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgTypes2</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::piecewise_construct_t</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::tuple</span></span></span><span class="hljs-class">&lt;ArgTypes1...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_args</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::tuple</span></span></span><span class="hljs-class">&lt;ArgTypes2...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second_args</span></span></span><span class="hljs-class">): </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first_args</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">second_args</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePackIndices</span></span></span><span class="hljs-class">&lt;sizeof ... (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgTypes1</span></span></span><span class="hljs-class">)&gt;::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">(), </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreatePackIndices</span></span></span><span class="hljs-class">&lt;sizeof ... (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgTypes2</span></span></span><span class="hljs-class">)&gt;::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class">()) {} </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">;</span></span> T2 second; };</code> </pre> </div></div><br><br>  Of course, this technique is useful not only for creating a handicraft and cycling <i>pair</i> .  So, a programmer dealing with <a href="http://www.lua.org/">stack-based virtual machines</a> will probably come to mind for functions.  Undoubtedly, there are applications in other areas. </div><p>Source: <a href="https://habr.com/ru/post/183830/">https://habr.com/ru/post/183830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../183818/index.html">TypeScript 0.9 released</a></li>
<li><a href="../183820/index.html">Habrakamp # 7 about freelance and freelancers</a></li>
<li><a href="../183824/index.html">GitRec: Personal GitHub Recommendations</a></li>
<li><a href="../183826/index.html">Awesomium for C ++</a></li>
<li><a href="../183828/index.html">How we created a cloud PBX Sipuni.com</a></li>
<li><a href="../183832/index.html">NETMAP (by Luigi Rizzo). Simple and convenient opensource framework for processing traffic at speeds of 10Gbit / s or 14 Mpps</a></li>
<li><a href="../183834/index.html">Cache in multiprocessor systems. Cache coherence MESI protocol</a></li>
<li><a href="../183836/index.html">Integration of mobile application design. Part 1: Android</a></li>
<li><a href="../183838/index.html">What would happen if Hemingway wrote in JavaScript</a></li>
<li><a href="../183842/index.html">Call Center from birth to death</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>