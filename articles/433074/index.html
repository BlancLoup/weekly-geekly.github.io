<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Switching to Kotlin in the Android project: Tips and Tricks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Author: Sergey Eshin, Strong Middle Android Developer, DataArt 

 More than a year and a half has passed since Google announced Kotlin‚Äôs official supp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Switching to Kotlin in the Android project: Tips and Tricks</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ss/no/sd/ssnosdopahysny9zaa0gevj_u54.jpeg"><br>  <i>Author: Sergey Eshin, Strong Middle Android Developer, DataArt</i> <br><br>  More than a year and a half has passed since Google announced Kotlin‚Äôs official support for Android, while the most experienced developers began experimenting with it in their combat and not-so-many projects more than three years ago. <br><br>  A new language was warmly received in the Android community, and the overwhelming part of new projects on Android starts with Kotlin on board.  It is also important that Kotlin is compiled into JVM bytecode, therefore, it is fully compatible with Java.  So, in existing Android projects written in Java, there is also the possibility (moreover, the need) to use all the features of Kotlin, thanks to which he gained so many fans. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article I will talk about the experience of migrating an Android application from Java to Kotlin, the difficulties that had to be overcome in the process, and explain why all this was not in vain.  The article is mostly designed for Android developers who are just starting to learn Kotlin, and besides personal experience, relies on materials from other members of the community. <a name="habracut"></a><br><br><h2>  Why Kotlin? </h2><br>  I will briefly describe the features of Kotlin, because of which I switched to it in the project, leaving the ‚Äúcozy and painfully familiar‚Äù world of Java: <br><br><ol><li>  Full Java Compatibility </li><li>  Null safety </li><li>  Type inference </li><li>  Extension methods </li><li>  Functions as first class and lambda objects </li><li>  Generics </li><li>  Coroutines </li><li>  Absence checked exception </li></ol><br><h2>  DISCO application </h2><br>  This is a small application for the exchange of discount cards, consisting of 10 screens.  On his example, we consider the migration. <br><br><h3>  Architecture in brief </h3><br>  The application uses MVVM-architecture with Google Architecture Components under the hood: ViewModel, LiveData, Room. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oe/n1/e4/oen1e4fepl7q4ff8zdth-jxwjlk.png"></div><br>  Also, according to the principles of Clean Architecture from Uncle Bob, I selected 3 layers in the application: data, domain and presentation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/em/o4/rz/emo4rzbpvpeadmnhzucuyhhtzpq.png"></div><br>  Where to begin?  So, we imagine the main features of Kotlin and have a minimal idea of ‚Äã‚Äãthe project that needs to be migrated.  There is a natural question "where to start?". <br><br>  On the Android <a href="https://developer.android.com/kotlin/get-started">Getting Started with Kotlin</a> page, it‚Äôs written that if you want to transfer an existing application to Kotlin, you just have to start writing unit tests.  When you get a little experience with this language, write new code to Kotlin, you will just have to convert existing Java code. <br><br>  But there is one "but."  Indeed, simple conversion usually (although not always) allows you to get a working code on Kotlin, but its idiomaticity leaves much to be desired.  Then I will tell you how to eliminate this gap due to the mentioned (and not only) features of the Kotlin language. <br><br><h2>  Layer Migration </h2><br>  Since the application is already divided into layers, it makes sense to perform the migration by layers, starting with the top one. <br><br>  The order of the layers during the migration is shown in the following picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kp/oq/k_/kpoqk_8rpc0xg9qstzecyrlp_is.png"></div><br>  It is no coincidence that we started the migration from the upper layer.  We thereby save ourselves from using Kotlin-code in Java-code.  On the contrary, we make the upper layer Kotlin code use the lower layer Java classes.  The fact is that Kotlin was originally designed taking into account the need to interact with Java.  Existing Java code can be invoked from Kotlin in a natural way.  We can easily inherit from existing Java classes, access them and apply Java annotations to Kotlin classes and methods.  Kotlin code can also be used in Java without any problems, but this often requires additional efforts, such as adding JVM annotations.  And why do extra conversions in Java code, if in the end it will still be rewritten to Kotlin? <br><br>  For example, let's look at the generation of overloads. <br><br>  Usually, if you write a Kotlin function with default parameter values, it will be visible in Java only as a complete signature with all parameters.  If you want to provide multiple overloads to Java calls, you can use the @JvmOverloads annotation: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JvmOverloads</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constructor</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Double</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-meta"><span class="hljs-meta">@JvmOverloads</span></span> <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: String, b: Int = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, c: String = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"abc"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>  For each parameter with a default value, this will create one additional overload, which has this parameter and all parameters to its right in the remote parameter list.  In this example, the following will be created: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Constructors: Foo(int x, double y) Foo(int x) // Methods void f(String a, int b, String c) { } void f(String a, int b) { } void f(String a) { }</span></span></code> </pre> <br>  There are many examples of using JVM annotations for Kotlin to work correctly.  <a href="https://kotlinlang.ru/docs/reference/java-to-kotlin-interop.html">This documentation page</a> details the topic of calling Kotlin from Java. <br><br>  Now we describe the process of migration layer by layer. <br><br><h3>  Presentation Layer </h3><br>  This is a user interface layer that contains screens with views and a ViewModel, in turn, containing properties in the form of LiveData with data from the model.  Next, we look at the techniques and tools that have proven useful when migrating this layer of the application. <br><br><h4>  1. Kapt annotation processor </h4><br>  As with any MVVM, View binds to the ViewModel properties through databinding.  In the case of Android, we are dealing with Android Databind Library, which uses annotation processing.  So, Kotlin has <b>its own annotation processor</b> , and if you do not make changes to the appropriate build.gradle file, the project will stop building.  Therefore, we will make these changes: <br><br><pre> <code class="java hljs">apply plugin: <span class="hljs-string"><span class="hljs-string">'kotlin-kapt'</span></span> android { dataBinding { enabled = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } } dependencies { <span class="hljs-function"><span class="hljs-function">api </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fileTree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dir: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'libs'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, include: [</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'*.jar'</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">///‚Ä¶ kapt "com.android.databinding:compiler:$android_plugin_version" }</span></span></span></span></code> </pre><br>  It is important to remember that you need to completely replace all occurrences of the annotationProcessor configuration in your build.gradle with kapt. <br><br>  For example, if you are using Dagger or Room libraries in a project, which also use the annotation processor for code generation under the hood, you need to specify kapt as the annotation processor. <br><br><h4>  2. Inline functions </h4><br>  Marking a function as inline, we ask the compiler to place it at the place of use.  The body of the function becomes embedded, in other words, it replaces the usual use of the function.  Due to this, we can bypass the type erasure restriction, i.e., type erasure.  When using inline-functions, we can get the type (class) in runtime. <br><br>  This feature of Kotlin was used in my code to ‚Äúextract‚Äù the class of the launched Activity. <br><br><pre> <code class="scala hljs">inline fun &lt;reified <span class="hljs-type"><span class="hljs-type">T</span></span> : <span class="hljs-type"><span class="hljs-type">Activity</span></span>&gt; <span class="hljs-type"><span class="hljs-type">Context</span></span>?.startActivity(args: <span class="hljs-type"><span class="hljs-type">Bundle</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>?.let { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intent = <span class="hljs-type"><span class="hljs-type">Intent</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">intent</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">putExtras</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">args</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">it</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">startActivity</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">intent</span></span></span><span class="hljs-class">) } }</span></span></code> </pre> <br>  reified - the designation of the materialized type. <br><br>  In the example described above, we also touched upon such a feature of the Kotlin language as Extensions. <br><br><h4>  3. Extensions </h4><br>  They are extensions.  Utility methods were imposed in extensions, which made it possible to avoid bloated and monstrous class utilities. <br><br>  I will give an example of the extensions involved in the application: <br><br><pre> <code class="scala hljs">fun <span class="hljs-type"><span class="hljs-type">Context</span></span>.inflate(res: <span class="hljs-type"><span class="hljs-type">Int</span></span>, parent: <span class="hljs-type"><span class="hljs-type">ViewGroup</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>): <span class="hljs-type"><span class="hljs-type">View</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">LayoutInflater</span></span>.from(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).inflate(res, parent, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } fun &lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; <span class="hljs-type"><span class="hljs-type">Collection</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;?.isNotNullOrEmpty(): <span class="hljs-type"><span class="hljs-type">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; isNotEmpty(); } fun <span class="hljs-type"><span class="hljs-type">Fragment</span></span>.hideKeyboard() { view?.let { hideKeyboard(activity, it.windowToken) } }</code> </pre> <br>  Kotlin developers have thought of useful extensions for Android in advance by offering their Kotlin Android Extensions plugin.  Among the features that it offers, you can highlight View binding and support for Parcelable.  Detailed information about the capabilities of this plugin can be found <a href="https://kotlinlang.org/docs/tutorials/android-plugin.html">here</a> . <br><br><h4>  4. Lambda functions and higher order functions </h4><br>  With the help of lambda-functions in Android-code, you can get rid of clumsy ClickListener and callback, which were implemented in Java through self-written interfaces. <br><br>  An example of using lambda instead of onClickListener: <br><br><pre> <code class="java hljs">button.setOnClickListener({ doSomething() })</code> </pre> <br>  Lambda is also used in higher-order functions, for example, for functions for working with collections. <br><br>  Take for example the <b>map</b> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transform: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): List&lt;R&gt; {...}</code> </pre> <br>  In my code there is a place where you need to ‚Äúwrap‚Äù the id of the cards for their subsequent removal. <br><br>  Using the lambda expression passed to the map, I get the required id array: <br><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ids = cards.map { it.id }.toIntArray() cardDao.deleteCardsByIds(ids)</code> </pre> <br>  Please note that parentheses can be omitted at all when calling a function, if lambda is the only argument, and the keyword it is the implicit name of the only parameter. <br><br><h4>  5. Platform Types </h4><br>  You will inevitably have to work with SDKs written in Java (including, in fact, the Android SDK).  So, you should always stay alert with such a feature of Kotlin and Java Interop as platform types. <br><br>  Platform type is a type for which Kotlin cannot find null validity information.  The fact is that by default the Java code does not contain information about the validity of null, and the <a href="https://habr.com/ru/users/notnull/" class="user_link">NotNull</a> and @ Nullable annotations are not always used.  When the corresponding annotation is missing in Java, the type becomes platform.  You can work with it as with a type that allows null, and as with a type that does not allow null. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/r_/cu/zwr_cuwc3ajqxcsezq1b0zqcwyw.png"></div><br>  This means that just like in Java, the developer is solely responsible for operations with this type.  The compiler does not add a runtime check to null and will allow you to do everything. <br><br>  In the following example, we override onActivityResult in our Activity: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(requestCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, resultCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Intent</span></span></span></span><span class="hljs-function"><span class="hljs-params">{ </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">super</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">onActivityResult</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">requestCode</span></span></span></span><span class="hljs-function"><span class="hljs-params">, resultCode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">data</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> randomString = <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>.getStringExtra(<span class="hljs-string"><span class="hljs-string">"some_string"</span></span>) }</code> </pre> <br>  In this case, data is a platform type that can contain null.  However, from the point of view of the Kotlin code, data cannot be null under any circumstances, and regardless of whether you specify the type of Intent as nullable, you will receive neither a warning nor an error from the compiler, since both signature variants are valid .  But since the receipt of non-empty data is not guaranteed, since in cases with the SDK you cannot control this, obtaining null in this case will lead to NPE. <br><br>  Also, as an example, you can list the following places of possible occurrence of platform types: <br><br><ol><li>  Service.onStartCommand (), where the Intent can be null. </li><li>  BroadcastReceiver.onReceive (). </li><li>  Activity.onCreate (), Fragment.onViewCreate () and other similar methods. </li></ol><br>  Moreover, it happens that the parameters of the method are annotated, but for some reason the studio loses its Nullability when generating override. <br><br><h3>  Domain layer </h3><br>  This layer includes all business logic; it is responsible for the interaction between the data layer and the presentation layer.  The key role here is played by the Repository.  In the Repository, we perform the necessary manipulations with data, both with server and local.  To the top, in the Presentation layer, we give only the Repository interface method, which hides all the complexity of actions with data. <br><br>  As mentioned above, RxJava was used for implementation. <br><br><h4>  1. RxJava </h4><br>  Kotlin is fully compatible with RxJava and more concise in conjunction with it than Java.  However, here I had to face one unpleasant problem.  It sounds like this: if you pass lambda as a parameter of the <b>andThen</b> method, this lambda will not be executed! <br><br>  To verify this, it is enough to write a simple test: <br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Completable</span></span> .fromCallable { cardRepository.uploadDataToServer() } .andThen { cardRepository.markLocalDataAsSynced() } .subscribe()</code> </pre> <br>  Content <b>andThen</b> fails.  This is the case with most operators (such as <b>flatMap</b> , <b>defer</b> , <b>fromAction,</b> and many others) as arguments that are really lambda expected.  And with such an entry with <b>andThen</b> <b>Completable / Observable / SingleSource is expected</b> .  The problem is solved using ordinary parentheses () instead of curly {}. <br><br>  This problem is described in detail in the article <a href="https://android.jlelse.eu/kotlin-and-rx2-how-i-wasted-5-hours-because-of-wrong-brackets-581021717774">‚ÄúKotlin and Rx2.</a>  <a href="https://android.jlelse.eu/kotlin-and-rx2-how-i-wasted-5-hours-because-of-wrong-brackets-581021717774">How I was 5 hours because of wrong brackets</a> . <a href="https://android.jlelse.eu/kotlin-and-rx2-how-i-wasted-5-hours-because-of-wrong-brackets-581021717774">‚Äù</a> <br><br><h4>  2. Destructuring </h4><br>  We will also touch upon such an interesting Kotlin syntax as destructuring or <i>destructuring assignment</i> .  It allows you to assign an object to several variables at once, breaking it apart. <br><br>  Imagine that we have a method in the API that returns several entities at once: <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/foo/api/sync"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBrandsAndCards</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Single&lt;BrandAndCardResponse&gt; <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BrandAndCardResponse</span></span></span></span>(<span class="hljs-meta"><span class="hljs-meta">@SerializedName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cards"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cards: List&lt;Card&gt;?, <span class="hljs-meta"><span class="hljs-meta">@SerializedName(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"brands"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brands: List&lt;Brand&gt;?)</code> </pre><br>  A compact way to return the result from this method is destructuring, as shown in the following example: <br><br><pre> <code class="scala hljs">syncRepository.getBrandsAndCards() .flatMapCompletable {it-&gt; <span class="hljs-type"><span class="hljs-type">Completable</span></span>.fromAction{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (cards, brands) = it syncCards(cards) syncBrands(brands) } } }</code> </pre> <br>  It is worth mentioning that multi-declarations are based on a convention: the classes that are supposed to be structured must contain the componentN () functions, where N is the corresponding number of the component being a member of the class.  That is, the example above is translated into the following code: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cards = it.component1() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brands = it.component2()</code> </pre> <br>  In our example, a data class is used that automatically declares the componentN () function.  Therefore, multi-declarations work with it out of the box. <br><br>  In more detail we will talk about data-class in the following part devoted to the Data layer. <br><br><h3>  Data layer </h3><br>  This layer includes the POJO for data from the server and the base, interfaces for working with local data and data received from the server. <br><br>  To work with local data, Room was used, providing us with a convenient wrapper for working with the SQLite database. <br><br>  The first goal for migration, which suggests itself, is POJOs, which in standard Java code are three-dimensional classes with many fields and corresponding get / set methods.  You can make POJOs more concise with the help of Data classes.  One line of code will be enough to describe an entity with several fields: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Card</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber:String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> brandId:String,<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> barCode:String)</code> </pre><br>  In addition to brevity, we get: <br><br><ul><li>  Overridden methods <b>equals ()</b> , <b>hashCode ()</b> and <b>toString ()</b> under the hood.  Generating equals over all properties of the data class is extremely convenient when using DiffUtil in an adapter that generates views for RecyclerView.  The fact is that DiffUtil compares two data sets, two lists: the old and the new, it finds out what changes have occurred, and with the help of notify-methods it optimally updates the adapter.  And as a rule, list items are compared using equals. <br><br>  Thus, after adding a new field to a class, we don‚Äôt need to add it to equals as well so that DiffUtil takes into account a new field. </li><li>  Immmtable class </li><li>  Support for defaults, which can be replaced by using the Builder pattern. <br><br>  Example: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Card</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> = <span class="hljs-number"><span class="hljs-number">0L</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cardNumber: String=<span class="hljs-string"><span class="hljs-string">"99"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> barcode: String = <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> brandId: String=<span class="hljs-string"><span class="hljs-string">"1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newCard = Card(id =<span class="hljs-number"><span class="hljs-number">1L</span></span>,cardNumber = <span class="hljs-string"><span class="hljs-string">"123"</span></span>)</code> </pre> </li></ul><br>  Another good news: when you configure kapt (as described above), the Data classes work fine with Room annotations, which allows you to convert all database entities into Data classes.  Also Room supports nullable properties.  True, Room does not yet support the default values ‚Äã‚Äãfrom Kotlin, but this is already the corresponding bug. <br><br><h2>  findings </h2><br>  We have considered only a few pitfalls that may arise during the migration process from Java to Kotlin.  It is important that, although problems arise, especially with a lack of theoretical knowledge or practical experience, they are all solvable. <br><br>  However, the pleasure of writing a short, expressive and secure code on Kotlin will more than pay for all the difficulties that arise in the transition.  I can say with confidence that the example of the DISCO project certainly confirms this. <br><br><h3>  Books, useful links, resources </h3><br><ol><li>  The theoretical foundation of knowledge of the language will lay the book <a href="https://www.manning.com/books/kotlin-in-action">Kotlin in Action</a> from the creators of the language Svetlana Isakova and Dmitry Zhemerov. <br><br>  Conciseness, informative, wide coverage of topics, focus on Java-developers and the availability of a version in Russian make it the best possible tool at the start of language learning.  I started it from her. </li><li>  <a href="https://developer.android.com/kotlin/resources">Sources</a> on Kotlin from developer.android. </li><li>  <a href="https://kotlinlang.ru/">Kotlin Guide in Russian</a> </li><li>  <a href="https://dou.ua/lenta/articles/moving-to-kotlin/">Great article by</a> Konstantin Mikhailovsky, an Android developer from Genesis, about the experience of switching to Kotlin. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/433074/">https://habr.com/ru/post/433074/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Compare CCTV Cameras</a></li>
<li><a href="../433064/index.html">Incident management: ‚Äúgive away cannot be left‚Äù or the art of placing commas</a></li>
<li><a href="../433066/index.html">HighLoad Cup # 2. Championship for backend-developers back in the ranks</a></li>
<li><a href="../433070/index.html">How to distinguish shampoo from champignons, and skewers from champagne ... Elasticsearch - search for goods in store databases</a></li>
<li><a href="../433072/index.html">How to hacked the copy protection console Sega Dreamcast</a></li>
<li><a href="../433076/index.html">How we made our Android Gallery library to view media content</a></li>
<li><a href="../433078/index.html">We write trading robots using the StockSharp graphic framework. Part 2</a></li>
<li><a href="../433080/index.html">Pocket OLAP in Javascript and IndexedDB Performance</a></li>
<li><a href="../433082/index.html">Bleeding someone else's accounts has become a criminal offense in South Korea</a></li>
<li><a href="../433084/index.html">Open lesson "Feature Engineering on the example of the classic dataset of the Titanic"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>