<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LCD matrix management F-51543NFU-LW-ADN / PWB51543C-2-V0 (from tape library)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello again, Habr! Having made a translation of an article on managing an LCD module with a driver, but without my own video RAM, I decided to transla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LCD matrix management F-51543NFU-LW-ADN / PWB51543C-2-V0 (from tape library)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/yz/yf/la/yzyflade5gq71l7xiakjzym4utg.jpeg"><br><br>  Hello again, Habr!  Having made a <a href="https://habr.com/ru/post/444762/">translation of an</a> article on managing an LCD module with a driver, but without my own video RAM, I decided to translate another publication on the same topic.  Here the module is already simpler, monochrome, but it is equally interesting to ‚Äúrevive‚Äù it. <a name="habracut"></a><br><br><h1>  LCD control with driver, but without controller </h1><br>  The display, which the author is going to work with, is taken from the old tape library.  The controller was not preserved, but a search for something related to ‚Äú263645-001‚Äù showed that there was a FPGA.  It is believed that direct control of such LCD modules from Arduino, etc.  impossible, you need an intermediate link - the SEDxxxxx series controller, which is not ‚Äúfriendly‚Äù with the development boards, and has more inputs than the module itself.  But it is not.  Here are four similar projects: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://www.mikrocontroller.net/topic/98321">On ATmega8515</a> <br>  <a href="https://www.mikrocontroller.net/topic/25099%3Fpage%3Dsingle">On it</a> <br>  <a href="http://www.pcbheaven.com/exppages/Reverse-Engineering_an_LCD_Display/%3Fp%3D0">On pic</a> <br>  <a href="https://github.com/har-in-air/ESP32-LCD-I2S">On ESP32</a> <br><br>  And some even control eight-bit AVR VGA monitors ... <br><br>  In general, the author has succeeded, the software under the MIT license is <a href="https://github.com/ikostoski/arduino-clglcd">here</a> . <br><br><h1>  Still image </h1><br>  To make sure that everything works, you must first try to display a single-bit raster image from the microcontroller‚Äôs flash memory.  To obtain a negative voltage, three ‚ÄúCrowns‚Äù were taken, the voltage from the divider was applied to the V0 terminal, as a trimming resistor.  And on the screen - Lenna: <br><br><img src="https://habrastorage.org/webt/yb/7-/fg/yb7-fgxw6yf64l_ylhqaccnhq-g.jpeg"><br><br>  The author still can not understand how he managed to turn the picture (see which side of the train).  Anyway, on the project page on GitHub there is this example. <br><br><h1>  Text mode </h1><br>  But from the video ROM little sense, and 9600 bytes for video RAM in the Arduino is not.  The text mode comes to the rescue, in which the character generator's ROM and video RAM combined have a smaller volume than video RAM in graphics mode.  On this subject, supporters of the Republic of Kazakhstan and the "Specialist" can break spears endlessly. <br><br><img src="https://habrastorage.org/webt/yz/yf/la/yzyflade5gq71l7xiakjzym4utg.jpeg"><br><br>  A short example in AVR assembly language: <br><br><pre><code class="plaintext hljs">... lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ld r30, X+ swap r24; (CL2 rising edge) out %[data_port], r24 lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ...</code> </pre> <br><h1>  Required "iron" </h1><br><img src="https://habrastorage.org/webt/85/p_/52/85p_52apzq0nmbzcnde9vaphrxy.jpeg"><br><br>  For the module F-51543NFU-LW-ADN / PWB51543C-2-V0, the author has applied: <br><br>  Arduino on AVR with a clock frequency of 16 MHz (tested on Uno, Leonardo and a clone similar to ProMicro). <br><br>  Negative voltage source.  The author has it - unstabilized DC-DC converter A0524S-1W with input and output decoupling.  Converters for the MC34063 will also work (this chip is very easy to find - just disassemble the cheapest USB charger for the cigarette lighter) or MAX749.  Stabilization is not required, the range of allowable voltages for this input of the module applied here is quite wide.  The nominal is minus 24 V, the maximum is minus 30 relative to the common wire and 35 between Vdd and Vee.  Current consumption is 6 mA. <br><br>  Two N-channel MOSFETs with logic level control.  The author has applied IRL530n, the stock, of course, is large, but it definitely will not burn out.  One transistor controls the backlight, the other - a source of negative voltage. <br><br>  A 250 kŒ© trimming resistor for applying voltage to the V0 input.  Expose that the moving contact is -16.8 V at a temperature of +25 ¬∞ C.  This is from datasheet, and so, of course, such accuracy is not needed. <br><br>  Several 10-kilohm resistors to pull up. <br><br>  Layout and jumpers. <br><br>  What to do now?  QR clock?  Ask kote: <br><br><img src="https://habrastorage.org/webt/lw/yv/qp/lwyvqp84jo4uvj5byzropcuzf7k.jpeg"><br><br>  Kote offers to implement a simulation of some common LCD with a controller.  So that the Arduino can be connected to another, ‚Äúthinking‚Äù, that works with the display on the HD44780, only large. <br><br><h1>  Font - also in RAM </h1><br>  Take the example of EGA and VGA - there it is done that way when working in text mode.  Only here the signs fit only 64, but at least that‚Äôs how it fit into the RAM, unlike the graphics mode.  True, the main cycle of events slowed down, but you can try tile graphics: <br><br><img src="https://habrastorage.org/webt/ie/5w/qa/ie5wqaezqkvosxnzrjhvu3bzpaa.jpeg"><br><br><h1>  Graphic mode and halftones </h1><br>  In the Arduino on the AVR so much RAM is not, and the point.  Even in Mega.  320x240 even with one bit per pixel is already 9600 bytes.  A total of four semitones will require twice as much.  With external RAM, for example, 23LC512 in SQI mode, you can try to implement something similar to DMA, but it's easier and more profitable to remake everything on ESP32, where there is more static RAM and DMA is easier done. <br><br>  If you just want to connect such a display to a PC via USB, you can try using ATmega32u4 for this - there are enough resources even for gradations of brightness (with the help of FRC, what it is, as described in my previous translation).  But not in the "mega" used as an interface converter, but in the PC, which will itself scan the LCD on the fly at a speed of 5.4 megabits per second. <br><br>  When the module was still in the tape library, there was both a GUI and brightness gradations ‚Äî everything was there. <br><br>  Updates will be.  In the meantime ... <br><br><img src="https://habrastorage.org/webt/9z/cu/p9/9zcup9llwkpyuzyzxky3wghu_hs.jpeg"><br><br>  And this is not a photo montage, but the result of PC control.  And we will move from Hackaday.io to GitHub - there are still a lot of interesting things in README.md. <br><br><h1>  Signals to control such modules </h1><br>  FLM - First Line Marker - the first line marker, may also be called FRAME, VSYNC, etc. <br>  CL1 - Row latch pulse - the impulse to write a row, may also be called.  LOAD, HSYNC, etc. <br>  CL2 - Pixel shift clock - pixel shift pulse, can also be called.  CP (change pixel), etc. <br>  M - alternating signal, due to which the pixels are controlled by alternating voltage, can also be called BIAS (offset), etc. <br><br>  D0-D3 is a four-bit parallel data bus. <br><br>  Common wire, backlight power (for example, VLED ¬±), module power (VEE and V0) <br><br>  Do not neglect datasheets.  The module may require another negative voltage, or it may be positive, or the converter may be embedded.  The logic may differ, for example, if the unit on CL1 does not have a reaction on CL2.  There may be another backlight (CCFL (caution, ‚Äúbite-cutter‚Äù inverter) instead of LEDs), or there is no pin on the board, then you just won‚Äôt recognize it without datasheet.  It is impossible to connect anything at random. <br><br><h1>  What is there to do </h1><br>  Send the string in chunks of four bits, the record is made on the decline on the line CL2.  Having passed a string, write it down in a decay on the CL1 line (yeah, after all, there is a bit of RAM in the module ‚Äî one line).  The next line will be selected automatically.  Having transmitted the entire frame, return to the beginning using the FLM signal.  There is an example in the datasheet on LC79401.  Record to produce with sufficient speed, pulses on CL1 to apply evenly.  The controller hesitated a little - the screen blinked ugly. <br><br>  After each frame, change the logic level at the input M to the opposite, so that the pixels are controlled by an alternating voltage.  Otherwise, the display deteriorates: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZP0KxZl5N2o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  This operation can not trust the microcontroller, and put the counting trigger.  The entrance to the FLM, the output to M - in general, is understandable. <br><br>  An example for outputting an image from flash memory (see the beginning of the article) is called clglcd_simple in this repository. <br><br>  As already mentioned, it is impossible to do the same with the RAM in the Arduino on the AVR - it is not enough, therefore ... <br><br><h1>  And again - text mode </h1><br>  According to the datasheet, you can transfer data on a four-bit bus and ‚Äúpull‚Äù CL2 with a frequency of up to 6 MHz.  Therefore, you can quickly and quickly pass a string, then the microcontroller will solve other tasks for a bit, but as a timer it will ‚Äútell‚Äù it - it will ‚Äúpull‚Äù CL1 and repeat the cycle. <br><br>  When generating characters for a horizontal resolution of 320 pixels, all this can be done in 20 ¬µs (320 pixels / 4 bits = 80 pulses, CL2 is ‚Äújerked‚Äù at a frequency of 4 MHz).  The remaining tasks remain 39.5 ¬µs.  CL1 "pull" every 59.5 ¬µs and get a frame rate of 70 Hz.  Well, there will be more interrupt handling procedures and so on, in general, the microcontroller will be busy managing the display 45% of the time.  "Whole" 45 or "total" 45?  Probably the second: you can quickly overwrite the data in the video RAM. <br><br>  Want the microcontroller to spend less time managing the indicator, and more on other tasks?  You can reduce the frame rate to 50 Hz, you can overclock the microcontroller to 20 MHz.  In either of these ways, more cycles will take place between interrupt handling routines. <br><br>  The output comparison timer switches the CL2 line every four clock pulses with a duty cycle of 50%.  At the same time, the data arrive at the outputs of the PORTB port connected to the four-bit data bus of the module in such a way that their change occurs at the time of the level increase on CL2, and at the time of the decline they remain unchanged.  Of course, you cannot do this without an assembler: <br><br><pre> <code class="plaintext hljs">... lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ld r30, X+ swap r24; (CL2 rising edge) out %[data_port], r24 lpm r24, Z ;---------- (CL2 rising edge) out %[data_port], r24 ...</code> </pre> <br>  8 cycles - and transferred four nibble.  And what exactly to transfer depends on which character is in the corresponding cell of the video RAM, which pixels corresponding to this symbol should be transferred from the character generator's ROM, and what is stored in the corresponding cells of this ROM. <br><br>  The most inconvenient here is the need to stop the timer after exactly 80 pulses.  Some timers, such as Timer4 at 32u4, cannot do this. <br><br>  To obtain the signal supplied to the CL1 line, the author used another output of the microcontroller, designed for both the timer and fast PWM.  What of this applied here, of course.  It switches every 952 bars.  Or, if we count after the clock divider by 8, it is obtained every 119 pulses.  At this point, the interrupt handling procedure is started and causes the microcontroller to send new data to the control lines, which will be needed during the next pulse on CL1.  Well, the level on line M changes with half the frequency.  And the LCD does not deteriorate.  All signals together look like this: <br><br><img src="https://habrastorage.org/webt/yt/_0/dh/yt_0dhpk4km7w-yml5spdz5ukl8.png"><br><br>  The character generator consists of 256 characters - enough for 866, KOI-8R or 1251. 40xN characters are placed in the video RAM, where N is the number of lines depending on the character height.  The width of the symbol is always 8 pixels, and the height can be 6, 8, 10, 12, 15, 16. The smaller it is, the less ROM is required for the character generator and the more video RAM.  With an 8x8 font (40 characters per 30 lines), 1200 bytes of RAM and 2048 bytes of ROM are required.  When the font is 8x16 (this module looks best), RAM is 600 bytes, and the ROM is 4096. From the translator: you can store the font as 8x8, and vertically scale twice as software, and bypass 600 bytes of RAM and 2048 - ROM.  In order to store several fonts in ROM, you need to keep the address of the beginning of the font not in a constant, but in a variable, but you will not be able to display the text in several fonts at once, unless, of course, you change the address on the fly by the interrupt handling procedure directly during the transfer of pixels to the display. <br><br>  The font is stored as follows: first, the top lines of all 256 characters, then one line below, and so on.  In the misc folder of the repository there is a Python script that automatically converts the TTF font to the header file clglcd_font.h with the PROGMEM array in the required format.  Classic pixel fonts under CC-BY-SA 4.0 can be found <a href="https://int10h.org/oldschool-pc-fonts/">here</a> . <br><br><h1>  And again - take the example of EGA and VGA </h1><br>  But this time with details.  The character generator in RAM, as indicated above, contains only 64 characters, they can be designated with numbers from 0 to n or from 255-n to 255. They are stored in the same way: the top lines of all characters, then the following, and so on.  Only all this is aligned, taking into account the fact that the characters are not 256, but 64. For characters of 8x16 pixels, 16 * 64 = 1024 bytes are required.  The repository has an example of working with a character generator in RAM. <br><br>  If both character generators are used at the same time - 256-character in ROM and 64-character in RAM, you will have to accept the fact that not only less RAM is left, but the data transfer rate of the lines to the module will decrease - instead of 8 cycles of loading two nibbles it will take 12, that is, not 20 Œºs, but 30, but instead of 45% of the time it takes 60 to control the LCD. <br><br><h1>  Graphic mode with semitones </h1><br>  As stated above, in this case the microcontroller works simply as an interface converter.  ATmega32u4 is required, and what to do is described <a href="">here</a> .  Please note that the module may deteriorate due to the program hanging on the PC. <br><br>  So what is this four-wire cable - from a resistive sensor, it turns out. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mMqvBnYOjEQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Where to connect </h1><br>  As stated above, a negative voltage is required, which in the first experiments can be removed from three ‚ÄúKron‚Äù, and then a converter is assembled, for example, on MAX749.  The power control signals, as well as the DISPOFF signal (this is an inverse signal, the module is turned on at one) pull the resistors down.  During the firmware and reset of the microcontroller, the appearance of logical units there is unacceptable. <br><br>  The negative voltage is applied after the + 5V voltage, and the logical unit to the DISPOFF line - when data is already present on the control lines: at least one unit on the data bus, one unit on CL1.  Otherwise, the module may fail. <br><br>  Inputs D0-D3 can be connected to the outputs of the same microcontroller port, for example, Px4-Px7, while the outputs Px0-Px3 cannot be used as a GPIO.  You can assign other functions to them, for example, use them as timer outputs, a serial interface, and so on.  If you use them as inputs, be careful: the built-in pull-up resistors can switch arbitrarily if they are not disabled (PUD - pull-up disable). <br><br>  Input M - to the output of the comparison timer or PWM. <br><br>  CL1 input - to another output of the same timer. <br><br>  CL2 input - to the output of another comparison timer. <br><br>  FLM - to any digital output. <br><br>  DISPOFF - to any other digital output. <br><br>  The rest depends on how you power the module.  The author prefers to control the backlight and Vee separately. <br><br><h1>  How to use the firmware </h1><br>  Place clglcd.h and clglcd.cpp files in the sketch <br><br>  Make a backup copy of the clglcd_config.h file and edit it, taking into account what is connected to, as well as what functions you need: character generator in RAM, etc.  Attention, the code does not indicate the names of the Arduino outputs, but the names of the outputs of the microcontroller according to the datasheet.  The names of the outputs of the comparison timers are as follows: for example, 2, B is OC2B, which corresponds to PD3 on Arduino Uno.  The examples show the connection options that have earned the author. <br><br>  Generate the font file clglcd_font.h with the Python script in the misc folder (see above). <br><br>  See in the examples how to initialize, turn on and off the display.  Place in the screen array the text that you want to display for verification. <br><br>  Compile and fill in the sketch.  Check with the logic analyzer that the correct signals will go to the display, and with a voltmeter that all the supply voltages are normal.  Only then connect the display. <br><br>  Add a code to the sketch that will do something, for example, receive text on the serial port and display it. <br><br><h1>  Interrupts when the display is on </h1><br>  Update the display must be constantly, what are the procedures for handling interrupts.  If the interrupts stop for more than 30 ¬µs, the display will start blinking, and if it‚Äôs more than 60 ¬µs with a unit on the FLM line, it can fail.  If it is necessary to stop interruptions for a long time, first turn off the display with the DISPOFF signal (I repeat, this is an inverse signal, the module is turned on at one).  Of course, if it turns off for two seconds every time you need to process data from a humidity and temperature sensor, few people will like it, but it‚Äôs better than to spoil the module.  It is even better to entrust everything else to a separate microcontroller.  Especially, information exchange by the same microcontroller with devices operating under the 1-wire protocol and address LEDs is unacceptable.  Arduino Pro Micro clones are inexpensive enough to buy two. <br><br><h1>  Connection </h1><br>  But hardware-implemented interfaces will work fine: serial ports, I <sup>2</sup> C bus, SPI bus in master mode.  In the slave - only if the master device allows periodic slapping of the slave for 25-35 ¬µs.  Of course, it still depends on how many ‚Äúlegs‚Äù are left unoccupied after connecting the display. <br><br>  A 32u4 USB works fine if you don‚Äôt interrogate the endpoint management too often (slow interrupt handling procedure code).  The CDC driver and its API were fast enough. <br><br>  Further in the README.md file on GitHub, the list of similar projects is repeated, the same as on the project page on Hackaday.io <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/444912/">https://habr.com/ru/post/444912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444898/index.html">How to choose a broadband modem for unmanned aerial vehicle (UAV) or robotics</a></li>
<li><a href="../444904/index.html">Extract the master password from the locked password manager SafeInCloud</a></li>
<li><a href="../444906/index.html">Read old</a></li>
<li><a href="../444908/index.html">Where to grow smartphones</a></li>
<li><a href="../444910/index.html">Sound and light stimulation helps with Alzheimer's disease while in mice, but the results are encouraging</a></li>
<li><a href="../444916/index.html">Do not buy a DLC: a function that would save the fallen 737, "Boeing" sold as an option</a></li>
<li><a href="../444918/index.html">Where to grow smartphones: a road map for becoming a full-fledged computer</a></li>
<li><a href="../444920/index.html">New algorithm 200 times accelerates the automatic design of neural networks</a></li>
<li><a href="../444922/index.html">How to protect against hypnovirus</a></li>
<li><a href="../444924/index.html">The first Moscow WIAD: how did it go and what did they talk about</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>