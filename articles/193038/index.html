<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Boost.Asio C ++ Network Programming". Chapter 2: Boost.Asio Basics Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming". The second chapter turned out to be big, so I will brea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Boost.Asio C ++ Network Programming". Chapter 2: Boost.Asio Basics Part 1</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br>  I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming".  The second chapter turned out to be big, so I will break it into two parts.  In this part we will talk about the basics of Boost.Asio, and in the second part we will discuss asynchronous programming. <br><br>  Content: <br><ul><li>  <a href="http://habrahabr.ru/post/192284/">Chapter 1: Getting Started with Boost.Asio</a> </li><li>  Chapter 2: Boost.Asio Basics <br><ul><li>  <b>Part 1: The Basics of Boost.Asio</b> </li><li>  <a href="http://habrahabr.ru/post/195006/">Part 2: Asynchronous Programming</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/195386/">Chapter 3: Echo Server / Client</a> </li><li>  <a href="http://habrahabr.ru/post/195794/">Chapter 4: Client and Server</a> </li><li>  <a href="http://habrahabr.ru/post/196354/">Chapter 5: Synchronous vs. Asynchronous</a> </li><li>  <a href="http://habrahabr.ru/post/196888/">Chapter 6: Boost.Asio - Other Features</a> </li><li>  <a href="http://habrahabr.ru/post/197392/">Chapter 7: Boost.Asio - additional topics</a> </li></ul><br><br>  In this chapter, we will look at what you need to know using Boost.Asio.  We delve into asynchronous programming, which is much more complicated than synchronous and much more interesting. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Network API </h4><br>  This section shows what you need to know in order to write a network application using Boost.Asio. <br><br><h5>  Namespaces Boost.Asio </h5><br>  Everything in Boost.Asio is in the namespace <code>boost::asio</code> or its subspace, consider them: <br><ul><li>  <code>boost::asio</code> : This is where all the main classes and functions are located.  The main classes are <code>io_service</code> and <code>streambuf</code> .  Here are functions such as <code>read, read_at, read_until</code> , their asynchronous copies, as well as write functions and their asynchronous copies. </li><li>  <code>boost::asio::ip</code> : This is where the network part of the library is located.  The main classes are <code>address, endpoint, tcp, udp, icmp</code> , and the main functions are <code>connect</code> and <code>async_connect</code> .  Note that <code>socket</code> in <code>boost::asio::ip::tcp::socket</code> is just a <code>typedef</code> inside the class <code>boost::asio::ip::tcp</code> . </li><li>  <code>boost::asio::error</code> : This namespace contains error codes that you can get when you call an I / O subroutine. </li><li>  <code>boost::asio::ssl</code> : This namespace contains classes that deal with SSL. </li><li>  <code>boost::asio::local</code> : This namespace contains POSIX-specific classes. </li><li>  <code>boost::asio::windows</code> : This namespace contains Windows-specific classes. </li></ul><br><br><h5>  IP addresses </h5><br>  To work with IP addresses, Boost. Asio provides the classes <code>ip::address, ip::address_v4</code> and <code>ip::address_v6</code> . <br>  They provide many features.  Here are the most important ones: <br><ul><li>  <code>ip::address(v4_or_v6_address)</code> : This function converts a v4 or v6 address to <code>ip::address</code> </li><li>  <code>ip::address:from_string(str)</code> : This function creates an address from an IPv4 address (separated by dots) or from IPv6 (hexadecimal format) </li><li>  <code>ip::address::to_string()</code> : This function returns the address representation in a favorable string format. </li><li>  <code>ip::address_v4::broadcast([addr, mask])</code> : This function creates a <code>broadcast</code> address. </li><li>  <code>ip::address_v4::any()</code> : This function returns an address that impersonates any address. </li><li>  <code>ip::address_v4::loopback(), ip_address_v6::loopback()</code> : This function returns a loop of addresses (from the v4 / v6 protocol) </li><li>  <code>ip::host_name()</code> : This function returns the name of the current host as a string. </li></ul><br>  Most likely you will most often use the <code>ip::address::from_string</code> : <br><br><pre> <code class="cpp hljs">ip::address addr = ip::address::from_string(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>);</code> </pre><br>  If you need to connect to the hostname, read on.  The following code will not work: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// throws an exception ip::address addr = ip::address::from_string("www.yahoo.com");</span></span></code> </pre><br><br><h5>  Endpoints </h5><br>  The endpoint is the address of the connection along with the port.  Each type of socket has its own endpoint class, for example, <code>ip::tcp::endpoint, ip::udp::endpoint</code> , and <code>ip::icmp::endpoint</code> . <br>  If you want to connect to <code>localhost</code> on port 80, then you need to write the following: <br><br><pre> <code class="cpp hljs">ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">80</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br>  You can create an endpoint in three ways: <br><ul><li>  <code>endpoint()</code> : the default constructor and it can sometimes be used for UDP / ICMP sockets </li><li>  <code>endpoint(protocol, port)</code> : typically used on server sockets to accept new connections </li><li>  <code>endpoint(addr, port)</code> : create endpoint by address and port </li></ul><br>  Here are some examples: <br><br><pre> <code class="cpp hljs">ip::tcp::endpoint ep1; ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::tcp::v4(), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">80</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1), 80);</span></span></span></span></span></span></code> </pre><br>  If you want to connect to a host (not an IP address), then you need to do the following: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// outputs "87.248.122.122" io_service service; ip::tcp::resolver resolver(service); ip::tcp::resolver::query query("www.yahoo.com", "80"); ip::tcp::resolver::iterator iter = resolver.resolve( query); ip::tcp::endpoint ep = *iter; std::cout &lt;&lt; ep.address().to_string() &lt;&lt; std::endl;</span></span></code> </pre><br>  You can replace tcp with the type of socket you need.  First, create a request with the name you want to connect to, this can be accomplished using the function <code>resolve()</code> .  If successful, at least one entry will be returned. <br>  After receiving the end point, you can get from it the address, port and IP protocol (v4 or v6): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ep.address().to_string() &lt;&lt; <span class="hljs-string"><span class="hljs-string">":"</span></span> &lt;&lt; ep.port() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"/"</span></span> &lt;&lt; ep.protocol() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br><h5>  Sockets </h5><br>  Boost.Asio includes three types of socket classes: <code>ip::tcp, ip::udp</code> , and <code>ip::icmp</code> , and, of course, it expands.  You can create your own socket class, although it is rather difficult.  In case you still decide to do this, look at <code>boost/ asio/ip/tcp.hpp</code> , <code>boost/asio/ip/udp.hpp</code> , and <code>boost/asio/ip/icmp.hpp</code> .  All of them are pretty small classes with internal <code>typedef</code> keywords. <br>  You can think of the classes <code>ip::tcp, ip::udp, ip::icmp</code> as placeholders;  they allow easy access to other classes / functions, which are defined as follows: <br><ul><li>  ip :: tcp :: socket, ip :: tcp :: acceptor, ip :: tcp :: endpoint, ip :: tcp :: resolver, ip :: tcp :: iostream </li><li>  ip :: udp :: socket, ip :: udp :: endpoint, ip :: udp :: resolver </li><li>  ip :: icmp :: socket, ip :: icmp :: endpoint, ip :: icmp :: resolver </li></ul><br>  The <code>socket</code> class creates the corresponding socket.  You always pass an instance of <code>io_service</code> to the constructor: <br><br><pre> <code class="cpp hljs">io_service service; ip::udp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span><span class="hljs-function"> sock.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_option</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::udp::socket::reuse_address(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>;</code> </pre><br>  Each socket name has a <code>typedef</code> : <br><ul><li> <code>ip::tcp::socket= basic_stream_socket</code> <br>  <code>ip::udp::socket= basic_datagram_socket&lt;ud</code> p&gt; <br> <code>ip::icmp::socket= basic_raw_socket</code> <br> <br><br><h4>  Error codes of synchronous functions </h4><br>  All synchronous functions have overloads that throw exceptions or return an error code, as shown below: <br><br><pre> <code class="cpp hljs">sync_func( arg1, arg2 ... argN); <span class="hljs-comment"><span class="hljs-comment">// throws boost::system::error_code ec; sync_func( arg1 arg2, ..., argN, ec); // returns error code</span></span></code> </pre><br>  In the remainder of the chapter, you will see many synchronous functions.  In order not to complicate things, I lowered the display of overloads that return an error code, but they exist. <br><br><h5>  Socket functions </h5><br>  All functions are divided into several groups.  Not all functions are available for each type of socket.  The list at the end of this section will show you which functions belong to which class of sockets. <br>  Note that all asynchronous functions respond instantly, while their synchronous colleagues respond only after the operation has been completed. <br><br><h6>  Connective function </h6><br>  These are functions that connect or connect to a socket, disconnect it and make a connection request whether it is active or not: <br><ul><li>  <code>assign(protocol,socket)</code> : this function assigns a raw (natural) socket to a socket instance.  Use it when working with legacy code (that is, when raw sockets have already been created). </li><li>  <code>open(protocol)</code> : this function opens a socket with the specified IP protocol (v4 or v6).  You will use it mainly for UDP / ICMP sockets or server sockets. </li><li>  <code>bind(endpoint)</code> : this function is associated with the given address. </li><li>  <code>connect(endpoint)</code> : this function is synchronously connected to this address. </li><li>  <code>async_connect(endpoint)</code> : this function is connected asynchronously to this address. </li><li>  <code>is_open()</code> : this function returns true if the socket is open. </li><li>  <code>close()</code> : this function closes the socket.  Any asynchronous operation on this socket is immediately terminated and the <code>error::operation_aborted</code> error code is returned. </li><li>  <code>shutdown(type_of_shutdown)</code> : this function disables the <code>send , receive</code> or both operation immediately after the call. </li><li>  <code>cancel()</code> : this function cancels all asynchronous operations on this socket.  All asynchronous operations on this socket will be completed immediately and <code>error::operation_aborted</code> code will be returned to <code>error::operation_aborted</code> . </li></ul><br>  Let's give a small example: <br><br><pre> <code class="cpp hljs">ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">80</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; sock.open(ip::tcp::v4()); sock.connect(ep); sock.write_some(buffer(<span class="hljs-string"><span class="hljs-string">"GET /index.html\r\n"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; sock.read_some(buffer(buff,<span class="hljs-number"><span class="hljs-number">1024</span></span>)); sock.shutdown(ip::tcp::socket::shutdown_receive); sock.close();</code> </pre><br><br><h6>  Read / write functions </h6><br>  These are the functions that perform input / output on the socket. <br>  For asynchronous functions, the handler has the following signature <code>void handler(const boost::system::error_code&amp; e, size_t bytes);</code>  .  But the functions themselves: <br><ul><li>  <code>async_receive(buffer, [flags,] handler)</code> : this function starts an asynchronous operation to receive data from a socket. </li><li>  <code>async_read_some(buffer,handler)</code> : this function is equivalent to <code>async_receive(buffer, handler)</code> . </li><li>  <code>async_receive_from(buffer, endpoint[, flags], handler)</code> : this function starts asynchronous data reception from a specific address. </li><li>  <code>async_send(buffer [, flags], handler)</code> : this function starts an asynchronous transfer of data from the buffer </li><li>  <code>async_write_some(buffer, handler)</code> : this function is equivalent to <code>async_send(buffer, handler)</code> . </li><li>  <code>async_send_to(buffer, endpoint, handler)</code> : this function starts an asynchronous transfer of data from the buffer to a specific address. </li><li>  <code>receive(buffer [, flags])</code> : this function receives data in the buffer synchronously.  The function is blocked until data starts to arrive or if an error has occurred. </li><li>  <code>read_some(buffer)</code> : this function is equivalent to <code>receive(buffer)</code> . </li><li>  <code>receive_from(buffer, endpoint [, flags])</code> : this function synchronously receives data from a specific address into this buffer.  The function is blocked until data has started to arrive, or if an error has occurred. </li><li>  <code>send(buffer [, flags])</code> : this function synchronously sends data from the buffer.  The function is locked while data is being sent or if an error has occurred. </li><li>  <code>write_some(buffer)</code> : this function is equivalent to <code>send(buffer)</code> . </li><li>  <code>send_to(buffer, endpoint [, flags])</code> : this function synchronously transfers data from the buffer to this address.  The function is locked while data is being sent or if an error has occurred. </li><li>  <code>available()</code> : this function returns the number of bytes that can be read synchronously, without blocking. </li></ul><br>  We will talk about buffers soon.  Let's look at the flags.  The default value for flags is 0, but combinations are possible: <br><ul><li>  <code>ip::socket_type::socket::message_peek</code> : this flag only looks in the message.  He will return the message, but on the next call, you will need to re-read it to read the message. </li><li>  <code>ip::socket_type::socket::message_out_of_band</code> : this flag processes out-of-band data.  OOB data is data that is flagged as more important than normal data.  Discussing OOB data is beyond the scope of this book. </li><li>  <code>ip::socket_type::socket::message_do_not_route</code> : This flag indicates that a message should be sent without using routing tables. </li><li>  <code>ip::socket_type::socket::message_end_of_record:</code> This flag indicates that the data is marked with a marker about the end of the record.  This is not supported on Windows. </li></ul><br>  Most likely you used <code>message_peek</code> if you ever wrote the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; sock.receive(buffer(buff), ip::tcp::socket::message_peek ); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(buff,<span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// re-reads what was previously read sock.receive(buffer(buff) );</span></span></code> </pre><br>  Below are examples that give instructions to read both synchronously and asynchronously to different types of sockets: <br><ul><li>  Example 1: synchronous read and write to TCP socket: <br><pre> <code class="cpp hljs">ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">80</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; sock.connect(ep); sock.write_some(buffer(<span class="hljs-string"><span class="hljs-string">"GET /index.html\r\n"</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"bytes available "</span></span> &lt;&lt; sock.available() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read = sock.read_some(buffer(buff));</code> </pre><br></li><li>  Example 2: synchronous read and write to a UDP socket: <br><pre> <code class="cpp hljs">ip::udp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; sock.open(ip::udp::v4()); ip::udp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receiver_ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"87.248.112.181"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">80</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; sock.send_to(buffer(<span class="hljs-string"><span class="hljs-string">"testing\n"</span></span>), receiver_ep); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">512</span></span>]; ip::udp::endpoint sender_ep; sock.receive_from(buffer(buff), sender_ep);</code> </pre><br>  Note that when reading from a UDP socket using <code>receive_from</code> , you need to use the default endpoint constructor, as shown in the previous example. <br></li><li>  Example 3: asynchronous reading from UDP server socket: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::asio; io_service service; ip::udp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; boost::asio::ip::udp::endpoint sender_ep; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp; err, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> read_bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"read "</span></span> &lt;&lt; read_bytes &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; sock.async_receive_from(buffer(buff), sender_ep, on_read); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ ip::udp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; sock.open(ep.protocol()); sock.set_option(boost::asio::ip::udp::socket::reuse_ address(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); sock.bind(ep); sock.async_receive_from(buffer(buff,<span class="hljs-number"><span class="hljs-number">512</span></span>), sender_ep, on_read); service.run(); }</code> </pre><br></li></ul><br><br><h5>  Socket control </h5><br>  These functions work with additional socket options: <br><ul><li>  <code>get_io_service()</code> : this function returns an instance of <code>io_service</code> , which was passed to the constructor. </li><li>  <code>get_option(option)</code> : this function returns a socket parameter </li><li>  <code>set_option(option)</code> : this function sets the socket parameter </li><li>  <code>io_control(cmd)</code> : this function executes I / O commands on the socket. </li></ul><br>  The following parameters you can get / set the socket: <br><table><tbody><tr><th>  Name </th><th>  Definition </th><th>  Type of </th></tr><tr><td> <code>broadcast</code> </td> <td>  If <code>true</code> , then allows broadcast messages </td><td>  bool </td></tr><tr><td> <code>debug</code> </td> <td>  If <code>true</code> , it allows debugging at the socket level. </td><td>  bool </td></tr><tr><td> <code>do_not_route</code> </td> <td>  If <code>true</code> , it prevents routing and uses only local interfaces. </td><td>  bool </td></tr><tr><td> <code>enable_connection_aborted</code> </td> <td>  If <code>true</code> , then reconnects the broken connection. </td><td>  bool </td></tr><tr><td> <code>keep_alive</code> </td> <td>  If <code>true</code> , send <code>keep-alives</code> </td><td>  bool </td></tr><tr><td> <code>linger</code> </td> <td>  If <code>true</code> , the socket is delayed by <code>close()</code> , if there are no saved ones <br>  data </td><td>  bool </td></tr><tr><td> <code>receive_buffer_size</code> </td> <td>  Receive Buffer Size </td><td> <code>int</code> </td> </tr><tr><td> <code>receive_low_watemark</code> </td> <td>  Provides the minimum number of bytes when processing an input socket. </td><td> <code>int</code> </td> </tr><tr><td> <code>reuse_address</code> </td> <td>  If <code>true</code> , the socket may be associated with an address that is already in use. </td><td>  bool </td></tr><tr><td> <code>send_buffer_size</code> </td> <td>  Send buffer size </td><td> <code>int</code> </td> </tr><tr><td> <code>send_low_watermark</code> </td> <td>  Provides the minimum number of bytes to send in the output socket. </td><td> <code>int</code> </td> </tr><tr><td> <code>ip::v6_only</code> </td> <td>  If <code>true</code> , it allows using only IPv6 communications. </td><td> <code>bool</code> </td> </tr></tbody></table><br>  Each name is an internal <code>typedef</code> socket or class.  Here's how to use them: <br><br><pre> <code class="cpp hljs">ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">80</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; sock.connect(ep); <span class="hljs-comment"><span class="hljs-comment">// TCP socket can reuse address ip::tcp::socket::reuse_address ra(true); sock.set_option(ra); // get sock receive buffer size ip::tcp::socket::receive_buffer_size rbs; sock.get_option(rbs); std::cout &lt;&lt; rbs.value() &lt;&lt; std::endl; // set sock's buffer size to 8192 ip::tcp::socket::send_buffer_size sbs(8192); sock.set_option(sbs);</span></span></code> </pre><br>  The socket must be open for the previous function to work, otherwise an exception will be thrown. <br><br><h5>  TCP vs UDP and ICMP </h5><br>  As I said, not all member functions are available for all socket classes.  I have compiled a list where member functions differ.  If the member function is not here, then this means that it is present in all classes of sockets: <br><table><tbody><tr><th>  Name </th><th>  Tcp </th><th>  UDP </th><th>  ICMP </th></tr><tr><td> <code>async_read_some</code> </td> <td>  Yes </td><td>  - </td><td>  - </td></tr><tr><td> <code>async_write_some</code> </td> <td>  Yes </td><td>  - </td><td>  - </td></tr><tr><td> <code>async_send_to</code> </td> <td>  - </td><td>  Yes </td><td>  Yes </td></tr><tr><td> <code>read_some</code> </td> <td>  Yes </td><td>  - </td><td>  - </td></tr><tr><td> <code>receive_from</code> </td> <td>  - </td><td>  Yes </td><td>  Yes </td></tr><tr><td> <code>write_some</code> </td> <td>  Yes </td><td>  - </td><td>  - </td></tr><tr><td> <code>send_to</code> </td> <td>  - </td><td>  Yes </td><td>  Yes </td></tr></tbody></table><br><br><h5>  Other functions </h5><br>  Other functions related to connection or I / O: <br><ul><li>  <code>local_endpoint()</code> : This function returns an address if the socket is connected locally. </li><li>  <code>remote_endpoint()</code> : this function returns the remote addresses to which the socket was connected. </li><li>  <code>native_handle()</code> : this function returns a clean socket.  It should be used only when you want to use functions for working with clean sockets that are not supported by Boost.Asio. </li><li>  <code>non_blocking()</code> : this function returns <code>true</code> if the socket is non-blocking, otherwise <code>false</code> . </li><li>  <code>native_non_blocking()</code> : this function returns <code>true</code> if the socket is non-blocking, otherwise <code>false</code> .  However, it will call a clean API for the natural socket.  As a rule, you do not need this ( <code>non_blocking()</code> always caches this result);  you should use it only when you are directly dealing with <code>native_handle()</code> . </li><li>  <code>at_mark()</code> : this function returns <code>true</code> if you intend to read OOB data in the socket.  She is needed very rarely. </li></ul><br><br><h5>  Other considerations </h5><br>  Lastly, a socket instance cannot be copied, since the copy constructor and <code>operator=</code> not available. <br><br><pre> <code class="cpp hljs">ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; s1 = s2; <span class="hljs-comment"><span class="hljs-comment">// compile time error ip::tcp::socket s3(s1); // compile time error</span></span></code> </pre><br>  This makes a lot of sense, as each instance stores and manages resources (the natural socket itself).  If we used a copy constructor, then ultimately we had two instances of the same socket;  they would have to somehow manage ownership (either one copy has ownership, or reference counting, or some other method is used).  In Boost.Asio it was customary to prohibit copying (if you want to create copies, just use a <code>shared</code> pointer). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ip::tcp::socket&gt; socket_ptr; <span class="hljs-function"><span class="hljs-function">socket_ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ip::tcp::socket(service))</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">socket_ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sock1)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ok socket_ptr sock3; sock3 = sock1; // ok</span></span></code> </pre><br><br><h4>  Socket buffers </h4><br>  When reading or writing to a socket, you need a buffer that will contain incoming or outgoing data.  Buffer memory must survive I / O operations;  you must make sure that as long as it is not released, it will not go out of scope as long as an I / O operation lasts. <br>  This is very simple for synchronous operations;  <code>buff</code> course, <code>buff</code> must survive both <code>receive</code> and <code>send</code> operations: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">512</span></span>]; ... sock.receive(buffer(buff)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(buff, <span class="hljs-string"><span class="hljs-string">"ok\n"</span></span>); sock.send(buffer(buff));</code> </pre><br>  And this is not so easy for asynchronous operations, as shown in the following snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// very bad code ... void on_read(const boost::system::error_code &amp; err, std::size_t read_ bytes) { ... } void func() { char buff[512]; sock.async_receive(buffer(buff), on_read); }</span></span></code> </pre><br>  After calling <code>async_receive()</code> , the <code>buff</code> will go out of scope, thus its memory will be freed.  When we are going to actually get some data on the socket, we need to copy it into memory no longer belong to us;  it can be either released or redistributed by code for other data, while all have memory corruption. <br>  There are several solutions to the problem: <br><ul><li>  Use global buffer </li><li>  Create a buffer and destroy it when the operation completes. </li><li>  Have a connection object to support the socket and additional data, such as a buffer (s). </li></ul><br>  The first solution is not very convenient, since we all know that global variables are bad.  Also, what happens if two handlers use the same buffer? <br>  Here is how you can implement the second solution: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp; err, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> read_bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] ptr; } .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * buff = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">512</span></span>]; sock.async_receive(buffer(buff, <span class="hljs-number"><span class="hljs-number">512</span></span>), boost::bind(on_ read,buff,_1,_2));</code> </pre><br>  If you want the buffer to automatically go out of scope when the operation completes, then use the <code>shared pointer</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_buffer</span></span></span><span class="hljs-class"> {</span></span> boost::shared_array&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; buff; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; shared_buffer(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size) : buff(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[size]), size(size) {} <span class="hljs-function"><span class="hljs-function">mutable_buffers_1 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asio_buff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer(buff.get(), size); } }; <span class="hljs-comment"><span class="hljs-comment">// when on_read goes out of scope, the boost::bind object is released, // and that will release the shared_buffer as well void on_read(shared_buffer, const boost::system::error_code &amp; err, std::size_t read_bytes) {} ... shared_buffer buff(512); sock.async_receive(buff.asio_buff(), boost::bind(on_read,buff,_1,_2));</span></span></code> </pre><br>  The class <code>shared_buffer</code> contains inside itself <code>shared_array&lt;&gt;</code> , which is a copy of the <code>shared_buffer</code> instance, so <code>shared_array &lt;&gt;</code> will remain alive;  when the latter goes out of scope, <code>shared_array &lt;&gt;</code> automatically collapses, just what we wanted. <br>  This works as expected, since Boost.Asio will hold a copy of the final handler that is called when the operation completes.  This copy is a <code>boost::bind</code> functor that internally stores a copy of our <code>shared_buffer</code> instance.  It is very neat! <br>  The third option is to use a communication object that supports a socket and contains additional data, such as buffers, which is usually the right solution, but rather complicated.  It will be discussed at the end of this chapter. <br><br><h4>  Buffer function vraper </h4><br>  In the code that we saw earlier, we always needed a buffer for read / write operations, the code turned into a real buffer object, a <code>buffer()</code> call and its function transfer: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">512</span></span>]; sock.async_receive(buffer(buff), on_read</code> </pre><br>  Basically, any buffer that we have in the class is wrapped, which allows functions from Boost.Asio to iterate over the buffer.  Say, you use the following code: <br><br><pre> <code class="cpp hljs">sock.async_receive(some_buffer, on_read);</code> </pre><br>  An instance of <code>some_buffer</code> must satisfy some requirements, namely <code>ConstBufferSequence</code> or <code>MutableBufferSequence</code> (you can see more about them in the Boost.Asio documentation).  The details of creating your own class to meet these requirements are quite complex, but Boost.Asio already contains some classes that model these requirements.  You do not access them directly, you use the <code>buffer()</code> function. <br>  Suffice it to say that you can wrap all of the following in the <code>buffer()</code> function: <br><ul><li>  constant character array </li><li>  <code>void*</code> and size in characters </li><li>  string <code>std::string</code> </li><li>  POD [] constant array (POD is suitable for old data, i.e. the constructor and destructor do nothing) </li><li>  array <code>std::vector</code> from any POD </li><li>  array <code>boost::array</code> from any POD </li><li>  array <code>std::array</code> from any POD </li></ul><br>  The following code is working: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pod_sample</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; }; ... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> b1[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * b2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b3; b3.resize(<span class="hljs-number"><span class="hljs-number">128</span></span>); pod_sample b4[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;pod_sample&gt; b5; b5.resize(<span class="hljs-number"><span class="hljs-number">16</span></span>); boost::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;pod_sample,16&gt; b6; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;pod_sample,16&gt; b7; sock.async_send(buffer(b1), on_read); sock.async_send(buffer(b2,<span class="hljs-number"><span class="hljs-number">512</span></span>), on_read); sock.async_send(buffer(b3), on_read); sock.async_send(buffer(b4), on_read); sock.async_send(buffer(b5), on_read); sock.async_send(buffer(b6), on_read); sock.async_send(buffer(b7), on_read);</code> </pre><br>  ,  ,         <code>ConstBufferSequence</code>  <code>MutableBufferSequence</code> ,    ,       ,       <code>mutable_ buffers_1</code> ,    ,      <code>shared_buffer</code> . <br><br><h4>   // </h4><br> Boost.Asio        /.      . <br><br><h5>   </h5><br>       : <br><ul><li> <code>connect(socket, begin [, end] [, condition])</code> :          ,   <code>begin</code>   <code>end</code> .  <code>begin</code>    <code>socket_type::resolver::query</code> ( ,    ¬´ ¬ª  ).      ,     .    <code>condition</code> ,      .    <code>Iterator connect_condition(const boost::system::error_code &amp; err, Iterator next);</code>  .       ,  ,      . </li><li> <code>async_connect(socket, begin [, end] [, condition], handler):</code>           .    <code>void handler(const boost::system::error_code &amp; err, Iterator iterator);</code>  .  ,         (  end   ). </li></ul><br>   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost::asio::ip; tcp::<span class="hljs-function"><span class="hljs-function">resolver </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; tcp::resolver::iterator iter = resolver.resolve(tcp::resolver::query(<span class="hljs-string"><span class="hljs-string">"www.yahoo.com"</span></span>,<span class="hljs-string"><span class="hljs-string">"80"</span></span>)); tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; connect(sock, iter);</code> </pre><br>       ,   <code>connect</code>  <code>async_connect</code>       ,      ;     . <br><br><h5>  / </h5><br>        (         ,     ): <br><ul><li> <code>async_read(stream, buffer [, completion] ,handler)</code> :      .    .     <code>void handler(const boost::system::error_code &amp; err, size_t bytes);</code>  .       completion . <code>Completion</code>       <code>read</code> ,   Boost.Asio   <code>async_read</code>  ( ,    ).    <code>size_t completion (const boost::system::error_code&amp; err, size_t bytes_transfered)</code> .      0,  ,    ;     ,   ,           <code>async_read_some</code>  .        . </li><li> <code>async_write(stream, buffer [, completion], handler)</code> :      .     <code>async_read</code> . </li><li> <code>read(stream, buffer [, completion])</code> :      .     <code>async_read</code> </li><li> <code>write(stream, buffer [, completion])</code> :      .     <code>async_read</code> . </li><li> <code>async_read(stream, stream_buffer [, completion], handler)</code> </li> <li> <code>async_write(strean, stream_buffer [, completion], handler)</code> </li> <li> <code>write(stream, stream_buffer [, completion])</code> </li> <li> <code>read(stream, stream_buffer [, completion])</code> </li> </ul><br> - ,       .    ,    . ,       Windows. <br>            : <br><ul><li>    ( )        ( ). </li><li> <code>Completion</code>   0 (      ). </li><li>   . </li></ul><br>    ,    '\n': <br><br><pre> <code class="cpp hljs">io_service service; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> up_to_enter(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> boost::system::error_code &amp;, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bytes; ++i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( buff[i + offset] == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} ... async_read(sock, buffer(buff), up_to_enter, on_read);</code> </pre><br>  , Boost.Asio     <code>completion</code> : <br><ul><li> transfer_at_least(n) </li><li> transfer_exactly(n) </li><li> transfer_all() </li></ul><br>     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// read exactly 32 bytes async_read(sock, buffer(buff), transfer_exactly(32), on_read);</span></span></code> </pre><br>         <code>stream_buffer</code>  Boost.Asio,    <code>std::streambuf</code> .       STL   ,  : <br><br><pre> <code class="cpp hljs">io_service service; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(streambuf&amp; buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">istream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;buf)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline(in, line); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"first line: "</span></span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ HANDLE file = ::CreateFile(<span class="hljs-string"><span class="hljs-string">"readme.txt"</span></span>, GENERIC_READ, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,<span class="hljs-number"><span class="hljs-number">0</span></span>); windows::<span class="hljs-function"><span class="hljs-function">stream_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, file)</span></span></span></span>; streambuf buf; async_read(h, buf, transfer_exactly(<span class="hljs-number"><span class="hljs-number">256</span></span>), boost::bind(on_read,boost::ref(buf),_1,_2)); service.run(); }</code> </pre><br>    ,     <code>async_read</code> ( - )   Windows.    256      .    ,   <code>on_read</code> ,   <code>std::istream</code> ,    ( <code>std::getline</code> )     . <br><br><h5>  <code>read_until/async_read_until</code> </h5><br>          : <br><ul><li> <code>async_read_until(stream, stream_buffer, delim, handler)</code> :      .         ( <code>delim</code> ).     , <code>std::string</code>  <code>boost::regex</code> .    <code>void handler(const boost::system::error_code &amp; err, size_t bytes);</code>  . </li><li> <code>async_read_until(stream, stream_buffer, completion, handler)</code> :       ,       .     <code>pair&lt;iterator,bool&gt; completion(iterator begin, iterator end);</code> ,    <code>buffers_iterator&lt;streambuf::const_buffers_type&gt;</code> .   ,       .     ( <code>begin, end</code> )          .    ;           ;    <code>true</code> ,   ,     ,  <code>false</code> . </li><li> <code>read_until(stream, stream_buffer, delim)</code> :      .         <code>async_read_until</code> . </li></ul><br>         : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> buffers_iterator&lt;streambuf::const_buffers_type&gt; iterator; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;iterator, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; match_punct(iterator begin, iterator end) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( begin != end) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">ispunct</span></span>(*begin)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(begin,<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(end,<span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> boost::system::error_code &amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} ... streambuf buf; async_read_until(sock, buf, match_punct, on_read);</code> </pre><br>       ,      : <br><br><pre> <code class="cpp hljs">async_read_until(sock, buff, <span class="hljs-string"><span class="hljs-string">' '</span></span>, on_read);</code> </pre><br><br><h5>  *_at </h5><br>     /  .  ,   /   ( ): <br><ul><li> <code>async_read_at(stream, offset, buffer [, completion], handler)</code> :         ,    <code>offset</code> .       <code>handler (const boost::system::error_code&amp; err, size_t bytes);</code>  .       <code>buffer()</code>    <code>streambuf</code> .    ,           Boost.Asio   <code>async_read_at operation</code>  ( ,   ).     <code>size_t completion(const boost::system::error_code&amp; err, size_t bytes);</code>  .     0,   ,    ,     ,   ,          <code>async_read_some_at</code>   . </li><li> <code>async_write_at(stream, offset, buffer [, completion], handler)</code> :      .    <code>async_read_at</code> . </li><li> <code>read_at(stream, offset, buffer [, completion])</code> :        .    <code>async_read_at</code> . </li><li> <code>read_at(stream, offset, buffer [, completion])</code> :        .    <code>async_read_at</code> . </li></ul><br>       .       ;  ,  ,       .      (  <code>forward-only</code> ). <br>      128   ,     256: <br><br><pre> <code class="cpp hljs">io_service service; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ HANDLE file = ::CreateFile(<span class="hljs-string"><span class="hljs-string">"readme.txt"</span></span>, GENERIC_READ, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,<span class="hljs-number"><span class="hljs-number">0</span></span>); windows::<span class="hljs-function"><span class="hljs-function">random_access_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, file)</span></span></span></span>; streambuf buf; read_at(h, <span class="hljs-number"><span class="hljs-number">256</span></span>, buf, transfer_exactly(<span class="hljs-number"><span class="hljs-number">128</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">istream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;buf)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline(in, line); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"first line: "</span></span> &lt;&lt; line &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br><br>     ,       .     .  . <br><br>  Good luck to all! </li></ul></div><p>Source: <a href="https://habr.com/ru/post/193038/">https://habr.com/ru/post/193038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../193024/index.html">Base GeoIP - countries and cities, September 2013</a></li>
<li><a href="../193026/index.html">We invite you to participate in the Intel Software Conference 2013</a></li>
<li><a href="../193028/index.html">Google introduces end-to-end encryption between data centers</a></li>
<li><a href="../193030/index.html">Dell Solutions Forum 2013: registration is open!</a></li>
<li><a href="../193032/index.html">Fujitsu OASYS 30AFII Japanese Text Editor</a></li>
<li><a href="../193040/index.html">Big update Ruward</a></li>
<li><a href="../193042/index.html">Electronic car numbers will appear in California</a></li>
<li><a href="../193044/index.html">Search for deleted files in NTFS</a></li>
<li><a href="../193046/index.html">LEC-2126 Network Platform Overview</a></li>
<li><a href="../193048/index.html">Unicode and .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>