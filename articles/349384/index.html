<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The slowest way to speed up a program on Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is something great about programming in assembler. It can be very slow and full of errors compared to programming in a language such as Go, but ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The slowest way to speed up a program on Go</h1><div class="post__text post__text-html js-mediator-article"><p>  There is something great about programming in assembler.  It can be very slow and full of errors compared to programming in a language such as Go, but sometimes it’s a good idea or at least a very fun experience. </p><br><p>  Why spend time programming in assembler when there are excellent high level programming languages?  Even with today's compilers, there are still a few cases where you want to write code in assembly language.  These are <a href="">cryptography</a> , <a href="https://go-review.googlesource.com/">performance optimization,</a> or <a href="">access to things that are usually not available in the language</a> .  The most interesting, of course, is performance optimization. </p><br><p>  When the performance of some part of your code really matters to the user, and you have already tried all the more simple ways to make it faster, writing code in assembly language can be a good place to optimize.  Although the compiler can be perfectly optimized for creating assembler code, you can know more about a particular case than the compiler suggests. </p><a name="habracut"></a><br><h2 id="pishem-assemblernyy-kod-v-go">  We write the assembly code in Go </h2><br><p> The best way to get started is to write the simplest function.  For example, the <code>add</code> function adds two int64s. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(add(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) }</code> </pre> <br><p>  Run: <code>go build -o add-go &amp;&amp; ./add-go</code> </p><br><p>  To implement this function in assembler, create a separate file <code>add_amd64.s</code> , which will contain the assembler code.  The examples use assembler for AMD64 architecture. </p><br><p>  <strong>add.go:</strong> </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int64</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(add(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) }</code> </pre> <br><p>  <strong>add_amd64.s:</strong> </p><br><pre> <code class="go hljs">#include <span class="hljs-string"><span class="hljs-string">"textflag.h"</span></span> TEXT ·add(SB),NOSPLIT,$<span class="hljs-number"><span class="hljs-number">0</span></span> MOVQ x+<span class="hljs-number"><span class="hljs-number">0</span></span>(FP), BX MOVQ y+<span class="hljs-number"><span class="hljs-number">8</span></span>(FP), BP ADDQ BP, BX MOVQ BX, ret+<span class="hljs-number"><span class="hljs-number">16</span></span>(FP) RET</code> </pre> <br><p>  To run the example, put these two files in one directory and run the command <code>go build -o add &amp;&amp; ./add</code> </p><br><p>  The assembler syntax is at best ... unclear.  There is an <a href="https://golang.org/doc/asm">official Go manual</a> and a rather <a href="http://doc.cat-v.org/plan_9/4th_edition/papers/asm">ancient manual for the Plan 9 assembler</a> , which gives some tips on how the assembly language in Go works.  The best sources to learn are the existing assembler code Go and the compiled versions of Go functions that can be obtained by executing the command: <code>go tool compile -S &lt;go file&gt;</code> . </p><br><p>  The most important things to know are the function declaration and the stack layout. </p><br><p>  The magic spell to start the function is <code>TEXT ·add(SB), NOSPLIT, $0</code> .  The Unicode character symbol <code>·</code> separates the package name from the function name.  In this case, the package name is <code>main</code> , so the package name is empty here, and the function name is <code>add</code> .  The <code>NOSPLIT</code> directive means that you do not need to write the size of the arguments as the next parameter.  The constant <code>$0</code> at the end is where you need to put the size of the arguments, but since we have a <code>NOSPLIT</code> , we can just leave it as <code>$0</code> . </p><br><p>  Each function argument is pushed onto the stack, starting at address <code>0(FP)</code> , meaning an offset of zero bytes from the <code>FP</code> pointer, and so on for each argument and the return value.  For <code>func add (x, y int64) int64</code> , it looks like this: <br><img src="https://habrastorage.org/webt/jc/dr/pk/jcdrpksxvxovpyzl59jhl2ofd84.png"></p><br><p>  Let's sort the code of the already familiar <code>add</code> function: </p><br><pre> <code class="go hljs">TEXT ·add(SB),NOSPLIT,$<span class="hljs-number"><span class="hljs-number">0</span></span> MOVQ x+<span class="hljs-number"><span class="hljs-number">0</span></span>(FP), BX MOVQ y+<span class="hljs-number"><span class="hljs-number">8</span></span>(FP), BP ADDQ BP, BX MOVQ BX, ret+<span class="hljs-number"><span class="hljs-number">16</span></span>(FP) RET</code> </pre> <br><p>  The assembler version of the <code>add</code> function loads the variable x at the memory address <code>+0(FP)</code> into the <code>BX</code> register.  It then loads <code>y</code> from address <code>+8(FP)</code> into the <code>BP</code> register, adds <code>BP</code> and <code>BX</code> , saves the result to <code>BX</code> , and finally copies <code>BX</code> to <code>+16(FP)</code> and returns from the function.  The calling function, which pushes all the arguments onto the stack, will read the return value, from where we left it. </p><br><h2 id="optimizaciya-funkcii-s-pomoschyu-assemblera">  Function optimization with assembler </h2><br><p>  It is not necessary to write a function in the assembler that adds two numbers, but why do you really need to use it? </p><br><p>  Suppose you have a bunch of vectors, and you want to multiply them by the transformation matrix.  Perhaps the vectors are points, and you <a href="http://blog.wolfire.com/2010/07/Linear-algebra-for-game-developers-part-3">want to move them in space</a> <em>( <a href="https://habrahabr.ru/post/131931/">translation on Habré</a> - approx. Lane.)</em> .  We will use vectors with a 4x4 transformation matrix. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> V4 [<span class="hljs-number"><span class="hljs-number">4</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> M4 [<span class="hljs-number"><span class="hljs-number">16</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">M4MultiplyV4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m M4, v V4)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">V4</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> V4{ v[<span class="hljs-number"><span class="hljs-number">0</span></span>]*m[<span class="hljs-number"><span class="hljs-number">0</span></span>] + v[<span class="hljs-number"><span class="hljs-number">1</span></span>]*m[<span class="hljs-number"><span class="hljs-number">4</span></span>] + v[<span class="hljs-number"><span class="hljs-number">2</span></span>]*m[<span class="hljs-number"><span class="hljs-number">8</span></span>] + v[<span class="hljs-number"><span class="hljs-number">3</span></span>]*m[<span class="hljs-number"><span class="hljs-number">12</span></span>], v[<span class="hljs-number"><span class="hljs-number">0</span></span>]*m[<span class="hljs-number"><span class="hljs-number">1</span></span>] + v[<span class="hljs-number"><span class="hljs-number">1</span></span>]*m[<span class="hljs-number"><span class="hljs-number">5</span></span>] + v[<span class="hljs-number"><span class="hljs-number">2</span></span>]*m[<span class="hljs-number"><span class="hljs-number">9</span></span>] + v[<span class="hljs-number"><span class="hljs-number">3</span></span>]*m[<span class="hljs-number"><span class="hljs-number">13</span></span>], v[<span class="hljs-number"><span class="hljs-number">0</span></span>]*m[<span class="hljs-number"><span class="hljs-number">2</span></span>] + v[<span class="hljs-number"><span class="hljs-number">1</span></span>]*m[<span class="hljs-number"><span class="hljs-number">6</span></span>] + v[<span class="hljs-number"><span class="hljs-number">2</span></span>]*m[<span class="hljs-number"><span class="hljs-number">10</span></span>] + v[<span class="hljs-number"><span class="hljs-number">3</span></span>]*m[<span class="hljs-number"><span class="hljs-number">14</span></span>], v[<span class="hljs-number"><span class="hljs-number">0</span></span>]*m[<span class="hljs-number"><span class="hljs-number">3</span></span>] + v[<span class="hljs-number"><span class="hljs-number">1</span></span>]*m[<span class="hljs-number"><span class="hljs-number">7</span></span>] + v[<span class="hljs-number"><span class="hljs-number">2</span></span>]*m[<span class="hljs-number"><span class="hljs-number">11</span></span>] + v[<span class="hljs-number"><span class="hljs-number">3</span></span>]*m[<span class="hljs-number"><span class="hljs-number">15</span></span>], } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []V4, m M4)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, v := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> data { data[i] = M4MultiplyV4(m, v) } }</code> </pre> <br><p>  Execution takes 140 ms for 128 MB of data.  Which implementation can be faster?  The standard is copying memory, which takes about 14 ms. </p><br><p>  The following is a version of the function, written in assembler using SIMD instructions for performing multiplications, allowing you to multiply four 32-bit floating-point numbers in parallel: </p><br><pre> <code class="go hljs">#include <span class="hljs-string"><span class="hljs-string">"textflag.h"</span></span> <span class="hljs-comment"><span class="hljs-comment">// func multiply(data []V4, m M4) // //     FP // +0  data, ptr // +8  data, len // +16  data, cap // +24 m[0] | m[1] // +32 m[2] | m[3] // +40 m[4] | m[5] // +48 m[6] | m[7] // +56 m[8] | m[9] // +64 m[10] | m[11] // +72 m[12] | m[13] // +80 m[14] | m[15] TEXT ·multiply(SB),NOSPLIT,$0 // data ptr MOVQ data+0(FP), CX // data len MOVQ data+8(FP), SI //   data MOVQ $0, AX //  ,    CMPQ AX, SI JE END //    128- xmm- (https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions#Registers) //  [m[0], m[1], m[2], m[3]]  xmm0 MOVUPS m+24(FP), X0 //  [m[4], m[5], m[6], m[7]]  xmm1 MOVUPS m+40(FP), X1 //  [m[8], m[9], m[10], m[11]]  xmm2 MOVUPS m+56(FP), X2 //  [m[12], m[13], m[14], m[15]]  xmm3 MOVUPS m+72(FP), X3 LOOP: //       xmm //  data[i][0] (x)  xmm4 MOVSS 0(CX), X4 //  data[i][1] (y)  xmm5 MOVSS 4(CX), X5 //  data[i][2] (z)  xmm6 MOVSS 8(CX), X6 //  data[i][3] (w)  xmm7 MOVSS 12(CX), X7 //       // [0, 0, 0, x] =&gt; [x, x, x, x] SHUFPS $0, X4, X4 // [0, 0, 0, y] =&gt; [y, y, y, y] SHUFPS $0, X5, X5 // [0, 0, 0, z] =&gt; [z, z, z, z] SHUFPS $0, X6, X6 // [0, 0, 0, w] =&gt; [w, w, w, w] SHUFPS $0, X7, X7 // xmm4 = [m[0], m[1], m[2], m[3]] .* [x, x, x, x] MULPS X0, X4 // xmm5 = [m[4], m[5], m[6], m[7]] .* [y, y, y, y] MULPS X1, X5 // xmm6 = [m[8], m[9], m[10], m[11]] .* [z, z, z, z] MULPS X2, X6 // xmm7 = [m[12], m[13], m[14], m[15]] .* [w, w, w, w] MULPS X3, X7 // xmm4 = xmm4 + xmm5 ADDPS X5, X4 // xmm4 = xmm4 + xmm6 ADDPS X6, X4 // xmm4 = xmm4 + xmm7 ADDPS X7, X4 // data[i] = xmm4 MOVNTPS X4, 0(CX) // data++ ADDQ $16, CX // i++ INCQ AX // if i &gt;= len(data) break CMPQ AX, SI JLT LOOP END: //     (Non-Temporal) SSE- (MOVNTPS) // ,         (  SFENCE) SFENCE RET</span></span></code> </pre> <br><p>  This implementation takes 18 ms, so it is pretty close to the copy speed of the memory.  The best optimization might be to run such things on the GPU, not on the CPU, because the GPU is really good at it. </p><br><p>  Operating time for various programs, including the inline version of Go and the assembler implementation without SIMD (with links to the source code): </p><br><table><thead><tr><th>  Program </th><th>  Time, ms </th><th>  Acceleration </th></tr></thead><tbody><tr><td>  <a href="https://gist.github.com/win0err/de4d4e83c2f4dfe5ca72c4c777b076ba">Original</a> , <a href="">zip</a> </td><td>  140 </td><td>  1x </td></tr><tr><td>  <a href="https://gist.github.com/win0err/3f65f7d60ac28dedcfc47c7dbf1ba3a6">Inline version</a> , <a href="">zip</a> </td><td>  69 </td><td>  2x </td></tr><tr><td>  <a href="https://gist.github.com/win0err/5de6adb530c70d9f5da05078b272ddd8">Assembler</a> , <a href="">zip</a> </td><td>  43 </td><td>  3x </td></tr><tr><td>  <a href="https://gist.github.com/win0err/a613d6194c9d4fde7b821e64836faf42">Assembly with SIMD</a> , <a href="">zip</a> </td><td>  17 </td><td>  8x </td></tr><tr><td>  <a href="https://gist.github.com/win0err/18bb29aa1d32733360cfa03aa47af499">Copy memory</a> , <a href="">zip</a> </td><td>  15 </td><td>  9x </td></tr></tbody></table><br><p>  The cost of optimization will be the complexity of the code, which simplifies the operation of the machine.  Writing a program in assembler is a complicated optimization method, but sometimes it is the best available method. </p><br><h2 id="zamechaniya-po-realizacii">  Implementation notes </h2><br><p>  The author developed assembly parts mainly in C and 64-bit assembler using Xcode, and then ported them to Go format.  Xcode has a good debugger that allows you to check the values ​​of the processor registers while the program is running.  If you include an assembly .s file in an Xcode project, the IDE will compile it and link it to the desired executable file. </p><br><p>  The author used the <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">Intel x64 instruction set guide</a> and <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">the Intel Intrinsics manual</a> to figure out which instructions to use.  Converting to assembly language Go is not always easy, but many 64-bit assembly instructions are listed in <a href="">x86 / anames.go</a> , and if not, they can be <a href="https://golang.org/doc/asm">encoded directly</a> with a binary representation. </p><br><hr><br><h2 id="primechanie-perevodchika">  Translator's Note </h2><br><p>  The original article does not include the header <code>#include "textflag.h"</code> in the assembler files, which is why the compile-time error is <code>illegal or missing addressing mode for symbol NOSPLIT</code> . <br>  Therefore I uploaded the corrected versions on GitHub Gist.  To start, unpack the archive, execute the following commands: <code>chmod +x run.sh &amp;&amp; ./run.sh</code> . </p><br><p>  It is possible to run code with an assembler only by assembling a binary with the help of <code>go build</code> , otherwise the compiler will crash onto the empty function body. </p><br><p>  Unfortunately, there is really little information on the Internet on assembler in Go.  I advise you to read <a href="https://habrahabr.ru/company/badoo/blog/317864/">an article on Habré about the assembly language Go</a> . </p><br><h3 id="eschyo-odin-sposob-ispolzovat-assemblernye-vstavki-v-go">  Another way to use assembler inserts in Go </h3><br><p>  As you know, Go supports the use of code written in C. Therefore, nothing prevents to do this: </p><br><p>  <strong>sqrt.h:</strong> </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { __asm__ (<span class="hljs-string"><span class="hljs-string">"fsqrt"</span></span> : <span class="hljs-string"><span class="hljs-string">"+t"</span></span> (x)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br><p>  <strong>sqrt.go:</strong> </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-comment"><span class="hljs-comment">/* #include "sqrt.h" */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%f\n"</span></span>, C.sqrt(C.double(<span class="hljs-number"><span class="hljs-number">16</span></span>))) }</code> </pre> <br><p>  And run: </p><br><pre> <code class="bash hljs">$ go run sqrt.go 4.000000</code> </pre> <br><p>  Assembler is fun! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/349384/">https://habr.com/ru/post/349384/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349374/index.html">Script Editor Age of Empires 2 can be turned into a Turing machine</a></li>
<li><a href="../349376/index.html">Game development for NES in C. Chapters 11-13. We write and debug a simple platformer</a></li>
<li><a href="../349378/index.html">Security Operations: protection against cyber threats in ServiceNow</a></li>
<li><a href="../349380/index.html">Angular 5: Unit tests</a></li>
<li><a href="../349382/index.html">DigiCert bought Symantec Website Security: implications for users of SSL / TLS certificates</a></li>
<li><a href="../349386/index.html">Team Leader. To be or not to be, that is the question</a></li>
<li><a href="../349388/index.html">We forward Steam API calls from Wine to GNU / Linux and back with Nim</a></li>
<li><a href="../349392/index.html">Sublime Text 3 is alive. (Setup and operation)</a></li>
<li><a href="../349394/index.html">The release of the first beta cross-platform XAML UI-toolkit Avalonia</a></li>
<li><a href="../349396/index.html">Configuring VoIP GSM Gateway Yeastar Neogate TGXXX Series for 3CX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>