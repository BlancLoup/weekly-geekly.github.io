<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Performance consoles and shells</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is a good MSR demo from 2012 that shows the effect of response time when working on a tablet . If you do not want to watch three minutes of vide...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Performance consoles and shells</h1><div class="post__text post__text-html js-mediator-article">  There is a <a href="https://www.youtube.com/watch%3Fv%3DvOvQCPLkPt4">good MSR demo from 2012 that shows the effect of response time when working on a tablet</a> .  If you do not want to watch three minutes of video, they essentially created a device that simulates arbitrary delays up to a fraction of a millisecond.  A delay of 100 ms (0.1 seconds), typical of modern tablets, looks terrible.  At 10 ms (0.01 seconds), the delay is noticeable, but you can already work normally, and at a delay of less than 1 ms, everything is just perfect - as if you are writing in pencil on paper.  If you want to check it yourself, take any Android tablet with a stylus and compare it with the current generation iPad Pro with the Apple stylus.  The Apple device has a response time much more than 10 ms, but the difference is still cardinal - it‚Äôs such that I really use the new iPad Pro to write notes and draw diagrams, while I consider Android tablets completely unacceptable as a replacement for pencil and paper. <br><br>  Something similar you will see in VR helmets with different delays.  <a href="http://oculusrift-blog.com/john-carmacks-message-of-latency/682/">20 ms looks fine, 50 ms lags, and 150 ms is already unbearable</a> . <br><br>  Strange, but rarely do you hear complaints about keyboard or mouse input latency.  It would seem that the reason may be that keyboard and mouse input is very fast - and it happens almost instantly.  Often I am told that this is the way it is, but I think the situation is completely reversed.  The idea that computers respond quickly to data entry ‚Äî so quickly that people don‚Äôt notice the difference ‚Äî the most common misconception I've heard from professional programmers. <br><a name="habracut"></a><br>  When testers measure real latency from start to finish in games on normal computer configurations, it usually turns out that the delay is in <a href="http://renderingpipeline.com/2013/09/measuring-input-latency/">the</a> <a href="https://www.youtube.com/watch%3Fv%3DGxaEJY-zd_4%26index%3D5%26list%3DPLfOoCUS0PSkXVGjhB63KMDTOT5sJ0vWy8%26t%3D187s">100 ms</a> <a href="http://renderingpipeline.com/2013/09/measuring-input-latency/">range</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you look at the <a href="http://renderingpipeline.com/2013/09/measuring-input-latency/">distribution of the delay in the gaming pipeline, which Robert Menzel did</a> , then it‚Äôs easy to understand where 100+ ms come from: <br><br><ul><li>  ~ 2 ms (mouse) </li><li>  8 ms (average waiting time for the game input to start) </li><li>  16.6 (game simulation) </li><li>  16.6 (rendering code) </li><li>  16.6 (GPU draws the previous frame, the current frame is cached) </li><li>  16.6 (GPU rendering) </li><li>  8 (average mismatch time by vsync) </li><li>  16.6 (frame cache in display) </li><li>  16.6 (frame redrawing) </li><li>  5 (switching pixels) </li></ul><br>  Please note that it is supposed to use a gaming mouse and a fairly decent LCD display;  but in practice it is often possible to see a much greater delay in the mouse and switching pixels. <br><br>  You can configure the system and fit into the range of 40 ms, but the vast majority of users do not.  And even if they do, it is still very far from the range of 10-20 ms, in which the tablets and VR helmets start to behave ‚Äúas they should‚Äù. <br><br>  Measuring the delay between pressing a key and displaying it is usually done in games, because it‚Äôs more important to gamers than most other people, but I don‚Äôt think that most other applications are very different from games in response time.  Although games usually do more work on each frame than "typical" applications, they are also much better optimized.  Menzel allocates a game budget of 33 ms, including half for game logic and half for rendering.  What is the response time in non-gaming applications?  Pavel Fatin measured it in text editors and found delays <a href="https://pavelfatin.com/typing-with-pleasure/">from a few milliseconds to hundreds of milliseconds</a> - and he <a href="https://github.com/pavelfatin/typometer">wrote a special application for taking measurements</a> , which we can also use to evaluate other applications.  Here <a href="https://docs.oracle.com/javase/7/docs/api/java/awt/Robot.html">java.awt.Robot is</a> used to generate keystrokes and capture the screen. <br><br>  Personally, for certain reasons, I would like to look at the response time of different consoles and shells.  First, I spend a significant part of my time on the console and usually edit it, so the input delays here are partially related to the console.  Secondly, most often (about two orders of magnitude more often) the speed of text output is given as a benchmark of consoles, often measured by running <code>cat</code> on a large file.  It seems to me that this is a rather useless benchmark.  I can not remember when the task I performed was last limited by the speed of processing the file with the <code>cat</code> and issuing <code>stdout</code> to the console (well, unless I use eshell in emacs).  And I cannot imagine a single task for which such a specialized dimension would be useful.  The immediate task that could be important for me is the execution speed of the <code>^C</code> interrupt command when I accidentally sent too much output to <code>stdout</code> .  But as we will see from actual measurements, the ability of the console to absorb a large amount of input data with output to <code>stdout</code> very weak about the response time on <code>^C</code>  The scrolling speed of the whole page up and down seems to be relevant, but in real dimensions these two parameters do not correlate much (for example, emacs-eshell scrolls quickly, but extremely slowly absorbs <code>stdout</code> ).  What else I care about is the response time, but the information that a particular console quickly processes <code>stdout</code> says little about its response time. <br><br>  Let's look at the response time in some consoles - does any of them add a noticeable delay?  If you measure the response time from pressing a key to the internal screen capture on my laptop, then for different consoles the delays are as follows: <br><br> <a href=""><img src="https://habrastorage.org/webt/ms/d6/8d/msd68dvpwn8mqnpvqvxmhdmts2q.png"></a> <br><br>  These graphs show the distribution of delays for different consoles.  On the vertical axis - the delay in milliseconds.  The horizontal axis is the percentile (for example, 50 means that 50% of the data are below the 50th percentile, that is, the median average press).  Measurements are taken at macOS, unless otherwise noted.  The graph on the left corresponds to the unloaded machine, and on the right - under load.  If you look only at the median averages, then some terminals look good - terminal.app and emacs-eshell are approximately around 5 ms on an unloaded system.  This is small enough for most people not to notice the delay.  But most consoles (st, alacritty, hyper and iterm2) are in a range <a href="https://pdfs.semanticscholar.org/386a/15fd85c162b8e4ebb6023acdce9df2bd43ee.pdf">where users</a> <a href="http://www.tactuallabs.com/papers/howMuchFasterIsFastEnoughCHI15.pdf">can</a> already <a href="http://www.tactuallabs.com/papers/howMuchFasterIsFastEnoughCHI15.pdf">notice an additional delay</a> even on an unloaded system.  If you look at the tail of the graph, say, the response for the 99.9th percentile, then all consoles fall into the range where the additional delay should be noticeable, according to user perception research.  For comparison, the delay between the internally generated keystrokes and the memory of the GPU for some consoles exceeds <a href="http://ipnetwork.bgtmo.ip.att.net/pws/network_delay.html">the travel time of the package from Boston to Seattle <i>and back</i></a> , which is about 70 ms. <br><br>  All measurements were taken when testing each console individually, on a full battery without power from the A / C cable.  Measurements under load were made during Rust compilation (as before, on a full battery without power from the A / C cable, and for the sake of reproducibility, each measurement started 15 seconds after a clean Rust build after downloading all dependencies, with sufficient time between tests to avoid interference from thermoregulation between tests). <br><br>  If you look at the average median latency under load, then apart from emacs-term, the results of the other consoles are not much worse than on an unloaded machine.  However, at the tail of the graph, like the 90th percentile or the 99.9th, each console becomes much less responsive.  Switching from macOS to Linux does not change the picture too much, although on different consoles in different ways. <br><br>  These results are much better than the worst scenario (on low battery, if you wait 10 minutes from the start of compilation to aggravate interference due to thermal control, there are also delays in hundreds of milliseconds), but even so, each console should have a delay in the tail of the graph be noticeable to man.  Also remember that this is only a fraction of the total response time from the beginning to the end of the input and output processing pipeline. <br><br>  Why don't people complain about the delay between keyboard input and screen output as they complain about the delay when drawing with a stylus or VR helmets?  My theory is that for VR and tablets people have a lot of experience in similar ‚Äúapplications‚Äù with much less delay.  For tablets, this ‚Äúapplication‚Äù is a pencil and paper, and for virtual reality - the ordinary world around, in which we also turn our heads, but only without a VR helmet.  But the response time between keyboard input and screen output is so long in all applications that most people just take a big delay as a given. <br><br>  An alternative theory may be that keyboard and mouse input is fundamentally different from tablet input, which makes the delay less noticeable.  Even without my data, this theory seems implausible, because when I connect through a remote terminal with dozens of extra milliseconds, I feel a noticeable lag when I press the keys.  And it is known that when adding additional delay in A / B testing, <a href="http://forums.blurbusters.com/viewtopic.php%3Ff%3D10%26t%3D1134">people may notice, and indeed notice, a delay in the range that we discussed earlier</a> . <br><br>  So, if we want to compare the most popular benchmark (stdout performance) with a delay in different consoles, then let's measure how quickly different consoles process input data for output to stdout: <br><br><table><thead><tr><th>  Console </th><th>  stdout <br>  (MB / s) </th><th>  idle50 <br>  (ms) </th><th>  load50 <br>  (ms) </th><th>  idle99.9 <br>  (ms) </th><th>  load99.9 <br>  (ms) </th><th>  mem <br>  (MB) </th><th>  ^ C </th></tr></thead><tbody><tr><td>  alacritty </td><td>  39 </td><td>  31 </td><td>  28 </td><td>  36 </td><td>  56 </td><td>  18 </td><td>  ok </td></tr><tr><td>  terminal.app </td><td>  20 </td><td>  6 </td><td>  13 </td><td>  25 </td><td>  thirty </td><td>  45 </td><td>  ok </td></tr><tr><td>  st </td><td>  14 </td><td>  25 </td><td>  27 </td><td>  63 </td><td>  111 </td><td>  2 </td><td>  ok </td></tr><tr><td>  alacritty tmux </td><td>  14 </td></tr><tr><td>  terminal.app tmux </td><td>  13 </td></tr><tr><td>  iterm2 </td><td>  eleven </td><td>  44 </td><td>  45 </td><td>  60 </td><td>  81 </td><td>  24 </td><td>  ok </td></tr><tr><td>  hyper </td><td>  eleven </td><td>  32 </td><td>  31 </td><td>  49 </td><td>  53 </td><td>  178 </td><td>  fail </td></tr><tr><td>  emacs-eshell </td><td>  0.05 </td><td>  five </td><td>  13 </td><td>  17 </td><td>  32 </td><td>  thirty </td><td>  fail </td></tr><tr><td>  emacs-term </td><td>  0.03 </td><td>  13 </td><td>  thirty </td><td>  28 </td><td>  49 </td><td>  thirty </td><td>  ok </td></tr></tbody></table><br>  The relationship between <code>stdout</code> performance and how fast the console looks like is not obvious.  In this test, terminal.app outwardly looked very bad.  When scrolling, the text moved in spurts, as if the screen was rarely updated.  Problems were also observed in hyper and emacs-term.  Emacs-term did not have time to issue at all - after the end of the test it took him a few seconds to update to the end (the status bar, which shows the number of lines left, seemed to be relevant, so the number stopped increasing until the end of the test).  Hyper has lagged behind even more and, having blinked a couple of times, practically did not update the screen.  The <code>Hyper Helper</code> process was artificially supported with a 100% CPU load for about two minutes, and the console was completely unresponsive to actions all the time. <br><br>  Alacritty was tested with the tmux manager, since this console does not support scrolling back up, and the documentation states that tmux should be used for this.  Just for comparison, terminal.app was also tested with tmux.  Most tmux consoles do not seem to reduce <code>stdout</code> speed, but alacritty and terminal.app were fast enough so that in reality their performance is still limited by tmux speed. <br><br>  Emacs-eshell is not technically a console, but I also tested eshell, because in some cases this program can be used as a console replacement.  In fact, Emacs, both with eshell and with term, turned out to be so slow that it doesn't matter with what speed it actually produces <code>stdout</code> .  In the past, when using eshell or term, I sometimes had to wait for a few thousand lines of text to scroll if I ran a command with detailed logging in <code>stdout</code> or <code>stderr</code> .  Since this happens quite rarely, for me it is not too big a problem until the delay reaches 0.5 or 1 second, although everything works fine on any other console. <br><br>  Conversely, I type characters fast enough to notice the delay of the long tail.  For example, if I type 120 words per minute, that is, 10 characters per second, then the tail from the 99.9th percentile (1 out of 1000) will appear every 100 seconds! <br><br>  In any case, instead of a ‚Äúbenchmark,‚Äù <code>cat</code> cares more about whether I can interrupt the process in <code>^C</code> if I accidentally run a command with millions of lines of display on the screen instead of thousands of lines.  This test passes almost every console, except for hyper and emacs-eshell ‚Äî they both hang for at least ten minutes (after ten minutes I kill tasks and no longer wait for the process to finish). <br><br>  The table also includes the memory usage when loading the program, since I saw that this parameter is also often used by people when testing consoles.  Although it seems to me a little strange that the console can take 40 MB in memory when booting, but even on a three-year old laptop I have 16 GB of RAM installed, so optimizing this 40 MB to 2 MB doesn‚Äôt particularly affect the work with the program.  Damn, even on the "Chromebook" for $ 300, which we recently bought, installed 16 GB of RAM. <br><br><h1>  Conclusion </h1><br>  Most consoles have a fairly long response time, which can be optimized to improve the user experience of the program if the developers concentrated on this parameter, rather than adding new features or other aspects of performance.  But when I was looking for benchmarks of consoles, I found that if the authors of the programs measured the performance of something, <a href="https://github.com/jwilm/alacritty/issues/289">it was</a> either <a href="https://github.com/jwilm/alacritty/issues/205">the output speed in stdout</a> , or memory usage at boot.  This is unfortunate, since most of the "slow" consoles already give out <code>stdout</code> several orders of magnitude faster than people are able to understand, so further optimization of the speed of <code>stdout</code> relatively weak effect on the actual usability for most users.  The same can be said about the reduction in memory usage when booting, if the console uses 0.01% of memory on my old laptop or on a modern cheap model. <br><br>  If you are working in the console, then it may be more important for you to more optimize response time and interactivity (for example, the reaction to <code>^C</code> ) and relatively less optimization of bandwidth and memory usage when loading. <br><br>  <i>Update.</i>  <i>In response to this article, the <a href="https://github.com/jwilm/alacritty/issues/673">alacritty author explained where the alacrity delay comes from, and described how it can be reduced</a> .</i> <br><br><h1>  Appendix: negative results </h1><br>  Tmux and delay.  I experienced a tmux manager with different consoles and found that the difference is within the measurement error. <br><br>  Shell and delay.  I checked different shells, but even in the fastest console the difference between them was within the measurement error.  In my experimental setup, it was a bit difficult to check Powershell, because it incorrectly processes colors (the first typed character is typed in the color set in the console, but the other characters are yellow regardless of the settings, this bug <a href="https://github.com/lzybkr/PSReadLine/issues/472">seems to be closed</a> ), which knocks the image recognition setting, which I used.  <a href="https://www.youtube.com/watch%3Fv%3Dcz5Hczlzvio">Powershell also does not always place the cursor in the right place</a> - it randomly jumps along the line, which also knocks the image recognition setting.  But despite these problems, Powershell performance is quite comparable with other shells. <br><br>  Wrappers and bandwidth stdout.  As in the previous cases, the difference between different shells is within the measurement error. <br><br>  Single and multiline text and bandwidth.  Although some text editors work with extremely long lines, the bandwidth does not practically change, either I pushed a file with one such line into the console, or it was split into lines of 80 characters each. <br><br>  Block queue / data skip error.  I ran these tests at an input speed of 10.3 characters per second.  But it turned out that the input speed does not have a special effect on the delay.  Theoretically, the console can be overflowed, and hyper first began to fail at very high input speeds, but these speeds are much faster than text input in people I know. <br><br><h1>  Appendix: experimental setup </h1><br>  All tests were conducted on a mid-2014 dual-core Macbook Pro 13 ‚Äù2.6 GHz.  This machine has 16 GB of RAM and a screen resolution of 2560 √ó 1600 characters.  OS X version 10.12.5.  Some tests were conducted in Linux (Lubuntu 16.04) to compare macOS and Linux.  Each delay measurement was limited to 10 thousand keystrokes. <br><br>  The measurements were carried out by pressing a button <code>.</code>  with the output in the default encoding <code>base32</code> , that is, simple ASCII text.  George King noted that different types of text can affect the speed of issuing: <br><br><blockquote>  I noticed that Terminal.app dramatically slows down when issuing non-Latin encodings.  I think there may be three reasons for this: the need to load different pages of fonts, the need to parse code points outside the Basic Multilingual Plane (BMP) and characters in multibyte Unicode encoding. <br><br>  Probably, the first one comes down to a very complex combination of deferred loading of glyphs of fonts, calculating backup fonts and caching glyph pages or another way this is done. <br><br>  The second is a bit speculative, but I would suggest that Terminal.app uses Cocoa NSString based on UTF16, which almost certainly leads to a slowdown if the code points are higher than BMP due to surrogate pairs. </blockquote><br>  Consoles were deployed in full screen before running the tests.  This affects the result, and resizing the console window can significantly change performance (for example, you can make hyper much slower than iterm2 by changing the window size for all other constant factors).  st on macOS started as client X under XQuartz.  To check the version that XQuartz is inherently slow, I tried <a href="https://github.com/doy/runes/">runes</a> , another Linux native console that uses XQuartz.  It turned out that runes have a much smaller delay in the tail than st and iterm2. <br><br>  The delay tests on the ‚Äúunloaded‚Äù system were performed immediately after the system was rebooted.  All terminals were open, but the text was entered only in one of them. <br><br>  Tests "under load" were conducted during the background compilation of Rust, 15 seconds after the start of compilation. <br><br>  Console bandwidth tests were performed by creating a large file with pseudo-random text: <br><br> <code>timeout 64 sh -c 'cat /dev/urandom | base32 &gt; junk.txt'</code> <br> <br>  with the subsequent launch <br><br> <code>timeout 8 sh -c 'cat junk.txt | tee junk.term_name'</code> <br> <br>  Terminator and urxvt were not tested, since installing them on macOS is a non-trivial procedure and I did not want to bother trying to get them to work.  Terminator is easy to build from source, but it hangs up on boot and does not show the command line.  Urxvt is installed via brew, but one of its dependencies (which is also installed via brew) was the wrong version, which is why the console did not load. </div><p>Source: <a href="https://habr.com/ru/post/346054/">https://habr.com/ru/post/346054/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346038/index.html">Parsing with ANTLR 4 T-SQL snapshots to get connections between tables</a></li>
<li><a href="../346042/index.html">5-minute guide to esoteric programming languages: why they are needed</a></li>
<li><a href="../346048/index.html">[Translation] IOHIDeous - New Year's zero-day vulnerability from macOS</a></li>
<li><a href="../346050/index.html">Wake up, and your application is on the main in the App Store</a></li>
<li><a href="../346052/index.html">MikroTik and blocking unwanted sites (for example, youtube and facebook)</a></li>
<li><a href="../346058/index.html">Outputting tabular data to the console, file or MS Excel in the style of C ++ threads</a></li>
<li><a href="../346062/index.html">IaaS for non-IT companies: 10 answers to director's questions</a></li>
<li><a href="../346064/index.html">How to build a community. Translation of the book "Social Architecture": Preface. Crowd wisdom</a></li>
<li><a href="../346066/index.html">Github flow</a></li>
<li><a href="../346068/index.html">‚ÄúNot again, but again‚Äù: Sea-Me-We 3 submarine cable failed for the second time in a year</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>