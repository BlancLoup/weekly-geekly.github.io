<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DariaDB. Database development for storing time series</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For more than a year, as I have my own hobby project, in which I am developing a database engine for storing time series - dariadb. The task is quite ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DariaDB. Database development for storing time series</h1><div class="post__text post__text-html js-mediator-article"><p>  For more than a year, as I have my own hobby project, in which I am developing a database engine for storing time series - dariadb.  The task is quite interesting - there are complex algorithms and a completely new area for me.  During the year the engine itself was made, a small server for it and the client.  All this is written in C ++.  And if the client server is still in a fairly raw state, the engine has already gained some stability. The task of storing time series is fairly common where there are at least some measurements (from SCADA systems to server status monitoring). </p><a name="habracut"></a><br><p>  To solve this problem, there are a number of solutions of different degrees of tricking: </p><br><ul><li>  <a href="https://www.influxdata.com/">InfluxDB</a> </li><li>  <a href="http://oss.oetiker.ch/rrdtool/">Rrdtool</a> </li><li>  <a href="https://github.com/akumuli/Akumuli">Akumuli</a> </li><li>  SQL Server Based Enterprise Solutions </li></ul><br><p>  As an introductory article I can advise an article from FaceBook ‚Äú <a href="http://www.vldb.org/pvldb/vol8/p1816-teller.pdf">Gorilla: A Fast, Scalable, In-Memory Time Series Database</a> ‚Äù widely known in certain circles. </p><br><p>  The main task of dariadb was to create an embeddable solution that could be built (like SQLite) into your application and pass it on to storing, processing and analyzing time series.  At the moment, the tasks, reception, storage and processing of measurements have been completed.  The project is still of a research nature, so now it is not suitable for use in production.  Anyway, bye :) </p><br><h2 id="vremennoy-ryad-izmereniy">  Time series of measurements </h2><br><p>  The time series of measurements is a sequence of four {Time, Value, Id, Flag}, where </p><br><ul><li>  Time, measurement time (8 bytes) </li><li>  Value, itself stopped (8 bytes) </li><li>  Id, time series identifier (4 bytes) </li><li>  Flag, metering flag (4 bytes) </li></ul><br><p>  The flag is used only when reading.  There is a special flag ‚Äúno data‚Äù ( <strong>_NO_DATA</strong> = 0xffffffff), which is set for values ‚Äã‚Äãthat are not at all or do not satisfy the filter.  If the request for the flag field is not 0 (zero), then for each dimension that matches the request time, the logical AND operation is applied to its flag flag field; if the answer is equal to the filter, then the measurement passes.  The value comes in ascending order of the timestamp (but this is not necessary, sometimes you need to write down the value ‚Äúinto the past‚Äù), you need to be able to make a slice and query for intervals. </p><br><h2 id="chitaem-srez">  Read the slice </h2><br><p>  The cutoff of the value for the time series to the timestamp T is the value that exists at time T or ‚Äúto the left‚Äù of this time. We always return the left nearest, but only if we are satisfied with the flag.  If there is no value or the flag does not match, then ‚Äúno data‚Äù. <img src="https://raw.githubusercontent.com/lysevi/dariadb/master/doc/images/read_timepoint.png" alt="img"></p><br><p>  Here it is important to understand why exactly ‚Äúno data‚Äù is returned for values ‚Äã‚Äãthat did not fall under the flag.  It may happen that none of the stored values ‚Äã‚Äãfall under the flag, then it will lead to reading the entire repository.  Therefore, it was decided that if there is a value at the time of the cut, but the flag did not match, then we believe that there is no value. </p><br><h2 id="chitaem-interval">  Read interval. </h2><br><p>  Everything is much simpler: all values ‚Äã‚Äãthat fall in the time interval are returned.  Those.  the condition from &lt;= T &lt;= to should be satisfied, where T is the time of measurement. <img src="https://raw.githubusercontent.com/lysevi/dariadb/master/doc/images/read_interval.png" alt="img"></p><br><p>  If the measurement falls within the interval, but does not satisfy the flag, then it is rejected.  Data is always given to the user in ascending timestamp order. </p><br><h2 id="minmaksy-poslednie-znacheniya-statistika">  Minmaxes, latest values, statistics. </h2><br><p>  It is also possible to get for each time series its minimum and maximum time, which is recorded in the storage;  Last recorded value;  different statistics on the interval. </p><br><h1 id="bazovoe-ustroystvo-hranilischa">  Base storage device </h1><br><p>  The result was a project with the following characteristics: </p><br><ul><li>  Support unsorted values </li><li>  Values ‚Äã‚Äãthat are recorded in the repository can no longer be changed. </li><li>  Various writing strategies. </li><li>  Storage on a disk in the form of an LSM tree ( <a href="https://ru.wikipedia.org/wiki/LSM-%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">https://ru.wikipedia.org/wiki/LSM-%D0%B4%D0%B5%D1%80</a> %D0BB% D0%B2%D0% <a href="https://ru.wikipedia.org/wiki/LSM-%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">BE</a> ). </li><li>  High write speed: 2.5 - 3.5 million records per second when writing to disk;  7-9 million records per second when writing to memory. </li><li>  Recovery after failures. </li><li>  CRC32 for all compressed values. </li><li>  Two variants of data request: Functor API (async) - a callback function is transmitted for the request, which will be used for each value that is in the request.  Standard API - return values ‚Äã‚Äãas a list or dictionary. </li><li><p>  Statistics on the interval: time min / max;  min / max values ‚Äã‚Äãnumber of measurements;  sum of values </p><br><p>  The following layers are implemented: storage in RAM, storage on disk in log files, storage in compressed form. </p><br><p><img src="https://raw.githubusercontent.com/lysevi/dariadb/master/doc/images/storage.png" alt="img"></p><br></li></ul><br><h2 id="log-fayly-wal">  Log files (* .wal) </h2><br><p>  These are just log files.  A small buffer is kept in memory, when filled, it is sorted and flushed to disk.  The maximum size of the buffer and the file is regulated by the settings (see below).  With requests, the entire file is read and the values ‚Äã‚Äãin the request are given to the user.  No indexes and markers to speed up the search, just a log file.  The file name is formed from the creation time of this file in microseconds + extension (wal). </p><br><h2 id="szhatye-stranicy-page">  Compressed pages (* .page) </h2><br><p>  Pages are obtained by compressing log files and their name is the same as the log file from which the page was obtained.  If at startup we find that there are pages with the same name (excluding the extension) as the log file, then we conclude that the storage was not stopped in the normal way, the page is deleted and compression is repeated again. These files are already better optimized for reading.  They consist of sets of chunks, each chunk stores sorted and compressed values ‚Äã‚Äãfor one time series, the maximum chunk size is limited by settings.  At the end of the file is the footer, which stores the minmax of the time, the bloom filter for the id of the time series in the file, statistics for the stored time series. </p><br><p><img src="https://raw.githubusercontent.com/lysevi/dariadb/master/doc/images/page.png" alt="img"></p><br><p>  An index file is created for each page.  The index file contains a set of minmaks of time for each chunk in the page, the id of the time series, the position in the page.  Thus, when querying for an interval or a slice, we just need to find the necessary chunks in the index file and subtract them from the page. In each chunk, the values ‚Äã‚Äãare stored in a compressed form.  Each measurement field has its own algorithm (inspired by the famous article ‚ÄúGorilla: A Fast, Scalable, In-Memory Time Series Database‚Äù): </p><br><ul><li><p>  DeltaDelta - for time </p><br></li><li><p>  Xor - for the values ‚Äã‚Äãthemselves </p><br></li><li><p>  LEB128 - for flags </p><br><p>  As a result, compression on different data reaches up to 3 times. </p><br><p>  Index file footers are always in the cache and are used to quickly search for the necessary pages to display results. </p><br></li></ul><br><h2 id="hranenie-v-pamyati">  Memory storage </h2><br><p>  In memory, each time series is stored in a list (a simple std :: list from stl) chunks, and for a quick search, a B + tree is built over all of this, built on the maximum time of each chunk.  Thus, when requesting an interval or a slice, we simply find chunks that contain the data we need, unpack them and return them.  Storage in memory is limited in maximum size, i.e.  if we write too vigorously into it, the limit will end quickly and then everything will go according to the scenario determined by the storage strategy </p><br><h2 id="ctrategii-hraneniya">  Storage strategies </h2><br><ol><li><p>  WAL - data is written only to log files, clipping to pages does not automatically start, but it is possible to start compression of all log files manually. </p><br></li><li><p>  COMPRESSED - data is written to the log files, but as soon as the file reaches the limit (see settings), a new file is created next to it, and the old one is put in a queue for compression. </p><br></li><li><p>  MEMORY - everything is written into memory, as soon as we reach the limit, the oldest chunks are starting to be flushed to disk. </p><br></li><li> CACHE - we write both to memory and to disk.  This strategy gives a write speed like that of COMPRESSED, but a quick search for fresh recently recorded data.  For this, the memory limit is also relevant, if we reach it, the old chunks are simply deleted. </li></ol><br><h2 id="pereupakovka-i-zapis-v-proshloe">  Repacking and writing to the past. </h2><br><p>  It is possible to record data in any order.  If the MEMORY strategy and we are writing to the past, which is still in memory, then we will simply add new data to the existing chunk.  If we write so far into the past that this time is no longer in memory, or the storage strategy is not MEMORY, then the data will be written to the current chunk, but when reading the data, the k-merge algorithm will be used, which slows down the reading a little if There are many such chunks.  To avoid this, there is a call to repack, which repackages pages, removing duplicates and sorting data in ascending order of time.  At the same time, pages collapse so that at each level there are no more pages than specified by the settings (LSM is a tree). </p><br><h2 id="sozdanie-vremennogo-ryada">  Creating a time series </h2><br><p>  The selection of an identifier for a time series can be implemented independently, or it can be assigned to dariadb - the ability to create named time series is implemented, then by name you can get an identifier, and it can be registered in the desired measurement.  It is easier than it seems.  In any case, if you record a measurement, but it is not described in the file with time series (it is created automatically during storage initialization), then the measurement will be recorded without any problems. </p><br><h2 id="nastroyki">  Settings </h2><br><p>  Settings can be set through the Settings class (see example below).  The following settings are available: </p><br><ol><li>  wal_file_size - the maximum size of the log file in dimensions (not in bytes!). </li><li>  wal_cache_size is the size of the buffer in memory, to which measurements are written, before getting into the log file. </li><li>  chunk_size - the size of the chunk in bytes. strategy - the storage strategy. </li><li>  memory_limit is the maximum amount of memory used by the storage in RAM. </li><li>  percent_when_start_droping ‚Äî The percentage of the RAM‚Äôs memory full of storage when the reset of chunks begins. </li><li>  percent_to_drop - how many percent of memory should be cleared when we reached the limit of memory. </li><li>  max_pages_in_level - the maximum number of pages (.page) at each level. </li></ol><br><h1 id="itogovye-benchmarki">  Final benchmarks </h1><br><p>  I will give speed characteristics on typical tasks. </p><br><h2 id="usloviya">  Conditions: </h2><br><p>  2 streams write 50 time series, in each row of measurement for 2 days.  Measurement frequency - 2 measurements per second.  As a result, we get 2000000 measurements.  Machine Intel core i5 2.8 760 @ GHz, 8 Gb ram, hard disk WDC WD5000AAKS, Windows 7 </p><br><h3 id="srednyaya-skorost-zapisi-v-sekundu">  Average write speed per second: </h3><br><table><thead><tr><th>  WAL, zp / sec </th><th>  Compressed, zp / sec </th><th>  MEMORY, Zap / sec </th><th>  CACHE, ZP / s </th></tr></thead><tbody><tr><td>  2.600.000 </td><td>  420.000 </td><td>  5,000,000 </td><td>  420.000 </td></tr></tbody></table><br><h3 id="chtenie-sreza">  Reading the slice. </h3><br><p>  N random time series is selected, for each there is a time at which exactly there are values ‚Äã‚Äãand a slice is requested for a random time in this interval. </p><br><table><thead><tr><th>  WAL, sec </th><th>  Compressed, sec </th><th>  MEMORY, sec </th><th>  CACHE, sec </th></tr></thead><tbody><tr><td>  0.03 </td><td>  0.02 </td><td>  0.005 </td><td>  0.04 </td></tr></tbody></table><br><h3 id="vremya-chtenie-intervala-za-2-e-sutok-dlya-vseh-znacheniy">  Time reading interval for 2 days for all values: </h3><br><table><thead><tr><th>  WAL, sec </th><th>  Compressed, sec </th><th>  MEMORY, sec </th><th>  CACHE, sec </th></tr></thead><tbody><tr><td>  13 </td><td>  13 </td><td>  0.5 </td><td>  five </td></tr></tbody></table><br><h3 id="chtenie-intervala-za-sluchaynyy-promezhutok-vremeni">  Read interval for a random amount of time </h3><br><table><thead><tr><th>  WAL, z / a </th><th>  Compressed, z / a </th><th>  MEMORY, zap / s </th><th>  CACHE, z / a </th></tr></thead><tbody><tr><td>  2.043.925 </td><td>  2.187.507 </td><td>  27.469.500 </td><td>  20.321.500 </td></tr></tbody></table><br><h1 id="kak-vse-sobrat-i-poprobovat">  How to collect and try everything. </h1><br><p>  The project was immediately thought of as cross-platform, its development goes on windows and ubuntu / linux.  Compilers gcc-6 and msvc-14 are supported.  Building via clang is not supported yet. </p><br><h2 id="zavisimosti">  Dependencies </h2><br><p>  On Ubuntu 14.04, you need to connect ppa ubuntu-toolchain-r-test: </p><br><pre><code class="bash hljs">$ sudo add-apt-repository -y ppa:ubuntu-toolchain-r/<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> $ sudo apt-get update $ sudo apt-get install -y libboost-dev libboost-coroutine-dev libboost-context-dev libboost-filesystem-dev libboost-test-dev libboost-program-options-dev libasio-dev libboost-log-dev libboost-regex-dev libboost-date-time-dev cmake g++-6 gcc-6 cpp-6 $ <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CC=<span class="hljs-string"><span class="hljs-string">"gcc-6"</span></span> $ <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CXX=<span class="hljs-string"><span class="hljs-string">"g++-6"</span></span></code> </pre> <br><h3 id="primer-ispolzovanie-v-kachestve-vstraivaemogo-proekta-httpsgithubcomlysevidariadb-example">  An example of using as an embedded project ( <a href="https://github.com/lysevi/dariadb-example">https://github.com/lysevi/dariadb-example</a> ) </h3><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/lysevi/dariadb-example $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> dariadb-example $ git submodule update --init --recursive $ cmake .</code> </pre> <br><h2 id="sborka-proekta-u-razrabotchika">  Build the project from the developer </h2><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/lysevi/dariadb.git $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> dariadb $ git submodules init $ git submodules update $ cmake .</code> </pre> <br><h2 id="zapusk-testov">  Running tests </h2><br><pre> <code class="bash hljs">$ ctest --verbose .</code> </pre> <br><h1 id="primer">  Example </h1><br><h2 id="sozdanie-hranilischa-i-napolnenie-znacheniyami">  Creation of storage and filling with values </h2><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;libdariadb/dariadb.h&gt; #include &lt;libdariadb/utils/fs.h&gt; int main(int, char **) { const std::string storage_path = "exampledb"; //   ,    if (dariadb::utils::fs::path_exists(storage_path)) { dariadb::utils::fs::rm(storage_path); } //  .     auto settings = dariadb::storage::Settings::create(storage_path); settings-&gt;save(); //   . p1  p2    //  auto scheme = dariadb::scheme::Scheme::create(settings); auto p1 = scheme-&gt;addParam("group.param1"); auto p2 = scheme-&gt;addParam("group.subgroup.param2"); scheme-&gt;save(); //  . auto storage = std::make_unique&lt;dariadb::Engine&gt;(settings); auto m = dariadb::Meas(); auto start_time = dariadb::timeutil::current_time(); //    //           // [currentTime:currentTime+10] m.time = start_time; for (size_t i = 0; i &lt; 10; ++i) { if (i % 2) { m.id = p1; } else { m.id = p2; } m.time++; m.value++; m.flag = 100 + i % 2; auto status = storage-&gt;append(m); if (status.writed != 1) { std::cerr &lt;&lt; "Error: " &lt;&lt; status.error_message &lt;&lt; std::endl; } } }</span></span></span></span></code> </pre> <br><h2 id="otkrytie-hranilischa-i-chtenie-intervala">  Opening storage and reading interval. </h2><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;libdariadb/dariadb.h&gt; #include &lt;iostream&gt; //       void print_measurement(dariadb::Meas&amp;measurement){ std::cout &lt;&lt; " id: " &lt;&lt; measurement.id &lt;&lt; " timepoint: " &lt;&lt; dariadb::timeutil::to_string(measurement.time) &lt;&lt; " value:" &lt;&lt; measurement.value &lt;&lt; std::endl; } void print_measurement(dariadb::Meas&amp;measurement, dariadb::scheme::DescriptionMap&amp;dmap) { std::cout &lt;&lt; " param: " &lt;&lt; dmap[measurement.id] &lt;&lt; " timepoint: " &lt;&lt; dariadb::timeutil::to_string(measurement.time) &lt;&lt; " value:" &lt;&lt; measurement.value &lt;&lt; std::endl; } class QuietLogger : public dariadb::utils::ILogger { public: void message(dariadb::utils::LOG_MESSAGE_KIND kind, const std::string &amp;msg) override {} }; class Callback : public dariadb::IReadCallback { public: Callback() {} void apply(const dariadb::Meas &amp;measurement) override { std::cout &lt;&lt; " id: " &lt;&lt; measurement.id &lt;&lt; " timepoint: " &lt;&lt; dariadb::timeutil::to_string(measurement.time) &lt;&lt; " value:" &lt;&lt; measurement.value &lt;&lt; std::endl; } void is_end() override { std::cout &lt;&lt; "calback end." &lt;&lt; std::endl; dariadb::IReadCallback::is_end(); } }; int main(int, char **) { const std::string storage_path = "exampledb"; //   .  ,    //   dariadb::utils::ILogger_ptr log_ptr{new QuietLogger()}; dariadb::utils::LogManager::start(log_ptr); auto storage = dariadb::open_storage(storage_path); auto scheme = dariadb::scheme::Scheme::create(storage-&gt;settings()); //    . auto all_params = scheme-&gt;ls(); dariadb::IdArray all_id; all_id.reserve(all_params.size()); all_id.push_back(all_params.idByParam("group.param1")); all_id.push_back(all_params.idByParam("group.subgroup.param2")); dariadb::Time start_time = dariadb::MIN_TIME; dariadb::Time cur_time = dariadb::timeutil::current_time(); //   dariadb::QueryInterval qi(all_id, dariadb::Flag(), start_time, cur_time); dariadb::MeasList readed_values = storage-&gt;readInterval(qi); std::cout &lt;&lt; "Readed: " &lt;&lt; readed_values.size() &lt;&lt; std::endl; for (auto measurement : readed_values) { print_measurement(measurement, all_params); } //       std::cout &lt;&lt; "Callback in interval: " &lt;&lt; std::endl; std::unique_ptr&lt;Callback&gt; callback_ptr{new Callback()}; storage-&gt;foreach (qi, callback_ptr.get()); callback_ptr-&gt;wait(); { //  auto stat = storage-&gt;stat(dariadb::Id(0), start_time, cur_time); std::cout &lt;&lt; "count: " &lt;&lt; stat.count &lt;&lt; std::endl; std::cout &lt;&lt; "time: [" &lt;&lt; dariadb::timeutil::to_string(stat.minTime) &lt;&lt; " " &lt;&lt; dariadb::timeutil::to_string(stat.maxTime) &lt;&lt; "]" &lt;&lt; std::endl; std::cout &lt;&lt; "val: [" &lt;&lt; stat.minValue &lt;&lt; " " &lt;&lt; stat.maxValue &lt;&lt; "]" &lt;&lt; std::endl; std::cout &lt;&lt; "sum: " &lt;&lt; stat.sum &lt;&lt; std::endl; } }</span></span></span></span></code> </pre> <br><h2 id="chtenie-sreza-dannyh">  Read data slice </h2><br><p>  Here, opening the repository and getting identifiers is no different from the previous example, so I will give only an example of getting a slice </p><br><pre> <code class="cpp hljs"> dariadb::Time cur_time = dariadb::timeutil::current_time(); <span class="hljs-comment"><span class="hljs-comment">//  ; dariadb::QueryTimePoint qp(all_id, dariadb::Flag(), cur_time); dariadb::Id2Meas timepoint = storage-&gt;readTimePoint(qp); std::cout &lt;&lt; "Timepoint: " &lt;&lt; std::endl; for (auto kv : timepoint) { auto measurement = kv.second; print_measurement(measurement, all_params); } //   dariadb::Id2Meas cur_values = storage-&gt;currentValue(all_id, dariadb::Flag()); std::cout &lt;&lt; "Current: " &lt;&lt; std::endl; for (auto kv : timepoint) { auto measurement = kv.second; print_measurement(measurement, all_params); } //       . std::cout &lt;&lt; "Callback in timepoint: " &lt;&lt; std::endl; std::unique_ptr&lt;Callback&gt; callback_ptr{new Callback()}; storage-&gt;foreach (qp, callback_ptr.get()); callback_ptr-&gt;wait();</span></span></code> </pre> <br><h1 id="ssylki">  Links </h1><br><ul><li>  <a href="https://github.com/lysevi/dariadb">dariadb</a> </li><li>  <a href="https://github.com/lysevi/dariadb-example">example</a> </li><li>  <a href="https://github.com/akumuli/Akumuli">akumuli</a> </li><li>  <a href="https://www.influxdata.com/">influxdb</a> </li><li>  <a href="http://oss.oetiker.ch/rrdtool/">Rrdtool</a> </li><li>  <a href="http://www.vldb.org/pvldb/vol8/p1816-teller.pdf">facebook gorilla</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323256/">https://habr.com/ru/post/323256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323244/index.html">The digest of interesting materials for the mobile developer # 193 (February 27 - March 5)</a></li>
<li><a href="../323246/index.html">I prepare CentOS 6.8 for work</a></li>
<li><a href="../323250/index.html">PVS-Studio security research</a></li>
<li><a href="../323252/index.html">Python program for statistical text analysis</a></li>
<li><a href="../323254/index.html">Backbone projects of telecommunications giants and maps of underwater communication channels</a></li>
<li><a href="../323258/index.html">Motion Detection in FPGA Video Stream</a></li>
<li><a href="../323260/index.html">Women's Day Gift by FPGA</a></li>
<li><a href="../323262/index.html">Implementing HQoS on Juniper MX80 / MX104 fixed ports</a></li>
<li><a href="../323266/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ252 (March 27 - 5, 2017)</a></li>
<li><a href="../323268/index.html">8 best extensions for WordPress to improve the menu on your site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>