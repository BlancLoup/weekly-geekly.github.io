<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lisp. Atom first</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 
 LISP has interested me for a long time, but, unfortunately, there was no chance to actively use my knowledge and aspirations in practice. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lisp. Atom first</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br>  LISP has interested me for a long time, but, unfortunately, there was no chance to actively use my knowledge and aspirations in practice.  Soon the new school year, which means I will again have the opportunity to study and, for the second year already, teach LISP students.  Another problem, apart from the traditional lack of interest in complex things, is the lack of literature.  Anyway, the topic of LISP on the Internet, and even more so in Runet, is poorly covered.  Here and on Habre publications quite a few. <br><br>  I hope this article will appeal to the public and open a series telling about one of the most interesting and least understandable (although far from the brainfuck and far) programming languages ‚Äã‚Äã- LISP.  After all, as it is not banal, one more language - one more life <br><a name="habracut"></a><br>  Let's start with the basic concepts of LISP-a - atoms and lists.  A little later, if it is interesting, in the Atom Zero prequel, it will be possible to talk in more detail about the philosophy and causes of the emergence of LISP, as well as about the modern directions of its use. <br><br><h3>  Short story </h3><br>  LISP was invented by John McCarthy in 1958 to solve non-numerical problems and was based on three main pillars: the algebra of list structures, lambda calculus, the theory of recursive functions.  For a long time LISP was used exclusively by a narrow circle of specialists in artificial intelligence.  But, starting from the 80s of the last century, LISP began to gain momentum and is now actively used, for example, in AutoCad and Emacs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is the difference between LISP and traditional programming languages?  Consider the <strong>key features</strong> : <br><ul><li>  The presentation forms of the programs and the data being processed in the LISP are identical and are list structures.  In connection with this, several interesting possibilities open up - for example, the processing of other programs by the program.  Not to mention the universality, extensibility and scalability of the syntax itself.  The LISP kernel written in LISP takes less than 200 lines, and the PROLOGUE interpreter takes just over 50 lines. </li><li>  The implementation of the lists allows you not to think about memory management, reserving and freeing cells occurs dynamically.  Thus, we can talk about the appearance of the garbage collector in the first versions of LISP. <br>  LISP is not a strongly typed programming language.  Today it will surprise no one, but it is worth recalling that at the initial stages this concept was opposed to the strictly typed Fortran. <br></li><li>  Prefix notation provides ample opportunities for parsing expressions, as well as provides the ability to use a single list context for programs and data. <br></li><li>  Use a huge amount of brackets.  That is why, along with the traditional LISP (LISt Processing) decoding, there is also a Lots of Idiotic Silly Parentheses. <br></li><li>  We should not forget about the existence of LISP-machines - computers, whose architecture is optimized for the effective execution of programs in the LISP language.  LISP machines are not very common, according to some data, their number in the world does not exceed 10,000. .  Xerox LISP machines became the ancestors of some common ideas and technologies: garbage collection, laser printing, multi-window systems, etc.).  I hope I will have a chance to talk about this in more detail in one of the next releases. <br></li></ul><br><h3>  Data types </h3><br><br>  Traditionally, LISP considers two types of <strong>atoms</strong> : symbols and numbers.  <strong>Symbols</strong> can denote numbers, strings, complex structures, functions, and other objects.  Restrictions on the names of characters depend on the dialect used, but most of them impose almost no restrictions on the characters used in the names.  In addition, again in most dialects, character names are not case sensitive. <br>  Some characters have a special purpose - they are constants, built-in functions, T (true, true) and NIL (false, false). <br><br>  <strong>Numbers</strong> , unlike characters, cannot represent other objects, so a number is always a constant number.  A little bit later we will look at the types of numbers in LISP. <br>  Symbols and numbers are the simplest objects of LISP - atoms.  The second main data type is point pairs, which are syntactically expressed as follows: <br><br> <code>&lt; &gt; ::= (&lt; |  &gt;.&lt; |  &gt;)</code> <br> <br>  For example, dot pairs are expressions: <br><br> <code>(ab), (a.(bc)), ((ab).(c.NIL)).</code> <br> <br>  Atoms and point pairs are collectively called S-expressions (S-expression, symbolic expression).  A special type of S-expression is a list, expressed as follows: <br><br> <code>&lt;&gt; ::= NIL | (&lt;S-&gt;.&lt;&gt;)</code> <br> <br>  NIL in most cases is defined as an empty list, in which case the list definition can be rewritten as follows: <br><br> <code>&lt;&gt; ::= &lt; &gt; | (&lt;&gt;.&lt;&gt;) <br> &lt; &gt; :: = NIL <br> &lt;&gt; ::= &lt;S-&gt; <br> &lt;&gt; ::= &lt;&gt;. <br></code> <br><br><h3>  Wings, legs ... Main tail </h3><br><br>  Both head and tail are key concepts in the LISP context list.  The first element of the list is called the head of the list, all other elements are called the tail.  To work with the head and tail, there is a set of basic functions, discussed below. <br>  An empty list is equivalent to a pair of empty brackets: <br>  NIL &lt;-&gt; (). <br>  A non-empty list consisting of the elements a1, a2, a3 ... in accordance with the rules for writing S-expressions can be written as follows: <br><br> <code>(a1.(a2.(a3‚Ä¶))) &lt;-&gt; (a1,a2,a3‚Ä¶)</code> <br> <br>  In a LISP list, you can also write a sequence of elements enclosed in brackets and separated by spaces.  By and large, the list is a multi-level data structure for which the sequence of opening and closing brackets is very important. <br>  The elements of the list can be atoms and lists, including an empty list.  For example, () is an empty list, and (NIL) is a list consisting of one NIL element - which is equivalent to (()). <br>  It should be understood that the usual S-expression syntax can be used along with the list syntax, for example, the following are equivalent: <br><br> <code>(a.(b.nil)), (a b.nil), (ab nil), (ab)</code> <br> <br>  If someone is interested, it will be possible to tell about the internal representation of lists in memory.  This is a completely independent topic in terms of interest and volume. <br><br><h3>  Basic functions and predicates </h3><br><br>  In LISP, there is a rather small set of primitive functions, which provides a complete list processing capability.  In the context of list structures, these functions are analogous to the basic arithmetic operations and form a certain system of rules to which absolutely all symbolic calculations are reduced. <br><br>  The traditional basic functions include QUOTE, CAR, CDR, CONS, ATOM, EQ. <br><br><h4>  QUOTE function </h4><br>  To begin, consider the function QUOTE, designed to block the calculation of the expression.  The easiest way to demonstrate the operation of this function is by a simple example: <br><br> <code>(+ 5 10) -&gt; 15 ;    5+10    <br> (quote (+ 5 10)) -&gt; (+5 10) ;   <br></code> <br><br>  The QUOTE function can also be written shorter: <br><br> <code>'(+ 5 10) -&gt; (+ 5 10) ; ' ‚Äì  quote <br></code> <br><br><h4>  CAR function </h4><br>  It is intended for receiving the first element of a point pair (or the head of the list).  Using this function is possible only in list context; using an atom will result in an error. <br><br>  <strong>car (list) -&gt; S-expression.</strong> <br><br>  A few examples: <br><br> <code>(car '(abc)) -&gt; a <br> (car '(a)) -&gt; a <br> (car 'a) -&gt; ERROR: a is not a list <br> (car '(nil)) -&gt; nil <br> (car nil) -&gt; nil <br> (car '(nil a)) -&gt; nil</code> <br> <br>  For convenience, a head empty list is considered NIL. <br><br><h4>  CDR function </h4><br>  Designed to get the second element of a point pair (or the tail of the list).  Using this function is possible only in list context; using an atom will result in an error. <br><br>  <strong>cdr (list) -&gt; list</strong> <br><br>  The tail of the list is the entire list without the first element.  If the list consists of one element, the tail will be NIL.  For convenience, the tail of the empty list is also considered to be nil. <br>  A few examples: <br><br> <code>(cdr '(abc)) -&gt; (bc) <br> (cdr '(a)) -&gt; nil <br> (cdr 'a) -&gt; ERROR: a is not a list <br> (cdr '(a (bc))) -&gt; ((bc)) <br> (cdr '(nil a)) -&gt; (a) <br> (cdr ()) -&gt; nil</code> <br> <br>  The CAR and CDR functions are implemented in all LISP dialects, but some of them have synonyms for them (FIRST and REST, HEAD and TAIL). <br><br><h4>  CONS function </h4><br>  It is intended to create a new list of the head and tail passed as arguments to it: <br>  <strong>cons (s-expression, list) -&gt; list</strong> <br><br>  For example: <br><br> <code>(cons 'a '(bc)) -&gt; (abc) <br> (cons 'a nil) -&gt; (a) <br> (cons nil '(bc)) -&gt;(nil bc) <br> (cons nil nil) -&gt;(nil) <br> (cons '(ab) '(c)) -&gt;((ab) c)</code> <br> <br>  In fact, the CONS function is the antithesis of the CAR and CDR functions: <br><br> <code>(cons (car '(abc)) (cdr '(abc))) -&gt; (abc)</code> <br> <br><h4>  ATOM function </h4><br>  ATOM and EQ are predicates - i.e.  functions that check the compliance of the argument with a certain property and return T or NIL depending on the success of the check. <br><br>  The ATOM predicate checks whether the object passed as an argument is an atom: <br><br>  <strong>atom (S-expression)</strong> <br><br>  For example: <br><br> <code>(atom 'a) -&gt; t <br> (atom '(abc)) -&gt; nil <br> (atom ()) -&gt; t ;..    nil,    <br></code> <br><br><h4>  EQ function </h4><br>  Predicate verifying the identity of two characters. <br><br>  <strong>eq (atom, atom)</strong> <br><br>  Examples: <br><br> <code>(eq 'a 'b) -&gt; nil <br> (eq 'a 'a) -&gt; t <br> (eq 'a (car '(ab)) -&gt; t <br> (eq () nil) -&gt; t <br></code> <br><br>  It should be remembered that the predicate EQ applies only to atomic arguments and cannot be used for lists.  Also, do not use EQ when comparing numbers. <br><br>  More common than EQ is the <strong>EQL</strong> predicate, which allows you to compare numbers of the same type: <br><br> <code>(eq 1.0 1.0) -&gt; nil <br> (eql 1.0 1.0) -&gt; t <br></code> <br><br>  Even more common for numbers is the predicate <strong>=</strong> , which allows you to compare the values ‚Äã‚Äãof numbers of different types: <br><br> <code>(eql 1 1.0) -&gt; nil <br> (= 1 1.0) -&gt; t <br></code> <br><br>  More common for lists is the predicate <strong>EQUAL</strong> , which allows you to compare the identity of two lists: <br><br> <code>(equal 'a 'a) -&gt; t <br> (equal '(ab) '(ab)) -&gt; t <br></code> <br><br>  The most common predicate is <strong>EQUALP</strong> , which allows to compare arbitrary objects. <br><br><h4>  NULL function </h4><br>  NULL checks whether the object passed as an argument is an empty list: <br><br>  For example: <br><br> <code>(null '()) -&gt; t <br> (null '(abc)) -&gt; nil <br> (null nil) -&gt; t <br> (null t) -&gt; nil <br></code> <br><br>  Judging by the last two examples, it can be concluded that the NULL function can also be used as a logical negation.  For the same purpose, the NOT predicate exists in LISP. <br><br><h3>  What's next? </h3><br>  Hope I could get interested.  Next time I plan to talk about existing LISP dialects (although university XLisp will suffice at first), less frequently used basic functions, folding CAR and CDR into something like CAAAADDAAR, and defining your own functions.  Later - recursion, control structures, scope, input-output.  Even later - if we do not need - about functionals, macros, properties of symbols and closures.  And of course, about what the public asks. <br>  See you! <br><br>  PS Criticize, but not too much, publish for the first time :) <br></div><p>Source: <a href="https://habr.com/ru/post/65791/">https://habr.com/ru/post/65791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../65783/index.html">How I worked two hours a day</a></li>
<li><a href="../65784/index.html">Flying saucers in the police service</a></li>
<li><a href="../65785/index.html">Google Picasa extension to post images to Twitter</a></li>
<li><a href="../65787/index.html">CSS. We leave to a new level</a></li>
<li><a href="../65790/index.html">Tricks of Windows 7</a></li>
<li><a href="../65792/index.html">Links and information on them. Should there be a type match?</a></li>
<li><a href="../65794/index.html">High-speed validation (for example, the site habrahabr.ru)</a></li>
<li><a href="../65796/index.html">JPEG XR has become the ISO / IEC standard</a></li>
<li><a href="../65797/index.html">E-commerce thrives in crisis</a></li>
<li><a href="../65798/index.html">Lambda expressions are now in C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>