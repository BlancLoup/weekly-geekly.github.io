<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Call event handlers thread-safe without extra assignment in C # 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From translator 
 Often, novice developers ask why when calling a handler you need to copy it to a local variable, and as the review code shows, even ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Call event handlers thread-safe without extra assignment in C # 6</h1><div class="post__text post__text-html js-mediator-article"><h2>  From translator </h2><br>  Often, novice developers ask why when calling a handler you need to copy it to a local variable, and as the review code shows, even experienced developers forget about it.  In C # 6, language developers added a lot of syntactic sugar, including a null-conditional operator (null-conditional operator or Elvis-operator - <b>?.</b> ), Which allows us to get rid of unnecessary (at first glance) assignment.  Under the cut explanations from John Skit - one of the most famous pillboxes there are no gurus. <br><a name="habracut"></a><br><h2>  Problem </h2><br>  Calling a handler in the C # language was always accompanied by not the most obvious code, because an event that has no subscribers is represented as a null link.  Because of this, we usually wrote this: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Foo; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EventHandler handler = Foo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); } }</code> </pre> <br>  The local variable handler should be used because without it, access to the Foo event handler is 2 times (when checked for null and at the call itself).  In this case, there is a possibility that the last subscriber will be removed just between these accesses to Foo. <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   ! if (Foo != null) { // Foo   null,   //      . Foo(this, EventArgs.Empty); }</span></span></code> </pre><br>  This code can be simplified by creating an extension method: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Raise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventHandler handler, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { handler(sender, args); } }</code> </pre><br>  Then using this extension method, the first call will overwrite: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Foo.Raise(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); }</code> </pre><br>  The disadvantage of this approach is that the extension method will have to be written for each type of handler. <br><br><h2>  C # 6 will save us! </h2><br>  The null-conditional operator ( <b>?.</b> ), Which appeared in C # 6, can be used not only to access properties, but also to call methods.  The compiler evaluates the expression only once, so the code can be written without using the extension method: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Foo?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); }</code> </pre><br>  Hooray!  This code will never throw a NullReferenceException, and we do not need helper classes. <br><br>  Of course, it would be better if we could write Foo? (This, EventArgs.Empty), but then it would be no longer <b>?</b>  an operator that would complicate the language a little.  Therefore, the extra call Invoke doesn‚Äôt bother me much. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  What is this thing - thread safety? </h2><br>  The code we write is ‚Äúthread-safe‚Äù in the sense that it doesn‚Äôt care what other threads do ‚Äî we will never get a NullReferenceException.  However, if other threads subscribe or cancel a subscription to an event, we may not see the most recent changes in the list of event subscribers.  This is due to the difficulties in implementing a common memory model. <br><br>  In C # 4, events are implemented using the Interlocked.CompareExchange method, so we can simply use the correct Interlocked.CompareExchange method to make sure we get the latest value.  Now we can combine these 2 approaches and write: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Interlocked.CompareExchange(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Foo, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); }</code> </pre><br>  Now, without writing <i>additional</i> code, we can notify the most recent set of subscribers, without the risk of falling out of a NullReferenceException.  Thanks to <a href="https://twitter.com/davidfowl">David Fowler</a> for reminding me of this feature. <br><br>  Of course, the CompareExchange call looks ugly.  Starting from .NET 4.5 and higher, there is a <a href="https://msdn.microsoft.com/en-us/library/gg712828.aspx">Volatile.Read</a> method that <i>can</i> solve our problem, but it‚Äôs not completely clear to me (if you read the documentation) whether this method does what you need.  (The description of the method says that it prohibits placing subsequent read / write operations before this method; in our case, it is necessary to prohibit <i>previous</i> write operations <i>after</i> this modified read). <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// .NET 4.5+,   ,     ... Volatile.Read(ref Foo)?.Invoke(this, EventArgs.Empty); }</span></span></code> </pre><br>  I don‚Äôt like this approach because I‚Äôm not sure that I‚Äôve foreseen everything.  Advanced readers may be able to suggest why this approach is not correct and did not get into the BCL. <br><br><h2>  Alternative approach </h2><br>  In the past, I used this alternative solution: create an empty fictitious event handler, using one advantage of anonymous methods that they have in comparison with lambda expressions - the ability not to specify a list of parameters: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Foo = <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Foo will never be null Volatile.Read(ref Foo).Invoke(this, EventArgs.Empty); }</span></span></code> </pre><br>  With this approach, there are still problems with the fact that we can not cause the most recent list of subscribers, but we do not need to worry about checking for null and NullReferenceException. <br><br><h2>  Explore MSIL </h2><br>  <i>From the translator:</i> this part is not in the article of John, this is my personal research in ildasm. <br>  Let's see what MSIL code is generated in different cases. <br><div class="spoiler">  <b class="spoiler_title">Bad code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Foo; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Foo != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Foo(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); } } .<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig instance </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Code size 35 (0x23) .maxstack 3 .locals init ([0] bool V_0) IL_0000: nop IL_0001: ldarg.0 //  this   IL_0002: ldfld class [mscorlib]System.EventHandler A::Foo //     Foo IL_0007: ldnull //    null IL_0008: cgt.un //  2     (Foo  null) -  ,     0 (false) IL_000a: stloc.0 //        bool IL_000b: ldloc.0 //     IL_000c: brfalse.s IL_0022 //     false,    IL_0022 (return) IL_000e: nop IL_000f: ldarg.0 //    this IL_0010: ldfld class [mscorlib]System.EventHandler A::Foo //     Foo - !!!     null IL_0015: ldarg.0 //    this IL_0016: ldsfld class [mscorlib]System.EventArgs [mscorlib]System.EventArgs::Empty //    System.EventArgs::Empty IL_001b: callvirt instance void [mscorlib]System.EventHandler::Invoke(object, class [mscorlib]System.EventArgs) //  Foo(this, EventArgs.Empty) IL_0020: nop IL_0021: nop IL_0022: ret } // end of method A::OnFoo</span></span></code> </pre><br></div></div><br>  In this code, we twice refer to the Foo field: for comparison with null (IL_0002: ldfld) and the actual call (IL_0010: ldfld).  Meanwhile, as we checked Foo for null equality, and once we got access to it, we put it on the stack and called the method, the last subscribers could unsubscribe from the event, and the second time it will be loaded null - hello, NullReferenceException. <br><br>  Let's see how the problem is solved by using an additional local variable. <br><div class="spoiler">  <b class="spoiler_title">Using variable</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Foo; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { EventHandler handler = Foo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { handler(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); } } .<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig instance </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Code size 32 (0x20) .maxstack 3 .locals init ([0] class [mscorlib]System.EventHandler 'handler', [1] bool V_1) IL_0000: nop IL_0001: ldarg.0 //  this   IL_0002: ldfld class [mscorlib]System.EventHandler A::Foo //  Foo,     IL_0007: stloc.0 //  Foo   handler IL_0008: ldloc.0 //    handler IL_0009: ldnull //    null IL_000a: cgt.un //  2     (handler  null) -  ,     0 (false) IL_000c: stloc.1 //        bool IL_000d: ldloc.1 //     IL_000e: brfalse.s IL_001f //     false,    IL_001f (return) IL_0010: nop IL_0011: ldloc.0 //    handler IL_0012: ldarg.0 //    this IL_0013: ldsfld class [mscorlib]System.EventArgs [mscorlib]System.EventArgs::Empty //    System.EventArgs::Empty IL_0018: callvirt instance void [mscorlib]System.EventHandler::Invoke(object, class [mscorlib]System.EventArgs) //  handler(this, EventArgs.Empty) IL_001d: nop IL_001e: nop IL_001f: ret } // end of method A::OnFoo</span></span></code> </pre><br></div></div><br>  In this case, everything is simple: access to Foo occurs once (IL_0002: ldfld), then all the work goes with the variable handler, so there is no danger of getting a NullReferenceException. <br><br>  Now the solution using the operator <b>?</b>  . <br><div class="spoiler">  <b class="spoiler_title">C # 6</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Foo; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Foo?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); } .<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig instance </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Code size 26 (0x1a) .maxstack 8 IL_0000: nop IL_0001: ldarg.0 //    this IL_0002: ldfld class [mscorlib]System.EventHandler A::Foo //     Foo IL_0007: dup //    Foo IL_0008: brtrue.s IL_000d //     true   null   0,    IL_000d ( ) IL_000a: pop //   -    Foo (  ,  Foo == null) IL_000b: br.s IL_0019 //    IL_000d: ldarg.0 //    this (  ,  Foo != null) IL_000e: ldsfld class [mscorlib]System.EventArgs [mscorlib]System.EventArgs::Empty //    EventArgs::Empty IL_0013: callvirt instance void [mscorlib]System.EventHandler::Invoke(object, class [mscorlib]System.EventArgs) //  Invoke IL_0018: nop IL_0019: ret } // end of method A::OnFoo</span></span></code> </pre><br></div></div><br>  In C # 6 using the <b>?</b> Operator <b>.</b>  everything becomes more interesting.  We put the Foo field on the stack, duplicate it (IL_0007: dup - all the magic is here), then if it is not null, then go to IL_000d and call the Invoke method.  If Foo == null, then clear the stack and exit (IL_000b: br.s IL_0019).  We are really only reading Foo once, so a NullReferenceException will not occur. <br><br>  Use the operator <b>?</b>  and Interlocked.CompareExchange. <br><div class="spoiler">  <b class="spoiler_title">Interlocked.CompareExchange</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Foo; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Interlocked.CompareExchange(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Foo, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); } .<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig instance </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Code size 33 (0x21) .maxstack 8 IL_0000: nop IL_0001: ldarg.0 //    this IL_0002: ldflda class [mscorlib]System.EventHandler A::Foo //      Foo IL_0007: ldnull //    null IL_0008: ldnull //    null IL_0009: call !!0 [mscorlib]System.Threading.Interlocked::CompareExchange&lt;class [mscorlib]System.EventHandler&gt;(!!0&amp;, !!0, !!0) //  Interlocked::CompareExchange IL_000e: dup //    Foo -  ,   Interlocked::CompareExchange IL_000f: brtrue.s IL_0014 //     true   null   0,    IL_0014 ( ) IL_0011: pop //   -    Foo (  ,  Foo == null) IL_0012: br.s IL_0020 //    IL_0014: ldarg.0 //    this IL_0015: ldsfld class [mscorlib]System.EventArgs [mscorlib]System.EventArgs::Empty //    EventArgs::Empty IL_001a: callvirt instance void [mscorlib]System.EventHandler::Invoke(object, class [mscorlib]System.EventArgs) //  Invoke IL_001f: nop IL_0020: ret } // end of method A::OnFoo</span></span></code> </pre><br></div></div><br>  This code differs from the previous one only by calling Interlocked.CompareExchange (IL_0009: call !! 0 [mscorlib] System.Threading.Interlocked :: CompareExchange), then the code is exactly the same as in the previous method (starting with IL_000e). <br><br>  Use the operator <b>?</b>  and volatile. read. <br><div class="spoiler">  <b class="spoiler_title">Volatile.Read</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Foo; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Volatile.Read(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Foo)?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, EventArgs.Empty); } .<span class="hljs-function"><span class="hljs-function">method </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> hidebysig instance </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFoo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) cil managed</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Code size 31 (0x1f) .maxstack 8 IL_0000: nop IL_0001: ldarg.0 //    this IL_0002: ldflda class [mscorlib]System.EventHandler A::Foo //      Foo IL_0007: call !!0 [mscorlib]System.Threading.Volatile::Read&lt;class [mscorlib]System.EventHandler&gt;(!!0&amp;) //  Volatile::Read IL_000c: dup //    Foo -  ,   Volatile::Read IL_000d: brtrue.s IL_0012 //     true   null   0,    IL_0012 ( ) IL_000f: pop //   -    Foo (  ,  Foo == null) IL_0010: br.s IL_001e //    IL_0012: ldarg.0 //    this IL_0013: ldsfld class [mscorlib]System.EventArgs [mscorlib]System.EventArgs::Empty //    EventArgs::Empty IL_0018: callvirt instance void [mscorlib]System.EventHandler::Invoke(object, class [mscorlib]System.EventArgs) //  Invoke IL_001d: nop IL_001e: ret } // end of method A::OnFoo</span></span></code> </pre><br></div></div><br>  In this case, the call to Interlocked.CompareExchange changes to a call to Volatile.Read, and then (starting with IL_000c: dup), all without changes. <br><br>  All solutions using the operator <b>?</b>  differ in that the access to the field occurs once, to call the handler, its copy is used (MSIL command dup), so we call Invoke to make an exact copy of the object, which was compared to null - NullReferenceException cannot occur.  The rest of the methods differ only in how quickly they catch changes in a multi-threaded environment. <br><br><h2>  Conclusion </h2><br>  Yes, C # 6 taxis - and not for the first time.  And we already have a stable version! </div><p>Source: <a href="https://habr.com/ru/post/272571/">https://habr.com/ru/post/272571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272559/index.html">Django: How to quickly get unnecessary duplicates in a simple QuerySet</a></li>
<li><a href="../272563/index.html">Some new settings in Linux Mint Release 17.3 LTS 12/04/2015</a></li>
<li><a href="../272565/index.html">How to improve the analysis and management of network traffic by watching the DNS</a></li>
<li><a href="../272567/index.html">Analysis of key performance indicators - part 3, the last, about system and service metrics</a></li>
<li><a href="../272569/index.html">Software design for beginners using the snowflake method</a></li>
<li><a href="../272573/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 21. "Master Splyntr"</a></li>
<li><a href="../272575/index.html">Minimum font size and default encoding in Vivaldi 1.0.344.5</a></li>
<li><a href="../272577/index.html">How to copy Skype and Google Chrome and Mozilla Firefox settings profiles from one / home to another</a></li>
<li><a href="../272579/index.html">Free course ‚ÄúAndroid. Fast start"</a></li>
<li><a href="../272581/index.html">Zsh life tricks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>