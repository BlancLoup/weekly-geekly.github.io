<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rewrite Require.js using Promise. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In order not to have problems with dependencies and modules with a large number of browser javascript, usually use require.js . Also, many people know...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rewrite Require.js using Promise. Part 1</h1><div class="post__text post__text-html js-mediator-article"> In order not to have problems with dependencies and modules with a large number of browser javascript, usually use <a href="https://github.com/jrburke/requirejs">require.js</a> .  Also, many people know that this is just one of many of the <a href="">AMD</a> standard downloaders, and it has alternatives.  But few people know how they are arranged inside.  In fact, it is not difficult to write such a tool, and in this article we will write our version of the AMD bootloader step by step.  At the same time let's deal with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> , which recently appeared in browsers and will help us cope with asynchronous operations. <br><br>  The basis of require.js is the <code>require(dependencies, callback)</code> function.  The first argument is the list of modules to load, and the second is the function that will be called when the load is completed, with the modules in the arguments.  Using Promise to write it is a snap: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">require</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">deps, factory</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(deps.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dependency</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!modules[dependency]) { modules[dependency] = loadScript(dependency); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modules[dependency]; }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">modules</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> factory.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, modules); }); }</code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, this is not all, but there is a basis.  Therefore, we will continue. <br><a name="habracut"></a><br><h3>  Module loading </h3><br>  Our first function will be the script loading function: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> el = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"script"</span></span>); el.onload = resolve; el.onerror = reject; el.async = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; el.src = <span class="hljs-string"><span class="hljs-string">'./'</span></span> + name + <span class="hljs-string"><span class="hljs-string">'.js'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'body'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].appendChild(el); }); }</code> </pre><br>  The download happens asynchronously, so we will return the Promise object, which will allow you to learn about the end. <br>  The Promise constructor accepts a function in which an asynchronous process will occur.  Two arguments are passed to it - <code>resolve</code> and <code>reject</code> .  These are functions for reporting results.  If successful, call <code>resolve</code> , and on error, <code>reject</code> . <br>  To subscribe to the result, the Promise instance has a then method.  But we may need to wait for the loading of several modules.  And for this there is a special function aggregator <code>Promise.all</code> , which will collect several promises into one, and its result in case of success will be an array of results of loading all the necessary modules.  With the help of these two simple functions, you can already get a minimally working prototype. <br><br>  <a href="https://github.com/just-boris/require-mini">The github repository</a> contains tags on key steps from this article.  At the end of each chapter there is a link to github, where you can see the full version of the code written for this step.  In addition, in the test folder are tests that show that our functionality works as it should.  <a href="https://travis-ci.org/just-boris/requirejs/branches">Travis-CI is</a> connected to the project, which performed tests for each step. <br><br>  <a href="https://github.com/just-boris/requirejs/tree/step-1">See the code for this step on Github</a> . <br><br><h3>  Ad modules </h3><br>  In fact, we have not loaded our modules.  The thing is that when we add a script to a page, we lose control over it and do not know anything about the result of its work.  Therefore, when we load the module A, we can slip the module B, but we will not notice.  To prevent this from happening, you need to give the modules the opportunity to introduce themselves.  The <code>define()</code> function is designed for this in the AMD standard.  For example, the registration of module A looks like this: <br><br><pre> <code class="hljs actionscript">define(<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'module A'</span></span>; });</code> </pre><br><br>  When the module is introduced by name, we will not confuse it with anything and will be able to mark it as loaded.  To do this, we need to define the module registrar - the <code>define</code> function.  At the last step, we simply waited for the successful loading of the script and did not check its contents.  Now we will wait for a call to <code>define</code> .  And at the time of the call, we will find our module and mark it as loaded. <br><br>  To do this, we need to create a module blank at the beginning of the download, which can turn into a real module after loading.  This can be done using deferred objects.  They are close to Promise, but he hides the resolve and reject inside himself, and from the outside only gives the opportunity to know the result.  Deferred objects have the resolve and reject methods, that is, having access to deferred, you can easily change its result.  Also, the deferred object has a <code>promise</code> field in which the Promise is written, the result of which we specify.  Deferred are easily made from Promise <a href="http://stackoverflow.com/a/21674674/1297743">prescription from Stackoverflow</a> . <br><br>  When modules are loaded into <code>require</code> , we will create a deferred object for each module and save it to the cache (pendingModules). <br>  <code>define</code> will be able to get it from there and call resolve to mark it as loaded and save it. <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">define</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, factory</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> = factory(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pendingModules[name]) { pendingModules[name].resolve(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pendingModules[name]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { modules[name] = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>; } }</code> </pre><br><br>  It is also sometimes necessary to register a module before it is asked.  Then it will not be in the pendingModules list, in this case we can immediately put it in modules. <br><br>  The loadScript function will now save deferred-objects to the cache and return the promise of this object, according to which the require function will wait for the module to load. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> loadScript(<span class="hljs-type"><span class="hljs-type">name</span></span>) { var <span class="hljs-keyword"><span class="hljs-keyword">deferred</span></span> = defer(), el = document.createElement("script"); pendingModules[<span class="hljs-type"><span class="hljs-type">name</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">deferred</span></span>; el.onerror = <span class="hljs-keyword"><span class="hljs-keyword">deferred</span></span>.reject; el.async = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; el.src = <span class="hljs-string"><span class="hljs-string">'./'</span></span> + <span class="hljs-type"><span class="hljs-type">name</span></span> + <span class="hljs-string"><span class="hljs-string">'.js'</span></span>; document.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'body'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].appendChild(el); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">deferred</span></span>.promise; }</code> </pre><br><br>  <a href="https://github.com/just-boris/requirejs/tree/step-2">See the code for this step on Github</a> . <br><br><h3>  Dependencies in modules, loop detection </h3><br>  Hurray, now we can load modules.  But sometimes the module may need other modules to work.  For this in AMD <br>  for the <code>define</code> function, another argument is provided - <code>dependencies</code> , which can be between name and factory. <br>  When a module has dependencies, we cannot just take and call a factory, we must first load the dependencies. <br>  Fortunately, for this we already have a require function, here it will have to be in place.  Where previously there was just a call to <code>factory()</code> there will now be <code>require</code> : <br><br><pre> <code class="diff hljs">define(name, deps, factory) { ... - var module = factory(); + var module = require(deps, factory); ... }</code> </pre><br><br>  It is worth noting that now the <code>module</code> variable will not be a module, but the promise of a module.  When we pass it to resolve, the promise of the source module will not be fulfilled, but will now wait for the dependencies to load.  This is quite a convenient feature of Promise, when our asynchronous process stretches into several stages, we can resolve to transfer the Promise from the next stage, and the internal logic will recognize this and switch to waiting for the result from the new Promise. <br><br>  When we load the dependencies of the modules, we are in danger.  For example, module A depends on B, and B depends on A. Load module A, it will require module B. After loading, B will require A, and as a result, they will wait for each other indefinitely.  The situation may be worse if there are not two modules in the chain, but more.  You need to be able to stop such cyclical dependencies.  To do this, we will save the download history to show a warning when we notice that our download went in a circle.  We used <code>require()</code> to load module dependencies, but this function is a fixed set of arguments, written in the standard, it must be followed.  Let's create our own internal function <code>_require(deps, factory, path)</code> to which we will be able to transmit information about the module load history, and in the public API we will make its call: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">require</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(deps, factory)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_require</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(deps, factory, [])</span></span></span><span class="hljs-function">; }</span></span></code> </pre><br>  At first, our boot history will be empty, so we will pass an empty array as path.  <code>_require()</code> will now have the same boot logic, plus history tracking. <br><br><pre> <code class="diff hljs">function loadScript(name, path) { var deferred = defer(); + deferred.path = path.concat(name); ... } function _require(deps, factory, path) { return Promise.all(deps.map(function (dependency) { + if(path.indexOf(dependency) &gt; -1) { + return Promise.reject(new Error('Circular dependency: '+path.concat(dependency).join(' -&gt; '))); + } ... }</code> </pre><br>  The global array with a list of all modules does not suit us, the load history of each module is different, we will save it to the deferred-object of the loadable module, so that it can then be read in <code>define</code> and transferred to <code>_require</code> if you need to load more modules.  I note that we add a new module to the history via <code>.concat()</code> , instead of <code>.push()</code> , because we need an independent copy of the history in order not to spoil the history to other modules that were loaded to us.  And instead of the usual <code>throw new Error()</code> we return Promise.reject ().  This means that the promise did not come true, and an error handler will be called, just as it does when an error occurs during the loading of the script, only the message indicates another reason - a cycle in dependencies. <br><br>  <a href="https://github.com/just-boris/requirejs/tree/step-3">See the code for this step on Github</a> . <br><br><h3>  Error processing </h3><br>  It is time to implement error reporting for users.  The require function also provides a third argument, a function called in case of an error.  Promise can tell us about an error if in <code>.then()</code> we pass two functions.  The first one is already transmitted and called, if everything is good, the second one will be called up if something goes wrong. <br><br>  An additional argument is called <code>errback</code> , as in the original require.js <br><br><pre> <code class="diff hljs">function _require(deps, factory, errback, path) { ... })).then(function (modules) { return factory.apply(null, modules); + }, function(reason) { + if(typeof errback <span class="hljs-comment"><span class="hljs-comment">=== 'function') { + errback(reason); + } else { + console.error(reason); + } + return Promise.reject(reason); }); }</span></span></code> </pre><br><br>  In case the user does not care about errors, we will do it ourselves, we will display a message in the console.  Also, it is not by chance that we return such a value in the error handler.  The promise logic is designed in such a way that if we pass the function to an error case, then it considers that we will fix everything in it and we can continue working, similar to the try-catch block. <br>  But for require.js, the loss of a module is fatal, we cannot continue to work without all modules, pass the error further using <code>Promise.reject</code> . <br><br>  <a href="https://github.com/just-boris/requirejs/tree/step-4">See the code for this step on Github</a> . <br><br><h3>  Anonymous modules </h3><br>  The AMD standard provides the ability to define modules without a name.  In this case, its name is determined by the script that is now loaded on the page.  The <a href="https://developer.mozilla.org/en-US/docs/Web/API/document.currentScript"><code>document.currentScript</code></a> property is not supported by all browsers, so we will have to define the current script in a different way.  We will make the loading of the modules consistent, which means we will expect only one module at a time.  Using Promise, you can easily get the implementation of a FIFO queue: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastTask = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(), currentContext; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invokeLater</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context, fn</span></span></span><span class="hljs-function">) </span></span>{ lastTask = lastTask.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ currentContext = context; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ currentContext = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }); }</code> </pre><br><br>  We always keep a promise from the last operation, the next operation will subscribe to its completion and leave a new promise. <br>  We will use this queue to load scripts.  Now we don‚Äôt have a <code>pendingModules</code> list, but one pendingModule, and the rest will be waiting. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> loadScript(<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-type"><span class="hljs-type">path</span></span>) { var <span class="hljs-keyword"><span class="hljs-keyword">deferred</span></span> = defer(); <span class="hljs-keyword"><span class="hljs-keyword">deferred</span></span>.name = <span class="hljs-type"><span class="hljs-type">name</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">deferred</span></span>.path = <span class="hljs-type"><span class="hljs-type">path</span></span>.concat(<span class="hljs-type"><span class="hljs-type">name</span></span>); invokeLater(<span class="hljs-keyword"><span class="hljs-keyword">deferred</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Promise(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(resolve, reject) { //    }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">deferred</span></span>.promise; }</code> </pre><br>  The function still returns the deferred module, but it starts loading it not immediately, but in turn.  And the module name is added to deferred to know which module we are going to wait for.  And now we can write a fairly short define: <br><br><pre> <code class="hljs actionscript">define(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'module-content'</span></span>; });</code> </pre><br><br>  And the module will receive the name by the name of its file, by which we refer to it, and so it is possible not to specify it separately. <br><br>  <a href="https://github.com/just-boris/requirejs/tree/step-5">See the code for this step on Github</a> . <br><br><h3>  Delayed initialization </h3><br>  When we meet <code>define</code> , it does not mean that it needs to be initialized immediately.  Maybe no one has asked him yet and he may not need it.  Therefore, it can be saved along with information about its dependencies and called only when it really comes in handy.  It will also be useful if the modules can be declared in any order, and their dependencies will be dealt with at the very end, during application initialization. <br><br>  Let's get a separate object <code>predefines</code> , and save modules in it, if nobody asked them. <br><br><pre> <code class="diff hljs">function define(name, deps, factory) { ... } else { - modules[name] = _require(deps, factory, null, []); + predefines[name] = [deps, factory, null]; } }</code> </pre><br><br>  And during <code>require</code> we will first check the <code>predefines</code> for the modules we are interested in. <br><br><pre> <code class="diff hljs">function _require(deps, factory, errback, path) { ... + var newPath = path.concat(dependency); + if(predefines[dependency]) { + modules[dependency] = _require.apply(null, predefines[dependency].concat([newPath])) + } else if (!modules[dependency]) { modules[dependency] = loadScript(dependency, newPath); } ... }</code> </pre><br><br>  This optimization will avoid unnecessary requests when we define modules in advance. <br><br><pre> <code class="hljs lua">define(<span class="hljs-string"><span class="hljs-string">'A'</span></span>, [<span class="hljs-string"><span class="hljs-string">'B'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}); define(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">'A'</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {});</code> </pre><br><br>  Previously, we would have started loading the module 'B' from somewhere in the first step, and would not have found it.  And now we can wait until all the modules are declared themselves, and only then call <code>require</code> .  Also now it does not matter the order of their announcement. <br>  It is enough that the entry point (call require) was last. <br><br>  <a href="https://github.com/just-boris/requirejs/tree/step-6">See the code for this step on Github</a> . <br><br>  Thus, we have already received a completely complete solution for loading modules and resolving dependencies.  But require.js allows you to do much more with modules.  Therefore, <a href="http://habrahabr.ru/post/252849/">in the next part of the</a> article, we will add support for settings and plugins, and we will make this functionality fully compatible with the original require.js. </div><p>Source: <a href="https://habr.com/ru/post/252783/">https://habr.com/ru/post/252783/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252767/index.html">We program in a cloud: the review popular IDE</a></li>
<li><a href="../252769/index.html">Align the modal window in the center</a></li>
<li><a href="../252771/index.html">Perspective matrices in graphic API or the devil hides in details</a></li>
<li><a href="../252773/index.html">Material Design: to the moon and back</a></li>
<li><a href="../252779/index.html">e-Ticket misunderstanding</a></li>
<li><a href="../252785/index.html">IBM Containers now in Bluemix: we put everything on the shelves</a></li>
<li><a href="../252787/index.html">Increase page conversion in the App Store and Google Play with A / B tests</a></li>
<li><a href="../252789/index.html">Applications in the electronic document management system. Part 1: Key Principles, Components, and Features</a></li>
<li><a href="../252791/index.html">About educational robotics and circles</a></li>
<li><a href="../252793/index.html">GPS control on the free service ViaLatM 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>