<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÄúSmooth‚Äù object model or what is ‚Äúsyntactic sugar‚Äù worth?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last 15-20 years, an incredible number of new programming languages ‚Äã‚Äãhave appeared. Many of them are represented as ‚Äútrue‚Äù object-oriented lan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>‚ÄúSmooth‚Äù object model or what is ‚Äúsyntactic sugar‚Äù worth?</h1><div class="post__text post__text-html js-mediator-article">  In the last 15-20 years, an incredible number of new programming languages ‚Äã‚Äãhave appeared.  Many of them are represented as ‚Äútrue‚Äù object-oriented languages ‚Äã‚Äãor, at a minimum, languages ‚Äã‚Äãthat support object-oriented programming (OOP).  In any case, it is especially emphasized that in these languages ‚Äã‚Äãit is possible to conduct development, adhering to an object-oriented methodology.  In order for a programming language to be an OOP language, it must implement some <i>Object Model</i> .  Due to the fact that OOP has evolved from a type of programming into something that is closer to the concept and methodology, different languages ‚Äã‚Äãbegan to adhere to more or less the same object model.  But, in addition, these languages ‚Äã‚Äãare overgrown with different syntactic constructions, some of which belong to the so-called ‚Äúsyntactic sugar‚Äù, which allow for some frequently performed actions on objects to be more compact. <br>  Due to the fact that in most programming languages ‚Äã‚Äãthe object model is very complicated, we will try to define a description, so to speak, of a ‚Äúflat‚Äù <i>Object Model</i> , removing from it everything that is possible. <br><a name="habracut"></a><br><ol><li>  The terminal symbol (term) of the type "object" is defined.  The expression ‚Äúterminal symbol of the type‚Äú object ‚Äù‚Äù means only that special lexical constructions that are expressed at the language level are available for this term, we will consider only two of them - the assignment and the method call. </li><li>  The value of the terminal symbol ‚Äúobject‚Äù is a reference to a certain entity, which is described in the following clauses. </li><li>  The operation "=" is defined - assignment by reference.  Assigning one terminal character ( <i>term1</i> ) to another ( <i>term2</i> ) means copying a reference to the same entity from <i>term1</i> to <i>term2</i> . </li><li> An entity that is a term value has a number of methods.  The method is called and its parameters are transferred using lexical constructions "."  and "()", that is, for example, <code>term.method(param1, param2)</code> . </li><li>  An entity has an unordered collection of (other) entities that make up its state. </li><li>  There is at least one entity that allows you to create other entities with a given set of methods and with a given initial state. </li><li>  There is at least one entity that allows you to copy a state and a set of methods from one entity to another. </li><li>  Methods and state elements when copying (clause 7) are not replaced if there are the same ones with the same name in the essence to which copying is made. </li></ol><br>  The object model, the description of which is given in paragraphs 1-8, will be called the ‚Äúflat object model‚Äù. <br>  Generally speaking, the above certain model is greatly simplified, for example, the default inheritance from the base type is not even considered, and there is even no inheritance mechanism supported in each object ‚Äî for this it is assumed that there is one predefined entity that can perform this action with other entities. <br>  A flat object model is enough to call the language that supports it object-oriented.  Often referred to in the characterization of OOP terms: encapsulation, inheritance and polymorphism are taken into account in paragraphs 4 and 5, 6 and 7, 8, respectively. The word <b>hack is the</b> lexical construction of the language, which allows you to perform an action on objects in a manner not described in paragraphs 1- eight.  At once I want to draw attention to the fact that language tools that are not dependent on the object model of this language in question and are generally intended for other purposes not related to manipulation of objects <i>will not be considered hacks</i> .  For example, if we consider the implementation of the Objective-C compiler built on top of the C ++ compiler, then the C ++ object model is not taken into account when considering hacks in the main Objective-C object model.  Let us make a brief description of how some languages, including those that appeared not so long ago, were overgrown with hacks and how successful these hacks were. <br><br><h4>  Don't need hacks </h4><br>  Indeed, why do we need hacks, when it is possible to write programs beautifully and clearly, and besides, the interpreter of such a language is simpler and faster in terms of compilation due to the fact that there are no additional syntactic structures that should be interpreted.  The flat object model discussed above assumes a minimum of syntactic constructions ‚Äî assignment and method call ‚Äî and if you make a pure object-oriented language that does not include other constructions except constructions for working with a flat object model, then it will be very simple.  Very close to the Smalltalk flat object model.  It has two syntactic constructs specified for a flat object model ‚Äî assignment and method invocation (sending a message) ‚Äîbut there are also several hacks.  First, there are ways to literally create special objects - blocks, arrays, characters.  But it is very neat and also useful khaki, there‚Äôs nothing to dig into.  Another thing, in Smalltalk is a metamodel.  Strangely enough, Smalltalk was created in the expectation that <a href="http://ru.wikibooks.org/wiki/Smalltalk_%25D0%25B2_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BC%25D0%25B5%25D1%2580%25D0%25B0%25D1%2585/%25D0%2592%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">children</a> can <a href="http://ru.wikibooks.org/wiki/Smalltalk_%25D0%25B2_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BC%25D0%25B5%25D1%2580%25D0%25B0%25D1%2585/%25D0%2592%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">program</a> on it, but even the well-worn programmer can hardly figure out the Smalltalk metamodel.  In Smalltalk there are classes, and classes are an obvious hack, an object-oriented model can quite do without classes.  But for Smalltalk, this is almost not a hack, because both classes and metaclasses are just global objects that, in particular, solve the problems of points 7 and 8, so Smalltalk's hacks are very neat, soft and hardly anyone something will cause complaints. <br>  For example, there are no constructors in the usual sense of the word; there is a new method that is inherited when creating a subclass.  But there is no special construct for inheritance either; there is just sending a subclass message to the class from which the inheritance originates.  And classes are simply global objects with all the ensuing possibilities: <br><br><pre> <code class="smalltalk hljs"><span class="hljs-type"><span class="hljs-type">Object</span></span> subclass: <span class="hljs-symbol"><span class="hljs-symbol">#Person</span></span> instanceVariableNames: <span class="hljs-string"><span class="hljs-string">'Family Name '</span></span> ...</code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      That is, the entire complexity of managing objects is presented not at the level of the syntax of the language, but at the level of the metamodel, which itself is written by all the rules into the object model of the language. <br>  Self is very good for a flat object model, it doesn‚Äôt even have an assignment operation, which is replaced by a method call (message sending), so that in this sense it is even cleaner than the flat object model discussed above. <br><br><h4>  Hacks as needed </h4><br>  The old hacks that appeared long ago in many programming languages ‚Äã‚Äãare classes, static members, open, closed, protected members, constructors, destructors.  These are so familiar things that very few people (to put it mildly, ‚Äúfew people‚Äù) will attribute them to hacks.  But the fact is that these things were introduced into programming, in order to make it even not so much simpler as clearer.  Moreover, in statically typed languages, without classes, which at the same time constitute the type of objects, it is generally very difficult to do.  Although, a statically typed language is not an ideal environment for OOP, frankly.  In general, these are quite pertinent things, another is surprising how easy they have become accustomed in dynamically typed languages.  And this trend continues, for example, in CoffeeScript.  As well done in JavaScript, an object is a hash table, which is logical, because externally an object is just an unordered set of properties and methods, it only remains to add inheritance and polymorphism, which was done very well in JavaScript.  In general, a prototyped language is very close to a flat object model, and JavaScript shows it well.  But to make on the basis of such a successful language as JavaScript another language - CoffeeScript, with classes - it already looks like a tribute to traditions, although this approach is more familiar to someone. <br><br>  A few more thoughts on why classes and static members are a hack on the object model.  Classes in fact play the role of global objects that create other objects.  But at the same time, the classes are outside the scope of the object model (C ++, Java), although there are cases when the classes are located within the object model and there are objects themselves (Smalltalk, Python).  It turns out that if there were no classes, it would be possible to use global objects for the same purposes.  Many would probably say that global objects, like variables, are bad.  Global variables are bad, but global objects in the language where they replace classes are not, because there is no difference with classes.  On the contrary, sometimes classes are more complicated than with global objects.  Take Java for example.  In order for the Java interpreter to "remember" that there is such a class and initialize its static part, you have to write <code>Class.forName("**   ")</code> , that is, the class seems to be known to the environment, but in practice, it must also be shown obviously that he is. <br>  Accordingly, static members can simply be made as ordinary (nonstatic) members of such global objects.  But again, these types of hacks are quite normal, at least, this is recognized by an absolute majority of developers. <br><br>  Generics can also be attributed to forced and therefore successful hacks, because they make it possible to overcome some of the limitations of statically typed languages ‚Äã‚Äãwhen creating classes that share common logic.  But, if Generics is just a type casting substitutions and checking them for compatibility at the compilation stage, then C ++ templates are another story, perhaps this is one of the most powerful hacks on the object model that allows you to perform static metaprogramming, which is clearly good ... if know how to use. <br><br>  There is a very interesting point in how the constraints of the object model of one language migrated to another.  PHP has an object model that is syntactically very similar to the Java model.  All anything, but there is one small difference between them, Java is a statically typed language, PHP is dynamically.  There is such a thing in PHP as specifying the type of the argument passed to the function.  But despite the fact that in Java and PHP it looks syntactically the same, due to the fact that these languages ‚Äã‚Äãhave different types of typing, this indication of the type of argument plays a completely different role.  In Java, this is an instruction to the compiler how to deal with an argument when compiling, while in PHP it is the use of Reflection, that is, a runtime check that the argument has such a supertype. <br><br><h4>  Neat Khaki </h4><br>  Of course, first of all, in the category of neat hacks, I would like to attribute redefinition / operator overloading.  These are no longer forced hacks, but a very convenient extension of the object model.  It is clear that all operator overloads can be absolutely definitely replaced by method calls, but thanks to their use, the code becomes more natural and expressive.  These types of features can also be attributed to successful extensions of the object model. <br><br><h4>  Powerful hack </h4><br>  Of course, one of the most powerful hacks is the closure.  Currying is possible with or without a closure.  In general, functional programming (FP) has ceased to be the property of the highest caste of programmers and has come to familiar languages.  But the thing is that the FP has come not just to popular languages, but has come to languages ‚Äã‚Äãwhere OOP has already ruled, and these are, in general, ‚Äúslightly‚Äù different directions.  It is clear that the OP could not move the PLO, so the OP had no choice but to lie on the PLO from above (in a good sense, I just don‚Äôt know how to say otherwise).  Externally, syntactically, the closures look cool, it seems that the FP really works ‚Äúhonestly‚Äù.  But judging sensibly how the FP can work honestly, for example, in Python, where objects occupied everything from classes to functions and modules?  That's right, no way, it works not the OP, but the OOP, into which all these wrappers, lambdas, decorators are converted by the interpreter.  That is, it turns out that all these gadgets from the world of FP are nothing more than regular hacks over the PLO.  What are they transformed into?  In very specialized objects, for example, in C # - in objects that have a supertype <code>Delegate</code> .  These objects override only one method, in which, in essence, the closure is implemented.  <i>And what if there were no delegates?</i>  If we talk about C #, there would be a little tension in this case, because there are no non-static inner classes that could snap into the context of the surrounding object, as is possible in Java.  But it would not have come to a catastrophe; one could simply pass a reference to an expandable object while explicitly creating a delegate object: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> number { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> initialNumber</span></span></span><span class="hljs-function">)</span></span> { number = initialNumber; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Addition addition { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Addition(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Addition</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      Addition public Addition(SomeContext context) { _contest = context; } public void add(int number) { _contest.number += number; //   private-,      } private SomeContext _contest; } } class Program { static void Main(string[] args) { SomeContext context = new SomeContext(9); SomeContext.Addition addToContext = context.addition; //      addToContext.add(6); Console.WriteLine(context.number); } }</span></span></code> </pre><br><br>  Of course, using the delegate, it would be simpler: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> number { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> initialNumber</span></span></span><span class="hljs-function">)</span></span> { number = initialNumber; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Addition addition { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> what) { number += what; }; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Addition</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { SomeContext context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeContext(<span class="hljs-number"><span class="hljs-number">9</span></span>); SomeContext.Addition addToContext = context.addition; <span class="hljs-comment"><span class="hljs-comment">// external delegate logic addToContext(6); Console.WriteLine(context.number); } }</span></span></code> </pre><br><br>  In both cases, we see that the object to which a separate logic is allocated (an object of type <code>Addition</code> ) is locked to the internal context of an extensible object of type <code>SomeContext</code> .  And the allocated logic can be very nontrivial, for the sake of which the processing of this logic is delegated to another object.  However, the first of these two solutions has the advantage that in the selected object its state can be saved, if it exists, and in the second case an object of type Delegate is created without saving the state, that is, between the delegate calls its current state is not saved.  It would be possible to write even more concisely, using lambda expressions, but now it's not about that.  So closures are not such a strong thing, although in simple cases it may look very concise. <br><br><h4>  Hack hack </h4><br>  Khaki over a flat object model can be useful and convenient.  But in some cases there are a lot of them and it seems that they are no longer manageable.  Certainly one of the most hacked C # languages.  It seems that the creators in this language wanted to shove everything that was possible, and moreover they tried to shove the same thing more than once.  In particular, because of this, for example, there are <a href="http://msdn.microsoft.com/ru-ru/library/ms173176%2528v%3Dvs.100%2529">four different ways to</a> define the same callback design.  Something seems to be busting ... But all these constructs use the syntax of the language and therefore overload it.  There are also many other oddities, how difficult is the guys from Microsoft decided to hack the object model of C #: <br><br><ol><li>  Two types of objects - reference and value.  Explicit-implicit transitions (packing / unpacking) between them.  Objects ‚Äúby value‚Äù are extremely not typical, not only for a flat, but even for a somewhat familiar object model.  And this is despite the fact that all objects, including ‚Äúby value‚Äù, inherit Object, which is a reference.  Strange, isn't it? </li><li>  Non-virtual methods.  Generally speaking, non-virtual methods are a disconnected polymorphism, that is, a way out of the rules is again the usual object model.  But this is not the strangest thing.  Classes with non-virtual methods can implement interfaces.  That is, at the first level, when moving from the interface to the implementing class with non-virtual methods, polymorphism works by itself on this first level, and then stops. </li><li>  A polymorphic link can be stopped at any level of the inheritance hierarchy by declaring methods as <code>new</code> . </li><li>  Structures that by definition cannot contain virtual functions can implement interfaces.  Structures are generally very interesting.  The structure is a type-value, and the interface is an object (reference) type.  Suppose that the <code>SomeStructure</code> structure implements the <code>SomeInterface</code> interface.  There is a ready-made instance of the instance structure, having the type <code>SomeStructure</code> .  <code>SomeInterface anObject = instance</code> variable <code>SomeInterface anObject = instance</code> .  Attention question: anObject will refer to an instance of the instance structure by value or by reference?  It turns out, by value, although the interfaces are of object (reference) type.  That is, in this assignment, a copy of the structure instance is created, which then exists by reference.  If you don‚Äôt know this in advance, you can get caught somewhere. </li></ol><br><br>  Of course, all these hacks are not critical, at least in C # there is a more or less normal object model as a subset of hacked, and a normal one can be followed. <br><br><h4>  findings </h4><br>  The fancy syntax does not always give some really great opportunities in the implementation of application logic.  Most often, if you don‚Äôt say ‚Äúalways,‚Äù any ‚Äúsyntactic sweets‚Äù can be replaced with the usual insertions of objects and even within the framework of a flat object model, you can write complex things without arriving at poorly readable and poorly structured code.  Even more, having a fairly simple object model at your disposal, you can gracefully and simply cope with scary beasts that <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D1%2584%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2587%25D0%25B5%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B5%25D0%25BA%25D0%25BE-%25D0%25BC%25D0%25B5%25D1%2581%25D1%258F%25D1%2586">are not taken by silver bullets</a> , you can still have even more freedom to implement non-trivial logic, for example, as can be seen in comparing two fragments C # code that uses a solution based on a new class and based on a delegate.  Where the decision is based on a class, you can save the state between calls to the object (delegate) in which the logic is made. <br>  Another conclusion that can be made, the functionality of the object model can be better when rendered into a metamodel, and does not exist at the level of the syntax of the language.  As an example, the Smalltalk metamodel was cited.  In this case, we get no less functionality, but without ‚Äúcluttering up‚Äù the syntax.  But in practice, the opposite trend has recently been observed - programming languages ‚Äã‚Äãare developing in the direction of increasing the complexity of syntax (C #, CoffeScript, Scala), and languages ‚Äã‚Äãwith pure object models are fading into oblivion.  For example, the development of Self is completely stopped, and Smalltalk is barely alive. </div><p>Source: <a href="https://habr.com/ru/post/149882/">https://habr.com/ru/post/149882/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149876/index.html">Would not spend a day trying to restore Windows Server 2008R2</a></li>
<li><a href="../149878/index.html">GTD vs Agile Results. Correcting the mistakes of David Allen</a></li>
<li><a href="../149879/index.html">Apple will get rid of intermediaries in Russia</a></li>
<li><a href="../149880/index.html">Three new smartphones and a Sony Xperia tablet</a></li>
<li><a href="../149881/index.html">Unity Unite: Amsterdam in 3D</a></li>
<li><a href="../149883/index.html">The final version of Windows Server 2012 RTM is available in Windows Azure</a></li>
<li><a href="../149885/index.html">–°RM vs lead-management</a></li>
<li><a href="../149886/index.html">Teaching children with disabilities with the use of network technologies: 2006-2011</a></li>
<li><a href="../149887/index.html">Sleepbox Sleep Cabs On Sale</a></li>
<li><a href="../149888/index.html">Pilotless Audi TTS accelerated to 190 km / h</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>