<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing in Yandex: ObjectBuilders for describing and generating synthetic test data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Denis Chernilevsky. In Yandex, I lead the display advertising system automation testing group. In the course of my work at Yandex an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing in Yandex: ObjectBuilders for describing and generating synthetic test data</h1><div class="post__text post__text-html js-mediator-article">  Hello!  My name is Denis Chernilevsky.  In Yandex, I lead the display advertising system automation testing group.  In the course of my work at Yandex and at previous places, I happened to lead teams of 10+ people, streamline processes, and come up with approaches to automate the testing of various systems.  And it just so happened that in each of these projects we had to think about preparing test data.  Following a fairly long reflection, an approach was invented that allows us to solve this problem in general form and apply it in different projects.  Besides the fact that I will talk about it on the <a href="http://tech.yandex.ru/events/meetings/testing-environment/%3Ffrom%3Dhabr_testenv">Test environment</a> , I decided to give details here. <br><br>  By the way, if you can‚Äôt come to our event for testers, you can <a href="http://tech.yandex.ru/events/meetings/testing-environment/%3Ffrom%3Dhabr_testenv">watch the broadcast</a> , which will begin tomorrow, on Saturday, November 30 at 11:00. <br><br> <a href="http://habrahabr.ru/company/yandex/blog/204192/"><img src="https://habrastorage.org/getpro/habr/post_images/a2c/a82/8f9/a2ca828f91e1fc17c32b5d813a5252b8.png" alt="image"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article is based on the experience of solving the problem of preparing complex sets of synthetic test data in the process of automating the testing of the Yandex display advertising system.  Of course, we are not the first to face such a task, therefore, first we analyzed the existing approaches and solutions.  As a result, the ObjectBuilders library (in Python) has become a solution, which can be applied in projects where it is necessary to create hierarchically related data sets.  It allows you to set their relationships, parameters and properties.  And also gives several bonuses as side effects. <br><br>  Below I will try to describe and show the work of this tool in understandable examples, but first, in more detail, about the problem being solved and possible alternatives for its solution. <br><a name="habracut"></a><br><h4>  Task: it is necessary to test the display advertising system </h4><br>  So, ‚Äúwhat to do if for the test I need to create in the system 30 (50, 100 ...) objects connected with each other from many to many, many to one, one to many, one to one, and having 10 ( 20, 40 ...) properties each? " <br><br>  I‚Äôll just make a reservation here: it‚Äôs about the establishment of a functional blackbox testing - without unit tests or load. <br><br>  So, how are we going to solve it.  Okay, so it should be.  What is our system?  Yeah, a database with data on advertising campaigns, a back-end for an advertising competition and statistics calculation, the front-end accepts http requests and gives an answer in a certain format. <br><br>  We will build infrastructure, stands, adjust CI and write tests, say, in Python and everything will be fine!  Once Python, then for tests we will choose PyTest: convenient, beautiful, reports in JUnit format and easy extension of functionality in the form of plug-ins.  Everything, you can write tests!  Actually, of course, a couple of person-years left for all of the above, but this is not about us now. <br><br>  It seems everything is simple: they started one or several advertising campaigns with different parameters, launched the system, pulled the http request, got an answer, checked that they were giving what they expected and, maybe, checked some side things: logs, statistics, etc. d. <br><br>  Passed day <strike>week</strike> in attempts to force the system to show at least one banner.  It turns out that in order to create one advertising campaign in the system and to show at least one banner, it is necessary to score 30 objects with 15 parameters each into the database, so that they are correctly connected to each other and that different test data do not affect each other.  Well, it is also desirable that the test be run several times in a row! <br><br>  But after all, we also need different advertising campaigns in each test, and even a few, and with different settings. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66e/8a0/c97/66e8a0c97cc5a7f34275501637783782.jpg" alt="image"><br><br>  And here it seems that we hit.  But you have to do something. <br><br>  Thinking, we have compiled the following list of requirements for the creation procedure and the test data itself: <br><ol><li>  Created data must ensure the correct operation of the system. </li><li>  When changing the logic of connections or parameters of objects (for example, when developing a new feature), it should be possible to easily and quickly repair ALL tests that use these objects ‚Äî that is,  need easy test support in the future. </li><li>  The data of one test should not affect the behavior of another test. </li><li>  It should be possible to restart the test several times.  Therefore, the data must either be returned to its original state each time, or be generated anew. </li><li>  According to the description of these data, it should be possible to understand exactly how they differ from all other cases and why such settings are necessary for this test. </li></ol><br><h4>  Solutions </h4><br>  It is impossible to take existing data from the production system. <br><ul><li>  They may change, the test will work unpredictably;  It is difficult to notice these changes (the test will continue to work, but it will check not what is needed). </li><li>  They may disappear - the test will stop working altogether. </li><li>  One test can change the data used by another test. </li><li>  In general, it is not clear what and how is used by each test. </li><li>  The only advantage of this solution is the lack of costs for the actual preparation of data. </li></ul><br>  The option to prepare the base in advance with the data for each specific test is also not suitable. <br>  Difficult: too many parameters and objects <br><ul><li>  You can easily make mistakes when creating data, and then the error will be difficult to find. </li><li>  It is difficult to understand exactly which parameters in a particular data set influence the test behavior (it is difficult to understand what the test checks and why) </li><li>  It will not be possible to restart the test - it can change the parameters of its initial data set, you will have to reload the data each time you start </li><li>  When changing the logic of the product being tested, you will have to change each object touched several times by hand, as it may occur in different tests. </li><li>  Compared to option 1, this solution has one plus: independent data can be prepared, so that tests do not affect each other. </li></ul><br>  We refused these options right away, as they violate most of our demands.  A good idea to use the <a href="http://en.wikipedia.org/wiki/Builder_pattern">Builder</a> pattern.  Consider its pros and cons in more detail. <br><br><h4>  Builder pattern, or why we didn‚Äôt use it </h4><br>  Builder is a design pattern that allows you to separate the construction of an object from its presentation.  I will not describe it in detail.  Let me just say that his main idea is to create classes that allow you to create objects of other classes through a clear interface.  Thus, the builder encapsulates the entire logic of creating and configuring objects. <br><br>  From the examples on the wiki, it is clear that this approach satisfies all our requirements: <br><ul><li>  <i>Do the data created ensure the correct operation of the system?</i>  Yes, correctly describing the configuration logic of objects in the builder, you can make sure that any created objects have the right connections and parameters. </li><li>  <i>Is it possible when changing the logic of connections or parameters of objects to quickly and easily repair ALL tests using these objects?</i>  Yes, due to the encapsulation of the creation logic of objects in the builder, we can change this logic only in one place, that is, we select it in a separate layer. </li><li>  <i>The data of one test does not affect the behavior of other tests?</i>  Yes, because with the help of the builder at the beginning of each test we generate our own set of objects, and not use any existing ones. </li><li>  <i>Is it possible to restart the test several times?</i>  Yes, inside the builder you can implement the logic of creating unique objects, for example, giving them unique names or IDs each time. </li><li>  <i>It is possible, by the description of these data, to understand how they differ from all other cases and why exactly such settings are necessary for this test?</i>  Mmm, almost.  Creating some objects will look like calling a set of methods using a builder.  With their proper naming, it will be possible to intuitively understand what they customize. </li></ul><br>  Fine! <br><br>  Moreover, the Builder can be used to create <a href="http://en.wikipedia.org/wiki/Composite_pattern">Composite</a> objects.  That is, entire graphs of related objects that can be interpreted as a single logical object.  We just need to create a multitude of objects, with different types of connections between each other and to be able to adjust any parameters of both the whole tree of objects and its individual components in a single manner. <br><br>  It would seem that all is well, BUT these patterns have a drawback: for <b>each type of</b> objects, you need to implement <b>your Builder</b> and perhaps <b>your Composite</b> as separate classes.  It is also necessary to describe the <b>methods</b> that allow modifying the objects that we are going to build, their connections and properties. <br><br>  Being lazy people, we thought about how it would be nice to somehow formally describe the data model, on the basis of which Builder will work and be able to easily modify it. <br><br>  As a result, a small library called ObjectBuilders in Python was born.  It allows you to create graphs of related objects, manage the connections and properties of the objects themselves, remember the modifications applied to the default configuration in the form of patches and reuse them in the future. <br><br><h4>  A bit of theory and description of the approach </h4><br>  As described above, our system under test operates with a set of interconnected objects with a certain set of parameters (this is how most systems work).  These objects and their connections can be represented as a graph or tree (vertices are objects, edges are connections between objects).  <b>Actually, our task is to construct a graph of objects and their parameters for each specific test.</b> <br><br>  Here the following fact will help us: if you write your tests carefully and test only a small piece of functionality with each test, then in most tests the graphs will coincide with the accuracy of the tested parameter / connection. <br><br>  Moreover, in your test, you should always set the values ‚Äã‚Äãof all parameters that affect its behavior, we do not care about all the other parameters - the main thing is that it works.  If this is not the case, and there are still influencing parameters, see the previous paragraph - you must set them!  There will be a lot of influencing parameters if your test checks a lot of functionality at once, and few if you check a specific piece of functionality. <br>  All this means that we can fix in advance some of the most frequently used template of the graph and parameters, and only ‚Äútwist‚Äù (patch) it a little in each test. <br><br>  Plus, it would be great to accumulate knowledge about configurations and reuse ‚Äúpatches‚Äù on the graph in various combinations, i.e.  to accumulate knowledge about the system, which will allow in the future (for those who have forgotten or for those who did not know) to understand how the system operates on the data supplied to it. <br><br>  <b>In fact, we decided to turn the Builder pattern ‚Äúinside out‚Äù and began to describe not the creation of each specific object and then build an associated graph from them, but began to build the object graph itself and then apply modifications to this graph and its vertices and connections.</b> <br><br><h4>  A simplified example is a car factory </h4><br>  The initial task of testing an advertising system is rather cumbersome and has many terms that most people don‚Äôt understand, so we‚Äôll use the following example to further illustrate the work of our library. <br><br>  Suppose there is a car factory.  It is necessary to test it, that is, to submit the configuration of the car to the control computer of the conveyor, which must be assembled and see what will be output. <br><br>  We will feed the various car configurations.  Each configuration consists of the following parts: chassis (passenger, all-terrain), engine (type: diesel or gasoline and volume), wheels (number of wheels, diameter, cast or stamped), body (sedan, coupe, convertible, all-terrain vehicle), gearbox (manual, automatic).  Ideally, we need to check all possible correct combinations (except those prohibited by TK). <br>  It is clear that the plant can produce different cars, but some kind occurs more often than others.  Based on the general logic and market requirements, it would be logical to assume that most often we will produce cars with 4 wheels, sedans, 15 "forged disks, with a 1.6 petrol engine and a manual gearbox. <br><br>  At least 4% of them will have 4 wheels and a sedan body!  This will be our basic configuration.  The remaining parameters are selected on the same principle. <br><br>  It is also worth considering the amount of functionality of each configuration: that is, if the most checks will fall on some configuration, you should choose it as the base one.  In other words, if you, despite market requirements, are going to test an SUV in the tail and in the mane, then this configuration will be your basic one, since it will most often occur in your tests. <br><br>  Next we only need to change some of the parameters of the basic configuration for different cars.  Let's see how these principles are implemented in our library. <br><br><h4>  Implementing and using the ObjectBuilders library </h4><br>  Our tool works on 2 levels: <br><ol><li>  <b>Constructs</b> - provides a tool for setting up links between objects and generating the objects themselves. </li><li>  <b>Modifiers</b> - provides a tool for describing and applying patches (modifiers) on the object graph. </li></ol><br>  Modifiers, in turn, are divided into 2 types: <br><ol><li>  InstanceModifiers - object modifiers. </li><li>  ConstructModifiers - Construct modifiers. </li></ol><br><br>  For example. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class">:</span></span> bar = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class">:</span></span> baz = <span class="hljs-number"><span class="hljs-number">10</span></span> bars = Collection(Bar) my_foo = Builder(Foo).withA(NumberOf(Foo.bars, <span class="hljs-number"><span class="hljs-number">5</span></span>)).build()</code> </pre> <br><br>  Here the construction <code>bars = Collection(Bar)</code> is level 1. We say that the class Foo can contain N Bar objects.  These objects can be accessed via <code>my_foo.bars[i]</code> .  And the <code>NumberOf(Foo.bars, 5)</code> construction <code>NumberOf(Foo.bars, 5)</code> is level 2. We want to get a Foo object with 5 Bar objects inside. <br><br>  By default, a graph of 2 objects will be created: Foo and a nested collection of Bar objects, consisting of one element. <br>  <code>NumberOf(Foo.bars, 5)</code> is the same modifier that can be applied to the graph so that 5 Bar objects are embedded in the Foo object. <br><br>  Let's return to our car factory. <br><br><h4>  Object model </h4><br>  To begin with, we need to describe the classes of objects and their properties that our factory operates with. <br><br><pre> <code class="python hljs">CHASSIS_LIGHT = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">#  CHASSIS_HEAVY = 1 #  ENGINE_PETROL = 0 #  ENGINE_DIESEL = 1 #  WHEEL_STAMPED = 0 #  WHEEL_ALLOY = 1 #  BODY_SEDAN = 0 #  BODY_COUPE = 1 #  BODY_CABRIO = 2 #  BODY_HEAVY = 3 #  TRANSMISSION_MANUAL = 0 #  TRANSMISSION_AUTO = 1 #  # class Chassis: type = CHASSIS_LIGHT # class Engine: type = ENGINE_PETROL volume = 1.6 # class Wheel: radius = 15 type = WHEEL_STAMPED # class Body: type = BODY_SEDAN number = ??? #      .         . #  class Transmission: type = TRANSMISSION_MANUAL # #       .  -   /    . class Spoiler: foo = None</span></span></code> </pre> <br><br>  Fine! <br><br>  Here, the values ‚Äã‚Äãwith which the fields of our classes are initialized were just chosen based on the most common configuration.  Now there are not enough connections between objects and dynamic parameters: you need to specify how the individual parts are assembled in the car and specify the parameters. <br><br>  For example. <br><pre> <code class="python hljs">chassis = Chassis() wheels = [Wheel() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>)] engine = Engine() body = Body() ... chassis.wheels = wheels chassis.engine = engine engine.chassis = chassis chassis.body = body body.number = random() ...</code> </pre> <br><br>  For small graphs it is easy.  In the case when there are several dozens of objects and many parameters in a graph, it becomes very expensive.  To facilitate such a task, ObjectBuilders provides Constructs. <br><br><h4>  Constructs </h4><br>  Above was a short example of Foo-Bar, in which the Collection () construct was used. <br>  In our library there are several different types of structures for different needs. <br><br><blockquote>  class Collection (typeToBuild, number = 1) </blockquote><br>  A collection of objects of type typeToBuild.  After calling Builder.build (), this construct becomes a list of objects of type typeToBuild.  Default number of objects = 1 <br><br><blockquote>  class Unique (typeToBuild) </blockquote><br>  After calling Builder.build (), it becomes a unique object of type typeToBuild.  Unique in the sense that even if in our graph there is already somewhere an object of type typeToBuild, we will still generate a new one. <br><br><blockquote>  class Reused (typeToBuild, local = False, keys = []) </blockquote><br>  In contrast to the Unique construction, if there is already an object of type typeToBuild in the graph, then it will be used, if not, a new object will be created.  In this case, using the keys parameter, you can specify which fields of the typeToBuild class must match in order for the objects to be considered the same. <br><br><blockquote>  class Maybe (construct) </blockquote><br>  This construction suggests that the connection with another object (and this object itself, respectively) may or may not be present.  By default, when you call <code>Builder.build()</code> converted to None.  <code>Enabled()</code> modifier, which will be described below. <br><br><blockquote>  class Random (start = 1, end = 100500, pattern = None) </blockquote><br>  This construct at the <code>build()</code> stage is converted either into a random int from start to end, or, if a pattern is specified, into a string.  The pattern must contain one% d marker, in place of which a random number from start to end will be substituted. <br><br><blockquote>  class Uplink () </blockquote><br>  Allows you to configure the connection of objects in both directions, for example: foo.bar.foo = foo. <br><br>  Let's try to rewrite our model using Constructs so that it contains information about the connection of objects with each other. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># class Chassis: type = CHASSIS_LIGHT **engine = Unique(Engine)** **body = Unique(Body)** **wheels = Collection(Wheel, number=4)** **transmission = Reused(Transmission)** # class Engine: type = ENGINE_PETROL volume = 1.6 **transmission = Reused(Transmission)** # class Wheel: radius = 15 type = WHEEL_STAMPED **transmission = Reused(Transmission)** # class Body: type = BODY_SEDAN number = **Random()** #      .         . spoiler = **Maybe(Unique(Spoiler))** #     . - . #  class Transmission: type = TRANSMISSION_MANUAL # class Spoiler: foo = None</span></span></code> </pre> <br><br>  As a result, we described that: <br><ul><li>  By the chassis are attached: engine, body, wheels, transmission. </li><li>  Several wheels are mounted - 4 (by default, but it will be possible to change it dynamically later). </li><li>  The chassis, engine and wheels attach themselves to the transmission.  And the same.  This is indicated by the Reused construction. </li><li>  A spoiler can be attached to the body (as an option, there is no default). </li><li>  The body number will be generated during vehicle assembly. </li><li>  All other parameters are set by default (but they can also be dynamically set later). </li></ul><br><br>  What to do now with this?  Now we can get a full-fledged car in one call!  True to the base. <br><br><pre> <code class="python hljs">car = Builder(Chassis).build()</code> </pre> <br><br>  The object type is car - Chassis, therefore: <br><br><pre> <code class="python hljs">&gt;&gt;&gt;car.engine.volume <span class="hljs-number"><span class="hljs-number">1.6</span></span> &gt;&gt;&gt;car.wheels[<span class="hljs-number"><span class="hljs-number">0</span></span>].radius <span class="hljs-number"><span class="hljs-number">15</span></span> &gt;&gt;&gt;car.body.spoiler <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><br>  Well, and so on. <br><br>  That is, in addition, in fact, an object of type Chassis, all objects associated with an object of type Chassis will be created: Engine, Wheel x 4, Body, Transmission.  The Spoiler object will not be created, since by default Construct Maybe () does not create an object, but is converted to None. <br><br>  In general, we can start building a car from any part (the top of our graph), passing any of our classes to Builder (typeToBuild). <br>  But since our graph has directed edges, a graph will be constructed only with those vertices that can be reached from the initial one. <br><br>  In the current implementation, from the top of Chassis you can get to all of the tops, from the top of the Engine only to Transmission, and from the top of Body only to Spoiler. <br><br>  That is, for example: <br><br><pre> <code class="python hljs">&gt;&gt;&gt;engine = Builder(Engine).build() &gt;&gt;&gt;engine.trasmission.type == TRANSMISSION_MANUAL <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt;engine.transmission.engine AttributeError: Transmission instance has no attribute <span class="hljs-string"><span class="hljs-string">'engine'</span></span></code> </pre> <br>  Only these two objects will be created. <br><br>  In order to be able to start collecting a full-fledged car from any of the parts, it is necessary to hand over our communications bidirectionally. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># class Chassis: type = CHASSIS_LIGHT engine = Unique(Engine) body = Unique(Body) wheels = Collection(Wheel, number=4) transmission = Reused(Transmission) # class Engine: type = ENGINE_PETROL volume = 1.6 transmission = Reused(Transmission) **chassis = Uplink()** **Engine.chassis.linksTo(Chassis, Chassis.engine)** # class Wheel: radius = 15 type = WHEEL_STAMPED transmission = Reused(Transmission) **chassis = Uplink()** **Wheel.chassis.linksTo(Chassis, Chassis.wheels)** # class Body: type = BODY_SEDAN number = Random() #      .         . spoiler = Maybe(Unique(Spoiler)) #     . - . **chassis = Uplink()** **Body.chassis.linksTo(Chassis, Chassis.body)** #  class Transmission: type = TRANSMISSION_MANUAL **chassis = Uplink()** **engine = Uplink()** **Transmission.chassis.linksTo(Chassis, Chassis.transmission)** **Transmission.engine.linksTo(Engine, Engine.transmission)** # class Spoiler: foo = None **body = Uplink()** **Spoiler.body.linksTo(Body, Body.spoiler)**</span></span></code> </pre><br><br>  Now, when calling Builder (typeToBuild) .build (), we can build a car from any detail!  Wherein: <br><pre> <code class="python hljs">&gt;&gt;&gt;engine = Builder(Engine).build() &gt;&gt;&gt;engine.transmission.chassis.engine == engine <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt;engine.transmission.chassis.wheels[<span class="hljs-number"><span class="hljs-number">0</span></span>].transmission.engine == engine <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Bilder, passing through the links (including Uplink'am), will create all the necessary objects, which simplifies the use of the model. <br>  For example, if you use an object of type Engine, it is more convenient for you to use the Builder (Engine), but all the necessary objects will be created and connected with each other. <br><br>  So, we looked at how you can conveniently describe the object model of our system under test by building a whole car with it.  But this car is still in the base. <br><br><h4>  Modifiers </h4><br>  To modify the basic configuration of our objects graph, several types of modifiers are provided in the ObjectBuilders library.  As mentioned above, modifiers are divided into two types: InstanceModifier and ConstructModifier. <br><ul><li>  InstanceModifier allows you to change the fields of objects that are represented by values, as well as perform some actions on the finished objects. </li><li>  ConstructModifier allows you to change the parameters of the Constructs objects that are assigned to some fields of our classes. </li></ul><br>  Consider the list of all modifiers and their capabilities (their work will be demonstrated on examples below). <br><br><blockquote>  class InstanceModifier (classToRunOn) </blockquote><br>  Actually the first and only (so far) InstanceModifier level modifier.  Allows you to change the values ‚Äã‚Äãof fields of objects or perform over them some actions.  When you call <code>Builder.build()</code> will be executed on each of the objects of type classToRunOn in our object graph. <br><br>  It has two methods. <br><ul><li>  <code>def thatSets(self, **kwargs)</code> - allows changing the field values ‚Äã‚Äãof objects.  The arguments are the key = value pairs, where key is the name of the field in the object of the classToRunOn type, to which the value must be assigned. </li><li>  <code>def thatDoes(self, action)</code> - allows you to perform some action on objects of type classToRunOn.  action is a method that takes an object of type classToRunOn as an argument. </li></ul><br><blockquote>  class Enabled (what) </blockquote><br>  ConstructModifier level modifier.  Allows you to translate the Maybe construction into an active state so that when you call Builder.build () it starts creating an object.  <b>what</b> - Maybe construction.  For example Body.spoiler in our example about the car. <br><br><blockquote>  class Given (construct, value) </blockquote><br>  ConstructModifier level modifier.  Allows at the stage of creating a graph to replace any Construct (what) with a specific object or value. <br><br><blockquote>  class HavingIn (what, * instances) </blockquote><br>  ConstructModifier level modifier.  Used on Collection constructs (what), allowing you to add specific objects (* instances) to them. <br>  Or, if one of the * instances elements is an int, then the size of the collection will increase by the value of this int.  At the same time, the number of objects generated by the Collection by the construction of objects will decrease by the number of objects that we have explicitly added. <br><br><blockquote>  class NumberOf (what, amount) </blockquote><br>  ConstructModifier level modifier.  Used on Collection constructs (what), allowing you to resize them to amount. <br><br><blockquote>  class OneOf (what, * modifiers) </blockquote><br>  ConstructModifier level modifier.  Used on Collection constructs (what), allowing you to apply a set of modifiers * modifiers on one of the objects in the collection.  Actually, at the moment - this is the whole set of available modifiers.  They allow you to conveniently describe almost any modifications of the basic configuration of our graph. <br><br>  Modifiers are applied to our object graph at the build stage by calling the Builder.withA (* modifiers) method. <br><br>  Consider the work of modifiers in the examples. <br><br>  <i>Example 1.</i> We want a car with a spoiler! <br><pre> <code class="python hljs">spoiler_option = Enabled(Body.spoiler) car = Builder(Chassis).withA(spoiler_option).build() &gt;&gt;&gt;car.body.spoiler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><br>  <i>Example 2.</i> We want a car with a diesel six-liter engine! <br><pre> <code class="python hljs">big_diesel = InstanceModifier(Engine).thatSets(type=ENGINE_DIESEL, volume=<span class="hljs-number"><span class="hljs-number">6.0</span></span>) car = Builder(Chassis).withA(big_diesel).build() &gt;&gt;&gt;car.engine.volume == <span class="hljs-number"><span class="hljs-number">6.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt;car.engine.type == ENGINE_DIESEL <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><br>  You can do the same thing with InstanceModifier.thatDoes (): <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_big_engine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(engine)</span></span></span><span class="hljs-function">:</span></span> engine.type = ENGINE_DIESEL engine.volume = <span class="hljs-number"><span class="hljs-number">6.0</span></span> big_diesel = InstanceModifier(Engine).thatDoes(make_big_engine)</code> </pre> <br>  Usually, this is used if the parameters need to be somehow dynamically calculated at the test execution stage, since in the make_big_engine method you can perform any calculations or implement any conditions. <br><br>  <i>Example 3.</i> We want 6 wheels and a heavy platform. <br><pre> <code class="python hljs">six_wheeled_heavy_chassis = [NumberOf(Chassis.wheels, <span class="hljs-number"><span class="hljs-number">6</span></span>), InstanceModifier(Chassis).thatSets(Chassis.type=CHASSIS_HEAVY)] car = Builder(Chassis).withA(six_wheeled_heavy_chassis).build() &gt;&gt;&gt;len(car.chassis.wheels) == <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt;car.chassis.type == CHASSIS_HEAVY <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br><br>  Here you should pay attention to the fact that the Builder.withA () method can accept as one Modifier object, an array of such objects, or an array with nested arrays of any depth. <br>  <i>Example 4</i>  We want a powerful all-terrain vehicle with a large body and a bunch of wheels. <br><pre> <code class="python hljs">rover_capabilities = [big_diesel] + \ six_wheeled_heavy_chassis + \ [InstanceModifier(Body).thatSets(type=BODY_HEAVY)] rover = Builder(Chassis).withA(rover_capabilities).build()</code> </pre> <br><br>  The key point is that we have reused the modifiers <b>big_diesel</b> and <b>six_wheeled_heavy_chassis</b> we have already written.  So in real life - the more tests you write, the more you will have ready-made modifiers.  This gives three advantages: <br><ol><li>  You can reuse modifiers and write tests faster, thinking about how to test, and not about how to prepare the necessary data </li><li>  Correct modifier names make it easy to understand exactly what data is used in the test and how it is configured. </li><li>  With changes in the system configuration (for example, the developers have made a feature in which the connections between objects change) you can easily repair all the tests in one place, having fixed only modifiers that have become wrong! </li></ol><br>  <i>Example 5.</i> We want to check how the all-terrain vehicle will go if one of the wheels has a radius of 14 ", one is 16", and 4 others - 15 ". <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wheel_radius</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> OneOf(Chassis.wheels, InstanceModifier(Wheel).thatSets(radius=radius)) car = Builder(Chassis).withA(rover_capabilities) .withA(wheel_radius(<span class="hljs-number"><span class="hljs-number">14</span></span>), wheel_radius(<span class="hljs-number"><span class="hljs-number">16</span></span>)) .build()</code> </pre> <br><br>  <i>Example 6.</i> We still have 2 of the last unused types of modifiers: HavingIn and Given.  They differ only in the fact that HavingIn is applied on the construction of the Collection, and Given on all other constructions in order to place the finished object instead of them. <br><br>  Consider only havingIn example.  Suppose we already have one wheel from the past car and we want to put it on a new one. <br><br><pre> <code class="python hljs">wheel = Wheel() car = Builder(Chassis).withA(HavingIn(Chassis.wheels, wheel)).build()</code> </pre> <br><br>  The Given modifier works similarly. <br><br>  BUT: you need to be careful with the use of these modifiers, since transferring the finished object there, no links will be created in it or something will change, it will be substituted into the as-is graph. <br><br>  Consider the algorithm of the call <code>Builder(typeToBuild).withA(*modifiers).build()</code> : <br><ol><li>  A current object of type <code>typeToBuild</code> </li><li>  If there are Construct modifiers in the * modifiers list, they are applied to Construct objects of the corresponding type in the properties of the current object </li><li>  All Construct objects in the properties of the current object are converted into objects, in accordance with the rules of each individual Construct </li><li>  If you have <code>InstanceModifier(currentObjectType).thatSets()</code> in the * modifiers list, they are applied to the current object </li><li>  Recursively descend into all objects obtained from the converted Constructs, and repeat the algorithm from step 2 </li><li>  In the presence of <code>InstanceModifier(clazz).thatDoes()</code> in the list * modifiers, they are used by objects of type clazz in the constructed graph </li></ol><br><br>  That's all!  With this simple library, we were able to greatly facilitate our lives and save a lot of man-hours of work. <br><br><h4>  The bottom line: what do we have and why is all this necessary? </h4><br><ol><li>  ObjectBuilders provides the ability to easily and in a readable form describe the properties of the data described by the object model and dynamically generate this data. </li><li>  The logic of connections between objects and their modifications are separated into a separate logical level, which allows you to reuse the previously described data configurations and, if necessary, easily repair the communication logic and data configuration in one place, instead of repairing it in all the places where the data were used. </li><li>  Now, in tests, it is possible to describe only the properties that really affect the test behavior, without worrying about all the necessary "side" settings and objects, which makes it easy to understand the relationship between the data and the system behavior (tests in the test). </li></ol><br><br>  However, our approach at the current stage of implementation has its drawbacks: <br><ul><li>  In the case of large object models, it becomes quite time-consuming to correctly describe all relationships. </li><li>  With the accumulation of a large amount of ‚Äúpackages‚Äù of modifiers, the temptation to write one's own increases, rather than re-using existing ones. </li><li>  When simultaneously applying a large set of modifiers to a graph, it is difficult to notice / find data inconsistencies in case of an error. </li></ul><br>  The first minus is not so critical, because usually the model either changes very rarely or changes very little.  The second minus is inherent in any developing piece of code (copy-paste lovers are everywhere).  The third minus is gradually negated as the accumulation of ready (read "debugged") modifier packages, besides, the discrepancies will still become visible during the test run over the data obtained. <br><br>  Even taking into account all the shortcomings, our approach saves time when writing tests, supporting tests, needing to figure out how this or that system behavior depending on data is configured.  In general, everything that was said earlier was spoken about objects in memory when Python was started, which have nothing to do with the data actually entering the system.   -   ‚Äî           ,       . <br><br> ,   ,   XMLRPC API  SQL Alchemy       .    ObjectBuilders         JSON  XML.      ObjectBuilders,        .  ,  -             .       . <br><br> <a href="http://bit.ly/objectbuilders">   Github.</a> <br> <a href="https://pypi.python.org/pypi/builders">   pypi.</a> <br><br>  Use on health! </div><p>Source: <a href="https://habr.com/ru/post/204192/">https://habr.com/ru/post/204192/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204176/index.html">Writing a plugin for CKEditor 4</a></li>
<li><a href="../204178/index.html">News: Jolla introduced its first smartphone on Sailfish OS. Price ‚Ç¨ 399</a></li>
<li><a href="../204180/index.html">Intel: server component life shortened due to environmental pollution</a></li>
<li><a href="../204184/index.html">Smartphone Lexand Vega: a pleasant "budget" on the platform MediaTek MT6572</a></li>
<li><a href="../204190/index.html">"Perfect" cluster. Part 2.1: Virtual hetzner cluster</a></li>
<li><a href="../204194/index.html">What you should know about flat design</a></li>
<li><a href="../204196/index.html">Is it worth it to believe sang a check? About wait five</a></li>
<li><a href="../204198/index.html">JetBrains update season: RubyMine 6.0</a></li>
<li><a href="../204200/index.html">Disk shelf ETegro Fastor JS300 G3</a></li>
<li><a href="../204204/index.html">Training in web development, web design and internet marketing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>