<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write the panel for i3 window manager on Qt</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="i3 is my favorite tile window manager. But quite recently, having taken up the regular repainting of my desktop, I came across one most unpleasant thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write the panel for i3 window manager on Qt</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://i3wm.org/">i3</a> is my favorite tile window manager.  But quite recently, having taken up the regular repainting of my desktop, I came across one most unpleasant thing: the functionality of the native panel is not enough at all to embody all of my fantasies.  In particular, it does not know how to change the size or change the color of the borders.  And what does a linuksoid do when the software does not suit him and there are no alternatives (and there are none)?  That's right, patch existing, or write your own.  I have no desire to deal with xcb, on which the standard panel is written, so I followed the second path.  C ++ was chosen as the language.  About the framework ask KO <br><a name="habracut"></a><br><h5>  Foreword </h5><br>  What is the panel?  Wikipedia on this subject tells us: <br>  ‚ÄúTaskbar (eng. Taskbar) is an application that is used to launch other programs or control already running, and is a toolbar.  Particularly used to manage windows applications. " <br>  But in tile window managers, things are not that simple.  Windows in them do not overlap each other.  The manager allocates to each window its own space (tile) on which this window is stretched.  For example: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5de/c8d/0eb/5dec8d0eb01fa78d6de5079af1b62695.png" alt="image"></a> <br><br>  See you  All windows in sight.  So the question of the need for the taskbar in such managers disappears by itself.  But on one screen, many applications do not fit.  What to do?  And here comes the concept of multiple desktops.  It's damn convenient!  There is no need to change the focus of windows, their size and position every minute.  I switched to the first desktop - here you have a set of applications for development, switched to the second - keep the file manager and player next to it.  And so on.  Theoretically, there can be infinitely many desktops, but it can be quite problematic to use more than 10 at a time. <br>  So, our panel will not manage windows, but desktops.  Therefore, I prefer to use just the word ‚Äúpanel‚Äù, rather than the phrase ‚Äútaskbar‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  We start the development </h5><br>  As a friendship begins with a smile, most Qt applications start with a widget.  So we will not depart from the traditions and first of all we will write a widget for our future panel.  For now, it will be just a class inherited from QWidget.  With the designer and destructor. <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Q3Panel</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QWidget { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Q3Panel(QWidget *parent = <span class="hljs-number"><span class="hljs-number">0</span></span>); ~Q3Panel(); };</code> </pre> <br>  If you now display this widget, you will see a blank window to the painfully familiar # D4D0C8 color.  To turn this into a panel, we need a little magic and change one flag. <br><pre> <code class="cpp hljs">setAttribute(Qt::WA_X11NetWmWindowTypeDock, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  Just add this to our widget's constructor.  Thus, you set the property of our window _NET_WM_WINDOW_TYPE X11 to the value of _NET_WM_WINDOW_TYPE_DOCK.  Now it's not just a window, but a dock!  We'll see: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2be/341/63e/2be34163e517db6b85f1061b54403ac9.png" alt="image"></a> <br><br>  Here it is, the panel of my dreams, hefty!  Too hefty, actually.  Control of the size and position, we would not interfere. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Q3Panel::setup(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height) { QRect screen = QApplication::desktop()-&gt;screenGeometry(); resize(screen.width(), height); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; x = screen.left(); y = position() == top ? screen.top() : screen.bottom(); move(x, y); }</code> </pre><br>  In this method, in the screen variable we get the geometry of the so-called <a href="http://en.wikipedia.org/wiki/Root_window">root window</a> .  Calling the resize () method makes the width of our panel equal to the width of the screen, and the height equal to the passed parameter.  In the variable x, we write the left coordinate of our screen, and in y, the upper or lower coordinate, depending on the position.  Then we move our panel along the (x, y) coordinates.  position (), as you may have guessed, is one of two methods for working with a hidden property: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">Position </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">position</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _position; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Position position)</span></span></span><span class="hljs-function"> </span></span>{ _position = position; }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Position _position;</code> </pre><br>  Now we can control the size and position of our panel.  It's time to move on to the next step. <br><br><h5>  Chat with i3 </h5><br>  So we got to the most interesting part.  To manage our window manager, you need to somehow communicate with it.  Fortunately, i3 out of the box supports such an <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B6%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B2%25D0%25B7%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25B9%25D1%2581%25D1%2582%25D0%25B2%25D0%25B8%25D0%25B5">IPC</a> method as <a href="http://ru.wikipedia.org/wiki/Unix_domain_socket">unix socket</a> 's.  And even more fortunately, Qt has a very convenient class for working with them - QLocalSocket. <br>  But first, a brief description of the protocol.  The message is as follows: <br><br> <code>&lt; &gt; &lt; &gt; &lt; &gt; &lt;&gt;</code> <br> <br>  Now about everything in order.  The magic string is ‚Äúi3-ipc‚Äù.  Its sole purpose is to control protocol versions.  It is followed by a 32-bit number, which stores the size of the message.  Then exactly the same 32-bit message type, followed by the message itself.  The message type can have the following values: <br><ul><li>  <b>COMMAND</b> (0) - the message contains the command </li><li>  <b>GET_WORKSPACES</b> (1) - get a list of desktops </li><li>  <b>SUBSCRIBE</b> (2) - subscribe to a specific event </li><li>  <b>GET_OUTPUTS</b> (3) - get a list of output devices </li><li>  <b>GET_TREE</b> (4) - get a list of all windows of all desktops </li><li>  <b>GET_MARKS</b> (5) - get a list of container identifiers </li><li>  <b>GET_BAR_CONFIG</b> (6) - get the panel configuration from the i3 config </li></ul><br>  Using all this functionality, you can create a panel with a bunch of features, but in this article we will limit ourselves only to the display and switching of desktops.  For this we need 3 types of messages: COMMAND, GET_WORKSPACES and SUBSCRIBE.  Now more about each.  Oh yeah, I almost forgot.  The data format that i3 receives and sends is json. <br><br>  <b>COMMAND</b> : I will not describe all the possible commands - there are too many of them.  To switch desktops, we need only one: ‚Äúworkspace number X‚Äù, where X is the desktop number.  The response to the command is an associative array, which contains only one property - ‚Äúsuccess‚Äù, which can be true or false.  Sample answer: <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"success"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  <b>GET_WORKSPACES</b> : the message body is empty, the answer is a list of desktops, each of which contains the following properties: <br><ul><li>  <b>num</b> (integer) - logical number of the desktop </li><li>  <b>name</b> (string) - the name of the desktop in UTF-8 </li><li>  <b>visible</b> (boolean) - whether the desktop is displayed.  In the case of multiple output devices, multiple desktops can be displayed simultaneously. </li><li>  <b>focused</b> (boolean) - whether the desktop is in focus.  Only one desktop can be in focus at the same time. </li><li>  <b>urgent</b> (boolean) - is there a window on the desktop requiring user attention (here I can be wrong, but I understood that way) </li><li>  <b>rect</b> (map) - desktop geometry, containing x and y coordinates, width and height </li><li>  <b>output</b> (string) - the output device on which the desktop is displayed </li></ul><br>  Sample answer: <br><pre> <code class="javascript hljs">[ { <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"visible"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"focused"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"urgent"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"rect"</span></span>: { <span class="hljs-string"><span class="hljs-string">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"width"</span></span>: <span class="hljs-number"><span class="hljs-number">1280</span></span>, <span class="hljs-string"><span class="hljs-string">"height"</span></span>: <span class="hljs-number"><span class="hljs-number">800</span></span> }, <span class="hljs-string"><span class="hljs-string">"output"</span></span>: <span class="hljs-string"><span class="hljs-string">"LVDS1"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"visible"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"focused"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"urgent"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"rect"</span></span>: { <span class="hljs-string"><span class="hljs-string">"x"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"y"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"width"</span></span>: <span class="hljs-number"><span class="hljs-number">1280</span></span>, <span class="hljs-string"><span class="hljs-string">"height"</span></span>: <span class="hljs-number"><span class="hljs-number">800</span></span> }, <span class="hljs-string"><span class="hljs-string">"output"</span></span>: <span class="hljs-string"><span class="hljs-string">"LVDS1"</span></span> } ]</code> </pre><br>  <b>SUBSCRIBE</b> : i3 allows you to subscribe to events.  In total there are 2 types of events: <br><ul><li>  <b>workspace</b> (0) - events related to desktops.  The body contains only one single property - ‚Äúchange‚Äù, which can take values: <br><ul><li>  focus - when focus shifts to another desktop </li><li>  init - when creating a new desktop </li><li>  empty - when deleting an empty desktop </li></ul></li><li>  <b>output</b> (1) - events associated with output devices. </li></ul><br>  The event message is completely identical to the standard message with the only difference that the most significant bit of the message type is set to 1. So, of the two types of events, we are only interested in the first one.  His body is an associative array with one string property ‚Äúchanged‚Äù, which can take the values ‚Äã‚Äã‚Äúfocus‚Äù, ‚Äúinit‚Äù, ‚Äúempty‚Äù and ‚Äúurgent‚Äù.  Sample answer: <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"change"</span></span>: <span class="hljs-string"><span class="hljs-string">"focus"</span></span> }</code> </pre><br>  Armed with knowledge of the protocol, you can begin to implement our client.  We will use 2 sockets: one will be subscribed to events, with the help of the other we will send commands and receive a list of desktops.  The general algorithm is as follows: <br><ol><li>  Connect </li><li>  Update the list of desktops </li><li>  Subscribing to the workspace event </li><li>  We wait </li><li>  When the event arrives, we update the list of desktops </li><li>  goto 4 </li></ol><br>  Let me remind you that the <a href="http://ru.wikipedia.org/wiki/Unix_domain_socket">unix socket</a> 's identifier is a file in the file system.  You can get its name either by reading the ‚ÄúI3_SOCKET_PATH‚Äù property of the <a href="http://en.wikipedia.org/wiki/Root_window">root window</a> , or by calling i3 --get-socketpath.  I took the path of least resistance: <br><pre> <code class="cpp hljs">QString I3Ipc::getSocketPath() { QProcess i3process; i3process.start(<span class="hljs-string"><span class="hljs-string">"i3 --get-socketpath"</span></span>, QIODevice::ReadOnly); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!i3process.waitForFinished()) { qDebug() &lt;&lt; i3process.errorString(); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString(i3process.readAllStandardOutput()).remove(QChar(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>)); }</code> </pre><br>  Now, knowing the path to the socket file, you can join the server: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I3Ipc::reconnect() { mainSocket-&gt;<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); eventSocket-&gt;<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); QString socketPath = getSocketPath(); mainSocket-&gt;connectToServer(socketPath); eventSocket-&gt;connectToServer(socketPath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mainSocket-&gt;waitForConnected() || !eventSocket-&gt;waitForConnected()) { qDebug() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Connection timeout!"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } subscribe(); }</code> </pre><br>  And send data: <br><pre> <code class="cpp hljs">QByteArray I3Ipc::pack(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> type, QString payload) { QByteArray b; <span class="hljs-function"><span class="hljs-function">QDataStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;b, QIODevice::WriteOnly)</span></span></span></span>; s.setByteOrder(QDataStream::LittleEndian); s.writeRawData(I3_IPC_MAGIC, qstrlen(I3_IPC_MAGIC)); s &lt;&lt; (quint32) payload.size(); s &lt;&lt; (quint32) type; s.writeRawData(payload.toAscii().data(), payload.size()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I3Ipc::send(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> type, QString payload) { send(type, payload, mainSocket); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I3Ipc::send(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> type, QString payload, QLocalSocket* socket) { socket-&gt;write(pack(type, payload)); }</code> </pre><br>  If you carefully read the part about the protocol, then this code should be clear to you.  We pack the data and write to the socket.  I3_IPC_MAGIC is a constant from the &lt;i3 / ipc.h&gt; header file describing the protocol. <br>  Regarding setByteOrder (): the standard for QDataStream is BigEndian byte order, and i3 is waiting for data in the native, therefore either such a crutch or you will have to abandon QDataStream in favor of char arrays and memcpy ().  We learned to send data, now we learn to accept answers: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I3Ipc::read() { QLocalSocket *socket = (QLocalSocket*)sender(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (socket-&gt;bytesAvailable() &lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (qstrlen(I3_IPC_MAGIC) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(quint32) * <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-function"><span class="hljs-function">QDataStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket)</span></span></span></span>; s.setByteOrder(QDataStream::LittleEndian); quint32 msgType, payloadSize; s.skipRawData(qstrlen(I3_IPC_MAGIC)); s &gt;&gt; payloadSize; s &gt;&gt; msgType; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (socket-&gt;bytesAvailable() &lt; payloadSize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!socket-&gt;waitForReadyRead()) { qDebug() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Reading timeout!"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } } <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[payloadSize]; s.readRawData(buf, payloadSize); <span class="hljs-function"><span class="hljs-function">QByteArray </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jsonPayload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf, payloadSize)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msgType &gt;&gt; <span class="hljs-number"><span class="hljs-number">31</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msgType == I3_IPC_EVENT_WORKSPACE) { <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">workspaceEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msgType == I3_IPC_REPLY_TYPE_WORKSPACES) { emit workspaceReply(jsonPayload); } } }</code> </pre><br>  Here, too, everything is extremely simple: we wait until 14 bytes have accumulated (6 is the magic line and two 4-byte numbers), we miss 6 bytes and read the message size and its type into variables.  It remains only to wait for the message itself and, depending on the type, to send the appropriate signal. <br>  Now, after each event, we will receive the current list of desktops in json-format.  To bring it to a ‚Äúnormal‚Äù state, we will use the QJson library.  In many distributions it is in the repositories, and if not, no one bothers to build it yourself.  So, we connect: <br><pre> <code class="cpp hljs">LIBS += -lqjson</code> </pre><br>  In the .pro file and <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;qjson/parser.h&gt;</span></span></span></span></code> </pre><br>  In the header file.  QJson is extremely easy to use. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Q3Panel::workspaceReplySlot(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QByteArray jsonPayload) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ok; QList&lt;QVariant&gt; workspacesList = jsonParser-&gt;parse(jsonPayload, &amp;ok).toList(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ok) { qDebug() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Parser error: "</span></span> &lt;&lt; jsonParser-&gt;errorString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } workspaces-&gt;clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; workspacesList.size(); ++i) { QMap&lt;QString, QVariant&gt; w = workspacesList.at(i).toMap(); workspaces-&gt;insert(w.value(<span class="hljs-string"><span class="hljs-string">"num"</span></span>).toUInt(), workspaceInfo(w.value(<span class="hljs-string"><span class="hljs-string">"name"</span></span>).toString(), w.value(<span class="hljs-string"><span class="hljs-string">"focused"</span></span>).toBool(), w.value(<span class="hljs-string"><span class="hljs-string">"urgent"</span></span>).toBool())); } <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateWorkspacesWidget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(workspaces)</span></span></span></span>; }</code> </pre><br>  workspaces is a hash table in which we store information about desktops.  Its key is the quint16 number of the desktop, and the value is such a structure: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">workspaceInfo</span></span></span><span class="hljs-class"> {</span></span> QString name; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> focused; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> urgent; workspaceInfo(QString _n, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _f = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _u = <span class="hljs-number"><span class="hljs-number">0</span></span>) { name = _n; focused = _f; urgent = _u; } };</code> </pre><br>  Everything is simple and clear.  We are able to receive information about desktops, to store too.  A trifle remains: to display it and by clicking on a specific desktop send a command to the window manager.  You can go different ways, I decided to write my widget based on QHBoxLayout.  Nothing complicated, store a hash table, where the key is the number of the desktop, and the value is a link to the WorkspaceButton button.  WorkspaceButton is inherited from QToolButton and does not represent anything new, except for its policy of changing the size and style.  After each update of the list of desktops, it is necessary to update the widget.  It would be possible to simply delete all the buttons and create them, but we will go in a slightly different way: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WorkspacesWidget::updateWorkspacesWidgetSlot(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QHash&lt;qint16, workspaceInfo&gt; *workspaces) { clearLayout(); QHash&lt;qint16, workspaceInfo&gt;::const_iterator wi = workspaces-&gt;constBegin(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (wi != workspaces-&gt;constEnd()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buttons-&gt;contains(wi.key())) { buttons-&gt;value(wi.key())-&gt;setFocused(wi.value().focused); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { addButton(wi.key(), wi.value().focused, wi.value().name); } ++wi; } QHash&lt;qint16, WorkspaceButton*&gt;::const_iterator bi = buttons-&gt;constBegin(); QList&lt;qint16&gt; toDelete; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (bi != buttons-&gt;constEnd()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!workspaces-&gt;contains(bi.key())) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> bi.value(); toDelete &lt;&lt; bi.key(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mainLayout-&gt;addWidget(bi.value()); } ++bi; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; toDelete.size(); ++i) { buttons-&gt;remove(toDelete.at(i)); } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WorkspacesWidget::clearLayout() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (mainLayout-&gt;takeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> WorkspacesWidget::addButton(quint16 num, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> focused, QString name) { WorkspaceButton* newButton = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WorkspaceButton(name, focused); connect(newButton, SIGNAL(clicked()), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(buttonClickedSlot())); buttons-&gt;insert(num, newButton); }</code> </pre><br>  First, we clear QHBoxLayout and go through the workspaces elements and, if there is already a button for the current desktop, update the focused property.  If there is no button, add it.  Then we check all the elements of buttons to see if the desktop still exists or not.  And, if exists, we add on QHBoxLayout.  If not, delete.  I do not know how optimal this method is, but it seemed to me much better than to delete and re-create all the buttons every time. <br>  Everything!  Here it is, our panel: <br> <a href=""><img src="http://storage7.static.itmages.ru/i/12/0718/h_1342621088_8590920_a007907dc3.png" alt="image"></a> <br>  Works fine, displays displays, switches.  But this is just a basic functionality, something to catch up and overtake the standard panel in terms of functionality, it remains to add the settings, the tray, the menu and the clock.  About this in the next article, if, of course, the topic will be interesting. <br><br>  <a href="https://bitbucket.org/Crazy_penguin/q3panel/src">Source Code Repository</a> </div><p>Source: <a href="https://habr.com/ru/post/147224/">https://habr.com/ru/post/147224/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147215/index.html">What will happen after the entry into force of the law ‚ÄúOn protection of children from information?‚Äù</a></li>
<li><a href="../147217/index.html">Video tutorials on creating components on Joomla 1.5</a></li>
<li><a href="../147218/index.html">Wikileaks publishes 2.4 million emails from Syrian authorities</a></li>
<li><a href="../147219/index.html">MapBox Static API</a></li>
<li><a href="../147221/index.html">Miniature Linux MIPS Laptop</a></li>
<li><a href="../147226/index.html">Font anatomy</a></li>
<li><a href="../147229/index.html">Yota CEO Denis Sverdlov appointed Deputy Minister of Communications</a></li>
<li><a href="../147230/index.html">Transferring Files from a Siemens Phone to Linux - SieFS</a></li>
<li><a href="../147231/index.html">Hi from 1996: personal computer for 5 million rubles</a></li>
<li><a href="../147232/index.html">Editing and pricing Windows Server 2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>