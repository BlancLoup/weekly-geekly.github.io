<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>In Search of Performance, Part 2: Java Profiling for Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Argued that you can endlessly look at the fire, water and how others work, but there is something else! We are sure that you can talk endlessly with S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>In Search of Performance, Part 2: Java Profiling for Linux</h1><div class="post__text post__text-html js-mediator-article">  Argued that you can endlessly look at the fire, water and how others work, but there is something else!  We are sure that you can talk endlessly with Sasha <a href="https://habrahabr.ru/users/goldshtn/" class="user_link">goldshtn</a> Goldstein about performance.  We already <a href="https://habrahabr.ru/company/jugru/blog/320620/">interviewed</a> Sasha before JPoint 2017, but then the conversation was specifically about BPF, to which Sasha‚Äôs report was devoted. <br><br>  This time we decided to dig deeper and find out the fundamental problems of monitoring performance and their solutions. <br><br><img src="https://habrastorage.org/webt/59/cc/e8/59cce87023d03470935360.jpeg"><br><a name="habracut"></a><br><h3>  Where to start </h3><br>  <b>- Last time we talked in some detail about BPF and briefly discussed the problems of monitoring Java performance under Linux.</b>  <b>This time I would like to concentrate not on a specific tool, but on problems and the search for solutions.</b>  <b>The first question, rather trivial, is how to understand that there are problems with performance?</b>  <b>Should I think about this if the user does not complain?</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Sasha Goldstein:</b> If you start thinking about performance only at the moment when your users complain, they will not be with you for long.  For many, performance engineering is trashshuting and crisis mode.  The phones are ringing, the light is flashing, the system has fallen, the keyboard is on - the usual working life of a performance engineer.  In reality, they spend most of their time planning, designing, monitoring and preventing crises. <br><br>  To begin with, capacity planning is an estimate of the expected system load and resource utilization;  designing scalability will help avoid bottlenecks and get significant increases in load;  Instrumentation and monitoring are vital for understanding what is happening inside the system so as not to dig blindly;  thanks to the installation of the automatic notification, you will know exactly about any problems that arise, as a rule, even before users start complaining;  and of course there will be single crises that will have to be resolved in stressful conditions. <br><br>  It is worth noting that the tula are constantly changing, but the process itself remains unchanged.  I will give a couple of concrete examples: you can do capacity planning on a piece of paper on your knee;  You can use APM solutions (like New Relic or Plumbr) for end-to-end instrumentation and monitoring, AB and JMeter for quick load testing, and so on.  To learn more, you can read Brendan Gregg‚Äôs <a href="http://www.brendangregg.com/sysperfbook.html">book, Systems Performance</a> , an excellent source on the life cycle and performance methodology, and Google <a href="https://landing.google.com/sre/book.html">‚Äôs Site Reliability Engineering</a> covers the topic of Service Level Objectives and their monitoring. <br><br>  <b>- Suppose we understand that there is a problem: where to start?</b>  <b>It often seems to me that many (especially not professional performance engineers) are immediately ready to uncover JMH, rewrite everything to unsafe and ‚Äúhack compilers‚Äù.</b>  <b>Then watch what happened.</b>  <b>But in reality it is better not to start with this?</b> <br><br>  <b>Sasha Goldstein:</b> This is a fairly common practice, when writing code and performing basic profiler tests, problems arise with performance, which can be easily corrected by changing the code or ‚Äúhacking compilers‚Äù.  However, on the sale, based on my experience, this is done not so often.  Many problems are inherent in only one environment, caused by changing workload patterns or associated with bottlenecks outside the code of your application, and only a small part can be mixed and improved at the source level by smart hacks. <br><br>  Here are a couple of examples to illustrate: <br><br><ul><li>  A couple of years ago, Datadog encountered a problem when database inserts and updates in PostgreSQL jumped from 50 ms to 800 ms.  They used AWS EBS with SSD.  What did it do?  Instead of tuning the database or changing the application code, they found that EBS throttling was to blame for everything: it has an IOPS quota, which, if exceeded, will fall under the performance limit. </li><li>  Recently, I had a user with the problem of huge response time on the server, which was associated with delays in garbage collection.  Some requests took more than 5 seconds (and they appeared completely haphazard), since garbage collection was out of control.  Having carefully studied the system, we found that everything was in order with the memory allocation of the application or with the tuning of garbage collection;  due to a jump in the size of the workload, the actual memory usage has increased and caused swapping, which is absolutely detrimental to implement any garbage collection (if the collector needs to pump up and pump out memory to mark active objects, this is the end). </li><li>  A couple of months ago, Sysdig ran into a container isolation problem: being close to container X, file system operations performed by container Y were much slower, while memory usage and processor utilization for both containers were very low.  After a little research, they found that the kernel's directory cache was overloaded with container X, which later caused a hash table collision and, as a result, a significant slowdown.  Again, changing the application code or container resource allocation would not have solved this problem. </li></ul><br>  I understand that it is often much easier to focus on things that you can manage, for example, application-level hacks.  Purely psychologically, this is understandable, does not require in-depth knowledge of the system or environment, and for some reason is considered ‚Äúcooler‚Äù in some cultures.  But to address this in the first place is wrong. <br><br>  <b>- Probably you should first see how the application / service works in production.</b>  <b>What tools do you recommend for this, and which ones - not so much?</b> <br><br>  <b>Sasha Goldstein:</b> Monitoring and profiling on the sale is a set of tools and a technician. <br><br>  We start with high-level performance metrics, focusing on the use of resources (processor, memory, disk, network) and load characteristics (# of queries, errors, types of requests, # of database requests).  There are standard tools for obtaining this data for each operation and execution time.  For example, Linux usually uses tools like vmstat, iostat, sar, ifconfig, pidstat;  for JVM, use JMX-based tools or jstat.  These are metrics that can be continuously collected into a database, perhaps at a 5 or 30 second interval, so that you can analyze jumps and, if necessary, go back in time, to correlate previous deployment operations, releases, world events, or workload changes. .  It is important that many focus on collecting only average values;  although they are good, but, by definition, do not represent the complete distribution of what you measure.  It is much better to collect percentiles, and if possible even histograms. <br><br>  The next level is operational metrics that usually cannot be continuously collected or stored for a long time.  These include: garbage collection log, network requests, database requests, class loads, and so on.  Understanding this data after it has been stored somewhere is sometimes much more difficult than actually collecting it.  This allows, however, to ask questions, such as ‚Äúwhat requests worked while the database CPU load increased to 100%‚Äù or ‚Äúwhat were the IOPS of the disks and the response time during the execution of this request‚Äù.  Numbers alone, especially in the form of averages, will not allow you to conduct this kind of research. <br><br>  And finally, the ‚Äúhardcore‚Äù level: SSH in the server (or remote launch of the body) to collect more internal metrics that cannot be stored during normal operation of the service.  These are tools that are commonly called ‚Äúprofilers.‚Äù <br><br>  For Java production profiling, there are a lot of creepy things that not only give you a big overhead and delay, but they can also lie to you.  Despite the fact that the ecosystem is already about 20 years old, there are only a few reliable profiling techniques with a low overhead for JVM applications.  I can recommend <a href="https://github.com/jvm-profiling-tools/honest-profiler">Honest Profiler</a> Richard Worburton, <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a> Andrey Pangin and, of course, my pet - <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> . <br><br>  By the way, many bodies focus on CPU profiling, understanding which path of code execution causes high CPU utilization.  This is great, but often this is not the problem;  we need tools that can show the code execution paths responsible for memory allocation (async-profiler can now do this as well), missing page errors, missing cache, disk accesses, network requests, database requests and other events.  In this area, I was attracted by the problem of finding the right performance for researching the working environment. <br><br><h3>  Java profiling for Linux </h3><br><br>  <b>- I heard that under the Java / Linux stack there are a lot of problems with the accuracy of measurements.</b>  <b>Surely you can somehow fight this.</b>  <b>How do you do that?</b> <br><br>  <b>Sasha Goldstein:</b> Yes, it is sad.  Here's what the current situation looks like: you have a fast conveyor line with a huge number of different parts that you need to test to find defects and understand the speed of the application / service.  You cannot check every part absolutely, so your main strategy is to check 1 part per second and see if everything is in order, and you need to do this through the ‚Äútiny window‚Äù above this ‚Äútape‚Äù, because it is dangerous to come closer.  It seems not bad, is not it?  But then it turns out that when you try to look at it, it shows you not what is happening on the conveyor right now;  it waits until the conveyor enters a magical ‚Äúsafe‚Äù mode, and only after that gives you everything to see.  It also turns out that you will never see many parts, because the pipeline cannot enter its ‚Äúsafe‚Äù mode while they are nearby;  and it turns out that the process of finding a defect in the window takes as much as 5 seconds, so it is impossible to do this every second. <br><br>  Approximately in such condition now there is a set of profilers in the world of JVM.  YourKit, jstack, JProfiler, VisualVM - they all have the same approach to CPU profiling: they use sampling of threads in a safe state.  This means that they use the documented API to suspend all JVM threads and take their stack traces, which are then collected for a report with the hottest methods and stacks. <br><br>  The problem with such a suspension of the process is as follows: threads do not stop immediately, runtime waits until they reach a safe state, which may be after many instructions and even methods.  As a result, you get a biased picture of the application, and different profilers may still disagree with each other! <br><br>  There is a study showing how bad it is when each profiler has his own point of view about the hottest method in the same workload (Mitkovich et al., "Evaluating the Accuracy of Java Profilers").  Moreover, if you have 1000 threads in a complex call stack of Spring, often you will not be able to collect stack traces.  Perhaps no more than 10 times per second.  As a result, your stack data will differ from the actual workload even more! <br><br>  Solving such problems is not easy, but it is worth investing: it is impossible to profile some workloads on the prod using ‚Äútraditional‚Äù tools like those listed above. <br><br>  There are two separate approaches and one hybrid: <br><br><ul><li>  Richard Worburton's <a href="https://github.com/jvm-profiling-tools/honest-profiler">Honest Profiler</a> uses an internal undocumented API, AsyncGetCallTrace, which returns a single-stack stack trace, does not require a transition to a safe state, and is called using a signal handler.  It was originally designed by Oracle Developer Studio.  The basic approach is to install a signal handler and register it on a signal with a set time (for example, 100 Hz).  Then you need to take a stack-trace of any thread that is currently running inside the signal handler.  Obviously, there are difficult tasks when it comes to efficiently combining stack-traces, especially in the context of a signal handler, but this approach works great.  (This approach uses JFR, requiring a commercial license) </li><li>  <a href="https://perf.wiki.kernel.org/index.php/Main_Page">Linux perf</a> can provide rich sampling stacks (not only for CPU instructions, but also for other events, such as disk access and network requests).  The problem is that the address of the Java method is converted to a method name, which requires a JVMTI agent that extracts a text file (perf map) that perf can read and use.  There are also problems with stack reconstruction if JIT uses frame pointer suppression.  This approach may well work, but it requires a little preparation.  As a result, however, you will receive stack traces not only for JVM threads and Java methods, but also for all of your threads, including the kernel stack and C ++ stacks. </li><li>  Andrey Pangin‚Äôs <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a> combines two approaches.  It sets up a perf sample, but also uses a signal handler to call AsyncGetStackTrace and get the Java stack.  Combining the two stacks gives a complete picture of what is happening in the stream, allowing you to avoid problems with the conversion of Java method names and the suppression of frame pointers. </li></ul><br>  Any of these options are much better than safepoint-biased profilers in terms of accuracy, resource consumption and frequency of reports.  They can be complicated, but I think accurate profiling of production with a low overhead is worth the effort. <br><br><h3>  Container Profiling <br></h3><br>  <b>- Speaking of environments, it is now fashionable to pack everything in containers, are there any special features here?</b>  <b>What should be remembered when working with containerized applications?</b> <br><br>  <b>Sasha Goldstein:</b> There are interesting problems with containers that many Tula completely ignore and as a result stop working altogether. <br><br>  In brief, I remind you that Linux containers are built around two key technologies: control groups and namespaces.  Monitoring groups allow you to increase the resource quota for a process or for a group of processes: CPU time caps, memory limit, IOPS storage, and so on.  Namespaces allow container isolation: mount namespace provides each container with its own mount point (in fact, a separate file system), PID namespace ‚Äî own process identifiers, network namespace gives each container its own network interface, and so on.  Because of the namespace, it is difficult for multiple subsets to properly exchange data with containerized JVM applications (although some of these problems are not peculiar to the JVM). <br><br>  Before discussing specific issues, it will be better if we briefly describe the different types of observability of the bodies for the JVM.  If you have not heard of some of them, it's time to refresh your knowledge: <br><br><ul><li>  basic <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html">tula</a> like <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jps.html">jps</a> and <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jinfo.html">jinfo</a> provide information about existing JVM processes and their configuration; </li><li>  <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html">jstack</a> can be used to get the thread dump (stack trace) from existing JVM processes; </li><li>  <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jmap.html">jmap</a> ‚Äî to get a head dump of existing JVM processes or simpler class histograms; </li><li>  <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jcmd.html">jcmd is</a> used to replace all previous tuls and send commands to existing JVM processes through the JVM attach interface;  it is based on a UNIX domain socket, which is used by JVM processes and jcmd for data exchange; </li><li>  <a href="http://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html">jstat</a> - to monitor basic JVM performance information, such as class loading, JIT compilation, and garbage collection statistics;  based on the JVM that generates the / tmp / hsperfdata_ $ UID / $ PID files with this binary format data; </li><li>  <a href="http://openjdk.java.net/groups/hotspot/docs/Serviceability.html">The Serviceability Agent</a> provides an interface to check the memory of JVM processes, threads, stacks, and so on, and can be used with a memory dump and not just live processes;  it works by reading the process memory and internal data structure; </li><li>  <a href="http://www.oracle.com/technetwork/articles/java/javamanagement-140525.html">JMX</a> (managed beans) can be used to obtain performance information from an ongoing process, as well as to send commands to control its behavior; </li><li>  <a href="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html">JVMTI</a> agents can join various interesting JVM events, such as loading classes, compiling methods, starting / stopping threads, monitor contention, and so on. </li></ul><br>  Here are some problems that arise when profiling and monitoring containers from a host, and how to solve them (in the future I will try to tell you more about this): <br><br><ul><li>  Most tools require access to process binaries to search for objects and values.  All this is in the mount namespace of the container and is not available from the host.  Partly this access can be provided by bind-mounting from the container or to the mount namespace of the container in the profiler during symbol symbol resolving (this is what the perf and BCC tools you mentioned in the <a href="https://habrahabr.ru/company/jugru/blog/320620/">previous interview</a> are doing now). </li><li>  If you have a JVMTI agent that generates a perf map (for example, perf-map-agent), it will be written to the container / tmp storage using the container process ID (for example, /tmp/perf-1.map).  The map file must be accessible to the host, and the host must wait for the correct process ID in the file name.  (Again, perf and BCC can now do this automatically). </li><li>  The JVM attach interface (on which jcmd, jinfo, jstack and some other tools rely) requires the correct PID and mount namespace attach file, as well as the UNIX socket of the domain used to exchange data with the JVM.  This information can be thrown using the jattach utility and creating an attach file, entering the container namespace or using the bind-mounting corresponding directories on the host. </li><li>  using JVM performance data files (in / tmp / hsperfdata_ $ UID / $ PID) used by jstat requires access to mount the container namespace.  This is easily addressed by bind-mounting the / tmp container on the host; </li><li>  The simplest approach to using JMX-based tools is, perhaps, accessing the JVM as if it were remote ‚Äî by configuring the RMI endpoint, as you would for remote diagnostics; </li><li>  The Serviceability Agent requires exact version correspondence between the JVM process and the host.  I think you understand that you should not run them on a host, especially if it uses a different distribution and it has different versions of JVM installed. </li></ul><br>  Here you can think: what if I just put the performance-tool in the container so that all these problems with isolation did not arise because of me?  Although the idea is not bad, many of the bodies will not work with this configuration because of the seccomp.  Docker, for example, rejects the perf_event_open system call, which is required for profiling with perf and async-profiler;  he also rejects the ptrace system call, which is used by a large number of bodies to read the memory capacity of the JVM process.  Changing the seccomp policy to accept these system calls puts the host at risk.  Also, by placing the profiling tula in a container, you increase its attack surface. <br><br><hr><br>  We wanted to continue the conversation and discuss the effect of iron on profiling ... <br><br><div style="text-align:center;"><img width="300" src="https://habrastorage.org/webt/59/cd/05/59cd056a55cfa255608997.jpeg"></div><br><br>  Very soon, Sasha will come to St. Petersburg to conduct <a href="https://jokerconf.com/2017/trainings/68vqefxcugkwc0wsk6gic/">training on profiling JVM applications in production</a> and speak at the <a href="https://jokerconf.com/">Joker 2017</a> conference with a <a href="https://jokerconf.com/2017/talks/4xupwfvjh6w8oksi4gu0i2/">report on BPF</a> , therefore, if you want to dive deeper into the topic - you have every chance to meet with Sasha personally. </div><p>Source: <a href="https://habr.com/ru/post/338928/">https://habr.com/ru/post/338928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338918/index.html">Indeed, what is a CRM system?</a></li>
<li><a href="../338920/index.html">DevFest North in St. Petersburg on September 30</a></li>
<li><a href="../338922/index.html">Simulate Mixed Circuits on System Verilog</a></li>
<li><a href="../338924/index.html">Kotlin, puzzlers and 2 Kekses: Are you sure you know how Kotlin behaves?</a></li>
<li><a href="../338926/index.html">Computer vision. Intel Expert Answers</a></li>
<li><a href="../338930/index.html">V8 under the hood</a></li>
<li><a href="../338932/index.html">React v16.0 released</a></li>
<li><a href="../338934/index.html">Prototype cheat ASO promotion</a></li>
<li><a href="../338938/index.html">Classic 2D quest or how our two years of development went. Part 2</a></li>
<li><a href="../338940/index.html">We understand WeChat - the second most popular messenger in the world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>