<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DynLib: library for creating and working with DLL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The DynLib library provides convenient tools for developers using intermodule interaction (EXE <-> DLL, DLL <-> DLL) in their projects, and significan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DynLib: library for creating and working with DLL</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/fd3/180/4aa/fd31804aa2eb10008bf2eae925231614.png" alt="image">  The DynLib library provides convenient tools for developers using intermodule interaction (EXE &lt;-&gt; DLL, DLL &lt;-&gt; DLL) in their projects, and significantly reduces the time and amount of code. <br>  DynLib has become an integral development tool.  Under the cut share results. <a name="habracut"></a><br><br><br><br><br><h4>  Disadvantages of the traditional approach to the implementation of DLL </h4>  The main disadvantages of the traditional approach (implementation) include: <ol><li>  inability to use namespaces </li><li>  a large amount of service code required: <ul><li>  when implementing dynamic library loading; </li><li>  when implementing intermodular interaction through classes, through the use of decryptors (or other implicit structures) and wrapper classes; </li><li>  when implementing error return mechanisms, in the case when exported functions can generate exceptions. </li></ul></li></ol>  These problems are solved with the help of the library DynLib! <br><h4>  DynLib usage examples </h4><br><h4>  1. Using a regular DLL </h4><br>  <b>Task.</b>  Dynamically connect and use the library test_lib.dll, which implements simple mathematical operations, with the interface presented in the header file: <pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== test_lib.h ========== #pragma once extern "C" __declspec(dllexport) int __stdcall sum(int x, int y); extern "C" __declspec(dllexport) int __stdcall mul(int x, int y); extern "C" __declspec(dllexport) double __stdcall epsilon();</span></span></code> </pre> <br>  <b>Decision.</b>  You need to write the following header file and connect it to the project. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== test_lib.hpp ========== #pragma once #include &lt;dl/include.hpp&gt; DL_NS_BLOCK(( test ) ( DL_C_LIBRARY( lib ) ( ( int, __stdcall, (sum), (int,x)(int,y) ) ( int, __stdcall, (mul), (int,x)(int,y) ) ( double,__stdcall, (epsilon), () ) ) ))</span></span></code> </pre>  The preprocessor will generate a <i>test :: lib</i> class that performs dynamic DLL loading and contains the listed functions <i>sum</i> , <i>mul,</i> and <i>epsilon</i> .  To connect the DLL to the application, you must include the provided header file test_lib.hpp in the source code.  Next, create an object of the class <i>test :: lib</i> .  Access to the exported DLL functions is possible via '.'  or '-&gt;'. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== exe.cpp ========== #include "test_lib.hpp" int main() { test::lib lib( "path_to/test_lib.dll" ); int s = lib-&gt;sum( 5, 20 ); int m = lib.mul( 5, 10 ); double eps = lib.epsilon(); return 0; }</span></span></code> </pre><br><h4>  2. Creating calculator.dll library </h4><br>  <b>Task.</b>  Write a library calculator.dll, which should calculate the sum, the product of two numbers and the value of the square root.  Dynamically load the library and call each function. <br>  <b>Decision</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== calculator.hpp ========== #include &lt;dl\include.hpp&gt; DL_NS_BLOCK(( team ) ( DL_LIBRARY( calculator ) ( ( double, sum, (double,x)(double,y) ) ( double, mul, (double,x)(double,y) ) ( double, sqrt, (double,x) ) ) )) //========== calculator_dll.cpp ========== #include "calculator.hpp" struct calculator { static double sum( double x, double y ) { return x + y; } static double mul( double x, double y ) { return x * y; } static double sqrt( double x ) { return std::sqrt(x); } }; DL_EXPORT( team::calculator, calculator )</span></span></code> </pre><br>  Use dll <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== application.cpp ========== #include &lt;iostream&gt; #include "calculator.hpp" int main() { using namespace std; team::calculator calc( "calculator.dll" ); cout &lt;&lt; "sum = " &lt;&lt; calc.sum(10, 20) &lt;&lt; endl; cout &lt;&lt; "mul = " &lt;&lt; calc.mul(10, 20) &lt;&lt; endl; cout &lt;&lt; "sqrt = " &lt;&lt; calc.sqrt(25) &lt;&lt; endl; return 0; }</span></span></code> </pre><br><h4>  3. Modernization of the calculator.dll library.  The use of exceptions. </h4><br>  <b>Task.</b>  The <i>sqrt</i> square root calculation function in the calculator.dll library should return an error if the input value is incorrect. <br>  <b>Decision</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== calculator.hpp ========== #include &lt;dl\include.hpp&gt; DL_NS_BLOCK(( team ) ( DL_LIBRARY( calculator ) ( ( double, sqrt, (double,x) ) ) )) //========== calculator_dll.cpp ========== #include "calculator.hpp" struct calculator { static double sqrt( double x ) { if ( x &lt; 0 ) throw std::invalid_argument( "   0" ); return std::sqrt( x ); } }; DL_EXPORT( team::calculator, calculator )</span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Use dll <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== application.cpp ========== #include &lt;iostream&gt; #include &lt;locale&gt; #include "calculator.hpp" int main() { using namespace std; locale::global( locale("", locale::ctype) ); try { team::calculator calc( "calculator.dll" ); cout &lt;&lt; "sqrt1 = " &lt;&lt; calc.sqrt( 25 ) &lt;&lt; endl; cout &lt;&lt; "sqrt2 = " &lt;&lt; calc.sqrt( -1 ) &lt;&lt; endl; } catch (dl::method_error const&amp; e) { cerr &lt;&lt; "what: " &lt;&lt; e.what() &lt;&lt; endl; } return 0; } //==========   ==========</span></span></code> </pre><pre> <code class="cpp hljs">sqrt1 = <span class="hljs-number"><span class="hljs-number">5</span></span> what: exception <span class="hljs-string"><span class="hljs-string">'class std::invalid_argument'</span></span> in method <span class="hljs-string"><span class="hljs-string">'sqrt'</span></span> of class <span class="hljs-string"><span class="hljs-string">'::team::calculator'</span></span> with message <span class="hljs-string"><span class="hljs-string">'   0'</span></span></code> </pre><br><h4>  4. Implementation of the shapes.dll library.  The use of interfaces. </h4><br>  <b>Task.</b>  Create a shapes.dll library for working with geometric shapes (square, rectangle, circle).  All figures must support a common interface through which you can find out the coordinates of the center of the figure. <br>  <b>Decision</b> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== shapes.hpp ========== #include &lt;dl/include.hpp&gt; DL_NS_BLOCK(( shapes ) ( DL_INTERFACE(figure) ( ( char const*, name, ) ( double, center_x, ) ( double, center_y, ) ( void, center_xy, (double&amp;,x)(double&amp;,y) ) ) )) DL_NS_BLOCK(( shapes ) ( DL_LIBRARY(lib) ( ( shapes::figure, create_rectangle, (double,left)(double,top)(double,width)(double,height) ) ( shapes::figure, create_square, (double,left)(double,top)(double,size) ) ( shapes::figure, create_circle, (double,center_x)(double,center_y)(double,radius) ) ) )) //========== shapes_lib.cpp ========== #include "shapes.hpp" class rectangle { public: rectangle(double l, double t, double w, double h) : l_(l), t_(t), w_(w), h_(h) { if (w &lt; 0) throw std::invalid_argument( "   " ); if (h &lt; 0) throw std::invalid_argument( "   " ); } char const* name() { return "rectangle"; } double center_x() { return l_ + w_ / 2.; } double center_y() { return t_ + h_ / 2.; } void center_xy(double&amp; x, double&amp; y) { x = center_x(); y = center_y(); } private: double l_, t_, w_, h_; }; class square { public: square(double l, double t, double s) : l_(l), t_(t), s_(s) { if (s &lt; 0) throw std::invalid_argument( "    " ); } char const* name() { return "square"; } double center_x() { return l_ + s_ / 2.; } double center_y() { return t_ + s_ / 2.; } void center_xy(double&amp; x, double&amp; y) { x = center_x(); y = center_y(); } private: double l_, t_, s_; }; class circle { public: circle(double x, double y, double r) : x_(x), y_(y), r_(r) { if (r &lt; 0) throw std::invalid_argument( "   " ); } char const* name() { return "circle"; } double center_x() { return x_; } double center_y() { return y_; } void center_xy(double&amp; x, double&amp; y) { x = x_; y = y_; } private: double x_, y_, r_; }; struct shapes_lib { static shapes::figure create_rectangle( double l, double t, double w, double h ) { return dl::shared&lt;rectangle&gt;( l, t, w, h ); } static shapes::figure create_square( double l, double t, double s ) { return dl::shared&lt;square&gt;( l, t, s ); } static shapes::figure create_circle( double x, double y, double r ) { return dl::shared&lt;circle&gt;( x, y, r ); } }; DL_EXPORT( shapes::lib, shapes_lib ) //========== application.cpp ========== #include &lt;iostream&gt; #include "shapes_lib.hpp" void print_center( shapes::figure shape ) { std::cout &lt;&lt; shape.name() &lt;&lt; ": " &lt;&lt; shape.center_x() &lt;&lt; "-" &lt;&lt; shape.center_y() &lt;&lt; std::endl; } int main() { shapes::lib lib( "shapes.dll" ); print_center( lib.create_circle(10, 10, 10) ); print_center( lib.create_square(0, 0, 20) ); print_center( lib.create_rectangle(0, 5, 20, 10) ); return 0; }</span></span></code> </pre><br><h4>  How to connect the library </h4><br>  The library is supplied as header files.  No .lib and .dll is required.  To connect, you need to add the following directive: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;dl/include.hpp&gt;</span></span></span></span></code> </pre><br><h4>  Library items </h4><br>  Many classes and macros of the DynLib library can be used independently and separately from each other. <br><br><h5>  <b>DL_BLOCK</b> </h5><br>  Serves as a container for all other macros. <br><pre> <code class="cpp hljs">DL_BLOCK ( <span class="hljs-comment"><span class="hljs-comment">// declarations )</span></span></code> </pre><br><br><br><h5>  <b>DL_NS_BLOCK</b> </h5><br>  Serves as a container for all other macros.  Creates namespaces for a class. <pre> <code class="cpp hljs">DL_NS_BLOCK( (ns0, ns1, ns2 ‚Ä¶ )<span class="hljs-comment"><span class="hljs-comment">/* ,  10*/</span></span> ( <span class="hljs-comment"><span class="hljs-comment">// declarations ))</span></span></code> </pre><br>  Macros that are described below except DL_EXPORT <b>should be</b> placed in <b>DL_BLOCK</b> or <b>DL_NS_BLOCK</b> <br><br><h5>  <b>DL_C_LIBRARY</b> </h5>  The purpose of the macro is to provide the user with a ready-made class that implements dynamic DLL loading and automatic import of functions.  Macros are represented as: <br><pre> <code class="cpp hljs">DL_C_LIBRARY(lib_class) ( <span class="hljs-comment"><span class="hljs-comment">/*functions*/</span></span> ( ret_type, call, (name, import_name), arguments ) )</code> </pre><br><ul><li>  <i>lib_class</i> - the name of the class whose implementation is generated by the DynLib library; </li><li>  <i>functions</i> - enumeration of functions exported by DLL.  is set through the list of the following format <br>  (ret_type, call, (name, import_name), arguments) <ul><li>  <i>ret_type</i> - the type of the function return value; </li><li>  <i>call</i> - <i>call</i> format, for example: __sdtcall, __cdecl, etc .; </li><li>  <i>name</i> - the name of the function (for the user); </li><li>  <i>import_name</i> is the name of the function specified in the DLL export table, including the decoration (if any).  If the name and import_name match, then import_name can be omitted. </li><li>  <i>arguments</i> is a list (argument type, argument name, = default value) specifying input arguments.  The argument name and the default value can be omitted .; </li></ul>  Example: <br><pre> <code class="cpp hljs">DL_BLOCK ( DL_C_LIBRARY( my_lib ) ( ( <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, __stdcall, (func), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,s)(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>,V,=<span class="hljs-number"><span class="hljs-number">1.0</span></span>) ) ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, __stdcall, (fn, <span class="hljs-string"><span class="hljs-string">"fn@0"</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,a) ) ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, __stdcall, (fn), () ) ) )</code> </pre></li></ul>  <i>Classes generated by the DL_C_LIBRARY macro cannot be passed across DLL boundaries</i> <br><h5>  <b>DL_RECORD</b> </h5><br>  The macro <i>DL_RECORD</i> generates a packed data structure for use in intermodule communication.  In addition, a constructor is created with all the arguments listed in the macro. <br><pre> <code class="cpp hljs">DL_RECORD( record_name ) ( <span class="hljs-comment"><span class="hljs-comment">/*fields*/</span></span> (type, name, =default_value) )</code> </pre><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== some_exe.cpp ========== #include &lt;dl/include.hpp&gt; DL_BLOCK ( DL_RECORD( data ) ( ( int, x ) ( int, y, = 100 /*  */ ) ( int, z, = 200 /*  */ ) ) ) int main() { data v( 20 ); // x = 20, y = 100, z = 200 vx = 10; vy = vx; vz = 50; v = data( 5, 20, 30 ); data a( 1, 2, 3 ); return 0; }</span></span></code> </pre><br><br><h5>  <b>DL_LIBRARY</b> </h5><br>  The macro <i>DL_LIBRARY</i> performs several tasks: <ol><li>  acts as a description (documentation) of the interface between the EXE (DLL) and DLL; </li><li>  contains the necessary structures for the automatic export of library functions to the developer; </li><li>  implements a class that provides loading of a DLL with a specified interface and provides access to exported functions by the user; </li><li>  Provides correct use of C ++ exceptions: <pre>  - automatic interception of C ++ exceptions on the DLL side;
	   - returning the value across the DLL boundaries, signaling the presence of an exception;
	   - the generation of a new exception in case the exception on the DLL side was intercepted (with the recovery of the description and information about the type of exception).
	</pre></li></ol><pre> <code class="cpp hljs">DL_LIBRARY( name ) ( <span class="hljs-comment"><span class="hljs-comment">/*functions*/</span></span> ( ret_type, name, arguments ) )</code> </pre><br>  <i>Classes generated by the DL_LIBRARY macro cannot be passed across DLL boundaries.</i> <br>  To demonstrate the operation of the macro, we will present the following header file: <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== test1_lib.hpp ========== #pragma once #include &lt;dl/include.hpp&gt; DL_NS_BLOCK(( team, test ) ( DL_LIBRARY( lib ) ( ( int, sum, (int,x)(int,y) ) ( void, mul, (int,x)(int,y)(int&amp;,result) ) ( double, epsilon, () ) ) ))</span></span></code> </pre><br>  This description is used by the DLL developer to export functions via the <i>DL_EXPORT</i> macro.  By connecting the test1_lib.hpp header file, a user can immediately start working with a DLL: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== test1_exe.cpp ========== #include &lt;test1_lib.hpp&gt; int main() { team::test::lib lib( "test1.dll" ); int s = lib.sum( 5, 10 ); lib.mul( 5, 5, s ); double eps = lib-&gt;epsilon(); return 0; }</span></span></code> </pre><br><h5>  <b>DL_EXPORT</b> </h5><br>  The macro <i>DL_EXPORT is</i> intended for exporting DLL functions. <br>  <i>DL_EXPORT</i> ( <i>lib_class</i> , <i>lib_impl_class</i> ) <ul><li>  <i>lib_class</i> is the full name of the class describing the interaction interface (that is the name of the class used in DL_LIBRARY); </li><li>  <i>lib_impl_class</i> - the full name of the class of the class that implements the functions specified in the interaction interface. </li></ul>  To export DLL functions you need: <ol><li>  Create a class (structure); </li><li>  Define each function from the interface as static.  Functions must be in the <i>public</i> scope <i>:;</i> </li><li>  Export the functions by writing the DL_EXPORT (lib, impl) construct. </li></ol>  For example, we will present the implementation of the DLL for the interaction interface in the <i>test1_lib.hpp</i> file defined in the DL_LIBRARY description. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========== test1_dll.cpp ========== #include "test1_lib.hpp" struct lib_impl { static int sum( int x, int y ) { return x + y; } static void mul( int x, int y, int&amp; result ) { result = x + y; } static double epsilon() { return 2.0e-8; } }; DL_EXPORT( team::test::lib, lib_impl )</span></span></code> </pre><br><h5>  <b>DL_INTERFACE</b> </h5><br>  The macro allows to describe the class interface and provide the user with a wrapper class for working with it.  The implementation of the wrapper class ensures the correct use of C ++ exceptions: <pre>  - automatic interception of C ++ exceptions on the DLL side;
	  - returning the value across the DLL boundaries, signaling the presence of an exception;
	  - the generation of a new exception in case the exception on the DLL side was intercepted (with the recovery of the description and information about the type of exception).
	</pre>  The wrapper class generated by this macro has a shared ownership of the object that implements this interface.  Shared ownership is provided by a reference counting mechanism, i.e.  when a wrapper class object is copied, an internal function is called to increase the reference count, and when destroyed, an internal function to reduce the reference count.  When the counter reaches 0, the object is automatically deleted.  Access to interface methods is done via '.'  or '-&gt;'. <br>  <i>DynLib library ensures safe use of interface classes at the border of an EXE (DLL) &lt;-&gt; DLL</i> <br><br><pre> <code class="cpp hljs">DL_INTERFACE( interface_class ) ( <span class="hljs-comment"><span class="hljs-comment">/*methods*/</span></span> ( ret_type, name, arguments ) )</code> </pre><ul><li>  <i>interface_class</i> - the name of the class whose implementation is generated by the DynLib library; </li><li>  <i>methods</i> - an enumeration of functions describing the class interface, </li></ul>  Example: <br><pre> <code class="cpp hljs">DL_NS_BLOCK(( example ) ( DL_INTERFACE( processor ) ( ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, threads_count, () ) ( <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>, process, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*,buf)(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>,size) ) ) ))</code> </pre><br>  Using: <br><pre> <code class="cpp hljs"> example::processor p; p =‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// .  dl::shared  dl::ref int tcount = p-&gt;threads_count(); p.process(some_buf, some_buf_size);</span></span></code> </pre><br><h5>  <b>dl :: shared</b> </h5><br>  The template class dl :: shared &lt;T&gt; solves the following tasks: <ol><li>  dynamic creation of an object of class T with arguments passed to the constructor; </li><li>  adding a reference count and securing shared ownership (like boost (std) :: shared_ptr); </li><li>  implicit coercion to the class object generated by the <i>DL_INTERFACE</i> macro. </li></ol>  Access to member functions of class T is done via '-&gt;'. <br>  <i>The dl :: shared classes cannot be passed across DLL boundaries</i> . <br>  Suppose there is a class <i>my_processor</i> and the interface <i>example :: processor</i> : <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_processor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: my_processor( <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* name = <span class="hljs-string"><span class="hljs-string">"default name"</span></span> ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">threads_count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   }; DL_NS_BLOCK(( example ) ( DL_INTERFACE( processor ) ( ( int, threads_count, () ) ( void, process, (char const*,buf)(std::size_t,size) ) ) ))</span></span></code> </pre><br>  Examples of using <i>dl :: shared are</i> presented below: <br><pre> <code class="cpp hljs">dl::shared&lt;my_processor&gt; p1( <span class="hljs-string"><span class="hljs-string">"some processor name"</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//   my_processor   dl::shared&lt;my_processor&gt; p2; //   my_processor   c    dl::shared&lt;my_processor&gt; p3( p1 ); // p3  p1       ,   = 2 dl::shared&lt;my_processor&gt; p4( dl::null_ptr ); // p4      p3.swap( p4 ); // p4    ,   p1, p3 ‚Äî      p4 = dl::null_ptr; // p4      p2 = p1; // p2    p1 p2 = p1.clone(); //    my_processor //   my_processor      p2-&gt;threads_count(); p2-&gt;process( /*args*/ ); //   my_processor example::processor pi = p2; //   my_processor   example::processor // pi     ,      ,   . pi-&gt;threads_count(); pi-&gt;process(/*args*/); //   my_processor   pi.</span></span></code> </pre><br><h5>  <b>dl :: ref</b> </h5><br>  A library function that allows you to cast any object to an interface class object declared via <i>DL_INTERFACE</i> with an identical set of methods.  Typically, this behavior is necessary when there is a function that takes a class-interface as an argument, and it should pass an object placed on the stack. <br>  It is necessary to use the <i>dl :: ref</i> function with caution, since the objects of the interface classes, in this case, will not own the transferred objects, and the user controls the lifetime of the object and its use through the interface classes.  Copying objects of interface classes that refer to objects passed through <i>dl :: ref</i> is allowed and quite correct (since there is no reference counter, then there is nothing to change ‚Äî objects of interface classes know how to work correctly here). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_processor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: my_processor( <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* name = <span class="hljs-string"><span class="hljs-string">"default name"</span></span> ); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">threads_count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   }; DL_NS_BLOCK(( example ) ( DL_INTERFACE( processor ) ( ( int, threads_count, () ) ( void, process, (char const*,buf)(std::size_t,size) ) ) )) void some_dll_func( example::processor p ) { //  p } int main() { my_processor processor( "abc" ); some_dll_func( dl::ref(processor) ); //       ,   dl::object&lt;my_processor&gt; return 0; }</span></span></code> </pre><br><h4>  Supported Compilers </h4><br>  <b>DynLib is</b> fully compatible with the following compilers (development environments): <ul><li>  Microsoft Visual C ++ 2008; </li><li>  Microsoft Visual C ++ 2010; </li><li>  MinGW GCC 4.5.0 and higher. </li></ul>  Partially compatible with the following compilers (development environments): <ul><li>  CodeGear C ++ Builder XE (operation is not guaranteed with certain compiler settings) </li></ul>  <a href="">You can get the library here.</a> </div><p>Source: <a href="https://habr.com/ru/post/137969/">https://habr.com/ru/post/137969/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137962/index.html">How to buy low customer loyalty?</a></li>
<li><a href="../137963/index.html">We communicate with the SIM card at a low level</a></li>
<li><a href="../137964/index.html">Free xml-source of cash exchange rates, as well as 3 convenient updates from the portal FINANCE.UA</a></li>
<li><a href="../137966/index.html">Filtering Input Characters in Ext.form.field.Number</a></li>
<li><a href="../137968/index.html">Joint promotion of Vodafone AU and Dropbox. + 2GB for your account</a></li>
<li><a href="../137970/index.html">Apple is worth more than Google and Microsoft together</a></li>
<li><a href="../137972/index.html">Personal goals: version control and beautiful one-click printing</a></li>
<li><a href="../137973/index.html">How do robots see the world?</a></li>
<li><a href="../137974/index.html">Budget Serial to Ethernet adapter in one evening</a></li>
<li><a href="../137976/index.html">Universal detector for determining software development conditions for customers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>