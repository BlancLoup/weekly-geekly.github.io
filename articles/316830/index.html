<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ISUII AmigaVirtual - universal AI for everyone</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all lovers and researchers of artificial intelligence! In this article, I would like to tell about an interesting project: the modular system...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ISUII AmigaVirtual - universal AI for everyone</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/6b8/18f/335/6b818f335ba64ae49c378b707b118cbe.png" alt="Logo" align="left" width="300">  Hello to all lovers and researchers of artificial intelligence!  In this article, I would like to tell about an interesting project: the modular system of universal artificial intelligence (ISUAI) "Amiga Virtual" (AV, "Virtual Girlfriend").  I will talk about the basic principles of its work and describe some details of the implementation, and the most curious will be able to explore all the source codes.  Development is conducted on Delphi, but the modules can theoretically be written in any PL.  This system will be of interest both to end users of chat bots and related systems, and to developers of AI - after all, almost any type of AI can be developed on its basis. <br><a name="habracut"></a><br>  First, a little history.  The project was launched in 2012, when I decided to start developing a chat bot.  And so I decided after becoming acquainted with ‚ÄúSayme 2‚Äù - a simple flash game about communicating with a virtual girl (unfortunately, the ambitious continuation of this game - version 3 - apparently died in the bud. RIP, ‚ÄúSayme 3‚Äù).  Then AV was a monolith, with images in a single DLL with parts of an avatar - in order not to download extra megabytes if the avatar is not needed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/37c/0c3/de0/37c0c3de049d49bcb5556fe077da5fb8.png" alt="screenshot 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/42b/f70/47d/42bf7047da014b699b76c70729d30fe8.png" alt="screenshot 2"></div><br>  <i>It looked like the first version of Amiga Virtual.</i> <br><br>  Since then, the concept has changed - now the AV itself - only the platform for organizing the work of the modules.  All ‚Äúorgans‚Äù of AI are in modules. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A few words about the programming language.  In 2012 I chose Delphi, because I didn‚Äôt know almost anything except him (not counting Turbo Pascal).  Later I tried many languages ‚Äã‚Äã... Most of all I liked Ada, but there are few educational materials, and the programs are slow.  I also tried Oxygen (Delphi Prism), but there are even less materials on it.  C ++ and other C-like languages ‚Äã‚ÄãI don‚Äôt like at all.  Therefore, in the end, I returned to Delphi, which I know well and for which there is just a lot of educational material on the Internet, and there are also a lot of ready-made solutions. <br><br>  Now about the project itself.  Amiga Virtual is a multipurpose multi-agent system.  In general terms, it is structured as follows: there is a main program (OP) and a set of modules (represented as DLLs and are software agents) that have certain interfaces from a certain list;  during the start, the OP loads and identifies (determines what the module can do; the purpose of the module is not reported to the program ‚Äî it does not make sense) all modules, then the user selects the modules with which he wants to work and starts multi-threaded processing of the input-output interfaces of the selected modules .  This is how modules are loaded and identified: <br><br><pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadModules</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(Module) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Module[i].Handle &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FreeModule(Module[i]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> LoadModule(Module[i]) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> DetermineModuleType(Module[i]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> M: TModule)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> B: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>; C: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> M <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Handle := LoadLibrary(PWideChar(FileName)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Handle &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> @SetLanguage := GetProcAddress(Handle, <span class="hljs-string"><span class="hljs-string">'SetLanguage'</span></span>); IncAndUpdateProgress; <span class="hljs-comment"><span class="hljs-comment">//  - @SendLanguageData := GetProcAddress(Handle, 'SendLanguageData'); IncAndUpdateProgress; @GetName := GetProcAddress(Handle, 'GetName'); IncAndUpdateProgress; //   ,   //      if @GetName &lt;&gt; nil then begin B := GetName; C := Pos(ControlCodeMarker, B); if C &gt; 0 then begin Name := Copy(B, C + 1, Length(B)); ControlCode := Copy(B, 1, C - 1); ControlCodeFormated := FormatControlCode(ControlCode); end else begin Name := B; ControlCode := MainForm.LanguageData[133]; end; end else begin Name := MainForm.LanguageData[114]; ControlCode := MainForm.LanguageData[133]; end; if (@OpenWindow &lt;&gt; nil) and (@CloseWindow &lt;&gt; nil) then WindowState := closed else WindowState := window_does_not_exist; if (@Sleep &lt;&gt; nil) and (@WakeUp &lt;&gt; nil) then ModuleState := working else ModuleState := module_cant_sleep; LoadStatistics; //     Result := true; end else Result := false; end; end; function DetermineModuleType(var M: TModule): TModuleType; begin with M do begin MType := undetermined; if (@SetLanguage = nil) and ... (*     nil *) then MType := erroneous_or_empty else begin if (@SetSource &lt;&gt; nil) or (@NextData &lt;&gt; nil) or (@Progress &lt;&gt; nil) or (@RestartParsing &lt;&gt; nil) then MType := parser else begin if (@GetData &lt;&gt; nil) and (@SendData &lt;&gt; nil) then MType := input_and_output else if (@GetData &lt;&gt; nil) and (@SendData = nil) then MType := only_input else if (@GetData = nil) and (@SendData &lt;&gt; nil) then MType := only_output else if (@GetData = nil) and (@SendData = nil) then MType := no_input_and_no_output; end; end; Result := MType; end; end;</span></span></code> </pre> <br>  OP implements only a text-based user interaction interface with modules, or, more simply, a chat window.  All modules communicate through this chat, but usually the technical messages of the modules are not shown to the user, since  They are of no interest to him (for debugging purposes, these messages can be displayed).  Technical messages are marked with several non-printable characters at the beginning of a line.  This code (‚Äúcontrol code‚Äù) is defined by the developer of the module.  Loading two modules with one control-code can lead to system looping - these two modules will endlessly exchange messages, like two mirrors set against each other.  In short, the control code is needed so that the modules ignore messages that are not addressed to them.  However, some modules can handle all messages - for example, modules of the intellect-core type. <br><br>  Each module that has input, output, or input / output interfaces is processed in a separate OP thread.  This allows you to maintain the performance of the OP, if a module hangs or just "thinks".  The remaining modules are used by the user in manual mode through their own windows.  The following class implements an I / O stream: <br><br><pre> <code class="delphi hljs"> <span class="hljs-title"><span class="hljs-title">TIOThread</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TThread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SleepTime = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Module: TModule; SelfID: Integer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(M: TModule; ID: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  This is how I / O processing happens: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIOThread</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetData</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> M: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> M := <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>(Module.GetData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> M &lt;&gt; SCM_No_Message <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Synchronize( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pool</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(M, SelfID)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendData</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Pool <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Empty <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(Records) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Records[i] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ModuleGot[SelfID] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (AuthorID &lt;&gt; SelfID) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Module.SendData(PChar(Text)); ModuleGot[SelfID] := true; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Synchronize( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckAndDeleteOddRecords</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Terminated <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Module.MType <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> only_input: GetData; only_output: SendData; input_and_output: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SendData; GetData; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Sleep(SleepTime); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  For messaging, the OP implements a message pool.  It saves all messages that come from the chat window and from modules, and are stored until all modules receive these messages, then they are deleted.  The following class implements a message pool: <br><br><pre> <code class="delphi hljs"> TPoolRecord = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Text: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>; AuthorID: Integer; ModuleGot: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TPool = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Records: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TPoolRecord; Empty: Boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecordText: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">; RecordAuthor: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckAndDeleteOddRecords</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPool</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RecordText: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">; RecordAuthor: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, RL: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> RL := Length(Records); SetLength(Records, RL + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Records[RL] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Text := RecordText; AuthorID := RecordAuthor; SetLength(ModuleGot, OutputModulesCount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> OutputModulesCount - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i = AuthorID <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ModuleGot[i] := true <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ModuleGot[i] := false; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> MainForm, MainForm.ChatBox.Lines <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RecordAuthor <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>: Add(User.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">': '</span></span> + RecordText); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> RecordText = SCM_Dont_Know_Answer <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> DontKnowCheckBtn.Checked <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Add(LanguageData[<span class="hljs-number"><span class="hljs-number">156</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Add(AVirtual.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">': '</span></span> + RecordText); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; Empty := false; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPool</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckAndDeleteOddRecords</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ItsOdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID: Integer)</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ItsOdd := true; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> Records[ID] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(ModuleGot) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ModuleGot[i] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ItsOdd := false; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeleteRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID: Integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := ID <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(Records) - <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> Records[i] := Records[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; SetLength(Records, Length(Records) - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Empty <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := Length(Records) - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">downto</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ItsOdd(i) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> DeleteRecord(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Length(Records) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Empty := true; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> MainForm.PoolShowBtn.Checked <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Show; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Now let's talk about the possible classes of modules and their capabilities. <br><br>  The most important, key class of modules for the sake of which the Girlfriend was conceived and implemented is the ‚Äúintellect-cores‚Äù (FL, or just the cores).  The kernel processes all messages arriving in the chat, in accordance with the algorithm embedded in it.  That is, he performs the main intellectual work.  The specific algorithm and its implementation depends on the kernel developer.  How to make a good kernel is an interesting question, and I will consider it in another article on the example of my series of kernels.  Another interesting question is how to split the kernel into separate modules.  I can't subdivide the kernels I'm working on.  But, in principle, nothing prevents you from making a composite core. <br><br>  All other modules are divided into several categories: receptors (generate chat messages ‚Äî module of vision, module of hearing, etc.), effectors (perform actions in response to messages from the chat), tools (not directly related to AI, are used by the user manually) ), parsers (used by the Dream Fusion training module), and other modules that can be used by some special modules. <br><br>  Some receptors and effectors respectively encode and decode messages recorded in the "control code + command" style.  Such messages are usually not displayed to the user.  The essence of these messages is as follows: the receptor recognizes some action performed by the user, encodes the message and sends it to the core for storage.  When the kernel issues this message, the corresponding effector decodes the message, receiving a command corresponding to the user's action, and performs this action.  Since the core does not make any difference what messages to memorize and issue, and we can connect any receptors and effectors to the system ‚Äî the intelligence is universal, that is, it can be taught anything.  Great, right? <br><br>  It should be replaced, for convenience, related receptors and effectors can be implemented in a single module.  An example is a class of modules under the general name ‚Äúemotional avatar‚Äù (I call this ‚Äúemotar‚Äù): a user assembles a face from a part expressing a certain emotion, and the module creates a message encoding the selected emotion, i.e.  acts as a receptor;  when the kernel sends this message to the chat, the emotar decodes it and builds a face image with the corresponding emotion, i.e.  acts as an effector.  I do not see the point of separating the emotar into two separate modules <br><br>  Here is an example of a template for creating a module in Delphi: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">library</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">uses</span></span> System.SysUtils, System.Classes, SystemControlMessagesUnit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'..\..\AmigaVirtual\SystemControlMessagesUnit.pas'</span></span>, MainFormUnit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'MainFormUnit.pas'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ControlCode = ++; <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> = ControlCode + <span class="hljs-string"><span class="hljs-string">'&gt; '</span></span>; Help = <span class="hljs-string"><span class="hljs-string">''</span></span> + <span class="hljs-string"><span class="hljs-string">#13</span></span> + <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> FormState: (closed, opened); Buffer, VirtualName: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>; NewMessageGot: Boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetName</span></span></span><span class="hljs-function">:</span></span> PChar; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := PChar(<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHelp</span></span></span><span class="hljs-function">:</span></span> PChar; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := PChar(Help); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenWindow</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> MainForm = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> MainForm := TMainForm.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); MainForm.Show; FormState := opened; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CloseWindow</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FormState = opened <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> MainForm.Close; FormState := closed; MainForm.Release; MainForm := <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data: PChar)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Buffer := Data; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetData</span></span></span><span class="hljs-function">:</span></span> PChar; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NewMessageGot <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := PChar(Buffer); NewMessageGot := false; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Result := PChar(SCM_No_Message); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> NewMessageGot := false; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> MainForm = <span class="hljs-keyword"><span class="hljs-keyword">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> MainForm := TMainForm.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetVirtual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Name</span></span></span></span><span class="hljs-function"><span class="hljs-params">: PChar)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VirtualName := <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadData</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//    end; procedure SaveData; stdcall; begin //    end; exports GetName, GetHelp, OpenWindow, CloseWindow, SendData, GetData, Start, SetVirtual, LoadData, SaveData; begin end.</span></span></code> </pre> <br>  At the moment there are 21 interfaces: <br><br><pre> <code class="delphi hljs"> SetLanguage: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Language: PChar)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; SendLanguageData: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">array</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">of</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PChar)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; GetName: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">:</span></span> PChar; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; GetHelp: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">:</span></span> PChar; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; Start: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; Sleep: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; WakeUp: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; OpenWindow: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; CloseWindow: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; SetVirtual: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Name</span></span></span></span><span class="hljs-function"><span class="hljs-params">: PChar)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; SaveData: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; LoadData: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; Reset: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; SetNewMainWindow: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Position, Size: TPoint)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; GetTimerInterval: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">:</span></span> Integer; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; SendData: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data: PChar)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; GetData: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">:</span></span> PChar; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; SetSource: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SourcePath: PChar)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; NextData: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">:</span></span> PChar; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; Progress: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">:</span></span> Real; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; RestartParsing: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>;</code> </pre> <br>  The module can implement any set of the above interfaces. <br><br>  Is a typical module an intelligent agent?  Depends on the implementation.  I see two options for implementation.  Consider them on the example of the module of view.  The first option is a simple software agent: it encodes pictures as is, that is, converts bitmaps into a text string.  The second option is a complex intelligent agent: for example, an artificial neural network that recognizes objects in pictures and describes them with words in a message.  If several modules of the second type are used, then it can be said that the universal AI is built from a set of weak AI.  Strong is intelligence or not - depends on the implementation of the kernel. <br><br>  And now about the details of the main program.  There are three of them: the organization of AI databases by name, the registration of users with the collection of statistics, and the ‚ÄúExchange Center‚Äù for sharing content. <br><br>  Know the chatbots platform iii?  In fact, Amiga Virtual is much more advanced version iii.  Only I call AI instances (named databases) not "Infi", but "Virtuals".  Each Virtual is trained by the user from scratch and can be easily transferred to another computer.  And with the help of avatar-modules (or emoters) a unique visual image of Virtual can be created.  Tab Virtual Manager looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/586/f3b/40b/586f3b40b02841d58f37fb0845289154.png" alt="screenshot"></div><br>  The selection of the used modules is made with checking for collisions by the control code: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> CResult = (no_collision, collision); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckModulesCollision</span></span></span><span class="hljs-function">:</span></span> CResult; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j: Integer; CC: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := no_collision; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ModulesList <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Items.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Checked[i] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CC := FindModuleByFileName(ExtractDLLName(Items[i])).ControlCode; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Items.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Checked[j] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (i &lt;&gt; j) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (CC = FindModuleByFileName(ExtractDLLName(Items[j])).ControlCode) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := collision; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  <s>In order to know how AV is used by most users and in which direction to develop the project, I collect anonymous statistics.</s> <br>  <i>While the collection of statistics is not implemented.</i> <br><br>  The Exchange Center (CO) is a service accessible from the main program, intended for the exchange of modules, Virtuals and other content between users: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b3e/c90/e42/b3ec90e42df34a7cb027c5a260b8663e.png" alt="screenshot"></div><br>  This is how content download is implemented: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMainForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DownloadFilesButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Dir, FileName: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetCurrentDir(ProgramPath); Dir := Category[ContentCategoryBox.ItemIndex]; Dir := UpCase(Dir[<span class="hljs-number"><span class="hljs-number">1</span></span>]) + Copy(Dir, <span class="hljs-number"><span class="hljs-number">2</span></span>, Length(Dir)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> DirectoryExists(Dir) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CreateDir(Dir); SetCurrentDir(Dir); FileName := ContentList.Items[ContentList.ItemIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FileExists(FileName) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> MessageDlg(LanguageData[<span class="hljs-number"><span class="hljs-number">172</span></span>], mtInformation, [mbOk], <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> DownloadFile(SiteProtocol + OfficialWebsite + ExchangeCenterPage + <span class="hljs-string"><span class="hljs-string">'?c='</span></span> + Category[ContentCategoryBox.ItemIndex] + <span class="hljs-string"><span class="hljs-string">'&amp;f='</span></span> + FileName + <span class="hljs-string"><span class="hljs-string">'&amp;l='</span></span> + LanguageData[<span class="hljs-number"><span class="hljs-number">0</span></span>], FileName); <span class="hljs-comment"><span class="hljs-comment">//  LanguageData[0]     if Copy(FileName, Length(FileName) - 2, 3) = 'zip' then UnzipFiles(FileName, GetCurrentDir); case ContentCategoryBox.ItemIndex of 0: UpdateModulesList; 1: UpdateVirtualsList; end; SetStatusMessage(LanguageData[173] + ' ' + ProgramPath + Dir + '\'); end; end; procedure TMainForm.DownloadFile(From, SaveTo: String); var LoadStream: TMemoryStream; begin Downloading := true; LoadStream := TMemoryStream.Create; IdHTTP.Get(TIdURI.URLEncode(From), LoadStream); LoadStream.SaveToFile(SaveTo); LoadStream.Free; Downloading := false; SplashScreen.Close; end;</span></span></code> </pre> <br>  The system of accounts is implemented for downloading content in the CO (it does not work yet): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0a3/bc5/084/0a3bc508443d46e7a7a052a57c5c17af.png" alt="screenshot"></div><br>  I plan to connect it with the accounts system of the official forum, but I don‚Äôt know how yet. <br><br>  Basic access (download only) is provided in the guest account, and to upload your content you need to register (until the content download algorithm is implemented, I upload manually by FTP). <br><br>  In addition to the CO, there is also a forum that provides technical support for users - it opens in the embedded browser (standard for Delphi - the Trident core seems to be used, but I don‚Äôt need much, just draw a simple page; the forum itself on phpBB): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ab2/148/f55/ab2148f551824fcc9fec88c813fd509e.png" alt="screenshot"></div><br>  As you can see from the screenshot, you can enter your address and add the page to the bookmarks (the bookmarks have not yet been implemented) - in order not to lose the discussion on the forum. <br><br>  One more thing.  Noticed in the code above LanguageData?  This is an array that stores text strings for GUI components that match the selected language.  Russian and English are packaged in .exe as resources, and at start they are unpacked into the Languages ‚Äã‚Äãfolder.  Files with other languages ‚Äã‚Äãcan be downloaded via the Sharing Center.  Since  Delphi supports Unicode, the language can be set to any one - Japanese or Arabic, for example. <br><br>  This is how language files are unloaded from .exe: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMainForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeployDefaultLanguages</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeployLanguage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LanguageName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ResHandle, MemHandle: THandle; MemStream: TMemoryStream; ResPtr: PByte; ResSize: Longint; ResName: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>; i: Integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ResName := <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Length(LanguageName) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ResName := ResName + UpCase(LanguageName[i]); ResName := ResName + <span class="hljs-string"><span class="hljs-string">'_LP'</span></span>; ResHandle := FindResource(HInstance, PWideChar(ResName), RT_RCDATA); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ResHandle = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(<span class="hljs-string"><span class="hljs-string">'Default language "'</span></span> + LanguageName + <span class="hljs-string"><span class="hljs-string">'" not found. ('</span></span> + ResName + <span class="hljs-string"><span class="hljs-string">')'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; MemHandle := LoadResource(HInstance, ResHandle); ResPtr := LockResource(MemHandle); MemStream := TMemoryStream.Create; ResSize := SizeOfResource(HInstance, ResHandle); MemStream.SetSize(ResSize); MemStream.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(ResPtr^, ResSize); MemStream.Seek(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); MemStream.SaveToFile(LangFilesDir + <span class="hljs-string"><span class="hljs-string">'/'</span></span> + LanguageName + LanguageFileExtension); FreeResource(MemHandle); MemStream.Destroy; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> DirectoryExists(LangFilesDir) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> CreateDir(LangFilesDir); DeployLanguage(<span class="hljs-string"><span class="hljs-string">'Russian'</span></span>); DeployLanguage(<span class="hljs-string"><span class="hljs-string">'English'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  As you can see, to embed a new pre-installed language, just paste the language file into the resource file, add a line of the DeployLanguage view ('NameLanguage') and recompile the project ‚Äî conveniently. <br><br>  This is how the language is loaded: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMainForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeLanguageTo</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LanguageDataLoaded</span></span></span><span class="hljs-function">:</span></span> Boolean; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> T: TextFile; B: RawByteString; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetCurrentDir(ProgramPath + LangFilesDir); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FileExists(Language + LanguageFileExtension) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> AssignFile(T, Language + LanguageFileExtension); Reset(T); SetLength(LanguageData, <span class="hljs-number"><span class="hljs-number">1</span></span>); LanguageData[<span class="hljs-number"><span class="hljs-number">0</span></span>] := Language; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> eof(T) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> SetLength(LanguageData, Length(LanguageData) + <span class="hljs-number"><span class="hljs-number">1</span></span>); ReadLn(T, B); LanguageData[Length(LanguageData) - <span class="hljs-number"><span class="hljs-number">1</span></span>] := UTF8ToWideString(B); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; CloseFile(T); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Length(LanguageData) - <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;= LangFileMinSize <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> Result := true <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Result := false; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Result := false; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCaptions</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> HelpForm <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> LoadHelpTexts; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> CurrentTopic &lt; HelpLast <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> OpenTopic(CurrentTopic) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> OpenTopic(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; AddModulesHelpToMainProgramHelp; ChangeModulesLanguageToProgramLanguage; AuthorizationTab.Caption := LanguageData[<span class="hljs-number"><span class="hljs-number">18</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// - ... CloudSaveNow.Caption := LanguageData[181]; CloudLoadNow.Caption := LanguageData[182]; end; procedure CheckMenuItem; var Item: TMenuItem; begin for Item in LanguageMenu.Items do if Item.Name = LanguageData[0] + 'Lang' then Item.Checked := true; end; begin if LanguageDataLoaded then begin if not Silent then SetStatusMessage(LanguageData[2] + ' ' + LanguageData[0]) else FormCaption.Caption := LanguageData[1]; SetCaptions; end else begin if Language &lt;&gt; SavedLanguage then ChangeLanguageTo(SavedLanguage) else ChangeLanguageTo(DefaultLanguage); MessageDlg(LanguageData[3] + #13 + LanguageData[2] + ' ' + LanguageData[0] + '.', mtError, [mbOk], 0); end; CheckMenuItem; end;</span></span></code> </pre> <br>  And there is also a window with a help: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4ce/16c/ff4/4ce16cff44b7422e8a115193eeee9899.png" alt="screenshot"></div><br>  In it, through the main menu, you can display information about the module: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9f8/1d7/5ad/9f81d75ad8c148d6981f315b542c8f54.png" alt="screenshot"></div><br>  Another interesting trick is the self-updating of the program, done using the .bat script: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TMainForm</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateProgram</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeployBAT</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bat: TextFile; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> FileExists(ProgramPath + <span class="hljs-string"><span class="hljs-string">'update.bat'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> AssignFile(bat, ProgramPath + <span class="hljs-string"><span class="hljs-string">'update.bat'</span></span>); Rewrite(bat); WriteLn(bat, <span class="hljs-string"><span class="hljs-string">'taskkill /im av.exe'</span></span>); WriteLn(bat, <span class="hljs-string"><span class="hljs-string">'sleep 1'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Windows XP WriteLn(bat, 'timeout /t 1 /nobreak'); // Windows 7+ WriteLn(bat, 'del av.exe'); WriteLn(bat, 'move ' + ZipsDir + '\av.exe %1'); WriteLn(bat, 'del /S /Q ' + ZipsDir); WriteLn(bat, 'start av.exe'); // WriteLn(bat, 'pause'); CloseFile(bat); end; end; begin DownloadFile(SiteProtocol + OfficialWebsite + '/av.zip', ProgramPath + 'av.zip'); UnzipFiles(ProgramPath + 'av.zip', ProgramPath + ZipsDir); DeployBAT; SetCurrentDir(ProgramPath); ShellExecute(Handle, nil, 'update.bat', PChar(ProgramPath), nil, SW_SHOW); end;</span></span></code> </pre> <br>  Finally, I want to note that the Amiga Virtual project includes not only a Windows program.  In addition to it, system options are planned for Android (AV Mobile), robotic platforms (AV OS) and supercomputers (AV Super).  And algorithms of intellect-cores can be used to create an intelligent search engine (reorganizing Yandex and Google search results).  When the alpha version is ready in one of these areas, I will write an article describing her work. <br><br>  Project source codes and design document can be downloaded here: <a href="https://github.com/TimKruz/AV">github.com/TimKruz/AV</a> <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/316830/">https://habr.com/ru/post/316830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316820/index.html">A small survey of hosting (~ 100) on the service VDS</a></li>
<li><a href="../316822/index.html">Automated recovery of MS SQL databases from backups</a></li>
<li><a href="../316824/index.html">The recipe for developing a bot under Telegram</a></li>
<li><a href="../316826/index.html">Jupyter Notebook features that you may not have heard of</a></li>
<li><a href="../316828/index.html">Building compact collimators for high power LEDs</a></li>
<li><a href="../316832/index.html">Demo cloud access to Ultimate 2C</a></li>
<li><a href="../316834/index.html">Tips for Indie Developers: The Dark Triad and Five Tips with Top ROI</a></li>
<li><a href="../316836/index.html">How not to use the Repository pattern</a></li>
<li><a href="../316838/index.html">Bot for telegram with status in DBMS and text classification</a></li>
<li><a href="../316840/index.html">How to gently get into the guts of WebRTC when transmitting voice and video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>