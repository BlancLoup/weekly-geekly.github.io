<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a clone game Super Mario Brothers (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For many of us, Super Mario Brothers was the first game to truly fascinate with its gameplay. 
 The intuitive control of SMB and the great level desig...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a clone game Super Mario Brothers (part 1)</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="http://kartinok.net/images/2012/12/16/Bu03c.png" alt="image">  For many of us, Super Mario Brothers was the first game to truly fascinate with its gameplay. <br>  The intuitive control of SMB and the great level design from Nintendo made it necessary to spend hours on end in the virtual universe of the plumber and his partner. <br><br>  In this wonderful tutorial from <a href="http://www.raywenderlich.com/about">Jacob Gundersen,</a> we will create our own platformer;  but since the main character will be Koala, we will call our game ‚ÄúSuper Koalio Brothers!‚Äù;] <br>  Also, to simplify the mechanics, we forget about moving enemies.  Instead, we will use spike blocks embedded in the floor.  This will allow us to concentrate fully on the heart of the platformer - the physics engine. <br><br>  Attention!  Under the cut an incredible amount of translated text, images, code (code is not translated) and a guide to creating your own physics engine! <br><a name="habracut"></a><br>  This tutorial in advance implies that you are familiar with the basics of Cocos2D programming.  Otherwise, I strongly recommend that you first familiarize yourself with a couple of initial lessons on <a href="http://www.raywenderlich.com/tutorials">Ray‚Äôs website</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Let's start </h4><br>  To get started, download the <a href="">starter project</a> for this tutorial.  Unzip it, open it in Xcode, run it.  Something similar should appear on the emulator screen: <br><br><img src="http://kartinok.net/images/2012/12/16/umt0O.png" alt="image"><br><br>  That's right - just a boring blank screen!  :] We will fill it in full as you go through the tutorial. <br>  All necessary pictures and sounds have already been added to the start project.  Let's run through the contents of the project: <br><br><ul><li>  <b>Game Art.</b>  Includes a free package of game artov from Ray <a href="http://www.vickiwenderlich.com/">Vicki‚Äôs</a> wife. </li><li>  <b>Level map</b>  I drew a level map especially for you, starting from the first level in SMB. </li><li>  <b>Great sound effects.</b>  After all, tutorial with raywenderlich.com!  :] </li><li>  <b>Subclass CCLayer.</b>  A class named GameLevelLayer that implements most of our physics engine.  Although it is now empty as a cork.  (Yes, this baby is waiting to be filled!) </li><li>  <b>Subclass of CCSprite.</b>  A class named Player that contains Koala logic.  Right now, our Koala is trying to fly away! </li></ul><br><h4>  Fundamentals of physics engines </h4><br>  Platformers operate on the basis of physics engines, and in this tutorial we will write our own physics engine. <br>  There are two reasons why we need to write our own engine, and not take the same Box2D or Chipmink: <br><br><ol><li>  <b>Detailed setting.</b>  To fully know the Zen platformer, you need to learn how to fully customize your engine. </li><li>  <b>Simplicity.</b>  Box2D and Chipmunk have a lot of customizable functions that, by and large, are not useful to us.  Yes, and there will be resources.  And our own engine will eat exactly as much as we allow it. </li></ol><br>  The physics engine performs two main tasks: <br><img align="right" src="http://kartinok.net/images/2012/12/18/iE8P.png" alt="image"><br><ol><li>  <b>Simulates movement.</b>  The first task of the physics engine is to simulate opposing forces of gravity, movement, jumps and friction. </li><li>  <b>Defines collisions.</b>  The second task is to determine the collisions between the player and other objects at the level. </li></ol><br>  For example, during the jump on our Koala acts force directed upwards.  After some time, the force of gravity exceeds the force of the jump, which gives us the classical parabolic change of speed. <br>  With the help of collision detection, we will stop our Koala every time she wants to go through the floor under the influence of gravity, and determine when our Koala stepped on spikes (ah!). <br>  Let's see how this works in practice. <br><br><h4>  Creating a physics engine </h4><br>  In the physics engine that we will create, the Koala will have its variables describing the movements: speed, acceleration and position.  Using these variables, each step of our program we will use the following algorithm: <br><br><ol><li>  Is a jump or move action selected? </li><li>  If so, apply the force of a jump or movement to a koala. </li><li>  Also apply gravity force to koala. </li><li>  Calculate the resulting koala velocity. </li><li>  Apply the resulting speed to Koala and update its position. </li><li>  Check for Koala collisions with other objects. </li><li>  If a collision occurs, then either move the Koala to such a distance from the obstacle that collisions no longer occur;  or damage poor Koale. </li></ol><img align="right" src="http://kartinok.net/images/2012/12/18/1oRZ9.png" alt="image"><br>  We will go through these actions every step of the program.  In our game, gravity constantly causes the Koala to sink lower and lower through the floor, but the definition of collisions each time brings it back to a point above the floor.  You can also use this feature to determine if Koala is touching the earth.  If not, you can forbid the player to jump when the Koala is in a state of jumping or has just jumped off from an obstacle. <br>  Items 1-5 occur within the Koala object.  All the necessary information should be stored inside this object and it is quite logical to allow Koale to update its variables on its own. <br>  However, when it comes to the 6th point - collision definitions - we need to take into account all the features of the level, such as: walls, floor, enemies and other dangers.  Collision detection will be carried out every step of the program using GameLevelLayer - remember, this is a subclass of CCLayer, which will perform most physical tasks. <br>  If we allow Koale to update her position with his own hand, then finally Koala will touch the wall or the floor.  And GameLevelLayer will bring Koala back.  And so again and again - what will make Koala look like it is vibrating.  (Too much coffee in the morning, Koalio?) <br>  And so, we will not allow Koale to update their state.  Instead, we‚Äôll add a new desiredPosition variable to Koala, which Koala will update.  GameLevelLayer will check if the Koala can be moved to the desiredPosition.  If so, then GameLevelLayer will update the status of the Koala. <br>  All clear?  Let's see how it looks in the code! <br><br><h4>  Download TMXTiledMap </h4><br>  I assume that you are familiar with how Tile Maps work.  If not, then I advise you to read about them in <a href="http://www.raywenderlich.com/1163/how-to-make-a-tile-based-game-with-cocos2d">this tutorial</a> . <br>  Let's take a look at the level.  Launch your <a href="http://www.mapeditor.org/">Tiled map editor</a> (download if you have not done this before) and open <b>level1.tmx</b> from your project folder.  You will see the following: <br><br><img src="http://kartinok.net/images/2012/12/16/5CqIQ.png" alt="image"><br><br>  If you look at the sidebar, you will see that we have three different layers: <br><br><ul><li>  <b>hazards:</b> This layer contains things Koala must beware of in order to stay alive. </li><li>  <b>walls:</b> This layer contains cells that Koala cannot pass through.  Basically it is the cell floor. </li><li>  <b>background:</b> This layer contains purely aesthetic things, such as clouds or hills. </li></ul><br>  It's time to code!  Open <b>GameLevelLayer.m</b> and add the following after <code>#import</code> , but before <code>@implementation</code> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameLevelLayer</span></span></span><span class="hljs-class">() </span></span>{ CCTMXTiledMap *map; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br>  We added a local map variable of the class CCTMXTiledMap for working with mesh maps in our head class. <br>  Next, we will place a mesh map on our layer right during layer initialization.  Add the following to the <b>init</b> method <b>:</b> <br><br><pre> <code class="objectivec hljs">CCLayerColor *blueSky = [[CCLayerColor alloc] initWithColor:ccc4(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">250</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>)]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addChild:blueSky]; map = [[CCTMXTiledMap alloc] initWithTMXFile:<span class="hljs-string"><span class="hljs-string">@"level1.tmx"</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addChild:map];</code> </pre><br>  First, we added a backdrop (CCLayerColor) blue sky color.  The next two lines of code are simply loading the map variable (CCTMXTiledMap) and adding it to the layer. <br><br>  Next, in <b>GameLevelLayer.m we</b> import Player.h: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Player.h"</span></span></span></span></code> </pre><br>  Still in <b>GameLevelLayer.m,</b> add the following local variable to the <code>@ interface</code> section: <br><br><pre> <code class="objectivec hljs">Player * player;</code> </pre><br>  Next, add Koala to the level with the following code in the <b>init</b> method: <br><br><pre> <code class="objectivec hljs">player = [[Player alloc] initWithFile:<span class="hljs-string"><span class="hljs-string">@"koalio_stand.png"</span></span>]; player.position = ccp(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); [map addChild:player z:<span class="hljs-number"><span class="hljs-number">15</span></span>];</code> </pre><br>  This code loads the Koala sprite object, sets its position and adds it to the object of our map. <br>  You ask why add a koala object to the map instead of just adding it directly to the layer?  It's simple.  We want to directly control which layer will be in front of the Koala, and which one will be behind it.  So we make Koala a baby card, not a main layer.  We want the Koala to be in front, so we give it a Z-order of 15. Similarly, when we scroll the map, the Koala is still at the same position, relative to the map, and not the main layer. <br>  Great, let's try!  Run your project and you should see the following: <br><br><img src="http://kartinok.net/images/2012/12/16/YTZvS.png" alt="image"><br><br>  It looks like a game, but Koalio ignores gravity!  It's time to lower it from heaven to earth - with the help of a physics engine:] <br><br><h4>  Situation with gravity Koalio </h4><img align="right" src="http://kartinok.net/images/2012/12/18/wjLh.png" alt="image"><br>  To create a simulation of physics, you can write a complex set of branching logic that would take into account the state of Koala and apply forces to it, building on the information received.  But this world will immediately become too complicated - a real physics doesn‚Äôt work so hard.  In the real world, gravity just constantly pulls objects down.  So, we add constant gravity force and apply it to Koale every step of the program. <br>  Other forces are also not just turned off and on.  In the real world, force acts on an object until another force surpasses or is equal to the first. <br>  For example, the force of a jump does not disable gravity;  for some time, it exceeds the force of gravity, until gravity presses Koala to the ground again. <br>  This is how physics is modeled.  You do not just decide whether or not to apply the gravitational force to Koale.  Gravity is always there. <br><br><h4>  Playing god </h4><img align="right" src="http://kartinok.net/images/2012/12/18/bB0mq.png" alt="image"><br>  In the logic of our engine, it is assumed that if a force acts on an object, it will continue to move until another force exceeds the first one.  When Koalio jumps off the ledge, he continues to move downward with a certain acceleration until he encounters an obstacle in his path.  When we move a Koalio, it will not stop moving until we stop applying the force of movement on it;  friction will act on Koalio until it stops. <br>  As you create a physics engine, you will see how so simple game logic helps to solve complex physical problems, such as: an ice floor or a fall from a cliff.  This behavioral model allows the game to change dynamically. <br>  Also such a knight's move will allow us to make implementation easier, since we do not need to constantly ask the state of our object - the object will simply follow the laws of physics from the real world. <br>  Sometimes we need to play god!  :] <br><br><h4>  Laws of Planet Earth: CGPoint's and Forces </h4><br>  Let's denote the following concepts: <br><br><ul><li>  <b>Speed</b> describes how fast an object moves in a certain direction. </li><li>  <b>Acceleration</b> describes how the speed and direction of an object changes over time. </li><li>  <b>Strength</b> is the influence that causes a change in speed or direction. </li></ul><br>  In a physical simulation, the force applied to an object will accelerate the object to a certain speed, and the object will move at that speed until it encounters another force on the way.  Speed ‚Äã‚Äãis a value that changes from one frame to the next as new forces appear. <br>  We will present three things using CGPoint structures: speed, force / acceleration and position.  There are two reasons for using CGPoint structures: <br><br><ol><li>  <b>They are 2D.</b>  Speed, force / acceleration and position are all 2D values ‚Äã‚Äãfor a 2D game.  You can say that gravity acts only in one direction, but what if at one point in the game we urgently need to change the direction of gravity?  Think of Super Mario Galaxy! </li><li>  <b>It's comfortable.</b>  Using CGPoint, we can use various functions built into Cocos2D.  In particular, we will use ccpAdd (addition), ccpSub (subtraction) and ccpMult (multiplication by a variable of type float).  All this will make our code much easier to read and debug! </li></ol><br>  The object of our Koala will have a variable speed, which will vary according to the appearance of various forces, including gravity, movement, jumps, friction. <br>  Each step of the game, we will add all the forces together, and the resulting value will be added to the current speed of the Koala.  As a result, we will receive a new current speed.  We will reduce it using the frame rate.  After that we will move the Koala. <br><blockquote>  <b>Please note:</b> if any of the above is misleading, then a wonderful person, Daniel Shiffman, wrote a great <a href="http://www.processing.org/learning/pvector/">tutorial</a> on vectors that fully explains the actions of forces on the structures that we use. <br></blockquote>  Let's start with gravity.  Let's write a run loop in which we will apply forces.  Add the following code to the init method of the <b>GameLevelLayer.m</b> file right before closing the conditional if block: <br><br><pre> <code class="objectivec hljs">[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> schedule:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(update:)];</code> </pre><br>  Next, add a new method to the class: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)update:(ccTime)dt { [player update:dt]; }</code> </pre><br>  Next, open <b>Player.h</b> and change it to look like this: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cocos2d.h"</span></span></span><span class="hljs-meta"> @interface Player : CCSprite @property (nonatomic, assign) CGPoint velocity; - (void)update:(ccTime)dt; @end</span></span></code> </pre><br>  Add the following code to <b>Player.m</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Click me</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Player.h"</span></span></span><span class="hljs-meta"> @implementation Player @synthesize velocity = _velocity; // 1 - (id)initWithFile:(NSString *)filename { if (self = [super initWithFile:filename]) { self.velocity = ccp(0.0, 0.0); } return self; } - (void)update:(ccTime)dt { // 2 CGPoint gravity = ccp(0.0, -450.0); // 3 CGPoint gravityStep = ccpMult(gravity, dt); // 4 self.velocity = ccpAdd(self.velocity, gravityStep); CGPoint stepVelocity = ccpMult(self.velocity, dt); // 5 self.position = ccpAdd(self.position, stepVelocity); } @end</span></span></code> </pre></div></div><br>  Let's go through the code above step by step. <br><br><ol><li>  Here we added a new init method to initialize the object and set the speed variable to zero. </li><li>  Here we denote the value of the gravity vector.  Every second we accelerate the Koala's speed down 450 pixels. </li><li>  Here we used ccpMult in order to reduce the value of the gravitational vector to meet the frame rate.  ccpMult gets float and CGPoint and returns CGPoint. </li><li>  Here, as soon as we calculate gravity for the current step, we add it to the current speed. </li><li>  Finally, when we calculated the speed for one step, we use ccpAdd to update the Koala position. </li></ol><br>  Congratulations!  We are on the direct path to creating our first physics engine!  Run your project to see the result! <br><br><img src="http://kartinok.net/images/2012/12/16/07HpV.png" alt="image"><br><br>  Oooooooooops - Koalio falls through the floor!  Let's fix it. <br><br><h4>  Night Strikes - Collision Detection </h4><br>  Collision detection is the basis of any physics engine.  There are many different types of collision detection, from simple use of image frames to complex collisions of 3D objects.  Fortunately for us, the platformer does not require complex structures. <br>  To define Koala collisions with objects, we will use TMXTileMap for the cells that directly surround the Koala.  Next, using several built-in iOS functions, we will check if the sprite Koalas crosses a sprite of a cell. <br>  The CGRectIntersectsRect and CGRectIntersection functions make such checks very simple.  CGRectIntersectsRect checks whether two rectangles intersect, and CGRectIntersection returns the intersection rectangle. <br>  First, we need to define the frame of our Koala.  Each downloaded sprite has a frame, which is the size of the texture and which can be accessed using a parameter named boundingBox. <br>  Why define a frame if it already exists in a boundingBox?  The texture usually has transparent edges around itself, which we don‚Äôt want to take into account when determining collisions. <br>  Sometimes we don‚Äôt need to take into account even a couple of pixels around the real image of the sprite (not transparent).  When Mario hits a wall, does he touch her a bit, or does his nose sink into the block slightly? <br>  Let's try.  Add to <b>Player.h</b> : <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)collisionBoundingBox;</code> </pre><br>  And add to <b>Player.m</b> : <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)collisionBoundingBox { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGRectInset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.boundingBox, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  CGRectInset compresses CGRect by the number of pixels from the second and third arguments.  In our case, the width of our collision frame will be six pixels less ‚Äî three pixels on each side. <br><br><h4>  Weight lifting </h4><br>  It's time to lift weights.  (‚ÄúHey, did you call me fat now?‚Äù Says Koalio). <br>  We will need a number of methods in our GameLevelLayer to determine collisions.  In particular: <br><br><ul><li>  The method that returns the coordinates of the eight cells surrounding the current Koalio cell. </li><li>  A method that determines which cell is an obstacle (and whether there are any in general).  Some cells do not have physical properties (clouds), and Koalio will not encounter them. </li><li>  A method that handles collisions in priority order. </li></ul><br>  We will create two helper functions that will simplify the methods described just above. <br><br><ul><li>  A method that determines the position of a Koalio cell. </li><li>  A method that receives cell coordinates and returns a cell rectangle in Cocos2D coordinates. </li></ul><br>  Add the following code to <b>GameLevelLayer.m</b> : <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)tileCoordForPosition:(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)position { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = floor(position.x / map.tileSize.width); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> levelHeightInPixels = map.mapSize.height * map.tileSize.height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = floor((levelHeightInPixels - position.y) / map.tileSize.height); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ccp(x, y); } - (<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)tileRectFromTileCoords:(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)tileCoords { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> levelHeightInPixels = map.mapSize.height * map.tileSize.height; <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> origin = ccp(tileCoords.x * map.tileSize.width, levelHeightInPixels - ((tileCoords.y + <span class="hljs-number"><span class="hljs-number">1</span></span>) * map.tileSize.height)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CGRectMake</span></span>(origin.x, origin.y, map.tileSize.width, map.tileSize.height); }</code> </pre><br>  The first method returns us the coordinates of the cell located on the coordinates in pixels that we pass to the method.  To get the position of a cell, we simply divide the coordinates by the size of the cells. <br>  We need to invert the elevation coordinates, since the coordinates of the Cocos2D / OpenGL system start at the bottom left corner, and the system coordinates start at the top left corner.  Standards - isn't it cool? <br>  The second method does the opposite.  It multiplies the cell coordinate by the cell size and returns the CGRect of the cell.  Again, we need to expand the height. <br>  Why do we need to add one to the y-coordinate of the height?  Remember, the cell coordinates start from zero, so the 20 cell has a real coordinate of 19. If we do not add one to the height, the point will be 19 * tileHeight. <br><br><h4>  I am surrounded by cells! </h4><br>  We now turn to the method that defines the surrounding Koala cells.  In this method we will create an array, which we will return.  This array will contain the GID of the cell, the coordinates of the cell and information about the CGRect of this cell. <br>  We organize this array in order of priority, in which we will define collisions.  For example, we want to define collisions from above, to the left, to the right, from below, before we determine the diagonal ones.  Also, when we determine the collision of the Koala with the lower cell, we set the flag to touch the ground. <br>  Add this method to <b>GameLevelLayer.m</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Click me</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)getSurroundingTilesAtPosition:(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>)position forLayer:(CCTMXLayer *)layer { <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> plPos = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> tileCoordForPosition:position]; <span class="hljs-comment"><span class="hljs-comment">//1 NSMutableArray *gids = [NSMutableArray array]; //2 for (int i = 0; i &lt; 9; i++) { //3 int c = i % 3; int r = (int)(i / 3); CGPoint tilePos = ccp(plPos.x + (c - 1), plPos.y + (r - 1)); int tgid = [layer tileGIDAt:tilePos]; //4 CGRect tileRect = [self tileRectFromTileCoords:tilePos]; //5 NSDictionary *tileDict = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:tgid], @"gid", [NSNumber numberWithFloat:tileRect.origin.x], @"x", [NSNumber numberWithFloat:tileRect.origin.y], @"y", [NSValue valueWithCGPoint:tilePos],@"tilePos", nil]; [gids addObject:tileDict]; } [gids removeObjectAtIndex:4]; [gids insertObject:[gids objectAtIndex:2] atIndex:6]; [gids removeObjectAtIndex:2]; [gids exchangeObjectAtIndex:4 withObjectAtIndex:6]; [gids exchangeObjectAtIndex:0 withObjectAtIndex:4]; //6 for (NSDictionary *d in gids) { NSLog(@"%@", d); } //7 return (NSArray *)gids; }</span></span></code> </pre></div></div><br>  Pff - a whole cloud of code.  Do not worry, we will take a detailed look at it. <br>  But before that, notice that we have three layers on our map. <br>  The presence of different layers allows us to determine the collisions for each layer in different ways. <br><br><ul><li>  <b>Koala and hazards.</b>  If a collision occurs, then we kill the Koala (quite brutal, isn't it?). </li><li>  <b>Koala and walls.</b>  If a collision occurs, we do not allow Koale to move further in this direction.  ‚ÄúStay mare!‚Äù </li><li>  <b>Koala and backgrounds.</b>  If a collision occurs, then we do nothing.  Lazy programmer is the best programmer.  Well, or how there, the people say? </li></ul><br>  Of course, there are various ways to identify different collisions with different blocks, but what we have - the layers on the map, is quite effective. <br>  Okay, let's go through the code step by step. <br><br>  <b>1.</b> To begin with, we get the coordinates of the input cell (which will be the coordinates of the Koala). <br>  <b>2.</b> Next, we create a new array that will return cell information. <br>  <b>3.</b> Next, we start the cycle 9 times - since we have 9 possible movement cells, including the cell in which the koala is already located.  The next few lines define the positions of the nine cells and store them in the variable tilePos. <br><br><blockquote>  <b>Note:</b> we only need information about eight cells, since we will never have to determine collisions with a cell on which the koala is already located. <br>  We should always catch this case and move the Koala to one of the cells around.  If Koalio is inside a solid cell, then more than half of the Koalio sprite has gone inside.  He should not move so fast - at least in this game! <br>  To make it easier to operate on these eight cells, simply add a Koalio cell at the beginning, and at the end remove it. </blockquote><br>  <b>4.</b> In the fourth section, we call the tileGIDAt: method.  This method returns the GID of the cell at a specific coordinate.  If there is no cell on the received coordinates, the method returns zero.  In the following, we will use zero for the ‚Äúno cell found‚Äù. <br>  <b>5.</b> Next, we use an auxiliary method to calculate the CGRect for a cell on the given Cocos2D coordinates.  We store the received information in NSDictionary.  The method returns an array of the resulting NSDictionary. <br>  <b>6.</b> In the sixth section, we remove the Koala cell from the array and sort the cells in priority order. <br><img align="right" src="http://kartinok.net/images/2012/12/18/g7Tyv.png" alt="image"><br>  Often, in the case of determining collisions with a cell under the Koala, we also define collisions with cells along the diagonal.  See the picture on the right.  Defining collisions with a cell under the Koala, baked in red, we also determine collisions with block # 2, highlighted in blue. <br>  Our collision detection algorithm will use some assumptions.  These assumptions are correct for adjacent, rather than for diagonal cells.  So we will try to avoid actions with diagonal cells as much as possible. <br>  And here is a picture that clearly shows us the order of cells in the array before and after sorting.  You may notice that the top, bottom, right and left cells are processed first.  Knowing the order of the cells, it will be easier to determine when the Koala touches the ground or flies in the clouds. <br><img src="http://kartinok.net/images/2012/12/16/c64mR.png" alt="image"><br><br>  <b>7.</b> The cycle in section seven allows us to monitor cells in real time.  So, we can know for sure that everything is going according to plan. <br><br>  We are almost ready for the next launch of our game!  However, you still need to do a couple of things.  We need to add the walls layer as a variable to the GameLevelLayer class so that we can use it. <br><br>  Inside <b>GameLevelLayer.m,</b> make the following changes: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//   @interface CCTMXLayer *walls; //    init,  ,      walls = [map layerNamed:@"walls"]; //    update [self getSurroundingTilesAtPosition:player.position forLayer:walls];</span></span></code> </pre><br>  Run!  But, unfortunately, the game crashes.  We see something in the console: <br><br><img src="http://kartinok.net/images/2012/12/16/afPg8.png" alt="image"><br><br>  First we get information about cell positions and GID values ‚Äã‚Äã(although mostly zeros, since the top is empty terrain). <br>  In the end, everything crashes with the error "TMXLayer: invalid position".  This happens when a position is passed to the tileGIDat: method that is outside the edges of the map. <br>  We will avoid this error a little later ‚Äî but first, we are going to change the existing definition of collisions. <br><br><h4>  We select Koala's privileges back </h4><br>  Up to this point, Koala herself was updating her position.  But now we are taking this privilege from her. <br><br><img src="http://kartinok.net/images/2012/12/18/f7EI6.png" alt="image"><br><br>  If Koala will independently update her position, then in the end she will start jumping like mad!  And we don't want that, no? <br>  So Koala requires an additional variable, desiredPosition, with which she will interact with GameLevelLayer. <br>  We want the Koala class to independently calculate its next position.  But GameLevelLayer should move the Koala to the desired position only after checking it for validity.  The same applies to the collision loop - we don‚Äôt want to update the real sprite before all the cells have been checked for collisions. <br>  We need to change a few things.  First, add the following to <b>Player.h</b> <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">assign</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> desiredPosition;</code> </pre><br>  And synthesize added in <b>Player.m</b> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@synthesize</span></span> desiredPosition = _desiredPosition;</code> </pre><br>  Now, change the <b>collisionBoundingBox</b> method in <b>Player.m</b> so that it looks like this: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)collisionBoundingBox { <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span> collisionBox = <span class="hljs-built_in"><span class="hljs-built_in">CGRectInset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.boundingBox, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> diff = ccpSub(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.desiredPosition, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.position); <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span> returnBoundingBox = <span class="hljs-built_in"><span class="hljs-built_in">CGRectOffset</span></span>(collisionBox, diff.x, diff.y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnBoundingBox; }</code> </pre><br>  This piece of code calculates a frame based on the desired position that GameLevelLayer will use to determine collisions. <br><blockquote>  <b>Note:</b> There are many different ways to calculate collision frames.  You can write code similar to the one that already exists in the CCNode class, but our current method is much simpler, despite some non-obviousness. <br></blockquote>  Next, make the following changes to the update method so that it updates the desiredPosition instead of the current position: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  'self.position = ccpAdd(self.position, stepVelocity);' : self.desiredPosition = ccpAdd(self.position, stepVelocity);</span></span></code> </pre><br><h4>  Let's start defining collisions! </h4><br>  The time has come for serious accomplishments.  We are going to put it all together.  Add the following method to <b>GameLevelLayer.m</b> : <br><br><div class="spoiler">  <b class="spoiler_title">Click me</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)checkForAndResolveCollisions:(Player *)p { <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *tiles = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getSurroundingTilesAtPosition:p.position forLayer:walls ]; <span class="hljs-comment"><span class="hljs-comment">//1 for (NSDictionary *dic in tiles) { CGRect pRect = [p collisionBoundingBox]; //2 int gid = [[dic objectForKey:@"gid"] intValue]; //3 if (gid) { CGRect tileRect = CGRectMake([[dic objectForKey:@"x"] floatValue], [[dic objectForKey:@"y"] floatValue], map.tileSize.width, map.tileSize.height); //4 if (CGRectIntersectsRect(pRect, tileRect)) { CGRect intersection = CGRectIntersection(pRect, tileRect); //5 int tileIndx = [tiles indexOfObject:dic]; //6 if (tileIndx == 0) { //    p.desiredPosition = ccp(p.desiredPosition.x, p.desiredPosition.y + intersection.size.height); } else if (tileIndx == 1) { //    p.desiredPosition = ccp(p.desiredPosition.x, p.desiredPosition.y - intersection.size.height); } else if (tileIndx == 2) { //    p.desiredPosition = ccp(p.desiredPosition.x + intersection.size.width, p.desiredPosition.y); } else if (tileIndx == 3) { //    p.desiredPosition = ccp(p.desiredPosition.x - intersection.size.width, p.desiredPosition.y); } else { if (intersection.size.width &gt; intersection.size.height) { //7 // ,     float intersectionHeight; if (tileIndx &gt; 5) { intersectionHeight = intersection.size.height; } else { intersectionHeight = -intersection.size.height; } p.desiredPosition = ccp(p.desiredPosition.x, p.desiredPosition.y + intersection.size.height ); } else { // ,     float resolutionWidth; if (tileIndx == 6 || tileIndx == 4) { resolutionWidth = intersection.size.width; } else { resolutionWidth = -intersection.size.width; } p.desiredPosition = ccp(p.desiredPosition.x , p.desiredPosition.y + resolutionWidth); } } } } } p.position = p.desiredPosition; //7 }</span></span></code> </pre></div></div><br>  Fine!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take a look at the code we just wrote. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First we get a set of cells surrounding the Koala. Next we cycle through each cell in this set. Every time we go through the cell, we check it for collisions. If a collision occurs, we change the desiredPosition of the Koala. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inside each loop of the loop, we first get the current Koala frame. Each time a collision is detected, the desiredPosition variable changes its value to one in which collisions no longer occur. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The next step is to get the GID that we stored in the NSDictionary, which may be null. If the GID is zero, then the current loop ends and we go to the next cell. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">four.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If a cell is in a new position, we need to get its CGRect. </font><font style="vertical-align: inherit;">It may or may not have a collision. </font><font style="vertical-align: inherit;">We carry out this process with the following line of code and save it to the tileRect variable. </font><font style="vertical-align: inherit;">Now, having CGRect Koals and cells, we can check them for collisions. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To check the cells for collisions, we run CGRectIntersectsRect. </font><font style="vertical-align: inherit;">If a collision occurs, we get a CGRect that describes the CGRect intersection using the CGRectIntersection () function.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's stop to think about the dilemma ... </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quite an interesting case. We need to figure out how to correctly identify collisions. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You might think that the best way to move a koala is to move it in the opposite direction from a collision. Some physics engines do work on this principle, but we are going to apply the solution better. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Think: gravity constantly pulls the Koala down into the cells below it, and these collisions happen all the time. If you imagine a Koala moving forward, then at the same time the Koala still pulls down with gravity. If we solve this problem by simply changing the movement in the opposite direction, the Koala will move up and to the left - and in fact we need something else!</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our Koala should move a sufficient distance to still remain above these cells, but continue to move forward at the same pace. </font></font><br><img src="http://kartinok.net/images/2012/12/18/Ezgt.png" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same problem will occur if Koala slides down the wall. If the player presses the Koala against the wall, then the desired trajectory of the movement of the Koala will be directed diagonally downwards and into the wall. Just turning the direction, we will make Koala move up and away from the wall - again, not at all! We want Koala to remain outside the wall, but still go down at the same pace!</font></font><br><img src="http://kartinok.net/images/2012/12/18/F2wJp.png" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we need to decide when to deal with collisions vertically, and when horizontally, and to process both actions mutually exclusive. Some physics engines constantly process the first event first, and then the second one; but we want to make a better decision based on the position of the Koala cell. So, for example, when the cell is right under the Koala, we want the collision determiner to return the Koala up. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what if the cell is diagonal to the Koala position? In this case, we use the CGRect intersection to understand how we should move the Koala. If the width of this rectangle is greater than the height, then Koala should be returned vertically. If the height is greater than the width, then the Koala should shift horizontally.</font></font><br><img src="http://kartinok.net/images/2012/12/18/pin52.png" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This process will work correctly as long as the Koala's speed and frame rate are within a certain range. A little later we will learn to avoid cases when the Koala falls too fast and slips down through the cell. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once we have determined how to move the Koala vertically or horizontally, we use the size of the CGRect intersection to determine how much the Koala needs to be removed. We look at the width or height, respectively, and use this value as the Koala offset distance. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why check the cells in a certain order? You always need to first work with adjacent cells, and then with diagonal. After all, if you want to check for a collision cell to the right below the Koala, then the displacement vector will be directed vertically.</font></font><br><img align="right" src="http://kartinok.net/images/2012/12/18/UuYdj.png" alt="image"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, there is still a chance that the CGRect of the collision will be elongated upwards when the Koala slightly touches the cell. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Look at the picture on the right. </font><font style="vertical-align: inherit;">The blue area extends upward, because the collision rectangle is only a small part of the overall collision. </font><font style="vertical-align: inherit;">However, if we have already solved the problem with the cell right under the Koala, then we no longer need to determine collisions with the cell below to the right of the Koala. </font><font style="vertical-align: inherit;">So we go around the problems that have appeared.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Back to the code! </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let‚Äôs return to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checkForAndResolveCollisions:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... </font><font style="vertical-align: inherit;">method </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The sixth section allows us to get the index of the current cell. </font><font style="vertical-align: inherit;">We use cell index to get cell position. </font><font style="vertical-align: inherit;">We are going to operate on adjacent cells individually, displacing the Koala, subtracting or adding the length or height of the collision.</font></font> Pretty simple.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, as soon as it comes to diagonal cells, we are going to apply the algorithm described in the previous section. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the seventh section, we determine which area of ‚Äã‚Äãour collision is: wide or upward? </font><font style="vertical-align: inherit;">If wide - we work vertically. </font><font style="vertical-align: inherit;">If the cell index is greater than 5, then we move the Koala up. </font><font style="vertical-align: inherit;">If the area is extended upwards - we work horizontally. </font><font style="vertical-align: inherit;">We act according to a similar order of cell indexes. </font><font style="vertical-align: inherit;">At the end, we assign Koale the resulting position. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method is the brain of our collision detection system. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's use all the available knowledge in practice! </font><font style="vertical-align: inherit;">Change the method of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the update</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (still in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameLevelLayer:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//  "[self getSurroundingTilesAtPosition:player.position forLayer:walls];" : [self checkForAndResolveCollisions:player];</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also delete or comment out the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getSurroundingTilesAtPosition: forLayer block:</font></font></b> <br><br><pre> <code class="objectivec hljs"> <span class="hljs-comment"><span class="hljs-comment">/* for (NSDictionary *d in gids) { NSLog(@"%@", d); } //8 */</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run! </font><font style="vertical-align: inherit;">Surprised by the result? </font></font><br><br><img src="http://kartinok.net/images/2012/12/16/kVQZ9.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paul stops Koalio, but he immediately sinks into it!</font></font> Why? <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Can you guess what we missed? </font><font style="vertical-align: inherit;">Remember - every step of the game we add gravity to the speed of the Koala. </font><font style="vertical-align: inherit;">This means that the Koala is constantly accelerating down. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We constantly add speed to the Koala's trajectory down until it becomes the size of a cell ‚Äî we move through the whole cell in one step, which causes problems (remember, we spoke about this recently). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as we detect the collision, we need to reset the speed of the koala in the direction of the cell we are facing! </font><font style="vertical-align: inherit;">The koala has stopped moving, so the speed must be reckoned with.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we do not do this, then we will have a rather strange behavior of the game. As we noted earlier, we need a way to determine if the koala touches the ground so that the koala cannot jump even higher. We will check this box right now. Add the following lines to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checkForAndResolveCollisions:</font></font></b> <br><br><div class="spoiler">  <b class="spoiler_title">Click me</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)checkForAndResolveCollisions:(Player *)p { <span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *tiles = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> getSurroundingTilesAtPosition:p.position forLayer:walls ]; <span class="hljs-comment"><span class="hljs-comment">//1 p.onGround = NO; ////// for (NSDictionary *dic in tiles) { CGRect pRect = [p collisionBoundingBox]; //3 int gid = [[dic objectForKey:@"gid"] intValue]; //4 if (gid) { CGRect tileRect = CGRectMake([[dic objectForKey:@"x"] floatValue], [[dic objectForKey:@"y"] floatValue], map.tileSize.width, map.tileSize.height); //5 if (CGRectIntersectsRect(pRect, tileRect)) { CGRect intersection = CGRectIntersection(pRect, tileRect); int tileIndx = [tiles indexOfObject:dic]; if (tileIndx == 0) { //   p.desiredPosition = ccp(p.desiredPosition.x, p.desiredPosition.y + intersection.size.height); p.velocity = ccp(p.velocity.x, 0.0); ////// p.onGround = YES; ////// } else if (tileIndx == 1) { //   p.desiredPosition = ccp(p.desiredPosition.x, p.desiredPosition.y - intersection.size.height); p.velocity = ccp(p.velocity.x, 0.0); ////// } else if (tileIndx == 2) { //  p.desiredPosition = ccp(p.desiredPosition.x + intersection.size.width, p.desiredPosition.y); } else if (tileIndx == 3) { //  p.desiredPosition = ccp(p.desiredPosition.x - intersection.size.width, p.desiredPosition.y); } else { if (intersection.size.width &gt; intersection.size.height) { //tile is diagonal, but resolving collision vertially p.velocity = ccp(p.velocity.x, 0.0); ////// float resolutionHeight; if (tileIndx &gt; 5) { resolutionHeight = intersection.size.height; p.onGround = YES; ////// } else { resolutionHeight = -intersection.size.height; } p.desiredPosition = ccp(p.desiredPosition.x, p.desiredPosition.y + resolutionHeight); } else { float resolutionWidth; if (tileIndx == 6 || tileIndx == 4) { resolutionWidth = intersection.size.width; } else { resolutionWidth = -intersection.size.width; } p.desiredPosition = ccp(p.desiredPosition.x + resolutionWidth, p.desiredPosition.y); } } } } } p.position = p.desiredPosition; //8 }</span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Every time there is a cell under Koala (either adjacent or diagonal), we set the value of the p.onGround variable to YES and reset the speed. </font><font style="vertical-align: inherit;">Also, if there is an adjacent cell under the Koala, we reset its speed. </font><font style="vertical-align: inherit;">This will allow us to properly respond to the current Koala speed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We set the onGround variable to NO at the beginning of the cycle. </font><font style="vertical-align: inherit;">In this case, onGround will have a YES value only when we detect a Koala collision with a cell under it. </font><font style="vertical-align: inherit;">We can use this feature to determine whether Koala can jump or not at the current time. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add the following code to the heading file (and then synthesize everything you need in the executive) in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Player.h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">assign</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> onGround;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Player.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@synthesize</span></span> onGround = _onGround;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run! </font><font style="vertical-align: inherit;">Does everything work as intended?</font></font> Yes!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oh, this great day! </font></font> Hooray! <br><br><img src="http://kartinok.net/images/2012/12/16/8ukz.png" alt="image"><br><br><h4>  What's next? </h4><br>  Congratulations!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You have completely finished your physics engine! If you get to this text, you can breathe a sigh of relief. It was a difficult part - there will be nothing difficult in the second part of the tutorial. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here is the </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source of the project</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that we have now completed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the </font></font><a href="http://habrahabr.ru/post/163435/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second part,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we will make our Koalio run and jump. We will also make spike blocks in the floor dangerous for our Koala and create screens of win and loss. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to gain even more knowledge about the physics engines for platformers, then I advise you to visit the following resources: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Sonic the Hedgehog Wiki is a great explanation of </font></font><a href="http://info.sonicretro.org/SPG:Solid_Tiles"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how Sonic interacts with solid cells</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps the best</font></font><a href="http://higherorderfun.com/blog/2012/05/20/the-guide-to-implementing-2d-platformers/"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Higher-Order Fun </font><a href="http://higherorderfun.com/blog/2012/05/20/the-guide-to-implementing-2d-platformers/"><font style="vertical-align: inherit;">Platform</font></a><font style="vertical-align: inherit;"> Tutorial</font></font><br><hr><br><h5>  Translator's Note </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I decided to translate this tutorial, inspired by </font></font><a href="http://habrahabr.ru/post/162733/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I myself am writing a platformer game on iOS and actively use tutorials on </font></font><a href="http://www.raywenderlich.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raywenderlich.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I advise everyone! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After a relatively large amount of time spent translating the first part, I thought about translating the second part. </font><font style="vertical-align: inherit;">Write in the comments if you need. </font><font style="vertical-align: inherit;">If it is claimed - I will translate.</font></font><br>  About all inaccuracies and typographical errors found, please write in habraposhta or here in the comments. <br>  We are happy to answer all questions on the tutorial! </div><p>Source: <a href="https://habr.com/ru/post/162747/">https://habr.com/ru/post/162747/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162737/index.html">Stellaris LaunchPad Short Review</a></li>
<li><a href="../162739/index.html">Analysis of statistics in free-to-play games: analytics tools</a></li>
<li><a href="../162741/index.html">We launch console Java applications on Android</a></li>
<li><a href="../162743/index.html">TVs. Part 1. Types of TVs, lights and technology, practical differences</a></li>
<li><a href="../162745/index.html">What is taught in the first semester of the master program of Erasmus Mundus IMSE</a></li>
<li><a href="../162749/index.html">Forcibly Implement Helpdesk: The Evil Corporation Experience</a></li>
<li><a href="../162755/index.html">The future of mobile platforms: Fresh Business Insider Report (86 slides)</a></li>
<li><a href="../162757/index.html">THQ and nVidia give out Metro 2033 for free</a></li>
<li><a href="../162759/index.html">Moving from Google Maps to Yandex MapKit</a></li>
<li><a href="../162763/index.html">Feedback on the book "Durov Code" N. Kononov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>