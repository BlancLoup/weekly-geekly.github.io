<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Moki and explicit contracts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably everyone who started writing unit and integration tests, faced with the problem of mock abuse, which leads to fragile tests. The latter, in t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Moki and explicit contracts</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Probably everyone who started writing unit and integration tests, faced with the problem of mock abuse, which leads to fragile tests.</em>  <em>The latter, in turn, create for the programmer the wrong belief that tests only interfere with the work.</em> </p><br><p>  <em>Below is a free translation of an article in which Jos√© Valim - the creator of the Elixir language - expressed his opinion on the problem of using mocks, with which I fully agree.</em> </p><br><hr><br><p>  A few days ago I shared my thoughts about mocks on Twitter: </p><br><p><img src="https://habrastorage.org/web/8df/b4b/0fc/8dfb4b0fc20947959128521d237aac66.png"></p><br><p>  Mock is a useful tool for testing, but existing test libraries and frameworks often lead to abuse of this tool.  Below we look at the best way to use mocks. </p><a name="habracut"></a><br><h2 id="chto-takoe-mok">  What is mock? </h2><br><p>  We use the definition from the <a href="https://en.wikipedia.org/wiki/Mock_object">English-language Wikipedia</a> : Mock - customizable object that simulates the behavior of a real object.  I will focus on this later, but for me, mock is always a noun, and not a verb [ <em>for clarity, the verb mock will be translated everywhere as ‚Äúlock‚Äù - approx.</em>  <em>trans.</em>  ]. </p><br><h2 id="na-primere-vneshnego-api">  On the example of the external API </h2><br><p>  Let's look at a standard real-life example: an external API. </p><br><p>  Imagine that you want to use the Twitter API in a web application on a Phoenix or Rails framework.  The application receives a request, which is redirected to the controller, which, in turn, makes a request to the external API.  The external API is called directly in the controller: </p><br><pre><code class="hljs sql">defmodule MyApp.MyController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> <span class="hljs-keyword"><span class="hljs-keyword">show</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">conn</span></span>, %{<span class="hljs-string"><span class="hljs-string">"username"</span></span> =&gt; username}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... MyApp.TwitterClient.get_username(username) # ... end end</span></span></code> </pre> <br><p>  The standard approach when testing such a code is to lock (it is dangerous! To lock in this case is a verb!) <code>HTTPClient</code> , which <code>MyApp.TwitterClien</code> uses: </p><br><pre> <code class="hljs lisp">mock(<span class="hljs-name"><span class="hljs-name">HTTPClient</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:get</span></span>, to_return: %{..., <span class="hljs-string"><span class="hljs-string">"username"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"josevalim"</span></span>, ...})</code> </pre> <br><p>  Next, you use the same approach in other parts of the application and you are trying to pass unit and integration tests.  Time to move on? </p><br><p>  Not so fast.  The main problem with HTTPClient is to create a strong external dependency <em>.</em>  <em>coupling everywhere translated as "dependency" - approx.</em>  <em>trans.</em>  ] to a specific <code>HTTPClient</code> .  For example, if you decide to use a new, faster HTTP client <em>without changing the behavior of the application</em> , most of your integration tests will fall, because they all depend on a particular HTTP <code>HTTPClient</code> .  In other words, changing the implementation without changing the behavior of the system still leads to a drop in the tests.  This is a bad sign. </p><br><p>  In addition, since the mock shown above modifies the module globally, you can no longer run these tests in parallel with Elixir. </p><br><h2 id="reshenie">  Decision </h2><br><p>  Instead of using <code>HTTPClient</code> , we can replace <code>MyApp.TwitterClient</code> with something else during the tests.  Let's see how the solution might look like on Elixir. </p><br><p>  In Elixir, all applications have configuration files and a mechanism for reading them.  We use this mechanism to configure the Twitter client for various environments.  The controller code will now look like this: </p><br><pre> <code class="hljs ruby">defmodule MyApp.MyController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @twitter_api Application.get_env(<span class="hljs-symbol"><span class="hljs-symbol">:my_app</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:twitter_api</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(conn, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">%{"username" =&gt; username}</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@twitter</span></span></span><span class="hljs-comment">_api.get_username(username) # ... end end</span></span></code> </pre> <br><p>  Appropriate settings for different environments: </p><br><pre> <code class="hljs lua"># <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>/dev.exs <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> :my_app, :twitter_api, MyApp.Twitter.Sandbox # <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>/test.exs <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> :my_app, :twitter_api, MyApp.Twitter.InMemory # <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>/prod.exs <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> :my_app, :twitter_api, MyApp.Twitter.HTTPClient</code> </pre> <br><p>  Now we can choose the best strategy for getting data from Twitter for each of the environments.  Sandbox can be useful if Twitter provides some kind of sandbox for development.  Our locked-in version of <code>HTTPClient</code> allowed <code>HTTPClient</code> to avoid real HTTP requests.  Implementing the same functionality in this case: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">defmodule</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">MyApp</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Twitter</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.InMemory</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">do</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">def</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">get_username</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">josevalim</span></span>") <span class="hljs-selector-tag"><span class="hljs-selector-tag">do</span></span> %<span class="hljs-selector-tag"><span class="hljs-selector-tag">MyApp</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Twitter</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.User</span></span>{ <span class="hljs-attribute"><span class="hljs-attribute">username</span></span>: <span class="hljs-string"><span class="hljs-string">"josevalim"</span></span> } <span class="hljs-selector-tag"><span class="hljs-selector-tag">end</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">end</span></span></code> </pre> <br><p>  The code is simple and clean, and there is no longer a strong external dependency on <code>HTTPClient</code> .  <code>MyApp.Twitter.InMemory</code> is <strong>mock</strong> , that is, a <strong>noun</strong> , and you do not need any libraries to create it! </p><br><h2 id="neobhodimost-yavnyh-kontraktov">  Need for explicit contracts </h2><br><p>  A mock is intended to replace a real object, which means it will be effective only when the behavior of a real object is clearly defined.  Otherwise, you may find yourself in a situation where the moke starts to get harder, increasing the dependency between the tested components.  Without an explicit contract, it will be difficult to notice. </p><br><p>  We already have three implementations of the Twitter API and it‚Äôs better to make their contracts explicit.  In Elixir, you can describe an explicit contract with the help of <a href="https://elixir-lang.org/getting-started/typespecs-and-behaviours.html">behavior</a> : </p><br><pre> <code class="hljs perl">defmodule MyApp.Twitter <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @doc <span class="hljs-string"><span class="hljs-string">"..."</span></span> @callback get_username(username :: String.t) :: %MyApp.Twitter.User{} @doc <span class="hljs-string"><span class="hljs-string">"..."</span></span> @callback followers_for(username :: String.t) :: [%MyApp.Twitter.User{}] end</code> </pre> <br><p>  Now add <code>@behaviour MyApp.Twitter</code> to each module that implements this contract, and Elixir will help you create the expected API. </p><br><p>  At Elixir, we rely on such behaviors all the time: when we use <a href="https://hexdocs.pm/plug/readme.html">Plug</a> , when we work with a database in <a href="https://hexdocs.pm/ecto/Ecto.html">Ecto</a> , when we test <a href="https://hexdocs.pm/phoenix/channels.html">Phoenix channels</a> and so on. </p><br><h2 id="testirovanie-granic">  Boundary testing </h2><br><p>  At first, when there were no explicit contracts, the boundaries of the application looked like this: </p><br><p> <code>[MyApp] -&gt; [HTTPClient] -&gt; [Twitter API]</code> </p> <br><p>  Therefore, a change in <code>HTTPClient</code> could lead to a drop in integration tests.  Now the application depends on the contract and only one implementation of this contract works with HTTP: </p><br><p> <code>[MyApp] -&gt; [MyApp.Twitter (contract)]</code> </p> <br><p> <code>[MyApp.Twitter.HTTP (contract impl)] -&gt; [HTTPClient] -&gt; [Twitter API]</code> </p> <br><p>  Tests of such an application are isolated from the <code>HTTPClient</code> and from the Twitter API.  But how do we test <code>MyApp.Twitter.HTTP</code> ? </p><br><p>  The difficulty of testing large systems lies in defining clear boundaries between components.  Too high level of isolation in the absence of integration tests will make tests fragile, and most of the problems will be detected only in production.  On the other hand, a low isolation level will increase the test passing time and make tests difficult to maintain.  There is no one right decision, and the level of isolation will vary depending on the team's confidence and other factors. </p><br><p>  Personally, I would test <code>MyApp.Twitter.HTTP</code> on the real Twitter API, running these tests as needed during development and every time a project is built.  The tagging system in <a href="https://hexdocs.pm/ex_unit/ExUnit.html">ExUnit</a> ‚Äî the library for testing in Elixir ‚Äî implements this behavior: </p><br><pre> <code class="hljs cs">defmodule MyApp.Twitter.HTTPTest <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use ExUnit.Case, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-meta"><span class="hljs-meta">#      Twitter API @moduletag :twitter_api # ... end</span></span></code> </pre> <br><p>  Exclude tests with Twitter API: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ExUnit</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.configure</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">exclude</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[:twitter_api]</span></span></code> </pre> <br><p>  If necessary, include them in the general test run: </p><br><p> <code>mix test --include twitter_api</code> </p> <br><p>  You can also run them separately: </p><br><p> <code>mix test --only twitter_api</code> </p> <br><p>  Although I prefer this approach, external restrictions, such as the maximum number of requests to the API, can make it useless.  In such a case, you may actually need to use the <code>HTTPClient</code> if its use does not violate the previously defined rules: </p><br><ol><li>  The change in <code>HTTPClient</code> only leads to a drop in the tests on <code>MyApp.Twitter.HTTP</code> </li><li>  You are not mocking (caution! In this case, the mock is a verb!) <code>HTTPClient</code> .  Instead, you pass it as a dependency through a configuration file, just as we did for the Twitter API </li><li>  You still need a way to test your client's work before rolling out to production. </li></ol><br><p>  Instead of creating a mock <code>HTTPClient</code> you can raise a dummy server that will emulate the Twitter API.  <a href="https://github.com/pspdfkit-labs/bypass">bypass</a> is one of the projects that can help with this.  All possible options you should discuss with your team. </p><br><h2 id="primechaniya">  Notes </h2><br><p>  I would like to finish this article by analyzing a few common problems that surface in almost every discussion of mocks. </p><br><h3 id="sozdanie-testiruemogo-koda">  Creation of "tested" code </h3><br><p>  Quote from <a href="https://groups.google.com/forum/">elixir-talk mailing list</a> : </p><br><blockquote>  It turns out that the proposed solution makes the production code more "testable", but creates the need to go into the configuration of the application for each function call?  Having an unnecessary overhead to make something ‚Äútestable‚Äù doesn't seem like a good solution. </blockquote><p>  I would say that this is not about creating a "testable" code, but about improving the design [ <em>from English.</em>  <em>design of your code - approx.</em>  <em>trans.</em>  ]. </p><br><p>  A test is a user of your API, like any other code you write.  One of the ideas of TDD is that tests are code and are no different from code.  If you say: ‚ÄúI don‚Äôt want to make my code testable,‚Äù it means ‚ÄúI don‚Äôt want to reduce the dependency between components‚Äù or ‚ÄúI don‚Äôt want to think about the contract (interface) of these components.‚Äù </p><br><p>  There is nothing wrong with not wanting to reduce the dependency between components.  For example, if we are talking about the module of work with URI [ <em>meaning the <a href="https://hexdocs.pm/elixir/URI.html">URI module</a> for Elixir - approx.</em>  <em>trans.</em>  ].  But if we are talking about something as complicated as the external API, defining an explicit contract and having the ability to replace the implementation of this contract will make your code comfortable and easy to maintain. </p><br><p>  In addition, the overhead is minimal, since the configuration of the Elixir application is stored in the <a href="http://erlang.org/doc/man/ets.html">ETS</a> , which means it is read directly from the memory. </p><br><h3 id="lokalnye-moki">  Local moki </h3><br><p>  Although we used application configuration to solve an external API problem, it is sometimes easier to pass the dependency as an argument.  For example, some function performs many calculations that you want to isolate in tests: </p><br><pre> <code class="hljs sql">defmodule MyModule <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">def</span></span> my_function <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... SomeDependency.heavy_work(arg1, arg2) # ... end end</span></span></code> </pre> <br><p>  You can get rid of the dependency by passing it as an argument.  In this case, passing an anonymous function will suffice: </p><br><pre> <code class="hljs ruby">defmodule MyModule <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(heavy_work \\ &amp;SomeDependency.heavy_work/</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... heavy_work.(arg1, arg2) # ... end end</span></span></code> </pre> <br><p>  The test will look like this: </p><br><pre> <code class="hljs rust">test <span class="hljs-string"><span class="hljs-string">"my function performs heavy work"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> #         heavy_work = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span></span>(_, _) -&gt; send(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>(), :heavy_work) end MyModule.my_function(heavy_work) assert_received :heavy_work end</code> </pre> <br><p>  Or, as described earlier, you can define a contract and transfer the entire module: </p><br><pre> <code class="hljs ruby">defmodule MyModule <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dependency \\ SomeDependency)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment"># ... dependency.heavy_work(arg1, arg2) # ... end end</span></span></code> </pre> <br><p>  Change the test: </p><br><pre> <code class="hljs pgsql">test "my function performs heavy work" <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> #         defmodule TestDependency <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> def heavy_work(_arg1, _arg2) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> send self(), :heavy_work <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> MyModule.my_function(TestDependency) assert_received :heavy_work <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  You can also represent a dependency in the form of a data structure and define a contract using <a href="http://elixir-lang.org/getting-started/protocols.html">protocol</a> . </p><br><p>  Passing the dependency as an argument is much simpler, so if possible, this method should be preferable to using the configuration file and <code>Application.get_env/3</code> . </p><br><h3 id="mok----eto-suschestvitelnoe">  Mok is a noun </h3><br><p>  It is better to think of mocks as nouns.  Instead of mopping the API (moka is a verb), you need to create mok (mok is a noun) that implements the necessary API. </p><br><p>  Most of the problems of using mocks arise when they are used as verbs.  If you wash something, you change already existing objects, and often these changes are global.  For example, when we mock the module <code>SomeDependency</code> , it will change globally: </p><br><pre> <code class="hljs lisp">mock(<span class="hljs-name"><span class="hljs-name">SomeDependency</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:heavy_work</span></span>, to_return: true)</code> </pre> <br><p>  When using mock as a noun, you need to create something new, and, naturally, this cannot be an already existing module <code>SomeDependency</code> .  The rule "mok is a noun, not a verb" helps to find "bad" mocks.  But your experience may be different from mine. </p><br><h3 id="biblioteki-dlya-sozdaniya-mokov">  Libraries to create mocks </h3><br><p>  After reading you may have the question: "Do I need to abandon libraries to create mocks?" </p><br><p>  It all depends on the situation.  If the library pushes you to substitute global objects (or use mocks as verbs), change static methods in object-oriented, or replace modules in functional programming, that is, violate the rules described above, you should refuse it. </p><br><p>  However, there are libraries for creating mocks that do not encourage you to use the anti-patterns described above.  Such libraries provide "mock objects" or "mock modules", which are passed to the system under test as an argument and collect information about the number of mock calls and about which arguments it was called with. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  One of the tasks of testing the system is finding the right contracts and boundaries between components.  Using mocks only if you have an explicit contract will allow you to: </p><br><ol><li>  To protect against the dominance of mocks, since contracts will be created only for the necessary parts of the system.  As mentioned above, you are unlikely to want to hide the interaction with standard <code>URI</code> and <code>Enum</code> modules behind the contract. </li><li>  Simplify component support.  When adding new functionality to a dependency, you need to renew the contract (add a new <code>@callback</code> to Elixir).  The endless growth of <code>@callback</code> will indicate a dependency that takes on too much responsibility, and you can deal with the problem earlier. </li><li>  Make your system suitable for testing, because the interaction between complex components will be isolated. </li></ol><br><p>  Explicit contracts let you see the complexity of dependencies in your application.  Difficulty is present in every application, so always try to make it as obvious as possible. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338066/">https://habr.com/ru/post/338066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338052/index.html">Magento updates, Protection against harmful administrators, data leaks, code execution</a></li>
<li><a href="../338054/index.html">Nobody needs your software. Or why software development requires a fresh approach.</a></li>
<li><a href="../338056/index.html">Streaming service Roku is going to IPO: what can go wrong</a></li>
<li><a href="../338060/index.html">Cut XML by XQuery Markup</a></li>
<li><a href="../338064/index.html">The principle of sole responsibility: the foundation of decomposition</a></li>
<li><a href="../338068/index.html">Angular vs. React vs. Vue: Comparison 2017</a></li>
<li><a href="../338070/index.html">ASO in iOS 11: a pivot table of changes</a></li>
<li><a href="../338072/index.html">Padding Oracle Attack: cryptography still scares</a></li>
<li><a href="../338074/index.html">Classic 2D quest or how our two years of development went. Part 1</a></li>
<li><a href="../338078/index.html">In the footsteps of cyberdetective</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>