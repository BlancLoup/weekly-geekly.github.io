<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagger 2. Part One. Basics, creating a dependency graph, Scopes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Recently, many tools, libraries, have appeared that make it much easier to write code for Android. Just manage to follow everything and try eve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagger 2. Part One. Basics, creating a dependency graph, Scopes</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello!  Recently, many tools, libraries, have appeared that make it much easier to write code for Android.  Just manage to follow everything and try everything.  One such tool is the Dagger 2 library. </p><br><p>  The network has a lot of different material on this library.  But when I was just starting to get familiar with Dagger 2, read articles, watched reports, I found one common flaw in all of this - I, as a person who did not work with Spring and other similar frameworks / libraries, found it rather difficult to understand where the dependencies come from how they are "provided" and what's going on there.  A large amount of code with new annotations usually falls out on listeners / readers.  And it somehow worked.  As a result, after the report / article in my head, everything could not be formed into a single clear picture. </p><br><p>  Now, looking back, I understand that I really lacked a schematic display, pictures, clearly showing "what, where and where."  Therefore, in my series of articles I will try to fill this gap.  I hope this will help beginners and all interested to better understand Dagger 2 and decide to try it in your project.  I can immediately say it is worth it. </p><br><p>  And yes, initially I wanted to write one article, but there was a lot of material and pictures, so I‚Äôll post the information in small portions so that the reader can gradually dive into the topic. </p><a name="habracut"></a><br><h2>  Theory </h2><br><p>  Let's quickly run through the theoretical aspects. <br>  Dagger 2 is a library that helps a developer implement the Dependency Injection (Dependency Injection) pattern, which in turn is a ‚Äúspecific form of inversion of control (Inversion of control)‚Äù. </p><br><h4>  Principles of inversion control </h4><br><ol><li>  The modules of the upper levels should not depend on the modules of the lower levels.  Modules of both levels should depend on abstractions. </li><li>  Abstractions should not depend on the details.  Details must depend on abstractions. </li></ol><br><h4>  Disadvantages of design that are eliminated with the use of Inversion Control </h4><br><ol><li>  Rigidity.  Changing one module leads to changing other modules. </li><li>  Fragility.  Changes in one part lead to uncontrollable errors in other parts of the program. </li><li>  Immobility.  The module is difficult to separate from the rest of the application for reuse. </li></ol><br><h4>  Dependency Injection (DI) </h4><br><p>  The process of providing external dependency software component.  It is a specific form of ‚Äúinversion of control‚Äù (English Inversion of control, IoC), when it is applied to dependency management.  In full accordance with the principle of a single duty, the object gives care to build the dependencies required by it to an external, specially designed general mechanism for this. <br>  So, Dagger 2 just takes care of creating this common mechanism. </p><br><p>  Anticipating the questions and holivars on IoC, DI, how they relate to each other, I will add that the definitions were taken from Wikipedia, and a detailed discussion is beyond the scope of the article. </p><br><p>  Now we list the main advantages of the library. </p><br><h4>  Advantages of Dagger 2 </h4><br><ol><li>  Easy access to ‚Äúshared‚Äù implementations. </li><li>  Simple setup of complex dependencies.  The more application you have, the more dependencies become.  Dagger 2 allows you to still control all dependencies easily. </li><li>  Facilitate Unit testing and integration testing.  This issue will be discussed in an article dedicated to testing with Dagger 2. </li><li>  ‚ÄúLocal‚Äù singletons. </li><li>  Code Generation  The resulting code is clear and accessible for debugging. </li><li>  No problems with obfuscation.  Both the fifth and sixth points are the distinguishing features of the second version of the Dagger.  Dagger 1 worked on reflection.  From here problems with productivity, obfuskatsiya, mysterious falling in rantayme. </li><li>  Small library size </li></ol><br><p>  For an example of simple access to ‚Äúshared‚Äù implementations, here is the code: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> RxUtilsAbs rxUtilsAbs; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> NetworkUtils networkUtils; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_main); App.getComponent().inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  That is, <code>@Inject</code> annotations are added to the fields and <code>App.getComponent().inject(this);</code> added to the <code>onCreate</code> method <code>App.getComponent().inject(this);</code>  .  And now the <code>MainActivity</code> class <code>MainActivity</code> ready-made <code>RxUtilsAbs</code> and <code>NetworkUtils</code> . </p><br><p>  All these advantages listed above make Dagger 2 the best library for implementing DI on Android at the moment. <br>  Of course, the library has drawbacks.  But we will talk about them at the end of a series of articles.  Now my task is to interest you and push Dagger 2 to try. </p><br><h4>  The main elements (annotations) of Dagger 2: </h4><br><ol><li>  <code>@Inject</code> - the base annotation with which the ‚Äúdependency is requested‚Äù </li><li>  <code>@Module</code> - classes whose methods ‚Äúprovide dependencies‚Äù </li><li>  <code>@Provide</code> methods inside <code>@Module</code> , ‚Äútelling Dagger how we want to design and provide dependency‚Äú </li><li>  <code>@Component</code> - the bridge between <code>@Inject</code> and <code>@Module</code> </li><li>  <code>@Scope</code> - provide the ability to create global and ‚Äúlocal singletons‚Äù </li><li>  <code>@Qualifier</code> - if you need different objects of the same type </li></ol><br><p>  For now, just review these annotations for general information.  We will discuss each of them in detail. <br>  Actually, according to the theory we limit ourselves to this.  More information can be found on the links at the end of the article. <br>  Our main goal is to understand how the entire dependency graph is constructed using Dagger 2. </p><br><h2>  Practice </h2><br><p>  Now more interesting things begin. <br>  Consider a specific example.  All applications have singletons.  Android without them is nowhere, considering the life cycles of activations and fragments. <br>  At the same time, I would divide the existing singletons into two categories: </p><br><ol><li>  "Global" singletons that may be needed in any part of the application.  These include Context, utility classes and other classes that affect the entire application. </li><li>  "Local" singletons, which are needed only in a specific one or several modules.  But because of possible reorientations of the screen and other things, it is often necessary to remove part of the logic and data to a place independent of the life cycle.  On the "local" singletons in more detail and schematically in the next article. </li></ol><br><p>  Let's start with the "global" singltonov.  How do we usually use them?  I dare to assume that in most cases the following code takes place: </p><br><pre> <code class="java hljs">SomeSingleton.getInstance().method();</code> </pre> <br><p>  Simple practice.  But if we want to apply the DI pattern, then this code will not be satisfactory for several reasons: </p><br><ol><li>  In a class where a similar call is used, there is suddenly a dependency on the <code>SomeSingleton</code> class.  This is an implicit dependency; it is not clearly indicated anywhere (neither in the constructor, nor in the fields, nor in the methods).  Therefore, one can only see such a dependency by looking at the code of a specific method, and after all, by the class interface, one cannot say that this <code>SomeSingleton</code> is <code>SomeSingleton</code> . </li><li>  The initialization process is handled by <code>SomeSingleton</code> itself.  And if lazy initialization is used, then the initialization process starts for one of the classes using <code>SomeSingleton</code> (where it will be called first).  That is, the classes, in addition to their work, are also responsible for the start of the initialization of Singleton. </li><li>  With the increase in the number of such Singletones, the system is covered by a network of implicit dependencies.  One more singletons may depend on others, which also does not simplify their further maintenance.  Plus, singletons are scattered around the system, can be in different packages, and this causes some inconvenience. </li></ol><br><p>  With this all, of course, you can live.  Not easy, but possible.  But everything starts to change radically when you want to impose your unit code on your code.  Here you have to do something with these implicit dependencies, somehow make their correct "substitution."  You start willy-nilly to convert your code into "tested code", and with implicit dependencies it is unreal. </p><br><p>  And now about Dagger 2 (in the course of the article I will sometimes call it simply in Russian - "Dagger").  Now we will see how using Dagger 2 you can implement DI singletones.  And at the same time we will see the whole cycle of creating a dependency graph. <br>  Let's start with the "global" singltonov. </p><br><h2>  Creating singletons </h2><br><p><img src="https://habrastorage.org/files/f68/bc1/8c1/f68bc18c1e814b3e921b284226384a96" alt="image"><br>  As we remember, <code>@Module</code> is an annotation marking a class whose methods "provide dependencies" ("provide dependencies").  In the following, we will call such classes simply Modules.  And the methods that "provide dependencies" or "provide dependencies" will be called provide-methods. <br>  For example, in <code>ReceiversModule</code> there is the method <code>provideNetworkChannel</code> , which just provides an object of type <code>NetworkChannel</code> .  This method can actually be called whatever you like, the most important is the <code>@Provides</code> annotation before the method and the return type ( <code>NetworkChannel</code> ). <br>  It is common practice when the return type is an interface or an abstract class ( <code>RxUtilsAbs</code> ), and inside the method we already initialize and return the desired implementation ( <code>RxUtils</code> ). <br>  About the <code>@Singleton</code> annotation below, until we pay attention to it. <br>  Also in the module, in the constructor, you can transfer the necessary objects.  Example - <code>AppModule</code> . <br>  And with <code>UtilsModule</code> already more interesting.  To provide its dependencies - <code>RxUtilsAbs</code> and <code>NetworkUtils</code> it needs objects of the types <code>Context</code> and <code>NetworkChannel</code> .  So we have to somehow tell Dagger that when creating <code>RxUtilsAbs</code> and <code>NetworkUtils</code> , <code>Context</code> and <code>NetworkChannel</code> .  To do this, the <code>provideRxUtils</code> <code>provideNetworkUtils</code> are added to the <code>provideRxUtils</code> and <code>provideNetworkUtils</code> methods: <code>Context context</code> for the first and <code>Context context, NetworkChannel networkChannel</code> for the second. <br>  In this case, the name of the arguments can be any, even the <code>context</code> , although the <code>contextSuper</code> , without a difference.  The main thing is the types of arguments. </p><br><p><img src="https://habrastorage.org/files/2d8/104/e71/2d8104e71145460daa5a9f53487c0967" alt="image"><br>  Next, create an <code>AppComponent</code> interface with annotation <br>  <code>@Component(modules = {AppModule.class, UtilsModule.class, ReceiversModule.class})</code> . <br>  For convenience, we will call this interface a Component. <br>  As mentioned above, <code>@Component</code> is essentially a bridge between <code>@Module</code> and <code>@Inject</code> .  Or in other words, the Component is a ready-made dependency graph.  What does this mean?  Let's understand a little lower. <br>  With this annotation we tell Dagger that <code>AppComponent</code> contains three modules - <code>AppModule, UtilsModule, ReceiversModule</code> .  The dependencies that each of these modules provides are available to all other modules combined under the auspices of the <code>AppComponent</code> component.  For greater clarity, take a look at the picture. </p><br><p><img src="https://habrastorage.org/files/37d/c8e/d26/37dc8ed26b2c495c98aa68032602f870" alt="image"></p><br><p>  I think using this picture will make it much clearer where Dagger takes <code>Context</code> and <code>NetworkChannel</code> to build <code>RxUtilsAbs</code> and <code>NetworkUtils</code> .  If you remove the <code>AppModule</code> module from the component annotation, for example, when compiling, Dagger will scream and ask where he will get the <code>Context</code> object from. <br>  Also inside the interface we declare the <code>void inject(MainActivity mainActivity)</code> method <code>void inject(MainActivity mainActivity)</code> .  With this method, we tell Dagger what class / classes we want to inject. <br>  I‚Äôll add that if you need to inject dependencies into another class other than <code>MainActivity</code> (for example, in <code>SecondActivity</code> ), then this should be clearly spelled out in the interface.  For example, </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = {AppModule.class, UtilsModule.class, ReceiversModule.class}) <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MainActivity mainActivity)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SecondActivity secondActivity)</span></span></span></span>; }</code> </pre> <br><p>  The name of the arguments can be any ( <code>mainActivity</code> can be changed to <code>activity</code> , etc.).  The most important type of object where we are going to inject!  And it is impossible to use for all classes into which we "push dependences" any generalization of the type: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = {AppModule.class, UtilsModule.class, ReceiversModule.class}) <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object object)</span></span></span></span>; }</code> </pre> <br><p>  Because Dagger 2 works on code generation, not reflection!  Types should always be clearly indicated! </p><br><p><img src="https://habrastorage.org/files/68b/c2e/67e/68bc2e67e1bd40c0bd963cc75b87d421" alt="image"></p><br><p>  We go further.  Remember, we in the <code>AppComponent</code> injection target set the class <code>MainActivity</code> .  In this class, we can use those dependencies that provide the modules <code>AppModule, UtilsModule, ReceiversModule</code> .  To do this, simply add the appropriate fields to the class and annotate them with <code>@Inject</code> annotation, and also make their accessibility at least batch (if the field is set as <code>private</code> , Dagger will not be able to substitute the desired implementation into this field). <br>  Also note that in the <code>RxUtilsAbs rxUtilsAbs</code> field, the <code>RxUtilsAbs rxUtilsAbs</code> class is <code>RxUtils</code> ( <code>RxUtils</code> is the successor of <code>RxUtilsAbs</code> ), that is, what we specified in the <code>UtilsModule</code> module. <br>  Next in the <code>onCreate</code> method <code>onCreate</code> we add the line <br> <code>App.getComponent().inject(this);</code> <br>  Since we are considering creating singletons, the component of our <code>AppComponent</code> best stored in the <code>Application</code> class.  In our example, you can access <code>AppComponent</code> through <code>App.getComponent()</code> . <br>  By calling the <code>inject(MainActivity mainActivity)</code> method <code>inject(MainActivity mainActivity)</code> , we finally connect our dependency graph.  Thus, all the dependencies that AppComponent modules <code>AppComponent</code> ( <code>Context</code> , <code>NetworkChannel</code> , <code>RxUtilsAbs</code> , <code>NetworkUtils</code> ) become available in <code>MainActivity</code> . <br>  Note the <code>buildComponent()</code> method of the <code>App</code> class.  <code>DaggerAppComponent</code> is not available to us before compiling. <br>  Therefore, in the beginning, we do not pay attention to the IDE, which will say that the <code>DaggerAppComponent</code> class <code>DaggerAppComponent</code> not exist.  Well, another IDE will not prompt when building a builder.  So initializing <code>AppComponent</code> with the help of <code>DaggerAppComponent</code> will have to write "blindly" for the first time. <br>  By the way, the <code>buildComponent()</code> code can be shortened: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> AppComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buildComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DaggerAppComponent.builder() .appModule(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppModule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) .build(); }</code> </pre> <br><p>  Dagger 2, as we have said, is responsible for creating the entire dependency graph.  If something goes wrong, it will tell you when compiling.  No unexpected and incomprehensible crashes in runtime, as it was, for example, with Dagger 1. <br>  And now attention to the diagram below! </p><br><p><img src="https://habrastorage.org/files/7c6/3ba/710/7c63ba7106e147f8a52a98cf12fe057a" alt="image"></p><br><p>  Fuf, now you can exhale!  The most saturated part behind.  It seems to me that this scheme clearly demonstrates that: </p><br><ol><li>  The module will provide dependencies.  That is, in the modules we prescribe what objects we want to provide. </li><li>  The component is a dependency graph.  It combines modules and provides dependencies to classes that need it ( <code>MainActivity</code> ) </li></ol><br><p>  If something is not clear or not explicitly, write in the comments, correct and explain! </p><br><p>  And finally, consider the <code>@Singleton</code> annotation.  This is the scope annotation provided by Dagger.  If the <code>@Singleton</code> placed in front of the method that provides the dependency, then Dagger, when the Component is initialized, creates a single instance of the marked dependency, that is, the singleton.  And with each request for this dependency, this single instance will provide. <br>  Less words, more pictures! <br><img src="https://habrastorage.org/files/fc6/225/ead/fc6225ead5b94f0c8644617ecafec926" alt="image"><br>  Each dependency is provided with the <code>@Singleton</code> annotation.  This means that every time Dagger needs to use this dependency, he will <strong>only use one instance of it</strong> . <br><img src="https://habrastorage.org/files/3f8/24a/07b/3f824a07bd234c47af648fe3269b4b07" alt="image"></p><br><p>  Now for comparison, remove the <code>provideNetworkChannel</code> annotation from the <code>provideNetworkChannel</code> method (the dependency becomes "unscoped").  This means that when Dagger needs to use this dependency, he will <strong>create a new instance of it every time</strong> . <br><img src="https://habrastorage.org/files/2b7/ee8/9e5/2b7ee89e5edc4344900888d8617a3065" alt="image"><br><img src="https://habrastorage.org/files/cef/d11/a66/cefd11a6666747baacbed637e03026de" alt="image"></p><br><p>  We can also create custom Scope annotations (more details in the next article). <br>  Here are some features of Scope annotations: </p><br><ol><li>  Usually scope-annotations are set for the Component and the provide-method. </li><li>  If at least one provide-method has a scope-annotation, then the Component must have <strong>exactly the same scope-annotation</strong> . </li><li>  A component can be "unscoped" only if in all its modules all provide-methods are also "unscoped". </li><li>  All scope annotations within one component (that is, for all modules with the provide-methods included in the Component and the Component itself) <strong>should be the same</strong> . </li></ol><br><p>  The topic with Scope annotations will be covered in more detail in the next article.  And for starters, that's enough for us :) <br>  So, in this article we got acquainted with the theoretical aspects of IoC, DI, Dagger 2. We considered in detail the creation of a dependency graph using Dagger 2, partially we got acquainted with the scope annotations and its specific implementation of <code>@Singleton</code> . </p><br><p>  Here is a list of articles that I recommend reading: </p><br><ol><li>  <a href="http://google.github.io/dagger/">Official library page</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DoK_XtfXPkqw">Google Presentation</a> </li><li>  <a href="http://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/">Article Fernando Cejas</a> </li><li>  <a href="http://frogermcs.github.io/dependency-injection-with-dagger-2-the-api/">Article from Miroslaw Stanek</a> </li><li>  <a href="http://antonioleiva.com/dependency-injection-android-dagger-part-1/">The first part of a series of articles from Antonio Leiva</a> </li><li>  <a href="https://github.com/codepath/android_guides/wiki/Dependency-Injection-with-Dagger-2">Good article with shemki</a> </li></ol><br><p>  <a href="https://habrahabr.ru/post/279641/">The second article about custom scopes, component dependencies and subcomponents is</a> already waiting for you! <br>  Waiting for comments, feedback and questions! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/279125/">https://habr.com/ru/post/279125/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279109/index.html">KTV. Rake on the way to marshaling</a></li>
<li><a href="../279111/index.html">C ++ exception handling under the hood or how exceptions work in C ++</a></li>
<li><a href="../279113/index.html">Observation of internationalized domain names and the letter K</a></li>
<li><a href="../279117/index.html">Linear models: simple regression</a></li>
<li><a href="../279123/index.html">Superscalar stack processor: we continue to cross the grass and the hedgehog</a></li>
<li><a href="../279127/index.html">Nutanix Big Update: NutanixOS 4.6</a></li>
<li><a href="../279129/index.html">On the issue of errors</a></li>
<li><a href="../279133/index.html">The digest of interesting materials for the mobile developer # 144 (on March 9-13)</a></li>
<li><a href="../279139/index.html">We invite everyone to the first hackathon in the history of the Stavropol Territory</a></li>
<li><a href="../279143/index.html">A brief course of computer graphics: setting normal maps in a tangent space</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>