<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qt and mobile camera. Part 2, Meego</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habravchane! 

 In the last article, I talked about how to create a convenient Qt-viewfinder for a camera on Symbian devices. Now it's time to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qt and mobile camera. Part 2, Meego</h1><div class="post__text post__text-html js-mediator-article">  Hello, Habravchane! <br><br>  In the <a href="http://habrahabr.ru/blogs/mobiledev/128394/">last article,</a> I talked about how to create a convenient Qt-viewfinder for a camera on Symbian devices.  Now it's time to make our code more universal and add compatibility with Meego 1.2, which, as it turned out, is not a trivial task. <br><br>  In short, I remind you that we got in the last part: <br><ul><li>  The class allows you to receive and process each frame of the video stream separately </li><li>  Viewfinder widget that is redrawn on each new frame, which allows you to do whatever you want with the incoming image </li></ul>  Now, why we can not just take and add this widget to the application for Nokia N9 (N900, N950).  It's all in the format of the image returned by the camera - UYVY.  When launching our viewfinder, all we get is a message to the debug log about the wrong format.  What is UYVY I do not know, but, fortunately, not without the help of foreign users of Maemo / Meego, I managed to find a solution to this problem.  Further I will give only excerpts of the code from the first article with new modifications. <br><a name="habracut"></a><br>  The solution is to convert UYVY into a more familiar and, most importantly, clear for Qt format RGB.  Oddly enough, the code that we will use in the future is included in QtMobility and can be found in the source code (link in the basement of the article).  The action plan for the implementation of the UYVY-&gt; RGB16 converter is as follows: <br><ol><li>  We add imaginary support UYVY to our viewfinder to get access to the image, not to read the logs for nothing </li><li>  Implementing the conversion function in the frame handler class </li><li>  We modify the QAbstractVideoSurface :: present () method with the addition of our new function </li></ol>  First we need to tell the system that UYVY is a valid format.  To do this, add the QVideoFrame :: Format_UYVY value to the list of formats returned by the QAbstractVideoSurface :: supportedPixelFormats () method: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      &gt;&gt; myvideosurface.cpp <br><pre><code class="cpp hljs">QList&lt;QVideoFrame::PixelFormat&gt; myVideoSurface::supportedPixelFormats( QAbstractVideoBuffer::HandleType handleType) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handleType == QAbstractVideoBuffer::NoHandle) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QList&lt;QVideoFrame::PixelFormat&gt;() &lt;&lt; QVideoFrame::Format_RGB32 &lt;&lt; QVideoFrame::Format_ARGB32 &lt;&lt; QVideoFrame::Format_ARGB32_Premultiplied &lt;&lt; QVideoFrame::Format_RGB565 &lt;&lt; QVideoFrame::Format_RGB555 &lt;&lt; QVideoFrame::Format_UYVY; <span class="hljs-comment"><span class="hljs-comment">//  } else { return QList&lt;QVideoFrame::PixelFormat&gt;(); } }</span></span></code> </pre> <br>  Further, the most important part, because of which the whole article appeared - UYVY-&gt; RGB16 conversion.  To do this, use the progressive conversion function optimized for the ARM \ Neon graphics processor.  As I wrote above, you can find it in the QtMobility source code (\ src \ multimedia \ qgraphicsvideoitem_maemo5.cpp).  However, people have problems with transferring this function to their cozy code (I confess, I only managed to do it the second time), so I‚Äôll give the code completely.  It is not necessary to delve into the meaning of this ASM snippet (within the framework of the problem being solved).  I myself have no idea what is going on in it (not counting the lines with comments), so it is enough just to copy this piece to me.  You can add it to myvideosurface.cpp before implementing the methods of the class myVideoSurface. <br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; #ifdef __ARM_NEON__ /* * ARM NEON optimized implementation of UYVY -&gt; RGB16 convertor */ static void uyvy422_to_rgb16_line_neon (uint8_t * dst, const uint8_t * src, int n) { /* and this is the NEON code itself */ static __attribute__ ((aligned (16))) uint16_t acc_r[8] = { 22840, 22840, 22840, 22840, 22840, 22840, 22840, 22840, }; static __attribute__ ((aligned (16))) uint16_t acc_g[8] = { 17312, 17312, 17312, 17312, 17312, 17312, 17312, 17312, }; static __attribute__ ((aligned (16))) uint16_t acc_b[8] = { 28832, 28832, 28832, 28832, 28832, 28832, 28832, 28832, }; /* * Registers: * q0, q1 : d0, d1, d2, d3 - are used for initial loading of YUV data * q2 : d4, d5 - are used for storing converted RGB data * q3 : d6, d7 - are used for temporary storage * * q6 : d12, d13 - are used for converting to RGB16 * q7 : d14, d15 - are used for storing RGB16 data * q4-q5 - reserved * * q8, q9 : d16, d17, d18, d19 - are used for expanded Y data * q10 : d20, d21 * q11 : d22, d23 * q12 : d24, d25 * q13 : d26, d27 * q13, q14, q15 - various constants (#16, #149, #204, #50, #104, #154) */ asm volatile (".macro convert_macroblock size\n" /* load up to 16 source pixels in UYVY format */ ".if \\size == 16\n" "pld [%[src], #128]\n" "vld1.32 {d0, d1, d2, d3}, [%[src]]!\n" ".elseif \\size == 8\n" "vld1.32 {d0, d1}, [%[src]]!\n" ".elseif \\size == 4\n" "vld1.32 {d0}, [%[src]]!\n" ".elseif \\size == 2\n" "vld1.32 {d0[0]}, [%[src]]!\n" ".else\n" ".error \"unsupported macroblock size\"\n" ".endif\n" /* convert from 'packed' to 'planar' representation */ "vuzp.8 d0, d1\n" /* d1 - separated Y data (first 8 bytes) */ "vuzp.8 d2, d3\n" /* d3 - separated Y data (next 8 bytes) */ "vuzp.8 d0, d2\n" /* d0 - separated U data, d2 - separated V data */ /* split even and odd Y color components */ "vuzp.8 d1, d3\n" /* d1 - evenY, d3 - oddY */ /* clip upper and lower boundaries */ "vqadd.u8 q0, q0, q4\n" "vqadd.u8 q1, q1, q4\n" "vqsub.u8 q0, q0, q5\n" "vqsub.u8 q1, q1, q5\n" "vshr.u8 d4, d2, #1\n" /* d4 = V &gt;&gt; 1 */ "vmull.u8 q8, d1, d27\n" /* q8 = evenY * 149 */ "vmull.u8 q9, d3, d27\n" /* q9 = oddY * 149 */ "vld1.16 {d20, d21}, [%[acc_r], :128]\n" /* q10 - initialize accumulator for red */ "vsubw.u8 q10, q10, d4\n" /* red acc -= (V &gt;&gt; 1) */ "vmlsl.u8 q10, d2, d28\n" /* red acc -= V * 204 */ "vld1.16 {d22, d23}, [%[acc_g], :128]\n" /* q11 - initialize accumulator for green */ "vmlsl.u8 q11, d2, d30\n" /* green acc -= V * 104 */ "vmlsl.u8 q11, d0, d29\n" /* green acc -= U * 50 */ "vld1.16 {d24, d25}, [%[acc_b], :128]\n" /* q12 - initialize accumulator for blue */ "vmlsl.u8 q12, d0, d30\n" /* blue acc -= U * 104 */ "vmlsl.u8 q12, d0, d31\n" /* blue acc -= U * 154 */ "vhsub.s16 q3, q8, q10\n" /* calculate even red components */ "vhsub.s16 q10, q9, q10\n" /* calculate odd red components */ "vqshrun.s16 d0, q3, #6\n" /* right shift, narrow and saturate even red components */ "vqshrun.s16 d3, q10, #6\n" /* right shift, narrow and saturate odd red components */ "vhadd.s16 q3, q8, q11\n" /* calculate even green components */ "vhadd.s16 q11, q9, q11\n" /* calculate odd green components */ "vqshrun.s16 d1, q3, #6\n" /* right shift, narrow and saturate even green components */ "vqshrun.s16 d4, q11, #6\n" /* right shift, narrow and saturate odd green components */ "vhsub.s16 q3, q8, q12\n" /* calculate even blue components */ "vhsub.s16 q12, q9, q12\n" /* calculate odd blue components */ "vqshrun.s16 d2, q3, #6\n" /* right shift, narrow and saturate even blue components */ "vqshrun.s16 d5, q12, #6\n" /* right shift, narrow and saturate odd blue components */ "vzip.8 d0, d3\n" /* join even and odd red components */ "vzip.8 d1, d4\n" /* join even and odd green components */ "vzip.8 d2, d5\n" /* join even and odd blue components */ "vshll.u8 q7, d0, #8\n" //red "vshll.u8 q6, d1, #8\n" //greed "vsri.u16 q7, q6, #5\n" "vshll.u8 q6, d2, #8\n" //blue "vsri.u16 q7, q6, #11\n" //now there is rgb16 in q7 ".if \\size == 16\n" "vst1.16 {d14, d15}, [%[dst]]!\n" //"vst3.8 {d0, d1, d2}, [%[dst]]!\n" "vshll.u8 q7, d3, #8\n" //red "vshll.u8 q6, d4, #8\n" //greed "vsri.u16 q7, q6, #5\n" "vshll.u8 q6, d5, #8\n" //blue "vsri.u16 q7, q6, #11\n" //now there is rgb16 in q7 //"vst3.8 {d3, d4, d5}, [%[dst]]!\n" "vst1.16 {d14, d15}, [%[dst]]!\n" ".elseif \\size == 8\n" "vst1.16 {d14, d15}, [%[dst]]!\n" //"vst3.8 {d0, d1, d2}, [%[dst]]!\n" ".elseif \\size == 4\n" "vst1.8 {d14}, [%[dst]]!\n" ".elseif \\size == 2\n" "vst1.8 {d14[0]}, [%[dst]]!\n" "vst1.8 {d14[1]}, [%[dst]]!\n" ".else\n" ".error \"unsupported macroblock size\"\n" ".endif\n" ".endm\n" "vmov.u8 d8, #15\n" /* add this to U/V to saturate upper boundary */ "vmov.u8 d9, #20\n" /* add this to Y to saturate upper boundary */ "vmov.u8 d10, #31\n" /* sub this from U/V to saturate lower boundary */ "vmov.u8 d11, #36\n" /* sub this from Y to saturate lower boundary */ "vmov.u8 d26, #16\n" "vmov.u8 d27, #149\n" "vmov.u8 d28, #204\n" "vmov.u8 d29, #50\n" "vmov.u8 d30, #104\n" "vmov.u8 d31, #154\n" "subs %[n], %[n], #16\n" "blt 2f\n" "1:\n" "convert_macroblock 16\n" "subs %[n], %[n], #16\n" "bge 1b\n" "2:\n" "tst %[n], #8\n" "beq 3f\n" "convert_macroblock 8\n" "3:\n" "tst %[n], #4\n" "beq 4f\n" "convert_macroblock 4\n" "4:\n" "tst %[n], #2\n" "beq 5f\n" "convert_macroblock 2\n" "5:\n" ".purgem convert_macroblock\n":[src] "+&amp;r" (src),[dst] "+&amp;r" (dst), [n] "+&amp;r" (n) :[acc_r] "r" (&amp;acc_r[0]),[acc_g] "r" (&amp;acc_g[0]),[acc_b] "r" (&amp;acc_b[0]) :"cc", "memory", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "d10", "d11", "d12", "d13", "d14", "d15", "d16", "d17", "d18", "d19", "d20", "d21", "d22", "d23", "d24", "d25", "d26", "d27", "d28", "d29", "d30", "d31"); } #endif</span></span></span></span></code> </pre><br>  In this simple way, you can make a single UYVY line sixteen-bit RGB.  Now it remains to implement this conversion in our frame handler.  I have carried out all conversion in separate method myVideoSurface :: convertFrame ().  It looks like this: <br><br>  &gt;&gt; myvideosurface.cpp <br><pre> <code class="cpp hljs"> QPixmap myVideoSurface::convertFrame(QVideoFrame lastVideoFrame) { QPixmap lastFrame = QPixmap(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!lastVideoFrame.isValid()){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QPixmap(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastVideoFrame.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(QAbstractVideoBuffer::ReadOnly)) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __ARM_NEON__ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (lastVideoFrame.pixelFormat() == QVideoFrame::Format_UYVY) { QImage lastImage(lastVideoFrame.size(), QImage::Format_RGB16); const uchar *src = lastVideoFrame.bits(); uchar *dst = lastImage.bits(); const int srcLineStep = lastVideoFrame.bytesPerLine(); const int dstLineStep = lastImage.bytesPerLine(); const int h = lastVideoFrame.height(); const int w = lastVideoFrame.width(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** *   itself */</span></span></span><span class="hljs-meta"> for (int y=0; y&lt;h; y++) { uyvy422_to_rgb16_line_neon(dst, src, w); src += srcLineStep; dst += dstLineStep; } lastFrame = QPixmap::fromImage( lastImage.scaled(lastVideoFrame.size(), Qt::IgnoreAspectRatio, Qt::FastTransformation)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> { QImage::Format imgFormat = QVideoFrame::imageFormatFromPixelFormat(lastVideoFrame.pixelFormat()); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (imgFormat != QImage::Format_Invalid) { QImage lastImage(lastVideoFrame.bits(), lastVideoFrame.width(), lastVideoFrame.height(), lastVideoFrame.bytesPerLine(), imgFormat); lastFrame = QPixmap::fromImage( lastImage.scaled(lastVideoFrame.size(), Qt::IgnoreAspectRatio, Qt::FastTransformation)); } } lastVideoFrame.unmap(); return lastFrame; } }</span></span></code> </pre><br>  The final touch is to modify the myVideoSurface :: present () method with the following innovations: <br><br>  &gt;&gt; myvideosurface.cpp <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> myVideoSurface::present(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QVideoFrame &amp;frame){ m_frame = frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(surfaceFormat().pixelFormat() != m_frame.pixelFormat() || surfaceFormat().frameSize() != m_frame.size()) { stop(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { observer-&gt;newImage(convertFrame(frame)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre><br>  That's all, now the image in RGB16 will return to our callback, which you can work with exactly the same way as with RGB24 (this format is used in Symbian).  And since our education is optimized, it happens without losing the speed of the application.  In the end, the viewfinder widget can be used in the same way as in the version for Symbian. <br><br>  In general, this image processing principle is used in the same QtMobility, for which we implement it ourselves, the question is only in the platform (as can be seen from the sources, inside mobility this method is used in Maemo 5).  So it remains to hope that in the future such conversion will be implemented in the mobility code for Meego. <br><br>  <b>PS</b> By the way, at the time of writing this code, in Qt (4.7.2) there was still no support for saving RGB16 to JPEG (although it was indicated on the bug tracker that the bug was fixed).  Therefore, in the callback before this saving, we had to apply one more conversion step - RGB16-&gt; RGB888.  This is done in one line: <br><pre> <code class="cpp hljs">image = image.convertToFormat(QImage::Format_RGB888);</code> </pre>  Here image is a QImage object that came into the newImage () method.  This process also does not affect the speed, so it is quite applicable when displaying an image on the screen in real time. <br><br>  Successful conversion! <br><br>  References: <ul><li>  QtMobility iishodniki - <a href="http://qt.gitorious.org/qt-mobility">git</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/129294/">https://habr.com/ru/post/129294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129289/index.html">Android client for myshows.ru</a></li>
<li><a href="../129290/index.html">Managing migration scripts or MyBatis Scheme Migration Extended</a></li>
<li><a href="../129291/index.html">Google+ traffic grew by 1269% in one week</a></li>
<li><a href="../129292/index.html">A simple script to switch network settings</a></li>
<li><a href="../129293/index.html">On Github, a single ticket panel for all projects.</a></li>
<li><a href="../129295/index.html">ZTE T98 based on NVIDIA Tegra Kal-El is represented in China</a></li>
<li><a href="../129296/index.html">Let's Talk iPhone - October 4, 2011 21:00 MSK</a></li>
<li><a href="../129298/index.html">About replacing the standard / sbin / init</a></li>
<li><a href="../129299/index.html">SlideShare has abandoned Flash in favor of HTML5</a></li>
<li><a href="../129300/index.html">Mobile Application Developers Forum Mobile People 2011</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>