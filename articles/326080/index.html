<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Future API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think we are not talking enough about the future of the API. I don‚Äôt remember a single good discussion about what the API is waiting for in the futu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Future API</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/85a/1f9/5da/85a1f95dad3546db841439f9c9b3b70d.jpeg" alt="image"></p><br><p>  I think we are not talking enough about the future of the API.  I don‚Äôt remember a single good discussion about what the API is waiting for in the future.  I don‚Äôt remember at all.  But if we think about it well, then we will come to the conclusion that the API in the form in which we now understand is far from the end of the game.  In this kind of API will not stay forever.  Let's try to look into the future and answer the question of what will happen to the API in the future. </p><a name="habracut"></a><br><h1 id="turok">  Turk </h1><br><p>  Our story begins in 1770 in the Hungarian Kingdom, which at that time was part of the Hapsburg Empire.  Wolfgang von Kampelen develops a machine capable of playing chess.  The idea was to play with the strongest players of the time. </p><br><p>  Having completed the work on the machine, he impresses with her the yard of Maria Theresa of Austria.  Campelen and his <em>chess automaton are</em> quickly becoming popular, winning chess players in demonstration games throughout Europe.  Even such figures as Napoleon Bonaparte and Benjamin Franklin are among the eyewitnesses. </p><br><p>  The car, which looked like a man dressed in Turkish robes, was actually a mechanical illusion.  She was ruled by a living person sitting inside.  The Turk was just an elaborate stunt.  The myth, invented in order to make people think that they are competing with a real machine.  The secret was fully revealed only in the 1850th year. </p><br><p><img src="https://habrastorage.org/files/6ab/e72/4ad/6abe724ad7c947668ac09b79c9196064.png" alt="image"></p><br><p>  Since then, the term "Mechanical Turk" (Mechanical Turk) has been used for systems that look completely autonomous, but actually need a person to function. </p><br><h1 id="chuzhie">  Strangers </h1><br><p>  Fast forward to the year 1963, where American psychologist and scientist Joseph Liklider writes "Memorandum for Members and Allies of the Galactic Computer Network." </p><br><p>  Liquidlider is one of the most important figures in the history of computers.  It can be safely called a visionary.  He foresaw the emergence of graphical interfaces and was involved in the creation of ARPANET and the Internet. </p><br><p>  In the memorandum, Liklider asks: </p><br><blockquote>  "How will you begin communication between two wise beings who are not connected with each other?" </blockquote><p>  Imagine that there is a giant network connecting many galaxies and connecting intelligent beings that have never met before.  The question is: How will they communicate when they meet? </p><br><p>  Similar to the picture shown in the movie "Arrival" (2016), these creatures will have to explore each other, observe and record the reactions in order to first find a common lexicon.  And only then will they be able to use this vocabulary to have a meaningful dialogue. </p><br><h1 id="konec-epohi-turka">  The end of the Turk era </h1><br><p>  We are transferred for 33 years forward, in 1996.  Computer IBM Deep Blue wins the first game in a chess tournament with world champion Garry Kasparov.  At the end of the tournament, Kasparov won the match of six games, losing only the first game. </p><br><p>  IBM improves deep blue.  A year later, the computer wins a rematch of 3¬Ω ‚Äì 2¬Ω, thus becoming the first car to win the reigning world champion. </p><br><p>  227 years have passed between the original Turk of Kampelen and the real machine capable of defeating the best chess players of the planet. </p><br><h1 id="vtoroe-prishestvie-turkov">  The Second Coming of the Turks </h1><br><p>  Just 3 years after Deep Blue, in 2000, Roy Fielding publishes his thesis on Architectural Styles and Design of Software Network Architecture.  This work will later become known as the architectural style of the REST API.  It has become a template for the emergence of a whole generation of Web APIs using the HTTP protocol. </p><br><p>  In the same year, Salesforce releases the first version of its Web API to automate sales.  eBay joins a little later, and all other well-known Internet companies follow the trend. </p><br><p><img src="https://habrastorage.org/files/cb8/a8f/cd8/cb8a8fcd88d041a494d1ce5890d44c09.png" alt="image"></p><br><p>  But there is something strange about these web APIs.  They seem to be protocols for communicating a computer with a computer.  But in reality, this is not the case. </p><br><p><img src="https://habrastorage.org/files/e20/7a4/01f/e207a401f4f9416b819e5582ea3c923f.png" alt="image"></p><br><p>  In reality, one service publishes an interface;  then the person writes documentation to him and publishes it. </p><br><p>  Another person should find this documentation and read it.  Having obtained this knowledge, a person can program another machine to use this interface. </p><br><p><img src="https://habrastorage.org/files/010/556/f8d/010556f8d16f4cb2b93591fc2d536deb.png" alt="image"></p><br><p>  In fact, we have an intermediate layer in communicating a computer with a computer that includes us humans.  As a result, what is meant by all as pure communication of a computer with a computer, in fact turns out to be a new Mechanical Turk. </p><br><p><img src="https://habrastorage.org/files/a9d/13e/f90/a9d13ef9032f4ad7bc8a5c2d75ee9103.png" alt="image"></p><br><h1 id="zolotaya-era-turkov">  Golden Era of the Turks </h1><br><p>  As in the case of the World Wide Web, companies around the world soon realized the importance of being in this segment of the Internet.  The business levers launched the process, and we are witnessing the real boom of the Web API. </p><br><p><img src="https://habrastorage.org/files/8a1/657/bce/8a1657bce7c84677b7b6412eeae8812e.png" alt="image"></p><br><p>  But as the API expands and the economy grows around them, new problems emerge.  And, in most cases, these problems are directly related to the person hidden inside the API of the Turk. </p><br><h1 id="problema-s-api-turkom">  Problem with API Turk </h1><br><p>  Each mature API must deal with the following tasks: </p><br><ul><li>  synchronization </li><li>  versioning </li><li>  scaling </li><li>  detection </li></ul><br><h2 id="sinhronizaciya">  Synchronization </h2><br><p>  In the case of the Turk API, we create and distribute "Liklider dictionary" in advance.  Ie, we write and publish API documentation before the two machines meet.  And even if we forget that people may just misunderstand the documentation, we have an obvious problem when the API changes, but the documentation does not. </p><br><p>  Keeping the API documentation in sync with the implementation is not an easy task.  But supporting change in customers is even more difficult. </p><br><p><img src="https://habrastorage.org/files/4fb/159/dc9/4fb159dc9daa40fcb167e0a8c77bbc93.png" alt="image"></p><br><h2 id="versionirovanie">  Versioning </h2><br><p>  Problems with synchronization lead us straight to the issue of versioning.  Since most of the Turk APIs do not follow the REST principles described by Fielding, API clients are usually strongly associated with the interfaces used.  Such strong connectivity creates very fragile systems.  Changing the API can easily break the client.  Moreover, human intervention is necessary to update an existing client for a new change in the API.  But dependence on the person for such an action is expensive, slow, and, in most cases, inaccessible, since the client is already installed. </p><br><p><img src="https://habrastorage.org/files/166/aa4/295/166aa42950a04508baddfac7219987a1.png" alt="image"></p><br><p>  Because of these problems, we are afraid to make changes.  We do not develop our API.  Instead, we create new APIs on top of existing ones, polluting the code base.  We increase the cost, technical debt and have endless discussions on how to solve versioning problems. </p><br><h2 id="masshtabirovanie">  Scaling </h2><br><p>  Since there are people inside the API of the Turks, we have to hire more people to create more of the API of the Turks.  And to make more mistakes.  We are people - we make mistakes. </p><br><p>  No matter how many people we hire - if we are talking about reading or writing documentation or correcting code for new changes in the API - we are limited in speed.  Increasing the number of people somehow can help create more APIs, but it does not help at all to scale up the speed of response to changes. </p><br><p>  Moreover, we often work with vague wording, which creates a lot of space for mistakes and misinterpretations.  Where one person expects the title of the article, another will see the title. </p><br><blockquote>  What is it not the same thing? </blockquote><br><h2 id="obnaruzhenie">  Detection </h2><br><p>  And finally, there is still a problem with detectability.  How do we know that there is a service that we want to use?  Perhaps there is already a service that will give us the opportunity to build a breakthrough product, or simply save us valuable time. </p><br><p> API providers do not know where to offer themselves.  It does not matter that this service for geolocation is better than the Google Places API - we simply have no way to even find out about it. </p><br><p>  Word of mouth and Google is a so-called API detection solution.  And, as with any other person-driven solution, this solution does not scale. </p><br><h1 id="vozmozhnyy-vyhod">  Possible exit </h1><br><p>  In the past decade, we have developed processes and tools to solve these problems.  Together with the mass of the people, we have created a whole industry API.  An economy that creates and maintains new Mechanical Turks. </p><br><p>  The Workflow API, API Style Guide, API documentation best practices and other processes are running to maintain synchronization, prevent incompatible changes, and avoid human errors.  We are creating even more tools to prop up these processes and support our API products. </p><br><p>  We began to generate documentation and code automatically to achieve synchronization.  We develop complex testing frameworks and hire more developers to support all of this.  Now it‚Äôs quite common to have a whole team of developers on staff for documentation APIs only.  Let me say it differently: <em>We hire developers to create documentation for other developers so that they can understand the interface of one computer and program another computer to use it.</em> </p><br><p>  As one friend of mine says: </p><br><blockquote>  Programmers solve programming problems even more by programming. </blockquote><p>  If the API becomes popular, these providers become lucky enough to get money and spend it on marketing and various PR events.  The rest are looking for good luck in the API directories or in the hope of being seen on Hacker News. </p><br><h1 id="rol-cheloveka-v-obschenii-mezhdu-kompyuterami">  The role of man in communication between computers </h1><br><p>  So why do we need a person in the API Turk?  What is the role of man in communication between computers? </p><br><p>  People play a critical role in API detection and understanding.  When we find any service, first of all we try to understand WHAT exactly we can do with it and HOW to do it. </p><br><p><img src="https://habrastorage.org/files/a89/9fb/8bc/a899fb8bc88046059296d7ce706e5b50.png" alt="image"></p><br><p>  For example: </p><br><blockquote>  (API detection and WHAT): "Is there a service that will give me a weather forecast for Paris?" <br>  (HOW): "How can I use this service to get the weather forecast for Paris?" </blockquote><p>  When we get answers to these questions, we can write an API client.  The client will be able to work further without our participation, until the API (or our requirements) changes.  And, of course, we mean that the API documentation is always accurate and in sync with the implementation of the API. </p><br><h1 id="avtonomnye-api">  Standalone APIs </h1><br><p>  But if human participation in the process is expensive, slow and error-prone, how can we get away from it?  What will it cost to create a completely autonomous API? </p><br><p>  First, we must find a way to develop and publish a common vocabulary.  The next step is to start spreading the meaning of the meaning on the fly.  Then the API detection system will be able to register new APIs along with its meaning dictionary. </p><br><p>  The process of such an automated system without human intervention may look like this: </p><br><p>  A computer publishes its interface along with a profile that describes the interface and its semantic dictionary.  The service registers itself with an API detection system. </p><br><p>  Later, another program polls the API discovery service using terms from the dictionary.  If something is found, the API discovery service returns the found service to this program. </p><br><p>  The program (which is now an API client) is already trained to work with a new dictionary.  Now she can use the API for the actions she needs. </p><br><p>  The client is programmed in a declarative way to perform a specific task, but is not strictly tied to a specific service. </p><br><p>  For clarity, here is an example of a program that displays the temperature in Paris: </p><br><pre><code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Using</span></span> a terms <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>.org <span class="hljs-keyword"><span class="hljs-keyword">dictionary</span></span>, # find services that offers WeatherForecast. services = apiRegistry.find(WeatherForecast, { vocabulary: "http://schema.org"}) # Query a service <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> WeatherForecast at GeoCoordinates. forecast = service.retrieve(WeatherForecast, { GeoCoordinates: ‚Ä¶ }) # Display Temperature print forecast(Temperature)</code> </pre> <br><p>  This approach not only allows you to create clients that are resistant to API changes, but also allows you to reuse code for many other APIs. </p><br><p>  For example, you no longer need to create a weather forecast program for a particular service.  On the contrary, you are writing a universal client who knows how to display the weather forecast.  This application can use various services, such as AccuWeather, Weather Underground or any other country-specific weather forecasting service, if it supports (at least partially) the same glossary of meanings. </p><br><p><img src="https://habrastorage.org/files/897/371/5bf/8973715bff2e4a89b35108631ecb5edf.png" alt="image"></p><br><p>  In summary, the building blocks of the Autonomous APIs are: </p><br><ul><li>  register of dictionaries </li><li>  understanding of meaning on the fly </li><li>  API discovery service </li><li>  programming under the dictionary, but not under data structures </li></ul><br><h1 id="pribytie">  Arrival </h1><br><p>  So where are we with all this at the beginning of 2017?  The good news is that we have these building blocks, and they gradually begin to attract attention. </p><br><p>  We begin to learn to understand the meaning on the fly.  <a href="https://spring.io/understanding/HATEOAS">HATEOAS</a> use hypermedia formats for this.  Using the <a href="https://blog.codeship.com/json-ld-building-meaningful-data-apis/">JSON-LD</a> format is gaining momentum in the industry APIs, and search providers like Google, Microsoft, Yahoo, and Yandex maintain the <a href="https://schema.org/">Schema.org</a> dictionary. </p><br><p>  Formats like <a href="http://alps.io/">ALPS</a> give new life to semantic information for data.  At the same time, <a href="http://graphql.org/learn/schema/">GraphQL Schema</a> can be studied on the fly to find out what is available using the GraphQL API. </p><br><p>  And finally, there are special API directories, with <a href="https://www.hitchhq.com/">HitchHQ</a> and the <a href="http://rapidapi.com/">Rapid API</a> at the head. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  In my version of the future API, we will get rid of human participation in documenting, discovering and using the API.  We will begin to write our API clients in a declarative form and the information will be recognized on the fly. </p><br><p>  This approach will reward us with lower costs, fewer mistakes and less time to market.  With autonomous APIs, we can finally develop an API, re-use clients and scale the API indefinitely. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/326080/">https://habr.com/ru/post/326080/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326070/index.html">Cat Discrimination: Web Tracking Through Invisible Pictures</a></li>
<li><a href="../326072/index.html">Integration of 3CX with Bitrix24 - free CRM plugin</a></li>
<li><a href="../326074/index.html">Async / await: 6 reasons to forget about promises</a></li>
<li><a href="../326076/index.html">Mikrotik 6to4 automation with dynamic IPv4</a></li>
<li><a href="../326078/index.html">MASM, TASM, FASM, NASM for Windows and Linux</a></li>
<li><a href="../326082/index.html">Huawei HyperMetro - tested and implemented</a></li>
<li><a href="../326084/index.html">Audit of current vulnerabilities without registration and SMS</a></li>
<li><a href="../326086/index.html">Cisco CSR 1000v: Features Overview. Part 1</a></li>
<li><a href="../326088/index.html">Message based integration. Advantages and differences from other approaches</a></li>
<li><a href="../326090/index.html">Creating npm package of React components based on create-react-app</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>