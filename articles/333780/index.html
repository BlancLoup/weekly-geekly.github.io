<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The birth of Software Tools: how and why did GREP and AWK appear</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This summer, I came across an essay by Brian Kernighan, ‚ÄúSometimes the old ways are the best,‚Äù published in honor of the 25th anniversary of IEEE Soft...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The birth of Software Tools: how and why did GREP and AWK appear</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/729/9e2/8cc7299e283dd8a9d981c61984f7942c.png" alt="image"><br>  This summer, I came across an <a href="https://www.computer.org/documents/53319/47266692/SometimestheOldWaysareBest.pdf/1767d342-8501-4f7d-886e-6730d8ddb4bc">essay by Brian Kernighan, ‚ÄúSometimes the old ways are the best,‚Äù</a> published in honor of the 25th anniversary of IEEE Software magazine in 2008.  In it, Professor Kernighan talked about what tools he uses in his work. <br><br>  At that moment, he was busy with two complex projects - one of them meant expert analysis of a project for 100,000 lines of code, written in C and Assembler in 1990, under Windows XP;  the other is the transfer of code from an exotic L1 language to a no less exotic L2 language using a program written in an unnamed scripting language for Linux.  Surprisingly, for such different tasks, Professor Kernigan instead of IDE used the same set of tools - <i>grep, diff, sort, awk, wc</i> and other ‚Äúold acquaintances‚Äù from the early Unix era.  Moreover, he criticized many tools and IDE of the end of the last decade for inconvenience and imperfection. <br><br>  Indeed, we have become so accustomed to some things in our lives that we already take them for granted and it does not even occur to us to criticize them - it seems to us that they have always existed.  This way of thinking helps to adapt to the flow of information and is inevitable in the modern world, but let's not deny ourselves the pleasure of ‚Äúgoing down a level‚Äù today to see how the very idea of <i>software tools appeared</i> (they are further in the text - <i>‚Äúsoftware tools ", Utilities, Unix commands</i> ). <br><a name="habracut"></a><br><h2>  Those who </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/ec8/0bd/022/ec80bd0226bb577e480ff4ded2b08eab.jpg" alt="image" align="right">  Of course, it all began in the walls of the Bell Labs lab, owned by AT &amp; T - it was here that Unix, C, and ( <i>somewhat later</i> ) C ++ were born.  Since the appearance of Unix teams was inextricably linked with the creation of the OS itself, the main actors here are Ken Thompson, Brian Kernighan and Alfred Aho, who are well known to Habrahabr readers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Ken Thompson, having become the creator of Unix with Dennis Ritchie, will leave Bell Labs in 1975 and return to his alma mater, University of Berkeley, where he will contribute to the emergence of BSD;  he will later return to Bell Labs, where he will work on Plan 9 with Rob Pike and the others. <br><br>  Alfred Aho is known to domestic programmers for the famous <i>"Book of the Dragon"</i> (it is also <i>called "Compilers: principles, technologies and tools"</i> ), as well as for the textbook <i>"Data Structures and Algorithms"</i> .  Aho worked at Bell Labs from 1967 to 1991, after which he once again returned to the role of vice president of the Computer Science research center at the turn of the millennium. <br><br>  Brian Kernigan, co-author of the all-time <i>K &amp; R C Programming Language</i> (hiding under the letter ‚ÄúK‚Äù from K &amp; R), and co-author of a number of other great programming books published over the past thirty years - including the recent <i>Go Programming Language</i> . <br><br>  Kernigan began his career in 1966 at MIT, where he was indirectly related to the Multics project.  A year later, during graduate school at Princeton University, he became an employee of Bell Labs, and in 1969 - one of the first developers who took part in the work on Unix.  Kernighan was assigned user ID # 9, but his first notable contribution to Unix dates back to 1973 ‚Äî the creation of <i>eqn</i> , the <i>troff</i> preprocessor for the language for describing mathematical expressions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/312/14c/858/31214c858411df6ebb4146a91df5efa9.jpg" alt="image"><br>  <i>This is said to be the very first ‚ÄúHello World‚Äù in the world.</i>  <i>Posted by Brian Kernigan.</i>  <i><a href="https://twitter.com/cs50/status/718552250075848705">(a source)</a></i> <br><br>  For these and many other scientists who worked at Bell Labs in the late 60s - early 70s, Unix was much more than just another OS. <br><br><h2>  Software tools </h2><br>  Today, we take the idea of ‚Äã‚ÄãUnix commands and pipelines as a matter of course;  however, in reality this was not always the case. <br><br>  The very idea that tools should be used to increase the productivity of programmers ‚Äî analogous to what humanity used in other areas of its life ‚Äî is certainly not new.  One of the pioneers of computer science, Alan J. Perlis, predicted that the emergence of a large number of improvised tools could allow programmers to create much larger projects. <br><br>  The first real step in this direction was the invention of time-sharing systems, which made it possible to distribute computing resources among many users.  The second is the creation of Multics, an attempt to implement such a system.  The third is Unix, which grew up on the ruins of Multics. <br><br>  In the 70s, outside of Bell Labs and the Unix operating system, the idea of ‚Äã‚Äãcreating such tools was unknown.  But the authors of Unix were well aware of what they were dealing with - after all, for them, the key feature of Unix was flexibility;  if desired, from a simple OS Unix turned into a full IDE.  And, of course, this idea remains applicable today (see the <a href="https://habrahabr.ru/post/150930/">article ‚ÄúUnix as IDE‚Äù</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b1/f50/01b/0b1f5001b4d539cfd9fa091419d1cc4f.jpg" alt="image" align="left">  The flexibility in Unix made it possible to take a fresh look at programming itself.  ‚ÄúDo you need this feature?  We do not have it, but thanks to utilities # 1 and # 2, we can implement it right now, and tomorrow you will be able to use it. ‚Äù  In those years when ‚Äúflexible‚Äù software development methodologies were not used in practice, and the tasks could take months, such words cost a lot. <br><br>  Few people know that the pipe ( <i>pipe</i> ), one of the most important features of Unix, could become part of this OS in 1969.  Then an idea like this was considered by Ritchie and Thompson when designing the file system, but, alas, ‚Äúimagination let them down‚Äù, which Richie later lamented.  But Douglas McIlroy, head of Bell Labs Research, did not let him down, who invented and described this concept in man pages in Unix v3. <br><br>  After channels appeared for the first time in Unix on January 15, 1973, this not only ‚Äúdisables‚Äù all Bell Labs (‚ÄúThe day after we implemented <i>pipes</i> , everyone considered it his duty to try to write a one-line‚Äù - he will remember later McIlroy), but also gives the most powerful final impetus needed to implement the idea of ‚Äã‚Äãsoftware tools that could be combined. <br><br>  <i>Grep</i> will appear next, after which it will finally become clear - the future stands behind this idea.  It will be formulated in the famous <i>"UNIX Philosophy"</i> : <br><blockquote>  Let each program do just one thing, but it does it well.  If you need to perform a new function, it is better to make a new program than to confuse the old one with the addition of new features.  Use tools to make your task easier for yourself and others, even if for this you need to write new utility tools that you have to throw away. </blockquote><br><h2>  Grep </h2><br>  <i>grep</i> has long been Ken Thompson‚Äôs personal tool;  The first public version of <i>grep was</i> included in Unix v4 - and immediately became for everyone else a tool in demand in daily work. <br><br>  The name <i>grep</i> today is often decoded as <i>general regular expression parser</i> ;  However, according to <a href="http://www.catb.org/~esr/jargon/html/G/grep.html">Dennis Ritchie</a> and <a href="">Ken Thompson</a> , the utility name appeared differently: in the editors <i>qed / ed, g / re / p</i> was just an editor command that it performed - <i>global regular expression print</i> (global regular expression search and print strings, containing matches). <br><br>  Douglas McIlroy, author of <i>spell, diff, sort, join</i> and other commands, will later claim that <i>grep</i> was added at his request.  He was working on a speech synthesizer, and he needed Ken Thompson to ‚Äútake out‚Äù from the editor <i>ed</i> the search function of regulars in the text into a separate program.  Alas, it is unknown how true this is. <br><br>  In any case, <i>grep</i> became the starting point for all other <i>software tools</i> - after it, Bell Labs began to move in the direction of developing various tools that could be combined with each other.  However, not everything was in the utility directory;  among the developers, there was an agreement to refrain from any unnecessary "garbage".  Therefore, before the teams could get into public access, they most often took a long run-in in private mode. <br><br>  In addition, the authors of Unix did not fix the time of creation of a team anywhere, so we need to be guided by the dates specified in <i>man</i> - the moment when a team appeared in the reference manual. <br><br>  When Brian Kernighan and Bill Plager release the book <i>Software Tools</i> in 1975, she will introduce a wide audience to the idea of ‚Äã‚Äãsoftware tools.  Borrowing an idea from Unix, this book demonstrated how using a small set of text utilities you can make programmers much more productive.  An interesting fact: the programs in this book are written in the Fortran dialect - because at that time C was barely three years old, the authors made a bet on Fortran, hoping thereby to sell more copies. <br><br>  Despite the fact that the phrase ‚Äúsoftware tools‚Äù was not used before the release of the book within the walls of Bell Labs, it is difficult to say who owned the authorship of this concept.  The same Kernigan flatly refuses to recognize himself as the author of this idea;  he rather considers himself a popularizer of this approach, and it‚Äôs hard to argue with that - starting with <i>eqn</i> and the numerous Unix manuals written by him in the 70s, he has been promoting this idea to the masses. <br><br>  Two years later, Kernigan will be the author of another utility (or rather, the language), which still continues to serve programmers <i>awk,</i> faithfully. <br><br><h2>  Awk </h2><br>  AWK was born out of necessity.  No one ever thought that it would be used outside of a group of several programmers working at Bell Labs.  Alfred Aho, who then worked at Bell Labs, had to keep track of budgets, correspondence ‚Äî and the assessments of students at the university that was located nearby and in which he taught at that time. <br><br>  Of course, the best way to solve these problems would be to write programs of a length of one or two lines;  that's just the language in which such programs could be written, then did not exist.  In those years, in the room next to Aho, Brian Kernigan worked, and his own routine tasks caused a similar desire.  Every day they discussed these ideas again and again, which as a result led them to want to create together a <i>pattern-matching</i> language that would be suitable for simple data processing tasks. <br><br>  The inspiration for AWK was <i>grep</i> .  But if everything that GREP could do was search in the match file with a fairly limited class of regular expressions and print all the found strings, then the AWK authors would like more.  First, the program had to work with numbers and strings;  secondly, to allow more varied data processing actions, and not just a simple printing of lines. <br><br>  Aho and Kernighan were engaged in data-processing algorithms for a long time.  For Aho, these tasks were of particular interest;  therefore, he drew attention to the <i>LEX</i> and <i>YACC</i> that Bell Labs used to create compilers (only later will they be used in other places).  Brian Kernighan was familiar with these programs, so things like using lexemes were taken for granted by AWK. <br><br>  Peter Weinberger was in the know from the very beginning.  He joined Aho and Kernighan at the moment when they finished with the grammar specification, and in a week created a working prototype.  Thanks to his work, it became possible to continue to engage in the evolution of language. <br><br>  Just to agree on which constructions should be in the language, and which - no, it took a whole year.  The very first version of AWK was written at the end of 1977.  The name of the software and the language came by itself - due to the fact that the trinity was constantly seen together, the colleagues had time to get used to refer to them as ‚ÄúAWK‚Äù (by the first initials of the last names)! <br><br>  The created language turned out so successful that it attracted to the ranks of programmers those who had not thought about programming before.  Aho later recalled that he had met people who were doing absolutely breathtaking projects with the help of AWK - for example, one enthusiast implemented his own CAD (CAD) on it and lamented that due to a bug in AWK he lost three weeks of his time.  (By the way, after this complaint, Aho and Kernighan decided that it was time to implement quality control, and since then, in order to implement new functionality in AWK, the developer had to first write a test for it) <br><br><h2>  Past &amp; Present </h2><br>  The tools with which Unix slowly mastered attracted the attention of an ever wider audience to the OS.  They could be quickly studied and conveniently used, each time saving time on hitherto difficult tasks. <br><br>  Studying <i>awk</i> today is not particularly difficult.  <a href="https://github.com/learnbyexample/Command-line-text-processing">This</a> command line <a href="https://github.com/learnbyexample/Command-line-text-processing">repository on Github</a> offers <a href="">hundreds of examples of <i>awk</i></a> and <a href=""><i>grep</i></a> <a href="">programs</a> .  Do not forget to <a href="https://unix.stackexchange.com/questions/24954/when-is-xargs-needed">read about <i>xargs</i></a> , which is used to run multiple processes in parallel. <br><br>  If you need a more thorough approach to the question, then your service is <a href="https://www.gnu.org/software/gawk/manual/gawk.html">The GNU Awk User's Guide</a> , an extremely detailed reference book that is perfect as a textbook. <br><br>  If you‚Äôre excited to see what the <i>awk</i> source code looked like in different years, then a pleasant surprise awaits you.  Dan Bornstein, the creator of <i>Dalvik</i> , collected <a href="https://github.com/danfuzz/one-true-awk">in his repository</a> all the versions of the one <i>True One Awk</i> he could find!  The repository stores only the original <i>awk</i> , which Brian Kernighan subsequently wrote and actively supported ‚Äî which is why it is often called <i>bwk</i> . <br><br>  If you don‚Äôt want to dive so deeply, you can look at the working <i>bwk</i> sources <a href="https://github.com/andychu/bwk">in another repository</a> . <br><br>  The idea of ‚Äã‚Äã"software tools" will continue to gain momentum.  By 1981, Unix itself included more than 300 utilities.  AWK will not disappear without a trace either - it will long remain one of the most popular languages ‚Äã‚Äãand inspire Perl with its principles. <br><br>  According to him, since that time a lot of water has flowed - Java and Python gained their popularity, which offered programmers their expressiveness and security in exchange for time and memory, which in our days often turns out to be an accessible compromise. <br><br><h2>  Epilogue </h2><br>  Returning to the beginning of our conversation, after reading the essay, I decided to ask Professor Kernighan how has his working process changed over the past ten years, and what does he use in his work today?  The answer seemed to me quite interesting: <br><br><blockquote>  Since then, little has changed.  I mostly use sam and vi to edit text.  I used them for the Go book;  Alan Donovan is an <i>emacs</i> wizard ( <i>"emacs wizard"</i> ).  Among those who write on Go in NY, I rarely met someone who would use a full-fledged IDE - and am not sure that I even met such people. <br><br>  What else has changed?  Today I probably write a lot more code in Python than 10 years ago.  It scales better than AWK;  However, it's not that I have to write large programs. <br><br>  Brian k </blockquote><br>  At work, Brian still uses the 27-inch iMac, and at home he has several MacBook Pros and MacBook Airs;  old Lenovo with Windows XP installed.  ‚ÄúMacs‚Äù are required for the most part as terminals for accessing the Linux servers of the university where it works. <br><br>  Professor Kernighan still uses <a href="http://www.washington.edu/alpine/">Alpine</a> to read the mail, <a href="https://en.wikipedia.org/wiki/Sam_(program)">Sam</a> , written by Rob Pike, and <i>vi</i> , who knows very well (every time he rushes to <i>emacs</i> , still prevents something from getting used) as an editor, but most of all wants to get rid of the unimaginable number of wires and connectors that annoy homes and on trips.  If you are interested in more details, he gave a short interview on this topic <a href="https://usesthis.com/interviews/brian.kernighan/">here</a> - although it has already become obsolete for 4 years, not much has changed since then. <br><br>  So, the ideas that appeared half a century ago continue to serve us today;  it remains to hope that modern software will find its place in the future. </div><p>Source: <a href="https://habr.com/ru/post/333780/">https://habr.com/ru/post/333780/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333768/index.html">Automation IP-network. Part 3 - Monitoring TCP Anomalies</a></li>
<li><a href="../333772/index.html">We copy the human brain: operation "Convolution"</a></li>
<li><a href="../333774/index.html">How to work with UX contractors? Experience messenger "Answer"</a></li>
<li><a href="../333776/index.html">Let the Internet bend under us</a></li>
<li><a href="../333778/index.html">Especially for Habr: interview with Alan Kay</a></li>
<li><a href="../333782/index.html">Sort by bubble in Qualcomm code</a></li>
<li><a href="../333784/index.html">A! Hack Summer - Alfa-Bank hackathon 5 and 6 August 2017</a></li>
<li><a href="../333786/index.html">How we added RAM to HPE servers</a></li>
<li><a href="../333788/index.html">MMO from scratch. Using Netty and the Unreal Engine. Part 1</a></li>
<li><a href="../333790/index.html">Asterisk func_odbc or strange ael</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>