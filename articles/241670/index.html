<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Deep into Pyparsing: Parsing units of measurement in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article, we got acquainted with the convenient parser library Pyparsing and wrote a parser for the expression 'import matplotlib.pyplot as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Deep into Pyparsing: Parsing units of measurement in Python</h1><div class="post__text post__text-html js-mediator-article"> In the <a href="http://habrahabr.ru/post/239081/">last article,</a> we got acquainted with the convenient parser library Pyparsing and wrote a parser for the expression <code>'import matplotlib.pyplot as plt'</code> . <br><br>  In this article we will begin the immersion in Pyparsing on the example of the task of parsing units of measurement.  Step by step, we will create a recursive parser that can search for characters in Russian, check the validity of the name of the unit of measurement, and also group those that the user has enclosed in brackets. <br><a name="habracut"></a><br>  <b>Note:</b> The code for this article has been tested and posted on <a href="https://cloud.sagemath.com/projects/1989e6b8-a109-487e-986a-df54caf96191/files/%25D0%2592%25D0%25B3%25D0%25BB%25D1%2583%25D0%25B1%25D1%258C%2520Pyparsing:%2520%25D0%25BF%25D0%25B0%25D1%2580%25D1%2581%25D0%25B8%25D0%25BC%2520%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D1%258B%2520%25D0%25B8%25D0%25B7%25D0%25BC%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%2520%25D0%25BD%25D0%25B0%2520Python.sagews">Sagemathclod</a> .  If suddenly something does not work for you (most likely due to the encoding of the text), be sure to let me know about it in a personal, in the comments or send me an <a href="">email</a> or <a href="http://vk.com/im%3Fsel%3D87466231">VK</a> . <br><br><h2>  Beginning of work.  Baseline data and task. </h2><br>  As an example, we will parse the expression: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="python hljs">s = <span class="hljs-string"><span class="hljs-string">"*^2/(*^2)"</span></span></code> </pre><br>  This unit of measurement was taken from the head in order to obtain a string, the analysis of which would use all the capabilities of our parser.  We need to get: <br><br><pre> <code class="python hljs">res = [(<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>), (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-number"><span class="hljs-number">2.0</span></span>), (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-number"><span class="hljs-number">-1.0</span></span>), (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-number"><span class="hljs-number">-2.0</span></span>)]</code> </pre><br>  Replacing in the string <code>s</code> division by multiplication, opening the brackets and clearly putting down the degrees of the units, we get: N * m ^ 2 / (kg * s ^ 2) = H ^ 1 * m ^ 2 * kg ^ -1 * s ^ -2 . <br><br>  Thus, each tuple in the variable <code>res</code> contains the name of the unit of measurement and the degree to which it must be built.  Between tuples you can mentally put multiplication signs. <br><br>  Before you use pyparsing, you must import it: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyparsing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> *</code> </pre><br>  When we write a parser, we replace * with the classes we use. <br><br><h2>  Method of writing a parser on Pyparsing </h2><br>  When using pyparsing, you should adhere to the following method of writing a parser: <br><ol><li>  First, keywords or individual important characters that are ‚Äúbuilding blocks‚Äù for constructing the final line are selected from the text line. </li><li>  We write separate parsers for "bricks". </li><li>  ‚ÄúBuild‚Äù a parser for the final string. </li></ol><br>  In our case, the main "building blocks" are the names of individual units of measure and their degree. <br><br><h2>  Writing a parser for a unit of measurement.  Parsing Russian letters. </h2><br>  A unit of measurement is a word that begins with a letter and consists of letters and dots (for example, mm Hg).  In pyparsing, we can write: <br><br><pre> <code class="python hljs">ph_unit = Word(alphas, alphas+<span class="hljs-string"><span class="hljs-string">'.'</span></span>)</code> </pre><br>  Note that the <code>Word</code> class now has 2 arguments.  The first argument is responsible for what should be the first character of the word, the second argument is responsible for what other characters of the word can be.  The unit of measurement necessarily begins with a letter, so we put the first argument <code>alphas</code> .  In addition to letters, the unit of measurement can contain a period (for example, mm.rt.st), so the second argument for <code>Word</code> is <code>alphas + '.'</code>  . <br><br>  Unfortunately, if we try to parse any unit of measurement, we will find that the parser only works for units of measurement in English.  This is because <code>alphas</code> means not just letters, but letters of the English alphabet. <br><br>  This problem is very easy.  First, create a string listing all the letters in Russian: <br><br><pre> <code class="python hljs">rus_alphas = <span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre><br>  And the parser code for a particular unit of measurement should be changed to: <br><br><pre> <code class="python hljs">ph_unit = Word(alphas+rus_alphas, alphas+rus_alphas+<span class="hljs-string"><span class="hljs-string">'.'</span></span>)</code> </pre><br>  Now our parser understands units of measurement in Russian and English.  For other languages, the parser code is written similarly. <br><br><h2>  Correction of the coding result parser. </h2><br>  When testing a parser for a unit of measurement, you can get a result in which Russian characters are replaced by their code designation.  For example, on Sage: <br><br><pre> <code class="python hljs">ph_unit.parseString(<span class="hljs-string"><span class="hljs-string">""</span></span>).asList() <span class="hljs-comment"><span class="hljs-comment"># : ['\xd0\xbc\xd0\xbc']</span></span></code> </pre><br>  If you get the same result, then everything works correctly, but you need to correct the encoding.  In my case (sage), the use of the self-made <code>bprint</code> function (better print) works: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bprint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj)</span></span></span><span class="hljs-function">:</span></span> print(obj.__repr__().decode(<span class="hljs-string"><span class="hljs-string">'string_escape'</span></span>))</code> </pre><br>  Using this function, we get the output in Sage in the correct encoding: <br><br><pre> <code class="python hljs">bprint(ph_unit.parseString(<span class="hljs-string"><span class="hljs-string">""</span></span>).asList()) <span class="hljs-comment"><span class="hljs-comment"># : ['']</span></span></code> </pre><br><h2>  Writing a parser for a degree.  Parsing an arbitrary number. </h2><br>  Learn to parse the degree.  Usually the degree is an integer.  However, in rare cases, the degree may contain a fractional part or be written in exponential notation.  Therefore, we will write a parser for a regular number, for example, like this: <br><br><pre> <code class="python hljs">test_num = <span class="hljs-string"><span class="hljs-string">"-123.456e-3"</span></span></code> </pre><br>  The ‚Äúbrick‚Äù of an arbitrary number is a natural number, which consists of numbers: <br><br><pre> <code class="python hljs">int_num = Word(nums)</code> </pre><br>  There may be a plus or minus sign in front of the number.  In this case, the plus sign should not be output to the result (we use <code>Suppress()</code> ). <br><br><pre> <code class="python hljs">pm_sign = Optional(Suppress(<span class="hljs-string"><span class="hljs-string">"+"</span></span>) | Literal(<span class="hljs-string"><span class="hljs-string">"-"</span></span>))</code> </pre><br>  A vertical bar means ‚Äúor‚Äù (plus or minus).  <code>Literal()</code> means an exact match to the text string.  Thus, the expression for <code>pm_sign</code> means that it is necessary to find an optional + symbol in the text, which should not be output to the result of parsing, or an optional minus symbol. <br><br>  Now we can write a parser for the whole number.  The number starts with an optional plus or minus sign, then the numbers follow, then the optional point is the fractional separator, then the numbers, then the e character can follow, followed by the number again: optional plus or minus and numbers.  The number after e has no fractional part.  On pyparsing: <br><br><pre> <code class="python hljs">float_num = pm_sign + int_num + Optional(<span class="hljs-string"><span class="hljs-string">'.'</span></span> + int_num) + Optional(<span class="hljs-string"><span class="hljs-string">'e'</span></span> + pm_sign + int_num)</code> </pre><br>  We now have a parser for the number.  Let's see how the parser works: <br><br><pre> <code class="python hljs">float_num.parseString(<span class="hljs-string"><span class="hljs-string">'-123.456e-3'</span></span>).asList() <span class="hljs-comment"><span class="hljs-comment">#  ['-', '123', '.', '456', 'e', '-', '3']</span></span></code> </pre><br>  As we can see, the number is divided into separate components.  We do not need this, and we would like to ‚Äúcollect‚Äù the number back.  This is done using <code>Combine()</code> : <br><br><pre> <code class="python hljs">float_num = Combine(pm_sign + int_num + Optional(<span class="hljs-string"><span class="hljs-string">'.'</span></span> + int_num) + Optional(<span class="hljs-string"><span class="hljs-string">'e'</span></span> + pm_sign + int_num))</code> </pre><br>  Check: <br><br><pre> <code class="python hljs">float_num.parseString(<span class="hljs-string"><span class="hljs-string">'-123.456e-3'</span></span>).asList() <span class="hljs-comment"><span class="hljs-comment">#  ['-123.456e-3']</span></span></code> </pre><br>  Fine!  But ... The output is still a string, but we need a number.  Add a string to number conversion using <code>ParseAction()</code> : <br><br><pre> <code class="python hljs">float_num = Combine(pm_sign + int_num + Optional(<span class="hljs-string"><span class="hljs-string">'.'</span></span> + int_num) + Optional(<span class="hljs-string"><span class="hljs-string">'e'</span></span> + pm_sign + int_num)).setParseAction(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> t: float(t.asList()[<span class="hljs-number"><span class="hljs-number">0</span></span>]))</code> </pre><br>  We use an anonymous function <code>lambda</code> , whose argument is <code>t</code> .  First we get the result as a list <code>(t.asList())</code> .  Since  the resulting list has only one element; you can immediately extract it: <code>t.asList()[0]</code> .  The <code>float()</code> function converts text to a floating point number.  If you work in Sage, you can replace <code>float</code> with <code>RR</code> , the constructor of the Sage real number class. <br><br><h2>  Parsing units with degree. </h2><br>  A separate unit of measurement is the name of the unit of measurement, after which the sign of the degree ^ and the number - the degree to which it is necessary to build can go.  On pyparsing: <br><br><pre> <code class="python hljs">single_unit = ph_unit + Optional(<span class="hljs-string"><span class="hljs-string">'^'</span></span> + float_num)</code> </pre><br>  Test: <br><br><pre> <code class="python hljs">bprint(single_unit.parseString(<span class="hljs-string"><span class="hljs-string">"^2"</span></span>).asList()) <span class="hljs-comment"><span class="hljs-comment"># : ['', '^', 2.0]</span></span></code> </pre><br>  Immediately improve the output.  We do not need to see ^ as a result of parsing, and we want to see the result in the form of a tuple (see the variable res at the beginning of this article).  To suppress output, we use <code>Suppress()</code> , to convert the list into a tuple - <code>ParseAction()</code> : <br><br><pre> <code class="python hljs">single_unit = (ph_unit + Optional(Suppress(<span class="hljs-string"><span class="hljs-string">'^'</span></span>) + float_num)).setParseAction(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> t: tuple(t.asList()))</code> </pre><br>  Check: <br><pre> <code class="python hljs">bprint(single_unit.parseString(<span class="hljs-string"><span class="hljs-string">"^2"</span></span>).asList()) <span class="hljs-comment"><span class="hljs-comment"># : [('', 2.0)]</span></span></code> </pre><br><br><h2>  Parsing units of measure, framed by brackets.  Recursion implementation. </h2><br>  We come to an interesting place - a description of the implementation of recursion.  When writing a unit of measurement, the user can frame one or more units of measurement, between which there are multiplication and division signs.  The expression in brackets may contain another, nested expression, framed by brackets (for example, <code>"(^2/ (^2 * ))"</code> ).  The possibility of nesting some expressions with brackets to others is a source of recursion.  Let's go to Pyparsing. <br><br>  First we write the expression, not paying attention that we have a recursion: <br><br><pre> <code class="python hljs">unit_expr = Suppress(<span class="hljs-string"><span class="hljs-string">'('</span></span>) + single_unit + Optional(OneOrMore((Literal(<span class="hljs-string"><span class="hljs-string">"*"</span></span>) | Literal(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)) + (single_unit | unit_expr))) + Suppress(<span class="hljs-string"><span class="hljs-string">")"</span></span>)</code> </pre><br>  <code>Optional</code> contains that part of the string that may or may not be present.  <code>OneOrMore</code> (translated as ‚Äúone or more‚Äù) contains the part of the string that should appear in the text at least once.  <code>OneOrMore</code> contains two ‚Äúaddends‚Äù: first we look for the multiplication and division sign, then the unit of measurement or the nested expression. <br><br>  In the form, as it is now, <code>unit_expr</code> cannot leave <code>unit_expr</code> : to the left and right of the equal sign there is <code>unit_expr</code> , which clearly indicates recursion.  This problem is solved very simply: you need to change the assignment sign to &lt;&lt;, and in the line before <code>unit_expr</code> add the assignment of a special class <code>Forward()</code> : <br><br><pre> <code class="python hljs">unit_expr = Forward() unit_expr &lt;&lt; Suppress(<span class="hljs-string"><span class="hljs-string">'('</span></span>) + single_unit + Optional(OneOrMore((Literal(<span class="hljs-string"><span class="hljs-string">"*"</span></span>) | Literal(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)) + (single_unit | unit_expr))) + Suppress(<span class="hljs-string"><span class="hljs-string">")"</span></span>)</code> </pre><br>  Thus, when writing a parser, there is no need to foresee recursion in advance.  First, write the expression as if there is no recursion in it, and when you see that it appears, just replace the = sign with &lt;&lt; and add the assignment of the <code>Forward()</code> class in the line above. <br><br>  Check: <br><br><pre> <code class="python hljs">bprint(unit_expr.parseString(<span class="hljs-string"><span class="hljs-string">"(*/^2)"</span></span>).asList()) <span class="hljs-comment"><span class="hljs-comment"># : [('',), '*', ('',), '/', ('', 2.0)]</span></span></code> </pre><br><br><h2>  Parsing a common expression for a unit of measure. </h2><br>  We have the last step: a general expression for the unit of measurement.  On pyparsing: <br><br><pre> <code class="python hljs">parse_unit = (unit_expr | single_unit) + Optional(OneOrMore((Literal(<span class="hljs-string"><span class="hljs-string">"*"</span></span>) | Literal(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)) + (single_unit | unit_expr)))</code> </pre><br>  Note that the expression has the form <code>(a | b) + (c | d)</code> .  The brackets are required and have the same role as in mathematics.  Using parentheses, we want to indicate that we first need to check that the first term is <code>unit_expr</code> or <code>single_unit</code> , and the second term is an optional expression.  If you remove the brackets, it turns out that <code>parse_unit</code> is <code>unit_expr</code> or <code>single_unit</code> + an optional expression, which is not exactly what we intended.  The same reasoning applies to the expression inside <code>Optional()</code> . <br><br><h2>  Draft parser.  Correction of the result encoding. </h2><br>  So, we wrote a draft parser: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyparsing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * rus_alphas = <span class="hljs-string"><span class="hljs-string">''</span></span> ph_unit = Word(rus_alphas+alphas, rus_alphas+alphas+<span class="hljs-string"><span class="hljs-string">'.'</span></span>) int_num = Word(nums) pm_sign = Optional(Suppress(<span class="hljs-string"><span class="hljs-string">"+"</span></span>) | Literal(<span class="hljs-string"><span class="hljs-string">"-"</span></span>)) float_num = Combine(pm_sign + int_num + Optional(<span class="hljs-string"><span class="hljs-string">'.'</span></span> + int_num) + Optional(<span class="hljs-string"><span class="hljs-string">'e'</span></span> + pm_sign + int_num)).setParseAction(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> t: float(t.asList()[<span class="hljs-number"><span class="hljs-number">0</span></span>])) single_unit = (ph_unit + Optional(Suppress(<span class="hljs-string"><span class="hljs-string">'^'</span></span>) + float_num)).setParseAction(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> t: tuple(t.asList())) unit_expr = Forward() unit_expr &lt;&lt; Suppress(<span class="hljs-string"><span class="hljs-string">'('</span></span>) + single_unit + Optional(OneOrMore((Literal(<span class="hljs-string"><span class="hljs-string">"*"</span></span>) | Literal(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)) + (single_unit | unit_expr))) + Suppress(<span class="hljs-string"><span class="hljs-string">")"</span></span>) parse_unit = (unit_expr | single_unit) + Optional(OneOrMore((Literal(<span class="hljs-string"><span class="hljs-string">"*"</span></span>) | Literal(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)) + (single_unit | unit_expr)))</code> </pre><br>  Check: <br><br><pre> <code class="python hljs">print(s) <span class="hljs-comment"><span class="hljs-comment"># s = "*^2/(*^2)" ‚Äî .  . bprint(parse_unit.parseString(s).asList()) # : [('',), '*', ('', 2.0), '/', ('',), '*', ('', 2.0)]</span></span></code> </pre><br><h2>  Grouping units of measure, framed by brackets. </h2><br>  We are already close to the result we want to get.  The first thing we need to implement is the grouping of those units that the user has enclosed in brackets.  To do this, Pyparsing uses <code>Group()</code> , which we apply to <code>unit_expr</code> : <br><br><pre> <code class="python hljs">unit_expr = Forward() unit_expr &lt;&lt; Group(Suppress(<span class="hljs-string"><span class="hljs-string">'('</span></span>) + single_unit + Optional(OneOrMore((Literal(<span class="hljs-string"><span class="hljs-string">"*"</span></span>) | Literal(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)) + (single_unit | unit_expr))) + Suppress(<span class="hljs-string"><span class="hljs-string">")"</span></span>))</code> </pre><br>  Let's see what has changed: <br><br><pre> <code class="python hljs">bprint(parse_unit.parseString(s).asList()) <span class="hljs-comment"><span class="hljs-comment"># : [('',), '*', ('', 2.0), '/', [('',), '*', ('', 2.0)]]</span></span></code> </pre><br><br><h2>  We put degree 1 in those tuples where there is no degree. </h2><br>  In some tuples after the comma does not cost anything.  Recall that a tuple corresponds to a unit of measurement and has the form (unit of measure, degree).  Recall that we can give names to certain pieces of the result of the parser (described in the <a href="http://habrahabr.ru/post/239081/">last article</a> ).  In particular, let's call the found unit of measure as <code>'unit_name'</code> , and its degree as <code>'unit_degree'</code> .  In <code>setParseAction()</code> we write an anonymous function <code>lambda()</code> , which will put 1 where the user does not specify the degree of the unit of measurement).  On pyparsing: <br><br><pre> <code class="python hljs">single_unit = (ph_unit(<span class="hljs-string"><span class="hljs-string">'unit_name'</span></span>) + Optional(Suppress(<span class="hljs-string"><span class="hljs-string">'^'</span></span>) + float_num(<span class="hljs-string"><span class="hljs-string">'unit_degree'</span></span>))).setParseAction(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> t: (t.unit_name, float(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t.unit_degree == <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> t.unit_degree))</code> </pre><br>  Now our entire parser produces the following result: <br><br><pre> <code class="python hljs">bprint(parse_unit.parseString(s).asList()) <span class="hljs-comment"><span class="hljs-comment"># : [('', 1.0), '*', ('', 2.0), '/', [('', 1.0), '*', ('', 2.0)]]</span></span></code> </pre><br>  In the code above, instead of <code>float(1)</code> , it would be possible to write just <code>1.0</code> , but in Sage, in this case, you will get not the type <code>float</code> , but your own type Sage for real numbers. <br><br><h2>  Remove the signs * and / from the result of the parser, open the brackets. </h2><br>  All that is left for us to do is to remove the * and / signs as well as the nested square brackets as a result of the parser.  If before the nested list (that is, before [) there is a division, the sign of the degree of the units of measurement in the nested list should be changed to the opposite.  To do this, we write a separate function <code>transform_unit()</code> , which we will use in <code>setParseAction()</code> for <code>parse_unit</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform_unit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unit_list, k=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> res = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> unit_list: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(v, tuple): res.append(tuple((v[<span class="hljs-number"><span class="hljs-number">0</span></span>], v[<span class="hljs-number"><span class="hljs-number">1</span></span>]*k))) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> v == <span class="hljs-string"><span class="hljs-string">"/"</span></span>: k = -k <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> isinstance(v, list): res += transform_unit(v, k=k) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(res) parse_unit = ((unit_expr | single_unit) + Optional(OneOrMore((Literal(<span class="hljs-string"><span class="hljs-string">"*"</span></span>) | Literal(<span class="hljs-string"><span class="hljs-string">"/"</span></span>)) + (single_unit | unit_expr)))).setParseAction(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> t: transform_unit(t.asList()))</code> </pre><br>  After this, our parser returns the unit of measure in the required format: <br><br><pre> <code class="python hljs">bprint(transform_unit(parse_unit.parseString(s).asList())) <span class="hljs-comment"><span class="hljs-comment"># : [('', 1.0), ('', 2.0), ('', -1.0), ('', -2.0)]</span></span></code> </pre><br>  Note that the <code>transform_unit()</code> function removes nesting.  In the conversion process, all brackets are expanded.  If there is a dividing sign in front of the parenthesis, the sign of the degree of units in brackets is reversed. <br><br><h2>  The implementation of checking units of measurement directly in the process of parsing. </h2><br>  The last thing that was promised to be done is to introduce an early verification of units of measurement.  In other words, as soon as the parser finds the unit of measurement, it will immediately check it against our database. <br><br>  We will use the Python dictionary as a database: <br><br><pre> <code class="python hljs">unit_db = {<span class="hljs-string"><span class="hljs-string">''</span></span>:{<span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">1000000</span></span>}, <span class="hljs-string"><span class="hljs-string">''</span></span>:{<span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-string"><span class="hljs-string">''</span></span>:{<span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1000</span></span>}, <span class="hljs-string"><span class="hljs-string">''</span></span>:{<span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-string"><span class="hljs-string">''</span></span>:{<span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>:<span class="hljs-number"><span class="hljs-number">0.001</span></span>}}</code> </pre><br>  To quickly check a unit of measure, it would be nice to create a lot of Python by putting units of measure into it: <br><br><pre> <code class="python hljs">unit_set = set([t <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> vals <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> unit_db.values() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vals])</code> </pre><br>  Let's write the <code>check_unit</code> function, which will check the unit of measurement, and insert it into the <code>setParseAction</code> for <code>ph_unit</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_unit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(unit_name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> unit_name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> unit_set: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">"        : "</span></span> + unit_name) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(unit_name) ph_unit = Word(rus_alphas+alphas, rus_alphas+alphas+<span class="hljs-string"><span class="hljs-string">'.'</span></span>).setParseAction(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> t: check_unit(t.asList()[<span class="hljs-number"><span class="hljs-number">0</span></span>]))</code> </pre><br>  The output of the parser will not change, but if you get a unit that is not in the database or in science, the user will receive an error message.  Example: <br><br><pre> <code class="python hljs">ph_unit.parseString(<span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    : Error in lines 1-1 Traceback (most recent call last): ‚Ä¶ File "", line 1, in &lt;lambda&gt; File "", line 3, in check_unit ValueError:         : </span></span></code> </pre><br>  The last line is our error message to the user. <br><br><h2>  Full parser code.  Conclusion </h2><br>  In conclusion, I will give the full code of the parser.  Do not forget in the import line <code>"from pyparsing import *"</code> to replace * with the used classes. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pyparsing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> nums, alphas, Word, Literal, Optional, Combine, Forward, Group, Suppress, OneOrMore <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bprint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(obj)</span></span></span><span class="hljs-function">:</span></span> print(obj.__repr__().decode(<span class="hljs-string"><span class="hljs-string">'string_escape'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#     unit_db = {'':{'':1, '':1/10, '':1/100, '':1/1000, '':1000, '':1/1000000}, '':{'':1}, '':{'':1, '':1000}, '':{'':1}, '':{'':1, '':0.001}} unit_set = set([t for vals in unit_db.values() for t in vals]) #           rus_alphas = '' def check_unit(unit_name): """      . """ if not unit_name in unit_set: raise ValueError("        : " + unit_name) return(unit_name) ph_unit = Word(rus_alphas+alphas, rus_alphas+alphas+'.').setParseAction(lambda t: check_unit(t.asList()[0])) #    int_num = Word(nums) pm_sign = Optional(Suppress("+") | Literal("-")) float_num = Combine(pm_sign + int_num + Optional('.' + int_num) + Optional('e' + pm_sign + int_num)).setParseAction(lambda t: float(t.asList()[0])) #       single_unit = (ph_unit('unit_name') + Optional(Suppress('^') + float_num('unit_degree'))).setParseAction(lambda t: (t.unit_name, float(1) if t.unit_degree == "" else t.unit_degree)) #      unit_expr = Forward() unit_expr &lt;&lt; Group(Suppress('(') + single_unit + Optional(OneOrMore((Literal("*") | Literal("/")) + (single_unit | unit_expr))) + Suppress(")")) #       def transform_unit(unit_list, k=1): """     ,  ,       *  / """ res = [] for v in unit_list: if isinstance(v, tuple): res.append(tuple((v[0], v[1]*k))) elif v == "/": k = -k elif isinstance(v, list): res += transform_unit(v, k=k) return(res) parse_unit = ((unit_expr | single_unit) + Optional(OneOrMore((Literal("*") | Literal("/")) + (single_unit | unit_expr)))).setParseAction(lambda t: transform_unit(t.asList())) # s = "*^2/(*^2)" bprint(parse_unit.parseString(s).asList())</span></span></code> </pre><br>  Thank you for the patience with which you read my article.  Let me remind you that the code presented in this article is posted on <a href="https://cloud.sagemath.com/projects/1989e6b8-a109-487e-986a-df54caf96191/files/%25D0%2592%25D0%25B3%25D0%25BB%25D1%2583%25D0%25B1%25D1%258C%2520Pyparsing:%2520%25D0%25BF%25D0%25B0%25D1%2580%25D1%2581%25D0%25B8%25D0%25BC%2520%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D1%258B%2520%25D0%25B8%25D0%25B7%25D0%25BC%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F%2520%25D0%25BD%25D0%25B0%2520Python.sagews">Sagemathcloud</a> .  If you are not registered on Habr√©, you can send me a question by <a href="">email</a> or write to <a href="http://vk.com/im%3Fsel%3D87466231">VK</a> .  In the next article I want to introduce you to <a href="https://cloud.sagemath.com/">Sagemathcloud</a> , to show how much he can simplify your work in Python.  After that, I will return to the topic of parsing Pyparsing at a qualitatively new level. <br><br>  I thank <a href="http://vk.com/id837282">Darya Frolov</a> and Nikita Konovalov for help in checking the article before publishing it. </div><p>Source: <a href="https://habr.com/ru/post/241670/">https://habr.com/ru/post/241670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241660/index.html">Moscow Big Data Hackathon 15-16 November</a></li>
<li><a href="../241662/index.html">Running a store through the eyes of an implementation engineer.</a></li>
<li><a href="../241664/index.html">Be able to say ‚Äúno‚Äù and be able to say ‚Äúyes‚Äù</a></li>
<li><a href="../241666/index.html">Pixel art course</a></li>
<li><a href="../241668/index.html">Oxygen Accelerator - Our First Day in London</a></li>
<li><a href="../241672/index.html">At the head of Google: how to get the most out of contextual advertising</a></li>
<li><a href="../241674/index.html">CppCon 2014 conference reports</a></li>
<li><a href="../241676/index.html">Do the right thing (and fight the zombies)</a></li>
<li><a href="../241680/index.html">Mobile services for ASP.NET developers</a></li>
<li><a href="../241684/index.html">All the answers to the questions of digital marketing on the portal AdCrunch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>