<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hell Visualization 1.1 - Book 2: Problems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ad visualization 1.1: 

- Book 1: Overview 
- Book 2: Problems 
- Book 3: Decisions 
- Book 4: Conclusion 
 Welcome to the second book! Here we will e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hell Visualization 1.1 - Book 2: Problems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/c0d/2b0/bc4/c0d2b0bc40c04d25a1415903bb077f26.png" align="left">  <i>Ad visualization 1.1:</i> <ul><li>  <a href="http://habrahabr.ru/post/245713/">Book 1: Overview</a> </li><li>  <b>Book 2: Problems</b> </li><li>  <a href="http://habrahabr.ru/post/246133/">Book 3: Decisions</a> </li><li>  <a href="http://habrahabr.ru/post/246133/">Book 4: Conclusion</a> </li></ul><br clear="all">  Welcome to the second book!  Here we will explore some of the problems that may arise during the visualization process.  But, for starters, a little practice: <br><br>  Knowing about the problem is useful.  But to really <b>feel the</b> problem is much better for understanding.  Let's try putting ourselves in the place of a CPU / GPU. <br><a name="habracut"></a><br><h3>  Experiment </h3><br>  Please create 10,000 small files (for example, 1 KB each) and copy them from one hard disk to another.  This operation will take a long time, although the data size is only 9.7 MB. <br><br><img src="https://habrastorage.org/files/8d8/843/fb0/8d8843fb071244a594d457926c8bffaa.gif">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now create one 9.7 MB file and copy it in the same way.  This operation will be performed much faster! <br><blockquote>  Why?  After all, the size of the data is the same! <br></blockquote>  This is true, but <b>each</b> copy operation consists of many things that need to be done, for example: prepare a file for movement, allocate memory, move the read / write heads of a disk back and forth ... All this is the overhead for <b>each</b> write operation.  As you might have felt the hard way, this overhead is huge if you copy many small files.  The visualization of multiple polygonal meshes (that is, the execution of many commands) is much more complicated, but it feels the same. <br><br><img src="https://habrastorage.org/files/69e/475/161/69e4751616c84d91bcc2b003ca05f92d.gif"><br><br>  Now let's look at the worst case that can occur during the rendering process. <br><br><h3>  Worst case </h3><br>  Having lots of small polygonal meshes is bad.  If they use <b>different</b> material parameters, then everything gets worse.  But why? <br><br><h4>  1. Many polygonal meshes </h4><br>  The graphics processor can draw faster than the central processor to send commands. <br><blockquote>  The main reason for reducing Draw Calls is that graphics hardware can change and visualize triangles much faster than you transfer them.  If you send a small number of triangles to each call, then you will be completely bound by the CPU performance, and the GPU will for the most part be in standby mode.  The CPU will not be able to ‚Äúfeed‚Äù the GPU fast enough.  [ <a href="https://habr.com/ru/post/245823/">f05</a> ] <br></blockquote><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Y3lAnf0WVkY%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhjcHlfFjUd5mVyXj9-mS53eUrYmbw" frameborder="0" allowfullscreen=""></iframe><br><br>  Everything else, each Draw Call incurs some overhead (as mentioned above): <br><blockquote>  There are driver-level overheads whenever you make an API call, and the best way to reduce them is to call the API as little as possible.  [ <a href="https://habr.com/ru/post/245823/">a02</a> ] <br></blockquote><br><h4>  2. Set Draw Calls </h4><br>  One example of such additional expenses is the command buffer.  Do you remember that the CPU fills the command buffer and the GPU reads it?  Yes, they have to report changes and this also creates overhead costs (read / write pointers change, you can read more <a href="http://traxnet.wordpress.com/2011/07/18/understanding-modern-gpus-2/">here</a> )!  For this reason, it may be better not to send commands one by one, but first fill the buffer and transfer a whole block of commands to the GPU.  This increases the risk that the GPU will have to wait until the CPU finishes building a block of commands, but at the same time reduces the cost of communication. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/efjDUHrvtPI%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhgB3hiy57sLnaQOZoYffwadyc89zQ" frameborder="0" allowfullscreen=""></iframe><br><blockquote>  The GPU (fortunately) has many things to do while the CPU is compiling a new command buffer (for example, processing the previous block).  Modern processors can fill several command buffers at once independently of each other, and then sequentially transfer them to the GPU. <br></blockquote>  Only <b>one</b> example has been described above.  In the real world, not only CPU, GPU and command buffers are talking to each other.  API (DirectX, OpenGL), drivers and many other elements are included in this process, which does not make it easier. <br><br>  We have discussed only the case with many polygonal grids that use <b>the same</b> material (Render State).  But what happens when we want to visualize objects with different materials? <br><br><h4>  3. Many polygonal meshes and materials </h4><br>  Reset conveyor. <br><blockquote>  Changing the state, sometimes you have to partially or completely reset the conveyor.  For this reason, changing the shader or material parameters can be very expensive [...] [ <a href="https://habr.com/ru/post/245823/">b01</a> ] <br></blockquote>  You thought it won't be any worse?  So ... if you use different materials with different polygonal meshes, you cannot group visualization commands.  You set the Render State for the first grid, command it to display it, then set the new Render State, send the next render command, and so on. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/gDi1b15Cdu8%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhhaGpty2cQL4MwrDtjpyeeRNsseSw" frameborder="0" allowfullscreen=""></iframe><br><blockquote>  I painted the command ‚ÄúChange State‚Äù in red, since a) it is expensive and b) for readability. <br></blockquote>  Setting the Render State values ‚Äã‚Äãsometimes (not always, depending on the parameters you want to change) causes the entire pipeline to be reset.  This means that each polygonal mesh that is being processed at the moment (with the current Render State) must be displayed before you can proceed to the next one (with the new Render State).  It looks like the video above. <br>  Instead of taking a huge number of vertices (for example, combining several grids with the same Render State, I will explain this optimization later), a small amount is displayed before the Render State change operation, which is obviously bad. <br><br>  By the way: Since the CPU takes some minimum time to set the Draw Call parameters (regardless of the size of the polygonal grid), we can assume that there is <b>no</b> difference in the display of 2 or 200 triangles.  The GPU is pretty darn fast and while the CPU prepares a new Draw Call, the triangles will already be the new pixels on the screen.  Of course, this ‚Äúrule‚Äù will change when we talk about combining several small polygonal meshes into one big one (we will look at it later). <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/skgMty2yCGA%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhjvjShJUbNiIAx5hdGq3hqZ0Q3g7Q" frameborder="0" allowfullscreen=""></iframe><br><blockquote>  I did not manage to find up-to-date data on the number of polygons that can be visualized ‚Äúfor free‚Äù on modern graphic maps.  If you know anything about this or have taken any measurements recently, please let me know! <br></blockquote><br><a name="p4"></a><h4>  4. Polygonal meshes and multi materials </h4><br>  What if a polygon mesh is assigned not one material, but two or more?  Basically, the grid breaks into several pieces, and then "fed" in parts to the command buffer. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/fRIrZW7O0hk%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhjbDqZzeOfuw_agdGfslebEdDShqw" frameborder="0" allowfullscreen=""></iframe><br><br>  Of course, this entails additional Draw Calls for each grid element. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/NbnuKFYHPx8%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700253&amp;usg=ALkJrhh0H-OntiRPeP8ibbTda1j0vHGjFQ" frameborder="0" allowfullscreen=""></iframe><br><br>  I hope I managed to give you a quick idea of ‚Äã‚Äãwhat is bad in a large number of polygonal meshes and materials.  In the next book, we will look at some solutions, even if all this looks terrible.  But there are wonderful games that prove that the problems described above somehow managed to be overcome. <br><br>  <b>the end</b> <br><br><hr><a name="a02"></a>  [a02] <a href="http://developer.download.nvidia.com/GPU_Programming_Guide/GPU_Programming_Guide_G80.pdf">GPU Programming Guide GeForce 8 and 9 Series</a> <br><a name="b01"></a>  [b01] <a href="http://www.realtimerendering.com/book.html">Real-Time Rendering</a> : p.  711/712 <br><a name="f05"></a>  [f05] <a href="http://stackoverflow.com/questions/4853856/why-are-draw-calls-expensive">Why are draw calls expensive</a> </div><p>Source: <a href="https://habr.com/ru/post/245823/">https://habr.com/ru/post/245823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245805/index.html">Free SMS sending from Arduino without GSM module</a></li>
<li><a href="../245807/index.html">C ++ Russia Conference in Moscow</a></li>
<li><a href="../245809/index.html">Experience creating a home Wi-Fi router. Part 2. Installing and configuring software</a></li>
<li><a href="../245811/index.html">New release and features: 3CX Phone System 12.5 Release Candidate</a></li>
<li><a href="../245817/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ138 (December 8 - 14, 2014)</a></li>
<li><a href="../245825/index.html">Black Friday 2014. Results</a></li>
<li><a href="../245829/index.html">Mobile Product Support: Tasks, Processes, Tools</a></li>
<li><a href="../245831/index.html">How to add Bing Maps to a Windows application in HTML and JavaScript. Part 2</a></li>
<li><a href="../245833/index.html">HeadHunter Public Test</a></li>
<li><a href="../245835/index.html">The future of parametric CAD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>