<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About C ++ aliasing, deft optimizations and vile bugs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I was surprised to find that there are no posts about aliasing. The situation needs to be corrected, tk. Aliasing in any complex C ++ program is neces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About C ++ aliasing, deft optimizations and vile bugs</h1><div class="post__text post__text-html js-mediator-article">  I was surprised to find that there are no posts about aliasing.  The situation needs to be corrected, tk.  Aliasing in any complex C ++ program is necessary at least somewhere, yes it is.  This can be good, giving the possibility of dexterous optimizations, and can be bad, introducing heightened scall bugs.  Under the cut in brief about both cases (well, the constant ‚Äúcompiler beats the back,‚Äù of course; for a change, today is gcc). <br><a name="habracut"></a><br><h4>  About aliasing </h4><br><br>  What is aliasing?  Very simple.  This is when several different pointers are shown on the same memory location.  For example. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * B = &amp;A; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * C = &amp;A;</code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this example, the variable A suddenly has <i>three</i> different names (alias): A, * B, * C.  This is a completely legal code.  The compiler will successfully process all 3 names, if something is written in A, then through * B it will be possible to read it and vice versa, everything is fine. <br><br><h4>  About optimization and __restrict </h4><br><br>  Except for one little thing: possible optimizations.  The compiler is obliged to understand and remember about aliasing not only in such a visual case, but also where a person implicitly assumes no alias.  For example. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SumIt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * out, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * in, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;count; i++ ) (*out) += *in++; }</code> </pre><br><br>  Normal function with out-parameter, nothing foretells trouble.  And she is.  No one gave a guarantee to the compiler that the out-variable at * out address does not intersect with the in-data at * in.  Independently, he has no right to make such assumptions: you never know how and why a person wants to write?  Therefore, at each iteration of the inner loop, * out is written back into memory, even with the maximum level of optimization.  Dysasm (gcc -O3 -S, 4.4.3, ubuntu x64) looks like this. <br><br><pre> <code class="hljs perl">.L7: addq $4, %rax addl (%rsi), %ecx cmpq %rdx, %rax movq %rax, %rsi movl %ecx, (%rdi) ; &lt;--  ! jne .L7</code> </pre><br><br>  However, the compiler can be told that out does not intersect with in.  For this, humanity came up with the <b>__restrict</b> modifier. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SumIt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * __restrict out, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * __restrict in, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;count; i++ ) (*out) += *in++; }</code> </pre><br><br><pre> <code class="hljs perl">.L14: addq $4, %rax addl (%rsi), %ecx cmpq %rdx, %rax movq %rax, %rsi jne .L14 movl %ecx, (%rdi)</code> </pre><br><br>  Well, think, 1 instruction?  The processors are now smart, with a thick cache and a bunch of pipelines.  In this mini-example, the record, of course, will be instantly cached, the extra instruction will probably coexist with something, and I guess the differences will not even be able to measure? <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">1783293664</span></span> in <span class="hljs-number"><span class="hljs-number">103818</span></span> usec <span class="hljs-number"><span class="hljs-number">1783293664</span></span> in <span class="hljs-number"><span class="hljs-number">69818</span></span> usec</code> </pre><br><br>  Not really.  It turns out.  Oops, the acceleration is about 1.5 times.  Such here and there is the price of one instruction (and two modifiers).  Usually it doesn't matter, but for well-loaded inner cycles it is useful. <br><br><h4>  About strict aliasing and bugs </h4><br><br>  As you can see, the removal of aliasing can result in a good speed improvement.  Apparently, from these considerations in the C99 standard, and through this and C ++, they invented and introduced a rule about <b>strict aliasing</b> .  A reference for people who are proficient in reading and understanding the Standard: N1124, 6.5 (7).  A normal person doesn‚Äôt really look there: for example, neither the word strict nor the word aliasing is in this paragraph.  ;) (It was possible to find it somehow quickly only because in footnote number 74 there is the word aliased.) The particularly important applied meaning ‚Äúon the fingers‚Äù, however, can be explained quite simply. <br><br>  <b>In strict aliasing mode, the compiler considers that the objects pointed to by "substantially different" types cannot be stored in the same memory area, and can use this for optimizations.</b> <br><br>  What does not matter when the pointers either really show in different places, or are used far enough from each other.  But deadly, when pointers are shown in the same memory, they are used side by side, and the compiler is gcc. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; typedef unsigned int DWORD; typedef unsigned short WORD; inline DWORD SwapWords ( DWORD val ) { WORD * p = (WORD*) &amp;val; WORD t; t = p[0]; p[0] = p[1]; p[1] = t; return val; } int main() { printf ( "%d\n", SwapWords(1) ); return 0; }</span></span></span></span></code> </pre><br><br>  This simple program prints either 65536 when building g ++ test.cpp, or 1 when building g ++ -O3 test.cpp.  What the heck?! <br><br>  The fact is that starting with -O2, -fstrict-aliasing is turned on automatically.  And the compiler believes that * p in principle cannot show where val is stored.  And this case is successfully optimized to death: if it cannot, then the value of the argument will be returned to us;  then SwapWords (1) can be replaced simply with the constant 1. <br><br>  And in this example, the problem is, in fact, not very much.  For if you enable -Wall (or at least -Wstrict-aliasing), the compiler honestly complains about the incomprehensible. <br><br><pre> <code class="cpp hljs">test.cpp:<span class="hljs-number"><span class="hljs-number">8</span></span>: warning: dereferencing pointer <span class="hljs-string"><span class="hljs-string">'p.14'</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> strict-aliasing rules</code> </pre><br><br>  What is not hard to fix.  The kindergarten method is to disable the damned strict aliasing with the -fno-strict-aliasing option.  A statutory method of correction, which de facto works everywhere and everywhere, is to stretch the value through the union.  Fields union like any other compiler graciously allows aliases with each other.  Any tricks with pointers can theoretically spill over (undefined behavior), in the case of gcc, the theory is not hard to turn into practice and vice versa (-fstrict-aliasing). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> DWORD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SwapWords</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { DWORD d; WORD v[<span class="hljs-number"><span class="hljs-number">2</span></span>]; } u; ud = val; WORD t = uv[<span class="hljs-number"><span class="hljs-number">0</span></span>]; uv[<span class="hljs-number"><span class="hljs-number">0</span></span>] = uv[<span class="hljs-number"><span class="hljs-number">1</span></span>]; uv[<span class="hljs-number"><span class="hljs-number">1</span></span>] = t; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ud; }</code> </pre><br><br>  Cheers cheers?  But alas, there is one small but: <b>-Wstrict-aliasing does not guarantee anything</b> .  To capture <i>all</i> cases of aliasing that are not compatible with the current compilation mode, it is not enough.  I don‚Äôt have a short enough one and therefore I have a clear example, so I‚Äôll have to take my word for it: quite a bit of patterned stuffing, a functor is another, and strict aliasing is cleverly disguised and doesn‚Äôt allow vorning.  In a program with active use of STL and / or Boost, I suspect that imperceptibly violating strict aliasing somewhere in the wilds of the code should be pretty light.  Third parties also testify that foci with coercion to void * and back successfully suppressed warning at least on gcc 4.1.x, while leaving the generation of curved code, of course. <br><br>  Despite the undefined behavior, the screw will of course not format it.  (Well, not immediately.) However, the compiler can easily rearrange reading and writing to memory in order to optimize.  It looks like this. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> uint64_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DWORD * p )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>*)p; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DWORD buf[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> t; buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; buf[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>; t = GetIt(buf); buf[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span>; buf[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> ( <span class="hljs-string"><span class="hljs-string">"%d, %d, %d, %d\n"</span></span>, buf[<span class="hljs-number"><span class="hljs-number">0</span></span>], buf[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(t&gt;&gt;<span class="hljs-number"><span class="hljs-number">32</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(t) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  Again, it prints a bit unexpected tsiferki: 1, 2, 32573, -648193368.  Unlike the previous example, where the compiler simplified the SwapWords () function to a complete lack of a function, it is here that the read / write swap takes place.  The compiler concludes that GetIt (buf) does not depend on the contents of buf, and therefore puts the ‚Äúcall‚Äù GetIt () where it sees fit.  The necessary is obtained generally before filling the buffer. <br><br><pre> <code class="hljs perl">mov (%rsp),%r8 ; t = GetIt(buf) ... movl $0x1,(%rsp) ; buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> movl $0x2,<span class="hljs-number"><span class="hljs-number">0x4</span></span>(%rsp) ; buf[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span> movl $0x3,<span class="hljs-number"><span class="hljs-number">0x8</span></span>(%rsp) ; buf[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">3</span></span> movl $0x4,<span class="hljs-number"><span class="hljs-number">0xc</span></span>(%rsp) ; buf[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">4</span></span> mov %r8d,%r9d ; r9 = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(t) shr $0x2<span class="hljs-number"><span class="hljs-number">0</span></span>,%r8 ; r8 = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(t&gt;&gt;<span class="hljs-number"><span class="hljs-number">32</span></span>) callq <span class="hljs-number"><span class="hljs-number">0x400510</span></span> &lt;__printf_chk@plt&gt;</code> </pre><br><br>  As a result, in some variable there is an incorrect value (either too old or too new) ... and then everything that follows.  Catching such a vile bug can be long and unsuccessful: for successful development, the optimizer should decide to optimize it in this ‚Äúblind‚Äù place, optimization should manifest itself so that the results are caught in 2x. <br><br>  How to confidently fight?  I do not know suitable automatic methods and tools.  I used to think that the compiler catches more or less;  now, however, I know that I can skip a completely trivial conversion, if I slightly wrap it with templates (and maybe even with functions even).  Fight because of <s>prayer and fasting is</s> tough discipline.  Changed the pointer type, think about side effects.  Feel yourself a compiler, think the boy for him: does the fox run, the eagle fly, the aliasing breaks. <br><br>  Side-note: You can read a classic detailed post on Comrade about all other subtleties and tricks due to strict aliasing.  Mike Acton, <a href="http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html">cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html</a> <br><br><h4>  What about MSVC? </h4><br><br>  There are no problems about strict aliasing.  Moreover, the ability to include either.  Apparently, MS decided that the C99-compliant code in the world without a thin rake about aliasing in the world is much smaller than what is usual, so there is no need to create difficulties.  The educational mission is carried out by gcc, well, and the bazhok-the other is sometimes quietly nenerenit, not without it. <br><br>  This automatically means that tricks about optimization and __restrict for pointers there are somewhat more important.  For example, for void SumIt (int64_t * out, const int * in, int count) according to the strict rule, gcc has the right to ‚Äúguess‚Äù that out is unlikely to lie in the middle of in;  MSVC will not be able to guess about this.  It is necessary to either restrict-it manually, or manually reduce the records to a minimum.  Already he can put a local variable in the register. <br><br>  It is important to understand that a member of the class is <i>also</i> data that is based on the this pointer.  Therefore, a constant reference to a member of a class in a loop can be compiled into a constant torment of memory. <br><br><h4>  Total </h4><br><br>  1. You write the inner loop, remember about aliasing and about __ restrict. <br>  2. Convert pointer, remember strict aliasing and nuclear potential of side effects permutation. <br>  3. You use gcc, remember the default -fstrict-aliasing, do not ignore -Wall. <br>  4. You use MSVC, remember about the forced absence of strict-aliasing-style optimizations, optimize with your hand. <br>  5. You see a warning about strict aliasing, figure it out, maybe a UB thread. <br>  6. Can you see a warning about strict aliasing?  And he is.  Like a gopher. <br>  6.1.  Compilers say lies, unreliable versions, -Wall sometimes works (you need to turn it on!), But it does not guarantee anything. <br>  6.2.  One cannot believe oneself at all, only benchmarks, dysasm, prayer and fasting. </div><p>Source: <a href="https://habr.com/ru/post/114117/">https://habr.com/ru/post/114117/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114107/index.html">Automate logging of inputs in functions</a></li>
<li><a href="../114108/index.html">Synchronization of tasks and calendar with MS Outlook</a></li>
<li><a href="../114111/index.html">Wopad WR701 - 7-inch tablet with a capacitive screen from China (part 2)</a></li>
<li><a href="../114113/index.html">We are looking fast, even faster</a></li>
<li><a href="../114114/index.html">Native Client: Ready for takeoff!</a></li>
<li><a href="../114118/index.html">Fun ImageMagick features to help web designer</a></li>
<li><a href="../114119/index.html">Layout mailing: view from the inside</a></li>
<li><a href="../114120/index.html">Collaboration approach to machine creativity</a></li>
<li><a href="../114122/index.html">ICQ spam in Pidgin - disable authorization requests</a></li>
<li><a href="../114125/index.html">Cultural differences. Communication with American colleagues</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>