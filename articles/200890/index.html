<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to OpenSceneGraph</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="OpenSceneGraph is a cross-platform open source library for developing high-performance 3D applications. This is not a game engine that connects the us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to OpenSceneGraph</h1><div class="post__text post__text-html js-mediator-article">  OpenSceneGraph is a cross-platform open source library for developing high-performance 3D applications.  This is not a game engine that connects the user hand and foot with the limitations laid down in it, namely, the library - a set of useful modules that work well both alone and in assembly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/518/c49/978/518c49978d3a563481859020a02c9598.jpg"><br><br>  The core of OpenSceneGraph, the actual graph of the scene, is a rather thin wrapper around OpenGL that allows you to set a hierarchy of objects and perform any desired transformations on them: <br><ul><li>  change the characteristics of nodes (move objects in space, assign materials to them, lighting properties, shaders, and other modes and attributes of OpenGL); </li><li>  rebuild the tree in any desired way (create and delete objects, link them to other nodes of the graph); </li><li>  do a graph traversal, performing any actions for each node; </li><li>  and of course render the scene using OpenGL. </li></ul><br><a name="habracut"></a><br><h4>  Scene graph in OpenSceneGraph </h4><br>  Each node of the scene graph is an instance of one of the descendants of the Node class.  Arrows are parent-child relationships: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/40d/9ae/d94/40d9aed94f9c5cd04113980ce4c7702a.png"><br><br>  Nodes with children are called groups.  An ordinary Group does nothing with its children - they will all be rendered as they are.  However, inheritors of the Group class may have additional behavior.  For example, MatrixTransform inherits the Group class, and allows you to apply a transformation matrix to all children at once.  For example, if you change the matrix responsible for the tank tower, the tower will spin along with the barrel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b8a/016/c37/b8a016c37e29180f935eaa8877ba227d.png"><br><br>  The primitives of drawing OpenSceneGraph are called Drawables.  Each Drawable corresponds to some OpenGL drawing primitive: sphere, cube, arbitrary mesh, OpenGL teapot, etc. The Drawables themselves enter the stage only in the Geode container (short for ‚Äúgeometry node‚Äù).  A geode can hold any number of drawables: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/018/8da/81c/0188da81c63b4040bd0343c35cd9a107.png"><br><br>  A very important feature of OpenSceneGraph is that any node can have several descendants.  This is important in order not to duplicate identical objects and not to waste computer memory and video adapter to store duplicate fragments.  For example, a tank has several wheels and several tracks, but since they are the same, you can store them in one instance, and so that they are located in different places of the tank, we will set their position using individual MatrixTransforms: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/543/577/771/5435777711a420d4572ca7926dbe71f9.png"><br><br>  If we want to make a full-fledged model of a tank that can turn wheels and caterpillars, turn the turret and control the barrel, then we get a graph like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14b/a55/312/14ba5531274840407bab33b639e4d0cb.png"><br><br>  To turn the wheels, just change the texture mapping on the left or right wheels.  And the user will see that the corresponding wheels are spinning all at once.  Similarly with caterpillars - a change in texture can achieve a visible effect of movement. <br><br><h4>  Two words about memory management </h4><br>  A scene graph can have a very complex structure, and in order to simplify memory management, OpenSceneGraph uses a garbage collector with a reference counter.  Each class inheriting osg :: Referenced gets its own reference counter, which is automatically incremented and decremented using the smart pointer system osg :: ref_ptr.  Here is a simple example: <br><br><pre><code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">osg</span></span>::ref_ptr&lt;osg::Geode&gt; geode = new osg::Geode; }</code> </pre> <br>  In this example, a new instance of osg :: Geode is created, a smart pointer is initialized, then the pointer is destroyed, and with it osg :: Geode, since there are no more links to it.  When adding children to the group, Drawables in the Geode and all other cross-references between objects of the graph, smart pointers are used.  This ensures that when deleting a link to the root node of the graph, all objects will be correctly destroyed. <br><br><h4>  Hello World </h4><br>  Here is the minimal OpenSceneGraph application: <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgViewer/Viewer&gt; int main() { osgViewer::Viewer viewer; return viewer.run(); }</span></span></span></span></code> </pre> <br>  It uses the osgViewer module, which takes care of opening the graphics window, initializing OpenGL, creating the default camera, initializing the Escape key handler and mouse controller, so that you can move the camera with it.  When you start the program, we will see an empty scene, which by Escape closes. <br>  The next step is to create the root node.  For example, put in front of viewer.run () the code for creating a sphere: <br><br><pre> <code class="hljs pgsql"> //  Drawable osg::Sphere *shape = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> osg::Sphere( osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f), <span class="hljs-number"><span class="hljs-number">1.0</span></span>f); osg::ShapeDrawable *drawable = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> osg::ShapeDrawable(shape); //  Geode osg::Geode *geode = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> osg::Geode; geode-&gt;addDrawable(drawable); //     viewer.setSceneData(geode);</code> </pre> <br>  After starting this application, we will see the scope: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/120/830/cd9/120830cd9e5f3fe3dae5fc251983c00e.jpg"><br><br>  Now you can go to download the font and text output.  We need the osgText library, which is responsible for working with text: <br><br><pre> <code class="hljs php"> osgText::Font *font = osgText::readFontFile( <span class="hljs-string"><span class="hljs-string">"/usr/share/fonts/truetype/msttcorefonts/arial.ttf"</span></span>); osgText::Text *text = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgText::Text; text-&gt;setFont(font); text-&gt;setAxisAlignment(osgText::Text::XZ_PLANE); text-&gt;setText(<span class="hljs-string"><span class="hljs-string">", !"</span></span>, osgText::String::ENCODING_UTF8); osg::Geode *geode = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Geode; geode-&gt;addDrawable(text);</code> </pre> <br>  The readFontFile function loads a font from a file, then we create a Text object that is derived from Drawable.  This means that it can be added to the Geode using the addDrawable method. <br>  After starting the program, the text will appear: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/660/647/fa5/660647fa5c7af5b2aba619c23adb80ab.jpg"><br><br><h4>  Main application loop </h4><br>  Most graphics applications must constantly update the image on the screen: create and delete new objects, move them, change properties and render them frame by frame: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/39a/93e/10d/39a93e10d016ad816a48bf8ec8909027.png"><br><br>  Scene changes are the operations that the application does.  Until the application finishes its updates, it is impossible to start rendering the next frame - otherwise, in the process of traversing the tree with the rendering system, the graph may be in an inconsistent state, and the application will damage its memory or just fall.  This means that the faster the updates are completed, the greater the FPS will be at the output. <br>  When creating real-world applications, it makes sense to perform heavy computations simultaneously with the rendering phase in another stream.  You can also create new objects of the scene.  And when the main cycle reaches the scene change phase, it will be possible to quickly apply the results of calculations to the objects of the scene, link the created subtrees to the scene graph.  Similarly, with the removal of a large number of objects.  During the phase of changing the scene, you can simply link them from the tree and place them in the delete queue, and the actual destruction of the objects can be performed in another thread. <br><br><h4>  How to change the scene </h4><br>  For example, let's make the inscription "Hello, Habr" spinning on the screen.  To do this, we first wrap the Geode in the MatrixTransform: <br><br><pre> <code class="hljs php"> osg::MatrixTransform *mat = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::MatrixTransform; mat-&gt;addChild(geode); viewer.setSceneData(mat);</code> </pre><br>  Then ask the Viewer to register our event handler: <br><br><pre> <code class="hljs pgsql"> RotationHandler *<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> RotationHandler(mat); viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>);</code> </pre><br>  Each event handler is an object that inherits the osgGA :: GUIEventHandler class.  We are now interested in how to handle the FRAME event, which is called before each frame: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotationHandler</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osgGA::GUIEventHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: RotationHandler(osg::MatrixTransform *mat): m_mat(mat) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osgGA::GUIEventAdapter&amp; ea, osgGA::GUIActionAdapter &amp;adapter)</span></span></span><span class="hljs-function"> </span></span>{ osg::Matrix mat; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ea.getEventType()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> osgGA::GUIEventAdapter::FRAME: mat.makeRotate(ea.getTime(), osg::Vec3(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); m_mat-&gt;setMatrix(mat); } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: osg::ref_ptr&lt;osg::MatrixTransform&gt; m_mat; };</code> </pre><br>  When you start the program, the text will begin to rotate around the axis (0, 0, 1). <br><br><h4>  What other features does OpenSceneGraph have? </h4><br>  We looked at the basic principles of scene construction, leaving behind the scenes a graph traversal, assigning attributes to nodes (materials, illumination), camera control, mouse and keyboard processing, and much more.  Just to mention some interesting features: <br><ul><li>  Visitor pattern implementation allows you to write your own class and ask OpenSceneGraph to bypass the graph, calling your code for each appropriate object of the scene; </li><li>  the Switch node (which is the successor of the Group) allows you to turn children on and off, excluding them from traversing the graph; </li><li>  The LOD node (also a successor of the Group) allows you to specify at what distance from the camera which of the children should be rendered.  Allows to use more simple models at a great distance from the camera; </li><li>  shader support (fragment and geometry); </li><li>  To achieve high performance and scalability, there is support for multi-stream rendering of images from multiple cameras.  Including multi-GPU; </li><li>  rendering to texture is possible; </li><li>  multi-layered textures, anisotropic lighting, bump-mapping, specular highlights; </li><li>  selection of scene objects into which the user points with the mouse (more precisely, the transformation of screen coordinates into a long and sharp polyhedron, which sticks to the screen, and then searches for intersections of this polyhedron with the scene objects and sorting the found objects by distance from the camera); </li><li>  many mathematical primitives for working with matrices, quaternions, polyhedra (calculating intersections, unions, etc.), 3d-morphing; </li><li>  Scene objects can be serialized and deserialized.  New export and import formats are easily connected using the plugin system.  The native format (osg) saves all attributes of objects in human-readable text format and allows you to accurately restore the graph after deserialization; </li><li>  special nodes of the HUD graph (head up display) allow children to be turned so that they are always facing the monitor; <br>  Particle systems allow you to create various special effects such as fire, smoke, sparks, programming the frequency of creation of each particle, its trajectory, time of life, texture, etc .; </li><li>  support for translucent objects and shadows; </li><li>  OpenThreads multithreading library allows you to abstract from the operating system and write a single code for all platforms; </li><li>  The osgDB module, in addition to simply loading and unloading objects onto a disk, has in its arsenal an object database module that allows them to be loaded in a background thread (paging mode); </li><li>  Integration with Qt allows you to render a GUI into a texture, which, in turn, can be stretched over some object of the scene.  In particular, you can take a Qt-component of a web browser, place it on a texture, display it on the scene, open YouTube in the browser and watch some video.  And it works; </li><li>  there is support for visualization of the earth's surface (terrain) and sky (skybox); </li><li>  the ability to work on mobile platforms Android and iOS; </li><li>  Excellent license (relaxed LGPL), allowing even statically linking the library with closed projects. </li></ul><br><h4>  Where to get </h4><br>  Official site - <a href="http://www.openscenegraph.org/">www.openscenegraph.org</a> <br>  The best documentation - <a href="http://www.amazon.com/s%3Ffield-keywords%3Dopenscenegraph">books from authors</a> . <br>  The best documentation available for free is a huge number of examples supplied with the library, and a great code that is easy and pleasant to read. </div><p>Source: <a href="https://habr.com/ru/post/200890/">https://habr.com/ru/post/200890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../200880/index.html">Multiplayer Games: Inside Look</a></li>
<li><a href="../200882/index.html">Six rules for effective management of promotion and "lead generation" using social media</a></li>
<li><a href="../200884/index.html">There is nothing wrong with types in C #</a></li>
<li><a href="../200886/index.html">Install and configure XBMC on Raspberry Pi</a></li>
<li><a href="../200888/index.html">About informational freedom</a></li>
<li><a href="../200892/index.html">ERP for the university: problems of choice and implementation</a></li>
<li><a href="../200894/index.html">Information security and certification. If there is no difference - why pay more?</a></li>
<li><a href="../200896/index.html">Compact USB HID Bootloader for ATtiny85</a></li>
<li><a href="../200898/index.html">Fast deserialization of really big JSON responses</a></li>
<li><a href="../200902/index.html">Importing OpenStreetMap to MySQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>