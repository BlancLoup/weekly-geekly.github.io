<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Extensible Android application code with MVP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: - I have long been interested in how to make the code of Android applications cleaner, and this is probably the first article, af...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Extensible Android application code with MVP</h1><div class="post__text post__text-html js-mediator-article"> <em>From the translator: - I have long been interested in how to make the code of Android applications cleaner, and this is probably the first article, after which I didn‚Äôt have any thoughts: "Why is this all here?"</em>  <em>and "Did he ever try to use it in his life?"</em>  <em>Therefore, I decided to translate, maybe someone else would be useful</em> . <br><br>  Write Hello World is always easy.  The code looks simple and straightforward, and it seems that the SDK is very adapted to your needs.  But if you have experience writing more complex Android applications, you know that this is not the case with working code.  You can spend hours trying to understand why your shopping cart is not updated after changing the orientation of your phone if WiFi is not available.  You assume that the solution to the problem may be to add another <code>if</code> in the 457-line <code>onCreate()</code> method of your activation - somewhere between the code that fixes the crash on Samsung 4.1 on board, and the one that shows the coupon on $ 5 on the user's birthday.  Well, there is a better way. <br><br>  In Remind, we roll out new functions every two weeks, and in order to maintain this speed and high quality of the product, we need a way to keep the code simple, maintained, divided <em>.</em> "decoupled", in the sense of loose coupling, and tested.  Using the MVP architectural pattern allows us to do this and focus on the most significant part of our code - our business logic. <br><a name="habracut"></a><br>  <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593presenter">MVP</a> , or Model-View-Presenter, is one of several patterns that contributes to the division of responsibility when implementing a user interface.  In each of these patterns, the roles of the layers are slightly different.  The purpose of this article is not to describe the differences between the patterns, but to show how this can be applied on the android (by analogy with modern UI frameworks such as <a href="http://guides.rubyonrails.org/getting_started.html">Rails</a> and <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">iOS</a> ), and how your application will benefit from this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      An example of code that illustrates most of the approaches described below can be found here: <br>  <a href="https://github.com/remind101/android-arch-sample">https://github.com/remind101/android-arch-sample</a> <br><br><h1>  Old School Android </h1><br>  The division of responsibility, which is implied by the Android framework, looks like this: <strong>A model</strong> can be any POJO, a <strong>View</strong> is an XML markup, and a fragment (or initially activated) acts as a <strong>Controller / Presenter</strong> .  In theory, this works quite well, but as soon as your application grows, a lot of code related to the Presentation appears in the Controller.  This is because not so much can be done with XML, so that all data binding (data-binding), animation, input processing, etc., is performed in the fragment, along with business logic. <br><br>  Everything becomes even worse when complex interface elements are placed in lists or grids (GridView / GridLayout means, in general, "grid elements").  Now the adapter is responsible not only to store the view and controller code for all these elements, but also to manage them as a collection.  Since all these elements are tightly coupled, they become very difficult to maintain and even harder to test. <br><br><h1>  Enter the Model-View-Presenter </h1><br>  MVP gives us the opportunity to highlight all that boring low-level Android code that is needed to display our interface and interact with it, in the <strong>View</strong> , and the higher-level business logic of what our application should do, evict to <strong>Presenter</strong> . <br><br>  To achieve this on an android, you need to consider the activation or a fragment as a presentation layer, and provide a lightweight presenter in order to control the presentation.  The most important thing is to determine the responsibility of each layer, and standardize the interface between them.  Here is a general description of the division, which works very well with us: <br><br>  The presentation (activation or fragment) is responsible for: <br><br><ol><li>  Creating a copy of the presenter and the mechanism of its connection / disconnection; </li><li>  Alert the presenter about important life cycle events for him; </li><li>  A message to the presenter about the input events; </li><li>  Placing the views and connecting them to the data; </li><li>  Animations; </li><li>  Event tracking; </li><li>  Switch to other screens. </li></ol><br>  The presenter is responsible for: <br><br><ol><li>  Loading models; </li><li>  Saving the reference to the model and view state; </li><li>  Formatting what should be displayed on the screen, and instructing the view to display it; </li><li>  Interaction with repositories (database, network, etc.) ( <em>approx. Lane.</em> Repository is a pattern, just in case); </li><li>  Determining what to do when input events are received from the view. </li></ol><br>  Here is an example of what the interface between a presentation and a presenter could be: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,         //     void setMessageBody(String body); void setAuthorName(String name); void showTranslationButton(boolean shouldShow); //   void goToUserProfile(User user); } interface MessagePresenter { //       ,        //     void onStart(); //    void onAuthorClicked(); void onThreeFingersSwipe(); }</span></span></code> </pre> <br>  There are a couple of interesting points to consider about this interface: <br><br><ul><li>  Methods for updating the presentation should be simple and aimed at a single element.  This is better than having one <code>setMessage(Message message)</code> method that will update everything, since the formatting of what needs to be displayed should be the responsibility of the presenter.  For example, in the future you will want to display "you" instead of the username if the current user is the author of the message, and this is part of the business logic. </li><li>  Presenter's life cycle event methods are simple and should not reflect the true (over complicated) system life cycle.  You are not required to process any of these.  But if you want the presenter to perform some actions at different stages of this cycle, you can process as much in it as you see fit. </li><li>  Input events at the presenter must remain high level.  For example, if you want to define a complex gesture, for example, a three-finger swipe, this and other events should be determined by the presentation. </li><li>  You can pay attention to the <code>MessagePresenter.onAuthorClicked()</code> and <code>MessageView.goToAuthorProfile()</code> methods.  The presentation implementation will likely have a clicker that will call this method of presenter, and that in turn will call <code>goToAuthorProfile()</code> .  Is it not necessary to remove all this and go to the author's profile directly from the click of the miner.  Not!  Deciding whether to go to a user profile when clicking on his name is part of your business logic, and the presenter is responsible for this. </li></ul><br>  As it turned out in practice, if the code of your presenter contains the code of the Android framework, and not just pure Java, you are probably doing something wrong.  And accordingly, if your presentations need a reference to a model, apparently, you are also doing something wrong. <br><br>  As soon as the question of tests arises, <strong>most of the code that you need to test will be in the presenter</strong> .  What is cool is that this code does not need Android to run, since it only has links to the presentation interface, and not to its implementation in the context of Android.  This means that you can simply get up the presentation interface and write clean JUnit tests for business logic that check the correctness of calling methods on the wet presentation.  <a href="">This is how</a> our tests look now. <br><br><h1>  What about lists? </h1><br>  Until now, we assumed that our ideas are activations and fragments, but in reality they can be anything.  We did quite well with the lists, having a <strong>ViewHolder that implements the view interface</strong> (both <code>RecyclerView.ViewHolder</code> , and the usual old ViewHolder for use in conjunction with a ListView).  In the adapter, you just need the basic logic for handling the attachment / detachment of presenters (an example of all this is in the git repository). <br><br>  If you look at an example of a screen containing a list of messages, download progress, and an empty view, the division of responsibility will be as follows: <br><br><ul><li>  The list presenter is responsible for loading messages and displaying list / progress view / empty stub display logic; </li><li>  The fragment is responsible for implementing the logic for displaying the list of views / progress / stub and switching to other screens; </li><li>  The adapter matches the presenters with their ViewHolder; </li><li>  The message presenter is responsible for the business logic of the individual message; </li><li>  ViewHolder is responsible for displaying the message. </li></ul><br>  All of these components are loosely coupled and can be tested separately from each other. <br><br>  Moreover, if you have a message list screen and a detail screen, you can reuse the same message presenter and just have two different implementations of the presentation interface (in the ViewHolder and the snippet).  This saves your DRY code ( <em>approx. Lane</em> - ‚ÄúDon't Repeat Yourself‚Äù, or ‚ÄúDo not repeat‚Äù, who does not know). <br><br>  Similarly, a view interface can implement custom views.  This allows you to use MVP in custom widgets to reuse it in different parts of the application, or simply break complex interfaces into simpler blocks. <br><br><h1>  MVP and configuration changes </h1><br>  If you‚Äôve been writing for Android for some time, you know how much pain the support for changing orientation and configuration delivers: <br><br><ul><li>  Fragment / activation should be able to restore their state.  Every time when working with a fragment, you should ask yourself how this thing should act when changing orientation, what should be placed in the saveInstanceState bundle, etc. </li><li>  Long operations in background threads are very difficult to do correctly.  One of the most popular errors is to keep the link to the fragment / activation in the background thread, since it needs to update the UI after the work is completed.  This leads to a memory leak (and, probably, a drop in the application due to an increase in memory consumption), as well as to the fact that the new activation will never receive a callback and, accordingly, will not update the UI. </li></ul><br>  Proper use of MVP can resolve this issue without having to think about it at all.  Since presenters do not have a strong reference to the current UI, they are very lightweight and can be restored when the orientation changes!  Since the presenter stores the link to the model and the state of the view, it can restore the desired state of the view after the orientation change.  Here is a rough description of what happens when the screen is rotated, if this pattern is used: <br><br><ul><li>  Initially, the activation was created (let's call it the "first instance"); <br><ul><li>  A new presenter is being created; </li><li>  Presenter is attached to the activit; </li></ul></li><li>  The user clicks the "Download" button; <br><ul><li>  The presenter runs a long operation; </li></ul></li><li>  Orientation changes; <br><ul><li>  Presenter decouples from the first copy of the activit </li><li>  There are no more references to the first copy of the activation, and now it is available to the garbage collector; </li><li>  Presenter saved, background operation continues; </li><li>  A second copy of the activation is created; </li><li>  The second copy of the activity is tied to the presenter. </li></ul></li><li>  Loading is completed; <br><ul><li>  Presenter updates the presentation (second copy of the activation). </li></ul></li></ul><br>  How to save fragments between changes of orientation can be seen in the repository in the class <code>PresenterManager</code> . <br><br><h1>  Total </h1><br>  Yes, this is the end.  I hope it turned out to demonstrate how sharing responsibility like MVP will help you write supported and tested code. <br><br>  Summarizing: <br><br><ul><li>  Separate your business logic by putting it into a naked java-object of the presenter; </li><li>  Spend time on a clean interface between your presenters and presentations; </li><li>  Let your activations, snippets and custom views implement the presentation interface; </li><li>  For lists, the view interface must implement the ViewHolder; </li><li>  Test your presenters thoroughly; <br><ul><li>  Save presenters when changing orientation. </li></ul></li></ul><br>  The implementation of the above can be found in <a href="https://github.com/remind101/android-arch-sample">the ArchExample repository</a> . <br>  There are also many libraries that can help you use this approach, for example, <a href="http://hannesdorfmann.com/mosby/">Mosby</a> , <a href="https://corner.squareup.com/2014/01/mortar-and-flow.html">Flow and Mortar</a> , or <a href="https://github.com/konmik/nucleus">Nucleus</a> .  I advise you to consider them. <br></div><p>Source: <a href="https://habr.com/ru/post/278769/">https://habr.com/ru/post/278769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278757/index.html">Windows-way synchronization settings between systems</a></li>
<li><a href="../278759/index.html">The idea of ‚Äã‚Äãan educational game for schoolchildren</a></li>
<li><a href="../278763/index.html">KTV. New JSON</a></li>
<li><a href="../278765/index.html">AutoCAD & RTree</a></li>
<li><a href="../278767/index.html">Microsoft announced Linux version of SQL Server</a></li>
<li><a href="../278771/index.html">Import substitution successes or entertaining statistics based on the Register of Federal State Information Systems</a></li>
<li><a href="../278773/index.html">Grid implementation for working with large tables. Part 1</a></li>
<li><a href="../278775/index.html">We write on D for Raspberry Pi</a></li>
<li><a href="../278777/index.html">The digest of interesting materials for the mobile developer # 143 (February 29 - March 8)</a></li>
<li><a href="../278779/index.html">Why is ownership / borrowing in Rust so complicated?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>