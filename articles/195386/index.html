<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Boost.Asio C ++ Network Programming". Chapter 3: Echo Server / Client</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming". 

 Content: 


- Chapter 1: Getting Started with Boost....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Boost.Asio C ++ Network Programming". Chapter 3: Echo Server / Client</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br>  I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming". <br><br>  Content: <br><ul><li>  <a href="http://habrahabr.ru/post/192284/">Chapter 1: Getting Started with Boost.Asio</a> </li><li>  Chapter 2: Boost.Asio Basics <br><ul><li>  <a href="http://habrahabr.ru/post/193038/">Part 1: The Basics of Boost.Asio</a> </li><li>  <a href="http://habrahabr.ru/post/195006/">Part 2: Asynchronous Programming</a> </li></ul></li><li>  <b>Chapter 3: Echo Server / Client</b> </li><li>  <a href="http://habrahabr.ru/post/195794/">Chapter 4: Client and Server</a> </li><li>  <a href="http://habrahabr.ru/post/196354/">Chapter 5: Synchronous vs. Asynchronous</a> </li><li>  <a href="http://habrahabr.ru/post/196888/">Chapter 6: Boost.Asio - Other Features</a> </li><li>  <a href="http://habrahabr.ru/post/197392/">Chapter 7: Boost.Asio - additional topics</a> </li></ul><br><br>  In this chapter, we will implement a small client / server application, which is likely to be the simplest client / server application.  This application is an echo server, which returns to the client what he wrote to him, and then closes the client connection.  The server can work with any number of clients.  When a new client connects, it sends a message.  The server receives the entire message and sends it back.  After that, it closes the connection. <br>  Thus, each echo client connects to the server, sends a message, and reads what the server answered, making sure that this is the same message that it sent, ends communication with the server. <br>  First we will implement a synchronous application, and then asynchronous, so you can easily compare them: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/40e/e3f/5fa/40ee3f5fa05982d0e6dfdfcb0de4f519.png"><br><br>  Not all of the code will be given here, but only parts of it, the entire code can be viewed at the link at the end of the article. <br><a name="habracut"></a><br><br><h4>  TCP echo server / client </h4><br>  For TCP, we can have an additional advantage; each message ends with a '\ n'.  Writing a synchronous server / client echo is very simple. <br>  We will give examples of programs such as a synchronous client, a synchronous server, an asynchronous client, and an asynchronous server. <br><br><h5>  TCP synchronous client </h5><br>  In most non-trivial examples, the client code is usually much simpler than the server (since the server must deal with several clients). <br>  The following example is an exception to the rule: <br><br><pre><code class="cpp hljs">ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read_complete(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * buf, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error_code &amp; err, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> found = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find(buf, buf + bytes, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) &lt; buf + bytes; <span class="hljs-comment"><span class="hljs-comment">// we read one-by-one until we get to enter, no buffering return found ? 0 : 1; } void sync_echo(std::string msg) { msg += "\n"; ip::tcp::socket sock(service); sock.connect(ep); sock.write_some(buffer(msg)); char buf[1024]; int bytes = read(sock, buffer(buf), boost::bind(read_complete,buf,_1,_2)); std::string copy(buf, bytes - 1); msg = msg.substr(0, msg.size() - 1); std::cout &lt;&lt; "server echoed our " &lt;&lt; msg &lt;&lt; ": "&lt;&lt; (copy == msg ? "OK" : "FAIL") &lt;&lt; std::endl; sock.close(); } int main(int argc, char* argv[]) { char* messages[] = { "John says hi", "so does James", "Lucy just got home", "Boost.Asio is Fun!", 0 }; boost::thread_group threads; for ( char ** message = messages; *message; ++message) { threads.create_thread( boost::bind(sync_echo, *message)); boost::this_thread::sleep( boost::posix_time::millisec(100)); } threads.join_all(); }</span></span></code> </pre> <br>  Notice the <code>sync_echo</code> function.  It contains all the logic to connect to the server, sends a message to it and waits for a return response. <br>  You have noticed that for reading we use the free function <code>read()</code> , because we want to receive the entire message before the '\ n' character.  The <code>sock.read_some()</code> function will not be enough, since it will read only what is available, but not necessarily the entire message. <br>  The third argument to the read () function is the final handler.  It will return 0 if the message is fully read.  Otherwise, the maximum buffer size is returned, which can be read in the next step (before the <code>read</code> completed).  In our case, it will always return 1, because we don‚Äôt want to mistakenly read more than we need. <br>  In <code>main()</code> we create several threads;  one thread for each message that the client sends, and wait until they complete.  If you run the program, you will see the following output: <br><br><pre> <code class="cpp hljs">server echoed our John says hi: OK server echoed our so does James: OK server echoed our Lucy just got home: OK server echoed our Boost.Asio is Fun!: OK</code> </pre><br>  Note that since we are dealing with a synchronous client, there is no need to call <code>service.run()</code> . <br><br><h5>  TCP synchronous server </h5><br>  Synchronous echo server is quite simple to write, as shown in the following code snippet: <br><br><pre> <code class="cpp hljs">io_service service; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read_complete(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * buff, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error_code &amp; err, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> found = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find(buff, buff + bytes, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) &lt; buff + bytes; <span class="hljs-comment"><span class="hljs-comment">// we read one-by-one until we get to enter, no buffering return found ? 0 : 1; } void handle_connections() { ip::tcp::acceptor acceptor(service, ip::tcp::endpoint(ip::tcp::v4(),8001)); char buff[1024]; while ( true) { ip::tcp::socket sock(service); acceptor.accept(sock); int bytes = read(sock, buffer(buff), boost::bind(read_complete,buff,_1,_2)); std::string msg(buff, bytes); sock.write_some(buffer(msg)); sock.close(); } } int main(int argc, char* argv[]) { handle_connections(); }</span></span></code> </pre><br>  All server logic is wrapped in <code>handle_connections()</code> .  Since it is single-threaded, we accept the new client, read the message that it sent, send it back, and then wait for the next client.  For example, if you connect two clients at once, then the second will have to wait while the server serves the first client. <br>  Note again that, since we are working synchronously, there is no need to call <code>service.run()</code> . <br><br><h5>  TCP asynchronous client </h5><br>  As soon as we start working asynchronously, the code becomes a bit more complicated.  We will model the <code>connection</code> class, as shown in the <a href="http://habrahabr.ru/post/195006/">second chapter</a> . <br>  Looking at the following code snippets in this section, you will notice that each asynchronous operation starts a new asynchronous operation, keeping service.run () in operation. <br>  First, the main functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEM_FN(x) boost::bind(&amp;self_type::x, shared_from_this()) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEM_FN1(x,y) boost::bind(&amp;self_type::x, shared_from_this(),y) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEM_FN2(x,y,z) boost::bind(&amp;self_type::x, shared_from_this(),y,z) class talk_to_svr : public boost::enable_shared_from_this</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;talk_to_svr&gt;,boost::noncopyable { typedef talk_to_svr self_type; talk_to_svr(const std::string &amp; message) : sock_(service), started_(true),message_(message) {} void start(ip::tcp::endpoint ep) { sock_.async_connect(ep, MEM_FN1(on_connect,_1)); } public: typedef boost::system::error_code error_code; typedef boost::shared_ptr&lt;talk_to_svr&gt; ptr; static ptr start(ip::tcp::endpoint ep, const std::string &amp; message) { ptr new_(new talk_to_svr(message)); new_-&gt;start(ep); return new_; } void stop() { if ( !started_) return; started_ = false; sock_.close(); } bool started() { return started_; } ... private: ip::tcp::socket sock_; enum { max_msg = 1024 }; char read_buffer_[max_msg]; char write_buffer_[max_msg]; bool started_; std::string message_; };</span></span></span></span></code> </pre><br>  We want to always use shared pointers on <code>talk_to_svr</code> , so that while there are asynchronous operations in the <code>talk_to_svr</code> instance, this instance remains alive.  In order to avoid such errors as creating instances of <code>talk_to_svr</code> in the stack, we made the constructor private and forbade the copy constructor (inherited from <code>boost::noncopyable</code> ). <br>  We have basic functions such as <code>start(), stop()</code> , and <code>started()</code> , which do only what their names say.  To create a connection, simply call <code>talk_to_svr::start(endpoint, message)</code> .  We also have buffers for reading and writing ( <code>read_buffer_</code> and <code>write_buffer_</code> ). <br>  As explained earlier, the following lines are very different: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// equivalent to "sock_.async_connect(ep, MEM_FN1(on_connect,_1));" sock_.async_connect(ep, boost::bind(&amp;talk_to_svr::on_connect,shared_ptr_from_this(),_1)); sock_.async_connect(ep, boost::bind(&amp;talk_to_svr::on_connect,this,_1));</span></span></code> </pre><br>  In the first case, we correctly create the final <code>async_connect</code> handler, it will save the shared pointer to the <code>talk_to_server</code> instance until it calls the final handler, thereby making sure that we are still alive when this happens. <br>  In the latter case, we incorrectly create the final handler.  By the time the <code>talk_to_server</code> instance is <code>talk_to_server</code> , it may already have been deleted! <br>  To read and write to the socket, we will use the following code fragment: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ async_read(sock_, buffer(read_buffer_), MEM_FN2(read_complete,_1,_2), MEM_FN2(on_read,_1,_2)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(msg.begin(), msg.end(), write_buffer_); sock_.async_write_some( buffer(write_buffer_, msg.size()), MEM_FN2(on_write,_1,_2)); } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read_complete(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> boost::system::error_code &amp; err, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes) { <span class="hljs-comment"><span class="hljs-comment">// similar to the one shown in TCP Synchronous Client }</span></span></code> </pre><br>  The <code>do_read()</code> function first makes sure that we read the message from the server, after which <code>on_read()</code> called.  The <code>do_write()</code> function first copies the message to the buffer (it is likely that msg may go out of scope and will eventually collapse), and then makes sure that the <code>on_write()</code> call occurs after the actual write. <br>  And the most important functions that contain the basic logic of the class: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !err) do_write(message_ + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> stop(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !err) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(read_buffer_, bytes - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"server echoed our "</span></span> &lt;&lt; message_ &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>&lt;&lt; (copy == message_ ? <span class="hljs-string"><span class="hljs-string">"OK"</span></span> : <span class="hljs-string"><span class="hljs-string">"FAIL"</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } stop(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ do_read(); }</code> </pre><br>  After that we connect and send a message to the server, <code>do_write()</code> .  When the write operation is completed, <code>on_write()</code> is called, which initiates the <code>do_read()</code> function.  When <code>do_read()</code> completed, <code>do_read()</code> is called, here we simply check that the message from the server is the same as what we sent to it and exit it. <br>  We will send three messages to the server just to make it all the more interesting: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* messages[] = { <span class="hljs-string"><span class="hljs-string">"John says hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"so does James"</span></span>, <span class="hljs-string"><span class="hljs-string">"Lucy got home"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ** message = messages; *message; ++message) { talk_to_svr::start( ep, *message); boost::this_thread::sleep( boost::posix_time::millisec(<span class="hljs-number"><span class="hljs-number">100</span></span>)); } service.run(); }</code> </pre><br>  In the previous code snippet, the following code will be generated: <br><br><pre> <code class="cpp hljs">server echoed our John says hi: OK server echoed our so does James: OK server echoed our Lucy just got home: OK</code> </pre><br><br><h5>  TCP asynchronous server </h5><br>  As shown below, the basic functions are very similar to those of the asynchronous client: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">talk_to_client</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::enable_shared_from_this&lt;talk_to_client&gt;, boost::noncopyable { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> talk_to_client self_type; talk_to_client() : sock_(service), started_(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::system::error_code error_code; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;talk_to_client&gt; ptr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ started_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; do_read(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> talk_to_client)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started_) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; started_ = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; vsock_.close(); } ip::tcp::<span class="hljs-function"><span class="hljs-function">socket &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sock_;} ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ip::tcp::socket sock_; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { max_msg = <span class="hljs-number"><span class="hljs-number">1024</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> read_buffer_[max_msg]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> write_buffer_[max_msg]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> started_; };</code> </pre><br>  This is a very simple echo server, there is no need for the <code>is_started()</code> function.  For each client, we simply read the message that he sent, send the same message back and close the connection. <br>  The functions <code>do_read(), do_write()</code> and <code>read_complete()</code> exactly the same as in the asynchronous TCP client. <br>  The main logic of the class is contained in the <code>on_read()</code> and <code>on_write()</code> functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !err) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(read_buffer_, bytes)</span></span></span></span>; do_write(msg + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>); } stop(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ do_read(); }</code> </pre><br>  Work with clients is as follows: <br><br><pre> <code class="cpp hljs">ip::tcp::<span class="hljs-function"><span class="hljs-function">acceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, ip::tcp::endpoint(ip::tcp::v4(), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(talk_to_client::ptr client, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err)</span></span></span><span class="hljs-function"> </span></span>{ client-&gt;start(); talk_to_client::ptr new_client = talk_to_client::new_(); acceptor.async_accept(new_client-&gt;sock(), boost::bind(handle_accept,new_client,_1)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ talk_to_client::ptr client = talk_to_client::new_(); acceptor.async_accept(client-&gt;sock(), boost::bind(handle_accept,client,_1)); service.run(); }</code> </pre><br>  Each time a client connects to the server, a <code>handle_accep</code> t is <code>handle_accep</code> , which starts to read asynchronously from this client, and also asynchronously waits for a new client. <br><br><h4>  UDP echo server / client </h4><br>  Since not all messages reach the recipient in UDP, we have no guarantee that the message has come completely.  Since we are working on UDP, then every message that we receive, we simply output without closing the socket (on the server side). <br><br><h5>  UDP synchronous echo client </h5><br>  UDP Echo Client is a bit simpler than TCP Echo Client: <br><br><pre> <code class="cpp hljs">ip::udp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sync_echo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg)</span></span></span><span class="hljs-function"> </span></span>{ ip::udp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, ip::udp::endpoint(ip::udp::v4(), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">) )</span></span></span></span>; sock.send_to(buffer(msg), ep); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; ip::udp::endpoint sender_ep; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytes = sock.receive_from(buffer(buff), sender_ep); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buff, bytes)</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"server echoed our "</span></span> &lt;&lt; msg &lt;&lt; <span class="hljs-string"><span class="hljs-string">": "</span></span>&lt;&lt; (copy == msg ? <span class="hljs-string"><span class="hljs-string">"OK"</span></span> : <span class="hljs-string"><span class="hljs-string">"FAIL"</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; sock.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* messages[] = { <span class="hljs-string"><span class="hljs-string">"John says hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"so does James"</span></span>, <span class="hljs-string"><span class="hljs-string">"Lucy got home"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }; boost::thread_group threads; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ** message = messages; *message; ++message) { threads.create_thread( boost::bind(sync_echo, *message)); boost::this_thread::sleep( boost::posix_time::millisec(<span class="hljs-number"><span class="hljs-number">100</span></span>)); } threads.join_all(); }</code> </pre><br>  All logic is contained in the <code>synch_echo()</code> function;  connecting to the server, sending a message, receiving a response message from the server and closing the connection. <br><br><h5>  UDP synchronous echo server </h5><br>  UDP Echo Server is the easiest server to write: <br><br><pre> <code class="cpp hljs">io_service service; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_connections</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; ip::udp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, ip::udp::endpoint(ip::udp::v4(), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { ip::udp::endpoint sender_ep; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytes = sock.receive_from(buffer(buff), sender_ep); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buff, bytes)</span></span></span></span>; sock.send_to(buffer(msg), sender_ep); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ handle_connections(); }</code> </pre><br>  Everything is very simple here and speaks for itself. <br>  Let's leave the asynchronous UDP server and client to write to the reader as an exercise. <br><br><h4>  Summary </h4><br>  We wrote several applications and finally got to work with Boost.Asio.  These applications are very good to get started with this library. <br>  In the next chapter, we will create more complex client / server applications, we will learn to avoid errors such as memory leaks, deadlocks, and so on. <br><br>  Thank you all very much! <br><br>  Resources for this article: <a href="https://github.com/Vasilui/habrahabr/tree/master/Boost.Asio_C%252B%252B_Network_Programming/Chapter_3">link</a> </div><p>Source: <a href="https://habr.com/ru/post/195386/">https://habr.com/ru/post/195386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195370/index.html">Why I (so far) do not believe in "smart watches"</a></li>
<li><a href="../195372/index.html">364 days for the iPhone - a fun calendar for every day</a></li>
<li><a href="../195378/index.html">Free music on youtube</a></li>
<li><a href="../195380/index.html">Schedule of universities on the phones: how we spent the summer - in search of freelancers</a></li>
<li><a href="../195382/index.html">Python meetup</a></li>
<li><a href="../195388/index.html">Definition of a start-up, or a new Holivar</a></li>
<li><a href="../195390/index.html">Apple finished the Interface Builder please!</a></li>
<li><a href="../195392/index.html">RailsClub'Moscow 2013. Interview with Vladimir Barsukov</a></li>
<li><a href="../195394/index.html">Meet GNOME 3.10</a></li>
<li><a href="../195398/index.html">Google Street View got to the Large Hadron Collider</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>