<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Encapsulation for real samurai, or nuances related to the internal keyword in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue: internal is new public 


 Each of us dreamed of a project where everything would be done correctly. It seems quite natural. As soon as you ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Encapsulation for real samurai, or nuances related to the internal keyword in C #</h1><div class="post__text post__text-html js-mediator-article"><h2>  Prologue: internal is new public </h2><br><p>  Each of us dreamed of a project where everything would be done correctly.  It seems quite natural.  As soon as you learn about the very possibility of writing good code, as soon as you hear legends about the very code that can be easily read and changed, you immediately catch fire thereby, ‚ÄúWell, now I‚Äôll do everything right, now I‚Äôve been smart and read McConnell.‚Äù </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/34f/ba6/d7e34fba6115e561d2016fa85f7a846a.jpg" alt="image"><br><br><p>  Such a project happened in my life.  Another.  And I do it under voluntary supervision, where every line is monitored.  Accordingly, not only wanted, but had to do everything right.  One of the "correct" was "honor the encapsulation and close to the maximum, because you always have time to open, and then it will be too late to close back."  And so I, wherever I could, began to use the access modifier internal for classes instead of public.  And, naturally, when you begin to actively use a new language feature for you, some nuances arise.  About them in order and I want to tell. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Offensive basic help</b> <div class="spoiler_text"><p>  Exclusively in order to recall and label. </p><br><ul><li>  The build is the minimum deployment unit in .NET and one of the basic compilation units.  As is correct, it is either .dll or .exe.  They say it can be divided into several files, which are called modules. </li><li>  public ‚Äî an access modifier that indicates that the tagged is accessible to everyone at all. </li><li>  internal is an access modifier that indicates that the tagged is available only inside the assembly. </li><li>  protected - an access modifier that indicates that the tagged is available only to the heirs of the class in which the tagged is located. </li><li>  private ‚Äî an access modifier that indicates that the tagged one is available only to the class in which it is located.  And no one else. </li></ul><br></div></div><br><h2>  Unit tests and friendly builds </h2><br><p>  In C ++, there was such a weird feature like friendly classes.  Classes could be assigned as friends, and then the encapsulation boundary between them was erased.  I suspect that this is not the strangest feature in C ++.  Perhaps even the top ten are not included.  But shooting oneself in the leg, tying several classes tightly, is somehow too easy, and it would be very hard to come up with a suitable case for this feature. </p><br><p>  It was all the more surprising to find out that in .NET there are friendly builds, a sort of rethinking.  That is, you can make one assembly see what is hidden behind the internal lock in another assembly.  When I found out about this, I was somewhat surprised.  Well, why would?  What's the point?  Who will tightly bind the two assemblies, taking up their separation?  Cases when in any incomprehensible situation are molded public, we do not consider in this article. </p><br><p>  And then in the same project I began to learn one of the branches of the path of the present samurai: unit testing.  And Feng Shui unit tests should be in a separate assembly.  For the same feng shui, everything that can be hidden inside the assembly should be hidden inside the assembly.  I faced a very, very unpleasant choice.  Either the tests will lie side by side and go to the client along with the code that is useful to him, or everything will be covered by the keyword public, how long it was in the damp bread. </p><br><p>  And here, somewhere from the bins of my memory, something about friendly assemblies was obtained.  It turned out that if you have the ‚ÄúYourAssemblyName‚Äù assembly, you can write it like this: </p><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: InternalsVisibleTo(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"YourAssemblyName.Tests"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre> <br><p>  And the ‚ÄúYourAssemblyName.Tests‚Äù assembly will see what is marked with the internal keyword in ‚ÄúYourAssemblyName‚Äù.  This line can be entered, just that, in AssemblyInfo.cs, which VS creates specifically for storing such attributes. </p><br><div class="spoiler">  <b class="spoiler_title">Returning an abusive basic reference</b> <div class="spoiler_text">  In .NET, in addition to already embedded attributes or keywords like abstract, public, internal, static, you can create your own.  And hang them on anything: fields, properties, classes, methods, events, and entire assemblies.  In C #, you simply write the name of the attribute in square brackets before you hang it.  The exception is the assembly itself, since there is no direct indication in the code that ‚ÄúAssembly begins here‚Äù.  There, before the attribute name, you must add the assembly: <br></div></div><br><p>  Thus, the wolves remain fed, the sheep are intact, everything that is possible is still hiding inside the assembly, unit tests live in a separate assembly, as expected, and the feature, about which I barely remembered, acquires a reason to use it.  Perhaps the only existing reason. </p><br><p>  I almost forgot one important point.  The actions of the InternalsVisibleTo attribute are one-way. </p><br><h2>  protected &lt;internal? </h2><br><p>  So, the situation: A and B were sitting on the pipe. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String SomeProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-comment"><span class="hljs-comment">//ERROR!!! The accessibility modifier of the 'B.OtherProperty.set' accessor must be more //restrictive than the property or indexer 'B.OtherProperty' internal String OtherProperty { get; protected set; } } }</span></span></code> </pre><br><p>  A was destroyed during the code review process, since it is not used outside the assembly, but for some reason it allows itself to have a public access modifier, B caused a compilation error, which in the first few minutes could introduce a stupor. </p><br><p>  Basically, the error message is logical.  The property accessor cannot disclose more than the property itself.  Any will react with understanding if the compiler gives a header for this: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  But claims to this line immediately break the brain: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  I note that there will be no complaints about this line: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br><p>  If you don‚Äôt think too much, then the following hierarchy is built in your head: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre> <br><p>  And this hierarchy seems to even work.  Except one place.  Where internal&gt; protected.  To understand the essence of the claims of the compiler, let's remember what restrictions impose internal and protected.  internal - only inside the assembly.  protected - only heirs.  Notice any heirs.  And if class B is marked as public, then in another assembly it is possible to define its heirs.  And then the set accessor will really get access to where all the property does not have it.  Since the C # compiler is paranoid, it cannot even allow it. </p><br><p>  Thank him for that, but we need to give heirs access to the accessor.  And especially for such cases there is a protected internal access modifier. </p><br><div class="spoiler">  <b class="spoiler_title">This reference is no longer so offensive.</b> <div class="spoiler_text"><ul><li>  protected internal - an access modifier that indicates that the tagged is available inside the assembly <strong>or to the</strong> heirs of the class in which the tagged is located. </li></ul><br></div></div><br><p>  So if we want the compiler to allow us to use this property and set it in the heirs, we need to do this: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> String OtherProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre><br><p>  And the correct hierarchy of access modifiers looks like this: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span></code> </pre><br><h2>  Interfaces </h2><br><p>  So, the situation: A, I, B sat on the pipe. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//'A' does not implement interface member 'I.SomeMethod()'. //'A.SomeMethod()' cannot implement an interface member because it is not public. } } internal class B : I { internal void SomeMethod() { //'B' does not implement interface member 'I.SomeMethod()'. //'B.SomeMethod()' cannot implement an interface member because it is not public. } } }</span></span></code> </pre><br><p>  Sat exactly and outside the assembly did not fit.  But they were rejected by the compiler.  Here the essence of the claims is clear from the error message.  The interface implementation must be open.  Even if the interface itself is closed.  It would be logical to tie access of the interface implementation to its availability, but what is not, is not.  The interface implementation must be public. </p><br><p>  And we have two options here.  First: through the creaking and gnashing of teeth, hang the public access modifier on the interface implementation.  Second: explicit interface implementation.  It looks like this: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  Please note that in the second case there is no access modifier.  To whom is the implementation of the method available?  Let's say no one.  Simply show an example: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); <span class="hljs-comment"><span class="hljs-comment">//'B' does not contain a definition for 'SomeMethod' and no accessible extension method //'SomeMethod' accepting a first argument of type 'B' could be found //(are you missing a using directive or an assembly reference?) b.SomeMethod(); //OK (b as I).SomeMethod();</span></span></code> </pre><br><p>  Explicit implementation of interface I means that unless we explicitly cast a variable to type I, there are no methods implementing this interface.  Each time writing (b as I) .SomeMethod () can be an overhead.  Like ((i) b) .SomeMethod ().  And I found two ways to get around this.  I thought of one myself, and the second honestly googled. </p><br><p>  Method one - factory: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Factory</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> I </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); } }</code> </pre><br><p>  Well, or any other pattern that allows you to hide this nuance. </p><br><p>  Method two - extension methods: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } }</code> </pre><br><p>  What is surprising, it works.  These lines cease to generate an error: </p><br><pre> <code class="cs hljs">B b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B(); b.SomeMethod();</code> </pre><br><p>  After all, the call goes, as IntelliSense in Visual Studio tells us, not to methods of an explicit interface implementation, but to extension methods.  And no one forbids contacting them.  And interface extension methods can be called on all its implementations. </p><br><p>  But one thing remains.  Inside the class itself, you need to access this method using the this keyword, otherwise the compiler will not understand that we want to refer to the extension method: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Error!!! SomeMethod(); //OK this.SomeMethod(); } void I.SomeMethod() { } }</span></span></code> </pre><br><p>  And so, and so, in our country or in public, where it should not be, but there it <em>seems</em> to cause no harm, or a little bit of extra code for each internal-interface.  Choose the least evil to your liking. </p><br><h2>  Reflection </h2><br><p>  I knocked about it painfully when I tried to find a constructor through reflection, which, of course, was labeled as internal by the internal-class.  And it turned out that reflection will not give out anything that would not be public.  And this, in principle, is logical. </p><br><p>  Firstly, reflection, if I remember correctly what smart people wrote in smart books, it‚Äôs about finding information in the build metadata.  Which, in theory, should not give too much (I thought so, at least).  Secondly, the main use of reflection is to make your program extensible.  You provide an outsider with some kind of interface (perhaps even in the form of interfaces, fit-ha!).  And they implement it and provide plugins, mods, extensions in the form of an assembly loaded on the fly, from which reflection gets them.  And of course, your API will be public.  That is, it is impossible to look at internal through reflection technically and senselessly from a practical point of view. </p><br><p>  <strong>Update.</strong>  Here in the comments it turned out that reflection allows, if it is explicitly asked about it, to reflect on everything.  Be it at least internal, at least private.  If you are not writing any code analysis tool, try not to do this, please.  The text further is still relevant when we are looking for open member types.  And in general, do not pass by the comments, there are a lot of interesting things. </p><br><p>  This could be the end of reflection, but let's return to the previous example, where A, I, B were sitting on the tube: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Pipe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I i</span></span></span><span class="hljs-function">)</span></span> { i.SomeMethod(); } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">B</span></span> : <span class="hljs-title"><span class="hljs-title">I</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OtherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> I.SomeMethod() { } } }</code> </pre><br><p>  The author of class A decided that nothing terrible would happen if the internal-class method was marked as public, so that the compiler didn‚Äôt scream, and so that it wouldn‚Äôt be necessary to fence more code.  The interface is marked as internal, the class that implements it is marked as internal, from the outside it is seemingly impossible to get to the method marked as public. </p><br><p>  And then the door opens and the reflection quietly sneaks: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pipe; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(I), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IExtensions), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(A), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"SomeMethod"</span></span>); FindThroughReflection(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(B), <span class="hljs-string"><span class="hljs-string">"OtherMethod"</span></span>); Console.ReadLine(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindThroughReflection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type, String methodName</span></span></span><span class="hljs-function">)</span></span> { MethodInfo methodInfo = type.GetMethod(methodName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInfo != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"In type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string"> we found </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodInfo}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"NULL! Can't find method </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{methodName}</span></span></span><span class="hljs-string"> in type </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{type.Name}</span></span></span><span class="hljs-string">"</span></span>); } } }</code> </pre><br><p>  Study this code, drive it into the studio, if you so wish.  Here we are trying using reflection to find all methods from all types of our pipe (namespace Pipe).  And what results it gives us: </p><br><blockquote>  I found a Void SomeMethod () <br>  Null!  Can't find method SomeMethod in type IExtensions <br>  In Void SomeMethod () <br>  Null!  Can't find method OtherMethod in type A <br>  Null!  Can't find method SomeMethod in type B <br>  Null!  Can't find method OtherMethod in type B <br></blockquote><br><p>  At once I will say that using an object of type MethodInfo, the found method can be called.  That is, if reflection found something, then it is theoretically possible to break the encapsulation.  And we have found something.  First, that same public void SomeMethod () from class A. It was expected, what else to say.  This concession may still have consequences.  Secondly, void SomeMethod () from interface I. This is more interesting.  No matter how we lock in, the abstract methods placed on the interface (or what the CLR actually places there) are in fact open.  Hence the conclusion in a separate paragraph: </p><br><p>  <em>Watch carefully to whom and what objects of type System.Type you give.</em> </p><br><p>  But here is another nuance with these two found methods that I would like to consider.  Methods of internal-interfaces and open methods of internal-classes can be found through reflection.  As a reasonable person, I conclude that they fall into the metadata.  As an experienced person, I will verify this conclusion.  And this will help us ILDasm. </p><br><div class="spoiler">  <b class="spoiler_title">To look with one eye into the rabbit hole of our pipe metadata</b> <div class="spoiler_text"><p>  The assembly was assembled in the Release mode. </p><br> <code>TypeDef #2 (02000003) <br> ------------------------------------------------------- <br> TypDefName: Pipe.I (02000003) <br> Flags : [NotPublic] [AutoLayout] [Interface] [Abstract] [AnsiClass] (000000a0) <br> Extends : 01000000 [TypeRef] <br> Method #1 (06000004) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000004) <br> Flags : [Public] [Virtual] [HideBySig] [NewSlot] [Abstract] (000005c6) <br> RVA : 0x00000000 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> TypeDef #3 (02000004) <br> ------------------------------------------------------- <br> TypDefName: Pipe.IExtensions (02000004) <br> Flags : [NotPublic] [AutoLayout] [Class] [Abstract] [Sealed] [AnsiClass] [BeforeFieldInit] (00100180) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000005) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000005) <br> Flags : [Assem] [Static] [HideBySig] [ReuseSlot] (00000093) <br> RVA : 0x00002134 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> ReturnType: Void <br> 1 Arguments <br> Argument #1: Class Pipe.I <br> 1 Parameters <br> (1) ParamToken : (08000004) Name : i flags: [none] (00000000) <br> CustomAttribute #1 (0c000011) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> CustomAttribute #1 (0c000010) <br> ------------------------------------------------------- <br> CustomAttribute Type: 0a000001 <br> CustomAttributeName: System.Runtime.CompilerServices.ExtensionAttribute :: instance void .ctor() <br> Length: 4 <br> Value : 01 00 00 00 &gt; &lt; <br> ctor args: () <br> <br> TypeDef #4 (02000005) <br> ------------------------------------------------------- <br> TypDefName: Pipe.A (02000005) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000006) <br> ------------------------------------------------------- <br> MethodName: SomeMethod (06000006) <br> Flags : [Public] [Final] [Virtual] [HideBySig] [NewSlot] (000001e6) <br> RVA : 0x0000213c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (06000007) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000007) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x0000213e <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (06000008) <br> ------------------------------------------------------- <br> MethodName: .ctor (06000008) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x00002140 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> InterfaceImpl #1 (09000001) <br> ------------------------------------------------------- <br> Class : Pipe.A <br> Token : 02000003 [TypeDef] Pipe.I <br> <br> TypeDef #5 (02000006) <br> ------------------------------------------------------- <br> TypDefName: Pipe.B (02000006) <br> Flags : [NotPublic] [AutoLayout] [Class] [AnsiClass] [BeforeFieldInit] (00100000) <br> Extends : 01000011 [TypeRef] System.Object <br> Method #1 (06000009) <br> ------------------------------------------------------- <br> MethodName: OtherMethod (06000009) <br> Flags : [Assem] [HideBySig] [ReuseSlot] (00000083) <br> RVA : 0x00002148 <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #2 (0600000a) <br> ------------------------------------------------------- <br> MethodName: Pipe.I.SomeMethod (0600000A) <br> Flags : [Private] [Final] [Virtual] [HideBySig] [NewSlot] (000001e1) <br> RVA : 0x0000214a <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> Method #3 (0600000b) <br> ------------------------------------------------------- <br> MethodName: .ctor (0600000B) <br> Flags : [Public] [HideBySig] [ReuseSlot] [SpecialName] [RTSpecialName] [.ctor] (00001886) <br> RVA : 0x0000214c <br> ImplFlags : [IL] [Managed] (00000000) <br> CallCnvntn: [DEFAULT] <br> hasThis <br> ReturnType: Void <br> No arguments. <br> <br> MethodImpl #1 (00000001) <br> ------------------------------------------------------- <br> Method Body Token : 0x0600000a <br> Method Declaration Token : 0x06000004 <br> <br> InterfaceImpl #1 (09000002) <br> ------------------------------------------------------- <br> Class : Pipe.B <br> Token : 02000003 [TypeDef] Pipe.I <br></code> <br></div></div><br><p>  A quick inspection reveals that <strong>everything</strong> goes into the metadata, no matter how it is marked.  Reflection is also carefully hiding from us what is not supposed to be seen by strangers.  So it may well be that the extra five lines of code for each method of the internal-interface is not such a big evil.  However, the main conclusion remains the same: </p><br><p>  <em>Watch carefully to whom and what objects of type System.Type you give.</em> </p><br><p>  But this is, of course, the next level, after the accession of the keyword internal in all places where there is no need for public. </p><br><h2>  PS </h2><br><p>  Do you know what's great about using the keyword internal everywhere inside an assembly?  When it grows, you have to divide it into two or more.  In the process, you have to take a pause to make some types open.  And you have to think about which types deserve to be open.  At least briefly. </p><br><p>  This means the following: <em>this practice of writing code will make you think once again about what form the architectural boundary between newborn assemblies will take.</em>  What can be more beautiful? </p><br><h2>  Pps </h2><br><p>  Starting with C # 7.2, a new access modifier private protected has appeared.  And I still have no idea what it is, and what it is eaten with.  Since it does not come across in practice.  But I will be glad to know in the comments.  But not copy-paste from the documentation, but real cases when this access modifier may be needed. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/445804/">https://habr.com/ru/post/445804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445794/index.html">IT giants unveiled collaborative solution to deploy hybrid cloud</a></li>
<li><a href="../445796/index.html">Fintech Digest: Dorsey pays Bitcoins, Australia's blockchain strategy, Levi's IPO, Chicago Mayor and the inevitability of Bitcoin</a></li>
<li><a href="../445798/index.html">Rhino inside the cat - run the firmware in the Kopycat emulator</a></li>
<li><a href="../445800/index.html">Monads in 15 minutes</a></li>
<li><a href="../445802/index.html">5 trends of the Internet of Things everyone should know about</a></li>
<li><a href="../445806/index.html">How artificial intelligence changes science</a></li>
<li><a href="../445808/index.html">Hated and hounded: the dangerous life of a virus hacker, making powerful enemies</a></li>
<li><a href="../445814/index.html">How the delivery robot changed the culinary habits of American students</a></li>
<li><a href="../445816/index.html">How we sawed the server rendering and what came of it</a></li>
<li><a href="../445820/index.html">MVCC-3. String Versions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>