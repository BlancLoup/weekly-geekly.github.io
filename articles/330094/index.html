<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the issue of numbers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúWell, without a fight? Volleyball - so volleyball! ‚Äù 
 Well, USB is USB. 

 It is not in my rules to indulge the reader of the KDPV, but I could not ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On the issue of numbers</h1><div class="post__text post__text-html js-mediator-article"><h3>  ‚ÄúWell, without a fight?  Volleyball - so volleyball! ‚Äù <br>  Well, USB is USB. </h3><br><img src="https://habrastorage.org/web/8df/bb4/3bf/8dfbb43bf66e43c0becee2a263069810.png"><br>  <i>It is not in my rules to indulge the reader of the KDPV, but I could not resist.</i> <br><br>  But we begin, as promised, with the time service in the MK.  Consider the task associated with this service - there is a set of numbers and among them should be identified those that do not exceed some other preassigned number.  Turning to time, we can say that we will need to determine the moment when our current time (T) becomes an interval (I) greater than the origin of the interval (C). <br><br>  How can we solve this problem, and where is Oroboros? <br><a name="habracut"></a><br>  To begin, we must be able to get the number T, which characterizes the current moment in time (it would be nice to understand exactly how it relates to time, although it is not necessary, to get started, it‚Äôs enough to know the size of the number and the behavior of this number as time increases ‚Äî it increases or decreases ).  Next, we must be able to memorize the current T in some variable C (for which it is required that they be of the same type - that‚Äôs why we need to know the size).  Next, we should be able to associate the desired interval with a certain number of AND (and here we will need knowledge of the exact behavior of T) and we can carry out a simple comparison operation, implementing it in the form 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      T = C + AND <br><br>  - as soon as this equality is fulfilled, we have reached the point in time we need. <br><br>  Everything is good, but there is a slippage problem - time flows independently of our behavior, the variable T changes at the same time, and if for some reason we don‚Äôt make comparisons at the moment of equality, the condition will be lost and we will never know that the time has come for us (in fact, in the real world we will find out, but more on that later).  Therefore, the hard condition = should be replaced by soft&gt; =, or &lt;= if the variable T decreases with time and we get the condition T&gt; = C + AND, which is much more difficult to miss (if at all possible) and everything turns out just fine, it is not clear what will fill the rest of the post. <br><br>  In fact, this solution has the pitfalls, but they are underwater so that they are not immediately noticed.  Consider one of them, which so many times already hit the unwary navigators, which is not counted.  And this stone is called a limited width or overflow. <br><br>  The problem arises due to the fact that time is infinite, and the digit capacity of numbers in the MC is limited and we basically can not stretch an uncountable set to a countable number, this is an axiom.  Therefore, our number T, no matter how large it is, cannot uniquely determine a certain moment in time, but will have a period.  The duration of this period will be the maximum number, decreasing in T + 1, multiplied by the time of increasing T per unit Pr = (Max + 1) * To.  For example, if T is increased by 1 every microsecond, and T is 32 bits wide, then the period will be (2 ^ 32) * 1e-6 = 4 * (2 ^ 10) ^ 3 * 1e-6 ~ 4 * 10 ^ 3 ^ 3 * 1e-6 = 4 * 10 ^ (9-6) = 4000 seconds, which is just over an hour.  If T increases by 1 every millisecond, then the period will increase a thousand times and will be 4-6 seconds, that is, approximately 46 days.  Of course, the second value is much larger than the first, but they both fade in comparison with eternity. <br><br>  And what happens when our number reaches its maximum value - different options are possible: it can ‚Äúlie on the stops‚Äù and remain unchanged (but then we lose the ability to fix the continuation of the passage of time), it can begin to decrease (imitating the work of the pendulum, but then computational complexity) and can take the minimum value, usually it is zero (the latter phenomenon is called overflow). <br><br>  As you can increase the time interval after which this phenomenon will occur - you need to increase any of the factors, but increasing the first will entail complication of operations on working with the number T, and increasing the second will make it impossible to work with intervals less than the minimum step, which is not always acceptable.  Therefore, the choice of pitch and digit capacity is always a compromise, which allows not to overstate the requirements for the MK and not to reduce the usability of the work. <br><br>  There is another way to extend the period - to make the relationship between time and number T non-linear, best (and quite easily realizable on MC) a power function with a power less than one or a logarithm (piecewise linear approximation) fits, but this option is more theoretical interest, rather than a real solution, since the increment step and, accordingly, the accuracy increase with time, which is unacceptable for us. <br><br>  So what threatens us with the periodicity of T values ‚Äã‚Äãand the overflow (wraparound, recount, reroll, warp) associated with this - that the monotony of T's behavior is broken, that is, some next time point can be represented by a number not larger than the previous one (if we have T increases with time), and smaller and, accordingly, our formula will stop working, and manifestations of this will be very unpleasant - the program will form a time interval significantly smaller than expected. <br><br>  Here is a picture that should be kept in mind for understanding what is happening. <br><br><img src="https://habrastorage.org/web/0e7/701/d66/0e7701d66ff145bcbe9939dec7d15c2e.png"><br><br>  Consider an example of this, for brevity, we assume that T is placed in a byte and its maximum value is 255. If the initial time for forming the interval is C = 20, and the interval is And = 08, then, according to our formula, the time will expire from 28 that is correct, but in the case of C = 250, the condition 251&gt; = (250 + 8) = 258 - 256 = 2 will already be met at T = 251, which is clearly not in line with our expectations.  This will not happen too often, near the end of the period, and if you are absolutely sure that your device will never work so long, you can ignore this feature and use the previously proposed formula to track the time intervals that many library authors do.  I am categorically opposed to this practice for two reasons - firstly, one should always do the program correctly so that bad habits do not arise, and secondly, it is completely easy to do correctly. <br><br>  To get the right formula (true in any case), it is necessary to subject the original T&gt; = C + AND to a simple transformation and subtract C from both parts, getting a new condition T - C&gt; = I. From the point of view of mathematics, these conditions are equivalent, but mathematics works with ideal numbers that have an infinite width, although it is not at all helpless and in the case of limited numbers, you just need to impose appropriate conditions.  So, taking into account these conditions, our new formula always works correctly.  Of course, it is true in the case when T is more than C, but it works and when T is less than C, and this happens because of the remarkable property of subtraction.  Imagine T as <br><br>  T = C + D, where D is an additive in relation to the start, even if during this addition we could get an overflow and then the value T = C + D - Max &lt;S, in any case, our formula turns into <br><br>  (C + D) - C = C - C + D = D <br><br>  that is, we get the time interval we are looking for (or rather, the number that characterizes it) for any C and T. Why it happens that way - this is ordinary street magic, that is, the transition from the absolute to the relative coordinate system with the beginning at point C. <br><br>  The computational complexity of the original formula has one addition and one comparison, one subtraction and one comparison are modified, that is, they do not differ (addition, subtraction and comparison have the same complexity), so why not use the correct one, since it costs nothing.  The only limitation of this method should be noted - we cannot order an interval equal to or greater than the maximum representable, that is, we can order, but we will get a much smaller interval, and this is very bad, although it is obvious.  And one more, less obvious limitation - if we order an interval close to the maximum possible, there will be very few control points where the condition is met, and if we miss them, then we will go to the second round, and so on.  But even in this case, we are guaranteed that we will receive, at a minimum, what we have ordered, which is much better than nothing. <br><br>  So, we have created an absolutely correct method of counting time intervals, which works in all possible situations (of course, with these limitations in mind), but, as we know, there is no limit to perfection.  Let's take a closer look at the resources involved in this method - we need to remember two variables and we need to perform two operations like addition.  To reduce resource requirements, you need to return to the original formula. <br><br>  T&gt; = C + AND <br><br>  and pay attention to the fact that both quantities in the right part are known at the moment of the beginning of the interval formation and it is possible to calculate the moment of the end of the delay <br><br>   =  + , <br><br>  and the formula will turn into expression <br><br>  T&gt; = P. <br><br>  Unfortunately, its main drawback - the false triggering at overflow, remains in force, but we can go the tried and tested way and use the subtraction T - P&gt; = 0. <br><br>  Unfortunately, ordinary street magic has let us down (the fakir was drunk and the focus did not succeed), since this condition is always fulfilled, since the difference between any two numbers is a number from 0 to Mach and is always not less than zero.  Actually, the result is predictable, since for two arbitrary numbers it is completely impossible to determine which of them precedes the other from the word ‚Äúabsolutely‚Äù is impossible. <br><br>  Let us try to create an additional criterion and assume that T precedes  if (T - ) &lt;(&lt;- T).  Not bad for a start, but a direct calculation using this formula will require three subtractions - we will reduce it.  First of all we establish the indisputable fact that (T - P) + (P - T) = 0 = Mach + 1. <br><br>  From this obvious fact we can deduce that T - P will be greater than P - T in the case, and only if T - P&gt; = (Max + 1) / 2.  Since the second expression is quite obviously constant and will be calculated at the compilation stage, the resulting condition P - T&gt; = (Max + 1) / 2 requires only two subtraction operations, and we have already reduced the memory by one storage unit, but we can go further. <br><br>  Note that for the fulfillment of the latter condition, it is required that the most significant bit of the result be set, and we could use conditional jump commands for the value of the result bit, but they are far from being in every MC and the translator can use them not efficiently enough.  Fortunately, it is for working with the high bit that any MC has such commands and any translator implements them very well - commands for checking the sign of the number.  The fact is that, if we consider the result as a number in the additional code, then the sign is encoded in the most significant bit and checking that the most significant bit of the number contains one, and that the number is negative, coincide.  Therefore, our comparison condition can be written as T - P &lt;0. <br><br>  Let's pay attention to the fact that we perform the subtraction operation with no significant numbers and only interpret the result as a significant number during the comparison operation.  This circumstance must be taken into account when writing software that implements this algorithm, for example, for the C language, the corresponding fragment can be executed as follows: <br><br> <code>if ( (long) ( - ) &lt; 0) ....</code> <br> <br>  So, we need to remember only one number (P) and the computational complexity of the test is one subtraction operation (comparison will use its result and does not require additional operations), it is hardly possible to achieve the best indicators.  What we had to pay for such beauty - we now can not order an interval of more than half the maximum possible number, or rather, we can order, but it will stop instantly, so you decide whether it is worth winning such a limit.  In Linux systems, the last option is adopted, and the fact that the details are hidden behind the macro is syntactic sugar. <br><br>  Well, and finally, a little to the side - I discovered recently (actually long ago, just forgot) that I personally cannot call the behavior of the C compiler (at least some of them) logical.  For example, the following program fragment behaves completely differently than I would like: <br><br> <code>typedef unsigned char Timet; <br> Timet S = 0xF8, I = 12, T = S + I + 2; <br> // , MISRA,   ,  ,   ,      <br> if ( (T - S) &gt;= I) printf ( "time"); //    <br> register Timet D = (T - S); <br> if (D &gt;= I) printf ("time"); //    </code> <br>  It is completely incomprehensible to me why, in this form, I see only one message about the expiration of time, and if I change the Timet type to unsigned long, I get two messages.  That is, I, of course, dissemble, I understand why this is happening, I do not understand why this decision was made when implementing the compiler.  But, by the way, this problem is practically solved very easily - you enable MISRA support (rule 10.1.b) and get the ban on using the unsuccessful string and we have to do everything correctly, that is, reliably, we will simply be forced to write an intermediate assignment.  Moreover, this assignment does not cost anything and a good compiler will make a very effective code.  Yes, this is a crutch, ‚Äúbut it works,‚Äù unfortunately, there is simply no other solution. <br><br>  I must say that the following code fragment looks even more amusing. <br><br> <code>if ( (c = uc ) == uc) printf ( "is equal");</code> <br> <br>  during the execution of which you will not receive, quite reasonably, the expected message of equality for some values ‚Äã‚Äãof the variable uc, and we will not get "what is the worst thing, no <s>bicycle</s> warning".  And I do not need to say that these two bytes are not equal - they are equal and this is where the horror of the situation lies. </div><p>Source: <a href="https://habr.com/ru/post/330094/">https://habr.com/ru/post/330094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330084/index.html">How old are you? I'm 11</a></li>
<li><a href="../330086/index.html">Preview RamblerFront & # 1</a></li>
<li><a href="../330088/index.html">All Flash Isilon NAS: Scalable Storage for Unstructured Data</a></li>
<li><a href="../330090/index.html">How did the intro on 64k</a></li>
<li><a href="../330092/index.html">Monte Carlo and tic-tac-toe tree search</a></li>
<li><a href="../330096/index.html">How to make money on the Yandex.Money API</a></li>
<li><a href="../330098/index.html">Text online from the festival RIT ++ 2017. Day One</a></li>
<li><a href="../330100/index.html">Text online from the festival RIT ++ 2017. Day two</a></li>
<li><a href="../330102/index.html">How to teach computational thinking?</a></li>
<li><a href="../330104/index.html">On the eve of Heisenbag: Grid Dynamics about testing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>