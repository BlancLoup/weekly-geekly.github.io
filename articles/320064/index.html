<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular 2: why on TypeScript?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone who does not forget to look at our blog and traditionally non-working time of the day! 

 Long ago, in our publication of November 13, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular 2: why on TypeScript?</h1><div class="post__text post__text-html js-mediator-article"> Hello everyone who does not forget to look at our blog and traditionally non-working time of the day! <br><br>  Long ago, in our <a href="https://habrahabr.ru/company/piter/blog/270837/">publication</a> of November 13, 2015, you convinced us to wait for the finishing of Angular 2 and publish a book about it.  We are seriously going to take up such a project in the very near future, but for now we are offering to read a detailed answer to the question in the title of this post. <br><a name="habracut"></a><br>  Angular 2 is written in TypeScript.  In this article I will explain why this decision was made.  In addition, I will share my own experience with TypeScript;  what it is to write and refactor code. <br><br>  <b>I have TypeScript to my taste, but you may not.</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Yes, Angular 2 is written in TypeScript, but applications in Angular 2 can be written without it.  The framework interacts well with ES5, ES6 and Dart. <br><br>  <b>In TypeScript - a great toolkit</b> <br><br>  The main advantage of TypeScript is its tooling.  <b>It provides sophisticated auto-completion, navigation and refactoring.</b>  <b>In large projects, such tools are almost indispensable</b> .  You don‚Äôt always decide by yourself to change the code permanently, the entire code base is raw, and any large refactoring becomes risky and costly. <br><br>  TypeScript is not the only typed language that is compiled into JavaScript.  There are other languages ‚Äã‚Äãwith more stringent type systems that theoretically should provide absolutely phenomenal tools.  But in practice in most of them you will find almost nothing except the compiler.  <b>The fact is that the elaboration of a rich toolkit should be a priority goal from the very first day - this is exactly the goal set by the TypeScript team</b> .  That is why language services were created here that can be used in editors for type checking and autocompletion.  If you were wondering where such a large number of editors came from with excellent support for TypeScript - it is in language services. <br><br>  Intellectual input (intellisense) and the simplest refactoring (for example, renaming a character) drastically change the process of writing and, especially, code refactoring.  Although this indicator is difficult to measure, it seems to me that the refactorings, which were spent several days before, are now done in a few hours. <br><br>  Yes, TypeScript significantly optimizes code editing, but preparing for development with it is more difficult than, say, taking and throwing an ES5 script on a page.  In addition, you lose JavaScript tools to analyze source code (for example, JSHint), but they usually have adequate replacements. <br><br>  <b>TypeScript is a superset of JavaScript</b> <br><br>  Since TypeScript is a superset of JavaScript, you do not need to radically rewrite code when migrating to this language.  This can be done gradually, module by module. <br>  Just take the module, rename the <code>.js</code> files in it to <code>.ts</code> , and then gradually add type annotations.  Finished with the module - go to the next.  When the entire code base is typed, you can start messing around with the compiler settings, making them stricter. <br><br>  The whole process may take some time, but when we migrated Angular 2 to TypeScript, in the process we managed to not only develop new functions, but also fixed bugs. <br><br>  <b>In TypeScript, abstractions become apparent.</b> <br><br>  <b>Good design is well defined interfaces.</b>  <b>And to express the idea of ‚Äã‚Äãan interface is much easier in a language that interfaces support.</b> <br><br>  Suppose there is an application for buying books.  Books in it are acquired in two ways: a registered user can do this through a graphical interface, and others through an external system, which connects to the application through an API. <br><br><img src="https://habrastorage.org/files/50f/085/0b0/50f0850b0592403aafabde18cbfdbb35.png"><br><br>  As you can see, the role of both classes in this case is the ‚Äúbuyer‚Äù.  Despite the importance of the ‚Äúbuyer‚Äù role in this application, it is clearly not expressed in the code.  There is no <code>purchaser.js</code> file.  Therefore, someone can change the code and not even notice that such a role exists. <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processPurchase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(purchaser, details)</span></span></span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExternalSystem</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  If you simply view the code, it is difficult to say which objects can act as a buyer.  Surely we do not know, and our tools are not particularly help us in this.  Such information has to be fished manually - and this is a slow matter, fraught with errors. <br><br>  And here is the version in which we explicitly define the <code>Purchaser</code> interface. <br><br><pre> <code class="hljs axapta"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Purchaser</span></span></span><span class="hljs-class"> </span></span>{id: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; bankAccount: Account;} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Purchaser</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExternalSystem</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Purchaser</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br>  In the typed version, it is clearly indicated that we have the <code>Purchaser</code> interface, and the <code>User</code> and <code>ExternalSystem</code> classes implement it.  So TypeScript interfaces allow you to define abstractions / protocols / roles. <br><br>  <b>It is important to understand that TypeScript does not force us to add unnecessary abstractions</b> .  Abstraction "Buyer" is in the JavaScript code, just there it is clearly not defined. <br><br>  <b>In a statically typed language, the boundaries between subsystems are defined using interfaces.</b>  <b>Since there are no interfaces in JavaScript, defining borders in pure JavaScript is more difficult.</b>  <b>If the boundaries for the developer are not obvious, then it depends on the concrete types, and not on the abstract interfaces, which provokes strong binding</b> . <br><br>  From experience with Angular 2 before and after the transition to TypeScript, this belief has only strengthened.  Defining the interface, I have to think over the boundaries of the API, it helps me to outline the public interfaces of the subsystems and immediately identify the binding, if it happens by chance. <br><br>  <b>TypeScript makes it easier to read and understand code</b> <br><br>  Yes, I know that at first glance it does not seem so.  Then consider an example.  Take the <code>jQuery.ajax()</code> function.  What information is clear from her signature? <br><br>  All that can be said for sure - this function takes two arguments.  Types can try to guess.  Perhaps, first comes the line, and after it - the configuration object.  But this is just a version, perhaps we are mistaken.  We do not imagine what options can be in the settings object (neither their names, nor types), we do not know what this function returns. <br><br>  It is not known how to call this function, it is necessary to check with the source code or documentation.  Checking the source code is not the best option;  what's the use of functions and classes, if it is not clear how they are implemented.  In other words, you need to rely on their interfaces, and not on the implementation.  You can check the documentation, but the developers will confirm that this is a thankless job - time is spent on checking, and the documentation itself is often irrelevant. <br><br>  So, it is <code>jQuery.ajax(url, settings)</code> to read <code>jQuery.ajax(url, settings)</code> , but in order to understand how to call this function, you need to read in either its implementation or the documentation. <br><br>  Now compare with the typed version. <br><br><pre> <code class="hljs cs">ajax(url: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, settings?: JQueryAjaxSettings): JQueryXHR; <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">JQueryAjaxSettings</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>?: boolean; cache?: boolean; contentType?: any; headers?: { [key: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]: any; }; <span class="hljs-comment"><span class="hljs-comment">//... } interface JQueryXHR { responseJSON?: any; //... }</span></span></code> </pre> <br>  This version is much more informative: <br><br><ul><li>  The first argument to this function is a string. </li><li>  The <code>settings</code> argument is optional.  We see all the parameters that can be passed to the function - not only their names, but also their types. </li><li>  The function returns a <code>JQueryXHR</code> object, we see its properties and functions. </li></ul><br>  A typed signature is definitely longer than untyped, but <code>:string</code> <code>:JQueryAjaxSettings</code> and <code>JQueryXHR</code> are not garbage.  This is an important "documentation", thanks to which the code is easier to read.  You can understand the code much deeper, without going into the implementation or reading of documents.  Personally, I read typed code faster, because types are a context that helps you understand the code.  But, if someone from the readers finds a study on how types affect readability, please leave a link in the comments. <br><br>  One of the important differences between TypeScript and many other languages ‚Äã‚Äãcompiled in JavaScript is that type annotations are optional, and jQuery.ajax (url, settings) is a real valid TypeScript.  So, types in TypeScript can be compared not with a switch, but with an adjustment dial.  If you think that the code is trivial, and it can be read without type annotations - do not use them.  <b>Use types only when they are useful</b> . <br><br>  <b>TypeScript limits expressiveness?</b> <br><br>  Tools in languages ‚Äã‚Äãwith dynamic typing are so-so, but they are more plastic and expressive.  I think with TypeScript your code will become slower, but to a much lesser extent than it might seem.  Now I will explain.  Suppose I use ImmutableJS to define a <code>Person</code> record. <br><br><pre> <code class="hljs pgsql">const PersonRecord = <span class="hljs-type"><span class="hljs-type">Record</span></span>({<span class="hljs-type"><span class="hljs-type">name</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, age:<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> createPerson(<span class="hljs-type"><span class="hljs-type">name</span></span>, age) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PersonRecord({<span class="hljs-type"><span class="hljs-type">name</span></span>, age}); } const p = createPerson("Jim", <span class="hljs-number"><span class="hljs-number">44</span></span>); expect(p.name).toEqual("Jim");</code> </pre><br>  How to typify such a record?  First, let's define an interface called Person: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">interface</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Person</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">name</span></span>: string, age: number };</code> </pre> <br>  If we are trying to do this: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name: string, age: number)</span></span></span><span class="hljs-function">: Person </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PersonRecord({name, age}); }</code> </pre> <br>  then the TypeScript compiler swears.  He does not know that PersonRecord is actually compatible with Person, because PersonRecord was created reflexively.  Some readers familiar with the OP may say: ‚ÄúOh, if there were dependent types in TypeScript!‚Äù But they are not here.  TypeScript's type system is not the most advanced.  But our goal is different: not to prove that the program is 100% correct, but to provide you with more detailed information and better tools.  Therefore, it is quite possible to cut corners if the type system is not very flexible. <br><br>  The created record can be easily brought, like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> createPerson(<span class="hljs-type"><span class="hljs-type">name</span></span>: string, age: number): Person { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PersonRecord({<span class="hljs-type"><span class="hljs-type">name</span></span>, age}); }</code> </pre> <br>  Typed example: <br><br><pre> <code class="hljs pgsql">interface Person { <span class="hljs-type"><span class="hljs-type">name</span></span>: string, age: number }; const PersonRecord = <span class="hljs-type"><span class="hljs-type">Record</span></span>({<span class="hljs-type"><span class="hljs-type">name</span></span>:<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, age:<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> createPerson(<span class="hljs-type"><span class="hljs-type">name</span></span>: string, age: number): Person { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">any</span></span>&gt;<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> PersonRecord({<span class="hljs-type"><span class="hljs-type">name</span></span>, age}); } const p = createPerson("Jim", <span class="hljs-number"><span class="hljs-number">44</span></span>); expect(p.name).toEqual("Jim");</code> </pre><br>  This works because the type system is structural.  If the created object has the necessary fields - name and age - then everything is in order. <br><br>  It is necessary to get used to that when working with TypeScript, ‚Äúcut corners‚Äù is normal.  Only then will you be pleased to deal with this language.  For example, do not try to add types to some fancy code for metaprogramming - most likely, you simply cannot express it statically.  Conjugate this code and order the type checking system to ignore the artsy part.  In this case, you hardly lose any expressiveness, but the bulk of the code will remain convenient for processing and analysis. <br><br>  The situation resembles an attempt to provide one hundred percent coverage with unit tests.  95% is usually done without problems, but to achieve 100% is already a task, and this coverage can adversely affect the architecture of the entire application. <br><br>  <b>With the optional type system, the JavaScript development cycle is also preserved</b> .  Large fragments of the code base may be ‚Äúbroken‚Äù, but you can still run them.  TypeScript will still generate javascript even if the type-checking system is not satisfied.  During development, this is extremely convenient. <br><br>  <b>Why typeScript?</b> <br><br>  Today, front-end vendors have a wide choice of development tools: ES5, ES6 (Babel), TypeScript, Dart, PureScript, Elm, etc.  Why typeScript? <br><br>  Let's start with ES5.  ES5 has one major advantage over TypeScript: no transpiler is required here.  Therefore, the entire development is easy to organize.  There is no need to set up file watchers, transpose code, generate code maps.  Everything just works. <br><br>  In ES6, a transpiler is needed, so the assembly itself will be organized roughly as in TypeScript.  But this is a standard, meaning that one and all editors or build tools either support ES6 or will support it.  Currently, most TypeScript editors are already well supported. <br><br>  Elm and PureScript are beautiful languages ‚Äã‚Äãwith powerful type systems that can give your program much more than TypeScript.  The code on Elm and PureScript can be much more concise than on ES5. <br><br>  Each of these options has its advantages and disadvantages, but it seems to me that TypeScript is the golden mean and is perfect for most projects.  TypeScript has 95% of the virtues of good statically typed languages, and brings these advantages to the JavaScript ecosystem.  The feeling is almost the same as you write in ES6: you use the same standard library, the same third-party libraries, idioms and many familiar tools (for example, the ‚ÄúDevelopment‚Äù section in Chrome).  You get a lot of everything, without leaving the usual JavaScript ecosystem. </div><p>Source: <a href="https://habr.com/ru/post/320064/">https://habr.com/ru/post/320064/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320054/index.html">Conducting research in modern conditions</a></li>
<li><a href="../320056/index.html">New quick start with PHPixie: we build quote-by-commit commit</a></li>
<li><a href="../320058/index.html">Application Insights. About analytics and other new tools</a></li>
<li><a href="../320060/index.html">Security Week 03: the sunset of SHA-1 continues, a bug or feature in Whatsapp, vulnerabilities in routers are not repaired</a></li>
<li><a href="../320062/index.html">Where to move with Parse Push?</a></li>
<li><a href="../320066/index.html">ERP CRM Consultant ‚Äî Eternal Negotiator</a></li>
<li><a href="../320070/index.html">Finite Difference Programming</a></li>
<li><a href="../320072/index.html">Writing a universal UICollectionViewLayout</a></li>
<li><a href="../320074/index.html">How to train your dragon. Short example on clang-c</a></li>
<li><a href="../320076/index.html">Zones / circles / spheres of influence, control and interest - a model of personal development strategy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>