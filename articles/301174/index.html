<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generics in Kotlin vs. Generics in JAVA: similarities, differences, features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is about Generics in Kotlin - features of their use, similarities and differences with Generics in Java. 

 In a nutshell about Generics ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generics in Kotlin vs. Generics in JAVA: similarities, differences, features</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/redmadrobot/blog/301174/"><img src="https://habrastorage.org/files/311/e39/e6f/311e39e6f7c148118698f6c251141ec4.png"></a> <br>  This article is about Generics in Kotlin - features of their use, similarities and differences with Generics in Java. <br><br><div class="spoiler">  <b class="spoiler_title">In a nutshell about Generics</b> <div class="spoiler_text">  In short, Generics is a way of saying that a class, interface or method will work not with some particular type, but simply with some kind.  How exactly will be determined from the context.  For example: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  It is not known in advance which objects of the class will be contained in the list, but this will be determined when using it: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs">List&lt;String&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;();</code> </pre> <br>  Now it‚Äôs not just a list, but a list of strings.  Generics help ensure type safety: you can try to put any object in the List, but in List &lt;String&gt; only String or one of its descendants. </div></div><br>  I will divide the story about Generics into two parts: the actual Generics and the use of Wildcards.  While we are not talking about Wildcards, the use of Generics in Kotlin is not much different from Java. <br><a name="habracut"></a><br>  The same generic classes: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java public class SomeGenericClass &lt;T&gt; { private T mSomeField; public void setSomeField(T someData) { mSomeField = someData; } public T getSomeField() { return mSomeField; } }</span></span></code> </pre> <br><pre> <code class="hljs pgsql">// Kotlin <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SomeGenericClass &lt;T&gt; { private var mSomeField: T? = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> fun setSomeField(someData: T?) { mSomeField = someData } fun getSomeField(): T? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mSomeField } }</code> </pre> <br>  The same generic methods: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java public &lt;K&gt; K makeSomething(K someData) { K localData = someData; //... return localData; }</span></span></code> </pre> <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// Kotlin fun &lt;K&gt; makeSomething(someData : K) : K { var localData = someData //... return localData }</span></span></code> </pre> <br>  Generics can be further restricted in Java: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java public &lt;K extends Number&gt; K makeSomething(K someData) { K localData = someData; //... return localData; }</span></span></code> </pre> <br>  And in Kotlin: <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// Kotlin fun &lt;K : Number&gt; makeSomething(someData : K) : K { var localData = someData //... return localData }</span></span></code> </pre> <br>  Such restrictions mean that instead of K, not any class can be used, but only satisfying the condition (in this case, Number or the class that inherits it). <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// makeSomething(1) // makeSomething(‚Äústring‚Äù)</span></span></code> </pre> <br>  Constraints can be complex, for example, showing that an object passed to a method must inherit a class and implement an interface, for example: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java public static &lt;T extends Interaction &amp; Fragment&gt; SomeFragment newInstance(T interactor) { SomeFragment fragment = new SomeFragment(); fragment.setTargetFragment(interactor, 0); return fragment; }</span></span></code> </pre> <br><pre> <code class="hljs pgsql">//Kotlin fun &lt;T&gt; newInstance(interactor : T) : SomeFragment <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Interaction, T : Fragment { val fragment = SomeFragment() fragment.setTargetFragment(interactor, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fragment }</code> </pre> <br>  Please note that Kotlin uses a different syntax for complex constraints: added some syntax sugar.  You can omit the type parameter if it can be defined by context: <br><br><pre> <code class="hljs lisp">// Kotlin val someGenericClassInstance = SomeGenericClass(<span class="hljs-string"><span class="hljs-string">"This is String"</span></span>)</code> </pre> <br>  And in Java it is necessary: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java SomeGenericClass&lt;String&gt; someGenericClassInstance = new SomeGenericClass&lt;&gt;("This is String");</span></span></code> </pre> <br>  Thus, the main thing you need to know about Generics when switching from Java to Kotlin - do everything the same way you did in Java.  Attempts to do something in a new way, ‚Äúin Kotlinov style,‚Äù are likely to lead only to new difficulties. <br><br><h2>  Wildcards </h2><br>  We turn to the second part.  Wildcards is a special case that causes the most difficulty in both Kotlin and Java.  The main problem of Generics is their invariance: List &lt;String&gt; is not a descendant of List &lt;Object&gt;.  Otherwise, errors like this might occur: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java List&lt;String&gt; strs = new ArrayList&lt;String&gt;(); List&lt;Object&gt; objs = strs; //objs - List&lt;Object&gt;,      Integer objs.add(1); // strs - List&lt;String&gt;,   get()   String String s = strs.get(0);</span></span></code> </pre> <br>  Generics invariance allows you to prevent this, but, on the other hand, introduces additional restrictions.  Thus, when using conventional Generics, it is not possible to pass List &lt;String&gt; to a method that expects List &lt;Object&gt; as a parameter.  In many cases it is convenient to have such an opportunity. <br><br>  Wildcards allow you to allow this behavior, denoting that in this place is expected some type parameter, but not some specific.  At the same time, Wildcards can also be specifically limited, which splits the question into 3 parts: <br><ul><li>  unlimited wildcards </li><li>  covariant wildcards </li><li>  contravariant wildcards </li></ul><br><br>  <i>Restricted ‚Äúfrom below‚Äù covariant Wildcards</i> are used in cases when a generic class is expected from some class or its descendants.  For example: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java public interface Container&lt;T&gt; { T getData(); void putData(T data); } static void hideView(Container&lt;? extends View&gt; viewContainer) { viewContainer.getData().setVisibility(View.GONE); }</span></span></code> </pre> <br>  Here, the hideView method expects an object that implements the Container interface, but not any and not just the containing View, but the containing View or some other class that inherits the View.  This is called covariance. <br><br>  In Kotlin, this behavior can be implemented in a similar way: <br><br><pre> <code class="hljs haskell">// <span class="hljs-type"><span class="hljs-type">Kotlin</span></span> interface <span class="hljs-type"><span class="hljs-type">Container</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; { fun getData() : <span class="hljs-type"><span class="hljs-type">T</span></span> fun putData(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">) } fun hideView (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">viewContainer</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Container</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">out</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">View</span></span></span><span class="hljs-class">&gt;) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">viewContainer</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getData</span></span></span><span class="hljs-class">().</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">visibility</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">View</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GONE</span></span></span><span class="hljs-class">; }</span></span></code> </pre> <br>  However, the use of the parameter declared as Wildcards is subject to additional restrictions. <br><br>  In Java, covariant Wildcards can be used to obtain data without restrictions, while the data will be returned in accordance with the indicated boundary (in the example above, getData () will return the View, even if the container actually contained a TextView).  But nothing can be put into it except null, otherwise it would cause the same problems that Generics would have had if they had not been invariant. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java static void hideView(Container&lt;? extends View&gt; viewContainer) { //getData()  View        , , TextView viewContainer.getData().setVisibility(View.GONE); //    null,   ,         //   viewContainer.putData(null); //  - ,        , , Container&lt;ImageView&gt; viewContainer.putData(new View(App.getContext())); }</span></span></code> </pre> <br>  In Kotlin, the limitations are almost the same.  Due to the nature of the types in Kotlin, it is impossible even to put null inside this parameter.  The out keyword perfectly describes what is happening. <br><br><pre> <code class="hljs pgsql">//Kotlin fun hideView (viewContainer : Container&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>&gt;) { viewContainer.getData().visibility = <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>.GONE; //   ,   ,   <span class="hljs-keyword"><span class="hljs-keyword">View</span></span> ( -   )  <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>? viewContainer.putData(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) }</code> </pre> <br>  <i>Contravariant Wildcards bounded ‚Äúfrom above‚Äù</i> are used to designate places where a generic class is expected from a certain class or its ancestors.  The traditional example of contravariant Wildcards is comparators: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; comparator) { //... }</span></span></code> </pre> <br>  Suppose a List &lt;String&gt; is passed to the method as the first parameter, and a comparator from any of the String ancestors, for example, CharSequence: Comparator &lt;CharSequence&gt;, as the second parameter.  Since the String is a descendant of CharSequence, any fields and methods necessary for the comparator will also be in the objects of the String class: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//Java class LengthComparator implements Comparator&lt;CharSequence&gt; { @Override public int compare(CharSequence obj1, CharSequence obj2) { //   String       if (obj1.length() == obj2.length()) return 0; if (obj1.length() &lt; obj2.length()) return -1; return 1; } }</span></span></code> </pre> <br>  In Kotlin, the implementation is similar: <br><br><pre> <code class="hljs xml">// Kotlin fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> sort(list : List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>, comparator: Comparator<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">in</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span><span class="hljs-tag">&gt;</span></span>) { //‚Ä¶ }</code> </pre> <br>  Contravariant Wildcards have quite expected limitations: you can read the value from such Wildcards, but will return Object in Java and Any?  in kotlin. <br><br>  At this stage I repeat: switching from Java to Kotlin, you should do everything the same way you did.  Although ‚ÄúKotlin doesn't have any‚Äù is written in the official documentation about Wildcards, the type projections mechanism (discussed above) offered instead of this works in all usual cases in a similar way, no new approaches are required. <br><br>  But not without innovations.  In addition to type projections, a completely similar familiar Wildcards model in Java, Kotlin offers another mechanism - the declaration-side variance. <br><br>  If it is known in advance that a generic class will be used only as a covariant (or only as contravariant), this can be indicated at the time of writing the generic class, and not at the time of its use.  As an example, comparators are again suitable.  Rewritten to Kotlin, java.util.Comparator might look like this: <br><br><pre> <code class="hljs pgsql">// Kotlin interface Comparator&lt;<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> T&gt; { fun compare(lhs: T, rhs: T): <span class="hljs-type"><span class="hljs-type">Int</span></span> override fun equals(other : <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>?): <span class="hljs-type"><span class="hljs-type">Boolean</span></span> }</code> </pre> <br>  And then its use will be as follows: <br><br><pre> <code class="hljs xml">// Kotlin fun <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> sort(list : List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>, comparator: Comparator<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span>) { //‚Ä¶ }</code> </pre> <br>  At the same time, restrictions on the use of the parameter comparator will be the same as if &lt;in T&gt; were indicated not on the side of the interface declaration, but on the side of its use. <br><br>  Likewise, the covariant behavior can be defined with a class declaration. <br><br>  The latter case is not disassembled - <i>Wildcards without restrictions</i> .  Such, obviously, are used in cases when generic from any class is suitable: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java public interface Container&lt;T&gt; { T getData(); void putData(T data); } static boolean isNull(Container&lt;?&gt; container) { return container.getData() != null; }</span></span></code> </pre> <br>  In Kotlin, a similar mechanism is called star-projection.  In all trivial cases, its only difference from unlimited Wildcards in Java is the use of the ‚Äú*‚Äù symbol instead of the ‚Äú?‚Äù: <br><br><pre> <code class="hljs haskell">// <span class="hljs-type"><span class="hljs-type">Kotlin</span></span> interface <span class="hljs-type"><span class="hljs-type">Container</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt; { fun getData() : <span class="hljs-type"><span class="hljs-type">T</span></span> fun putData(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">); } fun isNull(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Container</span></span></span><span class="hljs-class">&lt;*&gt;) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Boolean</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">getData</span></span></span><span class="hljs-class">() != </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">null</span></span></span><span class="hljs-class">; }</span></span></code> </pre> <br>  In Java, unlimited Wildcards are used according to the following rules: you can only put null in them, the Object is always read.  In Kotlin, nothing can be put inside, but an object of class Any can be read? .. <br><br>  When sharing the declaration-side variance and star-projection, one must take into account that the limitations are summed up.  So, when using contravariant Declaration-side variance (allowing you to put everything in, but counting Any only?) You can‚Äôt put anything inside (star-projection restriction) and the same Any?  (in this their limitations coincide). <br><br>  To read about Generics in general, please follow the links: <br>  <a href="http://www.oracle.com/technetwork/articles/java/juneau-generics-2255374.html">www.oracle.com/technetwork/articles/java/juneau-generics-2255374.html</a> <br>  <a href="http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html">www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html</a> </div><p>Source: <a href="https://habr.com/ru/post/301174/">https://habr.com/ru/post/301174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301152/index.html">Flexible configuration with PHPixie</a></li>
<li><a href="../301154/index.html">Friday format: Unusual data center solutions</a></li>
<li><a href="../301156/index.html">Report from Moscow CocoaHeads Meetup April 29</a></li>
<li><a href="../301166/index.html">Functional autotest</a></li>
<li><a href="../301172/index.html">Two availability, or why accessibility and availability are not the same</a></li>
<li><a href="../301176/index.html">R in Microsoft Azure to win the hackathon. Instructions for use</a></li>
<li><a href="../301178/index.html">Exploration and engineering: 3D-models of buildings, junctions and quarries by photo</a></li>
<li><a href="../301180/index.html">Digest of recent advances in cryptography. Zero release</a></li>
<li><a href="../301182/index.html">[St. Petersburg, Announcement] Meeting with Andrey Pangin - Everything you wanted to know about stack-traces and hip dumps</a></li>
<li><a href="../301186/index.html">Magento 2: cookies, registry, session</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>