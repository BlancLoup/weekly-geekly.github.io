<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Past and Future of JavaScript Compilation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Now we take for granted the fast execution of js-code in browsers, and every day there are more and more inspiring examples of what can be implemented...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Past and Future of JavaScript Compilation</h1><div class="post__text post__text-html js-mediator-article">  Now we take for granted the fast execution of js-code in browsers, and every day there are more and more inspiring examples of what can be implemented using JS.  But this was not always the case.  In this article we‚Äôll talk about JS engines that are responsible for compiling code in browsers, their historical acceleration path and possible future paths. <br><br>  The first engine interpreting the js-code was SpiderMonkey, which was introduced in the Netscape 2.0 browser in 1995. The myth of its rapid creation is well <a href="http://www.computer.org/csdl/mags/co/2012/02/mco2012020007.html">documented</a> .  Brendan Ike had only 10 days to design a language and build a compiler.  Javascript was successful from the start, and by August, Microsoft had already embedded its version of JScript in Internet Explorer 3.0 by the same code.  By the end of 1996, the language was accepted into the commission for formal standardization, and in June of the following year it acquired the official standard ECMA-262.  Since then, JS support has become mandatory for each browser, and each major manufacturer began to build its own engine to support JS.  Over the years, these engines have evolved, replaced each other, were renamed, and became the basis for the following engines.  Tracking all created versions is not a task for the faint of heart. <br><a name="habracut"></a><br><img src="http://rghost.ru/46609226/image.png" alt="image"><br><br>  For example, few people now remember the KDE Konquerer browser, which used its open source KJS engine.  Subsequently, the Apple developers ‚Äúforked‚Äù this project and developed the WebKit core to the future, replacing several names during the evolution process: <a href="http://trac.webkit.org/wiki/SquirrelFish">Squirrelfish</a> , <a href="https://www.webkit.org/blog/214/introducing-squirrelfish-extreme/">Squirrelfish Extreme</a> , <a href="https://www.apple.com/uk/pr/library/2009/02/24Apple-Announces-Safari-4-The-Worlds-Fastest-Most-Innovative-Browser.html">Nitro</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Opposite processes also took place to be.  There are engines, whose names have remained unchanged, while all the insides have been changed.  For example, in Mozilla‚Äôs <a href="https://developer.mozilla.org/en/docs/SpiderMonkey">SpiderMonkey</a> there is no hint of code that existed in 1995. <br><br>  By the mid-2000s, JavaScript was standardized and very common, but its execution was still slow.  The race for speed began in 2008, when a number of new engines appeared.  In early 2008, Futhark from Opera was the fastest engine.  By the summer, Mozilla introduced Tracemonkey, and Google launched its Chrome with a new JavaScript JavaScript V8.  Despite the abundance of names, they all tried to do the same thing, and each project wanted to compare favorably in the speed of execution.  Since 2008, the engines have been improved by optimizing their design, and the main players have been racing for building the fastest browser. <br><br>  When we talk about the JavaScript engine, we usually mean the compiler, and making the code generated by the compiler faster is what is the real challenge.  Probably, not all writing JS programs fail to understand how the compiler works. <br>  This implies that JavaScript is a high-level language.  This means that it is readable and has a high degree of flexibility.  Compiler's job is to form native code from this human-readable code. <br><br>  Usually compilation takes place in 4 stages: <br><br>  1. At the stage of lexical analysis (scanning), the compiler scans the source code and breaks it into separate components called tokens.  This is usually achieved through regular expressions. <br>  2. The parser structures reworked code into a syntax tree. <br>  3. Then this structure is converted by bytecode to translator.  In the simplest case, the translation can be represented as a mapping of tokens in their view bytecode. <br>  4. In the end, the bytecode passes through the bytecode interpreter to get the native code. <br><br>  This is a classic design of compilers, and it has been used for many years.  But the requirements of desktop applications are very different from the requirements of browsers, and this architecture began to experience difficulties in a number of ways.  The elimination of these contradictions was the result of a race for speed between browsers. <br><br><h5>  Fast, elegant, right </h5><br>  JavaScript is a very flexible language and is quite tolerant to ‚Äúon the verge of foul‚Äù constructions.  So how do you write a compiler for a weakly typed, dynamic language with late binding?  Before you make it fast, you need to make it neat.  As Brendan Ike put it, <br>  ‚ÄúFast, elegant, correct.  Select 2, considering that the 'correct' is already selected. ‚Äù <br>  ‚ÄúFast, Slim, Correct.  Pick any two, so long as one is 'Correct' ‚Äù <br><br>  Mozilla's Jesse Ruderman has created a very useful <a href="http://www.squarefree.com/2007/08/02/introducing-jsfunfuzz/">jsfunfuzz</a> tool for testing compiler validity.  Brendan called this a parody of the JavaScript compiler, as his goal is to create the strangest but valid constructions that are sent to the compiler for verification.  The tool revealed numerous extreme cases and bugs. <br><br><h5>  JIT compilers </h5><br>  The main problem with classical architecture is that the interpretation of the bytecode at runtime is rather slow.  Performance can be improved by completing the bytecode compilation into machine code, but this will require a long wait for users to load web pages. <br><br>  The solution is ‚Äúlazy compilation‚Äù, or ‚Äúon the fly‚Äù compilation.  As the name implies, pieces of code are compiled into machine code by the time it is needed.  JIT compilers have appeared in various technologies, with different optimization strategies.  Some are sharpened by optimizing individual commands, others by optimizing repetitive operations, such as loops and functions.  Modern JavaScript-engine uses several such compilers, working together to improve the performance of your code. <br><br><h5>  Javascript jit compilers </h5><br>  The first JavaScript JIT compiler was Mozilla's TraceMonkey.  This was the so-called tracing JIT, since it tracks the most repeated cycles.  These ‚Äúhot loops‚Äù are compiled into machine code.  Only through this optimization alone did Mozilla get performance improvements from 20% to 40% compared to their previous engine. <br><br>  Soon after launching TraceMonkey, Google released Chrome along with a new V8 engine.  V8 was designed specifically to optimize speed.  The main architectural solution was the rejection of the generation of bytecode, instead of which the translator directly generates native code.  During the year after launch, the team also applied register allocation, improved inline caching, and completely rewritten the regular expression engine, making it 10 times faster.  This combined increased the speed of JavaScript execution by 150%.  The race for speed went on! <br><br>  Later, browser manufacturers introduced compilers with an extra step.  After a control flow graph or syntax tree has been generated, the compiler can use this data for further optimizations before generating native code.  Examples of such compilers are <a href="https://wiki.mozilla.org/Platform/Features/IonMonkey">IonMonkey</a> and <a href="http://blog.chromium.org/2010/12/new-crankshaft-for-v8.html">Crankshaft</a> . <br><br>  The ambitious goal of all these transformations is to execute JavaScript code at native C speed. A few years ago, this goal seemed incredible, but the gap in execution speed is getting shorter. <br><br>  Now about some particular features of JS compilation. <br><br><h6>  Hidden Classes </h6><br>  Since in JavaScript, building objects and structures is fairly simple for a developer, navigation through these loosely determined structures can be very slow for the compiler.  For example, in C, a hash table is the usual way to store properties and access properties.  The problem with a hash table is that a search on a very large hash table can be very slow. <br>  To speed up this process, both V8 and SpiderMonkey use hidden classes ‚Äî an internal representation of your JavaScript objects.  In Google, they are called maps, and in Mozilla - shapes, but this is essentially the same thing.  These structures are much faster to search than a standard dictionary search. <br><br><h6>  Type inference </h6><br>  Dynamic typing Javascript is what allows the same property to be a number in one place and a string in another.  Unfortunately, this diversity leads to numerous additional type checks in the compiler, and the code with conditional checks is much longer and slower than the code defined for variable types. <br><br>  The solution is a type inference method that is available in all modern JS compilers.  The compiler makes assumptions about the data types of the properties.  If the assumption is true, it passes the execution to a typed JIT that generates fast machine code for these sections.  If the type does not match, then the code is transferred to the untypical JIT, for execution on a slower code with condition checks. <br><br><h6>  Inline caching </h6><br>  This is the most common optimization in modern JavaScript compilers.  This is not a new technique (first used 30 years ago for the Smalltalk compiler), but very useful. <br><br>  Inline caching requires both previous techniques for their work: type inference and hidden classes.  When the compiler detects a new class, it caches its hidden class along with all the specific types.  If this structure is encountered later, it can be quickly compared with the stored cache.  If the structure or data type has changed, they are transferred to a slower generalized (generic) code or in some compilers polymorphic inline caching is performed ‚Äî a separate cache of one structure is generated for each data type.  Read more about this in the article by Vyacheslav Egorov from the V8 team. <br>  When the compiler obtains the structure of the code and the data types in it, various additional optimizations become possible.  Here are just a few examples: <br><br><h6>  inline expansion, or ‚Äúinlining‚Äù </h6><br>  Calling a function is an expensive operation because it requires some kind of search, and the search can be slow.  The idea is to put the body code of the function in the place where it is called.  This avoids unnecessary branching, and speeds up execution, but at the expense of increasing the size of the executable code. <br><br><h6>  invariant cycle changes, ‚Äúlift‚Äù </h6><br>  Cycles are the first candidate for optimization.  By removing unnecessary calculations from the loop, you can greatly improve performance.  The simplest example is a for loop on an array element.  Calculate the length of the array at each iteration is unprofitable, so this operation is carried out, ‚Äúrises‚Äù for the cycle. <br><br><h6>  convolution of constants </h6><br>  Constant expressions are calculated, as well as expressions containing immutable variables. <br><br><h6>  removal of common subexpressions </h6><br>  Similar to the constants design, the compiler searches for expressions containing the same computations.  These expressions can be replaced with variables with calculated values. <br><br><h6>  dead code removal </h6><br>  Code that is not used or cannot be reached.  It makes no sense to optimize the body of the function, which is never used, you can simply delete it. <br><br>  This is just a small set of simple tools, demonstrating the direction in which browser manufacturers are working to achieve their ambitious goals.  Many of them have made long-term investments in the concept of the web as an operating system.  To achieve this, they set the task of executing JavaScript code at the speed of native C, and gradually erasing the difference between native and web applications. <br><br>  <b>ES.next</b> <br><br>  The next version of the EcmaScript specification (EcmaScript 6) has long been in operation, the final version is expected this year.  One of the stated goals of the project is a quick compilation.  A set of means by which this can be achieved is discussed, including typing, binary data, and typed arrays.  Typed code can be sent directly to JIT, speeding up compile and execute time. <br><br>  The support of ES.next by browsers is still quite limited, but you can follow it at least <a href="http://kangax.github.io/es5-compat-table/es6/">here</a> , you can also start testing with <a href="https://code.google.com/p/traceur-compiler/">Traceur</a> - the ES.next compiler in JavaScript, written in JavaScript. <br><br><h5>  Webgl </h5><br><br>  JavaScript in the browser is not limited to DOM manipulations.  A large number of modern browser games are rendered directly to the canvas element of the page, using the standard 2D context.  The fastest way to render on canvas is WebGL, an API that provides optimization by transferring expensive operations to the GPU, leaving the CPU for the application logic. <br><br>  WebGL <a href="http://caniuse.com/webgl">in some form is supported in most browsers</a> , primarily in Chrome and Firefox.  Safari and Opera users must first enable the corresponding option.  Microsoft also recently announced WebGL support in IE11. <br><br>  Unfortunately, even with full browser support, you cannot guarantee that WebGL will work equally well for all your users, as it also depends on modern GPU drivers.  Google Chrome is the only browser offering an alternative solution if these drivers are not installed.  WebGL is a very powerful technology, but its high point has not yet arrived.  In addition to security issues, support for mobile devices is very heterogeneous.  And, of course, there is no support in older browsers. <br><br><h5>  Javascript as a result of compilation </h5><br>  Despite the fact that all modern web applications use JavaScript on the client, not all of them were written in JavaScript.  Many are written in completely different languages ‚Äã‚Äã(Java, C ++, C #), and then compiled into JS.  Some were created as languages ‚Äã‚Äãthat extend JavaScript, for more convenient development, such as TypeScript. <br><br>  Cross compilation, however, has its problems.  The minified code is unreadable, it is difficult to debug it, in practice it is possible only for browsers with support for force mapping - an intermediate file that preserves the mapping in the code in the original language. <br>  A couple of years ago, Scott Hanselman from Microsoft put forward the postulate that <a href="http://www.hanselman.com/blog/JavaScriptIsAssemblyLanguageForTheWebSematicMarkupIsDeadCleanVsMachinecodedHTML.aspx">Javascript is the compilation language for the web</a> .  His remark that the modern minified JavaScript application is poorly readable is difficult to dispute, but his post nonetheless caused a lot of discussion.  Many web developers began by simply studying the source code in the browser, and now it is almost always obfuscated.  Can we, for these reasons, lose some of the future developers? <br><br>  An interesting demonstration of the idea was the <a href="https://github.com/kripken/emscripten/wiki">Emscripten</a> project, which allows you to compile LLVM bytecode in JavaScript.  <a href="http://llvm.org/">LLVM</a> (Low Level Virtual Machine) is a very popular intermediate compilation format; you can find LLVM compiler for almost any language.  This approach will allow everyone to write the source code in the language in which it is convenient.  The project is still in its early stages, but the team has already released some impressive demos.  For example, the Epic developers ported the Unreal Engine 3 to JavaScript and WebGL, using the LLVM compiler C and Emscripten to compile into asm.js code. <br><br><h5>  <b>asm.js</b> </h5><br>  A project working in the same direction.  Its creators accepted the call ‚Äújavascript as machine code‚Äù quite literally, taking a strongly limited subset of the language as an JavaScript assembler.  this way you can theoretically write asm.js code with your hands, but no one wants to do this.  To get the most out of this opportunity, you need 2 compilers. <br>  The Emscripten compiler can produce asm.js code.  the resulting javascript is unreadable, but it is correct and backward compatible.  A huge acceleration will come when the browser engines recognize the asm.js format and pass this code through a separate compiler.  For this purpose, Mozilla is working on OdinMonkey, an asm.js optimizing compiler embedded in IonMonkey.  Google also announced support for asm.js in Chrome.  Preliminary tests showed performance in about 50% of compiled C ++, a phenomenal achievement comparable in speed to Java and C #.  The team is confident that the result will be improved. <br>  Mozilla Research is really on the crest of a wave now.  In addition to Emscripten and asm.js, there is also an <a href="http://mbebenita.github.io/LLJS/">LLJS</a> project (JavaScript as C), and <a href="https://github.com/RiverTrail/RiverTrail/wiki">River Trail</a> , ECMAScript extensions for parallel computing, is being developed in conjunction with Intel.  Considering how much effort is being applied in this direction, and what results have already been obtained, it can be assumed that the execution of JavaScript at native speed is not as unattainable as it seemed before. <br><br><h5>  <b>ORBX.js</b> </h5><br>  There are also those who offer to solve the problem of JavaScript performance due to full virtualization.  Instead of running the application on your machine, it runs in the cloud.  This, of course, is not a solution to the JS compilation problem itself, but an alternative solution for users.  ORBX.js - implementation of a video codec capable of streaming video with a resolution of 1080 pixels exclusively using JavaScript.  Joint project of Mozilla and Otoy. <br>  The technology, of course, is <a href="https://brendaneich.com/2013/05/today-i-saw-the-future/">impressive</a> , but perhaps it creates more problems than it solves. <br><br>  And what do you think about the future of Javascript compilation? </div><p>Source: <a href="https://habr.com/ru/post/182802/">https://habr.com/ru/post/182802/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182788/index.html">We are looking for java, runtime optimization</a></li>
<li><a href="../182790/index.html">How in Ukraine to accept payments on PayPal in general (and when selling on eBay in particular)</a></li>
<li><a href="../182792/index.html">Replacing a system call handler</a></li>
<li><a href="../182794/index.html">LG Electronics TVs and DLNA protocol</a></li>
<li><a href="../182798/index.html">We are friends with Cisco IP Phone CP-7925G (WiFi), Cisco IP Conference Station CP-7937G, CP-3905G and Unified IP Phone CP-7965 with Asterisk</a></li>
<li><a href="../182804/index.html">How to quickly and cheaply do user segmentation and A / B testing for an iOS application</a></li>
<li><a href="../182806/index.html">Qualimetric approach to rating startups</a></li>
<li><a href="../182808/index.html">WWDC: The official broadcast will be available on Apple.com and Apple TV</a></li>
<li><a href="../182812/index.html">Sale of tablets from Barnes & Noble - up to 44% discount</a></li>
<li><a href="../182820/index.html">Search on Drupal 7 using Apache Solr Part 5 - widgets for facet filters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>