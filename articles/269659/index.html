<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write own gateway for Thrift API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Microservices, whatever one may say, is our everything. You can resist SOAP 2.0 for as long as you like, but sooner or later they will come for you an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write own gateway for Thrift API</h1><div class="post__text post__text-html js-mediator-article">  Microservices, whatever one may say, is our everything.  You can resist SOAP 2.0 for as long as you like, but sooner or later they will come for you and convert you to their faith, or you will come to them yourself and ask them to baptize themselves with fire and sword.  Like any architectural solution, microservices have their drawbacks.  One of them is the need for every microservice to include some kind of logic for authorizing requests from external systems or other microservices.  This logic can be directly ‚Äúsewn up‚Äù within microservice (and it does not matter that it is a separate library), delegated to another microservice, or it can be declared declaratively.  What does it mean declaratively?  For example, you can agree that a special HTTP header comes to each microservice, or some kind of data structure in which there is information about the user making the request.  And the data in this structure must be unequivocally trusted.  All three options have their drawbacks, but in the article we will analyze the latter.  To implement it, the API Gateway design pattern is usually used: <br><img src="https://habrastorage.org/files/37e/52c/a51/37e52ca51c964a81a221fdf1a21cc2b4.png" alt="image"><br><br>  Under the cut all the difficulties of implementing the pattern in a binary data transfer protocol. <br><a name="habracut"></a><br>  In general, API Gateway limits the number of requests for internal services, authorizes customer requests, logs and audits, distributes requests among clients, and converts data if necessary.  As an example, the usual nginx can be used.  Consider the function of authorizing user requests.  If the HTTP protocol is used, then it is common practice to add a certain token (no matter how we got it) to the Authorization header: <br><br><pre><code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">Authorization</span></span>: Bearer &lt;some token&gt;</code> </pre> <br>  On the API Gateway side, this header is somehow checked and exchanged for another header containing some knowledge about the user to whom the token was written out, for example, its identifier, and you can forward it to internal services: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">Customer</span></span>: &lt;id&gt;</code> </pre><br>  Everything seems simple and clear, but the trouble is that Apache Thrift consists of several parts: <br><br><pre> <code class="bash hljs">+-------------------------------------------+ | Server | | (single-threaded, event-driven etc) | +-------------------------------------------+ | Processor | | (compiler generated) | +-------------------------------------------+ | Protocol | | (JSON, compact, binary etc) | +-------------------------------------------+ | Transport | | (raw TCP, HTTP etc) | +-------------------------------------------+</code> </pre><br>  In general, we can not tie in a protocol or transport.  You can of course choose one thing, everyone can agree that we only use HTTP, but this limits the ability to replace the transport and forces you to do some external processors / filters already inside the Thrift services themselves (after all, for them the http-headers are not native) . <br><br>  It remains to use the capabilities of the protocol itself, so that in the process of passing the request through the API gateway, the external authorization token is replaced with the internal one. <br><br><h4>  <b>Convention over configuration</b> </h4><br>  So, let us have the following internal service: <br><br><pre> <code class="java hljs">service InternalTestService { <span class="hljs-function"><span class="hljs-function">SomeReturnData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">: UserData userData, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">: RequestData requestData )</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">: SomeException e)</span></span></span></span>; }</code> </pre><br>  UserData is some information about the user, on whose behalf the service is called, so that the latter can understand, and whose data to pull.  It is clear that such a service can not be put out.  And what can?  For example: <br><br><pre> <code class="java hljs">service ExternalTestService { <span class="hljs-function"><span class="hljs-function">SomeReturnData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">: AuthToken authData, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">: RequestData requestData )</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">: SomeException e, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">99</span></span></span></span><span class="hljs-function"><span class="hljs-params">: UnauthorizedException ue)</span></span></span></span>; }</code> </pre><br>  All the difference between the services is their first argument and exception, which is initiated in case of problems with the authorization of the request (I hope that 98 own exceptions will suffice for everyone).  Our task at the gateway level is to check the authorization token and replace it with user information. <br><br><h4>  <b>Intestines</b> </h4><br>  Unfortunately, the documentation for Thrift's cat wept.  Almost all the guides, including, perhaps, the <a href="http://diwakergupta.github.io/thrift-missing-guide/">best</a> of them, do not concern the internal structure of these or other protocols.  And this is understandable.  In 99% of cases, the developer does not have to climb inside the protocol, but we need something. <br><br>  There are three most popular protocols: <br><br><ul><li>  <b>Binary</b> - just a binary data protocol (strings, for example, are transmitted as it is in UTF-8) </li><li>  <b>Compact</b> - the same binary only compact </li><li>  <b>JSON</b> - very original JSON </li></ul><br>  Each of the presented protocols has its own implementation, hidden behind the same API.  If we consider the binary protocol, then for our service it will look like this from an API point of view: <br><img src="https://habrastorage.org/files/864/e56/080/864e5608064149db9e552b59af801856.png" alt="image"><br><br>  <b>TMessage</b> - meta information about the message.  It consists of the method name, type and order number of the method in the service.  Message type may be as follows: <br><br><ul><li>  CALL = 1 - incoming message </li><li>  REPLY = 2 - answer </li><li>  EXCEPTION = 3 - an error occurred during execution </li><li>  ONEWAY = 4 - the message does not require a response </li></ul><br>  Everything that is not <b>TMessage</b> is useful information that is wrapped in the structure of the incoming message. <br>  All submitted protocols read the incoming byte array of data sequentially and store its current index to continue reading from the right place. <br><br>  Therefore, our algorithm should be as follows: <br><br><ol><li>  Read TMessage </li><li>  Read the beginning of the general structure of the message </li><li>  Read the meta information about the first field in the message </li><li>  Remember current position in byte array </li><li>  Read token information </li><li>  Remember current position in byte array </li><li>  Exchange token for user data </li><li>  Serialize user data </li><li>  To form a new binary array of three parts: <ul><li>  From the beginning of the original message to the index from point 4 </li><li>  Byte array of user data structure </li><li>  From the index from point 6 to the end of the original message </li></ul></li></ol><br><br><h4>  <b>We write a test</b> </h4><br>  We don‚Äôt go to reconnaissance without testing, all the more so in the case of a binary protocol, this is the easiest way to test the performance of your code.  For the test, we need the following thrift services: <br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><pre> <code class="java hljs">namespace java ru.aatarasoff.thrift exception SomeException { <span class="hljs-number"><span class="hljs-number">1</span></span>: string code } exception UnauthorizedException { <span class="hljs-number"><span class="hljs-number">1</span></span>: string reason } service ExternalTestService { <span class="hljs-function"><span class="hljs-function">SomeReturnData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">: AuthToken authData, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">: RequestData requestData )</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">: SomeException e, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">99</span></span></span></span><span class="hljs-function"><span class="hljs-params">: UnauthorizedException ue)</span></span></span></span>; } service InternalTestService { <span class="hljs-function"><span class="hljs-function">SomeReturnData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">: UserData userData, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">: RequestData requestData )</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">: SomeException e)</span></span></span></span>; } struct SomeReturnData { <span class="hljs-number"><span class="hljs-number">1</span></span>: string someStringField, <span class="hljs-number"><span class="hljs-number">2</span></span>: i32 someIntField } struct RequestData { <span class="hljs-number"><span class="hljs-number">1</span></span>: string someStringField, <span class="hljs-number"><span class="hljs-number">2</span></span>: i32 someIntField } struct AuthToken { <span class="hljs-number"><span class="hljs-number">1</span></span>: string token, <span class="hljs-number"><span class="hljs-number">2</span></span>: i32 checksum } struct UserData { <span class="hljs-number"><span class="hljs-number">1</span></span>: string id }</code> </pre></div></div><br>  Create and fill in external service with test data: <br><br><pre> <code class="java hljs">TMemoryBuffer externalServiceBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TMemoryBufferWithLength(<span class="hljs-number"><span class="hljs-number">1024</span></span>); ExternalTestService.Client externalServiceClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExternalTestService.Client(protocolFactory.getProtocol(externalServiceBuffer)); externalServiceClient.send_getSomeData( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthToken().setToken(<span class="hljs-string"><span class="hljs-string">"sometoken"</span></span>).setChecksum(<span class="hljs-number"><span class="hljs-number">128</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestData().setSomeStringField(<span class="hljs-string"><span class="hljs-string">"somevalue"</span></span>).setSomeIntField(<span class="hljs-number"><span class="hljs-number">8</span></span>) );</code> </pre><br>  <b>TMemoryBufferWithLength</b> is a specially created class that eliminates the fatal flaw in the <b>TMemoryBuffer</b> transport for us.  The latter does not know how to give the true length of the message.  Instead, you can get the length of the entire buffer, which is usually greater than the length of the message because a portion of the byte array is reserved for future data. <br><br>  The <b>send_getSomeData</b> method serializes the message to our buffer. <br><br>  We will do the same with the internal service: <br><br><pre> <code class="java hljs">internalServiceClient.send_getSomeData( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UserData().setId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RequestData().setSomeStringField(<span class="hljs-string"><span class="hljs-string">"somevalue"</span></span>).setSomeIntField(<span class="hljs-number"><span class="hljs-number">8</span></span>) );</code> </pre><br>  Get the byte array of our message: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] externalServiceMessage = Arrays.copyOf( externalServiceBuffer.getArray(), externalServiceBuffer.length() );</code> </pre><br>  We introduce a class that will translate our message from a view for an external service to a view for an internal: <b>MessageTransalator</b> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageTransalator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TProtocolFactory protocolFactory, AuthTokenExchanger authTokenExchanger)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.protocolFactory = protocolFactory; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authTokenExchanger = authTokenExchanger; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] process(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] thriftBody) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> TException { <span class="hljs-comment"><span class="hljs-comment">//some actions }</span></span></code> </pre><br>  The implementation of the token exchange ( <b>AuthTokenExchanger</b> ) may be different in different projects, so we will <b>create a</b> separate interface: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthTokenExchanger</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEmptyAuthToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">U </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T authToken)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> TException</span></span>; }</code> </pre><br>  <b>createEmptyAuthToken</b> must return an object that represents an empty token filled with <b>MessageTransalator</b> .  In the <b>process</b> method, you need to implement the exchange of the access token for user data.  For our test, we use a simple implementation: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AuthToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEmptyAuthToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthToken(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> UserData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AuthToken authToken)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"sometoken"</span></span>.equals(authToken.getToken())) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UserData().setId(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"token is invalid"</span></span>); }</code> </pre><br>  We write a check: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>.assertTrue( <span class="hljs-string"><span class="hljs-string">"Translated external message must be the same as internal message"</span></span>, Arrays.equals( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageTransalator( protocolFactory, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthTokenExchanger&lt;AuthToken, UserData&gt;() {} ).process(externalServiceMessage), internalServiceMessage ) )</code> </pre><br>  We run tests, and nothing works.  And this is good! <br><br><h4>  <b>Green light</b> </h4><br>  Implement the <b>process</b> method according to the algorithm: <br><br><pre> <code class="java hljs">TProtocol protocol = createProtocol(thriftBody); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startPosition = findStartPosition(protocol); TBase userData = authTokenExchanger.process( extractAuthToken(protocol, authTokenExchanger.createEmptyAuthToken()) ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endPosition = findEndPosition(protocol); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ArrayUtils.addAll( ArrayUtils.addAll( getSkippedPart(protocol, startPosition), serializeUserData(protocolFactory, userData) ), getAfterTokenPart(protocol, endPosition, thriftBody.length) );</code> </pre><br>  As a protocol, <b>we</b> use <b>TMemoryInputTransport</b> , which allows you to read a message directly from the byte array passed to it. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TProtocol </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProtocol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] thriftBody)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> protocolFactory.getProtocol(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TMemoryInputTransport(thriftBody)); }</code> </pre><br>  We realize the finding of token boundaries in a byte array: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findStartPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TProtocol protocol)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> TException </span></span>{ skipMessageInfo(protocol); <span class="hljs-comment"><span class="hljs-comment">// TMessage skipToFirstFieldData(protocol); //      return protocol.getTransport().getBufferPosition(); } private int findEndPosition(TProtocol protocol) throws TException { return protocol.getTransport().getBufferPosition(); } private void skipToFirstFieldData(TProtocol protocol) throws TException { protocol.readStructBegin(); protocol.readFieldBegin(); } private void skipMessageInfo(TProtocol protocol) throws TException { protocol.readMessageBegin(); }</span></span></code> </pre><br>  Serialize user data: <br><br><pre> <code class="java hljs">TMemoryBufferWithLength memoryBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TMemoryBufferWithLength(<span class="hljs-number"><span class="hljs-number">1024</span></span>); TProtocol protocol = protocolFactory.getProtocol(memoryBuffer); userData.write(protocol); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.copyOf(memoryBuffer.getArray(), memoryBuffer.length());</code> </pre><br>  We run the tests, and ... <br><br><h4>  <b>Turn on Sherlock</b> </h4><br>  So, tests for Binary and Compact pass, but JSON resists.  What is wrong?  We're going to debug and see what kind of arrays we compare: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//JSON   [1,"getSomeData",1,1,{"1":{"rec":{"1":{"str":"user1"}}},"2":{"rec":{"1":{"str":"somevalue"},"2":{"i32":8}}}}] //JSON  [1,"getSomeData",1,1,{"1":{"rec"{"1":{"str":"user1"}}},"2":{"rec":{"1":{"str":"somevalue"},"2":{"i32":8}}}}]</span></span></code> </pre><br>  Did not notice the difference?  And she is.  After the first ‚Äúrec‚Äù there is not enough colon.  The API is the same, and the result is different.  The solution came only after a careful reading of the code of the <b>TJSONProtocol</b> class.  The protocol contains a context that stores various delimiters on the stack when it traverses the JSON structure for reading or writing. <br><br><pre> <code class="java hljs">TJSONProtocol.JSONBaseContext context_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TJSONProtocol.JSONBaseContext();</code> </pre><br>  When reading the structure, the ‚Äú:‚Äù symbol is also read, but it is not returned back, because there is no context in the object itself. <br><br>  Insert the crutch into the <b>seriaizeUserData</b> method: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (protocol <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> TJSONProtocol) { memoryBuffer.write(COLON, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ":" }</span></span></code> </pre><br>  We run the tests, and now everything is ok. <br><br><h4>  <b>Throw Exceptions</b> </h4><br>  We are close to the finish line.  Ok, let's remember that we have to throw an exception in case the request is unsuccessful: <br><br><pre> <code class="java hljs">service ExternalTestService { <span class="hljs-function"><span class="hljs-function">SomeReturnData </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSomeData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">: AuthToken authData, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">: RequestData requestData )</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">: SomeException e, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">99</span></span></span></span><span class="hljs-function"><span class="hljs-params">: UnauthorizedException ue)</span></span></span></span>; }</code> </pre><br>  We do exception handling in a separate <b>processError</b> method. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] processError(TException exception) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> Exception</code> </pre><br>  In Thrift, there are several types of exceptions that may arise as a result of calling a service: <br><ol><li>  <b>TApplicationException</b> - application level exception </li><li>  <b>TProtocolException</b> - protocol related exception </li><li>  <b>TTransportException</b> - exception related to message passing </li><li>  <b>TException</b> is a basic exception that all other types inherit from </li><li>  <b>YourException extends TException</b> - any exception that was declared in DSL </li></ol><br>  An interesting detail.  You can <b>send a TApplicationException</b> or a custom user in the reply message to the client, in our case it is <b>UnauthorizedException</b> .  Therefore, we must wrap any errors either in a <b>TApplicationException</b> or in an <b>UnauthorizedException</b> . <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] processError(TException exception) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> Exception { TMemoryBufferWithLength memoryBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TMemoryBufferWithLength(<span class="hljs-number"><span class="hljs-number">1024</span></span>); TProtocol protocol = protocolFactory.getProtocol(memoryBuffer); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> exception; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TApplicationException e) { writeTApplicationException(e, protocol); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TProtocolException e) { writeTApplicationException(createApplicationException(e), protocol); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TTransportException e) { writeTApplicationException(createApplicationException(e), protocol); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (TException e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TException.class.equals(e.getClass())) { writeTApplicationException(createApplicationException(e), protocol); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { writeUserDefinedException(exception, protocol); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Arrays.copyOf(memoryBuffer.getArray(), memoryBuffer.length()); }</code> </pre><br>  Implementing a <b>TApplicationException entry</b> in a response data packet is fairly simple: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeTApplicationException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TApplicationException exception, TProtocol protocol)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> TException </span></span>{ protocol.writeMessageBegin(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.methodName, TMessageType.EXCEPTION, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.seqid)); exception.write(protocol); protocol.writeMessageEnd(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TApplicationException </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createApplicationException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TException e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TApplicationException(TApplicationException.INTERNAL_ERROR, e.getMessage()); }</code> </pre><br>  According to the protocol, each message has its own sequence identifier and the name of the method being called, which must be returned to the client.  To do this, add new fields: <b>seqid</b> and <b>methodName</b> to our class <b>MessageTranslator</b> , which are filled in when reading the beginning of the message.  Because of this, our class ceases to be thread-safe. <br><br>  To record an arbitrary exception, more gestures are required: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ERROR_STRUCT_NAME = <span class="hljs-string"><span class="hljs-string">"result"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ERROR_FIELD_NAME = <span class="hljs-string"><span class="hljs-string">"exception"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> ERROR_FIELD_POSITION = (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>) <span class="hljs-number"><span class="hljs-number">99</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String WRITE_METHOD_NAME = <span class="hljs-string"><span class="hljs-string">"write"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeUserDefinedException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TException exception, TProtocol protocol)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> TException, IllegalAccessException, InvocationTargetException, NoSuchMethodException </span></span>{ TStruct errorStruct = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TStruct(ERROR_STRUCT_NAME); TField errorField = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TField(ERROR_FIELD_NAME, TType.STRUCT, ERROR_FIELD_POSITION); protocol.writeMessageBegin(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.methodName, TMessageType.REPLY, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.seqid)); protocol.writeStructBegin(errorStruct); protocol.writeFieldBegin(errorField); exception.getClass().getMethod(WRITE_METHOD_NAME, TProtocol.class).invoke(exception, protocol); protocol.writeFieldEnd(); protocol.writeFieldStop(); protocol.writeStructEnd(); protocol.writeMessageEnd(); }</code> </pre><br>  The interesting thing here is that for a custom exception, the type of the return message is not <b>TMessageType.EXCEPTION</b> , but <b>TMessageType.REPLY</b> . <br><br>  Now we can take the incoming message, replace the token in it and correctly respond to the client if an error occurred during the verification of the token. <br><br><h4>  <b>Spring breaks into a bar</b> </h4><br>  Ok, we made the preparation of binary packages.  Now is the time to make a practical implementation on the popular framework for creating microservices.  For example, on <b>Spring Boot</b> .  It is good because, on the one hand, it is possible to find ready-made solutions for it, and on the other hand, it is easy and convenient to customize it with annotations by adding new features with two or three lines of code.  For routing and processing HTTP requests, take <b>Netflix Zuul</b> , which is included in the <b>Spring Cloud</b> extension set.  The scheme of Zuul's work is presented in the following image: <br><br><img src="https://habrastorage.org/files/5be/216/e38/5be216e38309448c8f3b75f45561dd49.png"><br><br>  If it is very simple, then <b>Netflix Zuul</b> is a regular servlet with a chain of its own filters, which can be loaded dynamically or included in the application.  Each filter adds a new behavior, and even the HTTP response record is also implemented by the filter.  There are several types of filters that are executed sequentially as shown in the image above.  Within each type, filters are executed in the order determined by the priority of a particular filter.  Connecting <b>Zuul</b> to the <b>Spring Boot</b> application is simple (add dependencies): <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableZuulProxy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(Application.class, args); } }</code> </pre><br>  We want the same thing, but for the API gateway, so that those who will use our solution can concentrate on the business logic of authorizing their application, and not on the problems listed in the article.  To do this, create an annotation <b>@EnableThriftGateway</b> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>(ElementType.TYPE) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@Documented</span></span> <span class="hljs-meta"><span class="hljs-meta">@Inherited</span></span> <span class="hljs-meta"><span class="hljs-meta">@Import</span></span>(ThriftGatewayConfiguration.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> EnableThriftGateway { }</code> </pre><br>  The configuration of <b>ThriftGatewayConfiguration</b> will contain three bins that are created if the annotation is added to the main application class: <b>Application</b> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThriftGatewayConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span>(AuthTokenExchanger.class) <span class="hljs-function"><span class="hljs-function">AuthTokenExchanger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authTokenExchanger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnsupportedOperationException(<span class="hljs-string"><span class="hljs-string">"You should implement AuthTokenExchanger bean"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConditionalOnMissingBean</span></span>(TProtocolFactory.class) <span class="hljs-function"><span class="hljs-function">TProtocolFactory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thriftProtocolFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TBinaryProtocol.Factory(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AuthenticationZuulFilter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authenticationZuulFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthenticationZuulFilter(); } }</code> </pre><br>  The <b>ConditionalOnMissingBean</b> annotation prevents the creation of a default bean if the application has declared its own bean of this class.  The previously created <b>AuthTokenExchanger</b> interface should be implemented without fail by the developer of a specific project.  We cannot, for security reasons, do any default implementation, so an exception is thrown in the bean creation method.  Also, you need to define the protocol used for sending thrift messages.  By default, this is <b>TBinaryProtocol</b> , but you can always use the one you need for a project by redefining the protocol factory creation bin.  But the most important part of the configuration is of course the <b>AuthenticationZuulFilter</b> bin, which implements the business logic of the authorization layer. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthenticationZuulFilter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZuulFilter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"pre"</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">filterOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequestWrapper request = (HttpServletRequestWrapper) ctx.getRequest(); <span class="hljs-comment"><span class="hljs-comment">//   return null; } }</span></span></code> </pre><br>  After receiving the context objects and the HTTP request, we will create a <b>MessageTransalator</b> . <br><br><pre> <code class="java hljs">MessageTransalator messageTransalator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageTransalator(protocolFactory, authTokenExchanger);</code> </pre><br>  A positive scenario consists of processing the incoming data packet, recording a new packet in the <b>requestEntity</b> field of the <b>request</b> context, and specifying a new message length instead of the original one: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] processed = messageTransalator.process(request.getContentData()); ctx.set(<span class="hljs-string"><span class="hljs-string">"requestEntity"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteArrayInputStream(processed)); ctx.setOriginContentLength(processed.length);</code> </pre><br>  If an error has occurred, it must be processed: <br><br><pre> <code class="java hljs">ctx.setSendZuulResponse(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); ctx.setResponseDataStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteArrayInputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{})); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ctx.getResponse().getOutputStream().write(messageTransalator.processError(e)); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e1) { log.error(<span class="hljs-string"><span class="hljs-string">"unexpected error"</span></span>, e1); ctx.setResponseStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR); }</code> </pre><br>  Here we had to apply several unobvious tricks to prevent further processing of the request and attempts to send the packet to the internal service.  First of all, <br><pre> <code class="java hljs">ctx.setSendZuulResponse(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)</code> </pre>  does not allow GZIP compression of the outgoing packet.  Not all thrift clients are able to survive after such repacking.  And secondly, <br><pre> <code class="java hljs">ctx.setResponseDataStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteArrayInputStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{}))</code> </pre>  allows you to use the original outgoing message generation filter, despite the installation in the previous paragraph of the ban on transferring data back to the client. <br><br><h4>  <b>We put everything together</b> </h4><br>  Create a new Spring Boot application and add two annotations to it, <b>@EnableZuulProxy</b> and <b>@EnableThriftGateway</b> : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableZuulProxy</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableThriftGateway</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(Application.class, args); } }</code> </pre><br>  We implement simple authorization logic: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthenticationConfiguration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-function">AuthTokenExchanger </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">authTokenExchanger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AuthTokenExchanger&lt;Token, TName&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Token </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createEmptyAuthToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Token(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> TName </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Token authToken)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> TException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (authToken.getValue().equals(<span class="hljs-string"><span class="hljs-string">"heisours"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TName(<span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"Smith"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnauthorizedException(ErrorCode.WRONG_TOKEN); } }; } }</code> </pre><br>  As you can see, if a token with the <b>heisours</b> value came to us, then we authorize the request, and if not, then we throw out the error.  It remains only to configure Zuul: <br><br><pre> <code class="bash hljs">zuul: routes: greetings: <span class="hljs-comment"><span class="hljs-comment">#  URL,      path: /greetings/** #  serviceId: greetings greetings: ribbon: listOfServers: localhost:8080 # ,    greetings</span></span></code> </pre><br>  and API Gateway can be used. <br><br><h4>  <b>Links</b> </h4><br>  The basic part to convert binary packages: <a href="https://github.com/aatarasoff/thrift-api-gateway-core">https://github.com/aatarasoff/thrift-api-gateway-core</a> <br>  Magic annotations for Spring: <a href="https://github.com/aatarasoff/spring-thrift-api-gateway">https://github.com/aatarasoff/spring-thrift-api-gateway</a> <br>  Examples: <a href="https://github.com/aatarasoff/spring-thrift-api-gateway/tree/master/examples">https://github.com/aatarasoff/spring-thrift-api-gateway/tree/master/examples</a> </div><p>Source: <a href="https://habr.com/ru/post/269659/">https://habr.com/ru/post/269659/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269643/index.html">Meet the Unity Demo Team and The Blacksmith FAQ</a></li>
<li><a href="../269645/index.html">Creating a dynamically changing landscape for RTS on Unity3D</a></li>
<li><a href="../269649/index.html">Accelerate OSB</a></li>
<li><a href="../269651/index.html">0xDBE 1.0 Preview available</a></li>
<li><a href="../269657/index.html">NoSQL era behind</a></li>
<li><a href="../269661/index.html">The basic structure of the module Magento [Magento Certification]</a></li>
<li><a href="../269663/index.html">Vulnerabilities in Plategka.com service including XSS</a></li>
<li><a href="../269665/index.html">Pixar's 22 storytelling rules</a></li>
<li><a href="../269667/index.html">Java evolution by reading lines from a file</a></li>
<li><a href="../269669/index.html">Brilliance and Poverty HTML5 - Access to Sensors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>