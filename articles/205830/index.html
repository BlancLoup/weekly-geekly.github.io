<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell, as something very close, or we get comites from github api</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Too late - 'cause I got it now 
 there are monads all around 
 IO, State and lists abound 
 It's easy, like those people say 
 but my program got abst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell, as something very close, or we get comites from github api</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Too late - 'cause I got it now <br>  there are monads all around <br>  IO, State and lists abound <br>  It's easy, like those people say <br>  but my program got abstracted all away! <br>  Maybe ooo <br>  It's a monad too, I know <br>  Why should I use another language at all? <br></blockquote><br><br>  Again a crazy adept Haskell, and another attempt to prove its practicality.  Timeless classics. <br>  I will try to tell a smart story <s>(do not get fooled by pretentious advertising)</s> , which will have all the necessary components of a blockbuster <s>(I‚Äôm serious, do not get fooled)</s> - familiar characters, a well thought out universe and an open ending <s>(well ...)</s> . <br><a name="habracut"></a><br>  A little seriousness never hurts.  Therefore, first, without the slightest hint of humor, I will tell the logic of writing this text.  I wanted (first of all, for myself, but I hope someone will be interested too) to implement some kind of painfully close, incredibly practical task on Haskell.  A positive result of this task would give an extra reason to be proud of yourself, skills and one more argument in favor of choosing this programming language.  As an experimental task, I chose to receive and process information about commits to the repository on github.  Actually, it will contain work with github api - loading and parsing json. <br><br>  I believe that it is worth deciding on steps, therefore we will begin with an initial position, namely an empty directory in the file system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Module creation </h2><br>  First, create a new module for our purposes. <br><br><pre><code class="bash hljs">cabal init</code> </pre> <br>  <b>Inquisitive cabal</b> will ask a few questions, and as a result you will receive a module <b>stub</b> with the configuration file <b>project_name.cabal</b> .  For more aesthetics, add the <b>src</b> directory to the module, and specify it in the configuration <br><br><pre> <code class="hljs pgsql">executable project-<span class="hljs-type"><span class="hljs-type">name</span></span> hs-source-dirs: src main-<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>: Main.hs</code> </pre><br>  Of course, <b>Main.hs</b> needs to be created) <br><br>  Next, a few words about <a href="http://www.yesodweb.com/blog/2011/09/limitations-of-haskell">dependency hell</a> .  This is a sore subject Haskell, in which progress is planned.  There are several options for solving the problem of dependencies, but we are young and love everything that is fashionable, so we will use the fresh cabal-1.18 feature - sandoxes. <br><br>  Actually, for use you need to initialize the sandbox and install dependencies <br><br><pre> <code class="bash hljs">cabal sandbox init cabal install --only-dependencies</code> </pre> <br>  In the future, to assemble the module, you can use the command as usual <br><br><pre> <code class="bash hljs">cabal build</code> </pre> <br>  If there is a keen desire to debug something, and indeed, to see how it works from the inside (and, according to the laws of the genre, such a desire will necessarily arise), you can run <b>ghci</b> in the sandbox created by the command <br><br><pre> <code class="bash hljs">cabal repl</code> </pre> <br>  Everything, the fear of the empty catalog is overcome, we move on. <br><br><h2>  http-conduit </h2><br>  The first task that needs to be solved is to download information about commit in json format.  Actually, the source <a href="https://api.github.com/repos/erthalion/github-parser/commits">is obvious</a> , but simple things end there.  So, at this stage we will use the <a href="http-conduit">http-conduit</a> package authored by the sun-faced <s>Edward Snow</s> Michael Snoyman.  In general, conduit is a great solution for working with data streams.  I hardly get to talk about it well, so welcome to the blog of a man by the name of <a href="http://eax.me/haskell-conduits/">eax</a> .  I will tell quite a bit and on the periphery. <br><br>  First, add the necessary dependencies to the build-depends section of the configuration file. <br><br><pre> <code class="bash hljs">bytestring &gt;= 0.10, conduit &gt;= 1.0, http-conduit &gt;= 1.9,</code> </pre><br>  and update the sandbox with the command described above. <br><br>  Now we can anxiously proceed to the code.  To begin with, in order to simplify your life and work with strings, add an <a href="https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions">extension</a> <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE OverloadedStrings #-}</span></span></code> </pre><br>  We connect the necessary modules <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Conduit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Network.HTTP.Conduit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Conduit.Binary <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CB <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.ByteString.Char8 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BS</code> </pre><br>  All json download code will look something like this. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> manager &lt;- newManager def req &lt;- parseUrl <span class="hljs-string"><span class="hljs-string">"https://api.github.com/../.."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> headers = requestHeaders req req' = req { requestHeaders = (<span class="hljs-string"><span class="hljs-string">"User-agent"</span></span>, <span class="hljs-string"><span class="hljs-string">"some-app"</span></span>) : headers } runResourceT $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> res &lt;- http req' manager responseBody res $$+- <span class="hljs-type"><span class="hljs-type">CB</span></span>.lines =$ parserSink</code> </pre><br>  As I recall, api github requires the <b>User-agent</b> header, so I had to expand the request a bit.  The main action takes place in the last two lines, where we get an answer with json.  Since  if the result is wrapped in a transformer <b>ResourceT</b> , then the functions for getting it must be called using runResourceT.  After receiving the response body, we send it to the stock, which is designed for parsing json and it looks like this <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserSink</span></span> :: <span class="hljs-type"><span class="hljs-type">Sink</span></span> <span class="hljs-type"><span class="hljs-type">BS</span></span>.<span class="hljs-type"><span class="hljs-type">ByteString</span></span> (<span class="hljs-type"><span class="hljs-type">ResourceT</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) () parserSink = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> md &lt;- await <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> md <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; return () <span class="hljs-type"><span class="hljs-type">Just</span></span> d -&gt; parseCommits d</code> </pre><br>  If successful, the stock will simply parse the received json and display it on the screen (this part of the magic is hidden in the parseCommits function). <br><br><h2>  Aeson </h2><br>  We continue to distort the thinking of programmers and proceed to the parsing.  For it, we will use an extremely powerful package called <a href="http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html">Aeson</a> .  In fact, everything is quite simple here, but there are a few points that are used to introduce into a stupor: <br><br><ul><li>  Since  Haskell is strongly typed, we will need types that will describe the data structure embedded in json </li><li>  If I didn‚Äôt confuse anything, then Aeson uses lazy bytestring, while strict bytestring is in stock, so I‚Äôll have to demonstrate the skills of juggling with types </li></ul><br>  So, first define the types.  You can not bother, and define them only partially by sending some of the information from json to the firebox.  We leave only the url, hash and commit message. <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.ByteString.Char8 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> BS <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Aeson (<span class="hljs-type"><span class="hljs-type">FromJSON(..)</span></span>) data CommitInfo = CommitInfo { message :: BS.ByteString } deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>) data Commit = Commit { sha :: BS.ByteString, url :: BS.ByteString, commit :: CommitInfo } deriving (<span class="hljs-type"><span class="hljs-type">Show</span></span>)</code> </pre><br>  Further, it would be canonical to use applicative functors to match json and fields from data structures, but we will all deceive and use Generic. <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DeriveGeneric #-}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> GHC.Generics (<span class="hljs-type"><span class="hljs-type">Generic</span></span>)</code> </pre><br>  and add inheritance from Generic to existing data structures <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">deriving</span></span>(<span class="hljs-type"><span class="hljs-type">Show</span></span>, <span class="hljs-type"><span class="hljs-type">Generic</span></span>)</code> </pre><br>  It remains only to declare the possibility of creating Commit &amp; CommitInfo from json <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FromJSON</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Commit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FromJSON</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CommitInfo</span></span></span></span></code> </pre><br>  Only a few steps left to finish, we are almost there <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parseCommits</span></span> :: <span class="hljs-type"><span class="hljs-type">BS</span></span>.<span class="hljs-type"><span class="hljs-type">ByteString</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Sink</span></span> <span class="hljs-type"><span class="hljs-type">BS</span></span>.<span class="hljs-type"><span class="hljs-type">ByteString</span></span> (<span class="hljs-type"><span class="hljs-type">ResourceT</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) () parseCommits rawData = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parsedData = decode $ <span class="hljs-type"><span class="hljs-type">BL</span></span>.fromChunks [rawData] :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> [<span class="hljs-type"><span class="hljs-type">Models</span></span>.<span class="hljs-type"><span class="hljs-type">Commit</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> parsedData <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; liftIO $ <span class="hljs-type"><span class="hljs-type">BS</span></span>.putStrLn <span class="hljs-string"><span class="hljs-string">"Parse error"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> commits -&gt; liftIO $ printCommits commits</code> </pre><br><br>  As you can see, you have to create lazy bytestring to return to decoding.  If the parsing was successful, with the help of <b>liftIO we</b> raise the values ‚Äã‚Äãobtained and output them to the console. <br><br><h2>  Finish </h2><br>  Everything, the red carpet, fanfare and solemn end of the evening.  A full example is located <a href="https://github.com/erthalion/github-parser">here</a> .  The code is not an example of computer science ideals, so comments from the gurus are welcome.  I hope everyone else has learned something, or at least enjoyed it and became closer to the world of Haskell.  May the force be with you! </div><p>Source: <a href="https://habr.com/ru/post/205830/">https://habr.com/ru/post/205830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205812/index.html">Picaso 3D Designer Review - a new milestone in bulk printing</a></li>
<li><a href="../205816/index.html">Meet RENTMANIA-online rental platform</a></li>
<li><a href="../205820/index.html">Webinar: ‚ÄúEfficient and secure migration from Windows XP to Windows 8.1‚Äù</a></li>
<li><a href="../205822/index.html">Yota Phone: why such products are needed</a></li>
<li><a href="../205828/index.html">FAT patent in Europe is invalid</a></li>
<li><a href="../205832/index.html">Interview with Bobuk aka Grigory Bakunov, director of technology distribution at Yandex and radio host T</a></li>
<li><a href="../205836/index.html">Servers free until the end of the year</a></li>
<li><a href="../205838/index.html">Fallout 1, 2 and Tactics for free</a></li>
<li><a href="../205840/index.html">ZeroNights'2013 - Conference Report</a></li>
<li><a href="../205844/index.html">Language K: Displaying a graphical interface from data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>