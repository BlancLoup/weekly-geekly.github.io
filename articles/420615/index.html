<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript: object exploration</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The material, the translation of which we are publishing today, is devoted to the study of objects - one of the key entities of JavaScript. It is desi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript: object exploration</h1><div class="post__text post__text-html js-mediator-article">  The material, the translation of which we are publishing today, is devoted to the study of objects - one of the key entities of JavaScript.  It is designed mainly for novice developers who want to streamline their knowledge about objects. <br><br> <a href="https://habr.com/company/ruvds/blog/420615/"><img src="https://habrastorage.org/webt/vo/lg/xb/volgxbgclrhdnqvvi_qdqfc1yna.jpeg"></a> <br><br>  Objects in JavaScript are dynamic collections of properties that, in addition, contain a ‚Äúhidden‚Äù property, which is a prototype of the object.  Properties of objects are characterized by keys and values.  Let's start the conversation about JS objects with keys. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Object Property Keys</font> </h2><br>  The property key of the object is a unique string.  To access the properties, you can use two methods: accessing them through a point and specifying the object key in square brackets.  When accessing properties through a dot, the key must be a valid JavaScript identifier.  Consider an example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> obj = {  <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span> } obj.message //<span class="hljs-string"><span class="hljs-string">"A message"</span></span> obj[<span class="hljs-string"><span class="hljs-string">"message"</span></span>] //<span class="hljs-string"><span class="hljs-string">"A message"</span></span></code> </pre> <br>  If you attempt to access a non-existent property of the error message object, it will return the value <code>undefined</code> : <br><br><pre> <code class="hljs objectivec">obj.otherProperty <span class="hljs-comment"><span class="hljs-comment">//undefined</span></span></code> </pre> <br>  When used to access the properties of square brackets, you can use keys that are not valid JavaScript identifiers (for example, the key can be a string containing spaces).  They can have any value that can be cast to the string: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> french = {}; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>] = <span class="hljs-string"><span class="hljs-string">"thank you very much"</span></span>; french[<span class="hljs-string"><span class="hljs-string">"merci beaucoup"</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//"thank you very much"</span></span></code> </pre> <br>  If non-string values ‚Äã‚Äãare used as keys, they are automatically converted to strings (using the <code>toString()</code> method, if possible): <br><br><pre> <code class="hljs lua">et obj = {}; //Number obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"Number 1"</span></span>; obj[<span class="hljs-number"><span class="hljs-number">1</span></span>] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //<span class="hljs-literal"><span class="hljs-literal">true</span></span> //Object let number1 = { toString : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } } obj[number1] === obj[<span class="hljs-string"><span class="hljs-string">"1"</span></span>]; //<span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  In this example, the <code>number1</code> object is used as the key.  When attempting to access a property, it is converted to line <code>1</code> , and the result of this conversion is used as a key. <br><br><h2>  <font color="#3AC1EF">Object Property Values</font> </h2><br>  Object properties can be primitive values, objects, or functions. <br><br><h3>  <font color="#3AC1EF">‚ñçObject as an object property value</font> </h3><br>  Objects can be placed in other objects.  Consider <a href="https://jsfiddle.net/cristi_salcescu/m0a65e2g/">an example</a> : <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = { title : <span class="hljs-string"><span class="hljs-string">"The Good Parts"</span></span>, author : {   firstName : <span class="hljs-string"><span class="hljs-string">"Douglas"</span></span>,   lastName : <span class="hljs-string"><span class="hljs-string">"Crockford"</span></span> } } book.author.firstName; <span class="hljs-comment"><span class="hljs-comment">//"Douglas"</span></span></code> </pre> <br>  A similar approach can be used to create namespaces: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> app = {}; app.authorService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; app.bookService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} };</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçFunction as an object property value</font> </h3><br>  When a function is used as a property value of an object, it usually becomes an object method.  Inside the method, to refer to the current object, use the keyword <code>this</code> . <br><br>  This keyword, however, may have different meanings, depending on how the function was called.  <a href="https://medium.freecodecamp.org/what-to-do-when-this-loses-context-f09664af076f">Here</a> you can read about situations in which <code>this</code> loses context. <br><br><h2>  <font color="#3AC1EF">Dynamic nature of objects</font> </h2><br>  Objects in JavaScript, by their nature, are dynamic entities.  You can add properties to them at any time, the same applies to deleting properties: <br><br><pre> <code class="hljs ruby">let obj = {}; obj.message = <span class="hljs-string"><span class="hljs-string">"This is a message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   obj.otherMessage = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    delete obj.otherMessage; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> </code> </pre> <br><h2>  <font color="#3AC1EF">Objects as associative arrays</font> </h2><br>  Objects can be considered as associative arrays.  The keys of an associative array are the names of the properties of an object.  In order to gain access to the key, it is not necessary to look through all the properties, that is, the operation of accessing the key of an associative array based on an object is performed in O (1) time. <br><br><h2>  <font color="#3AC1EF">Object Prototypes</font> </h2><br>  Objects have a ‚Äúhidden‚Äù link, <code>__proto__</code> , pointing to a prototype object, from which the object inherits properties. <br><br>  For example, an object created using an object literal has a reference to the <code>Object.prototype</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; obj.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype; <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF"> Empty objects</font> </h3><br>  As we have just seen, an ‚Äúempty‚Äù object, <code>{}</code> , is actually not so empty, since it contains a reference to an <code>Object.prototype</code> .  In order to create a truly empty object, you need to use the following construction: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)</code> </pre> <br>  This will create an object without a prototype.  Such objects are usually used to create associative arrays. <br><br><h3>  <font color="#3AC1EF">A prototype chain</font> </h3><br>  Prototype objects can have their own prototypes.  If you try to access the property of an object that is not in it, JavaScript will try to find this property in the prototype of this object, and if there is no desired property there, an attempt will be made to find it in the prototype prototype.  This will continue until the desired property is found, or until the end of the prototype chain is reached. <br><br><h2>  <font color="#3AC1EF">Primitive Type Values ‚Äã‚Äãand Object Wrappers</font> </h2><br>  JavaScript allows you to work with values ‚Äã‚Äãof primitive types as objects, in the sense that the language allows you to access their properties and methods. <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span> <span class="hljs-string"><span class="hljs-string">"text"</span></span>.toUpperCase(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"TEXT"</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>.toString(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"true"</span></span></code> </pre> <br>  In this case, of course, the values ‚Äã‚Äãof primitive types are not objects. <br><br>  To provide access to the ‚Äúproperties‚Äù of values ‚Äã‚Äãof primitive types of JavaScript, if necessary, create wrapper objects, which, after they are no longer needed, are destroyed.  The process of creating and destroying wrapper objects is optimized by the JS engine. <br><br>  Object wrappers have numeric, string, and boolean values.  Objects of the corresponding types are represented by the constructor functions <code>Number</code> , <code>String</code> , and <code>Boolean</code> . <br><br><h2>  <font color="#3AC1EF">Embedded Prototypes</font> </h2><br>  Number objects inherit properties and methods from the <code>Number.prototype</code> prototype, which is derived from the <code>Object.prototype</code> : <br><br><pre> <code class="hljs pgsql">var <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__ === Number.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span>.__proto__.__proto__ === <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.prototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  The prototype of the string objects is the <code>String.prototype</code> .  The prototype of the boolean objects is the <code>Boolean.prototype</code> .  The prototype of the arrays (which are also objects) is <code>Array.prototype</code> . <br><br>  Functions in JavaScript are also objects that have a prototype <code>Function.prototype</code> .  Functions have methods like <code>bind()</code> , <code>apply()</code> and <code>call()</code> . <br><br>  All objects, functions, and objects representing values ‚Äã‚Äãof primitive types (with the exception of <code>null</code> and <code>undefined</code> values) inherit properties and methods from <code>Object.prototype</code> .  This leads to the fact that, for example, all of them have a <code>toString()</code> method. <br><br><h2>  <font color="#3AC1EF">Extending embedded objects with polyfills</font> </h2><br>  JavaScript allows you to easily extend built-in objects with new functions using the so-called polyfills.  Polyfill is a piece of code that implements features not supported by any browsers. <br><br><h3>  <font color="#3AC1EF">‚ñçUsing polyfills</font> </h3><br>  For example, there is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">polyfill</a> for the <code>Object.assign()</code> method.  It allows you to add a new function to <code>Object</code> if it is not available in it. <br><br>  The same applies to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from">Array.from</a> <code>Array.from()</code> , which, if there is no <code>from()</code> method in the <code>Array</code> object, equips it with this method. <br><br><h3>  <font color="#3AC1EF">‚ñçPolythills and prototypes</font> </h3><br>  With the help of polyfills new methods can be added to the prototypes of objects.  For example, a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim">polyfill</a> for <code>String.prototype.trim()</code> allows you to equip all string objects with a <code>trim()</code> method: <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = "   A text "; <span class="hljs-type"><span class="hljs-type">text</span></span>.trim(); //"A text"</code> </pre> <br>  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find">Polyfill</a> for <code>Array.prototype.find()</code> allows you to equip all arrays with the <code>find()</code> method.  The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/findIndex">polyfill</a> for <code>Array.prototype.findIndex()</code> works in a similar way: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-string"><span class="hljs-string">"E"</span></span>]; arr.indexOf(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//2</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Single inheritance</font> </h2><br>  The <code>Object.create()</code> command allows you to create new objects with a given prototype object.  This command is used in JavaScript to implement the single inheritance mechanism.  Consider <a href="https://jsfiddle.net/cristi_salcescu/zu79cebu/">an example</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookPrototype = { <span class="hljs-attr"><span class="hljs-attr">getFullTitle</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title + <span class="hljs-string"><span class="hljs-string">" by "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.author; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> book = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(bookPrototype); book.title = <span class="hljs-string"><span class="hljs-string">"JavaScript: The Good Parts"</span></span>; book.author = <span class="hljs-string"><span class="hljs-string">"Douglas Crockford"</span></span>; book.getFullTitle();<span class="hljs-comment"><span class="hljs-comment">//JavaScript: The Good Parts by Douglas Crockford</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Multiple inheritance</font> </h2><br>  The <code>Object.assign()</code> command copies properties from one or more objects to the target object.  It can be used to implement a multiple inheritance scheme.  Here is <a href="https://jsfiddle.net/cristi_salcescu/ghqsb9a3/">an example</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> authorDataService = { <span class="hljs-attr"><span class="hljs-attr">getAuthors</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bookDataService = { <span class="hljs-attr"><span class="hljs-attr">getBooks</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userDataService = { <span class="hljs-attr"><span class="hljs-attr">getUsers</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, authorDataService, bookDataService, userDataService ); dataService.getAuthors(); dataService.getBooks(); dataService.getUsers();</code> </pre> <br><h2>  <font color="#3AC1EF">Immunity objects</font> </h2><br>  The <code>Object.freeze()</code> command allows you to freeze an object.  In such an object can not add new properties.  Properties cannot be deleted, and their values ‚Äã‚Äãcannot be changed.  Using this command, the object becomes immutable or immutable: <br><br><pre> <code class="hljs pgsql">"use strict"; let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "Functional-Light JavaScript", author : "Kyle Simpson" }); book.title = "Other title";//: Cannot assign <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> property <span class="hljs-string"><span class="hljs-string">'title'</span></span></code> </pre> <br>  The <code>Object.freeze()</code> command performs the so-called ‚Äúshallow freezing‚Äù of objects.  This means that objects nested in a ‚Äúfrozen‚Äù object can be modified.  In order to carry out a ‚Äúdeep freezing‚Äù of an object, one must recursively ‚Äúfreeze‚Äù all its properties. <br><br><h2>  <font color="#3AC1EF">Cloning objects</font> </h2><br>  To create clones (copies) of objects, you can use the <code>Object.assign()</code> command: <br><br><pre> <code class="hljs pgsql">let book = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ title : "JavaScript Allong√©", author : "Reginald Braithwaite" }); let clone = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.assign({}, book);</code> </pre> <br>  This command performs shallow copying of objects, that is, it copies only top-level properties.  Nested objects are common for original objects and their copies. <br><br><h2>  <font color="#3AC1EF">Object literal</font> </h2><br>  Object literals give the developer a simple and straightforward way to create objects: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = { <span class="hljs-attr"><span class="hljs-attr">fn</span></span> : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; }, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, }</code> </pre> <br>  However, this method of creating objects has disadvantages.  In particular, with this approach, all properties of an object are publicly available, object methods can be overridden, they cannot be used to create new instances of identical objects: <br><br><pre> <code class="hljs pgsql">timer.fn;//<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> timer.start = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { console.log("New implementation"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Object.create () method</font> </h2><br>  The two problems mentioned above can be <code>Object.create()</code> and <code>Object.freeze()</code> methods. <br><br>  Apply this technique to our previous example.  First, create a frozen prototype <code>timerPrototype</code> containing all the methods needed by different instances of the object.  After that, create an object that is a successor of <code>timerPrototype</code> : <br><br><pre> <code class="hljs pgsql">let timerPrototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} }); let timer = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(timerPrototype); timer.__proto__ === timerPrototype; //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br>  If the prototype is protected from changes, the object that is its successor will not be able to change the properties defined in the prototype.  Now the <code>start()</code> and <code>stop()</code> methods cannot be redefined: <br><br><pre> <code class="hljs javascript"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; timer.start = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"New implementation"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//: Cannot assign to read only property 'start' of object</span></span></code> </pre> <br>  The <code>Object.create(timerPrototype)</code> can be used to create multiple objects with the same prototype. <br><br><h2>  <font color="#3AC1EF">Constructor function</font> </h2><br>  In JavaScript, there are so-called constructor functions, which are ‚Äúsyntactic sugar‚Äù for performing the above described actions for creating new objects.  Consider <a href="https://jsfiddle.net/cristi_salcescu/az35x2qs/">an example</a> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Timer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fn = callback; } Timer.prototype = { <span class="hljs-attr"><span class="hljs-attr">start</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">stop</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTodos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Timer(getTodos);</code> </pre> <br>  As a constructor, you can use any function.  The constructor is called using the <code>new</code> keyword.  An object created using a constructor function named <code>FunctionConstructor</code> will receive the prototype <code>FunctionConstructor.prototype</code> : <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Here, to prevent prototype changes, again, you can freeze the prototype: <br><br><pre> <code class="hljs pgsql">Timer.prototype = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({ <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {}, stop : <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {} });</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Keyword new</font> </h3><br>  When a command like <code>new Timer()</code> is executed, the same actions are performed as the following <code>newTimer()</code> function <code>newTimer()</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newTimer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newObj = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(Timer.prototype); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> returnObj = Timer.call(newObj, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(returnObj) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnObj;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newObj; }</code> </pre> <br>  This is where a new object is created, the prototype of which is <code>Timer.prototype</code> .  Then the <code>Timer</code> function is called, setting the fields for the new object. <br><br><h2>  <font color="#3AC1EF">Keyword class</font> </h2><br>  In ECMAScript 2015, a new way to perform the actions described above has been introduced, representing another portion of ‚Äúsyntactic sugar‚Äù.  We are talking about the <code>class</code> keyword and the corresponding constructs associated with it.  Consider <a href="https://jsfiddle.net/cristi_salcescu/aLg8t632/">an example</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Timer{ constructor(callback){   this.fn = callback; } <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {} stop() {} } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br>  An object created using a <code>class</code> -based class keyword named <code>ClassName</code> will have a prototype <code>ClassName.prototype</code> .  When creating an object based on a class, you need to use the keyword <code>new</code> : <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">timer</span></span>.__proto__ === <span class="hljs-built_in"><span class="hljs-built_in">Timer</span></span>.prototype;</code> </pre> <br>  Using classes does not make prototypes unchanged.  If necessary, they will have to be ‚Äúfrozen‚Äù just as we have already done: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(Timer.prototype);</code> </pre> <br><h2>  <font color="#3AC1EF">Prototype Inheritance</font> </h2><br>  In JavaScript, objects inherit properties and methods from other objects.  Constructor functions and classes are ‚Äúsyntactic sugar‚Äù for creating prototype objects containing all the necessary methods.  With their use, new objects are created which are the heirs of the prototype, whose properties that are specific to a particular instance are established using the constructor function or using class mechanisms. <br><br>  It would be nice if constructor functions and classes could automatically make prototypes unchanged. <br><br>  The strength of prototype inheritance is memory savings.  The fact is that a prototype is created only once, after which it is used by all objects created on its basis. <br><br><h3>  <font color="#3AC1EF">‚ñçThe problem of the lack of built-in encapsulation mechanisms</font> </h3><br>  The prototype inheritance pattern does not use the separation of the properties of objects into private and public.  All properties of objects are publicly available. <br><br>  For example, the <code>Object.keys()</code> command returns an array containing all property keys of the object.  It can be used to iterate through all the properties of an object: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //  } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br>  There is one pattern that mimics private properties, relying on the fact that developers will not refer to those properties whose names begin with an underscore ( <code>_</code> ): <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(callback){   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._fn = callback;   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._timerId = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><h2>  <font color="#3AC1EF">Factory Functions</font> </h2><br>  Encapsulated objects in JavaScript can be created using factory functions.  It looks like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TodoStore(callback){   let fn = callback;     <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() {},   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> stop() {}     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>,      stop   }); }</code> </pre> <br>  Here, the <code>fn</code> variable is private.  Only <code>start()</code> and <code>stop()</code> methods are publicly available.  These methods cannot be modified from the outside.  This keyword is not used here, so when using this method of creating objects, the problem of losing the <code>this</code> context is irrelevant. <br><br>  The <code>return</code> command uses an object literal containing only functions.  Moreover, these functions are declared in closure, they share a common state.  To ‚Äúfreeze‚Äù the public API of an object, the command <code>Object.freeze()</code> already known to you is used. <br><br>  Here, in the examples, we used the <code>Timer</code> object.  In <a href="https://medium.freecodecamp.org/here-are-some-practical-javascript-objects-that-have-encapsulation-fc4c1a79c655">this</a> material you can find its full implementation. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In JavaScript, the values ‚Äã‚Äãof primitive types, ordinary objects and functions are perceived as objects.  Objects have a dynamic nature, they can be used as associative arrays.  Objects are the heirs of other objects.  Constructor functions and classes are ‚Äúsyntactic sugar‚Äù; they allow you to create objects based on prototypes.  For the organization of a single inheritance, you can use the <code>Object.create()</code> method, for the organization of multiple inheritance - <code> Object.assign()</code> .  You can use factory functions to create encapsulated objects. <br><br>  <b>Dear readers!</b>  If you came to JavaScript from other languages, please tell us what you like or dislike in JS objects, in comparison with the implementation of objects in languages ‚Äã‚Äãyou already know. <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/420615/">https://habr.com/ru/post/420615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420605/index.html">Overview of tasks for interviewing algorithms - generating sets</a></li>
<li><a href="../420607/index.html">Digital events in Moscow from August 20 to 26</a></li>
<li><a href="../420609/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ327 (August 13 - 19, 2018)</a></li>
<li><a href="../420611/index.html">Modeling Quantum Entanglement on C #</a></li>
<li><a href="../420613/index.html">11 libraries (sets of components) for React Native, which you should know about in 2018</a></li>
<li><a href="../420617/index.html">Developer Web Design Guide</a></li>
<li><a href="../420619/index.html">Responsive images: CSS techniques that help save time</a></li>
<li><a href="../420623/index.html">Distributed C ++ applications with minimal effort</a></li>
<li><a href="../420625/index.html">KDD 2018, first day, tutorials</a></li>
<li><a href="../420627/index.html">Asynchronous C # programming: how are you doing with performance?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>