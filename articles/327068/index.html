<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PHP 7 Virtual Machine</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day to all! My name is Konstantin, I work in Badoo in the Features Team. Most likely, you already know that our backend is written in PHP and ser...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PHP 7 Virtual Machine</h1><div class="post__text post__text-html js-mediator-article">  <i>Good day to all!</i>  <i>My name is Konstantin, I work in Badoo in the Features Team.</i>  <i>Most likely, you already know that our backend is written in PHP and serves more than three hundred million users.</i>  <i>So I could not miss the chance to translate this article from PHP developer Nikita Popov.</i>  <i>I am sure it will be useful for developers of all levels, but it may seem complicated for beginners.</i>  <i>Have a nice (and helpful) reading!</i> <br><br><img src="https://habrastorage.org/files/cba/2e4/816/cba2e4816c9945ebb6252e504a5b2eb8.jpg"><br><br>  This article provides an overview of the Zend virtual machine for PHP 7. This is not an exhaustive description, but I will try to cover most of the important parts, as well as some details. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The description is made based on PHP version 7.2 (currently under development), but almost everything is true for PHP 7.0 / 7.1.  However, the differences from the PHP 5.x series virtual machines are significant, and I, as a rule, did not draw parallels with them. <br><a name="habracut"></a><br>  Most of the article deals with things at the instruction listing level, and only a few sections at the end relate to the level of the actual implementation of the virtual machine in C. However, I want to provide links to the main files that make up the virtual machine: <br><ul><li>  <a href="">zend_vm_def.h</a> : virtual machine definition file; </li><li>  <a href="">zend_vm_execute.h</a> : generated virtual machine; </li><li>  <a href="https://github.com/php/php-src/blob/master/Zend/zend_vm_gen.php">zend_vm_gen.php</a> : generating script; </li><li>  <a href="">zend_execute.c</a> : most of the directly serving code. </li></ul><br><br><h2>  Opcodes (Opcodes) </h2><br>  In the beginning was the opcode.  Speaking of "opcode", we refer to the instruction of the virtual machine as a whole (including operands), but it can also mean only an "actual" opcode, which is a small integer number that defines the type of instruction.  The intended meaning should be clear from the context.  In the source code, the full instructions are usually called oplines. <br>  A separate instruction corresponds to the following <b>zend_op</b> structure: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_op</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *handler; znode_op op1; znode_op op2; znode_op result; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> extended_value; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> lineno; zend_uchar opcode; zend_uchar op1_type; zend_uchar op2_type; zend_uchar result_type; };</code> </pre> <br>  Thus, opcodes are essentially an instruction in the format of a "three-address code."  There is an <b>opcode</b> that determines the type of instruction, there are two input operands <b>op1</b> and <b>op2</b> and one output operand <b>result</b> . <br><br>  Not all instructions use all operands.  The <b>ADD</b> instruction (representing the <b>+</b> operator) will use all three.  The <b>BOOL_NOT</b> instruction (representing the operator <b>!</b> ) Uses only op1 and result.  The <b>ECHO</b> instruction uses only op1.  Some instructions may or may not use the operand.  For example, <b>DO_FCALL</b> may or may not have a result operand (depending on whether the return value of the function call is used).  Some instructions require more than two input operands, and in this case for additional operands they will simply use the second auxiliary instruction ( <b>OP_DATA</b> ). <br><br>  Next to these three standard operands, there is an additional <b>extended_value</b> numeric field that can be used to store additional instruction modifiers.  For example, for <b>CAST,</b> it may contain the target type to which you want to cast. <br><br>  Each operand has a type stored in <b>op1_type</b> , <b>op2_type,</b> and <b>result_type,</b> respectively.  Possible types: <b>IS_UNUSED</b> , <b>IS_CONST</b> , <b>IS_TMPVAR</b> , <b>IS_VAR</b> and <b>IS_CV</b> . <br><br>  The last three types are for operand variables (with three different types of virtual machine variables), <b>IS_CONST</b> denotes a constant operand ( <b>5</b> , or <b>"string"</b> , or even <b>[1, 2, 3]</b> ), while <b>IS_UNUSED</b> denotes an operand, which is either not actually used or used as a 32-bit numeric value (the so-called direct operand).  For example, a jump instruction will store the jump address in the <b>UNUSED</b> operand. <br><br><h3>  Receiving dump opcodes </h3><br>  In the future, I will often demonstrate fragments of the opcode that PHP generates.  Currently there are three ways to get such opcode dumps: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># Opcache, since PHP 7.1 php -d opcache.opt_debug_level=0x10000 test.php # phpdbg, since PHP 5.6 phpdbg -p* test.php # vld, third-party extension php -d vld.active=1 test.php</span></span></code> </pre> <br>  Of these, opcache provides the best result.  The listings used in this article are based on opcache dumps, with minor syntax adjustments.  The magic number <b>0x10000</b> is an abbreviation "before optimization", so we see opcodes as the PHP compiler created them.  <b>0x200000</b> will give you optimized opcodes.  Opcache can also generate much more information.  For example, <b>0x40000 will</b> generate a CFG, and <b>0x200000</b> will generate an <a href="https://ru.wikipedia.org/wiki/SSA">SSA</a> .  But let's not get ahead of events: for our purposes, the rather common old linearized opcode dumps. <br><br><h2>  Variable Types </h2><br>  Probably one of the most important points to consider when working with a PHP virtual machine is the use of three different types of variables.  In PHP 5, TMPVAR, VAR and CV had very different views on the virtual machine stack, and the ways to access them were also very different.  In PHP 7, they became very similar because they use the same storage engine.  However, there are important differences in the meanings they may contain and in their semantics. <br><br>  CV is short for ‚Äúcompiled variable‚Äù.  It refers to the "real" PHP variable.  If the function uses the <b>$ a</b> variable, then it will have the corresponding CV for it. <br><br>  CV variables can be of type <b>UNDEF</b> to denote undefined variables.  If the instruction uses a UNDEF CV, in most cases it gives the well-known notification ‚Äúundefined variable‚Äù (undefined variable).  At the input of the function, all non-argument CVs are initialized as UNDEF. <br><br>  CV variables are not destroyed by instructions.  For example, the instruction <b>ADD $ a, $ b</b> does not destroy the values ‚Äã‚Äãstored in the variables <b>$ a</b> and <b>$ b</b> .  Instead, all CV variables are destroyed at the same time when they go out of scope.  This also implies that all CV variables contain valid values ‚Äã‚Äãthroughout the duration of the function. <br><br>  The variables TMPVAR and VAR, in turn, are temporary variables of the virtual machine.  They are usually entered as an operand of the result of some operation.  For example, the code <b>$ a = $ b + $ c + $ d</b> will result in an opcode similar to the following: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">T0</span></span> = ADD <span class="hljs-variable"><span class="hljs-variable">$b</span></span>, <span class="hljs-variable"><span class="hljs-variable">$c</span></span> T1 = ADD T0, <span class="hljs-variable"><span class="hljs-variable">$d</span></span> ASSIGN <span class="hljs-variable"><span class="hljs-variable">$a</span></span>, T1</code> </pre> <br>  TMP / VAR variables are always defined before use and as such cannot contain a UNDEF value.  Unlike CV, these types of variables are destroyed by the instructions in which they are used.  In the example above, the second ADD will destroy the value of the operand T0, and after this point T0 should not be used anymore.  Similarly, ASSIGN will destroy the value of T1, making the variable T1 invalid. <br><br>  From this it follows that the variables TMP / VAR are usually very short-lived.  In most cases, they live only within one instruction.  Outside this short interval, the values ‚Äã‚Äãin them are rubbish. <br><br>  So what is the difference between TMP and VAR variables?  They are few.  The difference was inherited from PHP 5, where TMP was placed on the virtual machine stack, and VAR - on the heap.  In PHP 7, all variables are placed on the stack.  Thus, at present, the main difference between TMP and VAR is that only the latter is allowed to contain references (this allows us to exclude dereferencing (DEREF) of TMP variables).  In addition, VARs can contain two types of special values, namely class entries and INDIRECT values.  The latter are used to process nontrivial assignments. <br><br>  This table shows the main differences of the variables: <br><table><tbody><tr><th></th><th>  UNDEF </th><th>  Ref </th><th>  INDIRECT </th><th>  Consumed? </th><th>  Named? </th></tr><tr><td>  CV </td><td>  yes </td><td>  yes </td><td>  no </td><td>  no </td><td>  yes </td></tr><tr><td>  TMPVAR </td><td>  no </td><td>  no </td><td>  no </td><td>  yes </td><td>  no </td></tr><tr><td>  Var </td><td>  no </td><td>  yes </td><td>  yes </td><td>  yes </td><td>  no </td></tr></tbody></table><br><h2>  Op-arrays </h2><br>  All PHP functions are represented as structures having a common <b>zend_function</b> header.  The concept of ‚Äúfunction‚Äù here is interpreted somewhat more broadly and includes everything from ‚Äúreal‚Äù functions and methods to autonomous pseudo-main code and eval code. <br><br>  The user functions use the <b>zend_op_array</b> structure.  It has more than 30 fields, so I will start with its smaller version: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Common zend_function header here */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> last; zend_op *opcodes; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> last_var; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> T; zend_string **vars; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> last_literal; zval *literals; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> };</code> </pre><br>  The most important part here is, of course, the <b>opcodes</b> , which are an array of opcodes (instructions).  <b>last</b> is the number of opcodes in this array.  Note that the terminology is somewhat confusing, since <b>last</b> sounds like it should be the index of the last opcode, while in fact it is the number of opcodes (one more than the last index).  The same applies to all other <b>last_ *</b> values ‚Äã‚Äãin the op_array structure. <br><br>  <b>last_var</b> is the number of CVs, and <b>T</b> is the number of TMP and VAR (in most cases we do not distinguish between them).  <b>vars</b> is an array of names for CV. <br><br>  <b>literals</b> are an array of literals occurring in code, something that the <b>CONST</b> operands <b>refer to</b> .  Depending on the ABI, each <b>CONST</b> operand will either contain a pointer to an element of this literal table, or store an offset from its beginning. <br><br>  There is something else in this structure, but this can be postponed. <br><br><h2>  Stack frame layout </h2><br>  With the exception of executor globals (EG), the entire execution state is stored on the virtual machine stack.  The VM stack is distributed on 256KiB pages, and individual pages are linked through a linked list. <br><br>  Each time a function is called, a new stack frame is allocated in the virtual machine stack, which has the following scheme: <br><pre> <code class="cpp hljs">+----------------------------------------+ | zend_execute_data | +----------------------------------------+ | VAR[<span class="hljs-number"><span class="hljs-number">0</span></span>] = ARG[<span class="hljs-number"><span class="hljs-number">1</span></span>] | arguments | ... | | VAR[num_args<span class="hljs-number"><span class="hljs-number">-1</span></span>] = ARG[N] | | VAR[num_args] = CV[num_args] | remaining CVs | ... | | VAR[last_var<span class="hljs-number"><span class="hljs-number">-1</span></span>] = CV[last_var<span class="hljs-number"><span class="hljs-number">-1</span></span>] | | VAR[last_var] = TMP[<span class="hljs-number"><span class="hljs-number">0</span></span>] | TMP/VARs | ... | | VAR[last_var+T<span class="hljs-number"><span class="hljs-number">-1</span></span>] = TMP[T] | | ARG[N+<span class="hljs-number"><span class="hljs-number">1</span></span>] (extra_args) | extra arguments | ... | +----------------------------------------+</code> </pre><br>  A frame begins with a <b>zend_execute_data</b> structure, followed by an array of variable slots.  The slots are all the same (simple zval), but they are used for different purposes.  The first <b>last_var</b> slots are CVs, of which the first <b>num_args</b> contains the function arguments.  The CV slots are followed by <b>T-</b> slots for TMP / VAR.  Finally, sometimes there may be additional arguments stored at the end of the frame.  They are used for <b>func_get_args ()</b> . <br><br>  The CV and TMP / VAR operands in the instructions are encoded as offsets relative to the beginning of the stack frame, so sampling a particular variable is a simple reading from the cell at the address <b>execute_data</b> plus the specified offset. <br><br>  The data at the beginning of the frame is defined as follows: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_execute_data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> zend_op *opline; zend_execute_data *call; zval *return_value; zend_function *func; zval This; <span class="hljs-comment"><span class="hljs-comment">/* this + call_info + num_args */</span></span> zend_class_entry *called_scope; zend_execute_data *prev_execute_data; zend_array *symbol_table; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **run_time_cache; <span class="hljs-comment"><span class="hljs-comment">/* cache op_array-&gt;run_time_cache */</span></span> zval *literals; <span class="hljs-comment"><span class="hljs-comment">/* cache op_array-&gt;literals */</span></span> };</code> </pre><br>  Most importantly, this structure contains the <b>opline</b> , which is the instruction currently being executed, and <b>func</b> , which is the function that is currently being executed.  Moreover: <br><ul><li>  <b>return_value</b> pointer to zval, in which the return value will be stored; </li><li>  <b>This</b> is the <b>$ this</b> object, but also the number of function arguments and a pair of call metadata flags in some unused zval spaces; </li><li>  <b>called_scope</b> scope, which in PHP-code refers to <b>static ::</b> ; </li><li>  <b>prev_execute_data</b> points to the previous stack frame, to which execution will return to after completion of this function; </li><li>  <b>symbol_table is a</b> normally unused symbol table, used if a madman actually uses variable variables or similar functions; </li><li>  <b>run_time_cache</b> caches op_array-&gt; run_time_cache to avoid indirect addressing when accessing this structure (which will be discussed below); </li><li>  <b>The literals</b> caches an op-array literal table for the same reason. </li></ul><br><br><h2>  Function calls </h2><br>  I missed one field in the execute_data structure, namely, <b>call</b> , since it requires some additional explanation of how function calls work. <br><br>  All calls use the same sequence of instructions.  <b>var_dump ($ a, $ b)</b> in the global scope is compiled into: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">INIT_FCALL</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> args) <span class="hljs-string"><span class="hljs-string">"var_dump"</span></span> SEND_VAR <span class="hljs-variable"><span class="hljs-variable">$a</span></span> SEND_VAR <span class="hljs-variable"><span class="hljs-variable">$b</span></span> V0 = DO_ICALL <span class="hljs-comment"><span class="hljs-comment">#   DO_ICALL  retval  </span></span></code> </pre> <br>  There are eight different types of INIT instructions (whichever is the call).  INIT_FCALL is used for function calls (not being class methods) that we recognize at compile time.  Similarly, there are ten different SEND opcodes (depending on the type of arguments and function).  There is only a small number of the four DO_CALL opcodes, where ICALL is used to call internal functions. <br><br>  Although specific instructions may differ, the structure is always the same: INIT, SEND, DO.  The main problem that a sequence of calls should handle is nested function calls that compile something like this: <br><pre> <code class="hljs mel"># var_dump(foo($a), bar($b)) INIT_FCALL (<span class="hljs-number"><span class="hljs-number">2</span></span> args) <span class="hljs-string"><span class="hljs-string">"var_dump"</span></span> INIT_FCALL (<span class="hljs-number"><span class="hljs-number">1</span></span> arg) <span class="hljs-string"><span class="hljs-string">"foo"</span></span> SEND_VAR $a V0 = DO_UCALL SEND_VAR V0 INIT_FCALL (<span class="hljs-number"><span class="hljs-number">1</span></span> arg) <span class="hljs-string"><span class="hljs-string">"bar"</span></span> SEND_VAR $b V1 = DO_UCALL SEND_VAR V1 V2 = DO_ICALL</code> </pre><br>  I formatted the opcode sequence to visualize which instructions correspond to which call. <br><br>  The INIT opcode pushes a call frame onto the stack that contains enough space for all the variables and function arguments that we know about (if decompressing the arguments is involved, we can end up with more arguments).  This call block is initialized by the called function, <b>$ this</b> and <b>called_scope</b> (in this case both of the latter will be NULL, since we call functions). <br><br>  A pointer to the new frame is stored in <b>execute_data-&gt; call</b> , where <b>execute_data</b> is the frame of the calling function.  In the future, we will denote this as <b>EX (call)</b> .  It is noteworthy that the <b>prev_execute_data of the</b> new frame is set to the old value <b>EX (call)</b> .  For example, INIT_FCALL to call <b>foo</b> will write the <b>var_dump</b> stack frame to <b>prev_execute_data</b> .  Thus, prev_execute_data in this case forms a linked list of "unfinished" calls, while usually it provides a <b>backtrace</b> chain. <br><br>  Then the SEND opcodes go on to passing arguments to the slots of <b>EX (call)</b> variables.  At this stage, all arguments are consecutive and can flow from the section for arguments to other CVs or TMPs.  This will be fixed later. <br><br>  Finally, DO_FCALL makes the actual call.  What was <b>EX (call)</b> becomes the current function, and <b>prev_execute_data</b> changes to the calling function.  In addition, the calling procedure depends on which function it is.  Internal functions need only call the handler function, while user functions must complete the initialization of the stack frame. <br><br>  This initialization involves arranging the stack of arguments.  PHP allows you to pass more arguments to functions than it expects (and <b>func_get_args</b> relies on this).  However, only actual arguments have corresponding CVs.  Any other arguments will be written to memory reserved for other CVs and TMPs.  Essentially, these arguments will be placed after the TMP, with the result that the arguments will be divided into two separate fragments. <br><br>  It is necessary to clarify that calls to user-defined functions do not imply recursion at the virtual machine level.  They only mean switching from one execute_data to another, but the VM continues to operate in a linear loop.  Recursive calls to the virtual machine occur only if the internal functions call custom callbacks (for example, via array_map).  For this reason, infinite recursion in PHP is usually interrupted due to a lack of memory or an OOM error, but a recursion stack overflow through callbacks or magic methods can be caused. <br><br><h3>  Passing arguments </h3><br>  To pass arguments, PHP uses a large number of opcodes, the differences between which can be confusing due to their unfortunate naming. <br><br>  SEND_VAL and SEND_VAR are the simplest variants that pass arguments by value when the value is known at compile time.  SEND_VAL is used for CONST and TMP operands, and SEND_VAR is used for VAR and CV. <br><br>  SEND_REF, in contrast, is used for arguments that are known at compile time to be references.  Since only pointers can be passed by reference, this opcode accepts only VAR and CV. <br><br>  SEND_VAL_EX and SEND_VAR_EX - options SEND_VAL / SEND_VAR for cases where we can not statically determine whether the argument is passed by value or by reference.  These opcodes check the type of the argument based on arginfo and behave accordingly.  In most cases, it is not the arginfo structure that is actually used, but a rather compact bit vector directly in the function structure. <br><br>  And there is SEND_VAR_NO_REF_EX.  Do not try to understand anything of his name - this is an outright lie.  This opcode is used when passing something that is not actually a variable, but returns a VAR as a statically unknown argument.  Two specific examples in which it is used are the transfer of the result of a function call as an argument and the transfer of the result of an assignment. <br><br>  This case requires a separate opcode for two reasons: first, it will create the familiar message ‚ÄúOnly variables must be passed by reference‚Äù, if you try to transfer something like assignment by reference (if SEND_VAR_EX were used, it would silently allow).  Secondly, this opcode deals with the case when you may need to transfer the result of a function call to a link without raising any exceptions.  The variant of this opcode SEND_VAR_NO_REF (without _EX) is a specialized option for the case when we statically know what the link is expected, but don‚Äôt know if the argument is one. <br><br>  The SEND_UNPACK and SEND_ARRAY opcodes deal with decompressing arguments and nested calls to <b>call_user_func_array,</b> respectively.  Both of them retrieve elements from the array and put them on the stack of arguments and differ in different details (for example, unpacking supports Traversables, but <b>call_user_func_array</b> does not).  If decompression is used, it may be necessary to increase the stack frame (since the actual number of function arguments is unknown during initialization).  In most cases, this increase can occur simply by moving the pointer to the top of the stack.  However, if the page boundary of the stack is crossed, the new page must be selected, and the entire call frame (including arguments already placed on the stack) must be copied to the new page (we cannot process the call frame that crosses the page border). <br><br>  The last opcode, SEND_USER, is used for internal calls to <b>call_user_func</b> and deals with some of its features. <br><br>  Although we have not yet discussed the various modes of obtaining data from variables, it is time to introduce the FUNC_ARG mode.  Consider a simple call of the type <b>func ($ a [0] [1] [2])</b> , for which we do not know at compile time, the argument will be passed by value or by reference.  In these cases, the behavior will be very different.  If passed by value, and <b>$ a</b> is empty, it can create a bunch of "undefined index" notifications.  If passing by reference, we must silently initialize the nested arrays. <br><br>  The FUNC_ARG data acquisition mode dynamically selects one of two behaviors (R or W), checking the arginfo of the current <b>EX (call)</b> function.  For example, the <b>func ($ a [0] [1] [2])</b> sequence of opcodes might look something like this: <br><pre> <code class="hljs lua">INIT_FCALL_BY_NAME <span class="hljs-string"><span class="hljs-string">"func"</span></span> V0 = FETCH_DIM_FUNC_ARG (<span class="hljs-built_in"><span class="hljs-built_in">arg</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) $a, <span class="hljs-number"><span class="hljs-number">0</span></span> V1 = FETCH_DIM_FUNC_ARG (<span class="hljs-built_in"><span class="hljs-built_in">arg</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) V0, <span class="hljs-number"><span class="hljs-number">1</span></span> V2 = FETCH_DIM_FUNC_ARG (<span class="hljs-built_in"><span class="hljs-built_in">arg</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) V1, <span class="hljs-number"><span class="hljs-number">2</span></span> SEND_VAR_EX V2 DO_FCALL</code> </pre><br><h2>  Fetch modes </h2><br>  The PHP virtual machine has four classes of opcodes for receiving data: <br><pre> FETCH_ * // $ _GET, $$ var
 FETCH_DIM_ * // $ arr [0]
 FETCH_OBJ_ * // $ obj-&gt; prop
 FETCH_STATIC_PROP_ * // A :: $ prop
</pre><br>  They do exactly what one would expect from them, with the observation that the basic FETCH_ * variant is used only for accessing variables of variables ($$ var) and superglobal variables: the usual calls to variables instead occur through a faster CV mechanism . <br><br>  These opcodes for data acquisition are presented in six variants: <br><pre> _R
 _RW
 _W
 _IS
 _UNSET
 _FUNC_ARG
</pre><br>  We have already learned that _FUNC_ARG chooses between _R and _W depending on how the function argument is passed, by value or by reference.  Let's try to create some situations when we expect different FETCH_ * variants to appear: <br><pre> <code class="hljs perl">// $arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; V2 = FETCH_DIM_R $arr <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) FREE V2 // $arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] = $val; ASSIGN_DIM $arr <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) OP_DATA $val // $arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span>; ASSIGN_ADD (dim) $arr <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) OP_DATA <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) // isset($arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]); T5 = ISSET_ISEMPTY_DIM_OBJ (isset) $arr <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) FREE T5 // unset($arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]); UNSET_DIM $arr <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><br>  Unfortunately, the actual retrieval by index occurs only in the case of FETCH_DIM_R.       .  ,  ASSIGN_DIM  ASSIGN_ADD   OP_DATA,        .    ,   ASSIGN_DIM,  -  FETCH_DIM_W + ASSIGN,  ( )  ,       (,   ASSIGN_DIM   ,  ArrayAccess :: offsetSet ()).        ,     : <br><pre> <code class="hljs markdown">// $arr[<span class="hljs-string"><span class="hljs-string">0</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">1</span></span>]; V2 = FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_DIM_</span></span>R $arr int(0) V3 = FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_DIM_</span></span>R V2 int(1) FREE V3 // $arr[<span class="hljs-string"><span class="hljs-string">0</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">1</span></span>] = $val; V4 = FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_DIM_</span></span>W $arr int(0) ASSIGN<span class="hljs-emphasis"><span class="hljs-emphasis">_DIM V4 int(1) OP_</span></span>DATA $val // $arr[<span class="hljs-string"><span class="hljs-string">0</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">1</span></span>] += 1; V6 = FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_DIM_</span></span>RW $arr int(0) ASSIGN<span class="hljs-emphasis"><span class="hljs-emphasis">_ADD (dim) V6 int(1) OP_</span></span>DATA int(1) // isset($arr[<span class="hljs-string"><span class="hljs-string">0</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">1</span></span>]); V8 = FETCH<span class="hljs-emphasis"><span class="hljs-emphasis">_DIM_</span></span>IS $arr int(0) T9 = ISSET<span class="hljs-emphasis"><span class="hljs-emphasis">_ISEMPTY_</span></span>DIM<span class="hljs-emphasis"><span class="hljs-emphasis">_OBJ (isset) V8 int(1) FREE T9 // unset($arr[0][1]); V10 = FETCH_</span></span>DIM<span class="hljs-emphasis"><span class="hljs-emphasis">_UNSET $arr int(0) UNSET_</span></span>DIM V10 int(1)</code> </pre><br><br>   ,          ,       FETCH   fetch mode.     ,     ¬´Undefined offset¬ª,    ,       : <br><table><tbody><tr><th></th><th> Notice? <br></th><th> Write? <br></th></tr><tr><td>  R </td><td>  yes </td><td>  no </td></tr><tr><td>  W </td><td>  no </td><td>  yes </td></tr><tr><td>  Rw </td><td>  yes </td><td>  yes </td></tr><tr><td> IS </td><td>  no </td><td>  no </td></tr><tr><td> UNSET </td><td>  no </td><td> yes-ish </td></tr></tbody></table><br>   UNSET  ,              .  - (write-fetch)     . <br><br><h3>      </h3><br> Write fetches  VAR,      zval,  INDIRECT-   zval. ,     ,   zval,   ,        VM.  PHP    <b>[][0] = 42</b> ,         ,  <b>call()[0] = 42</b> .    ,  <b>call()</b>   ,         . <br><br>    ‚Äì  fetch  INDIRECT,        (,      -).  ,         :         ,  ¬´¬ª .  ,       ,    INDIRECT,    . <br><br>   : <br><pre> <code class="php hljs">$arr[a()][b()] = c();</code> </pre><br>  : <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">INIT_FCALL_BY_NAME</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> args) <span class="hljs-string"><span class="hljs-string">"a"</span></span> V1 = DO_FCALL_BY_NAME INIT_FCALL_BY_NAME (<span class="hljs-number"><span class="hljs-number">0</span></span> args) <span class="hljs-string"><span class="hljs-string">"b"</span></span> V3 = DO_FCALL_BY_NAME INIT_FCALL_BY_NAME (<span class="hljs-number"><span class="hljs-number">0</span></span> args) <span class="hljs-string"><span class="hljs-string">"c"</span></span> V5 = DO_FCALL_BY_NAME V2 = FETCH_DIM_W <span class="hljs-variable"><span class="hljs-variable">$arr</span></span> V1 ASSIGN_DIM V2 V3 OP_DATA V5</code> </pre><br> ,                - (   FETCH_DIM_W ¬´ opline¬ª).  ,  write-fetch  ,   fetch,     . <br><br>   : <br><pre> <code class="php hljs">$arr[<span class="hljs-number"><span class="hljs-number">0</span></span>] =&amp; $arr[<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre><br>      :        .     <b>$arr[0]</b>  ,   <b>$arr[1]</b>  ,     .     : <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">V2</span></span> = FETCH_DIM_W <span class="hljs-variable"><span class="hljs-variable">$arr</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> V3 = MAKE_REF V2 V1 = FETCH_DIM_W <span class="hljs-variable"><span class="hljs-variable">$arr</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> ASSIGN_REF V1 V3</code> </pre><br>  <b>$arr[1]</b>    ,     ,  MAKE_REF.  MAKE_REF    INDIRECT    ,    <b>$arr[0]</b>   . <br><br><h2>   </h2><br>  ‚Äî    . <br><br>       <b>EG(exception)</b> ,  EG   executor globals.     C    ;               <b>EG(exception)</b> .    ,       . <br><br>    VM          . ,  ¬´ ¬ª    ,     .     <b>EG(exception)</b>    VM.     : <br><br>   ,  opline  execute data   opline HANDLE_EXCEPTION (   op array,    ). Opline,    ,   <b>EG(opline_before_exception)</b> .  , ,        ,    HANDLE_EXCEPTION.      :  , : )  opline,   execute data,       opline ( opline_before_exception   );  )    opline  execute data    ( HANDLE_EXCEPTION   ). <br><br>      ,   .   ,         opline,     opline,   execute data.   PHP 7       GOTO  SWITCH,   PHP 7      :    , opline    . <br><br>  ,    ,    ,  opline      execute data ( SAVE_OPLINE).        opline     execute data (  CHECK_EXCEPTION). <br><br>   HANDLE_EXCEPTION   ,    .    ?  ,  ,       try.   op array   try_catch_elements,    opline   try, catch  finally: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_try_catch_element</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> try_op; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> catch_op; <span class="hljs-comment"><span class="hljs-comment">/* ketchup! */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> finally_op; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> finally_end; } zend_try_catch_element;</code> </pre><br>     ,   finally  ,      . ,       try,       ,     ,       try. <br><br>            ,       .         ,         .           : <br><pre> <code class="hljs pgsql"># (<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>)[] + throwing() L0: T0 = CAST (<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>) [] L1: INIT_FCALL (<span class="hljs-number"><span class="hljs-number">0</span></span> args) "throwing" L2: V1 = DO_FCALL L3: T2 = <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> T0, V1</code> </pre><br>     T0     L1  L2      ,    . <br><br>     ,      , ‚Äî  .  For example: <br><pre> <code class="hljs mel"># foreach ($array as $value) throw $ex; L0: V0 = FE_RESET_R $array, -&gt;L4 L1: FE_FETCH_R V0, $value, -&gt;L4 L2: THROW $ex L3: JMP -&gt;L1 L4: FE_FREE V0</code> </pre><br>    V0   L1  L3 (     ).     op array,   : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">zend_live_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> var; <span class="hljs-comment"><span class="hljs-comment">/* low bits are used for variable type (ZEND_LIVE_* macros) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> start; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> end; } zend_live_range;</code> </pre><br>  <b>var</b> ‚Äî  ,    , <b>start</b> ‚Äî    opline (   ),  <b>end</b> ‚Äî   opline (  ). ,       ,      . <br><br>   <b>var</b>     ,      : <br><ul><li> ZEND_LIVE_TMPVAR:  ¬´¬ª .     zval.        FREE; </li><li> ZEND_LIVE_LOOP:    foreach,     zval.    FE_FREE; </li><li> ZEND_LIVE_SILENCE:      .      ,   .   , , ,    .  END_SILENCE; </li><li> ZEND_LIVE_ROPE:    ,           <b>zend_string*</b> ,   .     ,    ,   .   END_ROPE. </li></ul><br>  ,      ,   ,     ,        .   : <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">T2</span></span> = ADD T0, T1 ASSIGN <span class="hljs-variable"><span class="hljs-variable">$v</span></span>, T2</code> </pre><br>    ADD,   T2  ,   ADD-   ? ,  ASSIGN  ,   T2   ,  ASSIGN     ?     :       ,    . <br><br>     ,       PHP 7.1  7.2.  PHP 7.1         ,   PHP 7.2    (    ,    ).     ‚Äî ,      (  ADD).     : <br><ol><li>   . </li><li>  ,  . </li><li>    ( ). </li></ol><br>  ,   PHP     ,      ,       (  ,      ).  ,  3   ,      .       ,             . <br><br>       ,      catch.  catch  (  finally),   ,              . <br><br>       ,     ,      ,     .    ,          . <br>   : <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dtor <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $value) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Return"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $e) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Catch"</span></span>; } }</code> </pre><br>  ,  <b>Dtor</b> ‚Äî   Traversable    .        (     ): <br><pre> <code class="hljs kotlin">L0: V0 = NEW <span class="hljs-string"><span class="hljs-string">'Dtor'</span></span>, -&gt;L2 L1: DO_FCALL L2: V2 = FE_RESET_R V0, -&gt;L11 L3: FE_FETCH_R V2, $value L4: ECHO <span class="hljs-string"><span class="hljs-string">'Return'</span></span> L5: FE_FREE (free on <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>) V2 # &lt;- <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L6: RETURN <span class="hljs-literal"><span class="hljs-literal">null</span></span> # &lt;- <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> L7: JMP -&gt;L10 L8: CATCH <span class="hljs-string"><span class="hljs-string">'Exception'</span></span> $e L9: ECHO <span class="hljs-string"><span class="hljs-string">'Catch'</span></span> L10: JMP -&gt;L3 L11: FE_FREE V2 # &lt;- the duplicated instr</code> </pre><br>  ,  return   FE_FREE-   RETURN.  ,  FE_FREE  ?   <b>Dtor</b>   .   ,       try,     catch.        ! Catch   ‚Äì         . <br><br>     , ,     FE_FREE    try,    FE_FREE  L11.   ,      .   FE_FREE,  ,   FREE_ON_RETURN.            .  ,        catch ‚Äì     . <br><br><h3>  finally </h3><br>  PHP   finally  .      PHP 5.5,    -  . PHP 5.6, 7.0  7.1       .      ,       .  , , PHP 7.1  -  ( ). <br><br>         ,        finally        . ,      ,   .  ,             (,  ,    PHP 5     AST). <br><br>  finally   ,      try,    (,   return),   ( ).      ,   ,     . : <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; }</code> </pre><br>  What's happening? Finally ,    42. <br><br> : <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; }</code> </pre><br>   finally ,    42. Finally  . <br><br> PHP     finally. ,  : <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $value) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } }</code> </pre><br> Continue     .  ,    ‚Äì  ¬´¬ª,     ,       catch: <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($array <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $value) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JumpException; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (JumpException $e) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } }</code> </pre><br>   ,  ,   ,      finally. ,   goto   finally     finally. <br><br>   ,   ,  finally .    : FAST_CALL  FAST_RET.  , FAST_CALL      finally,  FAST_RET ‚Äî    .   : <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"try"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"finally"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"finished"</span></span>;</code> </pre><br>       : <br><pre> <code class="hljs php">L0: <span class="hljs-keyword"><span class="hljs-keyword">ECHO</span></span> string(<span class="hljs-string"><span class="hljs-string">"try"</span></span>) L1: T0 = FAST_CALL -&gt;L3 L2: JMP -&gt;L5 L3: <span class="hljs-keyword"><span class="hljs-keyword">ECHO</span></span> string(<span class="hljs-string"><span class="hljs-string">"finally"</span></span>) L4: FAST_RET T0 L5: <span class="hljs-keyword"><span class="hljs-keyword">ECHO</span></span> string(<span class="hljs-string"><span class="hljs-string">"finished"</span></span>) L6: <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> int(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br> FAST_CALL      T0    finally-  L3.   FAST_RET,    ,   T0.      L2,      finally.   ,      (  ). <br><br>     : <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"try"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"catch"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"finally"</span></span>); }</code> </pre><br>              try/catch/finally: <br><ol><li>   try   catch:  $e    catch. </li><li>   catch  try   catch,   finally-:    finally     FAST_CALL      (      ). </li><li>   finally:    ,   FAST_CALL,         .      try/catch/finally. </li><li>   :      try/catch/finally. </li></ol><br><br>        :     try,    catch. Catch   ,     finally     FAST_CALL.  finally   ,    ¬´finally¬ª    ¬´catch¬ª,     . <br><br>       : <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"try"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> {} } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> $e) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"catch"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> {} } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"finally"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> {} }</code> </pre><br>      finally     ,   ‚Äì   ( FAST_RET).              try/catch/finally.   try/catch    FAST_RET ( ‚Äì ¬´try-catch(0)¬ª). <br><br>      finally  .    return  finally? <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"try"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; }</code> </pre><br>     : <br><pre> <code class="hljs php">L4: T0 = FAST_CALL -&gt;L6 L5: JMP -&gt;L9 L6: DISCARD_EXCEPTION T0 L7: <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> L8: FAST_RET T0</code> </pre><br>   DISCARD_EXCEPTION       ,    try (:   finally ).    return  try? <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { $a = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { ++$a; }</code> </pre><br>     42,   43,      <b>return $a</b> ,     <b>$a</b>    .    : <br><pre> <code class="hljs php">L0: ASSIGN $a, <span class="hljs-number"><span class="hljs-number">42</span></span> L1: T3 = QM_ASSIGN $a L2: T1 = FAST_CALL -&gt;L6, T3 L3: <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> T3 L4: T1 = FAST_CALL -&gt;L6 <span class="hljs-comment"><span class="hljs-comment">#  L5: JMP -&gt;L8 #  L6: PRE_INC $a L7: FAST_RET T1 L8: RETURN null</span></span></code> </pre><br>    ,       return.      ,     .     . -, $a   T3,  QM_ASSIGN (     ¬´   ¬ª).       $a   . -, T3    FAST_CALL,      T1.   return   try   (,    finally  throw  return),         . <br><br>       ,        .   ,  <b>Dtor</b>    Traversable    : <br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dtor <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $v) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"finally"</span></span>; }</code> </pre><br>     : <br><pre> <code class="hljs rust">L0: V2 = NEW (<span class="hljs-number"><span class="hljs-number">0</span></span> args) <span class="hljs-string"><span class="hljs-string">"Dtor"</span></span> L1: DO_FCALL L2: V4 = FE_RESET_R V2 -&gt;L16 L3: FE_FETCH_R V4 $v -&gt;L16 L4: T5 = FAST_CALL -&gt;L10 #  try L5: FE_FREE (free on <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>) V4 L6: T1 = FAST_CALL -&gt;L19 L7: RETURN <span class="hljs-number"><span class="hljs-number">1</span></span> L8: T5 = FAST_CALL -&gt;L10 #  L9: JMP -&gt;L15 L10: DISCARD_EXCEPTION T5 #  finally L11: FE_FREE (free on <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>) V4 L12: T1 = FAST_CALL -&gt;L19 L13: RETURN <span class="hljs-number"><span class="hljs-number">2</span></span> L14: FAST_RET T5 try-catch(<span class="hljs-number"><span class="hljs-number">0</span></span>) L15: JMP -&gt;L3 L16: FE_FREE V4 L17: T1 = FAST_CALL -&gt;L19 L18: JMP -&gt;L21 L19: ECHO <span class="hljs-string"><span class="hljs-string">"finally"</span></span> #  finally L20: FAST_RET T1</code> </pre><br>    return (  try) ‚Äî FAST_CALL L10, FE_FREE V4, FAST_CALL L19, RETURN.      finally,     foreach,     finally , ,  .    return (  finally) ‚Äî DISCARD_EXCEPTION T5, FE_FREE V4, FAST_CALL L19.     (  ‚Äì  )   try,     foreach , ,    finally.  ,               . <br><br><h2>  Generators </h2><br>        , ,      .   : <br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ foo(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $x); }</code> </pre><br>     : <br><pre> <code class="hljs php">$x = RECV <span class="hljs-number"><span class="hljs-number">1</span></span> GENERATOR_CREATE INIT_FCALL_BY_NAME (<span class="hljs-number"><span class="hljs-number">1</span></span> args) string(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>) V1 = <span class="hljs-keyword"><span class="hljs-keyword">YIELD</span></span> $x SEND_VAR_NO_REF_EX V1 <span class="hljs-number"><span class="hljs-number">1</span></span> DO_FCALL_BY_NAME GENERATOR_RETURN <span class="hljs-keyword"><span class="hljs-keyword">null</span></span></code> </pre><br><br>   GENERATOR_CREATE          . GENERATOR_CREATE   <b>Generator</b> ,       execute_data (     ,  ),     execute_data   VM. <br><br>    , executor   execute_data  ,           .     , ,    ,       .  YIELD   ,     foo()      VM. <br><br>                yield       . <br>      PHP 7.1.        VM- 4 KB,    executor   .       ,    . <br><br><h2> - </h2><br>         .  For example: <br><pre> <code class="hljs php">L0: T2 = IS_EQUAL $a, $b L1: JMPZ T2 -&gt;L3 L2: <span class="hljs-keyword"><span class="hljs-keyword">ECHO</span></span> <span class="hljs-string"><span class="hljs-string">"equal"</span></span></code> </pre><br>     ,    (  IS_EQUAL)   - (smart branch):  ,      JMPZ  JMPNZ,   ,     . <br><br>    ,     JMPZ/JMPNZ,   ,        .       ,       . ,  <b>($a == $b) + ($d? $e: $f)</b> : <br><pre> <code class="hljs php">L0: T5 = IS_EQUAL $a, $b L1: NOP L2: JMPZ $d -&gt;L5 L3: T6 = QM_ASSIGN $e L4: JMP -&gt;L6 L5: T6 = QM_ASSIGN $f L6: T7 = ADD T5 T6 L7: FREE T7</code> </pre><br>  ,   IS_EQUAL  JMPZ  NOP.    NOP  ,       IS_EQUAL,    JMPZ. <br><br><h2> - </h2><br>          ( ),    .  -      -,      .      - (  ). <br><br>  -   .  ‚Äî     (,   INIT_FCALL).  ,  INIT_FCALL      (  ),        -. <br><br>   ‚Äî    ,      -,     ,   ‚Äî   .      FETCH_OBJ_R,         .           (  ),    .        ,      . <br><br><h2>    </h2><br>  PHP 7.0  - ,     -    .    ,    .   PHP 7.0  - ,      .        () ,   .   PHP 7.1 pcntl-     ,   - . <br><br>      ,   ,       .       ,      .  ,          ,        . <br><br><h2>  Specialization </h2><br>     <a href="">   </a> ,  ,      : <br><pre> <code class="cpp hljs">ZEND_VM_HANDLER(<span class="hljs-number"><span class="hljs-number">1</span></span>, ZEND_ADD, CONST|TMPVAR|CV, CONST|TMPVAR|CV)</code> </pre><br>  1 ‚Äî  , ZEND_ADD ‚Äî  ,     ,     . <a href="">   </a> (   zend_vm_gen.php)           .    ,   ZEND_ADD_SPEC_CONST_CONST_HANDLER. <br><br>          .   OP1_TYPE  OP2_TYPE,   ,  GET_OP1_ZVAL_PTR ()  FREE_OP1 (),   . <br><br>   ADD ,     <b>CONST</b> | <b>TMPVAR</b> | <b>CV</b> .  TMPVAR ,      TMP,   VAR,  ,     . ,        TMP  VAR   ,     .    ,  ADD (        ),        .    ,   ,      TMP|VAR. <br><br>    ,       , ,    . <br><br> ASSIGN_DIM       OP_DATA-: <br><pre> <code class="cpp hljs">ZEND_VM_HANDLER(<span class="hljs-number"><span class="hljs-number">147</span></span>, ZEND_ASSIGN_DIM, VAR|CV, CONST|TMPVAR|UNUSED|NEXT|CV, SPEC(OP_DATA=CONST|TMP|VAR|CV))</code> </pre> <br>       <b>2*4*4=32</b>   ASSIGN_DIM. <br><br>        <b>NEXT</b> .     ,    ,    UNUSED-   :  ,     ( <b>$arr[]</b> ). <br><br>  : <br><pre> <code class="cpp hljs">ZEND_VM_HANDLER(<span class="hljs-number"><span class="hljs-number">23</span></span>, ZEND_ASSIGN_ADD, VAR|UNUSED|THIS|CV, CONST|TMPVAR|UNUSED|NEXT|CV, DIM_OBJ, SPEC(DIM_OBJ))</code> </pre> <br>   UNUSED-    <b>$this</b> .     ,    (, <b>FETCH_OBJ_R UNUSED</b> , ' <b>prop</b> '  <b>$this-&gt;prop</b> ).  UNUSED-    .       extended_value:   ,   <b>$a += 1</b> , <b>$a[$b] += 1</b>  <b>$a-&gt;b += 1</b> . , , <b>SPEC(DIM_OBJ)</b> ,          .        ,    ,    . , UNUSED op1     OBJ  . . <br><br> ,     ,    .          : <br><pre> <code class="cpp hljs">ZEND_VM_TYPE_SPEC_HANDLER( ZEND_ADD, (res_info == MAY_BE_LONG &amp;&amp; op1_info == MAY_BE_LONG &amp;&amp; op2_info == MAY_BE_LONG), ZEND_ADD_LONG_NO_OVERFLOW, CONST|TMPVARCV, CONST|TMPVARCV, SPEC(NO_CONST_CONST,COMMUTATIVE) )</code> </pre> <br>        ,      ,       . ,      ,            . , ,    ,   ,       <b>int + int -&gt; int</b> .  ,  SPEC   ( specializer),              ,  ,       CONST + TMPVARCV,     TMPVARCV + CONST. <br><br><h2>       </h2><br>         / ,      ,       . <br><br>     -  ,        SL ( ): <br><pre> <code class="cpp hljs">ZEND_VM_HANDLER(<span class="hljs-number"><span class="hljs-number">6</span></span>, ZEND_SL, CONST|TMPVAR|CV, CONST|TMPVAR|CV) { USE_OPLINE zend_free_op free_op1, free_op2; zval *op1, *op2; op1 = GET_OP1_ZVAL_PTR_UNDEF(BP_VAR_R); op2 = GET_OP2_ZVAL_PTR_UNDEF(BP_VAR_R); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXPECTED(Z_TYPE_INFO_P(op1) == IS_LONG) &amp;&amp; EXPECTED(Z_TYPE_INFO_P(op2) == IS_LONG) &amp;&amp; EXPECTED((zend_ulong)Z_LVAL_P(op2) &lt; SIZEOF_ZEND_LONG * <span class="hljs-number"><span class="hljs-number">8</span></span>)) { ZVAL_LONG(EX_VAR(opline-&gt;result.var), Z_LVAL_P(op1) &lt;&lt; Z_LVAL_P(op2)); ZEND_VM_NEXT_OPCODE(); } SAVE_OPLINE(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OP1_TYPE == IS_CV &amp;&amp; UNEXPECTED(Z_TYPE_INFO_P(op1) == IS_UNDEF)) { op1 = GET_OP1_UNDEF_CV(op1, BP_VAR_R); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OP2_TYPE == IS_CV &amp;&amp; UNEXPECTED(Z_TYPE_INFO_P(op2) == IS_UNDEF)) { op2 = GET_OP2_UNDEF_CV(op2, BP_VAR_R); } shift_left_function(EX_VAR(opline-&gt;result.var), op1, op2); FREE_OP1(); FREE_OP2(); ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION(); }</code> </pre> <br>        <b>GET_OPn_ZVAL_PTR_UNDEF</b>   BP_VAR_R.   <b>UNDEF</b> ,     CV      ,       UNDEF  .      ,  ,      ,      .        ,      . ,      ,    UNDEF,   GET_OPn_ZVAL_PTR_UNDEF  . <br><br>      ,     ,    SAVE_OPLINE ().     ¬´   ¬ª.    ,    . GET_OPn_UNDEF_CV             NULL. <br><br>     shift_left_function,      <b>EX_VAR(opline-&gt;result.var)</b> . ,    ( ),          ( ,  opline   ,   ). <br><br>  ,          ,   ,  ,      opline   .     ,   . <br><br><h2>    </h2><br>     ,       .        C,        .  ,         : <br><pre>OPn_TYPE<font></font>
OP_DATA_TYPE<font></font>
<font></font>
GET_OPn_ZVAL_PTR(BP_VAR_*)<font></font>
GET_OPn_ZVAL_PTR_DEREF(BP_VAR_*)<font></font>
GET_OPn_ZVAL_PTR_UNDEF(BP_VAR_*)<font></font>
GET_OPn_ZVAL_PTR_PTR(BP_VAR_*)<font></font>
GET_OPn_ZVAL_PTR_PTR_UNDEF(BP_VAR_*)<font></font>
GET_OPn_OBJ_ZVAL_PTR(BP_VAR_*)<font></font>
GET_OPn_OBJ_ZVAL_PTR_UNDEF(BP_VAR_*)<font></font>
GET_OPn_OBJ_ZVAL_PTR_DEREF(BP_VAR_*)<font></font>
GET_OPn_OBJ_ZVAL_PTR_PTR(BP_VAR_*)<font></font>
GET_OPn_OBJ_ZVAL_PTR_PTR_UNDEF(BP_VAR_*)<font></font>
GET_OP_DATA_ZVAL_PTR()<font></font>
GET_OP_DATA_ZVAL_PTR_DEREF()<font></font>
<font></font>
FREE_OPn()<font></font>
FREE_OPn_IF_VAR()<font></font>
FREE_OPn_VAR_PTR()<font></font>
FREE_UNFETCHED_OPn()<font></font>
FREE_OP_DATA()<font></font>
FREE_UNFETCHED_OP_DATA()<font></font>
</pre><br><br>  ,    .  <b>BP_VAR_*</b>         ,    FETCH_* (  FUNC_ARG). <br><br> <b>GET_OPn_ZVAL_PTR()</b> ‚Äî     .      CV     . <b>GET_OPn_ZVAL_PTR_UNDEF()</b> ,    ,  ,     CV. <b>GET_OPn_ZVAL_PTR_DEREF()</b>  DEREF  zval.     GET,       CV  VAR,    CONST  TMP.      TMP  VAR,      TMP|VAR- (  <b>TMPVAR</b> ). <br><br>  <b>GET_OPn_OBJ_ZVAL_PTR*()</b>     UNUSED-.   ,   <b>$this</b>   UNUSED-,   <b>GET_OPn_OBJ_ZVAL_PTR*()</b>    <b>EX(This)</b>  UNUSED. <br><br> ,    <b>PTR_PTR</b> .      PHP 5,     INDIRECT- zval.             CV  VAR (   NULL).      PTR ,   ¬´-INDIRECT-¬ª  VAR. <br><br>  <b>FREE_OP*()</b>      .       <b>zend_free_op</b> <b>free_opN</b> ,    GET     .   <b>FREE_OPn()</b>  TMP  VAR,    CV  CONST. <b>FREE_OPn_IF_VAR()</b>   ,   :  ,     VAR. <br><br>  <b>FREE_OP*_VAR_PTR()</b>      <b>PTR_PTR</b> .      VAR      INDIRECT. <br><br>  <b>FREE_UNFETCHED_OP*()</b>   ,       ,       GET.   ,      . <br><br>    ,      .    ,   ,      : <br><pre>ZEND_VM_CONTINUE()<font></font>
ZEND_VM_ENTER()<font></font>
ZEND_VM_LEAVE()<font></font>
ZEND_VM_RETURN()<font></font>
</pre><br> CONTINUE     ,     ENTER  LEAVE   /    .      ,      (,    ,   ,  ).   ,        ,   . RETURN        VM. <br><br> ZEND_VM_CONTINUE () ,  opline   . ,   ,   : <br><table><tbody><tr><th></th><th> Continue? </th><th> Check exception? </th><th> Check interrupt? </th></tr><tr><td> ZEND_VM_NEXT_OPCODE() </td><td>  yes <br></td><td>  no <br></td><td>  no <br></td></tr><tr><td> ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION() </td><td>  yes <br></td><td>  yes <br></td><td>  no <br></td></tr><tr><td> ZEND_VM_SET_NEXT_OPCODE(op) </td><td>  no <br></td><td>  no <br></td><td>  no <br></td></tr><tr><td> ZEND_VM_SET_OPCODE(op) </td><td>  no <br></td><td>  no <br></td><td>  yes <br></td></tr><tr><td> ZEND_VM_SET_RELATIVE_OPCODE(op, offset) </td><td>  no <br></td><td>  no <br></td><td>  yes <br></td></tr><tr><td> ZEND_VM_JMP(op) </td><td>  yes <br></td><td>  yes <br></td><td>  yes <br></td></tr></tbody></table><br><br>   ,     ZEND_VM_CONTINUE(),         VM. <br><br>      <b>SAVE_OPLINE()</b> , <b>LOAD_OPLINE()</b>  <b>HANDLE_EXCEPTION()</b> .        , SAVE_OPLINE()          .      opline,  VM (    ),  execute data. LOAD_OPLINE() ‚Äî   ,       ,       ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION()  ZEND_VM_JMP(). HANDLE_EXCEPTION()        ,    ,    .    LOAD_OPLINE  CONTINUE. <br><br> ,    (  ...),         . </div><p>Source: <a href="https://habr.com/ru/post/327068/">https://habr.com/ru/post/327068/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327058/index.html">Difficult lessons: five years with Node.js</a></li>
<li><a href="../327060/index.html">Clarive 6.8 has been released.</a></li>
<li><a href="../327062/index.html">Typography: font selection process</a></li>
<li><a href="../327064/index.html">Native American software designer tricks. Release 1</a></li>
<li><a href="../327066/index.html">Results of the second round of the Russian Code Cup 2017</a></li>
<li><a href="../327070/index.html">‚ÄúWhy don't you just rewrite it in X?‚Äù</a></li>
<li><a href="../327072/index.html">Predict the popularity of articles on TJ</a></li>
<li><a href="../327074/index.html">Experience migrating applications from Unity3D to iOS sdk and SceneKit</a></li>
<li><a href="../327076/index.html">We increase the potential of the network storage abandoned by the manufacturer</a></li>
<li><a href="../327078/index.html">Investigation of the position of the eyes in more than 1,000,000 persons: the rule of the golden section or the rule of thirds?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>