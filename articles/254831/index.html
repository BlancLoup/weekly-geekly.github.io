<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Code generation at runtime or ‚ÄúWriting your JIT compiler‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern compilers are very good at optimizing code. They remove the conditional jumps that are never executed, calculate constant expressions, get rid ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Code generation at runtime or ‚ÄúWriting your JIT compiler‚Äù</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b81/f0c/560/b81f0c5608924b22bd38c2bed670481d.png" align="left"><br>  Modern compilers are very good at optimizing code.  They remove the conditional jumps that are never executed, calculate constant expressions, get rid of senseless arithmetic operations (multiplication by 1, addition with 0).  They operate on data known at the time of compilation. <br>  At the time of execution of information about the processed data is much more.  Based on it, you can perform additional optimizations and speed up the program. <br>  The algorithm optimized for a particular case always works faster than the universal one (at least, not more slowly). <br>  What if for each set of input data to generate the optimal algorithm for processing this data? <br>  Obviously, some of the execution time will be spent on optimization, but if the optimized code is executed frequently, the costs will be repaid with interest. <br>  How technically to do this?  Quite simply, the program includes a mini-compiler that generates the necessary code.  The idea is not new, the technology is called ‚Äúcompile time‚Äù or JIT compilation.  The key role of JIT compilation plays in virtual machines and interpreters of programming languages.  Frequently used parts of the code (or bytecode) are converted to machine instructions, which can greatly improve performance. <br>  Java, Python, C #, JavaScript, Flash ActionScript - an incomplete (completely incomplete) list of languages ‚Äã‚Äãin which it is used.  I propose to solve a specific problem using this technology and see what happens. <br><a name="habracut"></a><br><h2>  Task </h2><br>  The task is to take the implementation of the interpreter of mathematical expressions.  At the entrance we have a string like <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/86e/562/972/86e562972a0e4e47a9435a3bacb702b4.png"></div><br><br>  and the number is the value of x.  The output should get a number - the value of the expression at this value of x.  For simplicity, we will process only four operators - '+', '-', '*', '/'. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At this stage, it is not yet clear how to compile this expression at all, because the string is not the most convenient way to work.  For analysis and computation, a parse tree is better suited, in our case, a binary tree. <br>  For the original expression, it will look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/620/44a/fad/62044afad9684c3890f5125dd858205f.png"></div><br><br>  Each node in the tree is an operator, its children are operands.  In the leaves of the tree are constants and variables. <br><br>  The simplest algorithm for constructing such a tree is recursive descent - at each stage we find the operator with the lowest priority, divide the expression into two parts - before this operator and after, and recursively call the construction operation for these parts.  Step-by-step illustration of the algorithm: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c07/930/b90/c07930b908a14dfd9b71858dfd3810af.png"></div><br><br>  I will not give here the implementation of the algorithm for a simple reason - it is quite large, and the article is not about that. <br>  A tree consists of nodes, each of which will be represented by a TreeNode structure <br><br><blockquote>  <font color="#993333">typedef</font> <font color="#993333">struct</font> TreeNode TreeNode <font color="#339933">;</font> <br>  <font color="#993333">struct</font> TreeNode <br>  <font color="#009900">{</font> <br>  TreeNodeType type <font color="#339933">;</font>  <font color="#666666">// node type</font> <br>  TreeNode <font color="#339933">*</font> left <font color="#339933">;</font>  <font color="#666666">// link to the left child</font> <br>  TreeNode <font color="#339933">*</font> right <font color="#339933">;</font>  <font color="#666666">// link for the right child</font> <br>  <font color="#993333">float</font> value <font color="#339933">;</font>  <font color="#666666">// value (for constant node)</font> <br>  <font color="#009900">}</font> <font color="#339933">;</font> </blockquote><br><br>  Here are all possible node types: <br><blockquote>  <font color="#993333">typedef</font> <font color="#000000">enum</font> <br>  <font color="#009900">{</font> <br>  OperatorPlus <font color="#339933">,</font> <font color="#666666">// Operator Plus</font> <br>  OperatorMinus <font color="#339933">,</font> <font color="#666666">// Operator minus</font> <br>  OperatorMul <font color="#339933">,</font> <font color="#666666">// Operator multiply</font> <br>  OperatorDiv <font color="#339933">,</font> <font color="#666666">// Operator split</font> <br>  OperandConst <font color="#339933">,</font> <font color="#666666">// Operand is a constant</font> <br>  OperandVar <font color="#339933">,</font> <font color="#666666">// Operand is a variable</font> <br>  OperandNegVar <font color="#339933">,</font> <font color="#666666">// Operand is a variable taken with a minus (for processing a unary minus)</font> <br>  <font color="#009900">}</font> TreeNodeType <font color="#339933">;</font> </blockquote><br>  The value of the expression for a given x is calculated very simply - with the help of a depth traversal. <br><div class="spoiler">  <b class="spoiler_title">This is also implemented using recursion.</b> <div class="spoiler_text"><blockquote>  <font color="#993333">float</font> calcTreeFromRoot <font color="#009900">(</font> TreeNode <font color="#339933">*</font> root <font color="#339933">,</font> <font color="#993333">float</font> x <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br><br>  <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#339933">==</font> OperandVar <font color="#009900">)</font> <br>  <font color="#b1b100">return</font> x <font color="#339933">;</font> <br>  <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#339933">==</font> OperandNegVar <font color="#009900">)</font> <br>  <font color="#b1b100">return</font> <font color="#339933">-</font> x <font color="#339933">;</font> <br>  <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#339933">==</font> OperandConst <font color="#009900">)</font> <br>  <font color="#b1b100">return</font> root <font color="#339933">-&gt;</font> value <font color="#339933">;</font> <br><br>  <font color="#b1b100">switch</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  <font color="#b1b100">case</font> OperatorPlus <font color="#339933">:</font> <br>  <font color="#b1b100">return</font> calcTreeFromRoot <font color="#009900">(</font> root <font color="#339933">-&gt;</font> left <font color="#339933">,</font> x <font color="#009900">)</font> <font color="#339933">+</font> calcTreeFromRoot <font color="#009900">(</font> root <font color="#339933">-&gt;</font> right <font color="#339933">,</font> x <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#b1b100">case</font> OperatorMinus <font color="#339933">:</font> <br>  <font color="#b1b100">return</font> calcTreeFromRoot <font color="#009900">(</font> root <font color="#339933">-&gt;</font> left <font color="#339933">,</font> x <font color="#009900">)</font> <font color="#339933">-</font> calcTreeFromRoot <font color="#009900">(</font> root <font color="#339933">-&gt;</font> right <font color="#339933">,</font> x <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#b1b100">case</font> OperatorMul <font color="#339933">:</font> <br>  <font color="#b1b100">return</font> calcTreeFromRoot <font color="#009900">(</font> root <font color="#339933">-&gt;</font> left <font color="#339933">,</font> x <font color="#009900">)</font> <font color="#339933">*</font> calcTreeFromRoot <font color="#009900">(</font> root <font color="#339933">-&gt;</font> right <font color="#339933">,</font> x <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#b1b100">case</font> OperatorDiv <font color="#339933">:</font> <br>  <font color="#b1b100">return</font> calcTreeFromRoot <font color="#009900">(</font> root <font color="#339933">-&gt;</font> left <font color="#339933">,</font> x <font color="#009900">)</font> <font color="#339933">/</font> calcTreeFromRoot <font color="#009900">(</font> root <font color="#339933">-&gt;</font> right <font color="#339933">,</font> x <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#009900">}</font> <br>  <font color="#009900">}</font> </blockquote><br></div></div><br>  What is the current situation? <br><ul><li>  Tree is generated for the expression </li><li>  If it is necessary to calculate the value of the expression, the recursive function calcTreeFromRoot is called. </li></ul><br><br>  What would the code look like if we knew the expression at the assembly stage? <br><blockquote>  <font color="#993333">float</font> calcExpression <font color="#009900">(</font> <font color="#993333">float</font> x <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  <font color="#b1b100">return</font> x <font color="#339933">*</font> x <font color="#339933">+</font> <font color="#0000dd">5</font> <font color="#339933">*</font> x <font color="#339933">-</font> <font color="#0000dd">2</font> <font color="#339933">;</font> <br>  <font color="#009900">}</font> </blockquote><br><br>  Calculating the value of an expression in this case comes down to calling one very simple function ‚Äî many times faster than recursively traversing the tree. <br><br><h2>  Compile time! </h2><br>  <em>I want to note that I will generate code for the x86 platform focusing on architecture processors similar to IA32.</em>  <em>In addition, I will take a float size of 4 bytes, an int size of 4 bytes.</em> <br><br><h3>  Theory </h3><br>  So, our task is to get the usual C function, which can be called if necessary. <br>  To begin with, let's define its prototype: <br><blockquote>  <font color="#993333">typedef</font> <font color="#993333">float</font> _cdecl <font color="#009900">(</font> <font color="#339933">*</font> Func <font color="#009900">)</font> <font color="#009900">(</font> <font color="#993333">float</font> <font color="#009900">)</font> <font color="#339933">;</font> </blockquote><br><br>  Now the Func data type is a pointer to a function that returns a value of type float and takes one argument, also of type float. <br>  _cdecl indicates that the C-declaration calling convention is used. <br>  This is the standard calling convention for the C language: <br>  - arguments are passed through the stack from right to left (when called on the top of the stack, the first argument should appear) <br>  - integer values ‚Äã‚Äãare returned via the EAX register <br>  - floating point values ‚Äã‚Äãare returned through the st0 register <br>  - for the safety of the registers eax, edx, ecx is responsible for the <em>calling</em> function <br>  - the rest of the registers must be restored <em>by the called</em> function <br><br>  The function call looks like this: <br><blockquote>  <font color="#00007f">push</font> <font color="#46aa03">ebp</font> <font color="#666666">// Save the stack frame pointer</font> <br>  <font color="#00007f">push</font> arg3 <font color="#666666">// Put the arguments on the stack in order from right to left (the first argument is at the end)</font> <br>  <font color="#00007f">push</font> arg2 <br>  <font color="#00007f">push</font> arg1 <br>  <font color="#00007f">call</font> func <font color="#666666">// self call</font> <br>  <font color="#00007f">add</font> <font color="#46aa03">esp</font> <font color="#339933">,</font> <font color="#ff0000">0xC</font> <font color="#666666">// Restore the pointer to the stack (3 arguments of 4 bytes just take 0xC bytes)</font> <br>  <font color="#00007f">pop</font> <font color="#46aa03">ebp</font> <font color="#666666">// Restore the stack frame pointer</font> </blockquote><br>  Stack status at the time of call: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/1dc/e39/a04/1dce39a045f34df0bcee08ed6b4b8529.png"></div><br><br>  How do we generate the code that evaluates the expression?  Time to remember that there is such a thing as a stack calculator.  How does he work?  At the entrance serves numbers and operators.  The algorithm is elementary: <br>  - We met a constant or variable - put it on the stack <br>  - The operator was met - 2 operands were removed from the stack, the operation was performed, the result was put on the stack <br><br>  But it is necessary to feed the stack calculator in a certain way - it works with the expressions presented in the reverse Polish notation.  Its peculiarity lies in the fact that the operands are written first, then the operator.  Thus, our original expression will appear as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/550/df9/6a6/550df96a644f479d9d3f86091994cf4c.png"></div><br><br>  The program for the stack calculator corresponding to the expression: <br><blockquote>  <font color="#00007f">push</font> x <br>  <font color="#00007f">push</font> x <br>  <font color="#00007f">mul</font> <br>  <font color="#00007f">push</font> <font color="#ff0000">5</font> <br>  <font color="#00007f">push</font> x <br>  <font color="#00007f">mul</font> <br>  <font color="#00007f">add</font> <br>  <font color="#00007f">push</font> <font color="#ff0000">2</font> <br>  <font color="#00007f">sub</font> </blockquote><br>  Much like a program in assembler, is not it? <br><br>  It turns out that it is enough to translate the expression into reverse Polish notation and create code following the elementary rules. <br>  Translation is very simple to perform - we already have a parse tree built, we just need to perform a depth crawl, and when we exit the vertex, generate the corresponding action - we get a sequence of commands in the order we need. <br><br><div class="spoiler">  <b class="spoiler_title">Pseudocode of this action:</b> <div class="spoiler_text"><blockquote>  <font color="#993333">static</font> <font color="#993333">void</font> generateCodeR <font color="#009900">(</font> TreeNode <font color="#339933">*</font> root <font color="#339933">,</font> ByteArray <font color="#339933">*</font> code <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> left <font color="#339933">&amp; amp</font> <font color="#339933">; &amp; amp</font> <font color="#339933">;</font> root <font color="#339933">-&gt;</font> right <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  generateCodeR <font color="#009900">(</font> root <font color="#339933">-&gt;</font> right <font color="#339933">,</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Must be generated first</font> <br>  generateCodeR <font color="#009900">(</font> root <font color="#339933">-&gt;</font> left <font color="#339933">,</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// code to calculate child elements</font> <br>  <font color="#009900">}</font> <br>  <font color="#666666">// Generate code for parent element</font> <br>  <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#339933">==</font> OperandVar <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  code <font color="#339933">+ =</font> <font color="#ff0000">"push x"</font> <font color="#339933">;</font>  <font color="#666666">// Put the value of the argument (variable) on the stack</font> <br>  <font color="#009900">}</font> <br>  <font color="#b1b100">else</font> <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#339933">==</font> OperandNegVar <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  code <font color="#339933">+ =</font> <font color="#ff0000">"push -x"</font> <font color="#339933">;</font>  <font color="#666666">// Put the value of the argument on the stack with a change of sign</font> <br>  <font color="#009900">}</font> <br>  <font color="#b1b100">else</font> <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#339933">==</font> OperandConst <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  code <font color="#339933">+ =</font> <font color="#ff0000">"push"</font> <font color="#339933">+</font> root <font color="#339933">-&gt;</font> value <font color="#339933">;</font>  <font color="#666666">// Put a constant in the stack</font> <br>  <font color="#009900">}</font> <br>  <font color="#b1b100">else</font> <br>  <font color="#009900">{</font> <br>  code <font color="#339933">+ =</font> <font color="#ff0000">"pop"</font> <font color="#339933">;</font>  <font color="#666666">// Remove from the stack</font> <br>  code <font color="#339933">+ =</font> <font color="#ff0000">"pop"</font> <font color="#339933">;</font>  <font color="#666666">// two values</font> <br>  <font color="#b1b100">switch</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  <font color="#b1b100">case</font> OperatorPlus <font color="#339933">:</font> <br>  code <font color="#339933">+ =</font> <font color="#ff0000">"add"</font> <font color="#339933">;</font>  <font color="#666666">// perform addition</font> <br>  <font color="#000000">break</font> <font color="#339933">;</font> <br><br>  <font color="#b1b100">case</font> OperatorMinus <font color="#339933">:</font> <br>  code <font color="#339933">+ =</font> <font color="#ff0000">"sub"</font> <font color="#339933">;</font>  <font color="#666666">// Perform Subtraction</font> <br>  <font color="#000000">break</font> <font color="#339933">;</font> <br><br>  <font color="#b1b100">case</font> OperatorMul <font color="#339933">:</font> <br>  code <font color="#339933">+ =</font> <font color="#ff0000">"mul"</font> <font color="#339933">;</font>  <font color="#666666">// Perform Multiplication</font> <br>  <font color="#000000">break</font> <font color="#339933">;</font> <br><br>  <font color="#b1b100">case</font> OperatorDiv <font color="#339933">:</font> <br>  code <font color="#339933">+ =</font> <font color="#ff0000">"div"</font> <font color="#339933">;</font>  <font color="#666666">// Perform Division</font> <br>  <font color="#000000">break</font> <font color="#339933">;</font> <br>  <font color="#009900">}</font> <br>  code <font color="#339933">+ =</font> <font color="#ff0000">"push result"</font> <font color="#666666">// Save the result of a mathematical operation on the stack</font> <br>  <font color="#009900">}</font> <br>  <font color="#009900">}</font> </blockquote><br></div></div><br><h3>  Implementation </h3><br>  First, let's define the stack: everything is simple with it - the esp register contains a pointer to the vertex.  To put something there, just run the command <br><blockquote>  <font color="#00007f">push</font> <font color="#009900">{</font> value <font color="#009900">}</font> </blockquote><br>  or subtract the number 4 from ESP and write the desired value at the received address <br><blockquote>  <font color="#00007f">sub</font> <font color="#46aa03">esp</font> <font color="#339933">,</font> <font color="#ff0000">4</font> <br>  <font color="#00007f">mov</font> <font color="#009900">[</font> <font color="#46aa03">esp</font> <font color="#009900">]</font> <font color="#339933">,</font> <font color="#009900">{</font> value <font color="#009900">}</font> </blockquote><br>  Removing from the stack is performed by the pop command or by adding the number 4 to esp. <br>  I used to mention a calling convention.  Thanks to him, we can know exactly where the only function argument will be.  At the esp address (at the top), the return address will be located, and at the esp address, 4 will be the argument value.  Since the call to it will occur relatively often, you can put it in the eax register: <br><blockquote>  <font color="#00007f">mov</font> <font color="#46aa03">eax</font> <font color="#339933">,</font> <font color="#009900">[</font> <font color="#46aa03">esp</font> <font color="#339933">-</font> <font color="#ff0000">4</font> <font color="#009900">]</font> <font color="#666666">;</font> </blockquote><br>  Now, a little about working with floating point numbers.  We will use the x87 FPU instruction set. <br>  An FPU has 8 registers that form a stack.  Each of them holds 80 bits.  Appeal to the top of this stack is through the register st0.  Accordingly, the register st1 addresses the next highest value in this stack, st2 is the next and so on up to st7. <br>  FPU stack: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/07e/58c/702/07e58c702e904e948e95c3dcc7edaab6.png"></div><br>  To load the value on top, use the fld command.  The operand of this command can only be the value stored in memory. <br><blockquote>  <font color="#0000ff">fld</font> <font color="#009900">[</font> <font color="#46aa03">esp</font> <font color="#009900">]</font> <font color="#666666">// Load the value stored at the address contained in esp into st0</font> </blockquote><br>  Commands for performing arithmetic operations are very simple: fadd, fsub, fmul, fdiv.  They can have many different combinations of arguments, but we will use them only this way: <br><blockquote>  <font color="#0000ff">fadd</font> <font color="#0000ff">dword</font> ptr <font color="#009900">[</font> <font color="#46aa03">esp</font> <font color="#009900">]</font> <br>  <font color="#0000ff">fsub</font> <font color="#0000ff">dword</font> ptr <font color="#009900">[</font> <font color="#46aa03">esp</font> <font color="#009900">]</font> <br>  <font color="#0000ff">fmul</font> <font color="#0000ff">dword</font> ptr <font color="#009900">[</font> <font color="#46aa03">esp</font> <font color="#009900">]</font> <br>  <font color="#0000ff">fdiv</font> <font color="#0000ff">dword</font> ptr <font color="#009900">[</font> <font color="#46aa03">esp</font> <font color="#009900">]</font> </blockquote><br><br>  In all these cases, the value from [esp] is loaded, the necessary operation is performed, the result is stored in st0. <br>  Removing the value from the stack is also simple: <br><blockquote>  <font color="#0000ff">fstp</font> <font color="#009900">[</font> <font color="#46aa03">esp</font> <font color="#009900">]</font> <font color="#666666">// Delete the value from the top of the FPU stack and save it to the memory location at the address lying in esp</font> </blockquote><br>  Recall that in the expression there can be a variable x with a unary minus.  To process it, you need to change the sign.  For this, the FCHS command comes in handy - it inverts the bit of the register character st0 <br><br>  For each of these commands, we define the function that generates the necessary opcodes: <br><blockquote>  <font color="#993333">void</font> genPUSH_imm32 <font color="#009900">(</font> ByteArray <font color="#339933">*</font> code <font color="#339933">,</font> <font color="#993333">int32_t</font> <font color="#339933">*</font> pValue <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#993333">void</font> genADD_ESP_4 <font color="#009900">(</font> ByteArray <font color="#339933">*</font> code <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#993333">void</font> genMOV_EAX_PTR_ESP_4 <font color="#009900">(</font> ByteArray <font color="#339933">*</font> code <font color="#009900">)</font> <font color="#339933">;</font> <br><br>  <font color="#993333">void</font> genFSTP <font color="#009900">(</font> ByteArray <font color="#339933">*</font> code <font color="#339933">,</font> <font color="#993333">void</font> <font color="#339933">*</font> dstAddress <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#993333">void</font> genFLD_DWORD_PTR_ESP <font color="#009900">(</font> ByteArray <font color="#339933">*</font> code <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#993333">void</font> genFADD_DWORD_PTR_ESP <font color="#009900">(</font> ByteArray <font color="#339933">*</font> code <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#993333">void</font> genFSUB_DWORD_PTR_ESP <font color="#009900">(</font> ByteArray <font color="#339933">*</font> code <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#993333">void</font> genFMUL_DWORD_PTR_ESP <font color="#009900">(</font> ByteArray <font color="#339933">*</font> code <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#993333">void</font> genFCHS <font color="#009900">(</font> ByteArray <font color="#339933">*</font> code <font color="#009900">)</font> <font color="#339933">;</font> </blockquote><br>  In order for the code-calculator to work normally and return the value, add the corresponding instructions before it and after it.  The whole generateCode wrapper function collects this whole thing: <br><blockquote>  <font color="#993333">void</font> generateCode <font color="#009900">(</font> Tree <font color="#339933">*</font> tree <font color="#339933">,</font> ByteArray <font color="#339933">*</font> resultCode <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  ByteArray <font color="#339933">*</font> code <font color="#339933">=</font> resultCode <font color="#339933">;</font> <br><br>  genMOV_EAX_ESP_4 <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Put the value of the argument in eax</font> <br><br>  generateCodeR <font color="#009900">(</font> tree <font color="#339933">-&gt;</font> root <font color="#339933">,</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Generate a code calculator</font> <br><br>  genFLD_DWORD_PTR_ESP <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font> <br>  genADD_ESP_4 <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Remove the extra double word from the stack</font> <br>  genRET <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Exit the function</font> <br>  <font color="#009900">}</font> </blockquote><br><div class="spoiler">  <b class="spoiler_title">The final form of the function of generating code that calculates the value of the expression:</b> <div class="spoiler_text"><blockquote>  <font color="#993333">void</font> generateCodeR <font color="#009900">(</font> TreeNode <font color="#339933">*</font> root <font color="#339933">,</font> ByteArray <font color="#339933">*</font> resultCode <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  ByteArray <font color="#339933">*</font> code <font color="#339933">=</font> resultCode <font color="#339933">;</font> <br>  <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> left <font color="#339933">&amp; amp</font> <font color="#339933">; &amp; amp</font> <font color="#339933">;</font> root <font color="#339933">-&gt;</font> right <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  generateCodeR <font color="#009900">(</font> root <font color="#339933">-&gt;</font> right <font color="#339933">,</font> code <font color="#009900">)</font> <font color="#339933">;</font> <br>  generateCodeR <font color="#009900">(</font> root <font color="#339933">-&gt;</font> left <font color="#339933">,</font> code <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#009900">}</font> <br><br>  <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#339933">==</font> OperandVar <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  genPUSH_EAX <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// In eax, the function argument is</font> <br>  <font color="#009900">}</font> <br>  <font color="#b1b100">else</font> <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#339933">==</font> OperandNegVar <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  genPUSH_EAX <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// load the stack</font> <br>  genFLD_DWORD_PTR_ESP <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Change</font> <br>  genFCHS <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">//sign</font> <br>  genFSTP_DWORD_PTR_ESP <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// return to the stack</font> <br>  <font color="#009900">}</font> <br>  <font color="#b1b100">else</font> <font color="#b1b100">if</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#339933">==</font> OperandConst <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  genPUSH_imm32 <font color="#009900">(</font> code <font color="#339933">,</font> <font color="#009900">(</font> <font color="#993333">int32_t</font> <font color="#339933">*</font> <font color="#009900">)</font> <font color="#339933">&amp; amp</font> <font color="#339933">;</font> root <font color="#339933">-&gt;</font> value <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#009900">}</font> <br>  <font color="#b1b100">else</font> <br>  <font color="#009900">{</font> <br>  genFLD_DWORD_PTR_ESP <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Load the left operand in the FPU ..</font> <br>  genADD_ESP_4 <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// ... and remove it from the stack</font> <br>  <font color="#b1b100">switch</font> <font color="#009900">(</font> root <font color="#339933">-&gt;</font> type <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  <font color="#b1b100">case</font> OperatorPlus <font color="#339933">:</font> <br>  genFADD_DWORD_PTR_ESP <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Perform addition (the result is saved in st0)</font> <br>  <font color="#000000">break</font> <font color="#339933">;</font> <br><br>  <font color="#b1b100">case</font> OperatorMinus <font color="#339933">:</font> <br>  genFSUB_DWORD_PTR_ESP <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Perform subtraction (the result is saved in st0)</font> <br>  <font color="#000000">break</font> <font color="#339933">;</font> <br><br>  <font color="#b1b100">case</font> OperatorMul <font color="#339933">:</font> <br>  genFMUL_DWORD_PTR_ESP <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Perform multiplication (the result is saved in st0)</font> <br>  <font color="#000000">break</font> <font color="#339933">;</font> <br><br>  <font color="#b1b100">case</font> OperatorDiv <font color="#339933">:</font> <br>  genFDIV_DWORD_PTR_ESP <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Perform division (the result is saved in st0)</font> <br>  <font color="#000000">break</font> <font color="#339933">;</font> <br>  <font color="#009900">}</font> <br><br>  genFSTP_DWORD_PTR_ESP <font color="#009900">(</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Save the result to the stack (st0 - &amp; gt; [esp])</font> <br>  <font color="#009900">}</font> <br>  <font color="#009900">}</font> </blockquote><br></div></div><br>  By the way, about the buffer for storing code.  For these purposes, I created the ByteArray container type: <br><blockquote>  <font color="#993333">typedef</font> <font color="#993333">struct</font> <br>  <font color="#009900">{</font> <br>  <font color="#993333">int</font> size <font color="#339933">;</font>  <font color="#666666">// Size of allocated memory</font> <br>  <font color="#993333">int</font> dataSize <font color="#339933">;</font>  <font color="#666666">// Actual size of stored data</font> <br>  <font color="#993333">char</font> <font color="#339933">*</font> data <font color="#339933">;</font>  <font color="#666666">// Pointer to the data</font> <br>  <font color="#009900">}</font> ByteArray <font color="#339933">;</font> <br><br>  ByteArray <font color="#339933">*</font> byteArrayCreate <font color="#009900">(</font> <font color="#993333">int</font> initialSize <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#993333">void</font> byteArrayFree <font color="#009900">(</font> ByteArray <font color="#339933">*</font> array <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#993333">void</font> byteArrayAppendData <font color="#009900">(</font> ByteArray <font color="#339933">*</font> array <font color="#339933">,</font> <font color="#993333">const</font> <font color="#993333">char</font> <font color="#339933">*</font> data <font color="#339933">,</font> <font color="#993333">int</font> dataSize <font color="#009900">)</font> <font color="#339933">;</font> </blockquote><br>  It allows you to add data to the end and not to think about the allocation of memory - a kind of dynamic array. <br><br>  If you generate code using generateCode () and transfer control to it, the program is likely to crash.  The reason is simple - the lack of permission to perform.  I write under Windows, so the WinAPI function VirtualProtect will help me here, allowing me to set permissions for a memory region (or rather, for memory pages). <br>  In MSD, it is described as: <br><blockquote>  BOOL WINAPI VirtualProtect <font color="#009900">(</font> <br>  _In_ LPVOID lpAddress <font color="#339933">,</font> <font color="#666666">// Address of the beginning of the region in memory</font> <br>  _In_ SIZE_T dwSize <font color="#339933">,</font> <font color="#666666">// Size of region in memory</font> <br>  _In_ DWORD flNewProtect <font color="#339933">,</font> <font color="#666666">// New access parameters for pages in the region</font> <br>  _Out_ PDWORD lpflOldProtect <font color="#666666">// Pointer to a variable, where to save the old access parameters</font> <br>  <font color="#009900">)</font> <font color="#339933">;</font> </blockquote><br>  It is used in the main compiler function: <br><blockquote>  CompiledFunc compileTree <font color="#009900">(</font> Tree <font color="#339933">*</font> tree <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  CompiledFunc result <font color="#339933">;</font> <br>  DWORD oldP <font color="#339933">;</font> <br>  ByteArray <font color="#339933">*</font> code <font color="#339933">;</font> <br><br>  code <font color="#339933">=</font> byteArrayCreate <font color="#009900">(</font> <font color="#0000dd">2</font> <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Initial container size - 2 bytes</font> <br><br>  generateCode <font color="#009900">(</font> tree <font color="#339933">,</font> code <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// Generate code</font> <br><br>  VirtualProtect <font color="#009900">(</font> code <font color="#339933">-&gt;</font> data <font color="#339933">,</font> code <font color="#339933">-&gt;</font> dataSize <font color="#339933">,</font> PAGE_EXECUTE_READWRITE <font color="#339933">,</font> <font color="#339933">&amp;</font> oldP <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// We give the right to perform</font> <br><br>  result.  <font color="#202020">code</font> <font color="#339933">=</font> code <font color="#339933">;</font> <br>  result.  <font color="#202020">run</font> <font color="#339933">=</font> <font color="#009900">(</font> Func <font color="#009900">)</font> result.  <font color="#202020">code</font> <font color="#339933">-&gt;</font> data <font color="#339933">;</font> <br>  <font color="#b1b100">return</font> result <font color="#339933">;</font> <br>  <font color="#009900">}</font> </blockquote><br>  CompiledFunc is a structure for conveniently storing code and a function pointer: <br><blockquote>  <font color="#993333">typedef</font> <font color="#993333">struct</font> <br>  <font color="#009900">{</font> <br>  ByteArray <font color="#339933">*</font> code <font color="#339933">;</font>  <font color="#666666">// Container with code</font> <br>  Func run <font color="#339933">;</font>  <font color="#666666">// function pointer</font> <br>  <font color="#009900">}</font> CompiledFunc <font color="#339933">;</font> </blockquote><br>  The compiler is written and it is very easy to use: <br><blockquote>  Tree <font color="#339933">*</font> tree <font color="#339933">;</font> <br>  CompiledFunc f <font color="#339933">;</font> <br>  <font color="#993333">float</font> result <font color="#339933">;</font> <br><br>  tree <font color="#339933">=</font> buildTreeForExpression <font color="#009900">(</font> <font color="#ff0000">"x + 5"</font> <font color="#009900">)</font> <font color="#339933">;</font> <br>  f <font color="#339933">=</font> compileTree <font color="#009900">(</font> tree <font color="#009900">)</font> <font color="#339933">;</font> <br>  result <font color="#339933">=</font> f.  <font color="#202020">run</font> <font color="#009900">(</font> <font color="#0000dd">5</font> <font color="#009900">)</font> <font color="#339933">;</font>  <font color="#666666">// result = 10</font> </blockquote><br>  It remains only to test for speed. <br><br><h2>  Testing </h2><br>  When testing, I will compare the running time of the compiled code and the recursive calculation algorithm based on the tree.  We will measure the time using the clock () function from the standard library.  To calculate the time of the code section, it is enough to save the result of its call before and after the part being profiled.  If you find the difference of these values ‚Äã‚Äãdivided by the constant CLOCKS_PER_SEC, you can get the time of the code in seconds.  Of course, this is not a very accurate method of measurement, but I didn‚Äôt need it more precisely. <br>  In order to avoid the strong influence of errors, we will measure the time of multiple function calls. <br>  Code for testing: <br><blockquote>  <font color="#993333">double</font> measureTimeJIT <font color="#009900">(</font> Tree <font color="#339933">*</font> tree <font color="#339933">,</font> <font color="#993333">int</font> iters <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  <font color="#993333">int</font> i <font color="#339933">;</font> <br>  <font color="#993333">double</font> result <font color="#339933">;</font> <br>  clock_t start <font color="#339933">,</font> end <font color="#339933">;</font> <br>  CompiledFunc f <font color="#339933">;</font> <br><br>  start <font color="#339933">=</font> <font color="#000066">clock</font> <font color="#009900">(</font> <font color="#009900">)</font> <font color="#339933">;</font> <br>  f <font color="#339933">=</font> compileTree <font color="#009900">(</font> tree <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#b1b100">for</font> <font color="#009900">(</font> i <font color="#339933">=</font> <font color="#0000dd">0</font> <font color="#339933">;</font> i <font color="#339933">&amp;</font> lt <font color="#339933">;</font> iters <font color="#339933">;</font> i <font color="#339933">++</font> <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  f.  <font color="#202020">run</font> <font color="#009900">(</font> <font color="#009900">(</font> <font color="#993333">float</font> <font color="#009900">)</font> <font color="#009900">(</font> i <font color="#339933">%</font> <font color="#0000dd">1000</font> <font color="#009900">)</font> <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#009900">}</font> <br>  end <font color="#339933">=</font> <font color="#000066">clock</font> <font color="#009900">(</font> <font color="#009900">)</font> <font color="#339933">;</font> <br><br>  result <font color="#339933">=</font> <font color="#009900">(</font> end <font color="#339933">-</font> start <font color="#009900">)</font> <font color="#339933">/</font> <font color="#009900">(</font> <font color="#993333">double</font> <font color="#009900">)</font> CLOCKS_PER_SEC <font color="#339933">;</font> <br><br>  compiledFuncFree <font color="#009900">(</font> f <font color="#009900">)</font> <font color="#339933">;</font> <br><br>  <font color="#b1b100">return</font> result <font color="#339933">;</font> <br>  <font color="#009900">}</font> <br><br>  <font color="#993333">double</font> measureTimeNormal <font color="#009900">(</font> Tree <font color="#339933">*</font> tree <font color="#339933">,</font> <font color="#993333">int</font> iters <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  <font color="#993333">int</font> i <font color="#339933">;</font> <br>  clock_t start <font color="#339933">,</font> end <font color="#339933">;</font> <br>  <font color="#993333">double</font> result <font color="#339933">;</font> <br><br>  start <font color="#339933">=</font> <font color="#000066">clock</font> <font color="#009900">(</font> <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#b1b100">for</font> <font color="#009900">(</font> i <font color="#339933">=</font> <font color="#0000dd">0</font> <font color="#339933">;</font> i <font color="#339933">&amp;</font> lt <font color="#339933">;</font> iters <font color="#339933">;</font> i <font color="#339933">++</font> <font color="#009900">)</font> <br>  <font color="#009900">{</font> <br>  calcTree <font color="#009900">(</font> tree <font color="#339933">,</font> <font color="#009900">(</font> <font color="#993333">float</font> <font color="#009900">)</font> <font color="#009900">(</font> i <font color="#339933">%</font> <font color="#0000dd">1000</font> <font color="#009900">)</font> <font color="#009900">)</font> <font color="#339933">;</font> <br>  <font color="#009900">}</font> <br>  end <font color="#339933">=</font> <font color="#000066">clock</font> <font color="#009900">(</font> <font color="#009900">)</font> <font color="#339933">;</font> <br><br>  result <font color="#339933">=</font> <font color="#009900">(</font> end <font color="#339933">-</font> start <font color="#009900">)</font> <font color="#339933">/</font> <font color="#009900">(</font> <font color="#993333">double</font> <font color="#009900">)</font> CLOCKS_PER_SEC <font color="#339933">;</font> <br><br>  <font color="#b1b100">return</font> result <font color="#339933">;</font> <br>  <font color="#009900">}</font> </blockquote><br>  The code of the tester itself can be viewed in the repository.  All he does is consistently increasing the size of the input data in a controlled range, calls the above testing functions and writes the results to a file. <br>  According to this data, I plotted the execution time versus the size of the input data (expression length).  As the number of iterations to measure, I took 1 million.  Just.  The length of the string consistently increased from 0 to 2000. <br><img src="https://habrastorage.org/files/103/c1c/87a/103c1c87ada24ca0931b63926877085c.png" alt="Alt Testing graph 1"><br><img src="https://habrastorage.org/files/312/6a7/671/3126a7671e8d4e3da4987077b2f77af7.png" alt="Alt Testing graph 2"><br><br>  <font color="#00000ff">The blue graph</font> is the dependence of the execution time of the compiled code on the size of the task. <br>  <font color="#ff0000">The red graph</font> is the dependence of the execution time of the recursive algorithm on the size of the task. <br>  <b>The black graph</b> is the ratio of the y coordinates of the corresponding points of the first and second graphs.  Shows how many times the JIT is faster depending on the size of the task. <br>  It can be seen that when the size of the input data = 2000, JIT wins about 9.4 times.  I think this is very good. <br><br><h3>  Why is it faster with JIT? </h3><br>  Compiled code is absolutely linear - no conditional transition.  Due to this, during the execution time there is not a single reset of the processor pipeline, which is a very beneficial effect on performance. <br><br><h2>  What could be done better? </h2><br>  The biggest problem of our compiler is that it does not use all the features of FPU.  In FPU 8 registers, we use at most two.  If we were able to transfer part of our stack to the FPU stack, I am sure that the computation speed would greatly increase (of course, this should be tested). <br>  Another drawback - the compiler is very stupid.  It does not calculate constant expressions, it does not avoid unnecessary calculations.  It is very easy to make an expression so that it spends maximum resources.  If you add an elementary expression simplifier, the compiler will become close to ideal. <br>  The problem of the implementation itself can be considered the impossibility of a simple transfer to another platform (specific commands are used in the code generation function) and the operating system (VirtualProtect, though).  A completely obvious and fairly simple solution would be to abstract the platform and OS dependent parts and put their implementations into separate modules. <br><br>  <b>Thanks for reading, really looking forward to comments and advice.</b> <br>  Repository: <a href="https://bitbucket.org/Informhunter/jithabr">bitbucket.org/Informhunter/jithabr</a> <br><br>  The article was inspired by the book ‚ÄúPerfect Code‚Äù, namely, its chapter ‚ÄúDynamic Code Generation for Image Processing‚Äù. </div><p>Source: <a href="https://habr.com/ru/post/254831/">https://habr.com/ru/post/254831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254813/index.html">Getting the path to the SD Card on Android</a></li>
<li><a href="../254823/index.html">When robots "soar in the clouds": The five components of cloud robotics</a></li>
<li><a href="../254825/index.html">What actually happens when a user types google.com into a browser</a></li>
<li><a href="../254827/index.html">IBM and Semtech unveiled new network technology LoRaWAN for M2M communications</a></li>
<li><a href="../254829/index.html">Animal Feeder with ATTiny85</a></li>
<li><a href="../254835/index.html">FreePBX - forwarding with real-time notifications via XMPP</a></li>
<li><a href="../254837/index.html">Money as a Value Object</a></li>
<li><a href="../254839/index.html">Atmel is still too early to dig in - she is very much alive</a></li>
<li><a href="../254841/index.html">Building analytical expressions ... for any objects - from the Pythagorean theorem to the pink panther and Sir Isaac Newton in Wolfram Language (Mathematica)</a></li>
<li><a href="../254843/index.html">Lectures Technopark. Term 3 Design of high-load systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>