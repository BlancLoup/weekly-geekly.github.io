<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JIT compiler as an academic project at the Academic University</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="About sixteen years ago, the first version of Hotspot was released - a JVM implementation, which later became the standard virtual machine supplied wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JIT compiler as an academic project at the Academic University</h1><div class="post__text post__text-html js-mediator-article">  About sixteen years ago, the first version of <b>Hotspot was released</b> - a JVM implementation, which later became the standard virtual machine supplied with the Sun JRE. <br><br>  The main difference of this implementation was the JIT compiler, thanks to which, statements about <i>slow Java</i> in many cases became completely untenable. <br>  Now almost all interpreted platforms, such as CLR, Python, Ruby, Perl, and even the wonderful R <i>programming language</i> , have got their own implementations of JIT-translators. <br><br>  In this article, I do not plan to shed light on the little-known details of the implementation of industrial JIT-compilers, rather it will be quite a superficial acquaintance with the basics and a story about a training project on relevant topics. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, you may be interested under the cut if: <br><ul><li>  You basically do not understand what a JIT compiler is, or you have a slight misunderstanding than such an approach is <i>significantly</i> better than interpretation. </li><li>  You would like to write a simple JIT for your interpreted language. </li><li>  You teach the course ‚ÄúProgramming Languages ‚Äã‚Äãand Compilers‚Äù, and do not mind making the practical task for students more interesting. </li><li>  You wonder how this picture is drawn. </li></ul><br><img src="https://habrastorage.org/files/5f7/cfd/84e/5f7cfd84e9f8429cb28d5685fb8d5002.png"><br><a name="habracut"></a><br><h2>  Benefits of JIT Compilation </h2><br>  To talk about the benefits, let's first understand what it is.  Let's start from afar, namely with the definition of a compiled language. <br><br>  <b>A compiled programming language is a programming</b> language whose source code is converted by the compiler into the machine code of a specific architecture, for example x86 / ARM.  This machine code is a sequence of commands that is completely understandable to your processor, and can be executed by it without an intermediary. <br><br>  <b>Interpreted programming languages</b> are different in that source codes are not converted into machine code for direct execution on the CPU, but are executed using a special interpreter program. <br>  As an intermediate version, many languages ‚Äã‚Äã(Java, C #, Python) are translated into machine-independent <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B0%25D0%25B9%25D1%2582-%25D0%25BA%25D0%25BE%25D0%25B4">byte code</a> , <br>  which still cannot be executed directly on the CPU, and an interpreter is still needed to execute it. <br><br>  Why is the interpretation slower?  The answer to this question, oddly enough, does not seem obvious to everyone, although it is really very simple: interpreting each command separately, we spend additional resources on translating the semantics of this command into a processor language.  In addition, modern processors are optimized for executing sequential instructions (see <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B2%25D0%25B5%25D0%25B9%25D0%25B5%25D1%2580">Pipeline</a> ), and the interpreter most often represents a huge switch with a bunch of options that drives the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D1%2581%25D0%25BA%25D0%25B0%25D0%25B7%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D1%2585%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25B2">predictor of transitions</a> into a dead end. <br><br>  A completely natural solution to all these problems would be to translate the bytecode once into the processor language and transfer it to the CPU for execution.  So most often they do, calling this process <i>Just-in-time-compilation</i> <b>(JIT)</b> .  In addition, it is during this phase that various optimizations of the generated code are most often performed. <br><br>  We now turn to practice. <br><br><h2>  Formulation of the problem </h2><br>  The course <i>‚ÄúVirtualization and Virtual Machines‚Äù</i> at our university is read by Nikolai Igotti, who took part in the development of various VM classes: Hotspot, VirtualBox, NativeClient, and who knows firsthand the details of their implementation.  Thanks to the wonders of modern technology, in order to learn more about it, it is not even necessary to be a student at an Academic University, since the course has been <a href="https://www.lektorium.tv/course/22769">published in a lecture hall</a> .  Although it should be noted that this is of course a bit different, due to the interactivity of the course and work with the audience in lectures. <br><br>  As part of the course, students were asked to write their own implementation of a simple stack-based virtual machine interpreter and translator into bytecode from a C-like language to gain admission to the exam.  In fact, the task is somewhat simpler than it might seem at first glance - along with the task a lot of ready-made C ++ code is issued: <br><ul><li>  The parser in the AST of the programming language that you want to broadcast.  Thank you so much for this!  Usually, by the sixth year, students of AU have time to write sixteen different parsers, and writing another recursive descent is completely uninteresting. </li><li>  A list of types of bytecode instructions in the form of enum with detailed comments. </li><li>  Utility classes for working with byte-code: its design and work with binary representation. </li></ul><br>  The code name for this entire task is <b>mathvm</b> , apparently due to the fact that the main purpose of a programming language, as often happens, is to calculate something. <br><br>  A typical mathvm program: <br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = fib(x - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r + fib(x - <span class="hljs-number"><span class="hljs-number">2</span></span>); } print(fib(<span class="hljs-number"><span class="hljs-number">35</span></span>), <span class="hljs-string"><span class="hljs-string">'\n'</span></span>);</code> </pre> <br>  Main features of the language: <br><ul><li>  Work with data types: int, double, string, arithmetic over them. </li><li>  Standard control structures: if, while, for, print. </li><li>  The possibility of declaring functions within functions, as a consequence of the presence of closures.  This feature, although it caused a lot of questions in the design of the interpreter, however, given the availability of instructions for working with closures, did not become a stumbling block. </li><li>  Ability to declare <i>native-functions</i> .  That is, you can declare a function without a body with the mark ‚Äúnative‚Äù and the name of a symbol that can be loaded by the virtual machine via <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html">dlsym</a> with the parameter RTLD_DEFAULT. <br>  For example: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printfIDS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> format, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x3</span></span></span><span class="hljs-function">) native 'printf'</span></span>; printfIDS(<span class="hljs-string"><span class="hljs-string">'%d %f %s\n'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'abc'</span></span>);</code> </pre><br></li></ul>  It seems to me that the last point makes the task much more fun: <br><ul><li>  First, it is not immediately clear how you can pass an unknown set of arguments to a function if you have a pointer to the function in runtime, the signature and the calculated arguments are stored in a certain place in memory.  It is more or less clear that it will not be possible to do this completely cross-platform, and at least the Calling conventions must be fixed.  We agreed on calling conventions from <a href="http://www.x86-64.org/documentation/abi.pdf">System V ABI</a> , used in popular unix systems. <br>  But even after that, it does not seem obvious how to achieve the goal most painlessly. <br>  The only thing that came to mind was a huge, terrible assembler insert with a code that decomposes the arguments in the corresponding registers and stack cells.  As a result, I chose a slightly different solution, which I will describe below. <br></li><li>  Native-functions significantly expand the capabilities of the resulting language.  When the interpreter and translator are ready after several days of stupor, and instead of dull numerical integration with trapezes, something <a href="http://pastebin.com/aR4aVRAx">like</a> that starts up on your brainchild and draws a cool psychedelic animation on the screen (see the screenshot at the beginning of the article), this is a nice bonus. <br></li></ul><br>  The attentive reader may have noticed that the program from the last item for some reason calculates the number of frames drawn per second (FPS).  This indicator allows you to evaluate the performance of the interpreter and thus allows you to bring a competitive spirit into the learning process that seemed to someone boring. <br>  The student, the interpreter of which will be the fastest on this and another pair of similar benchmarks, automatically passes the exam, and in addition receives the love and respect of colleagues.  It should be noted that we are not the first thread with which we played this game, and usually it was necessary to implement a JIT compiler to win. <br><br><h2>  Difficulties </h2><br>  It would seem that it is essentially difficult to simply translate the semantics of simple byte-code instructions into the corresponding elements of the x86 instruction set? <br><br><ol><li>  If we had a compiled language, then we could literally generate the text in assembly language, then assemble it accordingly, resulting in an executable file. <br>  But within the framework of the JIT-translation, it is an impermissible luxury to divide the process into two phases, and you need to somehow immediately learn to generate machine code in the memory of the VM process. <br></li><li>  And not any area of ‚Äã‚Äãmemory is suitable for recording machine code.  More precisely, you can write anywhere, but you can transfer the execution only to the memory area whose pages are marked as executable.  It seems there can not do a simple malloc'om. </li><li>  Ideally, of course, so that the resulting machine code works as quickly as possible. </li></ol><br><h2>  Asmjit </h2><br>  <a href="https://github.com/kobalicek/asmjit">Asmjit</a> is quite suitable for solving the first two problems - an open source library, developed mostly by one person over the past few years, and used in other projects of the author, as well as in <a href="https://github.com/Zeex/samp-plugin-jit">JIT for scripts on the GTA San Andreas MP server</a> . <br>  As it is easy to understand from the title, its main mission is to create a convenient API for generating machine code Just-in-time.  Its public interface can be divided into two parts: <br><ul><li>  <b>The X86Assembler</b> is a low-level interface that essentially allows you to do three things: <br><ol><li>  Initiate the allocation of a piece of memory with execution privileges. </li><li>  Place instructions / data in it sequentially and set labels for places where transitions from other code sections exist. <br>  To work with the code in the library there is a set of classes of operands: GpReg, XmmReg, Imm, Mem, and for each instruction in the class there is a method of the same name, and exactly with that set of overloads that are valid for this instruction.  For example, the <i>mov</i> signature method <i>(X86Mem &amp;, X86Mem &amp;) is</i> missing, as it should be. <br></li><li>  Getting a pointer to the beginning of the filled piece of memory, which can be used as a pointer to a function-entry point. </li></ol><br></li><li>  <b>X86Compiler</b> - high level wrapper over X86Assembler encapsulating <br><ul><li>  Creating functions and working with arguments in accordance with the specified calling conventions, both on the side of the function definition, and at the call site <i>(by the way, the easiest way to implement native-functions)</i> . <br></li><li>  Register allocation: you can define variables (GpVar or XmmVar), the storage for which the compiler will choose for itself.  At once I will make a reservation that I did not search, and I do not know what kind of allocation algorithm is used.  The only thing I can say is that in simple experiments the existing registers were used quite reasonably. </li></ul><br></li></ul><br>  In my implementation, I used the Assembler, which bribed me with its transparency and finer controllability. <br><br>  The easiest working example of using Asmjit: <br><pre> <code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"asmjit/asmjit.h"</span></span> #include &lt;iostream&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, char** argv) { using <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> std; using <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> asmjit; using <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> asmjit::x86; JitRuntime runtime; <span class="hljs-comment"><span class="hljs-comment">// RAII object X86Assembler assembler(&amp;runtime); assembler.add(rdi, rsi); // add second argument to first assembler.mov(rax, rdi); // mov result to return register assembler.ret(); void * address = assembler.make(); cout &lt;&lt; reinterpret_cast&lt;int64_t (*) (int64_t, int64_t)&gt;(address)(2, 2) &lt;&lt; endl; // 4 return 0; }</span></span></code> </pre><br>  I think people who are familiar with the assembler, he should not cause many questions.  The only thing to be mentioned is the runtime object responsible for the lifetime of the allocated memory.  It will be released after calling its destructor ( <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B5%25D1%2581%25D1%2583%25D1%2580%25D1%2581%25D0%25B0_%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">RAII</a> ). <br>  More examples of use can be found in the test library of the library or in my repository. <br><br><h2>  Debugging </h2><br>  Oddly enough, debugging the generated code does not differ in special perversions. <br>  First, if something went wrong, you can thoughtfully look at the Asmjit logs.  In the logs you can see the resulting assembly code and a few comments, where it came from. <br>  In case even this did not help you, then in most modern debuggers (gdb / VS) there is a possibility to work in debug mode with disassembly.  That is, you can put a breakpoint in place of the call of the generated function, and <i>Step Into</i> will take you to the screen with an assembler code, where you can debug almost as usual. <br>  <b>Important</b> <br><ul><li>  In three cases out of ten in half an hour, you will find the error not in the compiler, but in the interpreted program itself. <br></li><li>  Unfortunately, since Asmjit is not used very intensively yet, it can potentially contain various degrees of nasty bugs.  Therefore, carefully watch that in the logs exactly what you wanted.  Although I didn‚Äôt come across anything, my classmate was unlucky: the fact that an invalid code was generated was not visible even in the logs, but only in the debugger. <br></li></ul><br><br><h2>  Optimization </h2><br>  After three days of active programming and debugging, the first completely unsophisticated version of the JIT-translator appeared, in which all values ‚Äã‚Äãof the stack and variables were thoughtlessly stored in memory each time. <br>  Even this solution gave a performance gain of about six times, with 6 FPS, which were obtained with an interpreter up to 36 FPS. <br><br>  In general, at the beginning of the semester, when the rules of the game became clear, I had Napoleon's plans: to make everything quite adult, with the transfer of bytecode to <a href="https://ru.wikipedia.org/wiki/SSA">SSA</a> and a clever register allocation algorithm. <br>  But due to the acute shortage of time and banal cowardice, it all ended up a bit more prosaic. <br><br><h4>  Register allocation </h4>  Just in case, let me remind you that one of the most critical points in terms of program performance is the effectiveness of using the existing CPU registers. <br>  This is due to the fact that the main computational activity can be performed only on them, and besides reading / writing, even in memory in the L1 cache, works up to two times longer than similar operations on registers. <br>  I used not the most difficult, but rather effective heuristic solution: we will store in registers the first elements of the virtual machine stack, 7 elements for general purpose slots (lines / integers) and 14 for floating point slots. <br>  This solution seems to be the most justified, since the hottest variables in the framework of the function‚Äôs work are indeed the bottom of the stack, which participates in all calculations. <br>  In addition, if you use the same registers, in which the arguments are expanded when you call functions, this in some cases saves time at the call sites. <br>  As a result of the implementation of these ideas, I received an acceleration of <b>9 FPS</b> , thus reaching 45 FPS, which could not but please me. <br><br><h4>  Peephole optimization </h4>  One of the simple classical approaches to generating is the so-called <a href="http://en.wikipedia.org/wiki/Peephole_optimization">Peephole-optimization</a> , the idea of ‚Äã‚Äãwhich is to search for and replace certain sequences of instructions with other, more productive ones. <br><br>  For example, due to the lack of expressiveness of the mathvm bytecode, comparison operators like (x0 &lt;= x1) have to be described something like this: <br><pre> <code class="hljs objectivec">LOADIVAR_0 LOADIVAR_1 IF_CMPLE L1 ILOAD_0 <span class="hljs-comment"><span class="hljs-comment">//   0    JA L2 //   L1: ILOAD_1 L2: ...</span></span></code> </pre><br>  Experts on Instructions set x86 will say that such code can be written much shorter and without a single conditional jump: <br><pre> <code class="hljs mel">mov rdi, %(var0) mov rsi, %(var1) cmp rdi, rsi setle al movzx rax, al</code> </pre><br>  Similar constructions are found in other cases: the negation operator, the for loop.  The detection and correction of these patterns led to an acceleration of <b>4 FPS</b> to 49 points. <br><br><h4>  Closure optimization </h4><br>  To provide work with closures in the prolog and epilogue of each function, I saved the address where the variables of the last call are located in a specially allocated area of ‚Äã‚Äãmemory outside the stack. <br>  In addition, you need to save and restore the previous base pointer.  All this joy took up to seven extra instructions for each challenge, including those actively working with memory. <br>  In fact, most functions do not contain circuits within themselves, and these losses can be avoided. <br>  Therefore, I carried out an additional analysis of the entire byte-code received for the presence of closures and the corresponding redundant instructions were removed, as a result of which the cartoon began to be drawn another <b>3 FPS</b> faster. <br><br><h4>  Inlining </h4><br>  The final point of the story about micro-optimization is <i>inlining</i> or in Russian <i>‚Äúembedding‚Äù</i> .  The method by which industrial compilers struggle with the cost of calling small functions: the code of the called function is simply duplicated at the call site, without a prologue / epilogue and other ‚Äúextra‚Äù instructions.  However, it should be noted that in real life compilers approach the decision about embedding very carefully - the size of the resulting machine code is also a measure of the quality of their work. <br><br>  However, in my case, since it is the time of work that is estimated, I decided to try to embed everything that is embedded (non-recursive calls). <br>  And here, oddly enough, it turned out to be easier to work at the level of AST translation into byte-code. <br><br>  The resulting increase of <b>2 FPS</b> was no longer as significant as in the previous cases, but the total 53-54 FPS (almost ninefold acceleration) can not but rejoice.  Acceleration of the same order was observed in other available benchmarks. <br><br>  What is interesting, even in my simple JIT-translator, to obtain peak performance, several warm-up iterations were required, although I didn‚Äôt run the interpreter at all and immediately compiled all the code. <br>  This illustrates the statements of authoritative people about the fact that warmup in benchmarks is needed not only to compile everything you need, but also to fix the profile of the program. <br><br><h2>  Results </h2><br>  As a result, my implementation was the fastest, but this is due not so much to the fact that I am the most cunning, but to the fact that none of the opponents made even the simplest implementation of JIT. <br>  Thus, the absence of at least some kind of sports intrigue darkened the victory a bit. <br><br>  The sources of my implementation can be viewed in the <a href="https://github.com/bintree/mathvm-impl">repository</a> in the impl directory. <br>  I apologize in advance for the quality of the code, but this is still a toy project, and I do not plan to support it further. <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/250841/">https://habr.com/ru/post/250841/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250829/index.html">Computer Interfaces in Cinema - Evolution of Imagination</a></li>
<li><a href="../250831/index.html">Bottle and plugins</a></li>
<li><a href="../250833/index.html">How to make friends OpenHAB and Arduino. Method # 3: MQTT</a></li>
<li><a href="../250835/index.html">High Frequency Trading Next Door - Part V (Beginning)</a></li>
<li><a href="../250837/index.html">Introducing the new version of Kerio Control 8.5</a></li>
<li><a href="../250845/index.html">Anti-patterns of design: Dead End</a></li>
<li><a href="../250847/index.html">The tools that allowed us to speed up the development of the game</a></li>
<li><a href="../250851/index.html">Why Bittorent via Tor is a Bad Idea</a></li>
<li><a href="../250853/index.html">Simple webdev in java 8</a></li>
<li><a href="../250855/index.html">Applied optimization practice and some history</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>