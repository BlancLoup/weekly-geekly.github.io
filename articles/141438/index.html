<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rendering the other way around. GPU Hough Transformation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hough Transform is used to search on the image of the figures specified analytically: straight lines, circles and any others, for which you can come u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rendering the other way around. GPU Hough Transformation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/211/b94/b5a/211b94b5a2bc471f5b7cf1bd7f94953f.png" alt="title"><br><br>  Hough Transform is used to search on the image of the figures specified analytically: straight lines, circles and any others, for which you can come up with an equation with a small number of parameters.  Much has been written about the conversion of Khaf, and this article does not set a goal to highlight in detail all aspects.  I will only explain the general principle, focusing on the features that prevent its implementation on the GPU "head on" and, of course, I will offer a solution.  Those who know the problems and want to see a solution immediately can skip a couple of sections. <br><br><a name="habracut"></a><br><h4>  Algorithm for CPU </h4><br>  First, we describe the desired shape by an equation.  For example, for a line, this could be y = Ax + B. <br>  Then we start the so-called accumulator: an array with the number of measurements equal to the number of parameters in the equation.  In our case - two-dimensional.  We will have the <i>Space of Hough</i> (at least part of it) - in it the straight lines will be represented by their parameters.  For example, A is horizontal and B is vertical.  One line in ordinary space = one point in Hough space. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The original image is binarized, and for each non-empty point (x <sub>0</sub> , y <sub>0</sub> ) we define a set of lines that can pass through this point: y <sub>0</sub> = Ax <sub>0</sub> + B. Here x <sub>0</sub> and y <sub>0</sub> are constant, A and B are variables, and This equation defines a straight line in Hough space.  We need to draw this line in our battery - add 1 to each element through which it passes.  Such a procedure is called voting: a dot votes for the direct ones that can pass through it. <br><br>  As a result, it turns out that all the votes from all points are collected in the accumulator, and it can be considered that the ‚Äúwinners of the vote‚Äù are present on the original image.  Here, of course, it is possible and necessary to apply threshold filtering and other methods in order to find maxima in the Hough space, but the main and most laborious task is to fill the battery. <br><br>  Wikipedia illustration: <br><br><img src="https://habrastorage.org/storage2/995/33f/3c7/99533f3c7d8d8bc490fedac9a645912f.png"><br><br><h4>  GPU issues </h4><br>  A GPU can be considered as a set (up to thousands) of small processors having a common memory, and, as a rule, the algorithms are simply divided: giving each processor its own piece of work.  It would seem that we divide the original image into pieces, give each processor its own piece - and that's it.  But no, we cannot divide the battery: in each piece of the original image there can be points projected onto any place of the Hough space.  Processors cannot write to the general memory, only to read - otherwise there will be problems with synchronization.  The solution would be to give each processor its own battery, and after processing, add up the batteries together.  But, you remember, thousands of processors.  Even if there is so much memory, the time for its allocation and processing will override the benefits of parallel execution of the algorithm. <br><br>  Another, smaller, problem is the algorithms for ‚Äúdrawing‚Äù lines in the Hough space.  They can be quite intricate, but even the simplest ones will contain loops and branching.  But the GPU does not like this: small processors do not know how to execute each of their programs, they all perform one (well, not all, but in large groups).  Simply everyone operates with the data.  This means that both branches of the branch are executed (then the result of the unnecessary is discarded for each processor separately).  And the loop is executed as many times as necessary for the worst case input.  This leads to the fact that the efficiency of the use of processors decreases. <br><br><h4>  Algorithm modification for GPU </h4><br>  My initial idea was this: why not divide into ‚Äúzones of influence‚Äù not the original image, but the Hough space?  That is, let's calculate the value for each point of the Hough space separately.  At first glance, this seems silly: any point of the original image can give a ‚Äúvoice‚Äù, which means that we will have to examine them all.  Total number of read operations = <i>[number of points of the original image]</i> x <i>[number of battery cells]</i> , whereas in the traditional way it is only <i>[number of points of the original image]</i> . <br><br>  But then the number of write operations is potentially reduced ‚Äî <i>[the number of battery cells]</i> versus <i>[the number of non-empty points]</i> x <i>[the average length of the image of a point in Hough space]</i> .  If there are a lot of non-empty points, the difference is significant. <br><br>  So the reading gets bigger, the writing gets smaller, and it becomes more orderly.  Now we remember what the power of the GPU is.  In reading speed!  Video cards are equipped with fast memory, access to it is ‚Äústraightened‚Äù to the limit - all with the aim to impose textures as quickly as possible.  True, this is at the expense of latency - unordered read requests are slower.  But we will not have these. <br><br>  The second idea.  If it is necessary to ‚Äúdraw‚Äù in the space of Hafa - why not use the ‚Äúdrawing‚Äù talents of video cards?  Let's overlay the original image on the Hough space as a texture. <br><br>  This leads to the fact that in my method neither the OpenCL or CUDA code, nor the shaders are needed.  The video card is not even obliged to support them in order to get an image of the Hough space.  The price for this is non-universality: in practice, these are two essentially different methods: one for circles and the other for straight lines.  It seems that the ‚Äúcircles‚Äù method can be applied to any closed lines and any figures with three or more parameters in the equation, but the efficiency may be different. <br><br><h4>  The method of "circles" </h4><br>  The circle is described by an equation with three parameters - (xx <sub>0</sub> ) <sup>2</sup> + (yy <sub>0</sub> ) <sup>2</sup> = R <sup>2</sup> .  Here (x <sub>0</sub> , y <sub>0</sub> ) are the coordinates of the center, and R is the radius.  The Hough space should have three dimensions, but for now we restrict ourselves to two and fix R (let's say we know it).  In this case, all we need to find is the coordinates of the center (s). <br><br>  Take this original image (all circles of one radius) <br><br><img src="https://habrastorage.org/storage2/a9a/5b0/a30/a9a5b0a301aa2527f389e262a58239bc.png"><br>  and, having made it almost transparent, we impose on ourselves as follows: <br><br><img src="https://habrastorage.org/storage2/b42/111/58c/b4211158cf1ba14e8dff7680d73c8105.png"><br>  All images are offset from the original by the radius of the circle.  The angle between adjacent offset radii is the same.  That is, for example, the upper left corners of the images are distributed around a circle of the same radius as the desired one. <br><br>  For clarity of illustration, I put the inverse of the original image below and marked the important places in red. <br><br><img src="https://habrastorage.org/storage2/b6d/079/b45/b6d079b45ae2feb8a62e9cb8608d53e2.png"><br>  Each circle of each image passes through the center of the corresponding circle of the original image.  At these points they overlap each other and the maximum brightness is obtained. <br><br>  This is what will happen if you do this operation 32 times: <br><br><img src="https://habrastorage.org/storage2/608/131/285/608131285bbf02b78fc3076c4144fdb4.png"><br>  And after the threshold filtering: <br><br><img src="https://habrastorage.org/storage2/a6b/45a/75c/a6b45a75c17aed3bcf889f0d8ce3d9c1.png"><br>  Thus, we have filled two dimensions of Hough space.  Now, by varying the radius, you can easily fill the third.  And you can not try to accumulate all 3 measurements in memory, and process the resulting image, keeping the position of the centers and the radius and free the memory. <br><br>  The code (Managed DirectX, the full version is the link below), creating well-spaced rectangles: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)rAbs / targetSize; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> angle = <span class="hljs-number"><span class="hljs-number">2</span></span> * Math.PI / n * i; rectangles.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TexturedRect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(Math.Cos(angle) * r), (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(Math.Sin(angle) * r)), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>  Code setting alpha transparency in the right way: <br><br><pre> <code class="cs hljs">device.RenderState.AlphaBlendEnable = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, device.RenderState.BlendFactor = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(<span class="hljs-number"><span class="hljs-number">256.0</span></span> * brightness / n) device.RenderState.BlendOperation = BlendOperation.Add; device.RenderState.SourceBlend = Blend.BlendFactor; device.RenderState.DestinationBlend = Blend.One;</code> </pre><br>  Here <code>rAbs</code> sets the desired radius, <code>brightness</code> - brightness, <code>n</code> - the number of layers. <br><br>  Render everything in texture <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Microsoft.DirectX.Direct3D.Texture(device, targetSize, targetSize, <span class="hljs-number"><span class="hljs-number">1</span></span>, Usage.RenderTarget, cbGray.Checked ? Format.L8 : Format.X8R8G8B8, Pool.Default); dxPanel.RenderToTexture(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Options() { AlphaBlendEnable = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, BlendFactor = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(<span class="hljs-number"><span class="hljs-number">256.0</span></span> * (tbBrightness.Value / <span class="hljs-number"><span class="hljs-number">100.0</span></span>) / n) }, rectangles);</code> </pre><br>  And you can use a 3D texture and several sets of layers in order to render all the radii of interest and at the same time get the three-dimensional space of Hough (I did not try to do that). <br><br>  With transparency, there is such a nuance that if you use an 8-bit color and a sufficiently large number of layers, then the BlendFactor will be less than 10, up to 1. This can lead to large rounding errors, and a stepwise change in brightness, if you adjust the overall brightness with BlendFactor.  However, if the brightness is not adjusted, it will be difficult to choose a threshold value for filtering all due to the same rounding errors.  Also, if you use an image with shades of gray, the shades will suffer, and even I will be lost with BlendFactor = 1. <br><br>  This problem can be solved by using a large color depth for the render target (for example, 16 or 32 bits), if the video card supports it. <br><br>  Here is another example of working on a noisy image.  Original: <br><br><img src="http://habrastorage.org/storage2/c37/b51/1ee/c37b511ee0cf860fc8d2e5d1cfdb468f.png"><br>  Result (64 layers): <br><br><img src="http://habrastorage.org/storage2/9b2/e87/756/9b2e87756c8e843e7a76da27e6349b2d.png"><br><br>  You may notice that the algorithm most likely polls not all the points that make up the circle (unless the circle is too small).  With the increase in the number of layers, the percentage of surveyed points and the accuracy of determination increases, but the operation time increases and the problems described above appear. <br><br><h4>  The method of "direct" </h4><br><h5>  Anisotropic filtering </h5><br>  Before proceeding to the description of the method itself, you need to make a digression and tell more about anisotropic filtering in video cards.  When overlaying a texture, it can happen that the color of a single screen pixel should define several texture points (texels).  This usually happens either with a large distance of the polygon from the viewer, or with a strong inclination of the polygon (a good example is the texture of the road).  And if in the first case it is possible to scale the texture into several resolutions in advance, and then take the necessary variant (mip-mapping), then in the second one cannot do it because the texture can be turned ‚Äútowards the viewer‚Äù either side. <br><br><img src="http://habrastorage.org/storage2/9d8/a39/a9d/9d8a39a9dcb931b6be1cd47021f97b14.png"><br>  And here the video cards use all sorts of tricks, but the most honest way is to take all the texels from the projection of the pixel on the texture and calculate their average value.  This is called anisotropic (direction dependent) filtering. <br><br>  The maximum traditionally supported level of anisotropic filtering is 16 (apparently texels). <br><br><h5>  About the method itself </h5><br>  Take our image and "flatten" it, for example, vertically.  Those.  render it entirely on a 1-pixel-high rectangle.  Ideally, the vertical lines will turn into points (maxima).  Everything else will be smeared.  Thus, we have already obtained the value of one parameter ‚Äî this is the distance from the left edge of the image to the point (to the line on the original image). <br><br>  Now take a fresh copy of the image, but before flattening it, turn it to some small angle around the center of the image in a clockwise direction.  Then flatten.  Some lines will go to points.  These will be the straight lines that are inclined at the same angle of rotation of the image. <br><br>  Thus, going through all the angles from 0 to Pi, we get the values ‚Äã‚Äãof the second parameter - the angle of rotation of the picture.  By these two parameters, you can restore any original line. <br><br>  The only question that remains is how to properly flatten the image.  If you do it in the forehead, only noise will remain - anisotropic filtering will work, but it will take only 16 texels (pixels of the original image).  This is most likely too little. <br><br>  You can cut the image into rectangles 16 pixels wide, flatten each one separately, <br><br><img src="http://habrastorage.org/storage2/a14/63c/15f/a1463c15f0abc49454b677d113c0b402.png"><br>  and then draw them on top of each other, as we did in the method with circles.  This will work, and as a result, each pixel will be taken into account. <br><br><img src="http://habrastorage.org/storage2/d57/348/e68/d57348e687a79f96758ee52913f8d1ca.png"><br>  (We can assume that the pictures are enlarged 4 times so that the details can be seen) <br><br>  If the image is higher than 16 * 256 = 4096 pixels, you can cut it into rectangles of greater height, or use a greater color depth.  But, most likely, such an image simply does not fit into the texture. <br><br>  In order not to lose the lines in the corners, or near the short sides of the non-square image, you must take the render target width equal to the diagonal of the original image. <br><br>  The code that sets up the texture sampler (I rotate the texture coordinates, so I need the sampler to return black if there is no texture somewhere because of the rotation). <br><br><pre> <code class="cs hljs">device.SamplerState[<span class="hljs-number"><span class="hljs-number">0</span></span>].MinFilter = TextureFilter.Anisotropic; device.SamplerState[<span class="hljs-number"><span class="hljs-number">0</span></span>].MaxAnisotropy = <span class="hljs-number"><span class="hljs-number">16</span></span>; device.SamplerState[<span class="hljs-number"><span class="hljs-number">0</span></span>].AddressU = TextureAddress.Border; device.SamplerState[<span class="hljs-number"><span class="hljs-number">0</span></span>].AddressV = TextureAddress.Border; device.SamplerState[<span class="hljs-number"><span class="hljs-number">0</span></span>].AddressW = TextureAddress.Border; device.SamplerState[<span class="hljs-number"><span class="hljs-number">0</span></span>].BorderColor = Color.Black;</code> </pre><br>  Creating Rectangles <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> sourceRectPixelWidth = sourceSize / n; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> targetRectPixelWidth = Math.Ceiling(sourceRectPixelWidth / anizotropy); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> angleValues = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Floor(targetSize / targetRectPixelWidth); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sourceRectWidth = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(sourceRectPixelWidth / sourceSize); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tarectRectWidth = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(targetRectPixelWidth / targetSize); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> angleNumber = <span class="hljs-number"><span class="hljs-number">0</span></span>; angleNumber &lt; angleValues; angleNumber++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> angle = Math.PI / angleValues * angleNumber; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> targetShift = tarectRectWidth * angleNumber; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sliceNumber = <span class="hljs-number"><span class="hljs-number">0</span></span>; sliceNumber &lt; n; sliceNumber++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sourceShift = sourceRectWidth * sliceNumber; rectangles.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TexturedRect( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(tarectRectWidth, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(targetShift, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(sourceRectWidth, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(sourceShift, <span class="hljs-number"><span class="hljs-number">0f</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)angle)); } }</code> </pre><br>  The same noisy image as in the last section, but now we are looking for lines (32 layers, 512 steps of the angle of rotation): <br><br><img src="http://habrastorage.org/storage2/79d/314/0c3/79d3140c385d198c64b965ee4c836c21.png"><br><br><h4>  Extension of the "circles" method </h4><br>  Images can be shifted not along the radii of circles, but in a more capricious way.  For example, choose some arbitrary desired contour (not even expressed using a formula) and a certain point O. <br><br><img src="http://habrastorage.org/storage2/3e0/3d0/e3d/3e03d0e3dbdcde95c89176d40d79c6ba.png"><br><br>  Then, successively choosing points A1, A2 on the contour, shift the image layers by vectors AO.  It turns out that the angle of the images describes a figure like this. <br><br><img src="http://habrastorage.org/storage2/784/9ab/b52/7849abb520c3eb49fe6b8195df0ac721.png"><br><br>  In this case, all the bears in the image will be found - the maxima will fall on the point corresponding to the point O of the original contour. <br><br><img src="http://habrastorage.org/storage2/659/911/10a/65991110abc0b0ac9474fda29c6c10bf.png"><br><br><h4>  Additional advantages over the traditional way </h4><br><ul><li>  Saving memory (you can not save all measurements in memory) <br></li><li>  You can not do binarization, and use shades of gray.  This will not affect performance and may increase accuracy. <br></li><li>  You can evenly ignore part of the points in favor of speed (In the traditional way, you can also do this, but you have to resort to all sorts of tricks to achieve uniformity, and not just skip some angle) <br></li><li>  You can work with very noisy images, it will not reduce the speed <br></li><li>  Bonus  You can use color images to get beautiful pictures like the one on KPDV <br></li></ul><br><h4>  Performance </h4><br>  It will not be very fair to compare the performance of a pure counting between a CPU and a GPU, since one of the hardest parts of working with a GPU is loading and unloading data.  It is hardly worth uploading the results of the raw work back to the CPU.  You can try compacting them first to upload only the found shape parameters, not the points.  However, data compaction is also quite cunningly implemented on the GPU, so I haven‚Äôt even taken it for now. <br><br>  Pure conversion performance hafa.  Input and output - 2048 * 2048, GPU - GeForce GTS250: <br><br><img src="http://habrastorage.org/storage2/dd0/788/9a2/dd07889a29b973672447c962c4ebb507.png"><br>  For comparison, the results of the detection of lines using OpenCV.  The input is 2048 * 2048, the output is 2048 distance steps between the lines, CPU is Core i5 750 @ 3700Mhz. <br><br><img src="http://habrastorage.org/storage2/ae7/50e/28f/ae750e28f393b56ef352f3590f9de57d.png"><br>  From this time, 50-80 ms goes to the Canny border detector (after which a two-color image is processed). <br><br>  Conclusion: in the detection of lines on images with a small number of GPU details, it is 5‚Äì20 times faster.  On noisy / detailed images, the speed increase can be 100 to 300 times. <br><br>  It was not possible to compare the speed of detecting circles, since OpenCV uses not the usual, but the <i>gradient Hough method</i> . <br><br><h4>  Materials on the topic </h4><br>  <a href="https://gpuhough.codeplex.com/">Project sources</a> (To build you need DirectX SDK June 2010) <br>  <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A5%25D0%25B0%25D1%2584%25D0%25B0">Hough Transformation</a> <br>  <a href="http://habrahabr.ru/post/102948/">Hough's algorithm for detecting arbitrary curves in images</a> <br>  <a href="http://parse.ele.tue.nl/system/attachments/21/original/Fast%2520Hough%2520Transform%2520on%2520GPUs%2520-%2520Exploration%2520of%2520Algorithm%2520Trade-offs.pdf">Hough Transform on GPU</a> <br>  <a href="http://locv.ru/wiki/6.6.2_%25D0%259F%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A5%25D0%25B0%25D1%2584%25D0%25B0_%25D0%25B4%25D0%25BB%25D1%258F_%25D0%25BE%25D0%25BA%25D1%2580%25D1%2583%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">Gradient Hough Method in OpenCV</a> <br><br>  UPD: Yes, in order to run the attached example you need .NET and DirectX, but the principle itself is not tied to them.  With the same success, you can implement it in c ++ and OpenGL.  CUDA and OpenCL are still not needed. </div><p>Source: <a href="https://habr.com/ru/post/141438/">https://habr.com/ru/post/141438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141430/index.html">Version 4.0 - Creative Commons License Draft Ready for Public Comment</a></li>
<li><a href="../141431/index.html">The accident on the cellular network Vodafone in the Netherlands</a></li>
<li><a href="../141432/index.html">WordpressMD Community 1st Offline</a></li>
<li><a href="../141433/index.html">Facebook Developer Garage in faces</a></li>
<li><a href="../141434/index.html">TeamLab Document Editor on canvas: erasing the lines between desktop and online</a></li>
<li><a href="../141439/index.html">We write the first project on the Play Framework 2.0</a></li>
<li><a href="../141440/index.html">Data Filters on ASP.NET MVC and Entity Framework</a></li>
<li><a href="../141441/index.html">Search for repetitions in a two-dimensional array, or the right tool</a></li>
<li><a href="../141442/index.html">Accelerate your Arduino</a></li>
<li><a href="../141444/index.html">Django Gmap v3 Widget - geolocation with search, saving coordinates and addresses in JSONField</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>