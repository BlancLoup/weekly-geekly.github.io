<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Linux, delayed driver loading and broken interrupts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I will talk about unexpected problems that have arisen when connecting a matrix keyboard to an ARM board running Linux in the Bercut-ETN device ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Linux, delayed driver loading and broken interrupts</h1><div class="post__text post__text-html js-mediator-article"><img align="left" width="20%" src="https://habrastorage.org/files/825/540/d0f/825540d0fd47420c9f238bf4c8f25b4b.jpg">  Today I will talk about unexpected problems that have arisen when connecting a matrix keyboard to an ARM board running Linux in the Bercut-ETN device (ETN is a new hardware revision of <a href="http://metrotek.spb.ru/b3et.html">Bercut-ET</a> ).  Specifically, about why the adp5589 driver did not want to receive interrupts and how we were able to get him to do it. <br><br>  Who cares - welcome under cat. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>The contents of the article:</b> <br><br><ul><li>  Description of the iron part </li><li>  Where is the problem? </li><li>  A few words about Device Tree </li><li>  A bit about device and driver registration </li><li>  Driver Delay Mechanism </li><li>  How to make everything work </li></ul><br>  Description of the iron around the keyboard: <br><br>  The controller's keyboard itself is not - it is connected via the I2C bus using a special matrix keyboard controller - the adp5589 chip.  The chip has an interrupt line wound up on one of the GPIO pins ARM SoCa.  As a result, the wiring diagram looks like this: <br><br><img src="https://habrastorage.org/files/351/fbc/6c3/351fbc6c3fb34bb7acf1145b8692a68d.png"><br><br>  <b>portb</b> is the port on the pin of which the interrupt from the keyboard controller is initiated; <br>  <b>intc</b> - main interrupt controller; <br>  <b>i2c0</b> - <b>i2c</b> bus controller. <br><br>  The driver adp5589 for some reason stubbornly does not want to get the interrupt number.  What could be the cause of this behavior?  Perhaps, there are not enough resources to load the keyboard driver.  Maybe you did not have time to boot the device on which it depends?  Let's look at which devices it may depend on: <br><br>  First, from the I2C bus controller to which it is connected. <br>  Secondly, from the port controller, to the pin of which we have an interrupt line. <br><br>  Now let's see in what order the drivers of these devices are loaded: <br><br>  gic <br>  designware-i2c <br>  adp5589 <br>  dw-apb-gpio-port <br><br>  Aha  That's the reason - when the keyboard driver is loaded, its interrupt-parent is not yet loaded.  As a result, the keyboard driver does not receive the interrupt number.  The standard solution to this problem is the mechanism of delayed loading of drivers. <br><br>  Its essence is that the driver may require re-loading if any necessary resource is not yet available.  And he can demand this by returning the value <b>-EPROBE_DEFER</b> from his <b>probe</b> function.  Then this driver will be reloaded later.  By that time, either the necessary resource will already be available, or the loading of the driver will be postponed again. <br><br>  Add a check to the keyboard driver's <b>probe</b> function: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!client-&gt;irq) { dev_err(&amp;client-&gt;dev, <span class="hljs-string"><span class="hljs-string">"no IRQ boss?\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EPROBE_DEFER; }</code> </pre> <br>  Hoping to look at the new boot order: <br>  gic <br>  adp5589 <br>  designware-i2c <br>  dw-apb-gpio-port <br>  (deferred) adp5589 <br>  (deferred) adp5589 <br>  (deferred) adp5589 <br><br>  Something went wrong - the keyboard driver re-loaded after the GPIO driver, but did not receive an interrupt.  It looks like you‚Äôll have to dig deeper into the source code than expected. <br><br>  This suggests three possible solutions: <br><br><ul><li>  Check in the interrupt number directly to the driver </li><li>  Any way to set the boot driver order </li><li>  Deal with the mechanism of deferred loading of drivers, which for some reason did not work </li></ul><br>  <b>First option:</b> <br><br>  The option is working, but not desirable.  It is suitable as a temporary one, but if you change something in the hardware (for example, connect the interrupt output to another GPIO port), you will have to make changes not only in Device Tree, but also in the source code of the driver. <br><br>  <b>The second option:</b> <br><br>  Explicitly set the driver loading order is not possible.  So this option is not suitable. <br><br>  <b>The third option:</b> <br><br>  The most correct.  We will consider it. <br><br>  Here, perhaps, it is worthwhile to briefly talk about such a thing as Device Tree, since then there will be references to it. <br><br>  Device Tree is one of the forms for describing the hardware of the device on which we want to use Linux.  It is presented in the form of a tree of nodes in which the necessary information is specified.  DT exists as human-readable text files ( <b>.dts</b> ; <b>.dtsi</b> ) and a binary file ( <b>.dtb</b> ) collected from them. <br><br>  For example, consider a slice of the .dts file describing the structure of connecting our keyboard controller to other SoCa devices. <br><br><pre> <code class="rust hljs">i2c0: i2c@ffc04000 { compatible = <span class="hljs-string"><span class="hljs-string">"snps,designware-i2c"</span></span>; keybs@<span class="hljs-number"><span class="hljs-number">34</span></span> { compatible = <span class="hljs-string"><span class="hljs-string">"adi,adp5589"</span></span>; interrupts = &lt;<span class="hljs-number"><span class="hljs-number">19</span></span> IRQ_TYPE_LEVEL_LOW&gt;; interrupt-parent = &lt;&amp;portb&gt;; }; }; intc: intc@fffed000 { compatible = <span class="hljs-string"><span class="hljs-string">"arm,cortex-a9-gic"</span></span>; #interrupt-cells = &lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;; interrupt-controller; }; portb: gpio-controller@<span class="hljs-number"><span class="hljs-number">0</span></span> { compatible = <span class="hljs-string"><span class="hljs-string">"snps,dw-apb-gpio-port"</span></span>; interrupt-controller; #interrupt-cells = &lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;; interrupts = &lt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">165</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>&gt;; interrupt-parent = &lt;&amp;intc&gt;; };</code> </pre><br>  (The nodes and properties that we are not interested in are cut out to facilitate understanding) <br><br>  <b>i2c0</b> , <b>keybs</b> , <b>inc</b> and <b>portb</b> are nodes, everything else is their properties.  From the code, it immediately becomes apparent that the keyboard controller chip is connected to the I2C bus.  The <b>compatible</b> property is a string that describes the manufacturer and model of the device.  It is for this property that the OS understands which driver needs to be associated with this device. <br><br>  <b>The interrupt-controller</b> is a property that indicates that this device can be an interrupt controller, and the <b>interrupt-parent</b> indicates who the interrupt is from the current device. <br><br>  <b># interrupt-cells</b> is a property that indicates the number of parameters that describe interrupts for this interrupt controller, and <b>interrupts</b> is a property in which parameters are set for this interrupt. <br><br>  For example, in <b>portb it is</b> indicated: # interrupt-cells = &lt;2&gt; This means that in nodes for which <b>portb</b> is an <b>interrupt-parent</b> in the <b>interrupts</b> property, two parameters need to be described.  <b>portb</b> is the <b>interrupt-parent</b> for <b>keybs</b> .  We look in <b>keybs</b> .  It says: interrupts = &lt;19 IRQ_TYPE_LEVEL_LOW&gt;.  What does it mean? <br><br>  Two parameters are described here.  The first is the pin number in the port <b>portb</b> , to which we have the interrupt line from the keyboard controller.  The second is an interrupt type (low or high).  How to find out how many parameters need to be described for the interrupt controller, and what each of them means?  Usually this is written in the documentation.  So, about <b>portb</b> is written in this file: <a href="http://lxr.free-electrons.com/source/Documentation/devicetree/bindings/gpio/snps-dwapb-gpio.txt">Documentation / devicetree / bindings / gpio / snps-dwapb-gpio.txt</a> . <br><br>  <b>&amp; portb</b> - link to the <b>portb</b> node (in our case, the link to the portb will be equal to / soc / gpio @ ff709000 / gpio-controller @ 0) <br>  The remaining properties will not be needed for us, about them, and in general about Device Tree, you can read in detail here: <a href="http://devicetree.org/Device_Tree_Usage">devicetree.org/Device_Tree_Usage</a> . <br><br>  It will not be superfluous to mention the process of registering devices and drivers (do not worry, we will return to the main topic in the next paragraph already).  According to the Linux Device Model: <br><br>  <b>A device</b> is a physical or virtual object that is connected to the bus (perhaps also virtual) <br>  <b>Driver</b> - a software object that can be associated with a device and can perform any control functions. <br>  <b>A tire</b> is a device designed to be the ‚Äúattachment point‚Äù of other devices.  The basic functionality of all buses supported by the kernel is determined by the <b>bus_type</b> structure.  In this structure, the subsys_private nested structure is declared, in which two lists are declared: <b>klist_devices</b> and <b>klist_drivers</b> . <br>  <b>klist_devices</b> - the list of devices that are connected to the bus. <br>  <b>klist_drivers</b> is a list of drivers that can manage devices on this bus. <br>  Devices and drivers are added to these lists using the <b>device_register</b> and <b>driver_register functions</b> .  In addition, <b>device_register</b> and <b>driver_register</b> bind the device with the appropriate driver.  <b>device_register</b> goes through the list of drivers and tries to find a driver suitable for this device.  ( <b>driver_register</b> passes through the list of devices and tries to find devices that it can control) Check whether the driver is suitable for the device using the <b>match</b> (dev, drv) function, the pointer to which is in the <b>bus_type</b> structure. <br><br><img src="https://habrastorage.org/files/844/788/321/8447883218db4fd492f02ebf03c08a7d.png"><br><br>  Now you can go to the main topic - the implementation of the mechanism of delayed loading of drivers.  Let's look at the file <u>drivers / base / dd.c.</u> Here is a brief description of what we see there: <br><br>  There are two lists for managing driver <b>reloading</b> - <b>deferred_probe_pending_list</b> and <b>deferred_probe_active_list</b> . <br><br>  <b>deferred_probe_pending_list</b> - a list of devices for which a driver is missing some resources. <br>  <b>deferred_probe_active_list</b> - a list of devices whose driver you can try to restart. <br><br>  In the function <b>really_probe</b> , the <b>probe</b> function is called for the bus on which the device is located.  In our case, this is the <b>i2c_device_probe</b> function and it looks like this: <b>dev-&gt; bus-&gt; probe (dev)</b> .  The return value is checked for errors, and if it is <b>-EPROBE_DEFER</b> , then the device is added to the <b>deferred_probe_pending_list</b> . <br><br>  But the most interesting is how and when the driver is called again.  While drivers return <b>-EPROBE_DEFER</b> , devices are sequentially added to <b>deferred_probe_pending_list</b> .  But as soon as the probe function has completed successfully for any driver, all devices from <b>deferred_probe_pending_list</b> are transferred to <b>deferred_probe_active_list</b> .  It looks logical - it is possible that the driver that we last had successfully loaded, and was not enough for the normal loading of deferred drivers.  A second attempt to launch drivers from <b>deferred_probe_active_list is</b> performed by the function <b>deferred_probe_work_func</b> .  It calls <b>bus_probe_device</b> for each device in the list. <br><br>  Calling <b>bus_probe_device</b> will eventually lead us again to the function <b>really_probe</b> for a pair of our device and its driver (see above). <br><br><img src="https://habrastorage.org/files/068/c68/09d/068c6809d00242b3b5dd21e4175dd76c.png"><br><br>  But wait!  We now talked about calling the probe function for the bus on which the device is located.  That is about <b>i2c_device_probe</b> .  But what about the probe function of the keyboard driver?  No, we have not forgotten about it, it will just be called from <b>i2c_device_probe</b> .  This can be seen by looking at its code in the file <u>drivers / i2c / i2c-core.c</u> : <br><br><div class="spoiler">  <b class="spoiler_title">I2c_device_probe code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i2c_device_probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct device *dev)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i2c_client</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i2c_verify_client</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i2c_driver</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">driver</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> status; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!client) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; driver = to_i2c_driver(dev-&gt;driver); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!driver-&gt;probe || !driver-&gt;id_table) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENODEV; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!device_can_wakeup(&amp;client-&gt;dev)) device_init_wakeup(&amp;client-&gt;dev, client-&gt;flags &amp; I2C_CLIENT_WAKE); dev_dbg(dev, <span class="hljs-string"><span class="hljs-string">"probe\n"</span></span>); status = of_clk_set_defaults(dev-&gt;of_node, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; status = dev_pm_domain_attach(&amp;client-&gt;dev, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (status != -EPROBE_DEFER) { <span class="hljs-comment"><span class="hljs-comment">//   probe   (  ) status = driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client)); if (status) dev_pm_domain_detach(&amp;client-&gt;dev, true); } return status; }</span></span></code> </pre><br></div></div><br>  Okay, reloading seems to work, why then does the keyboard driver not get interrupt numbers? <br>  Let's try to track how the interrupt number should get into our driver. <br><br>  The <b>adp5589_probe</b> function (struct i2c_client * client, const struct i2c_device_id * id) is passed to the <b>client</b> structure, one of whose fields ‚Äî <b>irq</b> ‚Äî is the interrupt number that our device (keyboard controller) will generate.  <b>adp5589_probe is</b> called from the function <b>i2c_device_probe</b> (struct device * dev).  The <b>device</b> structure is passed to it, from the pointer to which the pointer to the <b>i2c_client</b> structure is <b>calculated</b> (using the <s>magic of</s> <b>container_of</b> macro). <br><br><div class="spoiler">  <b class="spoiler_title">A few words about container_of</b> <div class="spoiler_text">  This macro takes as input a pointer to the structure field, the type of this structure and the name of the field to which the pointer points, and returns a pointer to the structure itself. <br><br><img src="https://habrastorage.org/files/b9c/8c6/227/b9c8c6227e4f4300b2ceb417272f0604.png"><br><br>  About his work is well painted <a href="http://radek.io/2012/11/10/magical-container_of-macro/">here</a> . <br></div></div><br>  So you need to find where the <b>i2c_client</b> structure is <b>filled</b> .  It is filled in the function <b>i2c_new_device</b> (struct i2c_adapter * adap, struct i2c_board_info const * info);  Specifically, the irq field is copied from the <b>i2c_board_info</b> structure field of the same name. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i2c_client</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">client</span></span></span><span class="hljs-class">;</span></span> client-&gt;irq = info-&gt;irq;</code> </pre><br>  The <b>i2c_board_info</b> structure <b>is</b> populated in the <b>of_i2c_register_devices</b> function (struct i2c_adapter * adap). <br><br><pre> <code class="cpp hljs">info.irq = irq_of_parse_and_map(node, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  <b>irq_of_parse_and_map</b> is a wrapper for a chain of two functions - <b>of_irq_parse_one</b> and <b>irq_create_of_mapping</b> ;  The function <b>of_irq_parse_one</b> tries to find the node that is declared in the device tree as an interrupt-controller for the current device. <br>  Remember these few lines in device tree? <br><br><pre> <code class="cpp hljs">expander: pca9535@<span class="hljs-number"><span class="hljs-number">20</span></span> { interrupt-parent = &lt;&amp;portb&gt;; };</code> </pre><br>  It is the <b>portb</b> that is looking for <b>of_irq_parse_one</b> , and, based on the results of its work, it fills the structure <b>of_phandle_args</b> , which is passed to the <b>irq_create_of_mapping</b> function.  <b>irq_create_of_mapping</b> already and returns the desired interrupt number. <br><br>  The first time <b>of_irq_parse_one</b> does not find the GPIO port, for which it swears in the log: <br><br>  irq: no irq domain found for / soc / gpio @ ff709000 / gpio-controller @ 0! <br><br>  What happens when the driver is reloaded?  And nothing.  Only <b>i2c_device_probe</b> and <b>adp5589_probe are called</b> . <br>  That's the problem.  The interrupt is set only for the first time and remains so forever, no matter how much we reload our driver. <br><br>  Found the problem, but how to fix it? <br><br>  You can try to transfer the code to receive the interrupt to <b>i2c_device_probe</b> .  Before that, we do not need an interrupt number anywhere, so there should be no problems. <br><br>  But better, let's take a look at the source code of a more recent version of the kernel (we have version 3.18 installed) Here‚Äôs what we will see there: <br>  The i2c client interrupt setting was transferred to the <b>i2c_device_probe</b> function. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!client-&gt;irq &amp;&amp; dev-&gt;of_node) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> irq = of_irq_get(dev-&gt;of_node, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq == -EPROBE_DEFER) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> irq; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) irq = <span class="hljs-number"><span class="hljs-number">0</span></span>; client-&gt;irq = irq; }</code> </pre><br>  Although the <b>irq</b> field remains in the <b>i2c_board_info structure,</b> it is not used.  So the problem has been fixed in new versions of the kernel. <br><br>  It remains only to transfer the changes to our version.  All changes will affect the file <u>drivers / i2c / i2c-core.c</u> <br>  Add the <b>i2c</b> client interrupt setting to our <b>i2c_device_probe</b> , which appeared in the latest version, and remove the interrupt setting in the <b>of_i2c_register_devices</b> function. <br><br><div class="spoiler">  <b class="spoiler_title">Changes in listing view from git diff</b> <div class="spoiler_text"><pre> <code class="cpp hljs">--- a/drivers/i2c/i2c-core.c +++ b/drivers/i2c/i2c-core.c @@ <span class="hljs-number"><span class="hljs-number">-626</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span> +<span class="hljs-number"><span class="hljs-number">626</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> @@ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i2c_device_probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct device *dev)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!client)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">return</span></span></span><span class="hljs-function"> 0</span></span>; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!client-&gt;irq &amp;&amp; dev-&gt;of_node) { + <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> irq = of_irq_get(dev-&gt;of_node, <span class="hljs-number"><span class="hljs-number">0</span></span>); + + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq == -EPROBE_DEFER) + <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> irq; + <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) + irq = <span class="hljs-number"><span class="hljs-number">0</span></span>; + + client-&gt;irq = irq; + } + driver = to_i2c_driver(dev-&gt;driver); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!driver-&gt;probe || !driver-&gt;id_table) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENODEV; @@ <span class="hljs-number"><span class="hljs-number">-1407</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span> +<span class="hljs-number"><span class="hljs-number">1418</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span> @@ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of_i2c_register_devices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct i2c_adapter *adap)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">continue</span></span></span></span>; } - info.irq = irq_of_parse_and_map(node, <span class="hljs-number"><span class="hljs-number">0</span></span>); + <span class="hljs-comment"><span class="hljs-comment">/* + * Now, we don't need to set interrupt here, because we set + * it in i2c_device_probe function + * info.irq = irq_of_parse_and_map(node, 0); + */</span></span> + info.of_node = of_node_get(node); info.archdata = &amp;dev_ad;</code> </pre><br></div></div><br>  Check - the keyboard works.  Look in / proc / interrupt: <br><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">'adp5589_keys'</span></span> /proc/interrupts 305: 2 - 20 adp5589_keys</code> </pre><br>  Click a few buttons: <br><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">'adp5589_keys'</span></span> /proc/interrupts 305: 6 - 20 adp5589_keys</code> </pre><br>  Problem solved. </div><p>Source: <a href="https://habr.com/ru/post/271983/">https://habr.com/ru/post/271983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271969/index.html">Lightweight Parser Designer with Interactive Mode</a></li>
<li><a href="../271971/index.html">Announcement of online courses Technopark, Technosphere and Technotrack on Stepic</a></li>
<li><a href="../271977/index.html">Recognition of the Burmese language: now we can even</a></li>
<li><a href="../271979/index.html">How did we do Linux-penguins for the New Year</a></li>
<li><a href="../271981/index.html">New malicious campaign Dridex led to a large number of infections in Europe</a></li>
<li><a href="../271985/index.html">Quarterly site security check</a></li>
<li><a href="../271987/index.html">IBM Bluemix Business Quest - Special Project for Application Developers</a></li>
<li><a href="../271989/index.html">Welcome to PGConf 2016 - Russian PostgreSQL conference</a></li>
<li><a href="../271991/index.html">Covering graphs in software testing, part 1</a></li>
<li><a href="../271993/index.html">Experimental version of PVS-Studio supporting C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>