<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Amazing country Oz, or how to accept data using send</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For a long time, collecting information on the means of parallel programming, I came across an elegant (in other words difficult to describe sensation...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Amazing country Oz, or how to accept data using send</h1><div class="post__text post__text-html js-mediator-article"> For a long time, collecting information on the means of parallel programming, I came across an elegant (in other words difficult to describe sensations) language Oz <a href="http://www.mozart-oz.org/">http://www.mozart-oz.org</a> .  The language then seemed to me worthy of introducing it to the Habra community.  And so, I had time and reasons to do it. <br><br>  Oz is a multi-paradigm programming language.  A set of basic abstractions in the language is unusual and allows, for example, to write the send procedure information so that with its help it will be possible to receive data as well.  And without any trick like: <br><br>  <code>send(socket; buffer; flag) = (if (flag == RECV) (recv(socket; buffer)) or (realsend(socket; buffer)))</code> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We are talking about the fact that sending and receiving data is carried out by the same sequence of operations of the virtual machine Oz.  Naturally, this is achieved through special abstractions for working with data and with parallel processes.  This text is devoted to the description of these abstractions, because in my opinion, they let you feel the characteristics of Oz quite well.  Of course, Oz is more than what is stated below, but, as it seems to me, the secret of the cunning send is the material suitable for the first acquaintance with this language and for receiving pleasure from it. <br><br><a name="habracut"></a><br><br><h6>  0. Introduction </h6><br><br>  You can start with the text of the program that implements the construction of the <code>Port</code> , through which data is transmitted using the send procedure.  This program also includes an example of using <code>Port</code> .  Source code (proper name in this text): <br><br><blockquote><pre> 
	 declare Port in <font></font>
	 <font></font>
	 local PortTag NewPort IsPort Send in 
		 PortTag = {NewName} <font></font>
	 <font></font>
		 fun {NewPort FS} 
			 local SC in 
				 C = {NewCell S} 
				 FS = !! S 
				 {NewChunk port (PortTag: C)} 
			 end 
		 end <font></font>
	 <font></font>
		 fun {IsPort? P} 
			 {Chunk.hasFeature P PortTag} 
		 end <font></font>
	 <font></font>
		 proc {Send PM} 
			 local Ms Mr in 
				 {Exchange P.PortTag Ms Mr} 
				 Ms = M |  !! Mr 
			 end 
		 end <font></font>
	 <font></font>
		 Port = port 
		 ( 
			 new: NewPort 
			 is: IsPort 
			 send: send 
		 ) 
	 end <font></font>
	 <font></font>
	 declare NewQueueServer in <font></font>
	 <font></font>
	 fun {NewQueueServer} 
		 local Given GivePort Taken TakePort Join in 
			 GivePort = {Port.new Given} 
			 TakePort = {Port.new Taken} <font></font>
	 <font></font>
			 proc {Join Xs Ys} 
				 local Xr Yr XY in 
					 Xs = X |  Xr 
					 Ys = Y |  Yr 
					 X = y 
					 {Join Xr Yr} 
				 end 
			 end <font></font>
	 <font></font>
			 thread {Join Given Taken} end <font></font>
		 <font></font>
			 queue 
			 ( 
				 put: proc {$ X} {Port.send GivePort X} end 
				 get: proc {$ X} {Port.send TakePort X} end 
			 ) 
		 end 
	 end <font></font>
	 <font></font>
	 declare Q in <font></font>
	 <font></font>
	 thread Q = {NewQueueServer} end <font></font>
	 <font></font>
	 {Q.put 1} 
	 {Browse {Q.get $}} 
	 {Browse {Q.get $}} 
	 {Q.put 2} 
</pre></blockquote><br><br>  As you can see, there is no trick.  Both queueserver functions ‚Äî <code>put</code> and <code>get</code> ‚Äî are implemented using the <code>Send</code> procedure, the semantics of which corresponds to its name.  This code could be shorter - Oz has enough syntactic sugar, which is not used above in order to reduce the amount of necessary explanations. <br><br>  To understand how this code works, you need to understand the (1) model of program execution in Oz: variables, threads, alignment operator ( <code>=</code> );  (2) procedures;  (3) cells (cells), memory areas (chunks) and future (futures). <br><br><h6>  1. Variables, threads, operator <code>=</code> </h6><br><br>  As mentioned, Oz is a multi-paradigm language.  In Wikipedia, it is described as functional, logical, imperative, object-oriented, distributed, parallel (in the sense of concurrent) and as a language for programming with constraints.  But it is based on another paradigm - dataflow programming.  Oz implements this paradigm close enough to the original (used in CPU architectures) concept of computing with data streams, and does it as follows. <br><br>  1.1.  All calculations in Oz occur with the data contained in the store.  The storage is a rather abstract thing (the internal mechanics are hidden from the programmer, and the information in the store can be managed only through a certain interface) and distributed (from the store, all participants of Oz-calculations can work, including scattered across the network).  Store can store information in three different types.  (1) In the form of free or related logical variables.  (2) In the form of cells (cells), which are, rather, not memory cells, but named variable pointers to variables.  (3) In the form of procedures that are named closures in Oz (naturally, they are first-order objects, that is, they can be explicitly manipulated in the program). <br><br>  1.2.  Calculation occurs when the thread (thread).  In this case, the thread in Oz - this is the dataflow.  That is, a certain sequence of statements (statements) executed one after another (all as in imperative languages), but with one reservation: the statement is executed only when all the variables used in it turn out to be related.  Otherwise, the thread pauses and waits for the moment of binding the desired variables.  Actually, the execution of a certain operator after the readiness of the data used in it is the main method of dateflow calculations. <br><br>  Threads are created in Oz very simply, using the <code>thread ... end</code> construct.  Creation of this occurs in the <code>fork()</code> style.  That is, the generated thread has access to all the variables (namely variables) that were available to the parent thread at the time of the <code>thread ... end</code> operation. <br><br>  1.3.  Variables in Oz are logical. <br><br>  A logical variable in the Oz style is a once-linked variable that can be equated with another variable. <br><br>  In general, this definition (translation from the manual) says little about variables in Oz.  They allow you to do a little more with yourself.  And they differ significantly from the usual variables in c / javascript / haskell, which are either named memory cells (c / js) or named values ‚Äã‚Äã(haskell).  Probably the best idea about the variables in Oz is a description of some technical details. <br><br>  1.3.1.  The life path of a variable in Oz begins with the fact that it is declared (introduce) with the help of constructions <code>local ... in ... end</code> or <code>declare ... in ...</code>  The differences between these constructions are that <code>local ...</code> allows declaring variables only for use in operations that are inside <code>in ... end</code> , and variables declared using <code>declare</code> will be available everywhere after the corresponding <code>in</code> .  Naturally, <code>declare</code> can be used to define variables only in the global scope of a module. <br><br>  The declaration of a variable is that a new node is created in the store (node) referenced by the declared variable.  And the value <code>unknown</code> written to the node, indicating that the variable is in no way associated with the data.  If a thread accesses such a variable, it will be suspended until the corresponding node is associated with the data.  For example (code-1): <br><br><blockquote><pre> 
	 local X in 
		 thread {Browse 2 * X} end 
		 X = 5 
	 end 
</pre></blockquote><br><br>  <code>Browse</code> is one of the standard Oz procedures that prints its argument.  When <code>X</code> declared in this example, a variable will be created and a new node in the store corresponding to it.  When <code>Browse</code> accesses this node through <code>X</code> , the execution of the corresponding thread will be suspended until the value appears in the corresponding <code>X</code> node (the value in the node itself and the variable binding to the node may change here). <br><br>  1.3.2.  The values ‚Äã‚Äãin the nodes are placed in the process of unification (unification) or (another name) incremental tell.  Unification for a pair of expressions is performed by the operator <code>=</code> (equality operator).  In the same process, the binding of variables to nodes may change.  The unification algorithm for a pair of expressions (specifically for expressions) in the code <code>E1 = E2</code> works like this (a recursive procedure with an analysis of the variants of what E1 and E2 can be). <br><br>  U.1.  The results of the calculations of E1 and E2 are the values ‚Äã‚Äãof the atomic types Oz (atomic types are indivisible types: integers, floating point numbers, literals - strings, for example).  In this case, if these values ‚Äã‚Äãare equal, the operator is executed, and if inequalities are generated, an exception is generated (exceptions in Oz are fairly standard and their processing is specified using the <code>try ... catch ... finally ... end</code> ; <code>finally</code> ; optionally). <br><br>  U.2.  The result of the calculation of <code>E1</code> is some variable, and the result of the calculation of <code>E2</code> is a value of some type (symmetric to this situation is the one in which the calculation of <code>E1</code> leads to a value of a certain type, and <code>E2</code> to a variable).  It can disappear like this: <br><br><blockquote><pre> 
	 X = (Y + Z) * ‚Äã‚Äã5 
</pre></blockquote><br><br>  In this case, everything works as follows. <br><br>  U.2.1.  The variable to be set by <code>E1</code> refers to unknown node.  If so, then the value obtained by the calculation of <code>E2</code> written to this node, as a result of which the <code>E1</code> variable is bound. <br><br>  U.2.2.  If the <code>E1</code> variable is already associated with an atomic value, then the value that is in the corresponding node is compared with the <code>E2</code> value, and if the types do not match or the values ‚Äã‚Äãthemselves, an exception is generated.  Otherwise, the statement ends. <br><br>  It is according to this rule that the variable <code>X</code> linked from code -1.  After it is associated with the value (5), the statement inside the called procedure <code>Browse</code> is executed, waiting for this binding.  And here it should be clear that the result would be exactly the same if code-1 looked like this: <br><br><blockquote><pre> 
	 local X in 
		 thread {Browse 2 * X} end 
		 5 = X 
	 end 
</pre></blockquote><br><br>  In U.2.  Another option is possible when the <code>E1</code> variable is associated with the value of a composite type, but it will be discussed later in paragraph U.4 ... <br><br>  U.3.  Both <code>E1</code> and <code>E2</code> define some variable.  Here, too, options are possible. <br><br>  U.3.1.  One of the variables is unbound, or both variables are unbound (that is, they refer to nodes with a value of unknown).  In this case, the node of one of the unrelated variables or the unknown-node of the only one that is not connected is discarded.  Then, the variable previously referenced to this node is modified so that it starts referring to the same node as the other variable. <br><br>  Here it should be clear why, by executing code-2: <br><br><blockquote><pre> 
	 local XYZ in 
		 thread {Browse X + Y + Z} end 
		 X = y 
	 % Z = X + YX = 10 
		 X + Y = Z 
	 end	 
</pre></blockquote><br><br>  Oz will give the value 40. And why does Oz "hang" if you remove the comment (starts with <code>%</code> ). <br><br>  U.3.2.  Both variables refer to nodes in which values ‚Äã‚Äãare written.  In this case, the behavior is as follows.  If these are values ‚Äã‚Äãof different types, or if they are different atomic values ‚Äã‚Äãof the same type, an exception will be generated.  If these are equal values ‚Äã‚Äãof some atomic type, then the operator will complete its execution.  But nodes can also store values ‚Äã‚Äãof composite types. <br><br>  The main composite type in Oz is record.  Syntactically, the entries look like this: <br><br><blockquote><pre> 
	 label (feature0: field0 feature2: field2 ... featureN: fieldN) 
</pre></blockquote><br><br>  Approximately, because the above is a closed record, with a fixed number of fields (field), and the records are also open.  Record fields can be accessed through a dot, by the name of the corresponding property (feature).  The number of fields in a structure is called its arity.  More specific example: <br><br><blockquote><pre> 
	 U = habrauser (nick: 'mikhanoid' karma: 10 strength: 10) 
	 K = U.karma 
</pre></blockquote><br><br>  Subtlety: the fields in the record type are themselves Oz variables.  In the example above, when creating a value with a record type and a habrauser tag, three variables are created that were unified according to the described algorithm with values ‚Äã‚Äãof atomic types: 'mikhanoid', 10 and 10. But instead of such values, the unification of variable fields can be performed with any expressions.  At this point, it should be clear how this code works: <br><br><blockquote><pre> 
	 local UKS in 
 (*) U = habrauser (nick: 'mikhanoid' karma: K strength: S) 
		 K = S 
		 10 = K 
	 end 
</pre></blockquote><br><br>  In line (*), the unlinked variable <code>U</code> unified with the value of the record type according to rule U.2.1. <br><br>  Oz records have an important role - they turn the store into a digraph structure: if a node has a value of record type, then with its variable fields it points to other nodes, that is, fields are something like arcs marked with property names.  And the described algorithm, thanks to clause U.4., Can be considered as a graph merge algorithm. <br><br>  U.4.  Here you can combine the following cases: (1) both expressions <code>E1</code> and <code>E2</code> are record type values, (2) both expressions define variables that refer to nodes in which records are stored, (3) one of <code>E1</code> , <code>E2</code> sets a record type value, and another - sets the variable associated with the node in which the record is stored.  In all these cases, if the records have (a) different labels, or (b) different arity, or different sets of properties, an exception is generated.  If the records coincide in points (a), (b) and ¬©, then unification of pairs of variables from different records with the same property names occurs. <br><br>  At this point, it should already be clear why as a result of the work of such code: <br><br><blockquote><pre> 
	 local WXYZ in 
		 W = XZ = Y 
		 f (a: 10 b: X) = f (a: Y b: 20) 
		 {Browse W + Z} 
	 end 
</pre></blockquote><br><br>  the value 30 will be displayed. <br><br>  Another interesting example is this code: <br><br><blockquote><pre> 
	 local Z in 
		 Z = f (Z 20) 
		 {Browse Z} 
	 end 
</pre></blockquote><br><br>  Here <code>f</code> is a variant of the record in which the field properties automatically get integer names from 1 to its arity.  In Oz, such records are called tuples and are analogs of compound expressions (compound term) in logic programming.  In the code above, the following happens.  (1) creates a value of type record with two fields, that is, two variables are created.  (2) the field with property <code>1</code> unified with the unbound variable Z, the second field with an atomic value of 20. In the end, the value of <code>f</code> points to the unknown-node pointed to by both the variable <code>Z</code> and the node storing the value 20. (3) to unknown -node to which <code>Z</code> points a value of type entry, the second element of which (like the variable Z) points to this node.  Nothing special, just get a cycle in the column store.  <code>Browse</code> prints it like this: <code>R10 = f(R10 20)</code> . <br><br>  Lists in Oz are a variety of tuples.  They are organized as standard for functional and logical programming: the list is a tuple, the first element is the head ‚Äî of which is variable, and the second is the list that constitutes the tail.  Mark the head at the tail of the list, you can use the symbol <code>|</code>  : <code>Head | Tail</code>  <code>Head | Tail</code> <br><br><h6>  2. Procedures </h6><br><br>  Oz allows you to abstract operator sequences using procedures.  Procedures in Oz are values ‚Äã‚Äã(first-class objects), so you can freely 'assign' them to variables.  In more detail.  Oz stores closures that implement procedures in the store in the form of some code.  Each such closure procedure gets a unique name for the entire store.  Names in Oz are literals - values ‚Äã‚Äãof atomic type.  After creating the procedure code and assigning a unique name to it, the name is written to the node referenced by some variable.  After that, the procedure can be called through this variable. <br><br>  That is why in the source code <code>NewPort</code> , <code>IsPort</code> , <code>Send</code> , ... are declared as variables using <code>local</code> or <code>declare</code> . <br><br>  The basic design defining the procedure is <code>proc</code> : <br><br><blockquote><pre> 
	 local ... P ... in 
		 ... 
		 proc {P X1 ... XN} S1 ... SM end 
		 ... 
	 end 
</pre></blockquote><br><br>  <code>X1</code> , ..., <code>XN</code> are formal arguments.  <code>S1</code> , ..., <code>SM</code> is a sequence of statements implementing the procedure.  Procedures are invoked using braces: <br><br><blockquote><pre> 
	 {P A1 ... AN} 
</pre></blockquote><br><br>  <code>A1</code> , ..., <code>AN</code> are valid parameters: expressions, variables, and so on.  The call occurs with the declaration of new variables corresponding to the formal parameters, which are unified with the arguments, among which may be unrelated variables.  Therefore, the procedure can both receive and return data through any parameter.  Therefore, to increase the readability of the code, variables that the programmer intends to use only for returning values ‚Äã‚Äãcan be marked with a prefix <code>?</code>  which is just a comment. <br><br>  A variable associated with a node that stores a procedure name can also be the result of evaluating an expression, like here, for example: <br><br><blockquote><pre> 
	 {Q.put 1} 
</pre></blockquote><br><br>  In Oz, it is possible to work with anonymous procedures, but it is implemented in an unusual way ‚Äî through the nesting mechanism.  In the sequence of operators enclosed in <code>{...}</code> one of the positions can be occupied by the <code>$</code> symbol - an attachment label.  When Oz encounters such labels inside curly brackets, executing some operator, it (1) automatically creates new variables, according to the number <code>{... $ ...}</code> , in the new local scope, then, in this scope (2) makes calls <code>{... $ ...}</code> , replacing the marker by substituting a new variable created for this call, and (3) inserts these variables into the <code>{... $ ...}</code> places in the executable statement.  for example <br><br><blockquote><pre> 
	 local P in 
		 proc {PX? Y} Y = X + 10 end 
		 {Browse {P 20 $} + {P 30 $} + 40} 
	 end 
</pre></blockquote><br><br>  will be executed as <br><br><blockquote><pre> 
	 local P in 
		 proc {PXY} Y = X + 10 end 
		 local X1 X2 in 
			 {P 20 X1} 
			 {P 30 X2} 
			 {Browse X1 + X2 + 40} 
		 end 
	 end 
</pre></blockquote><br><br>  The nesting tag can also be used in the first place inside <code>{...}</code> , but only during the procedure definition.  But the investment mechanism will work the same way.  Codes: <br><br><blockquote><pre> 
	 local P in 
		 local P1 in 
			 proc {P1 X1 ... XN} S1 ... SM end 
			 P = P1 
		 end 
	 end 
</pre></blockquote><br><br>  and <br><br><blockquote><pre> 
	 local P in 
		 P = proc {$ X1 ... XN} S1 ... SM end 
	 end	 
</pre></blockquote><br><br>  are equivalent. <br><br>  Oz functions are also procedures, and are a certain simplification of the syntax for those cases where it is known that the procedure should exactly return some value.  Then you can save on the description of one formal parameter, namely: <code>fun {F X1 ... XN} S1 ... SM end</code> the same as <code>proc {F X1 ... XN Y} S1 ... Y = SM end</code> .  Calling <code>{F A1 ... AN}</code> , as a function, Oz automatically turns into a procedure call <code>{F A1 ... AN $}</code> <br><br>  For example. <br><br><blockquote><pre> 
	 fun {FX} 
		 local K in 
			 K = X / 20 
			 {Browse K} 
		 end 
		 local L in 
			 L = 30 
			 X == L 
		 end 
	 end 
</pre></blockquote><br><br>  meets the definition <br><br><blockquote><pre> 
	 proc {FXY} 
		 local K in 
			 K = X / 20 
			 {Browse K} 
		 end <font></font>
		 <font></font>
		 Y = local L in 
			 L = 30 
			 X == L 
		 end 
	 end 
</pre></blockquote><br><br>  The value of the <code>local ... in ... end</code> block is the value of the last operator in it.  That is, in this example, <code>F</code> will be the result of its call to have the answer to the question: is the first and only argument of function 30 equal? <br><br><h6>  3. Cells (cell), memory areas (chunk) and future (future) </h6><br><br>  To work with data in store Oz supports a few more abstractions. <br><br>  3.1.  Memory areas are some entries in the store.  But unlike conventional recordings, they are identified using unique names (just like procedures) and do not allow arity to be detected.  That is, their components can be accessed only by the names of properties (feature).  If these names are hidden from some parts of the code, then in these areas, access to the elements of the corresponding memory area will be impossible.  Regions are created by calling the function <code>{NewChunk Record}</code> .  The call creates a memory region with a unique name, and returns this name.  The name can be written to the node referenced by some variable.  Then through this variable and the operator <code>.</code>  You can refer to the fields of the memory area: <br><br><blockquote><pre> 
	 local XR in 
		 R = f (a: 1 b: 2 c: 3) 
		 X = {NewChunk R} 
		 {Browse Xc} 
	 end 
</pre></blockquote><br><br>  3.2.  Cells in Oz are designed to work with states.  A cell, like procedures and memory areas, in a store is defined by some unique name.  Like a variable, it is a pointer to a certain node, but unlike a variable, nodes that a cell points to can be explicitly and repeatedly set.  The cell identifies the next interface. <br><br> <code>C = {NewCell E}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- creates a cell pointing to the node that will result from the unification of the value of the expression </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the variable - the formal argument of the procedure </font></font><code>NewCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The new unique name of the newly created cell is returned and assigned to the variable </font></font><code>C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The link to the node from the cell, of course, is taken into account when garbage collection. </font></font><code>{IsCell C}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">answers the question: is the variable associated </font></font><code>C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the cell name? </font></font><br><br> <code>@C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- this expression has the result of its own variable, pointing to the node on which the cell with the name stored in the variable refers </font></font><code>C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>C := E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes the pointer in the cell whose name is stored in </font></font><code>C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so that it points to the node obtained as a result of the unifications of some unrelated nameless variable and the result of the expression </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br> <code>{Exchange C E1 E2}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- for one inseparable, atomic operation unifies </font></font><code>@C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>E1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and, then, performs </font></font><code>C := E2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A cell, for example, can be used as a counter:</font></font><br><br><blockquote><pre> <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	local C in </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		C = {NewCell 0} </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		{Exchange CX thread X + 1 end} </font></font><font></font>
	 end 
</pre></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can not be excluded </font></font><code>thread ... end</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And it works for the reason that for each running thread, Oz automatically creates an unbound variable that is unified with the last of the thread body operators. </font><font style="vertical-align: inherit;">And this variable in this example is the last argument </font></font><code>Exchange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  3.3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The future was first proposed in Smalltalk-72, and then the idea of ‚Äã‚Äãusing them was developed in MultiLISP (1985). Future fairly common tool: they are in Java, accessible via </font></font><code>java.util.cuncurrent.Future</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; their support is scheduled in C ++ 0x. They are supported in Oz, but in an unusual form. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The future for some expression </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is an object associated with asynchronous computing </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The future allows you to perform some operations with a result that </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is </font><font style="vertical-align: inherit;">not yet computed </font><font style="vertical-align: inherit;">‚Äî for example, use it in function calls, write to lists, transfer to other asynchronous calculations, and so on. In the case when the continuation of work requires exactly the value of the expression </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the reference to its future will suspend execution until the moment when it </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is calculated.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Oz, ordinary variables have a similar property: some actions with them can be performed without waiting for the values ‚Äã‚Äãto appear in the nodes to which they refer. </font><font style="vertical-align: inherit;">Many of the examples already given illustrate this. </font><font style="vertical-align: inherit;">However, variables in Oz are bidirectional information exchange channels: those to the left and right of the </font></font><code>=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expression are symmetrical for the unification algorithm. </font><font style="vertical-align: inherit;">Therefore, in the code:</font></font><br><br><blockquote><pre> <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	local X in </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		thread X = 5 end </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		thread X = 7 end </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		X = 3 </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		{Browse X} </font></font><font></font>
	 end 
</pre></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">none of the strings stands out as producing data. </font><font style="vertical-align: inherit;">An exception in the process of unification can cause any thread. </font><font style="vertical-align: inherit;">The future allows to establish some order in this situation. </font><font style="vertical-align: inherit;">In Oz, the future is a read-only link to a node, that is, a somewhat limited version of the variable. </font><font style="vertical-align: inherit;">If the future is involved in the process of unification, then this process is suspended until the corresponding future variable is bound. </font><font style="vertical-align: inherit;">The future for the variable </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Oz is formed by the operator </font></font><code>!!X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The order in the example above can be made, for example, as follows:</font></font><br><br><blockquote><pre> <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	local XY in </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		Y = !! X </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		thread Y = 5 end </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		thread X = 7 end </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		Y = 3 </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
		{Browse Y} </font></font><font></font>
	 end 
</pre></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> here the value will always be formed only in the second thread. </font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. All together </font></font></h6><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is convenient to bring the code from the introduction again so that you do not need to scroll through this text to the beginning: </font></font><br><br><blockquote><pre> <font></font>
00 declare Port in <font></font>
 01	 <font></font>
02 local PortTag NewPort IsPort Send in <font></font>
03 PortTag = {NewName} <font></font>
 04	 <font></font>
05 fun {NewPort FS} <font></font>
06 local SC in <font></font>
07 C = {NewCell S} <font></font>
08 FS = !!S <font></font>
09 {NewChunk port(PortTag: C)} <font></font>
10 end <font></font>
11 end <font></font>
 12	 <font></font>
13 fun {IsPort ?P} <font></font>
14 {Chunk.hasFeature P PortTag} <font></font>
15 end <font></font>
 sixteen	 <font></font>
17 proc {Send PM} <font></font>
18 local Ms Mr in <font></font>
19 {Exchange P.PortTag Ms Mr} <font></font>
20 Ms = M | !!Mr <font></font>
21 end <font></font>
22 end <font></font>
 23	 <font></font>
24 Port = port <font></font>
25 ( <font></font>
26 new: NewPort <font></font>
27 is: IsPort <font></font>
28 send: Send <font></font>
29 ) <font></font>
30 end <font></font>
 31	 <font></font>
32 declare NewQueueServer in <font></font>
 33	 <font></font>
34 fun {NewQueueServer} <font></font>
35 local Given GivePort Taken TakePort Join in <font></font>
36 GivePort = {Port.new Given} <font></font>
37 TakePort = {Port.new Taken} <font></font>
 38	 <font></font>
39 proc {Join Xs Ys} <font></font>
40 local Xr Yr XY in <font></font>
41 Xs = X | Xr <font></font>
42 Ys = Y | Yr <font></font>
43 X = Y <font></font>
44 {Join Xr Yr} <font></font>
45 end <font></font>
46 end <font></font>
 47	 <font></font>
48 thread {Join Given Taken} end <font></font>
 49		 <font></font>
50 queue <font></font>
51 ( <font></font>
52 put: proc {$ X} {Port.send GivePort X} end <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
53 get: proc {$ X} {Port.send TakePort X} end </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
54) </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
55 end </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
56 end </font></font><font></font>
 57	 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
58 declare Q in </font></font><font></font>
 59	 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
60 thread Q = {NewQueueServer} end </font></font><font></font>
 61	 <font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
62 {Q.put 1} </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
63 {Browse {Q.get $}} </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
64 {Browse {Q.get $}} </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
65 {Q.put 2} </font></font><font></font>
</pre></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It makes no sense to describe the entire program line by line (which rarely gives an idea of ‚Äã‚Äãthe work of even non-parallel programs), but you need to clarify a few points. </font></font><br><br>  4.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creation </font></font><code>Port</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <code>Port</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a record, the fields are associated with a set of procedures. This is nothing more than a convenient grouping of several procedures. The port itself is a memory area containing a cell under the name, whose uniqueness is guaranteed by the function </font></font><code>NewName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The variable </font></font><code>PortName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is visible only in the local unit (02-30), so access to the components of the memory area can only be obtained from the procedures </font></font><code>IsPort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NewPort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Outside this block, </font></font><code>PortName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nothing is known </font><font style="vertical-align: inherit;">about the variable </font><font style="vertical-align: inherit;">, so access to the field of memory that stores the port state is unlikely (of course, the name can be guessed, but to encapsulate such a mechanism is quite enough). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attention must be paid to the function</font></font><code>NewPort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(05-11). In addition to returning the memory area of ‚Äã‚Äãthe port itself, the argument returns, through its first argument, the future of the variable that initializes the cell. This is used to initialize </font></font><code>Given</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Taken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(36-37).</font></font><br><br>  4.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedure </font></font><code>Send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(17-22). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be noted that the memory cell of the port always points to an unknown node. And </font></font><code>Send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the next call, first of all, it guarantees that by linking to the previous node in a variable </font></font><code>Ms</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and in its place by placing a link to the node in an unbound variable </font></font><code>Mr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Further, </font></font><code>Send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the value of the variable is formed </font></font><code>Ms</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is obtained in the course of unification with a list tuple, in which the sent message is in the first place (which may be unrelated), and the future in the second </font></font><code>Mr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(again: the list is just a tuple, in the second place which can stand anything). A subsequent call </font></font><code>Send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will do the same with the variable.</font></font><code>Mr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and this process will gradually turn the variable that was used to initialize the cell to </font></font><code>NewPort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the future of which was returned to the outside, into a list. In other words, it </font></font><code>Send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">really sends messages to some queue.</font></font><br><br>  4.3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedure </font></font><code>Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(39-46). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most important thing here is what this procedure applies to, working in a separate thread (48). It applies to </font></font><code>Given</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Taken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which as a result of calls </font></font><code>Send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gradually turn into lists. Actual parameters </font></font><code>Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are always future, therefore the unification operators (41-42) are executed only after linking </font></font><code>Xs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Ys</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that occurs in </font></font><code>Send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, turning these variables into references to tuples of the form </font></font><code>Message | SomeFuture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. After that, the </font></font><code>Message</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">components of the incoming ( </font></font><code>Given</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and outgoing ( </font></font><code>Taken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) streams are unified, and</font></font><code>Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> called for future tails of lists (A bit like quantum mechanics, is it not? Maybe Einstein did not have enough knowledge of parallel programming to build a model of the Universe with hidden variables). </font></font><br><br>  4.4.  Eventually. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any </font><font style="vertical-align: inherit;">bounded variable </font><font style="vertical-align: inherit;">exposed to a stream </font></font><code>Given</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the help of a </font></font><code>Send</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread will be unified in the thread (48) with the corresponding unbound variable exposed to the stream </font></font><code>Taken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Of course, the situation is completely symmetrical, and the names </font></font><code>put</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are used for convenience. </font><font style="vertical-align: inherit;">But queueserver is still asynchronous, which is useful.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Other interesting features of Oz </font></font></h6><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oz offers among its other features (and many of them are extensive), offers also an interesting model of parallel programming. </font><font style="vertical-align: inherit;">Which differs from the classical one adopted in Prolog, for example, in that it allows the programmer to define his own search and iterate search procedures. </font><font style="vertical-align: inherit;">And, of course, the logical programming model adopted in Oz is parallel.</font></font></div><p>Source: <a href="https://habr.com/ru/post/63715/">https://habr.com/ru/post/63715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../63708/index.html">Firesocks</a></li>
<li><a href="../63709/index.html">SMS cost for short numbers</a></li>
<li><a href="../63710/index.html">Tale of AI</a></li>
<li><a href="../63711/index.html">Newly Labels</a></li>
<li><a href="../63713/index.html">Commodore C286-LT '90 Notebook</a></li>
<li><a href="../63722/index.html">Is FGHI a lifelong business?</a></li>
<li><a href="../63724/index.html">What I like about Redmine</a></li>
<li><a href="../63725/index.html">Another time eater</a></li>
<li><a href="../63726/index.html">Hosting php 5.3</a></li>
<li><a href="../63727/index.html">Yeah! Buy DNA Upgrade at 50% discount!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>