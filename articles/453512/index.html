<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Style transfer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Style transfer is the process of transforming the style of the source to the style of the selected image and relies on the convolutional network type ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Style transfer</h1><div class="post__text post__text-html js-mediator-article">  Style transfer is the process of transforming the style of the source to the style of the selected image and relies on the convolutional network type (CNN), which has been previously trained, so much will depend on the choice of this trained network.  The benefit of such networks is and there are plenty to choose from, but VGG-16 will be used here. <br><br>  First you need to connect the necessary libraries <br><br><div class="spoiler">  <b class="spoiler_title">Library declaration code</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> torch <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> torch.autograd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Variable <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> torch.nn <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> nn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> torch.nn.functional <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> torch <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> optim <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> torchvision <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> torchvision <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> transforms <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> io <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BytesIO <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> OrderedDict <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> google.colab <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> files</code> </pre> </div></div><a name="habracut"></a><br>  Then you must declare the class of the pre-trained network VGG-16 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Class Code VGG-16</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VGG16</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(nn.Module)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, pool=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'max'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> super(VGG, self).__init__() self.conv1_1 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv1_2 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv2_1 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv2_2 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv3_1 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv3_2 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv3_3 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv3_4 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv4_1 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv4_2 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv4_3 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv4_4 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv5_1 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv5_2 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv5_3 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.conv5_4 = nn.Conv2d(<span class="hljs-number"><span class="hljs-number">512</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>, kernel_size=<span class="hljs-number"><span class="hljs-number">3</span></span>, padding=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pool == <span class="hljs-string"><span class="hljs-string">'max'</span></span>: self.pool1 = nn.MaxPool2d(kernel_size=<span class="hljs-number"><span class="hljs-number">2</span></span>, stride=<span class="hljs-number"><span class="hljs-number">2</span></span>) self.pool2 = nn.MaxPool2d(kernel_size=<span class="hljs-number"><span class="hljs-number">2</span></span>, stride=<span class="hljs-number"><span class="hljs-number">2</span></span>) self.pool3 = nn.MaxPool2d(kernel_size=<span class="hljs-number"><span class="hljs-number">2</span></span>, stride=<span class="hljs-number"><span class="hljs-number">2</span></span>) self.pool4 = nn.MaxPool2d(kernel_size=<span class="hljs-number"><span class="hljs-number">2</span></span>, stride=<span class="hljs-number"><span class="hljs-number">2</span></span>) self.pool5 = nn.MaxPool2d(kernel_size=<span class="hljs-number"><span class="hljs-number">2</span></span>, stride=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> pool == <span class="hljs-string"><span class="hljs-string">'avg'</span></span>: self.pool1 = nn.AvgPool2d(kernel_size=<span class="hljs-number"><span class="hljs-number">2</span></span>, stride=<span class="hljs-number"><span class="hljs-number">2</span></span>) self.pool2 = nn.AvgPool2d(kernel_size=<span class="hljs-number"><span class="hljs-number">2</span></span>, stride=<span class="hljs-number"><span class="hljs-number">2</span></span>) self.pool3 = nn.AvgPool2d(kernel_size=<span class="hljs-number"><span class="hljs-number">2</span></span>, stride=<span class="hljs-number"><span class="hljs-number">2</span></span>) self.pool4 = nn.AvgPool2d(kernel_size=<span class="hljs-number"><span class="hljs-number">2</span></span>, stride=<span class="hljs-number"><span class="hljs-number">2</span></span>) self.pool5 = nn.AvgPool2d(kernel_size=<span class="hljs-number"><span class="hljs-number">2</span></span>, stride=<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, layers)</span></span></span><span class="hljs-function">:</span></span> out = {} out[<span class="hljs-string"><span class="hljs-string">'relu1_1'</span></span>] = F.relu(self.conv1_1(x)) out[<span class="hljs-string"><span class="hljs-string">'relu1_2'</span></span>] = F.relu(self.conv1_2(out[<span class="hljs-string"><span class="hljs-string">'relu1_1'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'pool1'</span></span>] = self.pool1(out[<span class="hljs-string"><span class="hljs-string">'relu1_2'</span></span>]) out[<span class="hljs-string"><span class="hljs-string">'relu2_1'</span></span>] = F.relu(self.conv2_1(out[<span class="hljs-string"><span class="hljs-string">'pool1'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'relu2_2'</span></span>] = F.relu(self.conv2_2(out[<span class="hljs-string"><span class="hljs-string">'relu2_1'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'pool2'</span></span>] = self.pool2(out[<span class="hljs-string"><span class="hljs-string">'relu2_2'</span></span>]) out[<span class="hljs-string"><span class="hljs-string">'relu3_1'</span></span>] = F.relu(self.conv3_1(out[<span class="hljs-string"><span class="hljs-string">'pool2'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'relu3_2'</span></span>] = F.relu(self.conv3_2(out[<span class="hljs-string"><span class="hljs-string">'relu3_1'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'relu3_3'</span></span>] = F.relu(self.conv3_3(out[<span class="hljs-string"><span class="hljs-string">'relu3_2'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'relu3_4'</span></span>] = F.relu(self.conv3_4(out[<span class="hljs-string"><span class="hljs-string">'relu3_3'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'pool3'</span></span>] = self.pool3(out[<span class="hljs-string"><span class="hljs-string">'relu3_4'</span></span>]) out[<span class="hljs-string"><span class="hljs-string">'relu4_1'</span></span>] = F.relu(self.conv4_1(out[<span class="hljs-string"><span class="hljs-string">'pool3'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'relu4_2'</span></span>] = F.relu(self.conv4_2(out[<span class="hljs-string"><span class="hljs-string">'relu4_1'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'relu4_3'</span></span>] = F.relu(self.conv4_3(out[<span class="hljs-string"><span class="hljs-string">'relu4_2'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'relu4_4'</span></span>] = F.relu(self.conv4_4(out[<span class="hljs-string"><span class="hljs-string">'relu4_3'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'pool4'</span></span>] = self.pool4(out[<span class="hljs-string"><span class="hljs-string">'relu4_4'</span></span>]) out[<span class="hljs-string"><span class="hljs-string">'relu5_1'</span></span>] = F.relu(self.conv5_1(out[<span class="hljs-string"><span class="hljs-string">'pool4'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'relu5_2'</span></span>] = F.relu(self.conv5_2(out[<span class="hljs-string"><span class="hljs-string">'relu5_1'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'relu5_3'</span></span>] = F.relu(self.conv5_3(out[<span class="hljs-string"><span class="hljs-string">'relu5_2'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'relu5_4'</span></span>] = F.relu(self.conv5_4(out[<span class="hljs-string"><span class="hljs-string">'relu5_3'</span></span>])) out[<span class="hljs-string"><span class="hljs-string">'pool5'</span></span>] = self.pool5(out[<span class="hljs-string"><span class="hljs-string">'relu5_4'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [out[key] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> layers]</code> </pre><br></div></div><br>  Next, you need to download and upload the VGG-16 weights, first transferring it to the video card, if there is such an opportunity. <br><br><pre> <code class="python hljs">vgg = VGG16() vgg.load_state_dict(torch.load(<span class="hljs-string"><span class="hljs-string">'vgg_conv.pth'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vgg.parameters(): param.requires_grad = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> torch.cuda.is_available(): vgg.cuda()</code> </pre><br>  Where vgg_conv.pth is the name of the file with network weights. <br><br>  At the same time, it is necessary to disable the training of parameters from the network; otherwise, it is possible to spoil the loaded weights that have been trained for several days. <br><br>  After that, the functions of transforming input images are announced to bring them to the form of images on which they studied the VGG-16 network. <br><br><div class="spoiler">  <b class="spoiler_title">Input image conversion function code</b> <div class="spoiler_text"><pre> <code class="python hljs">SIZE_IMAGE = <span class="hljs-number"><span class="hljs-number">512</span></span> to_mean_tensor = transforms.Compose([transforms.Resize(SIZE_IMAGE), transforms.ToTensor(), transforms.Lambda(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[torch.LongTensor([<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>])]), transforms.Normalize(mean=[<span class="hljs-number"><span class="hljs-number">0.40760392</span></span>, <span class="hljs-number"><span class="hljs-number">0.45795686</span></span>, <span class="hljs-number"><span class="hljs-number">0.48501961</span></span>], std=[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]), transforms.Lambda(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.mul_(<span class="hljs-number"><span class="hljs-number">255</span></span>)), ]) to_unmean_tensor = transforms.Compose([transforms.Lambda(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x.div_(<span class="hljs-number"><span class="hljs-number">255</span></span>)), transforms.Normalize(mean=[<span class="hljs-number"><span class="hljs-number">-0.40760392</span></span>, <span class="hljs-number"><span class="hljs-number">-0.45795686</span></span>, <span class="hljs-number"><span class="hljs-number">-0.48501961</span></span>], std=[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]), transforms.Lambda(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[torch.LongTensor([<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>])]), ]) to_image = transforms.Compose([transforms.ToPILImage()]) normalize_image = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> t: to_image(torch.clamp(to_unmean_tensor(t), min=<span class="hljs-number"><span class="hljs-number">0</span></span>, max=<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre><br>  to_mean_tensor - direct conversion <br>  normalize_image - inverse transform <br></div></div><br>  Next, the Gram matrix classes and loss functions for the Gram matrix are declared. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GramMatrix</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(nn.Module)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, input)</span></span></span><span class="hljs-function">:</span></span> b,c,h,w = input.size() F = input.view(b, c, h*w) G = torch.bmm(F, F.transpose(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)) G.div_(h*w) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> G <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GramMSELoss</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(nn.Module)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, input, target)</span></span></span><span class="hljs-function">:</span></span> out = nn.MSELoss()(GramMatrix()(input), target) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out</code> </pre><br>  The Gram matrix is ‚Äã‚Äãused to eliminate the spatial reference of the details of the style. <br><br>  Then comes the process of loading and converting source and style images. <br><br><pre> <code class="python hljs">imgs = [style_img, content_img] imgs_torch = [to_mean_tensor(img) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> img <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> imgs] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> torch.cuda.is_available(): imgs_torch = [Variable(img.unsqueeze(<span class="hljs-number"><span class="hljs-number">0</span></span>).cuda()) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> img <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> imgs_torch] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: imgs_torch = [Variable(img.unsqueeze(<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> img <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> imgs_torch] style_image, content_image = imgs_torch opt_img = Variable(content_image.data.clone(), requires_grad=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre><br>  Where style_img and content_img are input images that are converted to tensors and transferred to the video card, if possible, and the result of style transfer will be contained in opt_img, while the initial image is taken as the initial image. <br><br>  Next comes the process of selecting layers, setting weights and initializing loss functions. <br><br><div class="spoiler">  <b class="spoiler_title">Code of weights and losses</b> <div class="spoiler_text"><pre> <code class="python hljs">style_layers = [<span class="hljs-string"><span class="hljs-string">'relu1_1'</span></span>,<span class="hljs-string"><span class="hljs-string">'relu2_1'</span></span>,<span class="hljs-string"><span class="hljs-string">'relu3_1'</span></span>,<span class="hljs-string"><span class="hljs-string">'relu4_1'</span></span>, <span class="hljs-string"><span class="hljs-string">'relu5_1'</span></span>] content_layers = [<span class="hljs-string"><span class="hljs-string">'relu4_2'</span></span>] loss_layers = style_layers + content_layers losses = [GramMSELoss()] * len(style_layers) + [nn.MSELoss()] * len(content_layers) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> torch.cuda.is_available(): losses = [loss.cuda() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> loss <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> losses] style_weights = [<span class="hljs-number"><span class="hljs-number">1e3</span></span>/n**<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> [<span class="hljs-number"><span class="hljs-number">64</span></span>,<span class="hljs-number"><span class="hljs-number">128</span></span>,<span class="hljs-number"><span class="hljs-number">256</span></span>,<span class="hljs-number"><span class="hljs-number">512</span></span>,<span class="hljs-number"><span class="hljs-number">512</span></span>]] content_weights = [<span class="hljs-number"><span class="hljs-number">1e0</span></span>] weights = style_weights + content_weights style_targets = [GramMatrix()(A).detach() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vgg(style_image, style_layers)] content_targets = [A.detach() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vgg(content_image, content_layers)] targets = style_targets + content_targets</code> </pre><br></div></div><br>  And the last stage is the process of transferring the style. <br><pre> <code class="python hljs">epochs = <span class="hljs-number"><span class="hljs-number">300</span></span> opt = optim.LBFGS([opt_img]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step_opt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> opt.zero_grad() out_layers = vgg(opt_img, loss_layers) layer_losses = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j, out <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(out_layers): layer_losses.append(weights[j] * losses[j](out, targets[j])) loss = sum(layer_losses) loss.backward() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loss <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, epochs+<span class="hljs-number"><span class="hljs-number">1</span></span>): loss = opt.step(step_opt)</code> </pre><br>  In conclusion, you can add a few examples: <br><br><img src="https://habrastorage.org/webt/ro/ns/ck/ronsckc23un8x17sqpk7fi9sudk.png"><br><br><img src="https://habrastorage.org/webt/ym/mc/tz/ymmctzlpipd4we5nlwb1h9aapnw.png"><br><br><img src="https://habrastorage.org/webt/dj/e2/b5/dje2b5bojm_lu0emauyx0t58x5m.png"><br><br><img src="https://habrastorage.org/webt/hv/pt/hg/hvpthgkls5r3vjxw0jh3p3h_zdg.png"><br><br><img src="https://habrastorage.org/webt/ym/mc/tz/ymmctzlpipd4we5nlwb1h9aapnw.png"><br><br><img src="https://habrastorage.org/webt/lc/p3/_l/lcp3_lvv4ydjbvvnihydc1zfuka.png"></div><p>Source: <a href="https://habr.com/ru/post/453512/">https://habr.com/ru/post/453512/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453496/index.html">Happy chemist, colleagues</a></li>
<li><a href="../4535/index.html">LinkedIn Launches Service Providers Directory</a></li>
<li><a href="../453502/index.html">My rake: from rags to riches</a></li>
<li><a href="../453508/index.html">Man without a smartphone</a></li>
<li><a href="../453510/index.html">All Your Own: Tutorial on Creating New Actions for UiPath RPA</a></li>
<li><a href="../453514/index.html">Introductory Offers Guide for iOS</a></li>
<li><a href="../453520/index.html">Accelerate Ansible with Mitogen</a></li>
<li><a href="../453522/index.html">Happy Birthday, Habr ‚ù§</a></li>
<li><a href="../453524/index.html">The digest of interesting materials for the mobile # 299 developer (May 20 - 26)</a></li>
<li><a href="../453526/index.html">ITSM - what is it and where to start implementation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>