<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a game on Lua and L√ñVE - 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 


- Article 1 Part 1. Game cycle Part 2. Libraries Part 3. Rooms and areas Part 4. Exercises 
- Part 1. Game cycle 
- Part 2. Libra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a game on Lua and L√ñVE - 4</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/625/305/a37/625305a37f81962551aed8611bab6bda.jpg" alt="image"></div><br><h2>  Table of contents </h2><br><ul><li>  <a href="https://habrahabr.ru/post/349276/">Article 1</a> <ul><li>  Part 1. Game cycle </li><li>  Part 2. Libraries </li><li>  Part 3. Rooms and areas </li><li>  Part 4. Exercises </li></ul></li><li>  <a href="https://habrahabr.ru/post/349440/">Article 2</a> <ul><li>  Part 5. Basics of the game </li><li>  Part 6. Basics of the Player Class </li></ul></li><li>  <a href="https://habrahabr.ru/post/349718/">Article 3</a> <ul><li>  Part 7. Player Parameters and Attacks </li><li>  Part 8. Enemies </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 4</a> <ul><li>  Part 9. Director and game cycle </li><li>  Part 10. Code Writing Practices </li><li>  Part 11. Passive skills </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 5</a> <ul><li>  Part 12. Other Passive Skills </li></ul></li></ul><br>  13. Skill Tree <br><br>  14. Console <br><br>  15. Final <br><a name="habracut"></a><br><h2>  Part 9: Director and Game Cycle </h2><br><h2>  Introduction </h2><br>  In this part we will complete the implementation of the basics of the whole game with a minimum amount of content.  We will study the director (Director) - the code that will manage the creation of enemies and resources.  Then we will consider restarting the game after the player dies.  And after that we will deal with a simple points system, as well as a basic UI, so that the player can know about his performance. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Producer </h2><br>  Director (Director) is a piece of code that controls the creation of enemies, attacks and resources in the game.  The goal of the game is to survive as long as possible and score as many points as possible.  The difficulty of the game is determined by the ever-increasing number and complexity of the enemies created.  This complexity will be fully controlled by the code that we will now begin to write. <br><br>  The rules that the director will follow are fairly simple: <br><br><ol><li>  Every 22 seconds the difficulty increases; </li><li>  The duration of each difficulty of creating enemies will be based on the points system: <br><ul><li>  Each difficulty (or round) has a certain amount of points that can be used; </li><li>  Enemies are worth some constant amount of points (the harder the enemy, the more expensive it is); </li><li>  The higher the level of difficulty, the more points the director has; </li><li>  Enemies are randomly selected to build for the duration of the round, until the director runs out of glasses. </li></ul></li><li>  Every 16 seconds a resource is created (HP, SP or Boost); </li><li>  Every 30 seconds an attack is created. </li></ol><br>  We'll start by creating a <code>Director</code> object, which will be a regular object (not one that inherits from a GameObject, but that used in the Area).  In it we put our code: <br><br><pre> <code class="lua hljs">Director = Object:extend() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stage)</span></span></span></span> self.stage = stage <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  We can create an object and create an instance of it in the Stage room as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.director = Director(self) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> self.director:update(dt) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  We want the Director object to have a link to the Stage room, since we need to create enemies and resources, and the only way to do this is to use <code>stage.area</code> .  The director will also need access to the time, so he needs the appropriate update. <br><br>  We will begin with rule 1, define the simple attribute <code>difficulty</code> and a few auxiliary ones to control the time for increasing this attribute.  This temporary change code will be the same as that used in the acceleration or cycle mechanisms of the Player. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.difficulty = <span class="hljs-number"><span class="hljs-number">1</span></span> self.round_duration = <span class="hljs-number"><span class="hljs-number">22</span></span> self.round_timer = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> self.round_timer = self.round_timer + dt <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.round_timer &gt; self.round_duration <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.round_timer = <span class="hljs-number"><span class="hljs-number">0</span></span> self.difficulty = self.difficulty + <span class="hljs-number"><span class="hljs-number">1</span></span> self:setEnemySpawnsForThisRound() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Thus, the <code>difficulty</code> increases every 22 seconds in accordance with rule 1. We can also call the <code>setEnemySpawnsForThisRound</code> function, which will execute rule 2. <br><br>  The first part of rule 2 is that each difficulty has a certain amount of points that can be spent.  The first thing we need is to determine how many levels of complexity we want to do in the game and how we will set these points: manually or through some kind of formula.  I decided to choose the second option so that the game was endless and it became more and more difficult until the player could cope with it anymore.  I decided that the game would have 1024 levels of difficulty, because this is a fairly large number that someone is unlikely to achieve. <br><br>  The number of points assigned to each difficulty will be determined by a simple formula, which I arrived at through trial and error.  Again, these things are more related to the design of the game, so I will not waste time explaining my decisions.  You can try your own ideas if you think you can do better. <br><br>  Scoring will be performed according to the following formula: <br><br><ul><li>  On difficulty 1 there are 16 points; </li><li>  Starting from complexity 2, the following four-stage formula is applied: <br><ul><li>  Difficulty <em>i</em> has a sum of difficulty points <em>i-1</em> + 8 </li><li>  Difficulty <em>i + 1</em> has a sum of difficulty points <em>i</em> </li><li>  The difficulty of <em>i + 2</em> has a sum of difficulty points <em>(i + 1) /1.5</em> </li><li>  Difficulty <em>i + 3</em> has a sum of difficulty points <em>(i + 2) * 2</em> </li></ul></li></ul><br>  In code, it looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.difficulty_to_points = {} self.difficulty_to_points[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> self.difficulty_to_points[i] = self.difficulty_to_points[i<span class="hljs-number"><span class="hljs-number">-1</span></span>] + <span class="hljs-number"><span class="hljs-number">8</span></span> self.difficulty_to_points[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = self.difficulty_to_points[i] self.difficulty_to_points[i+<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(self.difficulty_to_points[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]/<span class="hljs-number"><span class="hljs-number">1.5</span></span>) self.difficulty_to_points[i+<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(self.difficulty_to_points[i+<span class="hljs-number"><span class="hljs-number">2</span></span>]*<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  That is, for example, the first 14 difficulty levels will have the following number of points: <br><br> <code> -  <br> 1 - 16 <br> 2 - 24 <br> 3 - 24 <br> 4 - 16 <br> 5 - 32 <br> 6 - 40 <br> 7 - 40 <br> 8 - 26 <br> 9 - 56 <br> 10 - 64 <br> 11 - 64 <br> 12 - 42 <br> 13 - 84</code> <br> <br>  That is, it turns out that first there is a certain level of points that lasts for three rounds, then it drops by one round, and then increases significantly in the next round, which becomes a new plateau lasting about three rounds, then it jumps again in the next round, which becomes a new plateau, lasting about three rounds, and then this cycle repeats endlessly.  Thus, we create an interesting cycle ‚Äúnormalization -&gt; relaxation -&gt; intensification‚Äù, with which you can experiment. <br><br>  An increase in the number of points follows a very fast and hard rule, that is, for example, with a difficulty of 40, a round will have approximately 400 points.  Since the enemies are worth a constant amount of points, and each round must spend all the points given to him, the game quickly becomes oversaturated and at some point the players can no longer win.  But this is quite normal, because that is the design of the game.  Her goal - to score the maximum number of points in such conditions. <br><br>  Having dealt with this, we can try to implement the second part of rule 2, that is, determine the value of each enemy.  So far we have created only two types of enemies, so this is rather trivial, but in one of the following parts we will return to this after we create more enemies.  Now the code might look like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.enemy_to_points = { [<span class="hljs-string"><span class="hljs-string">'Rock'</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-string"><span class="hljs-string">'Shooter'</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  This is a simple table in which, by the name of the enemy, we can get the number of points to create it. <br><br>  The last part of rule 2 is the implementation of the <code>setEnemySpawnsForThisRound</code> function.  But before we get to it, I want to introduce you to a very important construction related to chances and probabilities.  We will use it throughout the game. <br><br><h3>  Chancelist </h3><br>  Suppose we want X to occur 25% of the time, Y to occur 25% of the time, and Z - 50% of the time.  In the usual way, this can be implemented with a function like <code>love.math.random</code> - to make it generate a value from 1 to 100, and then check where the value is.  If it is less than 25, then we say that event X occurred, if from 25 to 50, then event Y, and if greater than 50, then event Z. <br><br>  The big problem with this implementation is that we cannot guarantee that when you run <code>love.math.random</code> 100 times, X will occur exactly 25 times.  If we do it 10,000 times, then the probability will probably be close to 25%, but often we need to have more control over the situation.  Therefore, the simple solution is to create what I call a ‚Äúlist of changes‚Äù ( <code>chanceList</code> ). <br><br>  The chanceList list works as follows: we generate a list with values ‚Äã‚Äãfrom 1 to 100. When we need to get a random value from this list, we call the <code>next</code> function.  This function will give us a random value from the list, say, 28. This means that event Y will occur. The difference is that when we call a function, we also remove the selected random value from the list.  In essence, this means that 28 will never again fall out and the event Y now has a slightly lower probability than the other two events.  The more often we call <code>next</code> , the more empty the list becomes, and when it becomes completely empty, we simply recreate all 100 numbers again. <br><br>  Thus, we can guarantee that event X will occur exactly 25 times, event Y - also exactly 25, and event Z - exactly 50 times.  We can also make it so that instead of generating 100 numbers, the function generates 20. In this case, event X will occur 5 times, Y - also 5 times, and Z - 10 times. <br><br>  The interface for this principle works in a fairly simple way: <br><br><pre> <code class="lua hljs">events = chanceList({<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Z'</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(events:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>()) <span class="hljs-comment"><span class="hljs-comment">--&gt; will print X 25 times, Y 25 times and Z 50 times end</span></span></code> </pre> <br><pre> <code class="lua hljs">events = chanceList({<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Z'</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(events:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>()) <span class="hljs-comment"><span class="hljs-comment">--&gt; will print X 5 times, Y 5 times and Z 10 times end</span></span></code> </pre> <br><pre> <code class="lua hljs">events = chanceList({<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Z'</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(events:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>()) <span class="hljs-comment"><span class="hljs-comment">--&gt; will print X 10 times, Y 10 times and Z 20 times end</span></span></code> </pre> <br>  We will create the <code>utils.lua</code> function in <code>chanceList</code> and use some of the Lua features that we covered in the second part of this tutorial. <br><br>  First, we need to realize that this function will return an object for which we should be able to call the <code>next</code> function.  The easiest way to achieve this is to simply give this object a simple table that looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chanceList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here we get all possible definitions of values ‚Äã‚Äãand probabilities as <code>...</code> which we will process in more detail later.  Then we return a table that has a function <code>next</code> .  This function receives <code>self</code> as the only argument, since we know that calling the function with <code>:</code> transfers as its first argument itself.  That is, inside the function <code>next</code> <code>self</code> refers to a table that is returned by <code>chanceList</code> . <br><br>  Before defining what is inside the <code>next</code> function, we can define several attributes that this function will have.  The first is the <code>chance_list</code> itself, which will contain the values ‚Äã‚Äãreturned by the <code>next</code> function: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chanceList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { chance_list = {}, <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Initially this table is empty and will be filled in the <code>next</code> function.  In our example: <br><br><pre> <code class="lua hljs">events = chanceList({<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Z'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>})</code> </pre> <br>  The <code>chance_list</code> attribute will look something like this: <br><br><pre> <code class="lua hljs">.chance_list = {<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>, <span class="hljs-string"><span class="hljs-string">'Z'</span></span>}</code> </pre> <br>  We will need another attribute called <code>chance_definitions</code> , which will store all the values ‚Äã‚Äãand probabilities passed to the <code>chanceList</code> function: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chanceList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { chance_list = {}, chance_definitions = {...}, <span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And that's all we need.  Now we can go to the <code>next</code> function.  We need two behaviors from this function: it must return a random value according to the probabilities described in <code>chance_definitions</code> , and also restore the internal <code>chance_list</code> when it reaches zero elements.  Assuming the list is filled with elements, we can implement the first behavior as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">remove</span></span>(self.chance_list, love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, #self.chance_list)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  We simply select a random item inside the <code>chance_list</code> table and return it.  Due to the internal structure of the elements, all restrictions are satisfied. <br><br>  And now the most important part - we will build the <code>chance_list</code> table <code>chance_list</code> .  It turns out that we can use to build the list the same code that will be used to empty it.  It will look like this: <br><br><pre> <code class="lua hljs"><span class="hljs-built_in"><span class="hljs-built_in">next</span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> #self.chance_list == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, chance_definition <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.chance_definitions) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, chance_definition[<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.chance_list, chance_definition[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">remove</span></span>(self.chance_list, love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, #self.chance_list)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here we first determine whether the size of the <code>chance_list</code> zero.  This will be true when you first call <code>next</code> , and also when the list is empty after a lot of calls.  If this is true, then we begin to bypass the <code>chance_definitions</code> table, which contains tables that we call <code>chance_definition</code> with the values ‚Äã‚Äãand probabilities of these values.  That is, if we called the function <code>chanceList</code> like this: <br><br><pre> <code class="lua hljs">events = chanceList({<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Z'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>})</code> </pre> <br>  That <code>chance_definitions</code> table looks like this: <br><br><pre> <code class="lua hljs">.chance_definitions = {{<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Z'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}}</code> </pre> <br>  And when we <code>chance_definitions[1]</code> this list, <code>chance_definitions[1]</code> refers to the value, and <code>chance_definitions[2]</code> refers to the number of times the value is found in the <code>chance_list</code> .  Knowing this, to fill the list we simply insert <code>chance_definition[1]</code> into <code>chance_list</code> <code>chance_definition[2]</code> times.  And we do the same for all <code>chance_definitions</code> tables. <br><br>  If we test it, we will see that the system works: <br><br><pre> <code class="lua hljs">events = chanceList({<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Z'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(events:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h3>  Producer </h3><br>  Let's return to the director: we wanted to implement the second part of rule 2, which is associated with the implementation of <code>setEnemySpawnsForThisRound</code> .  The first thing we want to do is determine the likelihood of creating each enemy.  Different levels of complexity will have different probabilities of creation, and we will need to set at least the first few difficulties manually.  Then the subsequent difficulties will be set randomly, because they will have so many points that the player will be too overloaded anyway. <br><br>  So, here are some of the first levels of difficulty: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.enemy_spawn_chances = { [<span class="hljs-number"><span class="hljs-number">1</span></span>] = chanceList({<span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}), [<span class="hljs-number"><span class="hljs-number">2</span></span>] = chanceList({<span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Shooter'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}), [<span class="hljs-number"><span class="hljs-number">3</span></span>] = chanceList({<span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Shooter'</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}), [<span class="hljs-number"><span class="hljs-number">4</span></span>] = chanceList({<span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, {<span class="hljs-string"><span class="hljs-string">'Shooter'</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}), } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  These are not final values, but merely examples.  At the first difficulty, only stones will be created;  shooting enemies will be added to the second, but there will be fewer of them than stones;  in the third difficulty, both enemies will be created in approximately the same quantities;  finally, the fourth will create more shooting enemies than stones. <br><br>  For difficulties from 5 to 1024, we will simply ask each enemy random probabilities: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> self.enemy_spawn_chances[i] = chanceList( {<span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)}, {<span class="hljs-string"><span class="hljs-string">'Shooter'</span></span>, love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)} ) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  When we realize more enemies, we will manually create the first 16 difficulties, and after complexity 17 we will do it randomly.  In general, a player with a fully-filled skill tree will most often not be able to pass above difficulty level 16, so this will be the right moment to stop. <br><br>  We now turn to the <code>setEnemySpawnsForThisRound</code> function.  The first thing we do is use the creation of enemies in the list according to the <code>enemy_spawn_chances</code> table until we run out of points for the current difficulty level.  It might look something like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:setEnemySpawnsForThisRound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> points = self.difficulty_to_points[self.difficulty] <span class="hljs-comment"><span class="hljs-comment">-- Find enemies local enemy_list = {} while points &gt; 0 do local enemy = self.enemy_spawn_chances[self.difficulty]:next() points = points - self.enemy_to_points[enemy] table.insert(enemy_list, enemy) end end</span></span></code> </pre> <br>  Thus, the local table of <code>enemy_list</code> will be filled with the rows <code>Rock</code> and <code>Shooter</code> according to the probabilities of the current complexity.  We put this code inside a while loop, which stops execution when the number of remaining points reaches zero. <br><br>  After that, we need to decide when, in the interval of 22 seconds of the current round, each of the enemies within the <code>enemy_list</code> table will be created.  It might look something like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:setEnemySpawnsForThisRound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Find enemies spawn times local enemy_spawn_times = {} for i = 1, #enemy_list do enemy_spawn_times[i] = random(0, self.round_duration) end table.sort(enemy_spawn_times, function(a, b) return a &lt; b end) end</span></span></code> </pre> <br>  Here we make sure that each enemy in <code>enemy_list</code> assigned a random number between 0 and <code>round_duration</code> , stored in the <code>enemy_spawn_times</code> table.  We will sort this table so that the values ‚Äã‚Äãare in order.  That is, if our <code>enemy_list</code> table looks like this: <br><br><pre> <code class="lua hljs">.enemy_list = {<span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-string"><span class="hljs-string">'Shooter'</span></span>, <span class="hljs-string"><span class="hljs-string">'Rock'</span></span>}</code> </pre> <br>  then the <code>enemy_spawn_times</code> table will look like this: <br><br><pre> <code class="lua hljs">.enemy_spawn_times = {<span class="hljs-number"><span class="hljs-number">2.5</span></span>, <span class="hljs-number"><span class="hljs-number">8.4</span></span>, <span class="hljs-number"><span class="hljs-number">14.8</span></span>}</code> </pre> <br>  This means that Rock will be created in 2.5 seconds, Shooter will be created in 8.4 seconds, and another Rock will be created in 14.8 seconds after the start of the round. <br><br>  Finally, we need to set the creation of the enemies by calling <code>timer:after</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:setEnemySpawnsForThisRound</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Set spawn enemy timer for i = 1, #enemy_spawn_times do self.timer:after(enemy_spawn_times[i], function() self.stage.area:addGameObject(enemy_list[i]) end) end end</span></span></code> </pre> <br>  And here everything is pretty straightforward.  We go through the list of <code>enemy_spawn_times</code> and set the creation of enemies from <code>enemy_list</code> in accordance with the numbers in the first table.  The last thing to do is to call this function once when starting the game: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self:setEnemySpawnsForThisRound() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  If we do not do this, then the enemies will begin to be created only after 22 seconds.  We can also, at launch, add the creation of an attack resource so that the player can replace his attack, but this is not necessary.  Be that as it may, if we run the code now, then everything will work as intended! <br><br>  At this moment we will leave the director alone, but we will return to him in the next articles when we add more content to the game! <br><br><h3>  Exercises with the director </h3><br>  <strong>116. (CONTENT)</strong> Implement rule 3. It should work as a rule 1, but instead of increasing complexity one of the three resources specified in the list should be created.  The probabilities of creating each of the resources must meet the following definition: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.resource_spawn_chances = chanceList({<span class="hljs-string"><span class="hljs-string">'Boost'</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>}, {<span class="hljs-string"><span class="hljs-string">'HP'</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>}, {<span class="hljs-string"><span class="hljs-string">'SkillPoint'</span></span>, <span class="hljs-number"><span class="hljs-number">58</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  <strong>117. (CONTENT)</strong> Implement rule 4. It should work as a rule 1, only instead of increasing complexity, a random attack should be created. <br><br>  <strong>118.</strong> The while loop, which is searching for created enemies, has one big problem: it can be stuck forever in an endless loop.  Imagine a situation in which there is only one point left, but enemies standing one point (for example, Rock) can no longer be created, because the current level of difficulty does not create Rock.  Find a common solution to this problem, without changing the price of enemies, the number of points in difficulty levels and not relying on the fact that the problem is solved by the possibility of creating enemies (for example, forcing all levels of difficulty to always create enemies with low cost). <br><br><h2>  Game cycle </h2><br>  We now turn to the game cycle.  Here we will make it so that the player can play again and again - when a player dies, he starts the level again.  In the finished game, the cycle will be slightly different, because after death the player must move to the Console room, but since we do not have a Console room yet, we will simply restart the Stage room.  It will be convenient to check memory problems here, because we will restart the Stage room again and again. <br><br>  Due to the way we structured the code, this is incredibly easy to do.  We will define the <code>finish</code> function in the Stage class, which uses <code>gotoRoom</code> to switch to another Stage room.  This function looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> timer:after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> gotoRoom(<span class="hljs-string"><span class="hljs-string">'Stage'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  <code>gotoRoom</code> will deal with the destruction of the previous instance of the Stage and the creation of a new one so that we do not have to destroy the objects manually.  The only thing we need to take care of is to set the <code>player</code> attribute in the Stage class to <code>nil</code> in its destroy function, otherwise the Player object will not be deleted correctly. <br><br>  The <code>finish</code> function can be called from the Player object itself when the player dies: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:die</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... current_room:finish() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  We know that <code>current_room</code> is a global variable containing the current active room, and when the <code>die</code> function is called for the player, the only active room will be the Stage, so everything will work as it should.  If we run the code, it will work as we expected.  If the player dies, then after 1 second a new room of the Stage starts and you can start the game again. <br><br>  It is worth noting that everything worked out so simply because we structured our game in accordance with the principle of rooms and areas.  If we structured everything differently, it would be much more difficult, and because of this (in my opinion) many people get confused when creating a game in L√ñVE.  We can structure the system the way we need, but it is easy to do so that some aspects, such as restarting the game, are not so easy to implement.  It is important to understand the role that our chosen architecture plays. <br><br><h2>  Score </h2><br>  The main goal of the game is to score maximum points, so we need to create an account system.  This is also quite simple compared to what we have already done.  To do this, we just need to create the <code>score</code> attribute in the Stage class, which will track the points we collect.  After the game is completed, this score will be saved somewhere, and we will be able to compare it with previous records.  For now, we'll skip the part with the comparison of points and focus only on the basics. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.score = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Now we can increase the score when performing actions that increase it.  While we will have the following rules for scoring: <br><br><ol><li>  Picking up a resource of ammunition adds 50 points to the score </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Picking up an acceleration resource adds 150 points to the score. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Picking up a skill point resource adds 250 points to the score. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Choosing an attack resource adds 500 points to the score. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Destruction Rock adds 100 points to the score </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Destruction Shooter adds 150 points to the score </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rule 1 we implement as follows 1: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:addAmmo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amount)</span></span></span></span> self.ammo = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(self.ammo + amount, self.max_ammo) current_room.score = current_room.score + <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We move to the most obvious place - where the event occurs (in our case it is a function </font></font><code>addAmmo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and then simply add here the code that changes the account. </font><font style="vertical-align: inherit;">Just as we did for the function </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, here we can access the Stage room through </font></font><code>current_room</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because the Stage room is the only one that can be active in this case.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exercises with a score </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">119. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the rules from 2 to 6. They are very simple to implement and very similar to the one I gave for example.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ui </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now for the user interface (UI). </font><font style="vertical-align: inherit;">In the finished game, it will look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0f/523/224/f0f5232246fa7cf657032231f0278b72.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The number of available skill points is indicated in the upper left corner, the score is shown in the upper right part, and the player‚Äôs main characteristics are shown in the upper and lower part of the screen. </font><font style="vertical-align: inherit;">Let's start by counting. </font><font style="vertical-align: inherit;">All we want to do here is to display a number in the upper right corner of the screen.</font></font> It might look like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setCanvas(self.main_canvas) love.graphics.clear() ... love.graphics.setFont(self.font) <span class="hljs-comment"><span class="hljs-comment">-- Score love.graphics.setColor(default_color) love.graphics.print(self.score, gw - 20, 10, 0, 1, 1, math.floor(self.font:getWidth(self.score)/2), self.font:getHeight()/2) love.graphics.setColor(255, 255, 255) love.graphics.setCanvas() ... end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We want to draw the UI on top of everything else, and this can be implemented in two ways. </font><font style="vertical-align: inherit;">We can either create an object called UI and set its attribute </font></font><code>depth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it is drawn on top of everything, or we can just draw over the Area in the canvas </font></font><code>main_canvas</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that the Stage room uses. </font><font style="vertical-align: inherit;">I decided to choose the second method, but they both work. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the code above, we used to set the font </font></font><a href="https://love2d.org/wiki/love.graphics.setFont" rel="nofollow"><code>love.graphics.setFont</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.font = fonts.m5x7_16 <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then we draw the account in the appropriate position in the upper right corner of the screen. </font><font style="vertical-align: inherit;">We have shifted half the width of the text so that the account is centered on this position, and does not start in it, otherwise, when the numbers are too large (&gt; 10,000), the text may go beyond the borders of the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The text of skill points is also created in about the same simple way, so we leave it for the exercise.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to the second important part of the UI, that is, to the central elements. </font><font style="vertical-align: inherit;">We will start with health (HP). </font><font style="vertical-align: inherit;">We need to draw three elements: a word denoting a parameter (in our case, ‚ÄúHP‚Äù), a bar indicating the parameter‚Äôs fullness, and numbers showing the same information, but in a more accurate form. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We'll start by drawing the strip:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... love.graphics.setCanvas(self.main_canvas) love.graphics.clear() ... <span class="hljs-comment"><span class="hljs-comment">-- HP local r, g, b = unpack(hp_color) local hp, max_hp = self.player.hp, self.player.max_hp love.graphics.setColor(r, g, b) love.graphics.rectangle('fill', gw/2 - 52, gh - 16, 48*(hp/max_hp), 4) love.graphics.setColor(r - 32, g - 32, b - 32) love.graphics.rectangle('line', gw/2 - 52, gh - 16, 48, 4) love.graphics.setCanvas() end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we will draw this rectangle in position </font></font><code>gw/2 - 52, gh - 16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and its width will be equal </font></font><code>48</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. That is, both bars will be drawn relative to the center of the screen with a small gap of 8 pixels. From this we can also understand that the position of the bar on the right will be </font></font><code>gw/2 + 4, gh - 16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This bar will be a filled rectangle with color </font></font><code>hp_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and its outline will be a rectangle with color </font></font><code>hp_color - 32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Since we cannot subtract from the table, we need to divide the table </font></font><code>hp_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into separate components and subtract from each. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only strip that will change in any way is the filled rectangle, whose width will change according to the relation </font></font><code>hp/max_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For example, if it </font></font><code>hp/max_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is 1, then HP is full. If 0.5, then</font></font><code>hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has half the size </font></font><code>max_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If 0.25, then 1/4 of the size. </font><font style="vertical-align: inherit;">And if we multiply this ratio by the width that the strip should have, then we get a beautiful visualization of the player‚Äôs HP fill. </font><font style="vertical-align: inherit;">If we implement it, the game will look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8d/d79/2fc/d8dd792fc6348b09ba928f85177a5e14.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can see that when a player takes damage, the bar responds accordingly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now similarly to that. </font><font style="vertical-align: inherit;">as we have drawn the number of points, we can draw the text of HP:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... love.graphics.setCanvas(self.main_canvas) love.graphics.clear() ... <span class="hljs-comment"><span class="hljs-comment">-- HP ... love.graphics.print('HP', gw/2 - 52 + 24, gh - 24, 0, 1, 1, math.floor(self.font:getWidth('HP')/2), math.floor(self.font:getHeight()/2)) love.graphics.setCanvas() end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here again, just as we did for the account, we need the text to be centered relatively </font></font><code>gw/2 - 52 + 24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, relative to the center of the strip, that is, we need to shift it to the width of this text typed in this font (and we do this with the help of the function </font></font><code>getWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we can also simply draw the HP numbers under the bar:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... love.graphics.setCanvas(self.main_canvas) love.graphics.clear() ... <span class="hljs-comment"><span class="hljs-comment">-- HP ... love.graphics.print(hp .. '/' .. max_hp, gw/2 - 52 + 24, gh - 6, 0, 1, 1, math.floor(self.font:getWidth(hp .. '/' .. max_hp)/2), math.floor(self.font:getHeight()/2)) love.graphics.setCanvas() end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here apply the same principle. </font><font style="vertical-align: inherit;">We need the text to be centered, so we need to shift it to its width. </font><font style="vertical-align: inherit;">Most of these coordinates were obtained by trial and error, so if you wish, you can try other distances.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exercises with UI </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">120. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the UI for the Ammo parameter. </font><font style="vertical-align: inherit;">The position of the bar is equal to </font></font><code>gw/2 - 52, 16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">121. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the UI for the Boost parameter. </font><font style="vertical-align: inherit;">The position of the bar is equal to </font></font><code>gw/2 + 4, 16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">122. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the UI for the Cycle parameter. </font><font style="vertical-align: inherit;">The position of the bar is equal to </font></font><code>gw/2 + 4, gh - 16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h2>  the end </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And on this we completed the first main part of the game. </font><font style="vertical-align: inherit;">This is the basic skeleton of the entire game with a minimum amount of content. </font><font style="vertical-align: inherit;">The second half (in five or so parts) will be entirely devoted to adding content to the game. </font><font style="vertical-align: inherit;">The structure of the parts will become more like this part, in which I do something once, and then in the exercises you implement the same idea for other elements. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, the next part will be a short break in which I will share my thoughts on the practice of writing code and explain the architectural solutions and the structure of the code I have chosen. </font><font style="vertical-align: inherit;">You can skip it if you are only interested in creating the game, because it will be a more categorical part, not so strongly associated with the game itself as the rest.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 10: Code Writing Practices </font></font></h2><br><h2>  Introduction </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part, I‚Äôll talk about recommended coding practices and how they are applied or not applicable to what we are doing in this series of tutorials. If you read it from the very beginning and did most of the exercises (especially those labeled as ‚Äúcontent‚Äù), then you are likely to encounter solutions that raise questions from the point of view of programming practices: huge if / elseif chains, global functions, huge functions, huge classes that perform a bunch of operations, copy-and-paste and duplicate code instead of proper abstraction, and so on.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you already have programming experience in another field, then you know what you shouldn‚Äôt do, so in this part I would like to explain in more detail some of these solutions. Unlike all the previous parts, this will be very categorical and possibly erroneous, so you can skip it without any problems. We will not consider anything directly related to the game, even when, for the context of what I am talking about, I will give examples from the game we create. In this part we will talk about two main aspects: global variables and abstractions. First, we will discuss when and where global variables can be used, and second, we will more broadly consider how and when to abstract or generalize.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition, if you bought a tutorial, then in the code base for this article I added a code that was previously marked in the exercises as ‚Äúcontent,‚Äù namely, the graphics for all player‚Äôs ships, all attacks, and objects for all resources, because I will use them here as examples. </font></font><br><br><h2>  Global variables </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually people are advised to avoid using global variables. </font><font style="vertical-align: inherit;">There are </font></font><a href="http://wiki.c2.com/%3FGlobalVariablesAreBad" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">many </font></font></a> <a href="https://stackoverflow.com/questions/10525582/why-are-global-variables-considered-bad-practice" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">different </font></font></a> <a href="http://www.learncpp.com/cpp-tutorial/4-2a-why-global-variables-are-evil/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">discussions of </font></font></a> <a href="https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this topic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the rationale for this advice is quite logical. </font><font style="vertical-align: inherit;">In general, the main problem with using global variables is that they make things more unpredictable than necessary. </font><font style="vertical-align: inherit;">Here is what is written on the last link:</font></font><br><br><blockquote>    ‚Äî ,      ,    . ,        ,        (   ),        . <br><br>          ,     ,      ,          .       ,     ,      . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And all this is very correct and reasonable. But in such discussions the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">context is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> always forgotten </font><font style="vertical-align: inherit;">. The advice given above is logical as a general guide, but if you begin to look at a specific situation in detail, you will find that you need to clearly understand whether this applies to your case or not.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is the idea that I will repeat throughout the article, because I deeply believe in it: advice that is useful to teams of several people and in software development that will be supported for several years / decades does not work as well for developers - single indie video game. When you write code mostly on your own, you can go for simplifications that are not allowed by the team. And when you write video games, you can simplify even more, compared to other types of software, because games are usually supported for a short time.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This difference in contexts manifests itself when it comes to global variables. </font><font style="vertical-align: inherit;">In my opinion, you can use global variables when you know how and why to use them. </font><font style="vertical-align: inherit;">We want to maximize their benefits and at the same time avoid their disadvantages. </font><font style="vertical-align: inherit;">And in this sense, we also need to take into account the advantages we have: first, we write the code ourselves, and secondly, we write video games.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Types of global variables </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In my opinion, there are three types of global variables: those that are mostly read, those that are mainly written, and those that are often read and written. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Type 1 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first type is global variables that are often read but rarely written. </font><font style="vertical-align: inherit;">Variables of this type are harmless, because in fact they do not actually increase the unpredictability of the program. </font><font style="vertical-align: inherit;">These are simply existing values ‚Äã‚Äãthat are always or almost always constant. </font><font style="vertical-align: inherit;">They can also be considered as constants. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of a variable of this type in our game is a variable </font></font><code>all_colors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">containing a list of all colors. </font><font style="vertical-align: inherit;">These colors never change and never write to this table. </font><font style="vertical-align: inherit;">At the same time, it is read from different objects, for example, when we need to get a random color.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Type 2 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second type is global variables, which are often written and rarely read. </font><font style="vertical-align: inherit;">Such variables are almost harmless, because they also do not increase the unpredictability of the program. </font><font style="vertical-align: inherit;">These are simply storages of values ‚Äã‚Äãthat will be used in very specific and manageable conditions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So far, there are no variables in our game that correspond to this definition, but an example is a table containing data on how a player plays, and then, when leaving the game, sending all data to the server. </font><font style="vertical-align: inherit;">We will constantly write to this table all sorts of information in different places of the code base, but it will be read and, perhaps, slightly changed, only when we decide to send it to the server.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Type 3 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third type is global variables with active read and write. They represent a real threat and actually increase unpredictability, in many ways complicating our work. When people say ‚Äúdo not use global variables,‚Äù they mean this type. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are several such variables in our game, but I think it will be the most noticeable </font></font><code>current_room</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Already her name itself implies some uncertainty, since the current room can be an object </font></font><code>Stage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or an object </font></font><code>Console</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or an object </font></font><code>SkillTree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or any other type of Room object. I decided that for our game this would be an acceptable decrease in clarity.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main point of this division of global variables into types is to understand the problem a little deeper and, so to speak, separate the wheat from the chaff. Our productivity would suffer greatly if we took this too dogmatically and avoided global variables with all our strength. Avoiding them with all your strength is worthwhile for teams and people who have been involved in software support for years, but it is unlikely that the variable will </font></font><code>all_colors</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interfere with us in the long run. As long as we monitor variables like </font></font><code>current_room</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and do not allow them to be too multiple or too confusing (for example, it </font></font><code>current_room</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes only when a function is called </font></font><code>gotoRoom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), we can control everything.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you see or want to use a global variable, then first think about what type it will be. </font><font style="vertical-align: inherit;">If it is type 1 or 2, then most likely it will not cause problems. </font><font style="vertical-align: inherit;">If it has type 3, then it is important to think about when and how often it will be read and written. </font><font style="vertical-align: inherit;">If you very often write to it from random objects in the entire code base and read from random objects throughout the code base, then you probably should not make it global. </font><font style="vertical-align: inherit;">If you rarely write to it from a very small set of objects, and read it from random objects across the entire code base, this is still not very good, but it may be acceptable. </font><font style="vertical-align: inherit;">The point is to think about such problems critically, and not just follow some dogmatic rules.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abstraction and copying </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When I talk about abstractions, I mean the layer of code that is extracted from repetitive or similar code for reuse in a more limited and clear way. For example, in our game there are such lines:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> direction = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>({<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}) self.x = gw/<span class="hljs-number"><span class="hljs-number">2</span></span> + direction*(gw/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span>) self.y = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>, gh - <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And they are the same for all objects that should be created to the left or right of the screen in a random position along the y axis. It seems that these three lines are still in the beginning about 6-7 objects. The argument in favor of abstraction here is that if these strings are repeated in several objects, then we must abstract them in some way so that the objects can use this abstraction, rather than repeating the strings in the code base. We can implement this abstraction through inheritance, components, a function, or some other mechanism. In our discussion, all these different ways will be considered one topic, because they all demonstrate the same problems.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that you know what I'm talking about, let's look at the question in more detail. </font><font style="vertical-align: inherit;">From my point of view, the main discussion of these problems is whether to add a new code with existing abstractions, or to freely add a new code. </font><font style="vertical-align: inherit;">I mean that when we have abstractions that help us in some way, they also have (often hidden) costs that can slow us down in other ways.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abstraction </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the example above, we can create some function / component / parent class in which these three lines will be encapsulated, so that it will not be necessary to repeat them everywhere. Since components are at the peak of fashion today, let's take them and implement the SpawnerComponent component (but again, don't forget that this applies to functions / inheritance / admixtures and other similar methods of abstraction / reuse of code). We can initialize it as </font></font><code>spawner_component = SpawnerComponent()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and it will magically process for us all the logic of the spawn of objects. In our example, these are three lines, but the same logic applies to more complex behaviors.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The advantages of this solution are that now everything connected with the logic of the spawn of objects is in one place under one interface. This means that when we want to make some changes in the behavior of the spawn, then it will be enough for us to change it only in one place, and not to change the code manually in the set of files. The advantages of this are well understood and I will not question them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, such a solution has its own costs, which are most often ignored when people ‚Äúsell‚Äù you some kind of solution. Costs become apparent when we want to add some kind of new behavior that looks like the old one, but not completely. And in games this happens often.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, for example, suppose that we need to add objects that spawn exactly in the middle of the screen. </font><font style="vertical-align: inherit;">We have two options: either change the SpawnerComponent to accept this new behavior, or create a new component that implements this new behavior. </font><font style="vertical-align: inherit;">In our case, the obvious choice would be to change the SpawnerComponent, but in more complex examples the choice may not be so obvious. </font><font style="vertical-align: inherit;">The point here is that since we need to add a new code taking into account the existing code (in our case, this is SpawnerComponent), for this we will need more mental effort taking into account the fact that we need to decide where and where to add functionality instead of calmly add it.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Copypasting </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An alternative solution, which is applied now in our code base, is that these three lines are inserted wherever this behavior is needed. The disadvantages of this solution are that if we need to change the behavior of the spawn, we will have to monotonously go through all the files and change them all. In addition, the behavior of the spawn is not properly encapsulated in a separate environment, that is, when new behaviors are added to the game, it will be more difficult to separate it from everything else (most likely, they will not forever be just these three lines). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, such a solution has its advantages. In the case when we want to add objects that are created exactly in the middle of the screen, we just need to copy these lines from the previous object and change the last one:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> direction = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>({<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}) self.x = gw/<span class="hljs-number"><span class="hljs-number">2</span></span> + direction*(gw/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span>) self.y = gh/<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, adding a new behavior, similar to the previous one, is completely trivial and does not require any mental effort (unlike a solution with SpawnerComponent). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then the question arises - if both methods have their advantages and disadvantages, which of them should be used by default? </font><font style="vertical-align: inherit;">Usually, people say that the default is to use the first method and we don‚Äôt have to save such duplicate code for a long time, because it ‚Äúsmells bad‚Äù. </font><font style="vertical-align: inherit;">But in my opinion you need to do the opposite. </font><font style="vertical-align: inherit;">By default, we must use duplicate code and abstract it only when absolutely necessary. </font><font style="vertical-align: inherit;">And the reason for this ...</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Frequency and types of changes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I found a good way to find out if some piece of code should be abstracted: you need to look at how often it changes and how it can change. </font><font style="vertical-align: inherit;">I discovered two basic types of change: unpredictable and predictable changes.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unpredictable changes </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unpredictable changes are changes that fundamentally change behavior, much more than simple minor changes. </font><font style="vertical-align: inherit;">In the example of spawn behavior, an unpredictable change would be, for example, that instead of accidentally creating enemies to the left and right of the screen, they would be created based on the position given by the procedural generator algorithm. </font><font style="vertical-align: inherit;">We cannot predict fundamental changes of this type. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such changes often occur at the earliest stages of development, when we have some vague idea of ‚Äã‚Äãthe game, but there are no details. </font><font style="vertical-align: inherit;">You can cope with such changes by choosing the default copy-and-paste method, because the more abstractions we create, the more difficult it will be to implement all these intersecting changes in the code base.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Predictable changes </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Predictable changes are changes that modify behavior in a minor and definite way. In the example shown above with the behavior of spawn, a predictable change will be an example in which we need to create objects exactly in the middle of the screen along the y axis. This change changes the behavior of the spawn, but it is very little and does not completely destroy the basis of the work of the behavior of the spawn.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such changes are becoming more frequent when the game matures, because by that time we already have most of the systems, and we only need to make small variations or additions to the same fundamental aspects. Such changes can be considered by analyzing the frequency of change of the corresponding code. If it changes frequently and these changes are predictable, then you should choose abstraction. If it changes rarely, then by default it is worth choosing copy-pasting.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main point of dividing the changes into these two types is that they allow us to analyze the situation more clearly and make more conscious decisions. Our productivity will suffer if we dogmatically default to abstracting everything and avoiding duplicate code at all costs. Avoiding by all means is suitable for teams and people working on software that should be supported for a long time, but not suitable for indie games created alone.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you feel the desire to generalize something, then think hard whether it is necessary. </font><font style="vertical-align: inherit;">If this code fragment changes infrequently, then you should not worry about it. </font><font style="vertical-align: inherit;">If it changes frequently, how is it predictable or unpredictable? </font><font style="vertical-align: inherit;">If it changes unpredictably, then too much work and attempts to encapsulate are likely to be a waste of time, because encapsulation will prevent you from having to make major changes to the game. </font><font style="vertical-align: inherit;">If it changes predictably, then there is a possibility that abstraction can actually help us. </font><font style="vertical-align: inherit;">The point is to think about these issues critically, and not just blindly follow some dogmatic rule.</font></font><br><br><h2>  Examples </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There are other examples in our game that can be used for a deeper discussion of these problems: </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Move left / right </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This aspect is very similar to the spawn code, that is, the behavior of all entities moving left or right in a straight line. That is, this applies to multiple enemies and most resources. The code that controls this behavior looks something like this and repeats itself for all these entities:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rock:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> ... self.w, self.h = <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> self.collider = self.area.world:newPolygonCollider(createIrregularPolygon(<span class="hljs-number"><span class="hljs-number">8</span></span>)) self.collider:setPosition(self.x, self.y) self.collider:setObject(self) self.collider:setCollisionClass(<span class="hljs-string"><span class="hljs-string">'Enemy'</span></span>) self.collider:setFixedRotation(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) self.v = -direction*<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>) self.collider:setLinearVelocity(self.v, <span class="hljs-number"><span class="hljs-number">0</span></span>) self.collider:applyAngularImpulse(<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Rock:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.collider:setLinearVelocity(self.v, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depending on the entity, the setting of the collider may vary slightly, but in general it is almost the same. </font><font style="vertical-align: inherit;">As in the spawn code, we can decide that it is a good idea to abstract this code into something else, for example, in LineMovementComponent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The analysis here will be the same as before. </font><font style="vertical-align: inherit;">We need to think about how often this behavior changes for all these entities. </font><font style="vertical-align: inherit;">The correct answer: almost never. </font><font style="vertical-align: inherit;">The behavior is that some of these entities should move left / right, the direction is chosen and will not change, so there is no point in taking care of it, that is, we can completely repeat the code in the entire code base.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The graphics of the player‚Äôs ships and their tracks </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you have done most of the exercises, then in the Player class there is code that looks like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath101.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, these are two huge if / elseifs, one controls the graphics of various ships, and the other controls the traces of these ships. The first thing to think about when looking at this code is that it needs to be CLEARED. But again, is it necessary? Unlike the previous examples, this code is not repeated in many different places, that is, it‚Äôs just a bunch of sequential code.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also think about abstracting all these different types of ships into separate files, determine the differences in these files, and in the Player class just read these files so that all the code is clean and beautiful. </font><font style="vertical-align: inherit;">And this can really be done, but in my opinion this refers to the case of optional abstraction. </font><font style="vertical-align: inherit;">Personally, I prefer to have a simple code that is clearly visible, and not scattered across several levels of abstraction. </font><font style="vertical-align: inherit;">If this huge piece of code at the beginning of the Player class really annoys you, then you can put it in a function and place it at the end of the class. </font><font style="vertical-align: inherit;">Or use the folding that should be supported by your editor. </font><font style="vertical-align: inherit;">Here's how, for example, the collapse in my editor looks like:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2da/00d/838/2da00d8385b5463ae1f6fe20f73495ca.png"></div><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Class size Player </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Player class now consists of about 500 lines. In the next part, where we add passive skills, it will grow to about 2000 lines. When you see this, your natural response will be to make the code more beautiful and clean. And here again it is worth asking yourself the question - is it really necessary to do this? In most games, the Player class contains most of the functionality and often people make great efforts to ensure that it does not become such a huge class in which everything happens.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But for the same reasons that I decided not to abstract the graphics and traces of the ships from the previous example, in my opinion it does not make sense to abstract all these different logical parts that make up the player‚Äôs class. </font><font style="vertical-align: inherit;">Therefore, instead of creating separate files for player movement, player collisions, player attacks, and so on, I consider it best to put all this in one file and get the Player class of 2000 lines. </font><font style="vertical-align: inherit;">The ratio of benefits and costs of finding everything in one place and without layers of abstractions between elements is higher than the ratio of benefits and costs with the proper abstraction of elements (in my opinion!).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Entity-Component-System </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, the most popular "meme" for lonely developers in recent years has been ECS. I think, in view of the above, you already understand what my position on this matter is, but I will explain it anyway. The advantages of the ECS pattern are clearly visible and, I think, everyone understands them. What people do not understand is his faults.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin with, by definition, ECS is a more complex system. Its meaning is that when you add more functionality to the game, you can reuse components and create new entities from them. But the obvious costs (which people often ignore) are that at the beginning of development, you spend much more time creating reusable components than is necessary. And as I mentioned in the section on abstraction / copy-and-pick, when you create elements and default behavior so that they are abstract, adding code to the code base becomes a much more costly task, because you have to add it taking into account existing abstractions and structures. And this is very noticeable in games based on components.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, I believe that most indie games never reach the point where the ECS architecture begins to justify itself. </font><font style="vertical-align: inherit;">Look at this scientific chart drawn by me, and it will become clear to you:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a41/568/7f8/a415687f8d1699bf671b555ba31e552c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The point is that at the beginning ‚Äúyolo-coding‚Äù (which I advocate in this part of the article) requires less effort compared to ECS. </font><font style="vertical-align: inherit;">Over time, as the project progresses, yolo coding costs increase, while ECS costs decrease. </font><font style="vertical-align: inherit;">Then comes the moment when ECS becomes more efficient than yolo-coding. </font><font style="vertical-align: inherit;">I believe that most indie games, with very few exceptions (at least in my opinion), will never reach this intersection of two lines.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67b/18d/7f8/67b18d7f800e0ac94a95d881183c3d87.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if in your case this is the case, but in my opinion it is, then there is no point in using something like ECS. </font><font style="vertical-align: inherit;">This also applies to many other programming techniques and practices that are advertised by many people. </font><font style="vertical-align: inherit;">In fact, this whole part of the tutorial is about this thought. </font><font style="vertical-align: inherit;">There are things that are rewarded in the long term, but not suitable for the development of indie games, because for them the long term never comes.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> END </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anyway, I think that I have spoken enough on these issues. If you take something from this article, then just keep in mind that most of the programming recommendations that can be found on the Internet are intended for teams working on software that requires support for a long time. Your context as an indie video game developer is completely different, so you should always be critical about whether the advice given by other people is right for you. Often they are suitable because there are aspects of programming that are useful in any context (for example, the correct naming of variables), but sometimes they are not suitable. And if you do not pay attention to this, then slow down and become less productive.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, if you work in a large company and create software that has to be supported for a long time, and are used to related practices and programming styles, then trying to write code at home for your game in another style I described can be a failure. </font><font style="vertical-align: inherit;">Therefore, you also need to take into account the ‚Äúnatural‚Äù coding environment for you and how much the programming environment I described for indie game developers is far from you, as well as how well you can switch between them. </font><font style="vertical-align: inherit;">I want to say that you need to be critical of your programming practices, how they approach the specific context and how convenient you are to use them.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 11: Passive Skills </font></font></h2><br><h2>  Introduction </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part we will consider the implementation of all passive skills of the game. In total, there will be approximately 120 different elements in the game, and this is enough to turn into a very large skill tree (for example, in the tree I created, about 900 nodes). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part of the article there will be a lot of exercises labeled as ‚Äúcontent.‚Äù They work as follows: first I will show you how something is done, and then I will give a bunch of exercises in which you need to do the same, but for other parameters. For example, I will show how to implement the HP multiplier, that is, the characteristic that multiplies the player's HP by a certain percentage, and then in the exercises I will ask you to realize the Ammo and Boost multipliers. In fact, everything will be a little more complicated, but in general the meaning is as follows.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After we finish with the implementation of the entire code of this part, we will have implemented a large proportion of the game content, after which it will be necessary to complete small details, for example, building a huge skill tree from the passive skills we have implemented. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Types of characteristics </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before embarking on everything, we first need to decide on the types of passive skills that will be in our game. </font><font style="vertical-align: inherit;">I have already decided what I want to do, so I will just follow my plan, but you can safely deviate from it and come up with your own ideas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The game will have three main types of passive values: resources, characteristics multipliers and probabilities.</font></font><br><br><ul><li>  ‚Äî  HP, Boost  Ammo.     <code>max_value</code> ,    <code>current_value</code> .   HP     ,    ,     . </li><li>   ‚Äî  ,      .    ,     ,  ¬´    10%¬ª.            ,      ,     .      ,      50%,    <code>max_v</code>     .   <code>mvspd_multiplier</code>   1.5,      1.5 (   50%). </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probabilities are the chances of performing some event. </font><font style="vertical-align: inherit;">The player will also be able to choose an additional probability of performing certain events in certain conditions. </font><font style="vertical-align: inherit;">For example, ‚ÄúIncreased by 5% probability of a queue for a cycle‚Äù, that is, at the end of a cycle (the interval of 5 seconds implemented by us), the player has a 5% chance of releasing a queue from shells. </font><font style="vertical-align: inherit;">If a player chooses many such nodes, then the probability increases and the queues will occur more often.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also, the game will have an additional type of nodes and additional mechanics: important nodes and temporary bonuses. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Important nodes are nodes that somehow change the logic of the game (although not always). </font><font style="vertical-align: inherit;">For example, we will have a node replacing HP with an energy shield. </font><font style="vertical-align: inherit;">Thanks to the shield, the player can withstand double damage, if he doesn‚Äôt take damage for a while, the shield is recharged, in addition, the time of invulnerability becomes half as long. </font><font style="vertical-align: inherit;">Such nodes will not occur as often as others, but they can be very powerful and combined in interesting ways.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Temporary bonuses are temporary increases in parameters. </font><font style="vertical-align: inherit;">Sometimes a player may receive a temporary bonus, which, for example, increases attack speed by 50% for 4 seconds.</font></font></li></ul><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having learned all this, we can proceed. </font><font style="vertical-align: inherit;">First, let's see how the resource parameters in our code base should now look like:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Boost self.max_boost = 100 self.boost = self.max_boost ... -- HP self.max_hp = 100 self.hp = self.max_hp -- Ammo self.max_ammo = 100 self.ammo = self.max_ammo ... end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The values ‚Äã‚Äãof the movement code should look like this: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Movement self.r = -math.pi/2 self.rv = 1.66*math.pi self.v = 0 self.base_max_v = 100 self.max_v = self.base_max_v self.a = 100 ... end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the cycle values ‚Äã‚Äãshould look like this (for the sake of integrity, I renamed all previous references with the word "tick" to "cycle"): </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Cycle self.cycle_timer = 0 self.cycle_cooldown = 5 ... end</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HP multiplier </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So let's start with the HP multiplier. </font><font style="vertical-align: inherit;">In the simplest case, it is enough for us to define a variable </font></font><code>hp_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that initially has a value of 1, and then apply all the increases from the tree to this variable and at some point multiply it by </font></font><code>max_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Let's start with the first:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Multipliers self.hp_multiplier = 1 end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, we need to assume that we get the increase in HP from the tree. </font><font style="vertical-align: inherit;">To do this, we need to decide how these increases will be transmitted and how they will be determined. </font><font style="vertical-align: inherit;">Here I have to cheat a bit (because I have already written this game) and say that the tree nodes will be defined in the following format:</font></font><br><br><pre> <code class="lua hljs">tree[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {<span class="hljs-string"><span class="hljs-string">'HP'</span></span>, {<span class="hljs-string"><span class="hljs-string">'6% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.06</span></span>}}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This means that node 2 is called </font></font><code>HP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, has a description </font></font><code>6% Increased HP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and affects the variable </font></font><code>hp_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at 0.06 (6%). There is a function </font></font><code>treeToPlayer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that receives all 900 of these node definitions and applies them to the player object. It is also important to note that the variable name used in the definition of the node must be the same name that is defined in the player object, otherwise it will not work. This is a very subtly connected and error-prone way, but as I said in the previous part, you can put up with such things, because we write everything alone. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last question is: when we multiply </font></font><code>hp_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by</font></font><code>max_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">The natural choice is to simply do it in the constructor, because it is in him that a new player is created, and a new player is created when creating a new Stage room, which also happens when a new game starts. </font><font style="vertical-align: inherit;">However, we will do this at the very end of the constructor, after all the resources, factors, and probabilities are determined:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- treeToPlayer(self) self:setStats() end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, in the function </font></font><code>setStats</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can do the following:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:setStats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.max_hp = self.max_hp*self.hp_multiplier self.hp = self.max_hp <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, if we, for example, assign the </font></font><code>hp_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value 1.5 and start the game, we note that the player will have 150 HP instead of 100. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be noted that here we must also assume the existence of a function </font></font><code>treeToPlayer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and transfer the player's object to this function. </font><font style="vertical-align: inherit;">Later, when we write the skill tree code and implement this function, it will set the values ‚Äã‚Äãof all multipliers based on the bonuses from the tree, and after setting the values, we can call </font></font><code>setStats</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to use them to change player parameters. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">123. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the variable </font></font><code>ammo_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">124. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the variable </font></font><code>boost_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Easy HP </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's talk about simple features. </font><font style="vertical-align: inherit;">Simple characteristics are a direct increase in some characteristic, not based on percentages. </font><font style="vertical-align: inherit;">We implement them for HP by defining a variable </font></font><code>flat_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is added to </font></font><code>max_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(before multiplying by a factor):</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Flats self.flat_hp = 0 end</span></span></code> </pre> <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:setStats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.max_hp = (self.max_hp + self.flat_hp)*self.hp_multiplier self.hp = self.max_hp <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As before, when we specify a node in the tree, we want to bind it to the corresponding variable, so, for example, a node that adds a simple HP will look like this: </font></font><br><br><pre> <code class="lua hljs">tree[<span class="hljs-number"><span class="hljs-number">15</span></span>] = {<span class="hljs-string"><span class="hljs-string">'Flat HP'</span></span>, {<span class="hljs-string"><span class="hljs-string">'+10 Max HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'flat_hp'</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>}}</code> </pre> <br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">125. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the variable </font></font><code>flat_ammo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">126. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the variable </font></font><code>flat_boost</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">127. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a variable </font></font><code>ammo_gain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is added to the amount of ammunition received when a player selects a resource. </font><font style="vertical-align: inherit;">Change the calculations in the function accordingly </font></font><code>addAmmo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Self-guided shells </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next passive skill that we will implement will be ‚ÄúProbability of a shot by a homing projectile when selecting ammunition,‚Äù but for now we will focus on the part with the self-guided projectiles. </font><font style="vertical-align: inherit;">One of the attacks that the player will have is a homing projectile, so now we are implementing it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The homing function will be activated by the projectile when its </font></font><code>attack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value is </font><font style="vertical-align: inherit;">assigned to the attribute </font></font><code>'Homing'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The homing code will be the same as the code used for the Ammo resource:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.collider:setLinearVelocity(self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r)) <span class="hljs-comment"><span class="hljs-comment">-- Homing if self.attack == 'Homing' then -- Move towards target if self.target then local projectile_heading = Vector(self.collider:getLinearVelocity()):normalized() local angle = math.atan2(self.target.y - self.y, self.target.x - self.x) local to_target_heading = Vector(math.cos(angle), math.sin(angle)):normalized() local final_heading = (projectile_heading + 0.1*to_target_heading):normalized() self.collider:setLinearVelocity(self.v*final_heading.x, self.v*final_heading.y) end end end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only thing that will be different is the definition of the variable </font></font><code>target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For an Ammo object, the variable </font></font><code>target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">points to the player's object, but in the case of a projectile, it will indicate the nearest enemy. To get the nearest enemy, we can use the function </font></font><code>getAllGameObjectsThat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defined in the Area class and apply a filter that will select only objects that are enemies and are close enough. To do this, we must first determine which of the objects are enemies, and which objects are not. The easiest way to do this is to create a global table </font></font><code>enemies</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will contain a list of rows with the names of the enemy classes. That is, </font></font><code>globals.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can add the following definition:</font></font><br><br><pre> <code class="lua hljs">enemies = {<span class="hljs-string"><span class="hljs-string">'Rock'</span></span>, <span class="hljs-string"><span class="hljs-string">'Shooter'</span></span>}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When new enemies are added to the game, we will add their lines to this table accordingly. </font><font style="vertical-align: inherit;">Now that we know which types of objects are enemies, we can easily select them:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> targets = self.area:getAllGameObjectsThat(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, enemy <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(enemies) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e:is(<span class="hljs-built_in"><span class="hljs-built_in">_G</span></span>[enemy]) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use a string </font></font><code>_G[enemy]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to access the class definition of the current row that we loop through. </font><font style="vertical-align: inherit;">That is, </font></font><code>_G['Rock']</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns a table containing the class definition </font></font><code>Rock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We looked at this in several parts of the tutorial, so you should already understand why this works. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For another condition, we need to select only those enemies that are within a certain radius from the projectile. </font><font style="vertical-align: inherit;">Through trial and error, I came to a radius of 400 units that is not small enough that the projectile could not find a suitable target, and not so large that the projectile too often tried to hit enemies behind the screen:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> targets = self.area:getAllGameObjectsThat(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, enemy <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(enemies) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e:is(<span class="hljs-built_in"><span class="hljs-built_in">_G</span></span>[enemy]) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (distance(ex, ey, self.x, self.y) &lt; <span class="hljs-number"><span class="hljs-number">400</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br> <code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is a function that we can define in </font></font><code>utils.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It returns the distance between two positions:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x1, y1, x2, y2)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And after that the enemies will have to be on the list </font></font><code>targets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Then the only thing we need is to choose one of them at random and indicate it as the </font></font><code>target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projectile is heading to:</font></font><br><br><pre> <code class="lua hljs">self.target = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">remove</span></span>(targets, love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, #targets))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And all this should look like this: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.collider:setLinearVelocity(self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r)) <span class="hljs-comment"><span class="hljs-comment">-- Homing if self.attack == 'Homing' then -- Acquire new target if not self.target then local targets = self.area:getAllGameObjectsThat(function(e) for _, enemy in ipairs(enemies) do if e:is(_G[enemy]) and (distance(ex, ey, self.x, self.y) &lt; 400) then return true end end end) self.target = table.remove(targets, love.math.random(1, #targets)) end if self.target and self.target.dead then self.target = nil end -- Move towards target if self.target then local projectile_heading = Vector(self.collider:getLinearVelocity()):normalized() local angle = math.atan2(self.target.y - self.y, self.target.x - self.x) local to_target_heading = Vector(math.cos(angle), math.sin(angle)):normalized() local final_heading = (projectile_heading + 0.1*to_target_heading):normalized() self.collider:setLinearVelocity(self.v*final_heading.x, self.v*final_heading.y) end end end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the end of the block, where we get a new target, there is an additional line in which we assign the </font></font><code>self.target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value nil in the case when the target is killed. Due to this, when the target for the projectile ceases to exist, the </font></font><code>self.target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value nil is assigned and a new target is obtained, because the condition will be satisfied </font></font><code>not self.target</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, after which the whole process is repeated. It is also important to mention that after receiving the goal, we do not do any more calculations, so there is no need to worry about the speed of the function </font></font><code>getAllGameObjectsThat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which naively bypasses in the loop all the living objects in the game. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next thing we need to change is the behavior of the object of the projectile when it is not self-guided or when the target is missing. It would be logical to use first</font></font><code>setLinearVelocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to set the velocity of the projectile, and then reuse it inside the cycle </font></font><code>if self.attack == 'Homing'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since the speed will only change if the projectile is actually homing and if there is a target. </font><font style="vertical-align: inherit;">But for some reason, this leads to all sorts of problems, so we have to call </font></font><code>setLinearVelocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only once, that is, write something like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- Homing if self.attack == 'Homing' then ... -- Normal movement else self.collider:setLinearVelocity(self.v*math.cos(self.r), self.v*math.sin(self.r)) end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's a bit more confusing than the previous one, but it works. </font><font style="vertical-align: inherit;">And if we test all this and create a shell, the attribute of </font></font><code>attack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which is assigned a value </font></font><code>'Homing'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then it should look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/943/e81/2e1/943e812e19f8062d03cc94aa28103c82.gif"></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">128. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the attack </font></font><code>Homing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Its definition in the attack table looks like this:</font></font><br><br><pre> <code class="lua hljs">attacks[<span class="hljs-string"><span class="hljs-string">'Homing'</span></span>] = {cooldown = <span class="hljs-number"><span class="hljs-number">0.56</span></span>, ammo = <span class="hljs-number"><span class="hljs-number">4</span></span>, abbreviation = <span class="hljs-string"><span class="hljs-string">'H'</span></span>, color = skill_point_color}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the attack itself will look like this: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dca/8e1/c6b/dca8e1c6bb5ea2ef867eb3974ea58d52.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that the projectile for this attack (as well as for the others we create) is slightly different. </font><font style="vertical-align: inherit;">This is a diamond, half painted white, half in the color of the attack (in this case </font></font><code>skill_point_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), which also has a track that has the color of the player.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The probability of firing a homing projectile in the selection of ammunition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can go to what we want to implement, namely to the passive skill associated with probability. This skill is likely to work when selecting a resource of ammunition. We will store this probability in a variable </font></font><code>launch_homing_projectile_on_ammo_pickup_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and when selecting a resource Ammo, we will call a function that ‚Äúthrows out on the dice‚Äù the probability of the event being executed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But before we can do this, we need to specify how we will process these probabilities. As I said in one of the previous parts, here we will also apply the concept of the list </font></font><code>chanceList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If an event has a probability of 5%, then we need to make sure that these 5% are observed fairly enough, so it is logical to use chanceList. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We do it like this: after calling a function</font></font><code>setStats</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the Player constructor, we will also call a function </font></font><code>generateChances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will create all the chanceList lists that apply throughout the game. Since the game will have many different events for which you need to ‚Äúroll a cube‚Äù, we will put all the chanceList lists in the table </font></font><code>chances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and arrange everything so that when we need to ‚Äúroll the cube‚Äù on the likelihood of doing something, we could do something like:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.chances.launch_homing_projectile_on_ammo_pickup_chance:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">-- launch homing projectile end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can set the table </font></font><code>chances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manually, that is, each time we add a new type variable </font></font><code>_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in which the probability of a certain event will be stored, we will also add and generate </font></font><code>generateChances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">its chanceList list </font><font style="vertical-align: inherit;">in the function </font><font style="vertical-align: inherit;">. But here we can do a little smarter and decide that every variable that deals with probabilities will end in </font></font><code>_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and use this to our advantage:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:generateChances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.chances = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k:<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(<span class="hljs-string"><span class="hljs-string">'_chance'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(v) == <span class="hljs-string"><span class="hljs-string">'number'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we go through all the key-value pairs inside the player's object and return true when we find the attribute containing the substring in the name </font></font><code>_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as well as being a number. If both of these conditions are true, then, based on our own decision, this is a variable related to the likelihood of an event. That is, we just need to create then the chanceList and add it to the table </font></font><code>chances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:generateChances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.chances = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k:<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(<span class="hljs-string"><span class="hljs-string">'_chance'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(v) == <span class="hljs-string"><span class="hljs-string">'number'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.chances[k] = chanceList({<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(v)}, {<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(v)}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we will create a chanceList of 100 values, </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of which will be true, and </font></font><code>100-v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- false. </font><font style="vertical-align: inherit;">That is, if the only ‚Äúprobability‚Äù type variable defined in the player's object was </font></font><code>launch_homing_projectile_on_ammo_pickup_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and it has a value of 5 (meaning a 5% probability of making an event), then chanceList will have 5 true values ‚Äã‚Äãand 95 false values, which gives us the desired result. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then if we call </font></font><code>generateChances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the player constructor:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- treeToPlayer(self) self:setStats() self:generateChances() end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then everything will work fine. </font><font style="vertical-align: inherit;">Now we can define a variable </font></font><code>launch_homing_projectile_on_ammo_pickup_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Chances self.launch_homing_projectile_on_ammo_pickup_chance = 0 end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if you want to test the operation of this ‚Äúdie roll‚Äù system, you can assign a value of 50 and call it several times </font></font><code>:next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to see what happens. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation of the shot will occur through the function </font></font><code>onAmmoPickup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is called when selecting the Ammo resource:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.collider:enter(<span class="hljs-string"><span class="hljs-string">'Collectable'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> object:is(Ammo) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> object:die() self:addAmmo(<span class="hljs-number"><span class="hljs-number">5</span></span>) self:onAmmoPickup() ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And this function will work as follows: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:onAmmoPickup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.chances.launch_homing_projectile_on_ammo_pickup_chance:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d = <span class="hljs-number"><span class="hljs-number">1.2</span></span>*self.w self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), {r = self.r, attack = <span class="hljs-string"><span class="hljs-string">'Homing'</span></span>}) self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'InfoText'</span></span>, self.x, self.y, {text = <span class="hljs-string"><span class="hljs-string">'Homing Projectile!'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a result, it will look like this: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/a76/e77/544a76e7730354c3610d16bab034ad67.gif"></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">129. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>regain_hp_on_ammo_pickup_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The amount of HP recovered will be 25. It should be added using a function </font></font><code>addHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that adds the specified amount of HP to the value </font></font><code>hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, checking that it does not exceed </font></font><code>max_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In addition, an object must be created </font></font><code>InfoText</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with text </font></font><code>'HP Regain!'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and color </font></font><code>hp_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">130. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>regain_hp_on_sp_pickup_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The amount of HP recovered will be 25. It should be added using a function </font></font><code>addHP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that adds the specified amount of HP to the value </font></font><code>hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, checking that it does not exceed </font></font><code>max_hp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. An object must also be created </font></font><code>InfoText</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with text </font></font><code>'HP Regain!'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and color </font></font><code>hp_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In addition, you need to add a function to the Player class.</font></font><code>onSPPickup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and all the work must be done in it (in the same way as it was with the function </font></font><code>onAmmoPickup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acceleration area </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following passive skills that we want to implement are ‚ÄúProbability of creating an acceleration area when selecting HP‚Äù and ‚ÄúProbability of creating an acceleration area when selecting SP‚Äù. </font><font style="vertical-align: inherit;">We already know how to implement the part ‚Äúwhen selecting a resource‚Äù, so we will focus on the ‚Äúarea of ‚Äã‚Äãacceleration‚Äù. </font><font style="vertical-align: inherit;">The field of acceleration is a simple circle that increases the speed of the player‚Äôs attacks while he is in it. </font><font style="vertical-align: inherit;">This acceleration of attack speed will be used as a multiplier, so it would be logical to start with an attack speed multiplier.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ASPD multiplier </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can define the ASPD multiplier simply as a variable </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and then multiply this variable by the time of the ‚Äúrespite‚Äù between shooting:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Multipliers self.aspd_multiplier = 1 end</span></span></code> </pre> <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Shoot self.shoot_timer = self.shoot_timer + dt if self.shoot_timer &gt; self.shoot_cooldown*self.aspd_multiplier then self.shoot_timer = 0 self:shoot() end end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main difference is that for this multiplier, smaller values ‚Äã‚Äãare better than big ones. </font><font style="vertical-align: inherit;">Usually, if the value of the multiplier is 0.5, then it reduces by half the parameter to which it is applied. </font><font style="vertical-align: inherit;">That is, for HP, the speed and almost everything else is bad. </font><font style="vertical-align: inherit;">However, for attack speeds, smaller values ‚Äã‚Äãare better, and this is easily explained by the code shown above. </font><font style="vertical-align: inherit;">Since we apply a multiplier to a variable </font></font><code>shoot_cooldown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, smaller values ‚Äã‚Äãmean that the pause will be shorter, that is, the player will shoot faster. </font><font style="vertical-align: inherit;">We use this knowledge when creating an object </font></font><code>HasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acceleration area </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have an ASPD multiplier, we can go back to the area. </font><font style="vertical-align: inherit;">Here we want to create a circular area that will decrease </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by a certain amount while the player is in it. </font><font style="vertical-align: inherit;">To achieve this, we will create a new object </font></font><code>HasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will control the logic to check whether the player is inside and set the appropriate values. </font><font style="vertical-align: inherit;">The basic structure of this object is as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasteArea:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.r = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">96</span></span>) self.timer:after(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.timer:tween(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, self, {r = <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasteArea:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasteArea:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(ammo_color) love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, self.x, self.y, self.r + <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)) love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To implement the logic of applying the effect, we need to track the player‚Äôs entry / exit from the area and change the value </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when it happens. </font><font style="vertical-align: inherit;">You can do it like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasteArea:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> player = current_room.player <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> player <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d = distance(self.x, self.y, player.x, player.y) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d &lt; self.r <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> player.inside_haste_area <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Enter event player:enterHasteArea() elseif d &gt;= self.r and player.inside_haste_area then -- Leave event player:exitHasteArea() end end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use a variable </font></font><code>inside_haste_area</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to track whether a player is in the area. This variable takes the value true inside </font></font><code>enterHasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and false inside </font></font><code>exitHasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, these functions will be called only when these events occur in the object </font></font><code>HasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In the Player class, both functions will simply apply the necessary modifications:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:enterHasteArea</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.inside_haste_area = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.pre_haste_aspd_multiplier = self.aspd_multiplier self.aspd_multiplier = self.aspd_multiplier/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:exitHasteArea</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.inside_haste_area = <span class="hljs-literal"><span class="hljs-literal">false</span></span> self.aspd_multiplier = self.pre_haste_aspd_multiplier self.pre_haste_aspd_multiplier = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, when a player enters an area, his attack speed doubles, and when he leaves an area, he returns to normal. One important point that is easy to miss here is that there is a temptation to put all the logic inside the object </font></font><code>HasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and not to link it with the player through a variable </font></font><code>inside_haste_area</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. We cannot do this because if we do, then problems will arise when the player simultaneously enters several areas at the same time or leaves them. In the current form, the existence of a variable </font></font><code>inside_haste_area</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means that we will apply the bonus only once, even if the player is on top of three intersecting HasteArea objects. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">131. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>spawn_haste_area_on_hp_pickup_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The object </font></font><code>InfoText</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must be created with text.</font></font><code>'Haste Area!'</code>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, you need to add a function to the Player class </font></font><code>onHPPickup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">132. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>spawn_haste_area_on_sp_pickup_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The object </font></font><code>InfoText</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must be created with text.</font></font><code>'Haste Area!'</code>  . <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The probability of creating an SP in a loop </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next effect will be </font></font><code>spawn_sp_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We fully know how to implement it. </font><font style="vertical-align: inherit;">The ‚Äúin cycle‚Äù part behaves very much like ‚Äúwhen selecting a resource‚Äù; </font><font style="vertical-align: inherit;">the only difference is that we will call the function </font></font><code>onCycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when executing a new cycle, and not when selecting a resource. </font><font style="vertical-align: inherit;">And the ‚Äúcreation of SP‚Äù part is just the creation of a new SP resource, the implementation of which is known to us. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, for the first part we need to enter the function </font></font><code>cycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and call </font></font><code>onCycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:cycle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self:onCycle() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we add a variable to the Player </font></font><code>spawn_sp_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Chances self.spawn_sp_on_cycle_chance = 0 end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And so we will also automatically add a new chanceList, which is the probability of this variable. </font><font style="vertical-align: inherit;">Thanks to this, we can add the functionality necessary functions </font></font><code>onCycle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:onCycle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.chances.spawn_sp_on_cycle_chance:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'SkillPoint'</span></span>) self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'InfoText'</span></span>, self.x, self.y, {text = <span class="hljs-string"><span class="hljs-string">'SP Spawn!'</span></span>, color = skill_point_color}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And this should work as intended: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8b/70f/10a/d8b70f10a702a930778d96c6888b644e.gif"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chance to shoot the line when killing an enemy </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next skill is </font></font><code>barrage_on_kill_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The only thing that we do not know yet is the part with the ‚Äúqueue‚Äù. </font><font style="vertical-align: inherit;">Triggering an event during a kill is similar to the previous one, except that instead of calling during the execution of a cycle, we will call the player‚Äôs function </font></font><code>onKill</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when the enemy dies. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, we first add a variable to the Player </font></font><code>barrage_on_kill_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Chances self.barrage_on_kill_chance = 0 end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we will create a function </font></font><code>onKill</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and call it when the enemy dies. There are two approaches to challenge </font></font><code>onKill</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when a player dies. The first is to simply call a function from a function </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>hit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">each enemy. The problem here is that when adding new enemies we will have to add the same calling code to all of them </font></font><code>onKill</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The second option is to challenge </font></font><code>onKill</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if there is a collision with an enemy of the object Projectile. The problem here is that some projectiles can collide with enemies, but not kill them (because enemies have more HP or a projectile does less damage), so we need to find a way to check if the enemy is actually dead. It turns out that performing this check is quite simple, so I will choose this method:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.collider:enter(<span class="hljs-string"><span class="hljs-string">'Enemy'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> object <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> object:hit(self.damage) self:die() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> object.hp &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> current_room.player:onKill() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only thing we need to do after calling the function of the </font></font><code>hit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enemy is simply to check if the enemy's HP is zero. If it is equal, then it means that he is dead, and we can call </font></font><code>onKill</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to the queue itself. By default, 8 shells will be fired at intervals of 0.05 seconds between shots ranging from-math.pi / 8 to + math.pi / 8. In addition, the projectiles of the queue will have an attack that the player has. That is, if a player shoots homing shells, then all the shells of the queue will also be homing. In the code, this can be written as:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:onKill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.chances.barrage_on_kill_chance:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> self.timer:after((i<span class="hljs-number"><span class="hljs-number">-1</span></span>)*<span class="hljs-number"><span class="hljs-number">0.05</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> random_angle = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(-<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d = <span class="hljs-number"><span class="hljs-number">2.2</span></span>*self.w self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r + random_angle), self.y + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r + random_angle), {r = self.r + random_angle, attack = self.attack}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'InfoText'</span></span>, self.x, self.y, {text = <span class="hljs-string"><span class="hljs-string">'Barrage!!!'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most of the code is pretty simple. The only thing worth mentioning is that we use the inside of the for loop </font></font><code>after</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to separate the creation of shells with a pause of 0.05 seconds. In all other respects, we simply create a projectile with given limitations. All this should look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/909/496/0b2/9094960b2b8def9194164d6935cbcdac.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the exercises below (and in all the others after them) do not forget to create objects </font></font><code>InfoText</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with the corresponding colors so that the player can understand what is happening. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">133. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>spawn_hp_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">134. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>regain_hp_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The number of recovered HP should be equal to 25. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">135. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>regain_full_ammo_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">136. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>change_attack_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. New attack is chosen randomly. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">137. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>spawn_haste_area_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">138. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>barrage_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">139. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill</font></font><code>launch_homing_projectile_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">140. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>regain_ammo_on_kill_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The number of recovered ammunition should be equal to 20. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">141. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>launch_homing_projectile_on_kill_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">142. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>regain_boost_on_kill_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The number of recovered acceleration should be equal to 40. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">143. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>spawn_boost_on_kill_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Getting Accelerated ASPD When Killing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have already implemented a passive skill similar to "Accelerating ASPD" using an object </font></font><code>HasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Now we want to implement another one in which we will have a chance to get an increase in the speed of attacks after killing an enemy. </font><font style="vertical-align: inherit;">However, if we try to implement it in the same way as the previous acceleration of ASPD, we will soon encounter problems. </font><font style="vertical-align: inherit;">To refresh your memories, I‚Äôll give an example of how acceleration is implemented in </font></font><code>HasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasteArea:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> HasteArea.super.update(self, dt) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> player = current_room.player <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> player <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d = distance(self.x, self.y, player.x, player.y) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d &lt; self.r <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> player.inside_haste_area <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> player:enterHasteArea() <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> d &gt;= self.r <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> player.inside_haste_area <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> player:exitHasteArea() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then </font></font><code>enterHasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they </font></font><code>exitHasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">look like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:enterHasteArea</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.inside_haste_area = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.pre_haste_aspd_multiplier = self.aspd_multiplier self.aspd_multiplier = self.aspd_multiplier/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:exitHasteArea</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.inside_haste_area = <span class="hljs-literal"><span class="hljs-literal">false</span></span> self.aspd_multiplier = self.pre_haste_aspd_multiplier self.pre_haste_aspd_multiplier = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we tried to implement the passive skill in the </font></font><code>aspd_boost_on_kill_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">same way, it would look something like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:onKill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.chances.aspd_boost_on_kill_chance:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.pre_boost_aspd_multiplier = self.aspd_multiplier self.aspd_multiplier = self.aspd_multiplier/<span class="hljs-number"><span class="hljs-number">2</span></span> self.timer:after(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.aspd_multiplier = self.pre_boost_aspd_multiplier self.pre_boost_aspd_multiplier = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we just do the same thing as haste in HasteArea. We save the current attack speed multiplier, reduce it by half, and then after a specified period of time (4 seconds in our case), restore the original value. The problem with this implementation arises when we want to combine the effect of these bonuses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine a situation in which a player entered HasteArea and then accelerated ASPD after killing an enemy. The problem here is that if a player leaves HasteArea before four seconds, then his variable </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be restored to the value before the ASPD accelerates, that is, when leaving the area, all other acceleration bonuses will speed up the attacks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also imagine that the player is actively accelerating ASPD and he is entering the HasteArea area. After the completion of the acceleration action, the HasteArea effect will also be reset, since it will </font></font><code>pre_boost_aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restore to a </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value that does not take into account the increase in the HasteArea attack speed. But more importantly, when the player leaves HasteArea, he will have a constantly increased attack speed, because the stored attack speed at the entrance will be that increased by the acceleration of ASPD. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, this problem can be solved by introducing several variables:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.base_aspd_multiplier = <span class="hljs-number"><span class="hljs-number">1</span></span> self.aspd_multiplier = <span class="hljs-number"><span class="hljs-number">1</span></span> self.additional_aspd_multiplier = {} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of one variable </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we will have </font></font><code>base_aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>additional_aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The variable </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will store the current factor taking into account all accelerations. </font></font><code>base_aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will contain the original multiplier, taking into account only the percentage increase. That is, if we get from the tree an increase in the attack speed by 50%, it will be applied in the constructor (c </font></font><code>setStats</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) to </font></font><code>base_aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Then it </font></font><code>additional_aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will contain all the added values ‚Äã‚Äãof all accelerations. That is, when the player is in HasteArea, we will add the corresponding value to this table, and then in each frame multiply its amount by the base. Therefore, for example, the update function will be as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.additional_aspd_multiplier = {} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.inside_haste_area <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.additional_aspd_multiplier, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.aspd_boosting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.additional_aspd_multiplier, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> aspd_sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, aspd <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.additional_aspd_multiplier) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> aspd_sum = aspd_sum + aspd <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.aspd_multiplier = self.base_aspd_multiplier/(<span class="hljs-number"><span class="hljs-number">1</span></span> - aspd_sum) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this method, in each frame we will recalculate the variable </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in accordance with the value of the base, as well as all the accelerations. </font><font style="vertical-align: inherit;">We will have a few more factors that function in a very similar way, so I will create a common object for this, since repeating the code with different variable names every time will be tedious. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The object </font></font><code>Stat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">looks like this:</font></font><br><br><pre> <code class="lua hljs">Stat = Object:extend() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stat:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(base)</span></span></span></span> self.base = base self.additive = <span class="hljs-number"><span class="hljs-number">0</span></span> self.additives = {} self.value = self.base*(<span class="hljs-number"><span class="hljs-number">1</span></span> + self.additive) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stat:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, additive <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.additives) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> self.additive = self.additive + additive <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.additive &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.value = self.base*(<span class="hljs-number"><span class="hljs-number">1</span></span> + self.additive) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.value = self.base/(<span class="hljs-number"><span class="hljs-number">1</span></span> - self.additive) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.additive = <span class="hljs-number"><span class="hljs-number">0</span></span> self.additives = {} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stat:increase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(percentage)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.additives, percentage*<span class="hljs-number"><span class="hljs-number">0.01</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stat:decrease</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(percentage)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.additives, -percentage*<span class="hljs-number"><span class="hljs-number">0.01</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And we use it to solve the problem of attack speed as follows: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.aspd_multiplier = Stat(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.inside_haste_area <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.aspd_multiplier:decrease(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.aspd_boosting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.aspd_multiplier:decrease(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.aspd_multiplier:update(dt) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will be able to access the attack speed multiplier at any time after the call </font></font><code>aspd_multiplier:update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, referring to </font></font><code>aspd_multiplier.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which will return the correct result in accordance with the base and all the possible accelerations. </font><font style="vertical-align: inherit;">Therefore, we must change the way the variable is used </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Shoot self.shoot_timer = self.shoot_timer + dt if self.shoot_timer &gt; self.shoot_cooldown*self.aspd_multiplier.value then self.shoot_timer = 0 self:shoot() end end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we simply replace </font></font><code>self.shoot_cooldown*self.aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on </font></font><code>self.shoot_cooldown*self.aspd_multiplier.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because otherwise it will not work anything. In addition, we have to change something else here. The way the variable works is </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so far contrary to how all the other variables of the game work. When we say that we have increased HP by 10%, we know that it </font></font><code>hp_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is equal to 1.1, but when we say that we have increased by 10% ASPD, it </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is actually equal to 0.9. We can change this and make it </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">behave in the same way as other variables, with the division instead of multiplying </font></font><code>shoot_cooldown</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.shoot_timer &gt; self.shoot_cooldown/self.aspd_multiplier.value <span class="hljs-keyword"><span class="hljs-keyword">then</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, if we get an increase in ASPD by 100%, then its value will be equal to 2 and we will halve the pause between shots, which is exactly what we achieved. </font><font style="vertical-align: inherit;">In addition, we need to change the way bonuses are applied and instead of calling for them </font></font><code>decrease</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will call </font></font><code>increase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.inside_haste_area <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.aspd_multiplier:increase(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.aspd_boosting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.aspd_multiplier:increase(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.aspd_multiplier:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, you need to remember that since it </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is an object </font></font><code>Stat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and not just a number, then when you implement the tree and import its values ‚Äã‚Äãinto the Player object, we will have to process them in a different way. </font><font style="vertical-align: inherit;">Therefore, in the above function, </font></font><code>treeToPlayer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will have to take this into account. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anyway, in this way we can easily implement correctly the ‚Äúgetting accelerated ASPD during a murder‚Äù:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Chances self.gain_aspd_boost_on_kill_chance = 0 end</span></span></code> </pre> <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:onKill</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.chances.gain_aspd_boost_on_kill_chance:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.aspd_boosting = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.timer:after(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.aspd_boosting = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'InfoText'</span></span>, self.x, self.y, {text = <span class="hljs-string"><span class="hljs-string">'ASPD Boost!'</span></span>, color = ammo_color}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can also remove functions </font></font><code>enterHasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>exitHasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and also slightly change the operation of the HasteArea object:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasteArea:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> HasteArea.super.update(self, dt) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> player = current_room.player <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> player <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d = distance(self.x, self.y, player.x, player.y) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d &lt; self.r <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> player.inside_haste_area = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> d &gt;= self.r <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> player.inside_haste_area = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of the complex logic that we used earlier, we simply set the </font></font><code>inside_haste_area</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Player object </font><font style="vertical-align: inherit;">attribute </font><font style="vertical-align: inherit;">to true or false depending on whether it is in the region, and then, due to the way we implemented the object </font></font><code>Stat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the application of the acceleration rate of attacks received from HasteArea will be performed automatically. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">144. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>mvspd_boost_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. ‚ÄúIncreasing MVSPD‚Äù gives the player a 50 percent increase in movement speed for 4 seconds. Also implement the variable </font></font><code>mvspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and multiply it in the appropriate place. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">145. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>pspd_boost_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. ‚ÄúIncreasing PSPD‚Äù gives the shells created by the player a 100 percent increase in speed by 4 seconds. Also, implement the variable</font></font><code>pspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and multiply it in the appropriate place. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">146. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>pspd_inhibit_on_cycle_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">‚ÄúReducing PSPD‚Äù gives the shells created by the player a 50 percent reduction in speed by 4 seconds.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> During acceleration </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following passive skills that we will implement are the latest skills such as ‚Äúwith probability of an event‚Äù. All the skills we considered earlier were related to the likelihood of accomplishing something at some event (killing, cycle, selecting a resource ...) and the following will not differ, because they will be probabilities of doing something during acceleration (Boost) ship. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, we implement </font></font><code>launch_homing_projectile_while_boosting_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It will work like this: there is a normal probability of a shot by a homing projectile, and this probability will be checked in the interval of 0.2 seconds when performing acceleration (Boost). This means that if we accelerate within 1 second, ‚Äúprobability cubes‚Äù will be thrown 5 times. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A good way to implement this is to define two new functions: </font></font><code>onBoostStart</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>onBoostEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">They will activate the passive skill at the start of acceleration and deactivate it at the end of acceleration. </font><font style="vertical-align: inherit;">To add these two functions, we need to change the acceleration code slightly:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Boost ... if self.boost_timer &gt; self.boost_cooldown then self.can_boost = true end ... if input:pressed('up') and self.boost &gt; 1 and self.can_boost then self:onBoostStart() end if input:released('up') then self:onBoostEnd() end if input:down('up') and self.boost &gt; 1 and self.can_boost then ... if self.boost &lt;= 1 then self.boosting = false self.can_boost = false self.boost_timer = 0 self:onBoostEnd() end end if input:pressed('down') and self.boost &gt; 1 and self.can_boost then self:onBoostStart() end if input:released('down') then self:onBoostEnd() end if input:down('down') and self.boost &gt; 1 and self.can_boost then ... if self.boost &lt;= 1 then self.boosting = false self.can_boost = false self.boost_timer = 0 self:onBoostEnd() end end ... end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we add </font></font><code>input:pressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>input:released</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that return true only when these events occur, and thanks to this we can be sure that </font></font><code>onBoostStart</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they </font></font><code>onBoostEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will only be called when these events occur. </font><font style="vertical-align: inherit;">We also add inside the conditional design </font></font><code>input:down</code> <code>onBoostEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in case the player does not release the button, but the amount of acceleration available to him ends, and therefore the acceleration ends. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to parts with </font></font><code>launch_homing_projectile_while_boosting_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Chances self.launch_homing_projectile_while_boosting_chance = 0 end function Player:onBoostStart() self.timer:every('launch_homing_projectile_while_boosting_chance', 0.2, function() if self.chances.launch_homing_projectile_while_boosting_chance:next() then local d = 1.2*self.w self.area:addGameObject('Projectile', self.x + d*math.cos(self.r), self.y + d*math.sin(self.r), {r = self.r, attack = 'Homing'}) self.area:addGameObject('InfoText', self.x, self.y, {text = 'Homing Projectile!'}) end end) end function Player:onBoostEnd() self.timer:cancel('launch_homing_projectile_while_boosting_chance') end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, at the beginning of acceleration, we call </font></font><code>timer:every</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to test the probability of firing a homing projectile every 0.2 seconds, and then, when the acceleration ends, we cancel this timer. Here is what it looks like when the probability of an event is 100%:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/091/d38/244/091d38244c3e1d81f1f09482009a748a.gif"></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">147. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement the variable </font></font><code>cycle_speed_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This variable, depending on its value, increases or decreases the speed of the cycle. That is, for example, if it </font></font><code>cycle_speed_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is equal to 2, and the cycle duration defaults to 5 seconds, then the use of a variable will lead to a decrease in the cycle duration to 2.5 seconds. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">148. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>increased_cycle_speed_while_boosting</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This variable should be of type boolean and signal whether the speed of the cycle should increase when the player performs the acceleration. Acceleration should be an increase in cycle speed multiplier by 200%. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">149. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill</font></font><code>invulnerability_while_boosting</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This variable is of type boolean and indicates whether the player should be invulnerable during acceleration. </font><font style="vertical-align: inherit;">Use the existing attribute </font></font><code>invincible</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is responsible for the invulnerability of the player.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Increased Acceleration Luck </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last type of passive ‚Äúon acceleration‚Äù skill that we will implement is ‚Äúincreased success on acceleration‚Äù. </font><font style="vertical-align: inherit;">Before implementing it, we need to implement a parameter </font></font><code>luck_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luck is one of the basic parameters of the game; </font><font style="vertical-align: inherit;">it increases the likelihood of performing the desired events. </font><font style="vertical-align: inherit;">Suppose we have a 10 percent chance of hitting a projectile with a kill. </font><font style="vertical-align: inherit;">If it </font></font><code>luck_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is equal to 2, then this probability becomes 20 percent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The way the skill is implemented is extremely simple. </font><font style="vertical-align: inherit;">All passive ‚Äúprobability‚Äù skills pass through a function </font></font><code>generateChances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so we can simply implement it here:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:generateChances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.chances = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(self) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k:<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(<span class="hljs-string"><span class="hljs-string">'_chance'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(v) == <span class="hljs-string"><span class="hljs-string">'number'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.chances[k] = chanceList( {<span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(v*self.luck_multiplier)}, {<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(v*self.luck_multiplier)}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here we just multiply </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by </font></font><code>luck_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and it should work exactly as it should. </font><font style="vertical-align: inherit;">Due to this, we can realize the passive skill </font></font><code>increased_luck_while_boosting</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:onBoostStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.increased_luck_while_boosting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.luck_boosting = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.luck_multiplier = self.luck_multiplier*<span class="hljs-number"><span class="hljs-number">2</span></span> self:generateChances() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:onBoostEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.increased_luck_while_boosting <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.luck_boosting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.luck_boosting = <span class="hljs-literal"><span class="hljs-literal">false</span></span> self.luck_multiplier = self.luck_multiplier/<span class="hljs-number"><span class="hljs-number">2</span></span> self:generateChances() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we implement it as originally done for the object </font></font><code>HasteArea</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. We can do it now because we will not have any other passive skills that give the player an increase in luck, that is, we don‚Äôt need to worry about a few bonuses that can override each other. If we had a few passive skills that give an increase in luck, we would have to make them an object </font></font><code>Stat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as was the case with </font></font><code>aspd_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, it is important that when changing the luck multiplier, we also re-call</font></font><code>generateChances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otherwise, our increase in luck will not affect anything. </font><font style="vertical-align: inherit;">Such a solution has a flaw - all lists are reset, so if a list accidentally selected a series of unsuccessful ‚Äúthrows‚Äù and then was reset, then again it can re-select a series of unsuccessful ‚Äúthrows‚Äù instead of using the chanceList property, in which over time the selection of less successful shots becomes less likely. </font><font style="vertical-align: inherit;">But this is a very frivolous problem, which personally does not bother me very much.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> HP creation probability multiplier </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we will consider </font></font><code>hp_spawn_chance_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which increases the likelihood that when the director creates a new resource, this resource will be HP. </font><font style="vertical-align: inherit;">If you remember how the director works, then this implementation will be pretty simple:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Multipliers self.hp_spawn_chance_multiplier = 1 end</span></span></code> </pre> <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.resource_spawn_chances = chanceList({<span class="hljs-string"><span class="hljs-string">'Boost'</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>}, {<span class="hljs-string"><span class="hljs-string">'HP'</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>*current_room.player.hp_spawn_chance_multiplier}, {<span class="hljs-string"><span class="hljs-string">'SkillPoint'</span></span>, <span class="hljs-number"><span class="hljs-number">58</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Part 9, we looked at creating the probability of spawn for each of the resources. These probabilities are stored in the chanceList </font></font><code>resource_spawn_chances</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so all we need is to use </font></font><code>hp_spawn_chance_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to increase the likelihood that the HP resource will be created in accordance with the multiplier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, it is important to initialize in the Stage room of the director after the Player, since the Director depends on the variables of the Player, while the Player does not depend on the Director at all. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">150. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>spawn_sp_chance_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">151. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>spawn_boost_chance_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Given all that we have implemented earlier, the following exercises may seem difficult. I did not consider most of the aspects of their implementation, but they are quite simple compared to what we did earlier, so they are easy to write. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">152. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>drop_double_ammo_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When an enemy dies, there must be a chance that he will create two Ammo objects instead of one. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">153. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>attack_twice_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When a player attacks, there must be a probability of calling the function </font></font><code>shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twice. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">154. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>spawn_double_hp_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When a director creates an HP resource, there must be a chance that instead of one, he will create two HP objects. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">155. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement a passive skill </font></font><code>spawn_double_sp_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a director creates a SkillPoint resource, there must be a chance that he will create two instead of one SkillPoint object. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">156. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>gain_double_sp_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When a player selects a SkillPoint resource, there must be a chance that he will get two skill points instead of one.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The frequency of creating enemies </font></font></h3><br> <code>enemy_spawn_rate_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will control how quickly Director changes the difficulty levels. </font><font style="vertical-align: inherit;">By default, this happens every 22 seconds, but if it </font></font><code>enemy_spawn_rate_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is 2, then it will happen every 11 seconds. </font><font style="vertical-align: inherit;">The implementation of this is also quite simple:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Multipliers self.enemy_spawn_rate_multiplier = 1 end</span></span></code> </pre> <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Director:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Difficulty self.round_timer = self.round_timer + dt if self.round_timer &gt; self.round_duration/self.stage.player.enemy_spawn_rate_multiplier then ... end end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, here we simply divide </font></font><code>round_duration</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by </font></font><code>enemy_spawn_rate_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to get the desired duration of the round. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">157. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>resource_spawn_rate_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">158. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>attack_spawn_rate_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And there will be more exercises on other passive skills. Basically, these are multipliers that cannot be attributed to any class of passive skills we have discussed above, but they should be fairly easy to implement. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">159. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>turn_rate_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This passive skill increases or decreases the turning speed of a player‚Äôs ship. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">160. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill</font></font><code>boost_effectiveness_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This passive skill increases or decreases acceleration effectiveness. This means that if a variable has a value of 2, then acceleration will work twice as fast or slower. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">161. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>projectile_size_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is a passive skill that increases or decreases the size of projectiles. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">162. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>boost_recharge_rate_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is a passive skill that increases or decreases the acceleration recharge rate. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">163. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>invulnerability_time_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is a passive skill that increases or decreases the player‚Äôs invulnerability time when damage is dealt. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">164. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill</font></font><code>ammo_consumption_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This passive skill increases or decreases the amount of ammunition consumed during all attacks. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">165. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>size_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This passive skill increases or decreases the size of the player‚Äôs ship. </font><font style="vertical-align: inherit;">It should be noted that the positions of all traces of all ships, as well as the positions of projectiles must be changed accordingly. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">166. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>stat_boost_duration_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This passive skill increases or decreases the duration of the time bonuses given to the player.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shells passive skills </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we look at a few passive projectile skills. </font><font style="vertical-align: inherit;">These passive skills will fundamentally change the behavior of our shells. </font><font style="vertical-align: inherit;">The same ideas can also be implemented in the object </font></font><code>EnemyProjectile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, after which we will be able to create enemies using some of these skills. </font><font style="vertical-align: inherit;">For example, there is a passive skill that causes projectiles to rotate around a ship, rather than fly straight. </font><font style="vertical-align: inherit;">Later we will add an enemy around whom piles of shells will fly, and in both cases the same technology will be used.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 90 degree change </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will call this passive skill </font></font><code>projectile_ninety_degree_change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">He will periodically change the angle of the projectile to 90 degrees. </font><font style="vertical-align: inherit;">It will look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bc/930/d17/4bc930d17f44a22ed172b0533563c539.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that the projectile moves approximately in the same direction in which it moved when fired, but the angle quickly changes by 90 degrees each time. This means that changing the angle is not completely random, and we need to think about it well. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simple way is to make a </font></font><code>projectile_ninety_degree_change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boolean variable that will affect when true. Since we are going to apply this effect in the class </font></font><code>Projectile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we have two options on how to read the value from it </font></font><code>projectile_ninety_degree_change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the Player: either transfer it to the table </font></font><code>opts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when creating a new projectile as a function </font></font><code>shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or read it directly from the Player, accessing through</font></font><code>current_room.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I will take the second path, because it is simpler and there are no serious flaws in it, except that we will have to replace </font></font><code>current_room.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it with something else when we move part of this code to </font></font><code>EnemyProjectile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">All this will look something like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Booleans self.projectile_ninety_degree_change = false end</span></span></code> </pre> <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_room.player.projectile_ninety_degree_change <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to change the projectile angle by 90 degrees each time within the conventional design of the Projectile constructor, but also take into account its original direction. </font><font style="vertical-align: inherit;">The first thing we can do is randomly change the angle to either 90 or -90 degrees. </font><font style="vertical-align: inherit;">It will look like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_room.player.projectile_ninety_degree_change <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.timer:after(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.ninety_degree_direction = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>({<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}) self.r = self.r + self.ninety_degree_direction*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ed/d6b/0d6/7edd6b0d66babb8178e9f53e6d539190.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we need to figure out how to turn the projectile in a different direction, and then turn it back in another, and then again, and so on. </font><font style="vertical-align: inherit;">Since this is a periodic action, repeated infinitely, we can use </font></font><code>timer:every</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_room.player.projectile_ninety_degree_change <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.timer:after(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.ninety_degree_direction = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>({<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}) self.r = self.r + self.ninety_degree_direction*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> self.timer:every(<span class="hljs-string"><span class="hljs-string">'ninety_degree_first'</span></span>, <span class="hljs-number"><span class="hljs-number">0.25</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.r = self.r - self.ninety_degree_direction*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> self.timer:after(<span class="hljs-string"><span class="hljs-string">'ninety_degree_second'</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.r = self.r - self.ninety_degree_direction*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> self.ninety_degree_direction = <span class="hljs-number"><span class="hljs-number">-1</span></span>*self.ninety_degree_direction <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we turn the projectile in the direction opposite to the initial rotation, that is, now it is directed at the initial angle. </font><font style="vertical-align: inherit;">Then, after only 0.1 seconds, we turn it again in the same direction, so that it is directed in the opposite direction to the first turn. </font><font style="vertical-align: inherit;">If at first he was directed to the right when fired, then the following happens: after 0.2 seconds he turns up, after 0.25 seconds again to the right, after 0.1 seconds - down, and then after 0.25 seconds he repeats the process, turning first to the right, then up, then down , and so on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also important that at the end of each cycle</font></font><code>every</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we change the direction in which it should turn, otherwise it will not fluctuate between the up / down directions and will move up / down rather than in a straight line. </font><font style="vertical-align: inherit;">By implementing this, we get the following:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/317/c90/af8/317c90af8a168adb3ef152e5f12fe8e3.gif"></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">167. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>projectile_random_degree_change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that changes the angle of the projectile at random. </font><font style="vertical-align: inherit;">Unlike turns at 90 degrees, shells in this case should not restore their original direction. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">168. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>angle_change_frequency_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This skill increases or decreases the rate of change of the angles of the previous two passive skills. </font><font style="vertical-align: inherit;">If </font></font><code>angle_change_frequency_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, for example, is 2, then instead of changing the angles after 0.25 and 0.1 seconds, they will change after 0.125 and 0.05 seconds.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wave shells </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of intermittently changing the angle of the projectile, we can do it smoothly using the function </font></font><code>timer:tween</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, thus obtaining the effect of a wave projectile:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/486/72d/3c1/48672d3c1a6609cb0688e0c00a044b31.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idea here is almost the same as in the previous examples, only using </font></font><code>timer:tween</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_room.player.wavy_projectiles <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> direction = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>({<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}) self.timer:tween(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, self, {r = self.r + direction*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>}, <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.timer:tween(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, self, {r = self.r - direction*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>}, <span class="hljs-string"><span class="hljs-string">'linear'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) self.timer:every(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.timer:tween(<span class="hljs-number"><span class="hljs-number">0.25</span></span>, self, {r = self.r + direction*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>}, <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.timer:tween(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, self, {r = self.r - direction*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>}, <span class="hljs-string"><span class="hljs-string">'linear'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because of how it works </font></font><code>timer:every</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in the code it does not begin to perform its functions until the end of the initial time, so we first perform one iteration of the loop manually, and then execute each loop. </font><font style="vertical-align: inherit;">In the first iteration, we also use the initial value of math.pi / 8 instead of math.pi / 4, because we want the projectile to oscillate two times smaller than necessary, because it is initially in the middle position (as it was just shot Player), and not on one of the oscillation boundaries. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">169. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>projectile_waviness_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This skill increases or decreases the target angle that the projectile should reach when performing tween. </font><font style="vertical-align: inherit;">For example, if If </font></font><code>projectile_waviness_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is 2, then the arc of its trajectory will be twice the normal.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acceleration and braking of shells </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we turn to several passive skills that change the speed of the projectile. </font><font style="vertical-align: inherit;">The first is ‚ÄúFast -&gt; Slow‚Äù, and the second ‚ÄúSlow -&gt; Fast‚Äù, that is, the projectile starts at a high or low speed and then goes to low or high speed. </font><font style="vertical-align: inherit;">Here‚Äôs what ‚ÄúFast -&gt; Slow‚Äù looks like:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/c93/dfa/c7dc93dfacbdcde98e4a159c80d82733.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We implement it in a rather simple way. </font><font style="vertical-align: inherit;">The skill ‚ÄúFast -&gt; Slow‚Äù is realized by a fast tween speed with a doubling of the initial value, and then after some time a decrease in tween to half the initial value. </font><font style="vertical-align: inherit;">And for another skill, we just do the reverse operation.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_room.player.fast_slow <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> initial_v = self.v self.timer:tween(<span class="hljs-string"><span class="hljs-string">'fast_slow_first'</span></span>, <span class="hljs-number"><span class="hljs-number">0.2</span></span>, self, {v = <span class="hljs-number"><span class="hljs-number">2</span></span>*initial_v}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.timer:tween(<span class="hljs-string"><span class="hljs-string">'fast_slow_second'</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>, self, {v = initial_v/<span class="hljs-number"><span class="hljs-number">2</span></span>}, <span class="hljs-string"><span class="hljs-string">'linear'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_room.player.slow_fast <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> initial_v = self.v self.timer:tween(<span class="hljs-string"><span class="hljs-string">'slow_fast_first'</span></span>, <span class="hljs-number"><span class="hljs-number">0.2</span></span>, self, {v = initial_v/<span class="hljs-number"><span class="hljs-number">2</span></span>}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.timer:tween(<span class="hljs-string"><span class="hljs-string">'slow_fast_second'</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>, self, {v = <span class="hljs-number"><span class="hljs-number">2</span></span>*initial_v}, <span class="hljs-string"><span class="hljs-string">'linear'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">170. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>projectile_acceleration_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This skill controls the amount of acceleration as the speed increases from the original value. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">171. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a passive skill </font></font><code>projectile_deceleration_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This skill controls the amount of inhibition when the speed decreases from the initial value.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shield shells </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will be a bit more difficult to realize them, because there are more moving parts in them. </font><font style="vertical-align: inherit;">The end result should look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/393/bd3/7c8/393bd37c80b6ef3b81c74f55c28da05e.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, the shells revolve around the player and borrow his direction of movement. </font><font style="vertical-align: inherit;">We can do this with the </font></font><a href="http://mathworld.wolfram.com/ParametricEquations.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parametric equation of a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> circle. </font><font style="vertical-align: inherit;">In general, if we want A to rotate around B with a certain radius R, then we can do something like this:</font></font><br><br><pre> <code class="lua hljs">Ax = Bx + R*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>) Ay = By + R*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">time</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where </font></font><code>time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a variable whose value increases with time. </font><font style="vertical-align: inherit;">Before proceeding with the implementation, let's prepare everything else. </font></font><code>shield_projectile_chance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the variable will not be a boolean, but a variable of the ‚Äúprobability‚Äù type, that is, each time a new projectile is created, there will appear a probability that it will begin to rotate around the player.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Chances self.shield_projectile_chance = 0 end function Player:shoot() ... local shield = self.chances.shield_projectile_chance:next() if self.attack == 'Neutral' then self.area:addGameObject('Projectile', self.x + 1.5*d*math.cos(self.r), self.y + 1.5*d*math.sin(self.r), {r = self.r, attack = self.attack, shield = shield}) ... end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we define a variable </font></font><code>shield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for which the die rolls on whether this projectile should rotate around the player, after which we transfer it to the </font></font><code>opts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">challenge </font><font style="vertical-align: inherit;">table </font></font><code>addGameObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here we need to repeat this step for each of the available attacks. </font><font style="vertical-align: inherit;">Since we will have similar changes in the future, we can do something like this instead:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> mods = { shield = self.chances.shield_projectile_chance:<span class="hljs-built_in"><span class="hljs-built_in">next</span></span>() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.attack == <span class="hljs-string"><span class="hljs-string">'Neutral'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.merge({r = self.r, attack = self.attack}, mods)) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, in the future it will be enough for us to add everything to the table </font></font><code>mods</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The function </font></font><code>table.merge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is not yet defined, but based on how we use it here, you can guess what it does.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">table.merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t1, t2)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> new_table = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(t2) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> new_table[k] = v <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(t1) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> new_table[k] = v <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new_table <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It simply merges the two tables with their values ‚Äã‚Äãinto a new one, and then returns it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can proceed to the implementation of the functional itself </font></font><code>shield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">First, we want to define variables such as radius, rotational speed, and so on. </font><font style="vertical-align: inherit;">For now, I define them as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.shield <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.orbit_distance = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>) self.orbit_speed = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) self.orbit_offset = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br> <code>orbit_distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denotes the radius around the player. </font></font><code>orbit_speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be multiplied by </font></font><code>time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, at larger absolute values, the projectile will move faster, and at smaller values, it will move more slowly. Negative values ‚Äã‚Äãcause the projectile to move in a different direction, which adds a bit of randomness. </font></font><code>orbit_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- this is the initial angular displacement that each projectile has. It also adds a bit of randomness and does not allow all shells to be created in approximately one position. And now, when we have determined all this, we can apply the parametric equation of a circle to the position of the projectile:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Shield if self.shield then local player = current_room.player self.collider:setPosition( player.x + self.orbit_distance*math.cos(self.orbit_speed*time + self.orbit_offset), player.y + self.orbit_distance*math.sin(self.orbit_speed*time + self.orbit_offset)) end ... end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to insert this code after all other calls that can be used for </font></font><code>setLinearVelocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, otherwise nothing will work. </font><font style="vertical-align: inherit;">We also need to remember to add a global variable </font></font><code>time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and increment it in each frame by </font></font><code>dt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If we do everything right, it will look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e8/2e6/e92/2e82e6e92f35759a5cd46251b73cf81d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The task is completed, but it looks all not quite right. </font><font style="vertical-align: inherit;">The most incorrect thing is that when rotating around a player, the angles of the shells are not taken into account. </font><font style="vertical-align: inherit;">One way to fix this is to store the last frame of the projectile position and get the angle of the vector that constitutes the subtraction from the current position of the previous position. </font><font style="vertical-align: inherit;">The code is worth a thousand words, so let's better see what it looks like:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.previous_x, self.previous_y = self.collider:getPosition() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Shield if self.shield then ... local x, y = self.collider:getPosition() local dx, dy = x - self.previous_x, y - self.previous_y self.r = Vector(dx, dy):angle() end ... -- At the very end of the update function self.previous_x, self.previous_y = self.collider:getPosition() end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we set a variable </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in which the angle of the projectile will be stored, taken into account during rotation. </font><font style="vertical-align: inherit;">Since we use </font></font><code>setLinearVelocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this angle, when the projectile is drawn in </font></font><code>Projectile:draw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and used </font></font><code>Vector(self.collider:getLinearVelocity()):angle())</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to get direction, everything will be set according to how the variable is set </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And all this will look like this:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/811/e58/287/811e58287114574cf53eb3ada8ad0440.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now everything looks right. </font><font style="vertical-align: inherit;">In the GIF shown above, one small problem can be noticed - after firing shells, when they turn into shield shells, they do not do this instantly. </font><font style="vertical-align: inherit;">For 1-2 frames, they look like ordinary shells, and then disappear and appear, already rotating around the player. </font><font style="vertical-align: inherit;">One way to solve this problem is to simply hide all shield shells for 1-2 frames, and then display them:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.shield <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... self.invisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.timer:after(<span class="hljs-number"><span class="hljs-number">0.05</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.invisible = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.invisible <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And finally, shields will be too powerful weapons if they exist permanently, until they collide with the enemy, so we need to add the lifetime of the projectile, after which it must be destroyed: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.shield <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... self.timer:after(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thus, after 6 seconds of existence, the shield shells will be destroyed. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> END </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will end there, because the editor in which I am writing this article starts to slow down due to its volume. </font><font style="vertical-align: inherit;">In the next part, we will continue to implement other passive skills, as well as add all player attacks, enemies, and associated passive skills. </font><font style="vertical-align: inherit;">In addition, the next part will be the completion of the implementation of all the content of the game. </font><font style="vertical-align: inherit;">All other parts after it will consider displaying this content to the player (SkillTree and Console rooms).</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you like this series of tutorials, then you can stimulate me to write something similar in the future: </font></font><br><br><ul><li> <a href="http://store.steampowered.com/app/760330/BYTEPATH/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BYTEPATH game on Steam</font></font></a> </li><li> <a href="https://ssygen.itch.io/bytepath-tutorial" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BYTEPATH tutorial on itch.io</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By purchasing a tutorial on itch.io, you will have access to the complete source code of the game, answers to the exercises from parts 1-9, the code broken into parts of the tutorial (the code will look like it should look at the end of each part) and the key games on Steam. </font></font></div><p>Source: <a href="https://habr.com/ru/post/350316/">https://habr.com/ru/post/350316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350306/index.html">FastTrack Training. "Network Basics". "Area of ‚Äã‚Äãuse of network switches, the value of Cisco switches". Eddie Martin</a></li>
<li><a href="../350308/index.html">Graphs of the message of the President of the Russian Federation 2018</a></li>
<li><a href="../350310/index.html">Web application caching and performance</a></li>
<li><a href="../350312/index.html">How to make friends Siri and Xiaomi</a></li>
<li><a href="../350314/index.html">The PVS-Studio 6.22 static code analyzer is adapted for ARM compilers (Keil, IAR)</a></li>
<li><a href="../350318/index.html">There is a job for chatbot: virtual assistant help desk</a></li>
<li><a href="../350320/index.html">Rocket straight in the AppStore</a></li>
<li><a href="../350322/index.html">Gentleman's set in the field of marketing and sales of the company-developer of custom software</a></li>
<li><a href="../350324/index.html">Unity 2018 and ProBuilder: create, edit and texture 3D models directly in the editor</a></li>
<li><a href="../350326/index.html">Cheat Sheet for Technical Interview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>