<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Read datasheets 2: SPI on STM32; PWM, timers and interrupts on STM8</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part, I tried to tell hobby electronics engineers who grew out of Arduino's pants, how and why they should read datasheets and other docu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Read datasheets 2: SPI on STM32; PWM, timers and interrupts on STM8</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/zz/sh/fd/zzshfdfytuphbmlregcazfpxo2a.jpeg"></p><br><p>  In the <a href="https://habr.com/ru/company/skyeng/blog/449624/">first part,</a> I tried to tell hobby electronics engineers who grew out of Arduino's pants, how and why they should read datasheets and other documentation for microcontrollers.  The text was great, so I promised to show practical examples in a separate article.  Well, he called himself a load ... </p><br><p>  Today, I will show you how to solve fairly simple but necessary tasks for many projects on STM32 (Blue Pill) and STM8 controllers using datasheets.  All demo projects are dedicated to my favorite LEDs, we will light them in large quantities, for which you will have to use any interesting peripherals. </p><a name="habracut"></a><br><p>  The text was again huge, so for convenience I make the content: </p><br><p>  <a href="https://habr.com/ru/company/skyeng/blog/456094/">STM32 Blue Pill: 16 LEDs with DM634 driver</a> <br>  <a href="https://habr.com/ru/company/skyeng/blog/456094/">STM8: Configuring Six PWM Pins</a> <br>  <a href="https://habr.com/ru/company/skyeng/blog/456094/">STM8: 8 RGB LEDs on three pins, interrupts</a> </p><br><p>  <em>Disclaimer: I am not an engineer, I do not pretend to have a deep knowledge of electronics, the article is intended for fans like me.</em>  <em>In fact, as a target audience, I considered myself two years ago.</em>  <em>If someone told me then that datasheets on an unfamiliar chip are not terrible to read, I would not have spent a lot of time looking for some pieces of code on the Internet and inventing crutches with scissors and adhesive tape.</em> </p><br><p>  <em>The focus of this article is datasheets, not projects, so the code may not be too coiffed and often broken.</em>  <em>The projects themselves are very simple, although they are suitable for the first acquaintance with a new chip.</em> </p><br><p>  <em>I hope that my article will help someone at a similar stage of immersion in a hobby.</em> </p><br><h1 id="stm32">  STM32 </h1><br><h1 id="16-svetodiodov-c-dm634-i-spi">  16 LEDs with DM634 and SPI </h1><br><p>  A small project using the Blue Pill (STM32F103C8T6) and the DM634 LED driver.  With the help of datasheets, we will deal with the driver, STM IO-ports and configure SPI. </p><br><h2 id="dm634">  DM634 </h2><br><p>  A Taiwanese chip with 16 16-bit PWM outputs can be chained together.  The younger 12-bit model is known from the domestic <a href="https://lightpack.tv/">Lightpack</a> project.  At one time, choosing between the DM63x and the well-known TLC5940, I stopped at the DM for several reasons: 1) TLC on Aliexpress is fake, but this one is not;  2) DM has autonomous PWM with its own frequency generator;  3) it was cheap to buy in Moscow, and not wait for a parcel with Ali.  And, of course, it was interesting to learn how to manage the chip yourself, and not to use a ready-made library.  The chips are now mainly represented in the SSOP24 package, they are easy to solder onto the adapter. </p><br><p>  Since the manufacturer is Taiwanese, the chip <a href="http://www.siti.com.tw/product/spec/LED/SP-DM634-A.004.pdf">datasheet is</a> written in Chinese English, which means it will be fun.  First we look at the pinout ( <em>Pin Connection</em> ) in order to understand which leg to connect to and pin description ( <em>Pin Description</em> ).  16 conclusions: </p><br><p><img src="https://habrastorage.org/webt/uj/n8/mo/ujn8mooelrxoxg7xzvvfsdh4er8.png"><br>  <sup>Sources of inflowing direct current (open drain)</sup> </p><br><p>  <strong>Sink</strong> / <strong>Open-drain output</strong> - drain;  source of inflowing current;  the output, which is actively connected to ground, - LEDs are connected to the driver by cathodes.  Electrically, this is, of course, no ‚Äúopen drain‚Äù ( <em>open drain</em> ), but in datasheets such a designation for conclusions in drain mode is common. </p><br><p><img src="https://habrastorage.org/webt/yk/bq/p4/ykbqp4ivabirkgahd2d7l_9gjny.png"><br>  <sup>External resistors between REXT and GND for setting the output current value</sup> </p><br><p>  A reference resistor is installed between the pin REXT and ground, which controls the internal resistance of the outputs, see the graph on page 9 of the datasheet.  In DM634, this resistance can also be controlled programmatically by setting the <em>global brightness</em> ( <em>global brightness</em> );  I will not go into details in this article, I‚Äôll just put a 2.2-3k ohm resistor here. </p><br><p>  To understand how to control the chip, look at the description of the device interface: </p><br><p><img src="https://habrastorage.org/webt/7s/5n/to/7s5ntogguqr1yb6fu2l5pchaob8.png"></p><br><p>  Yeah, here he is, Chinese English in all its glory.  It is problematic to translate, you can understand if you wish, but there is another way - to look at how the connection in the datasheet to the functionally close TLC5940 is described: </p><br><p><img src="https://habrastorage.org/webt/qi/za/j2/qizaj2wq08ppbzehiszsd2spqz8.png"><br>  <sub>... Only three pins are required to enter data into the device.</sub>  <sub>The leading edge of the SCLK signal shifts the data from the SIN pin to the internal register.</sub>  <sub>After all data is loaded, a short high XLAT signal captures the sequentially transmitted data in internal registers.</sub>  <sub>Internal registers are triggered by the signal level of the XLAT gate valve.</sub>  <sub>All data is transmitted by the high bit forward.</sub> </p><br><p>  <strong>Latch</strong> - a latch / a latch / a clamp. <br>  <strong>Rising edge</strong> - the leading edge of the pulse <br>  <strong>MSB first</strong> - the leading (leftmost) bit forward. <br>  <strong>to clock data</strong> - transfer data sequentially (bit by bit). </p><br><p>  The word <em>latch is</em> often found in the documentation for the chips and is translated variously, so for understanding I will allow myself </p><div class="spoiler">  <b class="spoiler_title">small educational program</b> <div class="spoiler_text">  The LED driver is essentially a shift register.  The ‚Äúshift‚Äù ( <em>shift</em> ) in the title is a bit-wise movement of data inside the device: each new bit is thrust inside the bit and shoves the whole chain ahead of it.  Since during the shift no one wants to observe the chaotic flashing of the LEDs, the process takes place in the buffer registers separated from the workers by the <em>latch</em> - a kind of waiting room where the bits are arranged in the correct sequence.  When everything is ready, the flap opens and the bits are sent to work, replacing the previous batch.  The word <em>latch</em> in the documentation for the chips almost always implies such a valve, in whatever combinations it is used. </div></div><br><p> So, the data transfer in DM634 is carried out as follows: set the DAI input to the value of the high bit of the far LED, pull DCK up and down;  set the DAI input to the next bit value, pull the DCK;  and so on, until all the bits have been transmitted ( <em>clocked in</em> ), after which we pull the LAT.  This can be done manually ( <em>bit-bang</em> ), but it is better to use the specially designed SPI interface, since it is presented on our STM32 in two copies. </p><br><h2 id="sinyaya-tabletka-stm32f103">  Blue Tablet STM32F103 </h2><br><p>  Introductory: STM32 controllers are much more complicated than Atmega328 than they can frighten.  At the same time, for reasons of power saving, at the start almost all peripherals are turned off, and the clock frequency is 8 MHz from an internal source.  Fortunately, the STM programmers wrote the code that brings the chip to the ‚Äúcalculated‚Äù 72 MHz, and the authors of all the IDEs I know included it in the initialization procedure, so we don‚Äôt need clocking (but <a href="http://easyelectronics.ru/arm-uchebnyj-kurs-taktovyj-generator-stm32.html">it is possible if we really want to</a> ).  But you have to turn on the periphery. </p><br><p>  Documentation: on the Blue Pill, the popular STM32F103C8T6 chip is installed, there are two useful documents for it: </p><br><ul><li>  <a href="https://www.st.com/resource/en/datasheet/stm32f103c8.pdf">Data Sheet</a> for STM32F103x8 and STM32F103xB microcontrollers; </li><li>  <a href="https://www.st.com/resource/en/reference_manual/cd00171190.pdf">Reference Manual</a> for the entire line of STM32F103 and not only. </li></ul><br><p>  In the datasheet we may be interested in: </p><br><ul><li>  Pinouts - pinouts of chips - in case we decide to make the boards ourselves; </li><li>  Memory Map - a memory card for a specific chip.  The Reference Manual has a map for the entire line, it contains registers that are not on ours. </li><li>  Pin Definitions table - lists the main and alternative functions of the pins;  For the ‚Äúblue pill‚Äù on the Internet, you can find more convenient pictures with a list of pins and their functions.  Therefore, immediately google Blue Pill pinout and keep just such a picture at hand: </li></ul><br><p><img src="https://habrastorage.org/webt/_q/q_/o4/_qq_o4hwzc3k1nzqluqtaqpuye0.png"><br>  <em>NB: in the picture from the Internet there was an error noticed in the comments, thanks for that.</em>  <em>The picture has been replaced, but this is a lesson - it‚Äôs better to check information from datasheets.</em> </p><br><p>  Datashit remove, open the Reference Manual, now use only him. <br>  Procedure: deal with standard I / O, configure SPI, turn on the required peripherals. </p><br><h3 id="vvod-vyvod">  Input Output </h3><br><p>  Atmega328 I / O is extremely easy to implement, which is why the abundance of STM32 options can be confusing.  Now we need only conclusions, but even they have four options: </p><br><p><img src="https://habrastorage.org/webt/qv/ao/t6/qvaot6ql0b4z6c0bvv71dumovji.png"><br>  <sub>open drain output, push-pull output, alternative push-pull, alternative open drain</sub> </p><br><p>  <em>Push-pull</em> - the usual output from Arduine, pin can be either HIGH or LOW.  But with the "open drain" there are <a href="https://habr.com/ru/post/437234/">difficulties</a> , although in reality everything is simple here: </p><br><p><img src="https://habrastorage.org/webt/qa/e-/al/qae-alom88ushdmghd8wcu2l0q4.png"><br><img src="https://habrastorage.org/webt/en/oh/ny/enohnyxpb5u8cs4_t_m-cmtxbwy.png"><br>  <sub>Output configuration / when the port is assigned to output: / output buffer is on: / - open drain mode: ‚Äú0‚Äù in the output register activates N-MOS, ‚Äú1‚Äù in the output register leaves the port in Hi-Z mode (P-MOS is not activated ) / - push-pull mode: ‚Äú0‚Äù in the output register activates the N-MOS, ‚Äú1‚Äù in the output register activates the P-MOS.</sub> </p><br><p>  All the difference between open drain and <em>push-pull</em> is that in the first pin it cannot take the HIGH state: when writing a unit to the output register, it goes into high resistance mode ( <em>high impedance</em> , <em>Hi -Z</em> )  When writing a zero pin in both modes behaves the same way, both logically and electrically. </p><br><p>  In normal output mode, the pin simply translates the contents of the output register.  In the "alternative", it is controlled by the appropriate peripherals (see 9.1.4): </p><br><p><img src="https://habrastorage.org/webt/wu/mz/fv/wumzfvlk-fueikoig1wg6npj59u.png"><br>  <sub>If the port bit is configured as an alternative function output, the output register is disabled, and the pin is connected to the peripheral output signal</sub> </p><br><p>  An alternative functionality of each pin is described in the <em>Pin Definitions</em> datasheet and is on the downloaded image.  To the question what to do if a pin has several alternative functions, the answer is given by a footnote in the datasheet: </p><br><p><img src="https://habrastorage.org/webt/g1/hq/mi/g1hqmixkcdtdiius8u45hjfzagy.png"><br>  <sub>If several peripheral blocks use the same pin, in order to avoid conflict between alternative functions, only one peripheral block should be used at the same time, switching using the peripheral clock activation bit (in the corresponding RCC register).</sub> </p><br><p>  Finally, pins in output mode have a clocking speed.  This is another trick of energy saving, in our case we just set the maximum and forget. </p><br><p>  So: we use SPI, which means that two pins (with data and a clock signal) should be ‚Äúan alternative push-pull function‚Äù, and another (LAT) - ‚Äúa normal push-pull‚Äù function.  But before you assign them, let's deal with SPI. </p><br><h3 id="spi">  SPI </h3><br><div class="spoiler">  <b class="spoiler_title">Another small educational program</b> <div class="spoiler_text"><p>  SPI or Serial Peripherial Interface (Serial Peripheral Interface) is a simple and very effective interface for communicating with other MCs and the external world in general.  The principle of its operation is already described above, where about the Chinese LED driver (see section 25 in the reference manual).  SPI can work in master mode ("master") and slave ("slave").  SPI has four base channels, of which not all may be involved: </p><br><ul><li>  MOSI, Master Output / Slave Input: this pin in the master mode gives, and in the slave mode it receives data; </li><li>  MISO, Master Input / Slave Output: on the contrary, it accepts in the master, in the slave it returns; </li><li>  SCK, Serial Clock: sets the data transfer rate in the master or accepts a clock signal in the slave.  In essence, beats off the bits; </li><li>  SS, Slave Select: using this channel, the slave finds out that something is wanted from it.  On STM32 is called NSS, where N = negative, i.e.  the controller becomes the slave if the channel is ground.  Combines well with the Open Drain Output mode, but that's another story. </li></ul></div></div><br><p>  Like everything else, SPI on the STM32 is rich in functionality, which somewhat complicates its understanding.  For example, he can work not only with SPI, but also with the I2S interface, and in the documentation, their descriptions are intermixed, it is necessary to cut off the unnecessary in a timely manner.  Our task is extremely simple: you just need to give data, using only MOSI and SCK.  We go to section 25.3.4 (half-duplex communication, half-duplex communication), where we find <em>1 clock and 1 unidirectional data wire</em> (1 clock signal and 1 unidirectional data stream): </p><br><p><img src="https://habrastorage.org/webt/3o/wg/pm/3owgpmokhpahr9rkftf5ns2lclw.png"><br>  <sub>In this mode, the application uses SPI either in transmit only mode or receive only mode.</sub>  <sub>/ The transfer only mode is similar to the duplex mode: data is transmitted via the sending pin (MOSI in master mode or MISO in slave mode), and the receiving pin (MISO or MOSI, respectively) can be used as a normal input / output pin.</sub>  <sub>In this case, it is enough for the application to ignore the Rx buffer (if you read it, there will be no transferred data).</sub> </p><br><p>  Great, the pin MISO is free, we connect the LAT signal to it.  We will deal with Slave Select, which can be controlled programmatically on the STM32, which is extremely convenient.  We read the eponymous paragraph of section 25.3.1 SPI General Description: </p><br><p><img src="https://habrastorage.org/webt/8t/ng/jf/8tngjfopfxskwyq_gl8tlogcp2o.png"><br>  <sub>NSS program control (SSM = 1) / Information on slave selection is contained in the SSI bit of the SPI_CR1 register.</sub>  <sub>External pin NSS remains free for other application needs.</sub> </p><br><p>  It's time to write to registers.  I decided to use SPI2, we look for its base address in the datasheet - in section 3.3 Memory Map: </p><br><p><img src="https://habrastorage.org/webt/os/xd/6p/osxd6pdv5zfwombf5xflzfikj5c.png"></p><br><p>  Well, start: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI2_(mem_offset) (*(volatile uint32_t *)(0x40003800 + (mem_offset)))</span></span></code> </pre> <br><p>  We open section 25.3.3 with the telling title "Configuring SPI in master mode": </p><br><p><img src="https://habrastorage.org/webt/s8/ah/o5/s8aho5pbdv55j5vhhwecvewrm3m.png"></p><br><p>  <strong>1. Set the clock frequency of the serial interface with the bits BR [2: 0] in the SPI_CR1 register.</strong> </p><br><p>  Registers are collected in the reference manual section.  The address <em>offset</em> of CR1 is 0x00, by default all bits are reset ( <em>Reset value</em> 0x0000): </p><br><p><img src="https://habrastorage.org/webt/vt/46/um/vt46umrvbimjon75durupo3zsao.png"></p><br><p>  The BR bits set the controller clock divider, thereby determining the frequency at which the SPI will operate.  The STM32 frequency will be 72 MHz, the LED driver, according to its datasheet, works with a frequency of up to 25 MHz, thus, it is necessary to divide into four (BR [2: 0] = 001). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_CR1 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_0 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_1 0x0010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_2 0x0020 _SPI2_ (_SPI_CR1) |= BR_0;</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// pclk/4</span></span></span></span></code> </pre> <br><p>  <strong>2. Set the CPOL and CPHA bits to determine the relationship between data transfer and clocking of the serial interface (see diagram on page 240)</strong> </p><br><p>  Since we are reading the datasheet here, and not reviewing the diagrams, let's better examine the textual description of the CPOL and CPHA bits on page 704 (SPI General Description): </p><br><p><img src="https://habrastorage.org/webt/2h/pj/in/2hpjinoa65388hdfarcc9lwnqok.png"><br>  <sub>Clock Phase and Polarity</sub> <sub><br></sub>  <sub>Using the CPOL and CPHA bits of the SPI_CR1 register, you can programmatically select four timings relationships.</sub>  <sub>The CPOL bit (clock polarity) controls the state of the clock signal when no data is transmitted.</sub>  <sub>This bit controls the master and slave modes.</sub>  <sub>If the CPOL is cleared, the SCK pin in idle mode is low.</sub>  <sub>If the CPOL bit is set, the SCK pin in idle mode is at a high level.</sub> <sub><br></sub>  <sub>If the CPHA bit is set (clock phase), the high-bit strobe trap is the second front of the SCK signal (downward if CPOL is cleared, or upward if CPOL is set).</sub>  <sub>Data is captured by the second clock change.</sub>  <sub>If the CPHA bit is cleared, the leading edge of the SCK signal acts as the high-level gate trap (descending if CPOL is set, or ascending if CPOL is cleared).</sub>  <sub>The data is recorded by the first change in the clock signal.</sub> </p><br><p>  Having drunk into this knowledge, we conclude that both bits should remain zeros, since  we need the SCK signal to remain low when not in use, and the data to be transmitted on the leading edge of the pulse (see <em>Rising Edge</em> in DM634). </p><br><p>  By the way, here we first encountered the vocabulary feature in ST datasheets: in them the phrase ‚Äúreset bits to zero‚Äù is written <em>to reset a bit</em> , and not <em>to clear a bit</em> , as, for example, in Atmega. </p><br><p>  <strong>3. Set the DFF bit to define the 8-bit or 16-bit data block format.</strong> </p><br><p>  I specifically took a 16-bit DM634, so as not to bother with the transfer of 12-bit PWM data, like the DM633.  DFF makes sense to put in unit: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DFF 0x0800 _SPI2_ (_SPI_CR1) |= DFF; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 16-bit mode</span></span></span></span></code> </pre> <br><p>  <strong>4. Configure the LSBFIRST bit in the SPI_CR1 register to determine the block format.</strong> </p><br><p>  LSBFIRST, as its name implies, tunes the transmission with the low-order bit forward.  But DM634 wants to receive data, starting with the high bit.  Therefore, leave discarded. </p><br><p>  <strong>5. In hardware mode, if input from the NSS pin is required, send a high signal to the NSS pin during the entire byte transmission sequence.</strong>  <strong>In the NSS program mode, set the SSM and SSI bits in the SPI_CR1 register.</strong>  <strong>If the NSS pin should work on output, you only need to set the SSOE bit.</strong> </p><br><p>  Install SSM and SSI to forget about NSS hardware mode: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSI 0x0100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSM 0x0200 _SPI2_ (_SPI_CR1) |= SSM | SSI; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//enable software control of SS, SS high</span></span></span></span></code> </pre> <br><p>  <strong>6. The MSTR and SPE bits must be set (they remain set only if a high signal is sent to the NSS)</strong> </p><br><p>  Actually, we assign our SPI master to these bits and turn it on: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MSTR 0x0004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPE 0x0040 _SPI2_ (_SPI_CR1) |= MSTR; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//SPI master //  ,  SPI _SPI2_ (_SPI_CR1) |= SPE;</span></span></span></span></code> </pre> <br><p>  SPI is configured, let's write the functions that send the bytes to the driver right away.  We continue to read 25.3.3 "Configuring SPI in master mode": </p><br><p><img src="https://habrastorage.org/webt/sb/rg/u5/sbrgu5xwvaj7vc8a9rk2guxfdeq.png"><br>  <sub>Data transfer order</sub> <sub><br></sub>  <sub>The transfer starts when a byte is written to the Tx buffer.</sub> <sub><br></sub>  <sub>The data byte is loaded into the shift register in <strong>parallel</strong> mode (from the internal bus) during the transmission of the first bit, after which the MOSI pin is transmitted in <strong>sequential</strong> mode, with the first or last bit ahead, depending on the setting of the LSBFIRST bit in the CPI_CR1 register.</sub>  <sub>The TXE flag is set after the data is transferred <strong>from the Tx buffer to the shift register</strong> , and an interrupt is created if the TXEIE bit in the CPI_CR1 register is set.</sub> </p><br><p>  I highlighted a few words in translation to draw attention to one feature of the implementation of SPI in STM controllers.  On Atmega, the TXE flag ( <em>Tx Empty</em> , Tx is empty and ready to receive data) is set only after all the bytes have gone <em>out</em> .  And here this flag is set after the byte is stuck in the internal shift register.  Since it is pushed there by all the bits simultaneously (in parallel), and then the data is transmitted sequentially, TXE is set before the byte is completely sent.  This is important because  in the case of our LED driver, we need to pull the LAT pin after sending <em>all the</em> data, i.e.  Only the TXE flag will not be enough for us. </p><br><p>  This means that we need some more flag.  Let's see in 25.3.7 - ‚ÄúStatus Flags‚Äù: </p><br><p><img src="https://habrastorage.org/webt/_d/vn/jj/_dvnjjudvkmdyutpylvwfkfknng.png"><br>  &lt;...&gt; <br><img src="https://habrastorage.org/webt/3y/wv/nd/3ywvndaij5blabzqfq2n6wzdbfe.png"><br>  <sub>BUSY flag</sub> <sub><br></sub>  <sub>The BSY flag is set and reset by hardware (writing to it does not affect anything).</sub>  <sub>The BSY flag indicates the state of the SPI communication layer.</sub> <sub><br></sub>  <sub>It is reset:</sub> <sub><br></sub>  <sub>when the transfer is complete (except for master mode if the transfer is continuous)</sub> <sub><br></sub>  <sub>when SPI is disabled</sub> <sub><br></sub>  <sub>when a master mode error occurs (MODF = 1)</sub> <sub><br></sub>  <sub>If the transmission is not continuous, the BSY flag is cleared between each data transfer.</sub> </p><br><p>  Okay, it will come in handy.  Find out where the Tx buffer is.  To do this, read "Register data SPI": </p><br><p><img src="https://habrastorage.org/webt/sj/gk/o7/sjgko7dcnefgkio4jk9xrwt67bs.png"><br>  <sub>Bits 15: 0 DR [15: 0] Data Register</sub> <sub><br></sub>  <sub>Received data or data to transfer.</sub> <sub><br></sub>  <sub>The data register is divided into two buffers - one for writing (transfer buffer) and the second for reading (reception buffer).</sub>  <sub>Writing to the data register is written to the Tx buffer, and reading from the data register will return the value contained in the Rx buffer.</sub> </p><br><p>  Well, the status register, where there are flags TXE and BSY: </p><br><p><img src="https://habrastorage.org/webt/-k/pi/q9/-kpiq96tkpbqvvr1vly6nlzpwoe.png"></p><br><p>  We write: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_DR 0x0C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_SR 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BSY 0x0080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TXE 0x0002 void dm_shift16(uint16_t value) { _SPI2_(_SPI_DR) = value; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//send 2 bytes while (!(_SPI2_(_SPI_SR) &amp; TXE)); //wait until they're sent }</span></span></span></span></code> </pre> <br><p>  Well, since we need to transfer 16 times two bytes, according to the number of outputs of the LED driver, something like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendLEDdata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LAT_low(); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> k = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k--; dm_shift16(leds[k]); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_SPI2_(_SPI_SR) &amp; BSY); <span class="hljs-comment"><span class="hljs-comment">// finish transmission LAT_pulse(); }</span></span></code> </pre> <br><p>  But we are not yet able to pull the pin LAT, so back in I / O. </p><br><h3 id="naznachaem-piny">  Assign pins </h3><br><p>  In STM32F1, the registers responsible for the state of the pins are rather unusual.  It is clear that there are more of them than Atmega, but they also differ from other STM chips.  Section 9.1 General Description of GPIO: </p><br><p><img src="https://habrastorage.org/webt/ky/w9/ks/kyw9ksdar6bepxsf1u7kvyejfwm.png"><br>  <sub>Each of the general-purpose input / output ports <em>(GPIO)</em> has two 32-bit configuration registers (GPIOx_CRL and GPIOx_CRH), two 32-bit data registers (GPIOx_IDR and GPIOx_ODR), a 32-bit set / reset register (GPIOx_BSRR), 16-bit reset register (GPIOx_BRR) and 32-bit blocking register (GPIOx_LCKR).</sub> </p><br><p>  Unusual, and also rather inconvenient, here are the first two registers, because 16 pins of the port are scattered over them in the format ‚Äúfour bits per brother‚Äù.  Those.  pins from zero to seventh sit in the CRL, and the rest - in the CRH.  In this case, the remaining registers successfully fit the bits of all the pins of the port - often remaining half "reserved". </p><br><p>  For simplicity, start at the end of the list. </p><br><p>  We do not need a blocking register. </p><br><p>  The setup and reset registers are rather funny because they partially duplicate each other: you can only write everything in BSRR, where the older 16 bits will reset the pin to zero, and the younger ones to set to 1, or use the BRR, the lower 16 bits of which only reset the pin .  I like the second option.  These registers are important in that they provide atomic access to the pins: </p><br><p><img src="https://habrastorage.org/webt/tr/g9/tq/trg9tqg8ksmhfiaokjbslfvvhny.png"><br><img src="https://habrastorage.org/webt/yb/dm/da/ybdmdaayb-f0np1pawunxobfbaa.png"><br>  <sub>Atomic installation or reset</sub> <sub><br></sub>  <sub>You do not need to disable interrupts when programming GPIOx_ODR at the bit level: you can change one or several bits with one atomic APB2 write operation.</sub>  <sub>This is achieved by writing "1" to the set / reset register (GPIOx_BSRR or, for reset only, to GPIOx_BRR), the bit that needs to be changed.</sub>  <sub>Other bits will remain unchanged.</sub> </p><br><p>  Data registers have quite talking names - IDR = <em>Input</em> Direction Register, input register;  ODR = <em>Output</em> Direction Register, output register.  In the current draft, we will not need them. </p><br><p>  And finally, the control registers.  Since we are interested in the pins of the second SPI, namely PB13, PB14 and PB15, we immediately look at the CRH: </p><br><p><img src="https://habrastorage.org/webt/ei/_v/it/ei_vitm85yhwasuf5zjbhksfsoq.png"></p><br><p>  And we see that it will be necessary to write something in bits from the 20th to the 31st. </p><br><p>  We have already figured out what we want from the pins, so here I can do without a screenshot, I‚Äôll just say that MODE sets the direction (input, if both bits are set to 0) and pin speed (we need 50MHz, i.e. both pin in ‚Äú1‚Äù), and CNF sets the mode: usual ‚Äúpush-pull‚Äù - 00, ‚Äúalternative‚Äù - 10. By default, as we see above, all pins have the third bit (CNF0) registered, it sets them to <em>floating input</em> mode. </p><br><p>  Since I plan to do something else with this chip, for simplicity, I generally define all possible MODE and CNF values ‚Äã‚Äãfor both the lower and upper control registers. </p><br><div class="spoiler">  <b class="spoiler_title">Somehow like this</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_1 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_1 0x20000000</span></span></code> </pre> </div></div><br><p>  Our pins are located on port B (base address - 0x40010C00), code: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PORTB_(mem_offset) (*(volatile uint32_t *)(0x40010C00 + (mem_offset))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BRR 0x14 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BSRR 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRL 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRH 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  SPI2: MOSI  B15, CLK  B13 //LAT     MISO ‚Äì B14 //  ,      _PORTB_ (_CRH) &amp;= ~(CNF15_0 | CNF14_0 | CNF13_0 | CNF12_0); //   MOSI  SCK _PORTB_ (_CRH) |= CNF15_1 | CNF13_1; //50 , MODE = 11 _PORTB_ (_CRH) |= MODE15_1 | MODE15_0 | MODE14_1 | MODE14_0 | MODE13_1 | MODE13_0;</span></span></span></span></code> </pre> <br><p>  And, accordingly, you can write defains for LAT, which will be jerked by the BRR and BSRR registers: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*** LAT pulse ‚Äì high, then low */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_pulse() _PORTB_(_BSRR) = (1&lt;&lt;14); _PORTB_(_BRR) = (1&lt;&lt;14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_low() _PORTB_(_BRR) = (1&lt;&lt;14)</span></span></code> </pre> <br><p>  (LAT_low is just by inertia, somehow it always has been, let it remain for itself) </p><br><p>  Now everything is great, just not working.  Because it is an STM32, it saves electricity, which means that it is necessary to turn on the clocking of the necessary peripherals. </p><br><h2 id="vklyuchaem-taktirovanie">  Turn on clocking </h2><br><p>  The clocks are responsible for clocking, they are also Clock.  And we could already notice the abbreviation RCC.  We are looking for it in the documentation: this is Reset and Clock Control (control reset and clocking). </p><br><p>  As mentioned above, fortunately, the most difficult part of the clocking theme was made for us from STM, for which many thanks to them (once again I will <a href="http://easyelectronics.ru/arm-uchebnyj-kurs-taktovyj-generator-stm32.html">provide a</a> link to <a href="http://easyelectronics.ru/arm-uchebnyj-kurs-taktovyj-generator-stm32.html">the Di Halt website</a> , so that it is clear how <a href="http://easyelectronics.ru/arm-uchebnyj-kurs-taktovyj-generator-stm32.html">confused</a> this is).  We need only the registers that are responsible for enabling the Peripheral Clock Enable Registers.  First we find the base address of the RCC, it is at the very beginning of the "Memory Card": </p><br><p><img src="https://habrastorage.org/webt/r5/ad/jt/r5adjtnefym8toywwtuxwls-s8e.png"></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _RCC_(mem_offset) (*(volatile uint32_t *)(0x40021000 + (mem_offset)))</span></span></code> </pre> <br><p>  And then either click on the link where to try to find something in the tablet, or, much better, run through the descriptions of the <em>enable registers</em> from the sections about <em>enable registers</em> .  Where we find RCC_APB1ENR and RCC_APB2ENR: </p><br><p><img src="https://habrastorage.org/webt/bt/e7/_6/bte7_6icypsiop8tvagswdtfdpe.png"><br><img src="https://habrastorage.org/webt/pr/d0/l1/prd0l1e_vckbrxqk83wso_h9t5k.png"></p><br><p>  And in them, respectively, the bits that include clocking SPI2, IOPB (I / O Port B) and alternative functions (AFIO). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB2ENR 0x18 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB1ENR 0x1C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IOPBEN 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI2EN 0x4000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AFIOEN 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   B  .  _RCC_(_APB2ENR) |= IOPBEN | AFIOEN; //  SPI2 _RCC_(_APB1ENR) |= SPI2EN;</span></span></span></span></code> </pre> <br><p>  The final code can be found <a href="https://github.com/Ontaelio/Habra1905">here</a> . </p><br><p>  If there is an opportunity and desire to potest, then we connect DM634 like this: DAI to PB15, DCK to PB13, LAT to PB14.  We feed the driver from 5 volts, do not forget to combine the land. </p><br><p><img src="https://habrastorage.org/webt/sx/bz/va/sxbzvazmpgcgwsl0o5pt90gzlnm.jpeg"></p><br><h1 id="stm8-pwm">  STM8 PWM </h1><br><h1 id="shim-na-stm8">  PWM on STM8 </h1><br><p>  When I was just planning this article, I decided for an example to try to master some functionality of an unfamiliar chip using datasheet only, so that the shoemaker without boots would not work.  STM8 was ideally suited for this role: firstly, I had a couple of Chinese boards with STM8S103, and secondly, it was not very popular, and therefore the temptation to read and find a solution on the Internet rests on the absence of these very solutions. </p><br><p>  The chip also has a <a href="https://www.st.com/resource/en/datasheet/stm8s103f2.pdf">datasheet</a> and <a href="https://www.st.com/resource/en/reference_manual/cd00190271.pdf">reference manual RM0016</a> , in the first pinout and addresses of registers, in the second - everything else.  STM8 is programmed in C in the ugly IDE <a href="https://www.st.com/en/development-tools/stvd-stm8.html">ST Visual Develop</a> . </p><br><h3 id="taktirovanie-i-vvod-vyvod">  Clocking and I / O </h3><br><p>  By default, the STM8 operates at a frequency of 2 MHz, this should be immediately corrected. </p><br><p><img src="https://habrastorage.org/webt/h-/w7/hc/h-w7hclj1kovrmig-mxtjj-n62k.png"><br>  <sub>HSI Clock (High Speed ‚Äã‚ÄãInternal)</sub> <sub><br></sub>  <sub>The HSI clock signal is obtained from an internal 16 MHz RC oscillator with a programmable divider (from 1 to 8).</sub>  <sub>It is set in the clock divider register (CLK_CKDIVR).</sub> <sub><br></sub>  <sub>Note: at the start, the HSI RC generator with a divider 8 is selected as the leading clock source.</sub> </p><br><p>  Find the address of the register in the datasheet, the description in the refman and see that the register must be cleared: </p><br><pre> <code class="plaintext hljs">#define CLK_CKDIVR *(volatile uint8_t *)0x0050C6 CLK_CKDIVR &amp;= ~(0x18);</code> </pre> <br><p>  Since we are going to start the PWM and connect the LEDs, we look at pinout: </p><br><p><img src="https://habrastorage.org/webt/uv/ii/kt/uviikt-bigbrftn_ivjxx681d8e.png"></p><br><p>  The chip is small, many functions are suspended on the same pins.  The fact that in square brackets is ‚Äúalternative functionality‚Äù, it is switched by ‚Äú <em>option bytes</em> ‚Äù ( <em>option bytes</em> ) - something like Atmega fuses.  You can change their values ‚Äã‚Äãprogrammatically, but not necessary, because  new functionality is activated only after a reboot.  It is easier to use ST Visual Programmer (swings with Visual Develop), which can change these bytes.  The pinout shows that the pins CH1 and CH2 of the first timer are hidden in square brackets;  In STVP, you need to set the AFR1 and AFR0 bits, and the second one will also transfer the CH1 pin of the second timer from PD4 to PC5. </p><br><p>  Thus, 6 pins will control the LEDs: PC6, PC7 and PC3 for the first timer, PC5, PD3 and PA3 for the second. </p><br><p>  Configuring the I / O pins themselves on the STM8 is simpler and more logical than on the STM32: </p><br><ul><li>  familiar with Atmega data direction register DDR ( <em>Data Direction Register</em> ): 1 = output; </li><li>  the first control register CR1, when outputting, sets the push-pull mode (1) or open drain (0);  since I connect the LEDs to the chip with cathodes, I leave zeros here; </li><li>  CR2 second control register when output sets the clocking speed: 1 = 10 MHz </li></ul><br><pre> <code class="plaintext hljs">#define PA_DDR *(volatile uint8_t *)0x005002 #define PA_CR2 *(volatile uint8_t *)0x005004 #define PD_DDR *(volatile uint8_t *)0x005011 #define PD_CR2 *(volatile uint8_t *)0x005013 #define PC_DDR *(volatile uint8_t *)0x00500C #define PC_CR2 *(volatile uint8_t *)0x00500E PA_DDR = (1&lt;&lt;3); //output PA_CR2 |= (1&lt;&lt;3); //fast PD_DDR = (1&lt;&lt;3); //output PD_CR2 |= (1&lt;&lt;3); //fast PC_DDR = ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //output PC_CR2 |= ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //fast</code> </pre> <br><h2 id="nastroyka-shim">  PWM setting </h2><br><p>  To begin with, we define the terms: </p><br><ul><li>  <strong>PWM Frequency</strong> - the frequency with which the timer ticks; </li><li>  <strong>Auto-reload, AR</strong> - autoload value, up to which the timer will count (impulse period); </li><li>  <strong>Update Event, UEV</strong> - an event <strong>that occurs</strong> when the timer counts to AR; </li><li>  <strong>PWM Duty Cycle</strong> - PWM fill factor, often referred to as ‚Äúduty ratio‚Äù; </li><li>  <strong>Capture / Compare Value</strong> - the value for capture / comparison, by counting to which the timer <em>will do something</em> (in the case of PWM - inverts the output signal); </li><li>  <strong>Preload Value</strong> - the preloaded value.  <em>Compare value</em> cannot change while the timer is ticking, otherwise the PWM cycle will break.  Therefore, the new transmitted values ‚Äã‚Äãare buffered and pulled out when the timer reaches the end of the countdown and is reset; </li><li>  <strong>Edge-aligned</strong> and <strong>Center-aligned modes</strong> - the alignment of the border and the center, the same as atmelovskie <em>Fast PWM</em> and <em>Phase-correct PWM</em> . </li><li>  <strong>OCiREF, Output Compare Reference Signal</strong> - the reference output signal, in fact, that in the PWM mode is on the corresponding pin. </li></ul><br><p>  As is clear from pinouts, two timers have the PWM capabilities - the first and the second.  Both are 16-bit, the first one has a lot of additional features (in particular, it can count both up and down).  We need both to work the same way, so I decided to start with the obviously poorer second, in order not to accidentally use something that is not in it.  Some problem is that the description of the PWM functional of all the timers in the reference manual is in the chapter on the first timer (17.5.7 PWM Mode), so you always have to jump back and forth on the document. </p><br><p>  PWM on STM8 has an important advantage over PWM Atmega: </p><br><p><img src="https://habrastorage.org/webt/pk/_-/za/pk_-za7gnzo77lvwyw-gvkts1y0.png"><br>  <sub>PWM with alignment on the border</sub> <sub><br></sub>  <sub>Bottom Up Configuration</sub> <sub><br></sub>  <sub>The bottom-up count is active if the DIR bit in the TIM_CR1 register is cleared.</sub> <sub><br></sub>  <sub>Example</sub> <sub><br></sub>  <sub>The example uses the first PWM mode.</sub>  <sub>The PWM OCiREF reference signal is held at a high level while TIM1_CNT &lt;TIM1_CCRi.</sub>  <sub>Otherwise, it takes a low level.</sub>  <sub>If the value for comparison in the TIM1_CCRi register is larger than the auto-load value (TIM1_ARR register), the OCiREF signal is held at 1. <strong>If the value for comparison is 0, OCiREF is held at zero.</strong></sub>  <sub>...</sub> </p><br><p>  The STM8 timer during the <em>update event</em> first checks the <em>compare value</em> , and only then issues a reference signal.  Atmegie has a timer at first sharashit, and then compares, with the result that when <code>compare value == 0</code> , a needle is obtained at the output, with which we must somehow fight (for example, programmatically inverting logic). </p><br><p>  So, what we want to do: 8-bit PWM ( <code>AR == 255</code> ), we consider the bottom-up alignment along the border.  Since the light bulbs are connected to the chip by cathodes, the PWM must output 0 (LED is on) to <em>compare value</em> and 1 after. </p><br><p>  We have already read about some <em>PWM mode</em> , so we find the desired register of the second timer by searching the reference manual for this phrase (18.6.8 - TIMx_CCMR1): </p><br><p><img src="https://habrastorage.org/webt/tt/_3/7s/tt_37syfd9-bib2-ymdxijus9qi.png"><br>  <sub>110: First PWM mode - when counting from bottom to top, the first channel is active while TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Otherwise, the first channel is inactive.</sub>  <sub>[further in the document erroneous copy-paste from timer 1]</sub> <sub><br></sub>  <sub>111: Second mode PWM - when counting from the bottom up, the first channel is inactive, while TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Otherwise, the first channel is active.</sub> </p><br><p>  Since the LEDs are connected to MK cathodes, the second mode is suitable for us (the first one too, but we do not know it yet). </p><br><p><img src="https://habrastorage.org/webt/go/ap/x_/goapx_hk5neeok4phdkas_nnfzu.png"><br>  <sub>Bit 3 OC1PE: Enable Preloading Output 1</sub> <sub><br></sub>  <sub>0: The preload register on TIMx_CCR1 is disabled.</sub>  <sub>You can write in TIMx_CCR1 at any time.</sub>  <sub>New value works immediately.</sub> <sub><br></sub>  <sub>1: Preloading register on TIMx_CCR1 is enabled.</sub>  <sub>Read / write operations refer to the preload case.</sub>  <sub>The preloaded TIMx_CCR1 value is loaded into the shadow register during each update event.</sub> <sub><br></sub>  <sub>* Note: for correct operation of the PWM mode, the preloading registers must be enabled.</sub>  <sub>This is optional in single signal mode (the OPM bit is set in the TIMx_CR1 register).</sub> <br></p><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OK, turn on everything you need for the three channels of the second timer: </font></font></p><br><pre> <code class="plaintext hljs">#define TIM2_CCMR1 *(volatile uint8_t *)0x005307 #define TIM2_CCMR2 *(volatile uint8_t *)0x005308 #define TIM2_CCMR3 *(volatile uint8_t *)0x005309 #define PWM_MODE2 0x70 //PWM mode 2, 0b01110000 #define OCxPE 0x08 //preload enable TIM2_CCMR1 = (PWM_MODE2 | OCxPE); TIM2_CCMR2 = (PWM_MODE2 | OCxPE); TIM2_CCMR3 = (PWM_MODE2 | OCxPE);</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AR consists of two eight-bit registers, everything is simple: </font></font></p><br><pre> <code class="plaintext hljs">#define TIM2_ARRH *(volatile uint8_t *)0x00530F #define TIM2_ARRL *(volatile uint8_t *)0x005310 TIM2_ARRH = 0; TIM2_ARRL = 255;</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second timer can only count from the bottom up, alignment along the border, nothing needs to be changed. </font><font style="vertical-align: inherit;">Set the frequency divider, for example, at 256. At the second timer, the divider is set in the TIM2_PSCR register and is a power of two:</font></font></p><br><pre> <code class="plaintext hljs">#define TIM2_PSCR *(volatile uint8_t *)0x00530E TIM2_PSCR = 8;</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains to include the findings and the second timer itself. </font><font style="vertical-align: inherit;">The first task is solved by the registers </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Capture / Compare </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enable</font></font></strong></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : there are two of them, three channels are scattered across them asymmetrically. </font><font style="vertical-align: inherit;">Here we can also learn that the polarity of the signal can be changed, i.e. </font><font style="vertical-align: inherit;">in principle, it was possible to use PWM Mode 1. We write:</font></font></p><br><pre> <code class="plaintext hljs">#define TIM2_CCER1 *(volatile uint8_t *)0x00530A #define TIM2_CCER2 *(volatile uint8_t *)0x00530B #define CC1E (1&lt;&lt;0) // CCER1 #define CC2E (1&lt;&lt;4) // CCER1 #define CC3E (1&lt;&lt;0) // CCER2 TIM2_CCER1 = (CC1E | CC2E); TIM2_CCER2 = CC3E;</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And finally, we start the timer in the TIMx_CR1 register: </font></font></p><br><p><img src="https://habrastorage.org/webt/u8/rj/5v/u8rj5vb2h3oxtgnoe1zzz90fnfm.png"></p><br><pre> <code class="plaintext hljs">#define TIM2_CR1 *(volatile uint8_t *)0x005300 TIM2_CR1 |= 1;</code> </pre> <br><p>    AnalogWrite(),        .    <em>Capture/Compare registers</em> ,      :  8   TIM2_CCRxL    TIM2_CCRxH.    8- ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCR1L *(volatile uint8_t *)0x005312 #define TIM2_CCR2L *(volatile uint8_t *)0x005314 #define TIM2_CCR3L *(volatile uint8_t *)0x005316 void setRGBled(uint8_t r, uint8_t g, uint8_t b) { TIM2_CCR1L = r; TIM2_CCR2L = g; TIM2_CCR3L = b; }</code> </pre> <br><p>   ,       ,   100%  (   255      ).      ,      ,   . </p><br><p>     ,   . </p><br><p>            (  ,   ¬´¬ª   ,        ).            .      , ..       ,   16-     <em>Prescaler High</em>  <em>Low</em> .   ‚Ä¶    .  What's the matter? </p><br><p>             1,   ,     .  <em>17.7.30 Break register (TIM1_BKR)</em> ,    : </p><br><p><img src="https://habrastorage.org/webt/kb/h8/ue/kbh8ueavruur-vxcqo4fe0c2pdy.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM1_BKR *(volatile uint8_t *)0x00526D TIM1_BKR = (1&lt;&lt;7);</code> </pre> <br><p>    ,  <a href="https://github.com/Ontaelio/Habra1905"> </a> . </p><br><p><img src="https://habrastorage.org/webt/b9/hb/tn/b9hbtn6retrnp1vpnzxjsjaayoq.jpeg"></p><br><h1 id="stm8-multiplex"> STM8 Multiplex </h1><br><h1 id="multipleksing-na-stm8">   STM8 </h1><br><p>  -   ,          RGB-      .   ‚Äì  LED-,   ,   -     ,   ,     ( <em>persistence of vision</em> ,   ). -   <a href="https://www.instructables.com/id/LED-Multiplexing-101-6-and-16-RGB-LEDs-With-Just-a/">-   </a> . </p><br><p>    : </p><br><ul><li>    RGB LED; </li><li>  ,     ; </li><li>    ; </li><li>    RGB LED; </li><li>  ... </li></ul><br><p>  Well, etc. ,    ,     ¬´¬ª   .   .   ,    ,         ,   UEV          RGB-. </p><br><p>   LED  ,   ¬´¬ª,      .   : </p><br><pre> <code class="plaintext hljs">uint8_t colors[8][3];</code> </pre> <br><p>  ,     ,        .         </p><br><pre> <code class="plaintext hljs">uint8_t cnt;</code> </pre> <br><h3 id="demuks">  </h3><br><p>     ,   ,  CD74HC238.  ‚Äì ,    <code>&lt;&lt;</code> .     ( 0, 1  2)      X,        ( <code>1&lt;&lt;X</code> ).        .            ,     ‚Äì      ,  ,    .   ,       . </p><br><p> CD74HC238      ,       .           P-MOSFET,       , ..   20 ,  <em>absolute maximum ratings</em>  .  <a href="http://www.ti.com/lit/ds/schs147i/schs147i.pdf"> CD74HC238</a>       : </p><br><p><img src="https://habrastorage.org/webt/b3/lz/rv/b3lzrv4xyavibkiwekm3lbvkays.png"><br> <sub>H =   , L =   , X ‚Äì  </sub> </p><br><p>  E2  E1  , E3, A0, A1  A3   PD5, PC3, PC4  PC5 STM8.      ,   ,     push-pull . </p><br><h2 id="shim">  </h2><br><p>       ,    ,   : </p><br><p> -,      <em>Update Event</em> (UEV),    ,   LED.     <em>Update Interrupt Enable</em>      </p><br><p><img src="https://habrastorage.org/webt/me/kx/6p/mekx6pckxk6qmhkegaudnneach4.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM2_IER *(volatile uint8_t *)0x005303 //enable interrupt TIM2_IER = 1;</code> </pre> <br><p>       ,  <em>ghosting</em> ‚Äì   .       - ,  ,    UEV,   ,       LED      -   .        (0 =  , 255 =   )      .  Those.  ,   UEV       . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">//set polarity TIM2_CCER1 |= (CC1P | CC2P); TIM2_CCER2 |= CC3P;</code> </pre> <br><p>   r, g  b  255       . </p><br><h3 id="preryvaniya">  </h3><br><p>    ,            -  .   -    ,     . </p><br><p>         ST Visual Develop,   <code>main.c</code>       <code>stm8_interrupt_vector.c</code> ,    .         <code>NonHandledInterrupt</code> .        . </p><br><p>      ,    : </p><br><p><img src="https://habrastorage.org/webt/ly/ra/gy/lyragyga5skmcrzjojlftjit1qg.png"><br> <sub>13 TIM2 / <br> 14 TIM2 /</sub> </p><br><p>    LED  UEV,     ‚Ññ13. </p><br><p> , -,   <code>stm8_interrupt_vector.c</code>   ,    ‚Ññ13 (IRQ13)    : </p><br><pre> <code class="plaintext hljs">{0x82, TIM2_Overflow}, /* irq13 */</code> </pre> <br><p> -,     <code>main.h</code>  : </p><br><pre> <code class="plaintext hljs">#ifndef __MAIN_H #define __MAIN_H @far @interrupt void TIM2_Overflow (void); #endif</code> </pre> <br><p>  , ,      <code>main.c</code> : </p><br><pre> <code class="plaintext hljs">@far @interrupt void TIM2_Overflow (void) { PD_ODR &amp;= ~(1&lt;&lt;5); //   PC_ODR = (cnt&lt;&lt;3); //      PD_ODR |= (1&lt;&lt;5); //   TIM2_SR1 = 0; //   Update Interrupt Pending cnt++; cnt &amp;= 7; //   LED TIM2_CCR1L = ~colors[cnt][0]; //      TIM2_CCR2L = ~colors[cnt][1]; //     TIM2_CCR3L = ~colors[cnt][2]; // return; }</code> </pre> <br><p>   .     <code>rim</code> ‚Äì     <a href="https://www.st.com/resource/en/programming_manual/cd00161709.pdf">Programming Manual</a> : </p><br><pre> <code class="plaintext hljs">//enable interrupts _asm("rim");</code> </pre> <br><p>    ‚Äì <code>sim</code> ‚Äì  .          ¬´¬ª,         . </p><br><p>   ‚Äì <a href="https://github.com/Ontaelio/Habra1905"> </a> . </p><br><p><img src="https://habrastorage.org/webt/ri/ul/qs/riulqsjmsnehvg5fb_iofcnjl3u.jpeg"></p><br><p>   -   , ,     .     ,    . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/456094/">https://habr.com/ru/post/456094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45608/index.html">Sparko</a></li>
<li><a href="../456080/index.html">Which student needs a magician and which AI do we need?</a></li>
<li><a href="../456086/index.html">iOS Storyboards: analysis of the pros and cons, best practices</a></li>
<li><a href="../456088/index.html">Big Data Analysis Problems</a></li>
<li><a href="../456090/index.html">Introduction to unit testing in Unity</a></li>
<li><a href="../456096/index.html">What does the average reader Geektimes, soaring in the clouds</a></li>
<li><a href="../456098/index.html">Russian ICT as the foundation of national information security</a></li>
<li><a href="../4561/index.html">Internet Explorer 7 caused a wave of criticism in the blogosphere</a></li>
<li><a href="../456100/index.html">Now in the new package - Kingston A400 in M.2 format hurries to the market</a></li>
<li><a href="../456102/index.html">Easy report creation in C / C ++</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>