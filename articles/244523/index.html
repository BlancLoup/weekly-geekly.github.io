<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Subtleties nodejs. Part II: Work with errors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Error handling in JS is still a headache. I‚Äôm not mistaken if I say that mistakes are the weakest point of the whole language. Moreover, the problem c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Subtleties nodejs. Part II: Work with errors</h1><div class="post__text post__text-html js-mediator-article">  Error handling in JS is still a headache.  I‚Äôm not mistaken if I say that mistakes are the weakest point of the whole language.  Moreover, the problem consists of two others: the difficulty of catching errors in asynchronous code and the poorly designed object Error.  And if a lot of articles are devoted to the first problem, then many undeservedly forget about the second one.  In this article I will try to fill the gap and look at the Error object more closely. <br><a name="habracut"></a><br><h2>  Root of evil </h2><br>  The implementation of the error object in JS is one of the worst I‚Äôve ever met.  Moreover, the implementation itself is different in different engines.  The object is designed (and developed) as if neither before nor after the occurrence of JS with errors did not work at all.  I don't even know where to start.  This object is not programmatically interpreted, since all important values ‚Äã‚Äãare glued strings.  There is no call stack capture mechanism and error extension algorithm. <br><br>  The result of this is that each developer is forced to make their own decisions on a case-by-case basis, but, as scientists have proven, the choice makes people uncomfortable, so very often errors are simply ignored and fall into the mainstream.  Also, quite often, instead of an error, you can get Array or Object, designed "at its discretion."  Therefore, instead of a <em>single</em> error handling <em>system</em> , we are faced with a set of unique rules for each individual case. <br>  And these are not just my words, the same TJ Holowaychuck wrote about this in his letter saying goodbye to the nodejs community. <br><br>  How to solve the problem?  Create a unified strategy for the formation and processing of an error message!  Google developers offer V8 users their own set of tools that facilitate this task.  And so we begin. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Myerror </h3><br>  Let's start by creating your own error object.  In the classical theory, all you can do is create an instance of Error, and then supplement it, this is what it looks like: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> error = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Some error'</span></span>); error.name = <span class="hljs-string"><span class="hljs-string">'My Error'</span></span>; error.customProperty = <span class="hljs-string"><span class="hljs-string">'some value'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error;</code> </pre> <br>  And so for every occasion?  Yes!  Of course, one could create a MyError constructor and set the required field values ‚Äã‚Äãin it: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message, customProperty</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = message; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customProperty = customProperty; }</code> </pre><br>  But this way we will get an extra error record on the stack, which will complicate the search for errors by other developers.  The solution is the Error.captureStackTrace method.  It receives two values ‚Äã‚Äãat the input: the object to which the stack will be written and the constructor function, the record of which should be removed from the stack. <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message, customProperty</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>.captureStackTrace(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = message; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.customProperty = customProperty; } <span class="hljs-comment"><span class="hljs-comment">//      ...instanceof Error: var inherits = require('util').inherits; inherits(MyError, Error);</span></span></code> </pre><br><br>  Now, wherever the error in the stack comes up, the first place will be the address of the call to the new Error. <br><br><h2>  message, name and code </h2><br>  The next item in the solution is to identify the error.  In order to process it programmatically and decide on further actions: give a message to the user or complete the work.  The message field does not provide such opportunities: parsing a message with a regular expression does not seem reasonable.  How, then, to distinguish the error of the wrong parameter from the connection error?  In the nodejs itself, the code field is used for this.  In this case, the standard for classifying errors is <a href="http://www.ecma-international.org/ecma-262/5.1/">prescribed to use the name field</a> .  But they are used differently, so I recommend using the following rules for this: <br><br><ol><li>  The name field must contain the value in the "jumping" register: <code>MyError</code> . </li><li>  The code field must contain a value separated by an underscore, the characters must be in upper case: <code>SOMETHING_WRONG</code> . </li><li>  Do not use the word <code>ERROR</code> in the code field. </li><li>  The value in name is created for classifying errors, so it is better to use <code>ConnectionError</code> or <code>MongoError</code> , instead of <code>MongoConnectionError</code> . </li><li>  The code value must be unique. </li><li>  The message field must be formed based on the value of the code and the passed variable parameters. </li><li>  For successful error handling, it is advisable to add additional information to the object itself. </li><li>  Additional values ‚Äã‚Äãmust be primitives: it is not necessary to transfer a database connection to the error object. </li></ol><br><br>  Example: <br><br>  To create a file read error report for the reason that the file is missing, you can specify the following values: <code>FileSystemError</code> for <code>name</code> and <code>FILE_NOT_FOUND</code> for <code>code</code> , as well as the <code>file</code> field should be added to the error. <br><br><h3>  Stack handling </h3><br>  Also in V8 there is an <code>Error.prepareStackTrace</code> function for getting a raw stack ‚Äî an array of CallSite objects.  CallSite are objects that contain information about the call: the error address (method, file, string) and links directly to the objects themselves whose methods were called.  Thus, in our hands is quite a powerful and flexible tool for debugging applications. <br>  In order to get the stack, you need to create a function that takes two arguments as input: the error itself and the array of CallSite objects, you must return the finished string.  This function will be called for <strong>each</strong> error when accessing the stack field.  The created function must be added to Error itself as prepareStackTrace: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>.prepareStackTrace = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, stack</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... return error + ':\n' + stackAsString; };</span></span></code> </pre><br>  Let's take a closer look at the CallSite object contained in the stack array.  It has the following methods: <br><table><thead><tr><th>  Method </th><th>  Description </th></tr></thead><tbody><tr><td>  getThis </td><td>  returns the value of this. </td></tr><tr><td>  getTypeName </td><td>  returns the type of this as a string, usually the name field of the constructor. </td></tr><tr><td>  getFunction </td><td>  returns a function. </td></tr><tr><td>  getFunctionName </td><td>  returns the name of the function, usually the value of the name field. </td></tr><tr><td>  getMethodName </td><td>  returns the field name of this object. </td></tr><tr><td>  getFileName </td><td>  returns the name of the file (or browser script). </td></tr><tr><td>  getLineNumber </td><td>  returns the line number. </td></tr><tr><td>  getColumnNumber </td><td>  returns the offset in the string. </td></tr><tr><td>  getEvalOrigin </td><td>  returns the place of the eval call if the function was declared inside the eval call. </td></tr><tr><td>  isTopLevel </td><td>  whether the call is a call from the global scope. </td></tr><tr><td>  isEval </td><td>  whether a call is a call from eval. </td></tr><tr><td>  isNative </td><td>  whether the called method is internal. </td></tr><tr><td>  isConstructor </td><td>  whether the method is a constructor call. </td></tr></tbody></table><br>  As I said above, this method will be called once for each error.  In this case, the call will occur only when accessing the stack field.  How to use it?  Inside the method, you can add to the error the stack as an array: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>.prepareStackTrace = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, stack</span></span></span><span class="hljs-function">) </span></span>{ error._stackAsArray = stack.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">call</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... file : call.getFileName() }; }); // ... return error + ':\n' + stackAsString; };</span></span></code> </pre><br>  And then in the error itself add a dynamic property to get the stack. <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(MyError.prototype, <span class="hljs-string"><span class="hljs-string">'stackAsArray'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   prepareStackTrace this.stack; return this._stackAsArray; } });</span></span></code> </pre><br>  So we received a full-fledged report that is available programmatically and allows us to separate the system calls from the module calls and from the calls of the application itself for detailed analysis and processing.  I‚Äôll just make a reservation that there can be a lot of subtleties and questions when analyzing a stack, so if you want to figure it out, I advise you to dig in on your own. <br>  All changes to the API should be monitored on <a href="https://code.google.com/p/v8-wiki/wiki/JavaScriptStackTraceApi">the</a> v8 dedicated to ErrorTraceAPI. <br><br><h2>  Conclusion </h2><br>  At this point I want to finish, probably for the introductory article this is enough.  Well, I hope that this material will save someone time and nerves in the future.  In the next article I will tell you how to make work with errors comfortable using the approaches and tools described in the article. <br><br>  <strong>UPD</strong> .  Everyone who is waiting for revelations about catching asynchronous errors: to be continued ... </div><p>Source: <a href="https://habr.com/ru/post/244523/">https://habr.com/ru/post/244523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244511/index.html">Samsung's DeepSort ranked first in the Sort Benchmark 2014 competition</a></li>
<li><a href="../244515/index.html">The company Global Web Index presented a statistical report on the Internet preferences of Europeans in 2014</a></li>
<li><a href="../244517/index.html">Inversion of Control: Implementation Methods with PHP Examples</a></li>
<li><a href="../244519/index.html">How to warm up for a "foreign" account</a></li>
<li><a href="../244521/index.html">Elegant Java Builder</a></li>
<li><a href="../244525/index.html">Textbook on the programming language D. Part 5</a></li>
<li><a href="../244527/index.html">What will 100Gbps broadband satellite technology mean?</a></li>
<li><a href="../244529/index.html">The introduction of the software product. Features of the business consultant. Part III. Final</a></li>
<li><a href="../244531/index.html">Should Spring Boot be used in your next project?</a></li>
<li><a href="../244535/index.html">World Information Security Day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>