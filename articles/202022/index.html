<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Building your own JS SDK - why and how?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are writing an SDK for internal needs of a single project, then many things are simplified: backward compatibility issues are not so acute, ins...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Building your own JS SDK - why and how?</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/getpro/habr/post_images/c51/0f5/419/c510f5419b41fb6ce5f20fcecc1ed832.jpg"><br>  If you are writing an SDK for internal needs of a single project, then many things are simplified: backward compatibility issues are not so acute, instead of writing detailed documentation, you can personally answer colleagues' questions, and the errors found are relatively easy to include in the project.  If the SDK is done for all projects of a large company, then the problems become much more.  But if your SDK is designed for third-party developers around the world, then it‚Äôs just impossible to do without such things as good documentation and auto-tests.  It is to the latter that our <b>APS JavaScript SDK</b> can be attributed, and in this article I want to talk about how it works and how we try to make life as easy as possible for third-party developers who use or will use our SDK. <br><br>  <a href="http://www.slideshare.net/buranLcme/js-sdk">Slides</a> for those who do not like to read multi-letters. <br><br>  And for the most impatient: <a href="http://doc.apsstandard.org/2.2/frontend/">what happened with us</a> and <a href="http://doc.apsstandard.org/apsfiddle/">our sandbox</a> . <br><a name="habracut"></a><br><blockquote>  If you are only interested in technical details and code, I advise you to start reading immediately from the second part. </blockquote>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  What for </h2><br>  We did not need our own SDK to come up with a new type of vehicle shown in the picture to attract attention. <br><br>  We needed it to support the plugin system as part of <b>Parallels Automation's</b> <b>OSS</b> system and <b>Parallels Plesk</b> hosting control panel.  These systems are based on various code bases and they are very large.  <b>Parallels Automation has</b> millions of lines of code, and the solution itself is not the final product.  A contract is signed with a potential client and the product is branded.  The product needs to be expanded, so we needed to enable third-party developers to create a unified UI. <br><br>  To get a clear picture of <b>Parallels Automation,</b> you need to understand what <b>OSS is</b> .  It is a class of operational support systems that manage the network infrastructure, accounting and resource allocation.  The main consumers are telecoms and large hosters.  For them, it is important not only to manage the infrastructure as such, but also to sell services to its customers.  Telecoms get good revenues from selling the service.  Imagine a telecom with 10 million users.  Even if 1% of users buy a service worth $ 1, his income will be $ 100,000. <br><br><h3>  APS </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a02/230/65b/a0223065b81edaf17e34e76a7e964ea9.png"><br><br>  A standard developed by <b>Parallels</b> that allows integrating services into the <b>Parallels Automation</b> ecosystem.  The latest version of the standard is <b>APS 2</b> , which fixes version 1.x errors. <br><br><h5>  APS 1.x </h5><br>  <b>APS 1.x</b> allowed to integrate applications, describing the business model of integrable objects and declare the UI declaratively in a meta file.  Thus, the UI was automatically generated from the business model, which adversely affected the UX.  The script-oriented user interface was simply impossible to do.  Therefore, <b>APS 2.x</b> was created. <br><br><h5>  APS 2.x </h5><br>  In <b>APS 2, the</b> business model was completely separated from the presentation logic.  Business objects are now available via REST. <br>  After heated discussions and a design review, we stopped at the thin server architecture, in which the UI was described in HTML with very active use of JavaScript.  This allowed us to create a script-oriented interface without any significant restrictions. <br><br><h5>  Restrictions </h5><br>  Though restrictions nevertheless were. <br>  <b>Parallels Automation</b> , unlike, for example, <b>Parallels Desktop for Mac</b> , cannot simply be put out of the box.  As a rule, when it is sold, serious contracts are concluded and the <b>Parallels</b> brand is hidden in favor of the purchased hosting provider or telecom.  Therefore, the <b>APS</b> UI should have been branded.  As mentioned earlier, the level of developers can vary greatly.  Product commercial and copyleft restrictive licenses did not suit us. <br><br><h5>  APS JS SDK </h5><br>  As a result, we came up with the idea of ‚Äã‚Äãcreating our own JavaScript SDK, which allows us to abstract the developer from markup.  Abstracting serves as an additional bonus for us and end developers, since  legacy markup, strictly speaking, is not semantic. <br><br>  We also made an initial emphasis on documentation, since  JS SDK is not only used internally. <br><br><h2>  how </h2><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/4d2/a49/f41/4d2a49f41dcb1c32579d198192c5affc.jpg"><br>  How did we create our framework and what rules did we follow? <br><br><ul><li>  used existing frameworks; </li><li>  Do not forget about the thoughtful API; </li><li>  adhered to Test Driven Development - initially created automated tests; </li><li>  worked on the documentation; </li><li>  and above the sandbox where you can try the framework in action. </li></ul><br><br><h3>  Using existing frameworks </h3><br>  Creating and maintaining your entire JavaScript framework is a very laborious task.  Therefore, we decided to use any of the existing frameworks as the basis for building our JS SDK.  He had to meet several requirements: <br><ul><li>  because  we had an existing code base of the layout, which could be changed in the future, then I would like to work with UI elements as with whole objects - widgets that would be <b>based on HTML templates as isolated as possible from JS logic</b> ; </li><li>  the tasks of our users are very different, so the framework had to be <b>flexible enough to support a wide variety of UX variants</b> ; </li><li>  we did not want to force developers to learn some complex proprietary technologies, so the basic framework should be <b>as widespread as possible</b> ; </li><li>  as already mentioned, users can customize the design of their applications, so the framework should <b>allow you to easily change the appearance of widgets</b> ; </li><li>  besides, I wanted to find a <b>holistic framework</b> , on the basis of which one could immediately begin to create my widgets; </li><li>  and, of course, everyone loves <b>beautiful and dynamic widgets</b> , so the framework had to contain them, or at least allow them to be created. </li></ul><br>  As options we considered: <br><ul><li>  Extjs </li><li>  Jquery ui </li><li>  loader (RequireJS / CommonJS / ...) + MV * Framework (KnockoutJS / AngularJS / ...) </li><li>  Dojo toolkit </li></ul><br><h5>  Extjs </h5><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/374/43b/293/37443b29397e023a3a88f43f6eabec9d.png"><br>  Powerful, popular, actively developing framework with a large number of cool widgets and a convenient data binding model.  But still, this is a thing that was created to be taken and used.  This is not a foundation for creating your own framework.  Its widgets are difficult to customize, and the customization of the design is added only in the latest versions.  But its main drawback for us, of course, was very high license fees. <br><br><h5>  Jqueryui </h5><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/2fd/0bd/40d/2fd0bd40dbba1b7c95b8fcc51b8b15e3.png"><br>  Even more popular framework, with a low threshold of entry and the absence of license fees.  Widgets that are included in the official delivery, is not enough, but this is not a problem, because there are a huge number of widgets from third-party developers.  Unfortunately, at the time of the study, the API of the framework was not quite settled and changed frequently.  In addition, the widget code is not separate from the layout. <br><br><h5>  loader + MV * Framework </h5><br>  At the time of the study, the future of angular was vague, knockout solved very limited problems.  But there are customers, contracts and tight deadlines, so in order to proceed to the final development as soon as possible, we needed a holistic basic framework. <br><br><h5>  Dojo toolkit </h5><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/421/e03/a75/421e03a751fc897a38573b7331fb704e.png"><br>  A powerful framework with a modular structure based on <b>AMD</b> .  Rich, numerous easily customizable widgets with template support.  Many years of support for <b>Deferred</b> and <b>Promise</b> .  Lack of license fees.  But <b>Dojo is</b> strong and weak.  He has a relatively large threshold of entry due to which it is poorly distributed.  In addition, he recently began to actively move toward mobile devices. <br><br>  But we still decided to use <b>Dojo</b> : <br><ul><li>  the specifics of the system does not imply active use on mobile devices (now quite a lot has changed, but, on the other hand, we have solved the corresponding problems of the framework); </li><li>  We tried to lower the threshold of entry, which we will discuss below. </li></ul><br><br>  For more on <b>Dojo</b> 's merits, <b>see the</b> <a href="http://habrahabr.ru/post/189576/">translation of David Walsh‚Äôs article</a> .  There you can read <b>Dojo</b> and <b>ExtJS</b> comparisons in the comments. <br><br><h3>  Thoughtful API </h3><br>  The basis of any framework is a well thought-out API. <br><br><h5>  AMD </h5><br>  The foundation of our JS SDK are <b>AMD</b> modules which are visual components - widgets, components for working with data and various auxiliary utilities.  In addition, the AMD format allows you to include in the project any third-party libraries that support this packaging format.  Thus, we do not limit the developers in their preferences. <br><br><h5>  Widgets </h5><br>  Visual components - widgets - are logically separated from the HTML presentation.  They can dynamically change the values ‚Äã‚Äãof their properties and inherit from each other.  For the convenience of developers, there are 3 ways to describe widgets.  And on one screen it is absolutely not necessary to use only one, the methods can be freely combined. <br><br><h5>  Turning widgets into each other </h5><br>  Widgets can include each other at the template level.  For example, the aps / Slider widget consists of horizontal scrolling dijit / form / HorizontalSlider and aps / TextBox: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b67/2e0/7ac/b672e07ac197c0d1b71d47a55925634f.png"></div><br>  In addition to the described inclusion of widgets in the template, you can dynamically add child widgets to the screen description.  For example, add input to the form. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/d71/4d0/f3fd714d07a249c60b64d74087656f41.png"></div><br><h5>  Declarative announcement </h5><br>  Our framework supports 3 screen descriptions.  First declarative.  In it, the location of the widgets and their properties are specified as HTML layout with the specified special attributes.  The widget hierarchy is defined by the HTML Element hierarchy.  After the page loads, the parser is invoked, which creates widgets.  Parser can be called on the whole page or on a separate part of it. <br><br><div class="spoiler">  <b class="spoiler_title">Sample code</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([<span class="hljs-string"><span class="hljs-string">"dojo/parser"</span></span>, <span class="hljs-string"><span class="hljs-string">"aps/ready!"</span></span>], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parser</span></span></span><span class="hljs-function">)</span></span>{ parser.parse(); });</code> </pre> <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fieldset</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-dojo-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùaps/FieldSet‚Äù</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">title</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚ÄúI</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">am</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">aps</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">FieldSet</span></span></span><span class="hljs-tag">‚Äù&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">‚Äùcheckbox‚Äù</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-dojo-type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"aps/CheckBox"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-dojo-props</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" label: 'CheckBox', description: 'I am aps/CheckBox'"</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fieldset</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br></div></div><br><br><h5>  Programmatic Widget Ad </h5><br>  The second way to declare widgets is software.  With the help of <b>require</b> , the necessary modules are connected and by calling the constructor with parameters, the necessary widgets are created.  The widget hierarchy is defined by adding child widgets using the <b>addChild</b> method. <br><br><div class="spoiler">  <b class="spoiler_title">Sample code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([ <span class="hljs-string"><span class="hljs-string">"aps/FieldSet"</span></span>, <span class="hljs-string"><span class="hljs-string">"aps/CheckBox"</span></span>, <span class="hljs-string"><span class="hljs-string">"aps/ready!"</span></span> ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FieldSet, CheckBox</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FieldSet({ <span class="hljs-attr"><span class="hljs-attr">title</span></span> : ‚ÄúI am aps / FieldSet‚Äù }, <span class="hljs-string"><span class="hljs-string">"idDiv"</span></span>); fs.addChild(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CheckBox({ <span class="hljs-attr"><span class="hljs-attr">label</span></span> : ‚ÄúCheckBox‚Äù, <span class="hljs-attr"><span class="hljs-attr">description</span></span> : ‚ÄúI am aps / CheckBox‚Äù }); fs.startup(); });</code> </pre><br></div></div><br><br><h5>  Using the bootloader </h5><br>  The third way to describe the screen - using the loader.  It is designed by us, and we recommend it.  The location of the widgets and their properties are set in the form of a JSON-like structure.  Each widget is described by a triple: module name, constructor parameters and an array of child elements.  The second and third element are optional.  In addition to widgets, the downloader can also create HTML tags. <br><br><ul><li>  it does not waste time parsing HTML (the first method); </li><li>  In the program declaration (the second method), the logical order is violated - first, a child widget is created, and then the parent (container) is created, which is inconvenient and difficult to read. </li></ul><br><br><div class="spoiler">  <b class="spoiler_title">Sample code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([ <span class="hljs-string"><span class="hljs-string">"aps/load"</span></span>, <span class="hljs-string"><span class="hljs-string">"aps/ready!"</span></span> ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">load</span></span></span><span class="hljs-function">) </span></span>{ load([<span class="hljs-string"><span class="hljs-string">"aps/FieldSet"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">title</span></span> : <span class="hljs-string"><span class="hljs-string">"I am aps / FieldSet"</span></span> }, [ [<span class="hljs-string"><span class="hljs-string">"aps / CheckBox"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">label</span></span> : <span class="hljs-string"><span class="hljs-string">"CheckBox"</span></span>, <span class="hljs-attr"><span class="hljs-attr">description</span></span> : <span class="hljs-string"><span class="hljs-string">"I am aps / CheckBox"</span></span> } ]]]); });</code> </pre><br></div></div><br><br><h5>  Data sources </h5><br>  Two modules can be used as a data source for a widget: <b>Store</b> for a remote source and <b>Memory</b> for a local one. <br>  For querying the server, aps / Store uses an extended version of the <a href="https://github.com/persvr/rql">RQL</a> query language, which is also supported by aps / Memory. <br><br><div class="spoiler">  <b class="spoiler_title">Sample code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([ <span class="hljs-string"><span class="hljs-string">"aps/Store"</span></span>, <span class="hljs-string"><span class="hljs-string">"aps/Grid"</span></span>, <span class="hljs-string"><span class="hljs-string">"aps/ready!"</span></span> ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">load</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> store = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Store({ <span class="hljs-attr"><span class="hljs-attr">target</span></span> : <span class="hljs-string"><span class="hljs-string">"http://localhost/resources"</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Grid({ <span class="hljs-attr"><span class="hljs-attr">columns</span></span>: layoutSimpleGrid, <span class="hljs-attr"><span class="hljs-attr">store</span></span>: store }, <span class="hljs-string"><span class="hljs-string">"gridDiv"</span></span>); });</code> </pre><br></div></div><br><br><h5>  Data binding </h5><br>  For two-way communication of data and widgets, the modules of the <b>Model</b> family and the <b>at</b> method are used.  If you want to associate data and widgets, then as a constructor parameter you specify the <b>at</b> method with the model name passed to it and the property name of the model object to which you are mapping.  In addition to the possibility of mapping, the model supports the ability to track the value of its properties using the <b>watch</b> method. <br><br><div class="spoiler">  <b class="spoiler_title">Sample code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([ <span class="hljs-string"><span class="hljs-string">"aps/TextBox"</span></span>, <span class="hljs-string"><span class="hljs-string">"dojox/mvc/getStateful"</span></span>, <span class="hljs-string"><span class="hljs-string">"dojox/mvc/at"</span></span>, <span class="hljs-string"><span class="hljs-string">"aps/ready!"</span></span> ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TextBox, getStateful, at</span></span></span><span class="hljs-function">) </span></span>{ model = getStateful({<span class="hljs-attr"><span class="hljs-attr">val</span></span> : <span class="hljs-string"><span class="hljs-string">"Hello, world!"</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextBox({<span class="hljs-attr"><span class="hljs-attr">value</span></span> : at(<span class="hljs-string"><span class="hljs-string">"model"</span></span>, <span class="hljs-string"><span class="hljs-string">"val"</span></span>)}, <span class="hljs-string"><span class="hljs-string">"divTB"</span></span>).startup(); });</code> </pre><br></div></div><br><br><h5>  Uniform for all modules rules for naming properties and methods </h5><br>  The naming rules are simple and standard: <br><ul><li>  the names of private / protected properties and methods begin with an underscore ‚Äú_‚Äù; </li><li>  the names of methods, functions and properties begin with a small letter, the names of classes - with a large one;  if the class is a mixin, then an underscore is placed in front of a large letter. </li></ul><br><br><h5>  Uniform for all modules of the way of interaction between themselves and the outside world </h5><br><ul><li>  data and widgets are linked through the <b>Model</b> and <b>Store</b> modules; </li><li>  monitoring the state of the widget is done using the <b>watch</b> method, widgets do not generate any special events, all work with the properties is done only through the <b>set</b> and <b>get</b> methods. </li></ul><br><br><h5>  Example of interaction with the widget </h5><br>  As an example of interaction with widgets, consider the selection of lines in the <b>Grid</b> widget. <br><br>  In the simplest case, to create a table with the ability to select rows, it is enough to specify the column structure, the row selection mode (whether you can select one or several rows at a time) and the data source. <br><br>  If a string is selected, its id is added to a special array stored in the <b>selectionArray</b> property.  When you deselect it, it is removed from there.  Thus, to track the selection of rows, it is enough to add a callback to the <b>watchElements</b> method and it will automatically be called when the set of selected rows is changed. <br><br>  Communication is two-way.  Therefore, to visually select a row in the table, we just need to add its id to <b>selectionArray</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Sample code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Grid({ <span class="hljs-comment"><span class="hljs-comment">//     columns : layoutSimpleGrid, selectionMode : "single", store : store }); grid.get("selectionArray") //    .watchElements(function (index, removals, adds) { alert(adds); }); //   grid.get("selectionArray").push("ea7865aa");</span></span></code> </pre><br></div></div><br><br><h3>  Automated Tests </h3><br>  Tests are important, and automated tests are necessary.  They allow you to keep the code in a stable state.  And it is better to develop them from the very beginning.  But before developing tests, you need to think about the build system. <br><br><h5>  Build system </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/110/98f/0d9/11098f0d99ad89fc53932759d623d51f.png"></div><br>  Build launches <b>Jenkins</b> - standard build-scheduler.  <b>Maven</b> , <b>node.js</b> and <b>phantomjs</b> headless browser are <b>deployed on the build machine</b> .  Our build is built into the maven build lifecycle and includes checking JSHint code, compiling a <b>clojure compiler</b> , packaging, including creating layers (or merging files), testing and deploying the generated archive to the <b>nexus</b> artifact management system. <br><br><h5>  Automated Testing </h5><br>  Tests can determine the entire fate of the framework, since  stability is the key to development. <br><br>  What we followed when creating autotests: <br><ul><li>  <b>you can run without infrastructure</b> , because  tests can serve as an example for developers; </li><li>  because  modular framework, then there <b>must be a strictly separate test for each component</b> ; </li><li>  <b>tests should be located next to the framework itself</b> , right in the distribution, so that you can quickly run them out and see how to use the framework; </li><li>  and, finally, to understand the tests - you need to <b>strictly adhere to naming conventions</b> ;  in our case, test directories start with test, everything else is for manual testing. </li></ul><br><br>  Unit tests should always run at build.  It often happens that new functionality is required immediately.  At the same time, during the development process, it turns out that some of the tests are optional ‚Äúat first glance‚Äù and disabling them ‚Äúwill not hurt anyone‚Äù.  The test is disabled.  Then another.  And over time, the number of inconsistencies is such that it becomes pointless to run unit tests. <br><br>  The build is canceled if at least one test fails.  Disable tests can not. <br><br><h5>  Selection of tools </h5><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/ae1/735/ca5/ae1735ca5e69ebf6c32a3b31a34047ae.png"><br>  We chose <b>QUnit</b> and our own system that runs <b>phantomjs</b> , IE, Firefox and Safari in virtual machines.  We previously considered: <br><ul><li>  TestSwarm; </li><li>  Buster.js; </li><li>  DOH Robot; </li><li>  External Farms (browsershots, browserling, etc); </li><li>  Selenium. </li></ul><br><br><h5>  Why QUnit </h5><br>  The main thing for us is the simplicity of embedding.  One JavaScript programming language for writing both code and tests, which is very convenient.  <b>QUnit</b> is simple and common - if necessary, this allows you to easily outsource testing. <br><br><h5>  Why not TestSwarm </h5><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/2fd/502/eef/2fd502eefc083a0e780d90ebcea5d246.png"><br>  <b>TestSwarm is</b> heavily tied to infrastructure.  But the main thing is that the build is marked after the build, and not during the time, which contradicts the methodology adopted by us. <br><br><h5>  Why not Buster.js </h5><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/87b/926/16b/87b92616ba2bcf45ae1437cc695c98f5.png"><br>  The framework is designed to run modules on the server and on the client - we do not have such a task.  In addition, he can not independently launch browsers. <br><br><img align="left" src="https://habrastorage.org/getpro/habr/post_images/62d/85b/8ee/62d85b8ee625e278326c106e48b22ffa.png"><br><h5>  Why not Dojox Robot </h5><br>  The framework included in the <b>Dojo Toolkit</b> .  Unfortunately, despite this, abandoned and significantly obsolete. <br><br><h5>  Why not external farms </h5><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/bf4/798/f58/bf4798f584f0af5dfbdb29368fd4b3be.png"><br>  I really didn‚Äôt want to be tied up on external systems, moreover, it would have required complicated setup of VPN access to our assembly machines.  Plus, their use is quite expensive. <br><br><h5>  Why not Selenium </h5><br>  Cumbersome, requires infrastructure configuration. <br><br><img align="left" src="https://habrastorage.org/getpro/habr/post_images/013/fd5/ccf/013fd5ccfc7fdf74ba2f423a316caf83.png"><br><h5>  Total </h5><br>  We have a hybrid <b>Selenium Server</b> , which, on command from outside, launches a browser on a virtual machine.  All tests are run in one page, while the results can be delivered to the collector or shown in the browser if the tests were run manually. <br><br><h5>  Test infrastructure components </h5><br>  The diagram shows the components of the test infrastructure.  On the build server, phantom.js runs in parallel (for a quick result) and tests on various browsers running on different operating systems on virtual machines. <br><br><h3>  Documentation </h3><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/89c/d1d/ec0/89cd1dec0fe52d8fd99fab0b20f3d345.png"><br>  Even the most thoughtful API requires convenient documentation.  The APS JS SDK documentation consists of two parts: the <b>API</b> and the <b>Reference Guide</b> . <br><br><h5>  API </h5><br>  The API section contains a brief description of all available modules and their interfaces.  This section is primarily focused on developers who have already sorted out the SDK and want to quickly clarify the presence and proper spelling of a particular method or property.  This information is generated based on the comments in the code during the assembly of the code. <br><br><h5>  Reference Guide </h5><br>  In the description of each module there is a link to the corresponding page of the second part of the documentation - <b>Reference Guide</b> .  This section contains an extended (as compared to the API) description of the APS SDK modules and their basic properties and methods.  It is regularly updated and updated in accordance with the problems faced by users of our SDK.  Also, each Reference Guide article contains examples of using modules. <br><br><h5>  Examples </h5><br>  Examples of using and creating a module are given for all three ways to declare widgets: declarative, software, and using the loader.  But examples that cannot be launched and tried are of little interest.  The page of each module in the Reference Guide contains a link to the page with auto-tests.  The user can see how the tests are performed, and looking at the source code, see examples showing all the functionality of the widget. <br><br><h3>  Sandbox </h3><br><img align="right" src="https://habrastorage.org/getpro/habr/post_images/99a/2f4/c5d/99a2f4c5dfa856cd17926e1986a03702.png"><br>  But you always want to try it yourself.  And, preferably, quickly and easily.  To do this, most of the examples can be run in a special sandbox. <br><br>  When creating our sandbox, we were inspired by the notorious <b>jsfiddle</b> project, so it is called <b>apsfiddle</b> .  As in it, the user has 4 available areas: an HTML editor, a CSS editor, a JS editor, and the result of the code execution (it can be viewed both in the assigned screen area and in a new tab).  To create code editors, we used the <b>CodeMirror</b> project. <br><br>  In addition to manually entering text, in the sandbox you can open your files simply by dragging them into the browser window.  Editors fill out automatically.  Files can also be opened in the traditional way. <br><br>  For collaboration, we use <a href="http://habrahabr.ru/post/194486/">TogetherJS</a> . <br><br>  Editors support <br><ul><li>  syntax highlighting; </li><li>  check of the entered code on the fly; </li><li>  auto substitution of closing brackets and tags; </li><li>  folding of code blocks; </li><li>  beautiful formatting; </li><li>  smart code completion. </li></ul><br><br><h5>  Autocompletion </h5><br>  Typically, developers creating a sandbox for HTML + JS are limited to simple editors and a frame in which the entered code is run.  We think this is wrong.  The person who came to the sandbox does not know the API of the framework very well, and without a maximum of hints, he most likely cannot do anything.  Therefore, we implemented smart code completion with tooltips. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b35/b15/184/b35b15184b478af0bcb408ab81b97e2f.png"></div><br><br>  For autocompletion, the <b>Tern</b> project <a href="http://habrahabr.ru/post/171967/">already mentioned in Habr√© is used</a> .  In his work he uses several dictionaries.  The dictionary of methods and properties of <b>ECMA5</b> and <b>JQuery is</b> provided by the author of the project, for the APS JS SDK objects, a dictionary is generated based on the documentation.  This allows the editor to suggest methods and properties of the object based on how the designer created it. <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"MessageList"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"!type"</span></span>:<span class="hljs-string"><span class="hljs-string">"fn(options: object)-&gt;!custom:MessageList_ctor"</span></span>, <span class="hljs-string"><span class="hljs-string">"prototype"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"add"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"!type"</span></span>: <span class="hljs-string"><span class="hljs-string">"fn(description: string, error: string)"</span></span>, <span class="hljs-string"><span class="hljs-string">"!doc"</span></span>: <span class="hljs-string"><span class="hljs-string">"added new message"</span></span> }, ...</code> </pre><br><br>  It often happens that within a quarter of the screen it becomes crowded, so all editors support full-screen mode, in which you can switch between screens with hot keys without exiting to normal mode. <br><br><h5>  Hotkeys </h5><br>  Hotkeys are an important element of working with <b>apsfiddle</b> .  They duplicated all the functionality, and some operations can be done only by them.  This is done not to clutter up the screen with a bunch of buttons.  In order for the user to immediately recognize which key combinations can be used, when opening <b>apsfiddle,</b> it first displays the full list of keyboard shortcuts: <br><br>  Systemic <br>  <b>Ctrl + H</b> - help <br>  <b>Ctrl + O</b> - download file <br>  <b>Ctrl + R</b> - clearing fields <br>  <b>Ctrl + Enter</b> - launch <br>  <b>Ctrl + 1</b> focus on HTML editor <br>  <b>Ctrl + 2</b> - focus on CSS editor <br>  <b>Ctrl + 3</b> - focus on JavaScript editor <br>  <b>F11</b> - switch full screen mode <br>  <b>Esc</b> - exit from full screen mode <br><br>  Are common <br>  <b>Ctrl + B</b> - make beautiful formatting <br>  <b>Ctrl + F</b> - search <br>  <b>Ctrl + K</b> - folding code block <br>  <b>Ctrl + /</b> - commenting <br>  <b>Ctrl + Space</b> - code completion <br><br>  HTML <br>  <b>Ctrl + J</b> - switching by tag <br><br>  Javascript <br>  <b>Ctrl + I</b> - show type <br>  <b>Alt +.</b>  - jump to the announcement <br>  <b>Alt +,</b> - jump back <br><br><h5>  Autosave </h5><br>  To avoid accidental data loss, the entered code is periodically stored in localStorage.  The last saved code is inserted into the editors when the <b>apsfiddle is opened</b> . <br><br><h5>  Note </h5><br>  When we created our sandbox, we did not set ourselves the task of developing a full-fledged Cloud IDE.  First of all, we needed a platform where our users could easily test our SDK and quickly learn how to work with it based on the examples provided by us.  Therefore, we did not take the code of such large projects as, for example, Cloud9. <br><br>  In the creation of the most intelligent and convenient code completion for our framework, we are only at the very beginning.  Now his work requires compliance with the naming conventions for plug-ins, and we are not yet able to prompt the names of properties during their implicit use.  Those.  when declaring an object that acts as a constructor argument, and when specifying the property name as a string, for example, to invoke encapsulating methods. <br><br><h2>  Brief summary </h2><br>  Now <b>APS JS SDK</b> <br><ul><li>  has a modular structure; </li><li>  includes ‚Äúthick widgets‚Äù, data binding and templating; </li><li>  supplied with handwritten and auto-generated documentation; </li><li>  checked by autotest and manually; </li><li>  has a sandbox with advanced code completion. </li></ul><br>  All described can be tried <a href="http://doc.apsstandard.org/spec/ui/custom/sdk/sdk/">here</a> .  Our main clients are in the West, and servers are hosted there, so the first download of apsfiddle can be long. <br><br>  In general, the article turned out to be an overview, if you are interested in some implementation details, then ask in the comments.  If there is a lot of questions about something, we will try to highlight it in a separate article. <br><br>  <i>The authors of the article are Timur Nizametdinov and Evgeny Uspensky, Parallels</i> </div><p>Source: <a href="https://habr.com/ru/post/202022/">https://habr.com/ru/post/202022/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202012/index.html">The monitoring system in the car for him on the Raspberry Pi. Part 1</a></li>
<li><a href="../202014/index.html">Snake on Canvas</a></li>
<li><a href="../202016/index.html">Java web start issues when upgrading to j7u45</a></li>
<li><a href="../202018/index.html">OWIN and Katana: First Look</a></li>
<li><a href="../202020/index.html">Our tanks. The history of load testing in Yandex</a></li>
<li><a href="../202024/index.html">ScienceHub # 05: Biophysics of excitable systems</a></li>
<li><a href="../202026/index.html">What is a lawn mower? We disassemble Robomow RS 630</a></li>
<li><a href="../202028/index.html">Managerial tools: Why do customers demand stupid reports?</a></li>
<li><a href="../202030/index.html">COLT fresh build released</a></li>
<li><a href="../202036/index.html">Livity for C # - livecoding for Unity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>