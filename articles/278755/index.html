<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous parallel execution in PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A lot of rush is broken in the world on the topic of whether and how to create multithreading in PHP. Most often, it all comes down to the fact that i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous parallel execution in PHP</h1><div class="post__text post__text-html js-mediator-article">  A lot of rush is broken in the world on the topic of whether and how to create multithreading in PHP.  Most often, it all comes down to the fact that it is impossible to do this or the discussion materializes in some awful crutches (oh, how many I have already seen).  I want to state my point of view on this question.  It is easy to guess that if my position was ‚Äúso impossible‚Äù or ‚Äúthis is evil,‚Äù I would not have written this article.  Just wait a minute, do not rush to get the rotten eggs and equip small household items for melee.  I will try to diplomatically outline the topic and as objectively as possible to reveal the situation.  So the most courageous of my readers can read the prayer from heresy and open the article. <br><br><img src="https://habrastorage.org/files/756/079/d15/756079d156d64cc6888f7acbf0a2a7de.png"><br><a name="habracut"></a><br><br><h4>  The object of discussion - what do I mean by multitasking / multithreading? </h4><br>  There are many different terms: multithreading, multiprocess, asynchronous execution.  They all mean different things.  However, it often happens that in practice we, as consumers, are not so important in different processes, threads, or else how our program runs in parallel.  If only she worked faster and did not lose responsiveness in the process of its implementation.  Therefore, in this article I will consider all possible options for parallelizing PHP, regardless of the internal kitchen of this parallelization itself.  That is, I will try to answer the question: how can I make so that some long action in my PHP code is performed in the background, while my code is busy with something else useful. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  And why is it even necessary? </h4><br>  Actually, I believe that in 99% of cases it is not necessary (and notice that the author writes an article on the topic of parallelization).  I worked for 8 years with PHP and until last week I always considered it a great folly to try to thread multithreading into PHP.  The point is that the PHP task is to accept an incoming HTTP request and generate an answer to it.  One request - one answer.  The scheme is very simple, and it is very convenient to process linearly in one thread.  It seems to me that in a client-server bundle on the server, it is not necessary to do something multi-threaded, except for some special circumstances that force you to do this and on which you can play to reduce the resources consumed and the response time.  Why do I think so?  After all, someone can say that if you parallelize some process, then it can run on 2 cores at once and thus execute faster.  It's true.  But there is always one nuance on the server: you must be ready to process N clients at the same time.  And if your server code ‚Äúsprawls out‚Äù on all 8 available cores, and at that moment a new incoming request comes, then it will have to huddle in the queue, waiting for some kernel to be ready to start processing it.  And you will have a useless competition for the cycles of 8 CPUs between 16 threads / processes.  That is why I believe that even if the server has resources that can be involved in the processing of an incoming request due to parallelization, it is better not to do so.  We can say that parallelization is already present and so, because  The server can simultaneously process several incoming requests.  Well, it turns out that twisting parallelization into parallelization is already sort of a bust. <br><br>  By this moment I already mentioned a glimpse of why multithreading is needed.  It allows you to "break" a single thread of code execution.  This results in several ‚Äúuseful‚Äù consequences.  First, you can perform some kind of slow action in the background, while maintaining the responsiveness of the main program flow (asynchronous execution).  For example: according to business logic, we need to exchange information with some peripheral device.  This device is very slow, and the operation takes about 5 seconds.  If all this is done in one stream, then the block diagram of our algorithm looks like this: <br><img src="https://habrastorage.org/files/254/15a/551/25415a5519ac40b288b34325dc05ef8e.png"><br><br>  It is very likely that at least some of the ‚Äúsystem destruction and cleanup after itself‚Äù can be performed without knowing the response from the peripheral device.  Then you can call the peripheral device in a separate thread, and while the device responds, no one will forbid us to perform something from the ‚Äúsystem destruction and cleanup‚Äù clause in the main thread.  Then the block diagram looks like this: <br><img src="https://habrastorage.org/files/854/58e/bb7/85458ebb71a44d8486be07b0a7ae2ed2.png"><br><br>  Well, the second big consequence of breaking this single thread of execution is that you can use more resources of the computer on which the code is executed.  If this is some kind of laborious mathematical calculation, then it can be run on several threads (provided that the calculation algorithm allows it), and then several processor cores will immediately work on the result.  That is, in the abstract formulation: if in several streams to compete for some resource, then it can be obtained more in the same period of time.  Although, I have already said that this point is very doubtful for me in the case of server code (and we are considering just such a one). <br><br><h4>  Disadvantages and difficulties of parallelization </h4><br>  The biggest, and the only significant, I think - is the additional cost of maintaining multi-point, both at run time (the threads need to somehow share information with each other so that they can work for the common good) and during development time (multi-threaded / asynchronous programs are harder to write and maintain, since it is much easier for the human brain to perceive the linear logic of execution).  After all, we always perceive the world ‚Äúhere and now‚Äù, and to realize that somewhere else something else is happening, always turns out not as bright as the current scene ‚Äúhere and now‚Äù.  It turns out that a multi-threaded program will consume more resources, performing the same task as a single-threaded program.  It is also very likely that it will require more time to develop and maintain / expand.  What is the result?  Multithreading <b>can</b> give an increase in the speed of work due to parallel execution, and multipoint <b>will</b> consume more resources due to the need for synchronization and data exchange between threads.  In general, as always: parallelization is just a tool.  If used properly, it can be useful, otherwise it will be overweight. <br><br><h4>  What made me implement multithreading in PHP </h4><br>  I am working on a website that estimates the cost of sending a parcel from point A to point B. In essence, this is an aggregator of freight forwarders API.  Well, you guessed it?  With the cold cache, in the worst cases, it could turn out that from 1 incoming request to my website they ‚Äúgrow‚Äù under 200 requests for API from different carriers.  Naturally, making 200 synchronous HTTP requests is a sin much worse than twisting multithreading in PHP.  Therefore, out of 2 evils, I chose the least.  I really had one in a million cases in this situation.  Additional threads do not consume a lot of CPU cycles, no network, no hard disk, very roughly speaking, I needed threads in which I just needed to sleep for 1-2 seconds (while the carrier‚Äôs API response is generated).  Disclaimer: Think 10 times, first implement it somewhere in the project.  In 8 years of work, I first met a case where it makes sense.  Wear this collar around your neck only if you <b>really</b> need one. <br><br><h4>  The evolution of my thoughts (my algorithm) </h4><br>  Before I get to the concrete implementation methods that I have tried, let me introduce some theoretical reflections on this topic.  The largest division of the algorithms is split along the fork / thread line of the current PHP process or the launch of a new child process.  First, I found only 1 possible implementation on forking the current PHP process (which turned out to be inoperative to everything else).  Secondly, fork in PHP is clearly an example of poor parallelization.  Why?  Yes, because in a parallel stream, you should try to bring out only the action that is performed slowly (communication with the peripheral device, and not the interpretation of its response; the execution of the HTTP request, and not its interpretation again).  See the item about parallelizing server code at the top to see why you need to do this.  Thirdly, fork'aya full program, you commit yourself to synchronize data between them, and it is very difficult.  On the other hand, if you create a child process with literally a couple of lines of code that perform some kind of dreary and long-sleeping operation, you don‚Äôt need to synchronize anything and you don‚Äôt ‚Äúcrawl‚Äù to the other cores of your server.  Well, as a bonus, this approach is much more flexible - you can run not a PHP child process, but a bash script or C program, or whatever it is, only your imagination limits you (and Linux knowledge, of course). <br><br>  Let us dwell on child processes.  How can you organize communication between parent and child processes?  Of course, you can organize their communication on files, you can on the database or on some other data storage.  But to support the ‚Äúzoo‚Äù files of 200 pieces for each incoming request in my particular case looked very gemmno.  I didn‚Äôt want to work with the database in order not to exhaust connections to MySQL (after all, it would be 200 connections per 1 incoming request - with such arithmetic I won‚Äôt be able to scale my code too much and I very quickly put it into the number of connections to the database).  Fortunately, good old Linux already has tools for communication between processes (it has been for 20 years already and it seems that everyone has enough of it, which means that it should be enough for me and you too).  Thus, my goal was to find such an ideal implementation of creating child processes so that: <br><ol><li>  The parent process could write to the child's STDIN; </li><li>  The parent process knew the PID of the child process (useful if you need to send some kind of signal to the child process or check whether it has finished its work); </li><li>  The parent process could read from the STDERR and STDOUT child process; </li><li>  The parent process knew the exit code of the child process when it was completed; </li><li>  The child process knew the PPID (PID of its parent).  Again, this can be convenient for communicating via signals.  As we mentioned above, we will mainly consider parallelization through the launch of a child process.  The child process does not have to be a PHP interpreter, so this clause does not relate directly to the parent and parallelize PHP in general.  It is more likely a problem of the child process to get around the situation and find out your PPID. </li></ol><br><br><h5>  Via curl_multi_exec () </h5><br>  As for me, the most delusional thing I saw about PHP parallelization is to run <code>curl_multi_exec()</code> on my own website.  If you want to execute something asynchronously on the local OS, why do you even need to connect the HTTP stack to this case?  Just because cURL can do asynchronous requests?  The argument is weak.  Implementing asynchrony in such a way is relatively convenient, but you will have an extra load on your web server, and it will be more difficult to configure it optimally in terms of max child work processes (in Apache prefork MPM this is ‚ÄúMaxClients‚Äù, in PHP FPM this is ‚Äúpm.max_children‚Äù) because  it is very likely that there is a huge difference between valid incoming requests and your internal requests that are degenerate from asynchrony.  Well, you can forget about data synchronization issues between subprocesses.  Your maximum communication is an HTTP request and an HTTP response.  You can still communicate through the database, but I'm afraid to imagine what you have to do if you use transactions and you need to see the same transaction from both handlers. <br><br>  Another thing, if the requests are sent to another server, as in my case.  Here, I consider using <code>curl_multi_exec()</code> to be justified.  Your main plus: you can start with a half-kick, there is no need to do much work.  Your disadvantages: not every program logic can be ‚Äúturned out‚Äù in such a way that it is possible to run several cURL requests from one place and process their results in the same place.  For example, requests can go to 2 different hosts, and each of the hosts can respond in its own format.  Thus, your code can easily become inconvenient in supporting around this <code>curl_multi_exec()</code> call.  The second disadvantage is that you have little flexibility.  In this approach, you can never do anything other than HTTP requests asynchronously. <br><br>  An example (I will say straight away, I didn‚Äôt really try it very hard, because the inflexibility of this approach strongly scared me away): <a href="http://php.net/manual/en/function.curl-multi-exec.php">php.net/manual/en/function.curl-multi-exec.php</a> <br><br><h5>  Via pcntl_fork () </h5><br>  If you compile PHP with the <code>--enable-pcntl</code> , then the PHP functions _ * () will appear in PHP.  These functions provide the framework for forking the current PHP process.  The most interesting of these is <code>pcntl_fork()</code> .  She does the fork of the PHP process and in the parent process returns the PID of the child, in the child it returns zero.  While I was typing this code just an example, I had a question in my head.  And if PHP works as an Apache module from under an Apache process worker, how will fork happen here?  After all, in theory, fork will be a whole Apache worker process.  And then how does the Apache master process respond to this case?  There was a kind of division by zero in the air ... By the time I finished typing example with <code>pcntl_fork()</code> , the answer became obvious.  Still not guess?  Everything is very simple!  When PHP runs from under the Apache module, <code>pcntl_fork()</code> not declared, even if your PHP is compiled with the appropriate flag. <br><br>  Supposedly, <code>pcntl_fork()</code> can be used when PHP is running from the CLI.  I am not sure about the CGI and FastCGI interfaces.  Since  I was limited in time and did not study the vacuum space in the full moon of a leap year, but solved a specific problem, then I no longer paid attention to this option.  As I understand it, if <code>pcntl_fork()</code> can be run from the FastCGI interface, then this option should work with the Nginx + PHP-FPM bundle (Apache can also be used instead of Nginx in this formula, just who uses Apache with PHP-FPM?).  Maybe someone from the readers have more experience in this issue?  Write comments, and I will expand this section according to your additions.  I can assume that you expect enough problems related to file descriptors and connections to the database, if you go through the fork. <br><br><h5>  Through exec () </h5><br>  The quickest implementation method that allows you to run any command in the OS (read ‚Äúvery flexible‚Äù).  Before the collision with my current task, I only once resorted to this function.  But I had another case there, I just needed to run the command, give it input arguments and forget about it.  I didn't need any answers from her.  In the process of execution, the team itself will write down the result itself.  Then I implemented it like this: <br><pre> <code class="php hljs">exec(<span class="hljs-string"><span class="hljs-string">"my-command --input1 a --input2 b &amp;"</span></span>)</code> </pre><br>  Without an ampersand at the end of the command, it would be executed synchronously, i.e.  The PHP process would have slept until the end of the work of the team.  To tell the truth, I didn‚Äôt stay too long with this method, but in theory, all the necessary input arguments can be passed through the command arguments.  STDERR and STDOUT commands can be redirected to files or named pipes.  If you really need, you can pre-write STDIN to a file or a named pipe.  In the worst case, it turns out somewhere such Frankenstein: <br><pre> <code class="php hljs">exec(<span class="hljs-string"><span class="hljs-string">"my-command --inputargument1 a --inputargument2 b &lt; my-stdin.txt &gt; my-stdout.txt 2&gt; my-stderr.txt &amp;"</span></span>)</code> </pre><br><br>  The biggest drawback is that there is no good way to determine if the team has completed its work.  But if you initially lay down a certain interface of the contents of STDOUT, then you can live quite well and on this method.  You then need to periodically read the contents of STDOUT, and further, based on your protocol of the contents of STDOUT, you can interpret the state of the command.  Under the transfer of meta information about the current status, you can get a separate file descriptor (4th, say). <br><br><h5>  Via popen () </h5><br>  So, our next candidate looks a little better than the <code>exec("my-command &amp;")</code> option.  Have you already noticed that I am trying to build them in ascending order?  This method allows you to run the command and returns the file descriptor to the pipe.  Depending on the 2nd argument of the <code>popen()</code> function, this will be either the STDIN of the child command or the STDOUT of the child command.  It turns out somehow one-sided ... Either deaf or dumb, but conveniently in 1 line and with minimal low-level sea.  I liked this option the most: <br><br><pre> <code class="php hljs">$stdout = popen(<span class="hljs-string"><span class="hljs-string">'my-command --inputargument1 a'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//            STDOUT. //     ,     PHP  //   -   . do_something_while_asynchronous_command_works(); //  ,          // ,     .   // STDOUT        //   (    ).  STDOUT pipe   //   ,    ,   //   . $output = array(); while (!feof($stdout)) { $output[] = fgets($stdout); } pclose($stdout); //         //      . do_something_with_asynchronous_command_results($output);</span></span></code> </pre><br><br>  Supposedly, the <code>pclose()</code> function will return the exit code of the child command.  However, php.net warns that you don‚Äôt need to trust this value.  I can‚Äôt say any additional practical notes about this, because  This method is practically not tested. <br><br>  Among the shortcomings: it is impossible to know the current status of the child team.  Sometimes it can be important.  Imagine that we run 10 asynchronous commands.  They all run for about 2 seconds, ¬± 10%.  And in the main PHP process, at the end of each team we want to interpret the results.  Each such interpretation will take us 0.5 seconds.  If we had the opportunity to find out whether such a subsidiary team finished the work, then we could read the STDOUT of those subsidiary teams that have already completed their work.  And while we are engaged in the interpretation of the current child team, the other running child commands are very likely to have time to complete by the time we are ready to interpret their result.  Alas, we can not do that.  The maximum that we can do in this way is to read STDOUT, and if the STDOUT of the subsidiary command is still open, then our main PHP process will sleep until the subsidiary command closes it or finishes its work (which also implicitly closes pipe).  We lose a little asynchrony, because  in certain situations we can ‚Äúrun into‚Äù a long ‚Äúdream‚Äù of the main PHP process. <br><br>  The second drawback: one-way communication.  It would be nice to have 3 descriptors at once ... for all occasions, so to speak.  And if you can do without STDIN (you can shove all the input data into the input arguments of the child command), then without STDERR it's still more difficult.  Craftsmen can come up with such a solution: <br><pre> <code class="php hljs">$stdout = popen(<span class="hljs-string"><span class="hljs-string">'my-command --inputargument1 a 2&gt;&amp;1'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>)</code> </pre><br>  But then you will have to disassemble the porridge yourself in STDOUT, since  there at any time can be the contents of STDERR.  If you need STDERR, then you have to create named pipes or temporary files and redirect the STDERR stream to them yourself at the OS level.  Looking ahead, I will say that if you really need STDERR, then it is better not to fool with <code>popen()</code> , but go to the next paragraph of the article. <br><br><h5>  Via proc_open () </h5><br>  <code>proc_open()</code> is something like <code>popen()</code> older brother.  He does the same thing, but he can support more than 1 pipe.  Here is an example: <br><br><pre> <code class="php hljs">$descriptorspec = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'pipe'</span></span>, <span class="hljs-string"><span class="hljs-string">'r'</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'pipe'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>), <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'pipe'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>), <span class="hljs-comment"><span class="hljs-comment">//      .    //   ,    ! ); $pipes = array(); $process = proc_open('my-command ‚Äìinputargument1 a', $descriptorspec, $pipes); //  $process ‚Äì      . // $pipes ‚Äì     $desciptorspec // .        //    pipe,    //   PHP     . $meta_info = proc_get_status($process); //  $meta_info      //  ,     ( // )  PID  ).    // http://php.net/manual/en/function.proc-get-status.php //  ,         STDIN. fwrite($pipes[0], $stdin); fclose($pipes[0]); do_something_while_asynchronous_command_works(); // ,        // . $stdout = stream_get_contents($pipes[1]); $stderr = stream_get_contents($pipes[2]); //          // ,      . // $fdX = stream_get_contents($pipes[$x]); foreach ($pipes as $pipe) { if (is_resource($pipe)) { fclose($pipe); } } $exit_code = proc_close($process); $exit_code = $meta_info['running'] ? $exit_code : $meta_info['exitcode'];</span></span></code> </pre><br><br>  Total we have a winner!  It fits us with all the criteria and runs with a fairly small amount of code in PHP.  In practice, I have been using this method for about a week now and have no complaints.  The website and server have not yet seen the real load, because  the website has not yet reached the final stage, but pah-pah-pah I have no reason to complain, and it seems I wrote the code, the possibility of the existence of which I did not believe 10 days ago. <br><br><h4>  Specific tricks and tricks </h4><br>  I told about dry asynchrony implementations in PHP.  But in practice, everything is so simple and beautiful never happens, is not it?  Asynchrony is no exception.  In conclusion, I want to give some tricks that will help you at the application level at the time of applying these techniques. <br><br><h5>  base64_encode (serialize ()) </h5><br>  If you want to exchange information between 2 PHP processes, it is likely that at some point you will want to ‚Äúpush‚Äù some complex data structures inherent in your project between STDIN / STDOUT (read ‚Äúnot scalars‚Äù).  The first thing that comes to mind is to stuff them into the PHP <code>serialize()</code> function (and <code>unserialize()</code> , respectively, on the other side of the channel).  Everything would be fine, but <code>serialize()</code> can insert null byte or something else, and it will break your stream.  I had problems with non-ASCII characters like √°, √≠, √∫.  In the end, in practice, I simply wrap the serialization result in base64 to make sure that no heresy will fall into the I / O streams. <br><br><h5>  Run as early as possible, consume results as late as possible. </h5><br>  Skillful use of asynchronous calling is a big science.  It is not hard to guess that it is necessary to launch an asynchronous child command as aggressively as possible (eager) and read the results of its work as lazy as possible.  After all, this way your team will have a maximum time for execution and your main stream will not be blocked in hibernation, waiting for the end of its work.  Not all program architectures conveniently fall under this principle.  You should understand that to run a child command and the next line to read its result is to make yourself worse.  If you plan to use asynchrony, try to think about your architecture as early as possible and always keep it in mind.  Using my specific example, I‚Äôll say that when I came to understand that I needed to parallelize my PHP process, I had to rewrite the main website engine, having deployed it with a more convenient side to asynchrony. <br><br><h5>  Cover asynchronous call with synchronous cache </h5><br>  Asynchrony is an extra expense.  To synchronize data (if you have one), to create and kill a child process, to open and close a file descriptors, etc.  On my laptop, an asynchronous call to a simple <code>echo "a"</code> takes about 3 ms.  It seems to be not much, but I told you that I have up to 200 asynchronous calls.  200 x 3 = 600 ms.  So I have already lost 600 ms to nowhere. <br><br>  Secondly, supposedly, you are doing something asynchronously because it is executed slowly.  So why not kill 2 birds with one stone?  Cache the results of an asynchronous command in some permanent storage, be it a database, file system or memcache.  Naturally, this item makes sense only if your results do not lose their relevance too quickly.  Moreover, put this cache in front of all asynchronous to avoid those 3 ms.  Just in case, I will give a flowchart of my thoughts: <br><img src="https://habrastorage.org/files/736/ee8/d26/736ee8d2617946308e4177426bbb0f4e.png"><br><br><h5>  A small framework for lazy and practical guys. </h5><br>  Knowing the theory is good.  But usually the lazy and practical guys want to download any library, connect it, pull a couple of methods and solve their problem.  Based on the last solution (through <code>proc_open()</code> ) I created a very small library.  It is also convenient to use for synchronous cache, as I described it in the previous section.  Link: <a href="https://github.com/bucefal91/php-async">github.com/bucefal91/php-async</a> </div><p>Source: <a href="https://habr.com/ru/post/278755/">https://habr.com/ru/post/278755/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278743/index.html">django-controlcenter</a></li>
<li><a href="../278745/index.html">FLIF - free image compression format</a></li>
<li><a href="../278747/index.html">Sublime Text: syntax validation, autocompletion (v.1.1)</a></li>
<li><a href="../278749/index.html">Extortionist KeRanger for OS X: our analysis</a></li>
<li><a href="../278751/index.html">Work with private repositories and other updates of the FlyElephant platform</a></li>
<li><a href="../278757/index.html">Windows-way synchronization settings between systems</a></li>
<li><a href="../278759/index.html">The idea of ‚Äã‚Äãan educational game for schoolchildren</a></li>
<li><a href="../278763/index.html">KTV. New JSON</a></li>
<li><a href="../278765/index.html">AutoCAD & RTree</a></li>
<li><a href="../278767/index.html">Microsoft announced Linux version of SQL Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>