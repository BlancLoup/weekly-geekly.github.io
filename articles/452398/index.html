<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>EFORTH for programmable calculator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the first article in the cycle about 161eForth v0.5b, ending here: habr.com/ru/post/452572 

 The EFORTH translator is now available on the do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>EFORTH for programmable calculator</h1><div class="post__text post__text-html js-mediator-article">  <i>This is the first article in the cycle about 161eForth v0.5b, ending here:</i> <a href="https://habr.com/ru/post/452572/">habr.com/ru/post/452572</a> <br><br>  The EFORTH translator is now available on the domestic MK-161 Electronics calculator!  On May 17, version v0.5b successfully passed my tests, as well as the five author tests TEST-TEST4.  I have achieved what can be done alone, but I think this is only half the story.  It is time to introduce a new tool to the community by opening the code 161eForth for public testing.  I have a list of what to improve and where to ‚Äúwork on stability.‚Äù  Your suggestions and comments will be taken into account when completing work and releasing version 1.0. <br><br>  When transferring the latest version of eForth to the domestic platform, two obstacles were successfully overcome - the relatively low speed of the 8-bit machine, which is programmed in its own input language, and the modest amount of available binary memory (see 2.4.1), only 4096 bytes. <br><img src="https://habrastorage.org/webt/lx/76/pw/lx76pw2yfjmfnqz4wxg9pp_m6ya.jpeg"><br><a name="habracut"></a><br>  When writing 161eForth, ready-made solutions prepared for Callisto, the input language of the new generation for Russian PMK, were used.  This is the technology of implementation of the fort-machine on top of the decimal ALU and "Harvard" architecture, console drivers and the layout of the alphanumeric keyboard, as well as a software terminal based on them that works on the RS-232 serial port.  In addition to the "Electronics MK-161" and the distribution kit 161eForth, you may need a self-made invoice keyboard, where the keys have letters of the Russian and English alphabets.  The letters are arranged alphabetically line by line, from left to right and from top to bottom. <br><img src="https://habrastorage.org/webt/ff/pu/ry/ffpury7pflujlbysn28jipoylgg.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Dr. Chen-Hanson Ting, author of modern versions of eForth, emphasizes in his book [1] the importance of understanding the two components of the Fort.  This is an internal (‚Äúaddress‚Äù) interpreter, allowing the equipment to execute the sewn Fort code, and an external (‚Äútext‚Äù) interpreter, responsible for the dialogue with the person. <br><br>  In two articles I will discuss in detail the most radical solutions used in the implementation of each of these two interpreters on "Electronics".  Exploring these solutions can be helpful and inspiring to transfer eForth to other devices with limited memory and performance.  Understanding the articles will help initial acquaintance with programmable microcalculators (PMC) and the Fort.  I will explain the difficult moments that are unique to ‚ÄúElectronics MK‚Äù and the eForth translator. <br><br>  To begin with, the words eForth are divided into general useful and systemic.  <b>Letter size matters.</b>  <b>The names of ordinary words are defined in capital letters, and system - lowercase.</b>  I also made my innovations in eForth in lower case letters.  The author of eForth offers to conduct the main dialogue in CAPS mode.  When you need to use the system word, switch to time in lower case letters (FP key combination). <br><br>  In the article, all words are written in capital letters to stand out from the text.  In several early eForth implementations, the headers of the system words were eliminated and not outputted by the WORDS command.  This helped to simplify the appearance of eForth and save the attention of those who use the Fort for the first time.  In 161eForth, the headings of these words are saved primarily due to the presence of the SEE colon word decompiler (see video No. 3 at the end of the article), which will not show the names of the system words if their headings are removed. <br><br>  To streamline the article and make it useful, as a reference, I had to use several terms before defining them.  Specialists in the Fort and PMK these terms should be familiar.  Newbies sometimes have to look in the next sections (I put the links in the right places) or re-read the article a couple of times. <br><br>  The 161eForth itself is posted here, along with the source text, the drawing of the keyboard overlay and help words.txt with a description of all the words implemented: <a href="">http://the-hacker.ru/2019/161eforth0.5b.zip</a> <br><br>  I also posted 5 small videos on YouTube illustrating the work of 161eForth for those who do not have the MK-161.  You can <a href="https://www.youtube.com/playlist%3Flist%3DPLr5CZvfCYpd7I0mSe2k61i00E2YZro7BC">watch the entire playlist on YouTube</a> .  Below the first of them, the remaining 4 at the end of the article. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RxarUWHdNTE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  eForth and its implementation </h2><br>  eForth was developed as a modern replacement for the well-known FIG-Fort translator.  To transfer to the MK-161, I chose a 32-bit version 5.2 of the 86eForth translator with indirectly written code, written in 2016 in MASM assembler for the Windows operating system.  This version is described in detail in the third edition of the book ‚ÄúeForth and Zen‚Äù [1].  I advise those who know English to find and study this book, it is very useful for understanding 161eForth. <br><br>  In a personal letter, the author confirmed that 86eForth502.asm from this book is the latest version of eForth.  On the Internet you can find a lot of English-language information on this and previous versions of eForth. <br><br>  The development of eForth followed a scientific path, taught by Professor Wirth using the example of its programming language Oberon.  Each subsequent version of eForth was a simplification of the previous version.  Everything you can do without is removed from the language.  There remains a carefully thought-out set of strong, expressive language constructs, whose power has been tested on more than 40 eForth implementations for various platforms.  Now on the calculator! <br><br>  Being a minimalist dialect of the Fort, eForth does not aim to win the race for the tiniest Fort.  The set of words offered by him is quite practical and can be easily expanded by the programmer in the direction necessary for his tasks. <br><br>  The first version of eForth was released in 1990 in MASM assembler for 8086 processors and worked under MS-DOS.  It contained 31 machine-dependent core words and 191 high-level words.  The idea was simple - you translate only 31 words to your assembler, and immediately get eForth on your computer. <br><br>  This approach has been criticized on the Internet, as the way to minimize the number of words in assembler led to extremely low speed for embedded systems.  Already in the second version of eForth, the maximum number of words began to be implemented on the assembler, which straightened the tilt in the direction of not only easily portable, but also practical programming system. <br><br>  For several years, Bill Munch, the original author of eForth, and his colleague Dr. Chen-Hanson Ting released their eForth releases in parallel.  Each version had its own characteristics.  Other programmers have also made their own efforts for eForth options for different platforms. <br><br>  Version 5.2, released in 2016, contains 71 words ‚Äúcode‚Äù and 110 words ‚Äúcolons‚Äù.  A quarter of a century of searching for the ideal led to a significant decrease in the total number of words.  At the same time, for performance reasons, the percentage of words implemented at a low level has increased. <br><br>  The proposed 161eForth enjoys the generous fruits of this progress, but does not pretend to further develop the trunk line.  My implementation provides the programmer with all the tools present in version 5.2.  When the MK-161 architecture makes the implementation of some 86eForth words impossible or meaningless, instead of discarding the extra, I give the programmers a full replacement by taking it from the ANSI / ISO standard [4].  Those who are looking for minimalism can independently throw out ‚Äúextra‚Äù words, because by tradition 161eForth comes with source code. <br><br>  When implementing eForth, I adhered to the author's understanding.  For example, in my opinion, the FOR NEXT loop with an initial value of n must be executed exactly n times.  In time, Chuck Moore, author of the Forth and colorForth languages, came to the same conclusion.  Unfortunately, eForth uses an outdated agreement and performs such a cycle n + 1 times, with a counter from n to 0. I did not correct this and several other shortcomings, preferring 161eForth compatibility with implementations for other platforms. <br><br>  Since 161eForth is the first practical on-board programming system for MK-161 Electronics, except for the factory language, I traced the long history of eForth and returned a few words to the language that were useful on other platforms and may be in demand now. <br><br>  For example, the new-old variable 'BOOT contains a token (see 3.1) of the word that is executed first after the initialization of the environment, but before the dialogue begins.  By default, 'BOOT contains the TLOAD token for interpreting the code from the ‚Äútext area‚Äù (see 2.4.2).  This allows the programmer to tweak eForth for himself without recompiling the environment, which is not yet possible to produce on board Electronics. <br><br>  The priority tasks of implementation were the saving of binary memory (see 2.4.1) and the increase in speed.  Their solution led to a dramatic decrease in the number of high-level words, because their code takes up this precious memory, by increasing the number of core fast words implemented in cheap program memory (see 2.4.3). <br><br>  As a result, 161eForth contains 129 words of code, 78 high-level words and occupies 1,816 bytes of the MK-161 binary memory, that is, less than half of it.  This gives hope for the metacompilation of its high-level part right aboard the "Electronics". <br><br>  The original eForth for MK-161 is divided into two large parts.  The kernel written in the MK-161 command system is contained in the eForth0.mkl file.  High-level words are defined in SP-Forth language and are located in the eForth.f file. <br><br>  Also in the distribution there is a reference file words.txt, in which all 161eForth words with stack notation and a brief explanation, in one line, are documented. <br><br><h3>  1.1 Kernel source eForth0.mkl </h3><br>  The eForth kernel contains executable code running in the MK-161 program memory (see 2.4.3), which is compiled on the computer into the eForth0.mkp file by standard means, for example, the proprietary MKL2MKP compiler. <br><br>  The kernel source text contained in the eForth0.mkl file is written in <i>Latin mnemonics</i> .  For example, the IHE command for reading the register E (aka R14) is written in this mnemonic as RME.  Being unusual for the owners of the Soviet PMK, Latin mnemonics are convenient for typing from a computer keyboard.  Indeed, it is easier to type strange FX ^ 2 than Fx¬≤ familiar from childhood. <br><br>  The eForth0.mkp file is a kernel stock.  In addition to the primitive code, it contains the kernel header and the tblNames name table, which eForth.f translates into decimal registers during compilation (see 2.4.4).  It is on the basis of eForth0.mkp that the eForth.mkp kernel will be created (see 2.4.3), therefore eForth0.mkl must be compiled first. <br><br><h3>  1.2 Source code for high level words eForth.f </h3><br>  The file eForth.f is fed to the input of the excellent domestic compiler SP-Forth [5].  The file contains definitions for all high-level words.  In time, they can be defined at eForth itself and, possibly, compiled right aboard the "Electronics MK-161". <br><br>  During compilation, eForth.f reads the eForth0.mkp kernel procurement and with its help creates three files in the current directory for subsequent loading into MK-161: eForth.mkp, eForth.mkd and eForth.mkb.  It is eForth.mkb that contains the bodies of high-level words, although their headers are placed in the eForth.mkd file. <br><br>  The fourth file, eForth.mkt, is written on eForth manually and can be edited on board the MK-161 using the built-in text editor.  Each of these four files I will discuss in more detail below (see 2.4). <br><br><h2>  2. Electronics MK-161 </h2><br>  The manufacturer from Novosibirsk calls the MK-161 a vintage acronym.  So the very first calculators were called in the USSR.  The command system MK-161 inherits the command system of the Soviet calculators "Electronics B3-34" and "Electronics MK-61".  This means that programs written for Soviet calculators will go to MK-161 without changes or with minor changes. <br><br>  The reverse is not true.  eForth will not go to the Soviet PMK, because  uses many resources that appeared for the first time in the MK-152/161 and were absent in previous models of the series. <br><br>  Consider the features of the input language and architecture of the MK-161, which influenced the 161eForth (hereinafter referred to simply as eForth) and gave the Russian accent implementation of eForth under discussion. <br><br>  The first of these features is the <b>‚Äújunior address senior‚Äù agreement</b> consistently maintained in MK-161.  For example, the number 1000 = 3 √ó 256 + 232 will be written in two consecutive bytes, as 3 and 232. <br><br><h3>  2.1 Indirect Addressing </h3><br>  Programmed Soviet PMK heard about indirect addressing.  For <i>direct addressing,</i> we explicitly indicate the register number to which we are applying.  For example, the RSP 44 considers the contents of register 44. The P key, which appeared in MK-152, is used to access registers with number 15 and more ‚Äî these registers were absent in the Soviet PMC. <br><br>  For <i>indirect addressing, the</i> number of the required register is not known in advance.  This number is contained in another register.  For example, if register 8 contains the number 44, the command K IP 8 counts the contents of register 44 (R44). <br><br>  Keys K and P can be combined.  For example, the command RK BP 20 will transfer control (GOTO in Latin mnemonics) to the address stored in R20. <br><br>  The peculiarity that turned out to be important for the internal interpreter of eForth is associated with a preliminary increase / decrease in registers with indirect addressing.  This feature is inherited from the Soviet PMK. <br><br>  For example, the commands of indirect reading K PI 0, K IP 1, K IP 2 and K IP 3, before accessing the desired register, reduce by one the contents of registers 0, 1, 2 or 3. Teams K IP 4, K IP 5 and K IP 6 before reading increase by one the contents of registers 4, 5 or 6. <br><br>  Such a ‚Äúmodification‚Äù of the address register allows you to process entire groups of registers in a loop.  It is similar to ++ R and --R in C.  The index register number is important.  It is he who determines whether it will increase (registers 4-6) or decrease (registers 0-3) with indirect addressing. <br><br>  The architecture of 161eForth was affected by the fact that the increase in registers 4-6 with indirect addressing is <i>preliminary</i> .  As a result, the Interpretation Index (IP) located in R6 always <i>indicates the last read byte of the</i> sewn code.  In 86eForth IP always indicates the next byte, not yet read. <br><br>  This is also true for the return stack pointer (RP) stored in register 2. R2 always points to the top of the return stack. <br><br>  A useful feature of the MK-161 is the absence of an increase / decrease in the register if indirect addressing occurs with a new R key. For example, RKIP02 counts the number from the top of the return stack without changing the pointer.  This is Fort R @ ready command.  From the above, it follows that the read value is one less than the address of the next token, which will be executed after returning from the word "colon". <br><br>  When you have to develop or study words that closely interact with the internal interpreter of eForth - be sure to fully understand this subtle point associated with <b>pre-exaggeration</b> . <br><br><h3>  2.2 Tables ordered and associative </h3><br>  Tables MK-161 are located in the program memory (see 2.4.3).  They appeared in Novosibirsk "Electronics MK" and completely unfamiliar to experts on the Soviet PMK.  The address of the used table is always stored in register 9042, but the access to them is different. <br><br>  <i>An ordered table</i> is an array of unsigned 16-bit integers.  eForth contains the following tblTokens table with addresses of primitives (see 3.1.1) ‚ÄîFort words written in the command system MK-161.  The address interpreter (see 3.2) uses tblTokens to quickly execute the sewn code, so eForth tries to always contain the address of this table in R9042. <br><br>  To refer to an ordered table, you need to write the number of the desired element in R9210.  The number n in the register X will be replaced by the value of the element of the table with the number n, the counting starts from zero. <br><br>  <i>Associative tables</i> (‚Äúsearch by value‚Äù) are actively used by eForth, primarily the primitive (FIND), searching for a word by its name.  Also, the tblCHPUT associative table is used when displaying letters on the screen to handle line feeds and other control codes. <br><br>  To search for the element n in the associative table, you must write n in R9212.  The number n in the register X (the manual calls it ‚Äúthe index‚Äù) will be replaced by the 16-bit value recorded in the table immediately after its ‚Äúindex‚Äù n. <br><br>  The presence of this fast, albeit unpretentious search function implemented in assembler in the ‚Äúfirmware‚Äù MK-161, helped eForth to achieve acceptable performance when recognizing word names and compiling programs.  Of course, for this it was necessary to develop not the simplest name recognition tables, ‚Äúsharpened‚Äù for this function.  Let's talk about this in more detail in the second article. <br><br><h3>  2.3 Interrupts and console </h3><br>  "Electronics MK" allows its owners to write programs in the input language that react to certain events, such as pressing or releasing a button, ending a timer account. <br><br>  eForth actively uses this <i>interrupt system</i> both for keyboard input and displaying a flashing cursor when requesting such input, and for input / output via the universal serial port (RS-232). <br><br>  The letters entered from the keyboard are put in the bufKbd queue as you press the keys.  It is very convenient and saves time on systems with low speed.  Alphabet and register switches are handled by the KeyPress interrupt and do not take up space in the queue.  A long press on the key causes auto repeat. <br><br>  When the queue of 8 letters is full, and eForth is not yet ready to process the input (the situation is very rare), the MK-161 will emit a disgruntled squeak.  Of course, I would not like to implement all this natural work of the keyboard in the translator, but to get it out of the box of the MK-161, as a service of the firmware (firmware).  But so than, as they say, rich. <br><br>  After starting the work, the entire eForth output is directed to the <i>graphic screen</i> MK-161.  The output of the letter to it is carried out by a relatively simple subroutine ChPut.  The only difficulty here is associated with the implementation of the BS control code, the space back.  MK-161 uses a proportional font.  Therefore, in a special buffer tblBS, you have to memorize the positions of the characters that were output, from which they later get the output code BS. <br><br>  During the dialogue, the user can use the word IO&gt; redirect all I / O to the RS-232 serial port, which makes it possible to <b>program the MK-161 from a familiar computer keyboard or from another MK-161</b> .  The word CON&gt; returns control to the calculator console. <br><br><h3>  2.4 Memory and installation of eForth on the MK-161 </h3><br>  Memory "Electronics MK-161" consists of separately addressable program memory and a register data memory.  In turn, the register memory is heterogeneous and is divided into three large areas. <br><br>  Registers numbered from 0 to 999 store "decimal numbers."  These are the usual registers, as in "Electronics B3-34" and other calculators.  They are simply able to store not 8, but 12 decimal places of the "mantissa". <br><br>  Registers with numbers from 1000 to 8167 store integers from 0 to 255. The last 3 KB of this area with addresses from 5096 to 8167 are called <i>the text area</i> . <br><br>  Registers with numbers from 9000 to 9999 are called <i>function registers</i> .  This service area of ‚Äã‚Äãthe address space resembles microprocessor I / O ports.  Using the write and read commands to these addresses, access to I / O devices, an interrupt system, etc. is realized. <br><br>  To install eForth on ‚ÄúElectronics MK-161‚Äù, it is enough to transfer four files to the calculator, for example, using the program of the manufacturer MK.EXE: <br><ul><li>  Write eForth.mkp to the program memory, starting from page 0. Version 0.5b takes 74 pages. </li><li>  Write eForth.mkd to decimal data memory </li><li>  Write eForth.mkb to binary data memory </li><li>  Write eForth.mkt to text memory </li></ul><br>  After transferring to the calculator, I recommend that you immediately <b>save these four files in a separate directory of the</b> built-in "electronic disk".  Since they have the same name, you can download eForth immediately at once, as a ‚Äúpackage‚Äù. <br><br><h4>  2.4.1 Binary ("byte") memory MK-161: eForth.mkb </h4><br>  Registers "Electronics MK" with numbers from 1000 to 5095 are used to store numbers from 0 to 255. This area of ‚Äã‚Äãthe register memory of the calculator is called binary.  Two consecutive binary registers can be accessed from eForth, as one 16-bit ‚Äúcell‚Äù, and (as everywhere else on MK-161) the upper 8 bits are in the register with a lower number. <br><br>  eForth uses this tiny ‚Äúbinary memory‚Äù as its main memory.  Words work with her!  and @, HERE and ALLOT, only from here the address interpreter executes the sewn code (see 3.2).  There are eForth variables, a text input buffer (TIB), a dictionary and a rollback tblBS stack to implement a space back. <br><br>  4096 bytes is very modest, by modern standards.  Therefore, enormous efforts were expended to bring to the other areas of memory everything that was possible. <br><br><h4>  2.4.2 Text Area: eForth.mkt </h4><br>  Immediately after the binary memory follows <i>the text area</i> , registers with numbers from 5095 to 8167. Technically, these are the same byte registers, but the ability to write them to disk and read them in a separate file makes this area special. <br><br>  To work with "text" in eForth is the word TLOAD.  It feeds the entire area to the input of the text interpreter, as a string, 3072 characters long. <br><br>  There is disagreement on how to break the text into lines.  The editor built into MK Electronics insists on the length of the line of 24 characters.  Callisto uses the Fort convention, where the string contains 64 characters.  eForth provides a choice to the user, counting all the text as one long line.  You can use the built-in editor MK-161.  You can write your own, compatible with Callisto. <br><br>  Here is the initial content of eForth.mkt, for convenience, divided into three lines: <br><br><pre><code class="plaintext hljs">: hi ." , %user%!" CR ; ' hi 'boot ! hi \</code> </pre> <br>  The first line defines the new word hi, welcoming the user.  The second line takes the token of this word (see 3.1) and places it in the variable 'BOOT (see 1).  Now the text area will no longer compile each time you start eForth.  Instead, the already compiled greeting is executed. <br><br>  The last line starts the word hi, displaying the greeting on the screen.  The word \ ends the interpretation of the text, returning control to the console. <br><br>  To compile an arbitrary text file, you need to go to the calculator with the BYE command, go to the main menu and load the desired file in DOS mode.  You can also transfer the mkt file from the computer.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The C / P key will return you to eForth, after which the TLOAD command will be able to compile the file loaded into the text area. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.3 Program Memory: eForth.mkp </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory programs MK-161 - isolated address space. </font><font style="vertical-align: inherit;">It also stores bytes, but they are read-only. </font><font style="vertical-align: inherit;">The program memory contains 10,000 ‚Äústeps‚Äù, which turned out to be redundant for eForth. </font><font style="vertical-align: inherit;">More than a quarter of the program memory was free, which gives a good start for the development of the translator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only in the program memory can ‚Äúcode words‚Äù be realized. </font><font style="vertical-align: inherit;">Also here are the name recognition tables and all known text strings, which saves binary memory. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some words, such as C @, COUNT, and TYPE, can address program memory if the address is not a positive number. </font><font style="vertical-align: inherit;">For example, the phrase 0 C @ counts the ‚Äúpitch‚Äù (byte) from the address 0 of the program memory.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2.4.4 Decimal memory: eForth.mkd </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registers "Electronics MK" with numbers from 0 to 999 are called decimal and contain the numbers used for normal calculations on the calculator - 12 decimal places "mantissa" and 2 decimal places "order". The fort is designed to work with integers up to 4 bytes long, such a resource is clearly redundant for eForth. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decimal memory is used to save precious binary memory. These are stacks of data and returns. It also stores the headings of words - both user-defined and embedded, one register per title. This approach allows you to override even words that have standard names.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The stack in decimal memory leads to a number of features characteristic of the Fort on the MK-161. First, the range of values ‚Äã‚Äãof the elements of the stack is huge, it is capable of containing 32-bit integers. The need for "double integers" on the MK-161 is no longer necessary, although for the sake of compatibility I have implemented the corresponding words eForth. "Double integers" are presented on the MK-161, as two stack elements containing numbers from 0 to 65535, encoding a single 32-bit integer with a sign in the additional code. The older 16 bits of such a number are placed on top, that is, at the lowest address.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bitwise logical operations AND, OR, XOR and NOT treat their arguments as 16-bit integers. The result from 32768 to 65535 is converted to negative numbers from -32768 to -1. In eForth, false is encoded as zero, and true is minus one. Also true is any value other than zero. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second feature of the 161eForth data stack is that it contains signed numbers. When the word @ reads the number 65535 from a 16-bit "cell", it is automatically converted to -1. A </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">special "unsigned" word U @ is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> provided </font><font style="vertical-align: inherit;">for counting 65535 directly, with a plus sign. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I mention that in order to speed </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the two top stack element</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> data are not arranged in the decimal memory, directly </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to X and Y registers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact that decimal registers can contain fractional numbers and floating point numbers is not used by eForth. </font><font style="vertical-align: inherit;">The eForth virtual machine uses these registers to store signed 12-bit decimal integers. </font><font style="vertical-align: inherit;">Appeal to decimal registers carry the word C @ and C! </font><font style="vertical-align: inherit;">- the same that work with any single registers.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. Internal interpreter </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The eForth kernel is a program written in the input language MK-161. Her first BPU MAIN team transfers control to the MAIN code, which first determines the circumstances of the reboot. If the wrong token caused it, MK-161 squeals. When you first start, as well as after turning on the MK-161, the screen is cleared. Next, MAIN calls the Init subroutine to initialize the interrupt system and everything the MK-161 console drivers need. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After initialization of data stacks and returns, the low-level part of the start is complete. There is an incredible for machines with Harvard architecture - eForth goes to the execution of "sewn code" from byte memory. The honor of being the first belongs to a word whose heading address is recorded in R43. This is usually the word COLD. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How are </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the high-level words</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(IED)? Any word consists of two parts, body and heading. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The title</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is stored in decimal case. It helps the external interpreter and decompiler to find the name and body of the word. The header also contains </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a ‚Äúlexicon‚Äù field</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a set of flags that help the external interpreter correctly process the found word. The internal interpreter is much more important than the body of the VCA, located in binary memory and stored in the dictionary. He can even execute words that have no heading. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The body of the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VCA begins with a byte of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the code field</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that contains the address of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">processor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">given word. Four VCA handlers are written in the input language MK-161 and begin on the first page of the program memory. We will analyze them all (see 3.3), but the main one is called DOLST and is located at address 02, immediately after the already reviewed team of the MAIN BP. This handler executes Fort words defined with a colon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the byte of the code field, there is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">field of parameters of</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arbitrary length. In the ‚Äúwords of the colon‚Äù, the parameter field contains a ‚Äústitched code‚Äù - a sequence of 16-bit tokens, each of which represents one action assigned to it.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First we will look at the token in more detail. </font><font style="vertical-align: inherit;">Then we will study the internal interpreter INEXT, making the transition from one token to the execution of the next. </font><font style="vertical-align: inherit;">The author of eForth calls INEXT a primitive handler. </font><font style="vertical-align: inherit;">We will conclude this tour through the internal interpreter with an analysis of all four VCA processors.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.1 Tokens </font></font></h3><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The token</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> represents a word in the stitched code and stack, allowing it to be quickly executed. </font><font style="vertical-align: inherit;">The token is a pointer to the body of the word, but the severe architecture of the MK-161 has made its own adjustments to this simple idea. </font><font style="vertical-align: inherit;">Let's sort all types of tokens, starting with a token of primitives.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.1.1 Primitive Token </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All words included in the eForth distribution are numbered from 0 to 206. This numbering is through, taking into account both the primitives and the VCA. This is done to make it easy to restore his </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">name by the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> word number </font><font style="vertical-align: inherit;">. These names are stored in the program memory. A link to the desired name is easy to find through the header table. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The number of the primitive is its token</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Like any token, the primitive occupies two bytes in the sewn code. The first is zero. The second contains his number. The tblTokens table allows you to quickly find the address of the primitive code by this number. The tblTokens address is permanently stored in R9042 (see 2.2), that is, everything is always at hand to execute the primitive.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The word XT&gt; allows you to find out the address of the primitive code by its number (token). </font><font style="vertical-align: inherit;">Since the primitive code is always located in the program memory, the resulting address is always negative (see 2.4.3).</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.1.2 IED Token </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The VCA may have its own number and the standard name associated with it, or it may be completely new, created by the user. </font><font style="vertical-align: inherit;">In all cases, the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VCA token is the address of its code field</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (see 3), that is, the number is from 1000 to 5095. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the </font><font style="vertical-align: inherit;">sewn </font><font style="vertical-align: inherit;">code, the VCA token is recorded in a very unusual way. </font><font style="vertical-align: inherit;">The first byte is the number of hundreds (a number from 10 to 50), the second is the remainder of the division of a token by 100 (a number from 0 to 99). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, token 1234 will be represented by two bytes 12 and 34. Compilation of this, and of any other token, is performed by the word taken from the ANSI standard COMPILE ,. </font><font style="vertical-align: inherit;">To write and read VCA tokens in the sewn code are the words XT! </font><font style="vertical-align: inherit;">and xt @. </font><font style="vertical-align: inherit;">They also access the addresses (see 3.1.4), and the word XT @ can also read the token of the primitive.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.1.3 Whole Literals </font></font></h4><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entire literals</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are a type of primitive tokens. </font><font style="vertical-align: inherit;">They are unusual enough to be considered separately. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the stitched code, the DOLIT and DOLITM tokens occupy four bytes. </font><font style="vertical-align: inherit;">The first two bytes contain the already considered token of the primitive, that is, 0 and the number of the primitive. </font><font style="vertical-align: inherit;">The next two bytes contain the integer that the given literal will put on the data stack when executed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DOLITM differs in that it changes the sign of a number before putting it on the stack. </font><font style="vertical-align: inherit;">It is intended to implement negative numbers.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.1.4 Address Literals </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Like whole literals, the three </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">address literals</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BRANCH,? BRANCH and DONXT occupy 4 bytes each in stitched code. The first 2 bytes contain the primitive token, the last two contain the transition address. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The address is written in the same format as the VCA token (see 3.1.2). In the first byte, the number of hundreds goes, in the second - the remainder of the address division by 100. Let me remind you that due to the pre-exaggeration (see 2.1), the transition address contains not the address of the desired token, but a number that is one less.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The DONXT token helps implement the FOR-NEXT ‚Äúend loop‚Äù (see 1). </font><font style="vertical-align: inherit;">The unconditional BRANCH transition is needed to implement the infinite BEGIN-AGAIN loop. </font><font style="vertical-align: inherit;">A conditional transition? BRANCH transfers control if there is zero (‚Äúfalse‚Äù) on the top of the data stack. </font><font style="vertical-align: inherit;">It serves to implement the conditional IF-THEN operator, exits from the ‚Äúundefined cycles‚Äù BEGIN-UNTIL and BEGIN-WHILE-REPEAT.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.1.5 String Literals </font></font></h4><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String literals</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are a type of VCA tokens. </font><font style="vertical-align: inherit;">In the stitched code of the string literal after the token, there is a byte with the length of the string, after which the string itself, from the first byte to the last. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EForth has three string literals: $ "|,." | </font><font style="vertical-align: inherit;">and abort "|. They are defined in the eForth.mkl file as STRQP, DOTQP and ABORQ tokens, respectively. The main" literal "work is done for them by the word do $, the DOSTR token. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To make the size of the article reasonable, I cannot dwell too much on this interesting topic, but it is nice to know about their availability in eForth.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.2 Address Interpreter </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The time has come to consider the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpreter of tokens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , whose address is always written in register 9. Most primitives complete their work with the command K BP 9, which transfers control to the INEXT tag.</font></font><br><br><pre> <code class="plaintext hljs">INEXT: 6 Fx‚â†0 NPrime NData:  2 6 + 7 F‚ü≥ 7 8 F‚ü≥ 8</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, the address interpreter reads the first byte of the next token with the KIP6 command. If it is zero, it is a primitive and the token will be processed by the code under the label NPrime. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The NData tag designates the processing of the VCA token. The first byte is multiplied by one by the command VP 2, after which KIP6 + adds the second byte of the token to the result (see 3.1.2). The read token is entered by the P7 command into the WP working register (R7). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We know that the VCA token is the address of its code field, which contains the address of the processor. The CIP7 P8 commands read the code field byte at R8, and the KBP8 command transfers control to the VCA handler. The handler knows that there is a number in R7 that is one less than the address of the parameter field of the word being processed.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F‚ü≥ commands with code 25 ‚Äúclean up‚Äù on the stack. The fact is that eForth stores the two top items of the data stack directly in the X and Y registers of the MK-161 stack. Such a decision speeds up the work, but makes sure that this important data is not lost. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains to understand how the address interpreter executes primitives.</font></font><br><br><pre> <code class="plaintext hljs">NPrime: F‚ü≥ 6 9210 8 F‚ü≥ 8</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The KIP6 command reads the second byte of the token primitive. </font><font style="vertical-align: inherit;">The RRP9210 P8 commands read from the tblTokens table the address of this primitive (see 2.2 and 3.1.1), and the KBP8 passes control to this primitive. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As above, F‚ü≥ removes the excess from the stack, restoring the contents of the X and Y registers. The </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForth address interpreter is so tiny that it is duplicated several times in the program memory. </font><font style="vertical-align: inherit;">The main copy is executed by the command K BP 9, which ends most of the primitives. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an exercise, I recommend studying the implementation of the word EXECUTE, placed after the EXECU tag. </font><font style="vertical-align: inherit;">This is the INEXT variant, which reads the token not from the sewn code, but takes it from the data stack.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.3 Handlers of VCA </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Four types of VCA have four different handlers: DOLST, DOVAR, DOCON and DOCONM. </font><font style="vertical-align: inherit;">We have already seen above that the address interpreter, before calling the handler, leaves in R7 the address of the code field of the word being processed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eForth.f finds the addresses of these handlers by reading the kernel header from the eForth0.mkp file. </font><font style="vertical-align: inherit;">This helps him to correctly compile the VCA for "Electronics MK-161", placing the result in the file eForth.mkb.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.3.1 Colonals: DOLST and EXIT </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next important issue after INEXT is what the internal interpreter does when it encounters the token of a word defined through colons. </font><font style="vertical-align: inherit;">The code field of such a word contains the number 2, so INEXT transfers control to the DOLST handler, which performs the necessary work to begin interpreting the new list of tokens.</font></font><br><br><pre> <code class="plaintext hljs">DOLST: 6 2 F‚ü≥ 7 6 F‚ü≥ INEXT:</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register 2, as we have already discussed (see 2.1), contains the return pointer RP. The IP6 KP2 commands write to the return stack the value of R6 - Interpretation Index (IP). Later it will help to remember the current position in the old list of tokens, where INEXT came across the word colon. Now IP7 P6 rearranges IP to the beginning of the new list. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediately after the DOLST code, the INEXT code is placed, which will execute the first word of the new list of tokens. Like everywhere else, the F‚ü≥ commands help keep the top two items in the data stack. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colon words are usually terminated with the EXITT token, which does the reverse operation, in comparison with DOLST ‚Äî it retrieves the old IP value from the return stack and returns to interpreting the old list of tokens.</font></font><br><br><pre> <code class="plaintext hljs">EXITT: 02 6 x 1 2 + 2 F‚ü≥ INEXT:</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RCCP02 P6 commands read the old IP value from the top of the stack of returns (see 2.1). </font><font style="vertical-align: inherit;">After that, the Cx 1 IP2 + P2 commands correct the RP value by increasing it by one. </font><font style="vertical-align: inherit;">The F‚ü≥ command restores the stack, after which INEXT executes the next word from the old list of tokens. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, INEXT can not simultaneously go after DOLST, and after EXITT. </font><font style="vertical-align: inherit;">To do this, I applied one ancient trick of the times of the USSR. </font><font style="vertical-align: inherit;">You can also master it by examining the corresponding lines of the eForth0.mkl file.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.3.2 DOVAR, Variable and Array Handler </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Words generated by the words CREATE and VARIABLE use the same DOVAR handler. </font><font style="vertical-align: inherit;">This handler puts on the stack the address of a variable placed in the parameter field that comes right after the byte of the code field. </font><font style="vertical-align: inherit;">Variables VARIABLE occupy 2 bytes, and arrays created with CREATE contain as many bytes as the programmer wants.</font></font><br><br><pre> <code class="plaintext hljs">DOVAR: ‚áî 3 x 1 7 + 9</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KP3 commands ‚áî save the contents of the Y register in the data stack. At the same time, the number from the top of the stack is entered into RY, freeing the RX to a new value. </font><font style="vertical-align: inherit;">After the Cx 1 IP7 + commands, this new value at the top of the stack becomes the address of the parameter field of the word being executed. </font><font style="vertical-align: inherit;">KBP9 transfers control to INEXT, without any tricks, making the transition to the next word.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.3.3 Constant Handlers: DOCON and DOCONM </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unlike DOVAR, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the constant handler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> accesses the parameter field of its word itself. DOCON reads a 16-bit constant value from it. This value is always positive.</font></font><br><br><pre> <code class="plaintext hljs">DOCON: ‚áî 3 ‚áî 7 5 x 256 5 √ó 5 + 9</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commands ‚áî KP3 ‚áî save RY in the data stack. But this time the old top of the data stack returns to the RX. The IP7 P5 commands push it back to RY, at the same time preparing the register-pointer R5 to read the value of a constant. Then Cx 256 replaces the garbage in the X register with the number 256. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The KIP5 √ó KIP5 + commands read a constant from the parameter field to the top of the data stack, that is, in the RX. As we remember, in MK-161 the first byte is always the oldest. It is multiplied by 256, after which the low byte of the constant is added to the product. All the work has been done, KBP9 transfers control to the next word. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DOCONM works in the same way, only the sign of the constant after reading is changed to the opposite. Negative constants are implemented on the MK-161 by a separate handler for the sake of speed:</font></font><br><br><pre> <code class="plaintext hljs">DOCONM: ‚áî 3 ‚áî 7 5 x 256 5 √ó 5 + /-/ 9</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have completely figured out how eForth executes its code on the ‚ÄúMK-161 Electronics‚Äù from the data area, even slightly touching on the deeper topic of string literals (see 3.1.5). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the second article of the cycle, I will talk about the external "text" interpreter 161eForth, analyze the structure of the header tables and name recognition. </font><font style="vertical-align: inherit;">This part of the translator demanded from me the development of much more radical solutions, against the background of which the traditional Fort, old and kind, dismantled above. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Happy programming on the Fort!</font></font><br><br><h2>  Literature </h2><br><ol><li>  Dr.  Chen-Hanson Ting.  eForth and Zen - 3rd Edition, 2017. Available on Amazon Kindle. </li><li>  Baranov S.N., Nozdrunov N.R.  Language Fort and its implementation.  - L .: Mechanical Engineering.  Leningrad  Separation, 1988. </li><li>  Semenov Yu.A.  FORT programming.  - M .: Radio and communication, 1991. </li><li>  Standard ANS Forth.  X3.215-1994.  <a href="http://oco.org.ua/download/forth/dpans94_ru.html">Translation</a> . </li><li>  <a href="http://spf.sourceforge.net/docs/readme.ru.html">SP-Forth documentation</a> . </li><li>  <a href="https://sites.google.com/offete23.com/eforth/home">The website of Offete Enterprises (Dr. Chen-Hanson Ting)</a> , by 86eForth v5.2, is in English. </li></ol><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Video illustrations </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These four small videos about 161eForth - continued. </font><font style="vertical-align: inherit;">The first video at the beginning of the article. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part 2 of 5. TEST-TEST4 tests from the book ‚ÄúeForth and Zen‚Äù, 3rd edition, on MK-161.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/7UuQSozjuJ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 3 of 5. Decompiler SEE. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/K-mWJuL1fiQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 4 of 5. Breakpoint BYE, RS-232 terminal and remote access to the MK-161. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Cfj60ICJrHU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 5 of 5. Final words. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oAAX29TpH9c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/452398/">https://habr.com/ru/post/452398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452384/index.html">The processor will accelerate the optics to 800 Gbps: how it works</a></li>
<li><a href="../452388/index.html">Sieve of Eratosthenes for O (n). Evidence</a></li>
<li><a href="../45239/index.html">Online service simplest image editing</a></li>
<li><a href="../452392/index.html">A selection of datasets for machine learning</a></li>
<li><a href="../452394/index.html">Opus about His Majesty Clay. Part Two - Viva, cyanoacrylate! Viva, superglue</a></li>
<li><a href="../4524/index.html">Alexander Militsky told how providers sell subscribers</a></li>
<li><a href="../452400/index.html">Non-business</a></li>
<li><a href="../452402/index.html">Experiments with analog tunnel diode</a></li>
<li><a href="../452404/index.html">Five key ITSM trends for this year</a></li>
<li><a href="../452408/index.html">Toilet for Maine Coon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>