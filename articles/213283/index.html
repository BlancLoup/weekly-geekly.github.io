<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mark read: Twitter, VK, LiveJournal, Facebook ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I. What is the problem. 
 Mailboxes, "Inbox" personal messages, RSS - all this combines one convenience: a clear separation of read and unread message...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mark read: Twitter, VK, LiveJournal, Facebook ...</h1><div class="post__text post__text-html js-mediator-article"><h4>  I. What is the problem. </h4><br>  Mailboxes, "Inbox" personal messages, RSS - all this combines one convenience: a clear separation of read and unread messages.  However, in blogs and social networks, at least the most common, such an opportunity is often not provided.  And by coincidence, these resources do not provide users with RSS feeds. <br><br>  It seems to be not so difficult to remember what you read and what you don‚Äôt yet.  But if you follow a very dynamic tape or an active discussion of one topic, it is sometimes not so easy to figure it out right away.  Yes, and constantly reading one or two of the first sentences to idle, just to understand that you already read this, is not such a pleasant and harmless task. <br><br><a name="habracut"></a>  Previously, I used this method: I assigned custom styles on top of the site, which would more clearly highlight the viewed links;  at the end of the next reading, he opened the last (he is usually the top) post separately, so that the link to it got into the history of the browser;  subsequently, the first such reference to the read post and served as a watershed of old and new messages.  However, this is still not a very clear way. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, you can write a whole extension for your favorite browser or a cunning user script for one of the common extensions, but I wanted to find a simple and cross-browser way.  So the next idea was born.  I am not a programmer, so I don‚Äôt set myself the task of offering a ready-made elegant solution, and I understand that my method is clumsy in principle and is certainly ugly in implementation.  Therefore, the description of the problem will most likely be: <br><br>  1. Discuss the problem itself.  Perhaps, fundamentally different ways have long been known, simpler, more reliable and more beautiful.  That is, I pound through the open door and reinvent the wheel.  Share them, please. <br><br>  2. To think together about the features of the current implementation.  Perhaps the method can be improved in large and small.  However, it‚Äôs really quite small, maybe not necessary, we‚Äôre not developing the engine and not the library. <br><br>  That is, all this as a very rough idea. <br><br><h4>  Ii.  The solution in general terms. </h4><br>  A relatively perfect "overlay" method would look like this: the tape consists of homogeneous coordinated elements with constant unique identifiers;  create a <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D1%2583%25D0%25BA%25D0%25BC%25D0%25B0%25D1%2580%25D0%25BA%25D0%25BB%25D0%25B5%25D1%2582">bookmarklet</a> that will take instructions to the last post read, visually mark both it and all older posts following it, memorize the identifier of the last post read and subsequently restore the border on it. <br><br>  But here we come across a number of problems: <br><br>  1. Not always the structure of tapes for all users has the same structure. <br>  2. Not always posts are homogeneous subordinate elements. <br>  3. Not always they have classic identifiers. <br>  4. Not always on the current page from the very beginning of reading is already once read post. <br>  5. Some sites are aggressively tuned to the most convenient cross-browser information storage tool. <br><br>  Examples of these problems will be given in the course of the further description.  But first, let's imagine in the first approximation the implementation of the most optimistic option. <br><br>  Evaluation of the four networks mentioned in the header (listed in the order of complication of diagnosis) shows that the absence of message identifiers can be completed by referring to these messages within the messages themselves: these links are by definition unique and permanent.  Here is where they hide in the networks taken as a model (underlined in red): <br><br>  <b>Twitter</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e5/fe6/cd8/8e5fe6cd82d3ff100f0f8bc2dcc7ef59.png"><br><br>  <b>VK</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76d/bf6/cdc/76dbf6cdc4fa7657b767c3f71f96003b.png"><br><br>  <b>Livejournal</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17e/7b0/88b/17e7b088bd9798c56a6812124642d063.png"><br><br>  <b>Facebook</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/57a/9f5/382/57a9f5382024b140ccfd58e0f8f46026.png"><br><br>  To point the script in the bookmarklet to the desired link, we just select the part of the link right before launching the script (so that the cursor / focus remain inside the link).  The script remembers the address of the link in localStorage for the future, climbs the chain of elements to the main container of the post and assigns it a special class.  The script creates a style for this class and all subsequent subordinate elements so that the entire read segment is highlighted, for example, with a special color. <br><br>  If nothing is selected on the page, the script assumes that we are only starting to read after the break, so it immediately contacts localStorage, extracts a link to the previously read post from it, tries to find it, and then repeats the way to the top container and all operations with styles . <br><br>  The script will need to perform at least three checks with a message about possible unsuccessful results: is the open page a site for which the script is designed and to which the necessary department is assigned to localStorage;  whether the user selected the correct link (or did the selection not accidentally go beyond its borders);  is there a previously read post on the page if the user didn‚Äôt select anything. <br><br>  In the near future, if we have a <a href="http://web-standards.ru/news/840/">parent selector</a> , it will not be possible to deal with localStorage at all, but creating styles along the chain for the great-grandfathers of the browsed links (unless, of course, the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Privacy_and_the_:visited_selector">style restrictions for the browsed links</a> become even more stringent for their parent and ancestors ).  True, then you will have to open the last post separately, so that it will go down in history. <br><br><h4>  Iii.  Private features of the sites analyzed </h4><br>  <b>Twitter</b> <br><br>  Here we were lucky with the ribbon structure (tweets are homogeneous and subordinate).  But the principle of small dosing of tweets with endless scrolling leads to the fact that we may have to scroll down several times until the post reads before the break physically appears on it.  However, a few keystrokes of the ‚ÄúEnd‚Äù key alternately with a bookmarklet are not such a tedious task.  The same problem will persist for VK and Facebook: if the read segment has gone deep into the tape, the script will report several times that the last post was not found before it can mark the border. <br><br>  <b>VK</b> <br><br>  Here, the structure is also okay, but there is a slight warning: when rushing, it is easy to confuse the link to the original post of another person with reference to its repost in our wall (we need the second type of links) - both versions are inside the post and are very similar.  Links to the post itself and comments on it are also similar.  The script is trying to check if the user has confused all these links.  Currently, the script is designed for wall posts and news. <br><br>  <b>Livejournal</b> <br><br>  Here we are faced with a variety of the structure of the tapes of friends from different users.  In order to unify everything somehow, we will take the mobile tape as a base, because it has the same structure for everyone (in the screenshot above, you can see the title link to the post of such tape).  At the same time the need for multiple scrolls will be replaced by the need for multiple downloads of the previous pages.  But this is not the end of the features: not all posts in the feed are equally coordinated, because groups of posts of the same day are in a separate container, which we will not allow for by special CSS3 rules.  Therefore, the script can mark not all the read segment to the end, but only posts that are simultaneously the day with the last read. <br><br>  <b>Facebook</b> <br><br>  The most problematic option.  Posts have a very complex system of subordination, are distributed in several dynamic containers, have a complex system of unreadable classes.  Therefore, the homogeneity of the color of the read can not always be achieved, except that we read the tape for a long time, without closing and reloading the tab.  In addition, the site has a strange handling of localStorage: periodically our script records disappear from there, as if the scripts of the site itself from time to time clean the entire segment of the site in the repository, considering themselves to be the exclusive owner in this area (maybe this is right?).  Moreover, with the most meticulous tracking of friends and journals to which the user is subscribed, messages about the comments of friends in other posts get into the tape, and these messages can constantly move up the tapes, while maintaining a single key link, which destroys the sequence of posts and mechanism tracking.  Therefore, in such posts it is better to highlight the link to the last comment (fortunately, all XPath work, as well as with links to the post itself) so that there is no confusion during repeated comments and shifts of such posts up the tape, including before unread posts. <br><br>  Another minor general warning: the displayed text of the links we need in most networks is automatically updated about once a minute, adjusting to the past time, so sometimes our selection has time to fly before clicking on the bookmarklet - because after the update, the link already becomes a new element of the interface;  this failure does not do any harm, the script simply re-marks the old read post according to the data in localStorage (as if we didn‚Äôt select anything), and just need to select the link again and click the bookmark again. <br><br><h4>  Iv.  Implementation. </h4><br><br>  In theory, it should work in all recent browsers, because standard, albeit relatively new tools are used.  I apologize for the awkward amateurish code. <br><br>  <b>Readable option:</b> <br><br><pre><code class="javascript hljs">javascript:(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xpaths, doc, hst, stl, sel, lnks, i, a_lnk, the_lnk, post</span></span></span><span class="hljs-function">) </span></span>{ xpaths = { <span class="hljs-string"><span class="hljs-string">'twitter.com'</span></span>: { <span class="hljs-string"><span class="hljs-string">'lnk'</span></span>: <span class="hljs-string"><span class="hljs-string">'./ancestor-or-self::a[contains(@class, "tweet-timestamp") or contains(@class, "details")]'</span></span>, <span class="hljs-string"><span class="hljs-string">'post'</span></span>: <span class="hljs-string"><span class="hljs-string">'./ancestor::li[contains(@class, "stream-item")]'</span></span> }, <span class="hljs-string"><span class="hljs-string">'vk.com'</span></span>: { <span class="hljs-string"><span class="hljs-string">'lnk'</span></span>: <span class="hljs-string"><span class="hljs-string">'./ancestor-or-self::a[descendant::span[contains(@class, "rel_date")] and not(contains(@class, "wd_lnk"))]'</span></span>, <span class="hljs-string"><span class="hljs-string">'post'</span></span>: <span class="hljs-string"><span class="hljs-string">'./ancestor::div[contains(@class, "feed_row") or contains(@class, "post") and not(@id="page_wall_posts")]'</span></span> }, <span class="hljs-string"><span class="hljs-string">'m.livejournal.com'</span></span>: { <span class="hljs-string"><span class="hljs-string">'lnk'</span></span>: <span class="hljs-string"><span class="hljs-string">'./ancestor-or-self::a[ancestor::h3[contains(@class, "item-header")]]'</span></span>, <span class="hljs-string"><span class="hljs-string">'post'</span></span>: <span class="hljs-string"><span class="hljs-string">'./ancestor::li[contains(@class, "post-list-item")]'</span></span> }, <span class="hljs-string"><span class="hljs-string">'www.facebook.com'</span></span>: { <span class="hljs-string"><span class="hljs-string">'lnk'</span></span>: <span class="hljs-string"><span class="hljs-string">'./ancestor-or-self::a[descendant::abbr[@data-utime]]'</span></span>, <span class="hljs-string"><span class="hljs-string">'post'</span></span>: <span class="hljs-string"><span class="hljs-string">'./ancestor::div[contains(@class, "_5jmm") and contains(@class, "_5pat") and contains(@class, "_5uch")]'</span></span> } }; doc = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>; hst = doc.location.hostname; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xpaths[hst]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!doc.querySelector(<span class="hljs-string"><span class="hljs-string">'style#usernameReadPost'</span></span>)) { stl = doc.querySelector(<span class="hljs-string"><span class="hljs-string">'head'</span></span>).appendChild(doc.createElement(<span class="hljs-string"><span class="hljs-string">'style'</span></span>)); stl.id = <span class="hljs-string"><span class="hljs-string">'usernameReadPost'</span></span>; stl.innerHTML = <span class="hljs-string"><span class="hljs-string">'.usernameReadPost, .usernameReadPost ~ * {background-color: silver !important;}'</span></span>; } sel = doc.getSelection(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sel.isCollapsed) { lnks = doc.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a[href$="'</span></span> + localStorage.getItem(<span class="hljs-string"><span class="hljs-string">'usernameReadPost'</span></span>) + <span class="hljs-string"><span class="hljs-string">'"]'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>, a_lnk; a_lnk = lnks[i]; i++) { the_lnk = doc.evaluate(xpaths[hst].lnk, a_lnk, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, XPathResult.FIRST_ORDERED_NODE_TYPE, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).singleNodeValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(the_lnk) { post = doc.evaluate(xpaths[hst].post, the_lnk, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, XPathResult.FIRST_ORDERED_NODE_TYPE, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).singleNodeValue; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(post) { post.className += <span class="hljs-string"><span class="hljs-string">' usernameReadPost'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { alert(<span class="hljs-string"><span class="hljs-string">'Read post not found.'</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { the_lnk = doc.evaluate(xpaths[hst].lnk, sel.focusNode, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, XPathResult.FIRST_ORDERED_NODE_TYPE, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).singleNodeValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(the_lnk) { post = doc.evaluate(xpaths[hst].post, the_lnk, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, XPathResult.FIRST_ORDERED_NODE_TYPE, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).singleNodeValue; post.className += <span class="hljs-string"><span class="hljs-string">' usernameReadPost'</span></span>; localStorage.setItem(<span class="hljs-string"><span class="hljs-string">'usernameReadPost'</span></span>, the_lnk.getAttribute(<span class="hljs-string"><span class="hljs-string">'href'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { alert(<span class="hljs-string"><span class="hljs-string">'Wrong link.'</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { alert(<span class="hljs-string"><span class="hljs-string">'Wrong hostname.'</span></span>); } })()</code> </pre> <br><br>  <b>Abridged version:</b> <br><br>  A version with remote formatting spaces and line breaks (in Firefox, you can simply drag the bookmarks and then replace the name with something readable; this code fits into two kilobytes, in case this restriction still applies to the latest versions of IE). <br><br><pre> <code class="javascript hljs">javascript:(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xpaths,doc,hst,stl,sel,lnks,i,a_lnk,the_lnk,post</span></span></span><span class="hljs-function">)</span></span>{xpaths={<span class="hljs-string"><span class="hljs-string">'twitter.com'</span></span>:{<span class="hljs-string"><span class="hljs-string">'lnk'</span></span>:<span class="hljs-string"><span class="hljs-string">'./ancestor-or-self::a[contains(@class,"tweet-timestamp")or contains(@class,"details")]'</span></span>,<span class="hljs-string"><span class="hljs-string">'post'</span></span>:<span class="hljs-string"><span class="hljs-string">'./ancestor::li[contains(@class,"stream-item")]'</span></span>},<span class="hljs-string"><span class="hljs-string">'vk.com'</span></span>:{<span class="hljs-string"><span class="hljs-string">'lnk'</span></span>:<span class="hljs-string"><span class="hljs-string">'./ancestor-or-self::a[descendant::span[contains(@class,"rel_date")]and not(contains(@class,"wd_lnk"))]'</span></span>,<span class="hljs-string"><span class="hljs-string">'post'</span></span>:<span class="hljs-string"><span class="hljs-string">'./ancestor::div[contains(@class,"feed_row")or contains(@class,"post")and not(@id="page_wall_posts")]'</span></span>},<span class="hljs-string"><span class="hljs-string">'m.livejournal.com'</span></span>:{<span class="hljs-string"><span class="hljs-string">'lnk'</span></span>:<span class="hljs-string"><span class="hljs-string">'./ancestor-or-self::a[ancestor::h3[contains(@class,"item-header")]]'</span></span>,<span class="hljs-string"><span class="hljs-string">'post'</span></span>:<span class="hljs-string"><span class="hljs-string">'./ancestor::li[contains(@class,"post-list-item")]'</span></span>},<span class="hljs-string"><span class="hljs-string">'www.facebook.com'</span></span>:{<span class="hljs-string"><span class="hljs-string">'lnk'</span></span>:<span class="hljs-string"><span class="hljs-string">'./ancestor-or-self::a[descendant::abbr[@data-utime]]'</span></span>,<span class="hljs-string"><span class="hljs-string">'post'</span></span>:<span class="hljs-string"><span class="hljs-string">'./ancestor::div[contains(@class,"_5jmm")and contains(@class,"_5pat")and contains(@class,"_5uch")]'</span></span>}};doc=<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>;hst=doc.location.hostname;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(xpaths[hst]){<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!doc.querySelector(<span class="hljs-string"><span class="hljs-string">'style#usernameReadPost'</span></span>)){stl=doc.querySelector(<span class="hljs-string"><span class="hljs-string">'head'</span></span>).appendChild(doc.createElement(<span class="hljs-string"><span class="hljs-string">'style'</span></span>));stl.id=<span class="hljs-string"><span class="hljs-string">'usernameReadPost'</span></span>;stl.innerHTML=<span class="hljs-string"><span class="hljs-string">'.usernameReadPost,.usernameReadPost~*{background-color:silver !important;}'</span></span>;}sel=doc.getSelection();<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sel.isCollapsed){lnks=doc.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'a[href$="'</span></span>+localStorage.getItem(<span class="hljs-string"><span class="hljs-string">'usernameReadPost'</span></span>)+<span class="hljs-string"><span class="hljs-string">'"]'</span></span>);<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>,a_lnk;a_lnk=lnks[i];i++){the_lnk=doc.evaluate(xpaths[hst].lnk,a_lnk,<span class="hljs-literal"><span class="hljs-literal">null</span></span>,XPathResult.FIRST_ORDERED_NODE_TYPE,<span class="hljs-literal"><span class="hljs-literal">null</span></span>).singleNodeValue;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(the_lnk){post=doc.evaluate(xpaths[hst].post,the_lnk,<span class="hljs-literal"><span class="hljs-literal">null</span></span>,XPathResult.FIRST_ORDERED_NODE_TYPE,<span class="hljs-literal"><span class="hljs-literal">null</span></span>).singleNodeValue;<span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;}}<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(post){post.className+=<span class="hljs-string"><span class="hljs-string">' usernameReadPost'</span></span>;}<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{alert(<span class="hljs-string"><span class="hljs-string">'Read post not found.'</span></span>);}}<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{the_lnk=doc.evaluate(xpaths[hst].lnk,sel.focusNode,<span class="hljs-literal"><span class="hljs-literal">null</span></span>,XPathResult.FIRST_ORDERED_NODE_TYPE,<span class="hljs-literal"><span class="hljs-literal">null</span></span>).singleNodeValue;<span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(the_lnk){post=doc.evaluate(xpaths[hst].post,the_lnk,<span class="hljs-literal"><span class="hljs-literal">null</span></span>,XPathResult.FIRST_ORDERED_NODE_TYPE,<span class="hljs-literal"><span class="hljs-literal">null</span></span>).singleNodeValue;post.className+=<span class="hljs-string"><span class="hljs-string">' usernameReadPost'</span></span>;localStorage.setItem(<span class="hljs-string"><span class="hljs-string">'usernameReadPost'</span></span>,the_lnk.getAttribute(<span class="hljs-string"><span class="hljs-string">'href'</span></span>));}<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{alert(<span class="hljs-string"><span class="hljs-string">'Wrong link.'</span></span>);}}}<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{alert(<span class="hljs-string"><span class="hljs-string">'Wrong hostname.'</span></span>);}})()</code> </pre><br><br>  You can also drag a ready link <a href="http://vsemozhetbyt.ru/varia/bookmarklets.html">from here</a> (it‚Äôs there the same name for this post). <br><br>  <i>A brief explanation of the code</i> <br><br>  In order to be able to use one bookmarklet to all relevant sites, we first create an XPath path database for two necessary elements: links to the post and the top post container.  The particular complexity and strangeness of the paths is due to at least two reasons: when a link is selected, the focus element is often the link itself, then the subordinate element, then the final text node;  links and containers are not always have a unique combination of tag name and class, you have to connect the parameters of containing or subordinate elements. <br><br>  First of all, the script checks the page for belonging to the desired site.  If there is a coincidence, the desired style is created (if it has not already been created by running the script on the same page): for now, everything is simple, we just mark the read with gray. <br><br>  Next, the script checks if there is a user-selected site on the page.  If not, then this is the first reading of the page after the break, so you need to start with restoring the old border: the script goes through all the links that match the specified XPath and matches them with the saved address from localStorage.  If the desired link is found, it becomes the starting point for searching the entire container's XPath for the entire post.  If both the link and the post are found, the class is added and the style is applied.  Otherwise, the user is notified of the need to scroll the page or load other pages into the tape. <br><br>  If there is a segment selection on the page, the script checks the element in the middle of which the selection ends.  If it is the desired link, the operations with search and tagging of posts are repeated, and then the link address is placed in localStorage.  If this is not the link (or the user missed the end of the selection), a message is displayed. <br><br>  Those who wish can further reduce the names of variables, replace the blank name of the key class of read posts and the identifier of an additional style according to their nicknames for greater uniqueness, refuse to use a mobile tape in LiveJournal and adjust the parameters to their tape structure, not to mention more significant improvements ( you can, for example, attach a link selection event handler to the page so that you do not have to click on the bookmarklet every time during uninterrupted reading to automatically update  tapes). <br><br><hr><br>  If someone finds a way to at least a little worthy of improvement, ideas and code can be shared in the comments.  I would be grateful for additions, fixes and information about support in browsers (he tested only on the latest nightly builds of Firefox). </div><p>Source: <a href="https://habr.com/ru/post/213283/">https://habr.com/ru/post/213283/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213271/index.html">Intuition as a developer tool</a></li>
<li><a href="../213273/index.html">Thanks to 3D printing, a paralyzed woman can walk again</a></li>
<li><a href="../213275/index.html">"Heart Eater" - ASUS RT-AC68U Router: 802.11ac, usb 3.0, BitTorent, TimeMachine</a></li>
<li><a href="../213279/index.html">Airplane: 10 categories of people - those who can and who do not</a></li>
<li><a href="../213281/index.html">PRFLR, or how your code works in production</a></li>
<li><a href="../213287/index.html">Total Commander 8.50 Final</a></li>
<li><a href="../213291/index.html">Generate and scan QR / BAR codes</a></li>
<li><a href="../213293/index.html">ADCSpb # 11. Meeting iOS developers in St. Petersburg</a></li>
<li><a href="../213295/index.html">Custom events in action</a></li>
<li><a href="../213297/index.html">Kegbot: Beer Bottling System for Arduino and Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>