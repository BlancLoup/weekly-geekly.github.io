<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of rounding implementations in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! My name is Oleg, I'm a PHP-and-not-only-developer on Badoo. It often surprises me how differently in programming languages ‚Äã‚Äãthey approach t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of rounding implementations in Go</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/8l/kz/9s/8lkz9sx_tahobe8culzkhmditri.jpeg"></p><br><p>  Hi, Habr!  My name is Oleg, I'm a PHP-and-not-only-developer on Badoo.  It often surprises me how differently in programming languages ‚Äã‚Äãthey approach to compiling a standard library.  Go is no exception: the absence of the math.Round () function surprised me.  However, having rummaged in these your Internet, I found out the reason.  I would like to share this knowledge in my free translation. </p><a name="habracut"></a><br><p>  Rounding in Go is not easy to do correctly.  It would seem that we take float64, discard the fractional part and add one to the resulting value if the fractional part was&gt; = 0.5.  There are other options available when searching for ‚Äúgolang round‚Äù on Google, many of which can also be found on a <a href="https://github.com/golang/go/issues/4594">private ticket on GitHub</a> , where Round () refused to be included in the standard math package.  In this article I would like to study these and other implementations and check them for correctness.  We will see that almost all have errors that prevent their use. </p><br><h2 id="vybor-sposoba-okrugleniya">  Choosing a rounding method </h2><br><p>  There are several ways of rounding, depending on how the result is applied: rounding to a smaller / larger, rounding to a smaller / larger module, rounding to the nearest whole, rounding to the nearest even, etc. ... Rounding to the nearest whole, in turn, can be done differently depending on what the result should be if the fractional part is 0.5.  I will consider rounding to the nearest integer, and 0.5 will be rounded to a larger (modulo) direction. </p><br><p>  Requirements for the correct implementation of Round () are as follows: </p><br><ul><li>  correctly rounds all finite numbers to the nearest integer; </li><li>  supports special values ‚Äã‚Äã(NaN, Inf, -0), returning them unchanged. </li></ul><br><p>  I will use the following test cases to check the correctness, each pair contains the initial value and the expected result of the Round () function: </p><br><pre><code class="hljs ruby">tests <span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= [][<span class="hljs-number"><span class="hljs-number">2</span></span>]float64{ {-<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">49999999999999994</span></span>, negZero}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>+epsilon {-<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>}, {-<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5000000000000001</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>-epsilon {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">49999999999999994</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>-epsilon {<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, {<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5000000000000001</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>+epsilon {<span class="hljs-number"><span class="hljs-number">1.390671161567</span></span>e-<span class="hljs-number"><span class="hljs-number">309</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> denormal {<span class="hljs-number"><span class="hljs-number">2.2517998136852485</span></span>e+<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">2.251799813685249</span></span>e+<span class="hljs-number"><span class="hljs-number">15</span></span>}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> bit fraction {<span class="hljs-number"><span class="hljs-number">4.503599627370497</span></span>e+<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">4.503599627370497</span></span>e+<span class="hljs-number"><span class="hljs-number">15</span></span>}, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> large integer {math.Inf(-<span class="hljs-number"><span class="hljs-number">1</span></span>), math.Inf(-<span class="hljs-number"><span class="hljs-number">1</span></span>)}, {math.Inf(<span class="hljs-number"><span class="hljs-number">1</span></span>), math.Inf(<span class="hljs-number"><span class="hljs-number">1</span></span>)}, {math.NaN(), math.NaN()}, {negZero, negZero}, }</code> </pre> <br><p>  This list has the usual numbers, special values ‚Äã‚Äãand some boundary cases that simple algorithms are difficult to handle.  Please note that since we use float, we cannot use the number 0.49999999999999999 as the closest to 0.5, since due to the limited accuracy of the float, this number is exactly 0.5.  Instead, I use .49999999999999994. </p><br><p>  The implementations proposed in the closed ticket were obviously not checked for such data, often even those that were proposed by famous people did not work.  This once again proves how difficult it is to write Round (). </p><br><h3 id="intf--05">  int (f + 0.5) </h3><br><p>  The first implementation proposed by <a href="https://github.com/rsc">rsc</a> was as follows: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(f + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)</code> </pre> <br><p>  It does not work correctly with special values, negative numbers, numbers greater than math.MaxInt64 and numbers close to 0.5: </p><br><pre> <code class="hljs pgsql">round(<span class="hljs-number"><span class="hljs-number">-0.5</span></span>): got: <span class="hljs-number"><span class="hljs-number">0</span></span>, want <span class="hljs-number"><span class="hljs-number">-1</span></span> round(<span class="hljs-number"><span class="hljs-number">-0.5000000000000001</span></span>): got: <span class="hljs-number"><span class="hljs-number">0</span></span>, want <span class="hljs-number"><span class="hljs-number">-1</span></span> round(<span class="hljs-number"><span class="hljs-number">0.49999999999999994</span></span>): got: <span class="hljs-number"><span class="hljs-number">1</span></span>, want <span class="hljs-number"><span class="hljs-number">0</span></span> round(<span class="hljs-number"><span class="hljs-number">4.503599627370497e+15</span></span>): got: <span class="hljs-number"><span class="hljs-number">4.503599627370498e+15</span></span>, want <span class="hljs-number"><span class="hljs-number">4.503599627370497e+15</span></span> round(-Inf): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want -Inf round(+Inf): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want +Inf round(<span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span>): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want <span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span></code> </pre> <br><h3 id="floor-or-ceil">  Floor () or Ceil () </h3><br><p>  The second proposed option took into account negative numbers: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> f &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> math.Ceil(f - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> math.Floor(f + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)</code> </pre> <br><p>  however, he continued to work incorrectly in some cases: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">round</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">-0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.49999999999999994</span></span>): <span class="hljs-selector-tag"><span class="hljs-selector-tag">got</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">-1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">want</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">round</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.49999999999999994</span></span>): <span class="hljs-selector-tag"><span class="hljs-selector-tag">got</span></span>: 1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">want</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">round</span></span>(4<span class="hljs-selector-class"><span class="hljs-selector-class">.503599627370497e</span></span>+15): <span class="hljs-selector-tag"><span class="hljs-selector-tag">got</span></span>: 4<span class="hljs-selector-class"><span class="hljs-selector-class">.503599627370498e</span></span>+15, <span class="hljs-selector-tag"><span class="hljs-selector-tag">want</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.503599627370497e</span></span>+15</code> </pre> <br><p>  The first two tests do not pass, because the result of the difference n - 0.5 is exactly -1.0, while we expect to get something exactly greater than -1.0.  If you look at the <a href="">implementation of round in Postgres</a> , you can figure out how to solve this problem. </p><br><p>  The most interesting thing is that this error is not so rare.  Prior to version 6, exactly the same was <a href="https://stackoverflow.com/questions/9902968/why-does-math-round0-49999999999999994-return-1">present in Java</a> .  It is good that implementation has since improved. </p><br><h3 id="int-i-copysign">  int and copysign </h3><br><p>  In the third sentence, <a href="https://github.com/minux">minux</a> made another attempt to solve the problem of negative numbers: </p><br><pre> <code class="hljs lisp">return int(<span class="hljs-name"><span class="hljs-name">f</span></span> + math.Copysign(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, f))</code> </pre> <br><p>  And this option still breaks the tests: </p><br><pre> <code class="hljs pgsql">round(<span class="hljs-number"><span class="hljs-number">-0.49999999999999994</span></span>): got: <span class="hljs-number"><span class="hljs-number">-1</span></span>, want <span class="hljs-number"><span class="hljs-number">-0</span></span> round(<span class="hljs-number"><span class="hljs-number">0.49999999999999994</span></span>): got: <span class="hljs-number"><span class="hljs-number">1</span></span>, want <span class="hljs-number"><span class="hljs-number">0</span></span> round(<span class="hljs-number"><span class="hljs-number">4.503599627370497e+15</span></span>): got: <span class="hljs-number"><span class="hljs-number">4.503599627370498e+15</span></span>, want <span class="hljs-number"><span class="hljs-number">4.503599627370497e+15</span></span> round(-Inf): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want -Inf round(+Inf): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want +Inf round(<span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span>): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want <span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span></code> </pre> <br><p>  As you can see, some of the tests began to pass, but others began to fall.  An attempt was made to improve this algorithm: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> math.Abs(f) &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>(f + math.Copysign(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, f))</code> </pre> <br><p>  However, she failed: </p><br><pre> <code class="hljs pgsql">round(<span class="hljs-number"><span class="hljs-number">4.503599627370497e+15</span></span>): got: <span class="hljs-number"><span class="hljs-number">4.503599627370498e+15</span></span>, want <span class="hljs-number"><span class="hljs-number">4.503599627370497e+15</span></span> round(-Inf): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want -Inf round(+Inf): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want +Inf round(<span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span>): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want <span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span></code> </pre> <br><p>  This option looks better than the others, but it also incorrectly handles special values ‚Äã‚Äãand large numbers.  The first problem can be solved with the help of additional conditions, but the second is not so easy to handle. </p><br><p>  We have already considered four options, and in each of them there were flaws.  It's time to see how the authors of various packages implement Round (). </p><br><h3 id="kubernetes">  Kubernetes </h3><br><p>  Kubernetes 1.7 contains the <a href="">following</a> implementation: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> int32(a - <span class="hljs-number"><span class="hljs-number">0.5</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> int32(a + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)</code> </pre> <br><p>  It breaks down the following tests: </p><br><pre> <code class="hljs pgsql">round(<span class="hljs-number"><span class="hljs-number">-0.49999999999999994</span></span>): got: <span class="hljs-number"><span class="hljs-number">-1</span></span>, want <span class="hljs-number"><span class="hljs-number">-0</span></span> round(<span class="hljs-number"><span class="hljs-number">0.49999999999999994</span></span>): got: <span class="hljs-number"><span class="hljs-number">1</span></span>, want <span class="hljs-number"><span class="hljs-number">0</span></span> round(<span class="hljs-number"><span class="hljs-number">4.503599627370497e+15</span></span>): got: <span class="hljs-number"><span class="hljs-number">4.503599627370498e+15</span></span>, want <span class="hljs-number"><span class="hljs-number">4.503599627370497e+15</span></span> round(-Inf): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want -Inf round(+Inf): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want +Inf round(<span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span>): got: <span class="hljs-number"><span class="hljs-number">-9.223372036854776e+18</span></span>, want <span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span></code> </pre> <br><p>  Judging from the fact that the function returns int32, it is not designed to work with large numbers.  However, it does not work correctly with numbers that are close to 0.5. </p><br><h2 id="rabotayuschie-realizacii-na-go">  Running implementations on Go </h2><br><h3 id="round-ispolzuemaya-v-postgres">  Round () used in Postgres </h3><br><p>  Earlier, I mentioned that Postgres contains the code for the Round () function on C, which works for all tested values.  In CockroachDB we <a href="">rewrote this code on Go</a> , without comments it looks like this: </p><br><pre> <code class="hljs lua">func round(x float64) float64 { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.IsNaN(x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x } roundFn := <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Ceil <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Signbit(x) { roundFn = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Floor } xOrig := x x -= <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Copysign(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, x) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Signbit(x) != <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Signbit(xOrig) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Copysign(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, xOrig) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == xOrig-<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Copysign(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xOrig } r := roundFn(x) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r != x { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> roundFn(x*<span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> }</code> </pre> <br><p>  Let's see how it works.  The first six lines handle special cases.  Next, we select roundFn from Ceil and Floor, depending on whether the number is positive or negative.  Then the fun begins: </p><br><pre> <code class="hljs lua">x -= <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Copysign(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, x)</code> </pre> <br><p>  With this code, we move x closer to zero. </p><br><pre> <code class="hljs lua"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Signbit(x) != <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Signbit(xOrig) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Copysign(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, xOrig) }</code> </pre> <br><p>  Next, we check whether x has become exactly zero and whether its sign has changed.  This means that the original number &lt;= 0.5, in this case we return a zero with the desired sign. </p><br><pre> <code class="hljs lua"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == xOrig-<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Copysign(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, x) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xOrig }</code> </pre> <br><p>  This check is needed for very large numbers, for which x-0.5 == x-1.0, in these cases we can return the number unchanged. </p><br><pre> <code class="hljs kotlin">r := roundFn(x) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r != x { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r }</code> </pre> <br><p>  Next, we round the number using Floor () or Ceil () and return this value if it differs from x, which can happen only if the fractional part of the input value is not exactly 0.5, since we deducted above 0.5 out of him. </p><br><pre> <code class="hljs lisp">return roundFn(<span class="hljs-name"><span class="hljs-name">x*0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre> <br><p>  Now we know that the fractional part is 0.5, so we need to round to the nearest even number (the implementation of Round () in Postgres in this place differs from the above options).  The comment in the code describes it better: </p><br><blockquote>  Dividing input + 0.5 by 2, taking the floor and multiplying by 2 yields the closest even number.  This is not the case, that should be OK because underflow is impossible here: x is an integer. </blockquote><p>  To preserve the original behavior, this code can be replaced with the following: </p><br><pre> <code class="hljs lua"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xOrig + <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.Copysign(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, xOrig)</code> </pre> <br><h3 id="githubcommontanaflynnstats">  github.com/montanaflynn/stats </h3><br><p>  Another working implementation is contained in the github.com/montanaflynn/stats package.  Without comments, it looks like this: </p><br><pre> <code class="hljs pgsql">func round(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> float64) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> math.IsNaN(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> math.<span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span>() } sign := <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> { sign = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> *= <span class="hljs-number"><span class="hljs-number">-1</span></span> } _, <span class="hljs-type"><span class="hljs-type">decimal</span></span> := math.Modf(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) var rounded float64 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-type"><span class="hljs-type">decimal</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span> { rounded = math.Ceil(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rounded = math.Floor(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rounded * sign }</code> </pre> <br><p>  The key difference from the previous solutions is the use of the Modf () function, which correctly separates the integer and fractional parts of numbers. </p><br><h2 id="round-v-go-110">  Round () in Go 1.10 </h2><br><p>  A few months after the release of Go 1.8, <a href="https://github.com/golang/go/issues/20100">another ticket</a> appeared with a request to add math.Round to Go.  In the comments to it, incorrectly working implementations continued to appear, their number increased to eight.  Fortunately, the Go team agreed to add math.Round to Go 1.10!  And even a <a href="https://go-review.googlesource.com/c/go/%2B/43652">working implementation</a> appeared: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Round</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( mask = <span class="hljs-number"><span class="hljs-number">0x7FF</span></span> shift = <span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">11</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> bias = <span class="hljs-number"><span class="hljs-number">1023</span></span> signMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">63</span></span> fracMask = (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; shift) - <span class="hljs-number"><span class="hljs-number">1</span></span> halfMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (shift - <span class="hljs-number"><span class="hljs-number">1</span></span>) one = bias &lt;&lt; shift ) bits := math.Float64bits(x) e := <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>(bits&gt;&gt;shift) &amp; mask <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e &lt; bias: <span class="hljs-comment"><span class="hljs-comment">// Round abs(x)&lt;1 including denormals. bits &amp;= signMask // +-0 if e == bias-1 { bits |= one // +-1 } case e &lt; bias+shift: // Round any abs(x)&gt;=1 containing a fractional component [0,1). e -= bias bits += halfMask &gt;&gt; e bits &amp;^= fracMask &gt;&gt; e } return math.Float64frombits(bits) }</span></span></code> </pre> <br><p>  For those who are not familiar with the float device (I am among them), this code looks completely incomprehensible.  Let's try to figure out what he does: </p><br><pre> <code class="hljs go">bits := math.Float64bits(x) e := <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>(bits&gt;&gt;shift) &amp; mask</code> </pre> <br><p>  It seems that we take a bit representation of a number, shift it and apply a mask.  According <a href="https://en.wikipedia.org/wiki/IEEE_754">to IEEE 754 specification</a> : </p><br><blockquote>  This is what IEEE 754-1985 has been used for. </blockquote><p>  Considering the above constants, we see that the shift amounts to 64‚Äì11‚Äì1, which means 64 bits per number, 11 of which are used for the exponent, one for the sign and the 52 remaining bits for the mantissa.  This means that the shift used removes the bits of the mantissa, and the mask removes the bits of the sign, leaving us only with the exponent. </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e &lt; bias:</code> </pre> <br><p>  In the resulting number, the exponent is not recorded as it is, but with the addition of 1023 (this is done in order to record negative indicators for very small numbers), which means that we have to subtract 1023 from e calculated above to get the actual indicator.  In other words, if e &lt;bias, then we have a negative exponent, which means that the absolute value of the float must be &lt;1. Indeed, we see further: </p><br><pre> <code class="hljs xml">// Round abs(x)<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">including</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">denormals.</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bits</span></span></span><span class="hljs-tag"> &amp;= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">signMask</span></span></span><span class="hljs-tag"> // +</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-0</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">e</span></span></span><span class="hljs-tag"> == </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">bias-1</span></span></span><span class="hljs-tag"> { </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bits</span></span></span><span class="hljs-tag"> |= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">one</span></span></span><span class="hljs-tag"> // +</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">-1</span></span></span><span class="hljs-tag"> }</span></span></code> </pre> <br><p>  Here the bit is masked by the sign bit, it is used only to save the correct sign: now we can completely ignore the mantissa.  We can do this, because in this case we are only interested in the exponent.  Since the base of degree 2 is used, and e &lt;bias, we know that the smallest index, which can be, is -1, and 2 ^ -1 = 0.5.  In addition, the mantissa has a value of 1.X.  Thus, depending on the indicator, our number is either in the range (0.5, 1) or in the range (0, 0.5).  Therefore, in the second case, for correct rounding, we need to add one to the number.  Fuh.  This is described <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">in</a> more detail <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">in Wikipedia</a> . </p><br><p>  Now let's look at the second case: </p><br><pre> <code class="hljs bash"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> e &lt; bias+<span class="hljs-built_in"><span class="hljs-built_in">shift</span></span>:</code> </pre> <br><p>  Probably, you think that the condition in this thread should be e&gt; bias to cover all cases with a positive exponent.  But instead, only their part is used here.  The use of the shift is especially interesting here, because it seems to be incomparable with bias.  The first is the number of offset bits, and the second is the numerical offset.  But, since floating-point numbers are represented as (1.mantissa) * 2 ^ X, then if X is more than the number of bits in the mantissa, we are guaranteed to get the value without the fractional part.  That is, the exponent shifted the decimal point to the right so much that the mantissa finally disappeared.  Thus, the expression in this thread ignores floating-point numbers that are already rounded. </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// Round any abs(x)&gt;=1 containing a fractional component [0,1). e -= bias bits += halfMask &gt;&gt; e bits &amp;^= fracMask &gt;&gt; e</span></span></code> </pre> <br><p>  The first line here is simple: subtract bias from e and get the real value of the exponent.  The second line adds 0.5 to the value.  This works because the high bit of the mantissa adds 0.5 to the final amount (see the presentation in the Wikipedia article below).  In this case, this amount overflows the 52-bit boundaries of the mantissa, the exponent will be increased by 1. The exponent value cannot overflow to the sign bit, since it cannot be greater than the bias + shift from the example above.  In any case, the fractional part is cleared.  Thus, if the fractional part was greater than or equal to 0.5, it will be increased by 1, otherwise it will be discarded.  Sly and not obvious until we take a deeper look. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In this article, I talked mainly about rounding to a smaller module, but there are <a href="https://en.wikipedia.org/wiki/Rounding">many other options</a> .  In some cases, it is they who are suitable, and I will leave the reader the opportunity to study them and try to implement them on Go.  But I hope that now it has become clear to you how rounding is arranged in Go and how you need to test the implementation of rounding. </p><br><p>  I think the Go team made the right decision by adding the Round () function to the standard library.  Without this, we would continue to use various incorrect implementations. </p><br><p>  I hope that now it has become clear to you that when working with float there are many pitfalls, which even the experts sometimes forget.  It is easy to invent or copy a one-line implementation from somewhere, but it is difficult to write a truly correct one.  Not surprisingly, correctly working rounding appeared only in the sixth major version of Java (15 years after the release of Java 1.0 before the release of Java 7), and I am glad that Go went this way faster. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/345784/">https://habr.com/ru/post/345784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345772/index.html">Epic files in online chat rooms, or why sales do not grow</a></li>
<li><a href="../345774/index.html">Code Coverage - I want to believe</a></li>
<li><a href="../345776/index.html">Keyboard Response Comparison</a></li>
<li><a href="../345778/index.html">Pygest # 21. Releases, articles, interesting projects, packages and libraries from the world of Python [January 1, 2018 - January 17, 2018]</a></li>
<li><a href="../345780/index.html">Kubernetes success stories in production. Part 6: BlaBlaCar</a></li>
<li><a href="../345786/index.html">Blog RuVDS. Digest of posts and our results of the year</a></li>
<li><a href="../345788/index.html">Three-storey C ++ templates in the implementation of an embedded asynchronous HTTP server with a human face</a></li>
<li><a href="../345790/index.html">In memory of 2017: the best posts in our blog for the year</a></li>
<li><a href="../345792/index.html">Frontend 2017: the most important</a></li>
<li><a href="../345794/index.html">The whole truth about the new office "Informzaschity", and How we survived the move</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>