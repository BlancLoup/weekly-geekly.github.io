<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tactoom.com inside - social blogging platform on NodeJS / NoSQL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So, it's time to reveal some of the maps and talk about how the Tactoom works from the inside. 

 In this article I will talk about the development an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tactoom.com inside - social blogging platform on NodeJS / NoSQL</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://tactoom.com/"><img src="https://habrastorage.org/getpro/habr/post_images/401/234/6b2/4012346b272f2f76a7d9291a3e2af283.jpg" alt="Tactoom.com - under the hood" title="Tactoom.com - under the hood" align="left"></a>  So, it's time to reveal some of the maps and talk about how the Tactoom works from the inside. <br><br>  In this article I will talk about the development and production of a web service in production using: <br>  NodeJS (fibers), MongoDB, Redis, ElasticSearch, Capistrano, Rackspace. <br><a name="habracut"></a><br><br><h4>  Introduction </h4><br>  Three weeks ago, David and I ( <a href="http://habrahabr.ru/users/dmiloshev/" class="user_link">DMiloshev</a> ) <a href="http://habrahabr.ru/blogs/startup/129514/">launched the</a> info-social network Tactoom.com.  About what it is you can read <a href="http://tactoom.com/about">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Against the background of the noise <a href="http://habrahabr.ru/blogs/nodejs/129766/">recently</a> <a href="http://habrahabr.ru/blogs/nodejs/129640/">raised</a> around NodeJS, it is probably interesting to many what this technology is not in words, but in deeds. <br><br>  NodeJS is not a panacea at all.  It's just another technology, in fact, no better than others.  In order to achieve good performance and scalability, you have to sweat well - just like everywhere else. <br><br><h4>  Application architecture </h4><br>  NodeJS application is divided into two types of processes: <br>  1. Web process (http) <br>  2. Cloud process (queues) <br><br>  All processes are completely independent of each other, can be located on different servers and even in different parts of the globe.  At the same time, the application is scaled just by multiplying these processes.  Communication between them takes place exclusively through a centralized message server (redis). <br><br>  <b>Web processes</b> serve direct http user requests.  Each process can process multiple requests simultaneously.  Considering the specificity of Eventloop, depending on the ratio of CPU / IO of each specific request, the limit of parallel processing can either be reduced or increased for a separate process at a time. <br><br>  <b>Cloud processes</b> perform operations that are not directly related to user requests.  For example: sending emails, data denormalization, search indexing.  Like the Web, a single Cloud process can handle many different types of tasks at the same time. <br>  It should be noted that the "atomicity" of tasks / requests is very important here.  That is, you need to ensure that the capacious task / calculation is divided into many smaller parts, which will then be evenly distributed across the rest of the processes.  This will increase the speed of the task, fault tolerance and reduce memory consumption and the blocking factor of each process and the entire server. <br><br>  <b>Web ‚Üí Cloud</b> <br>  I try to organize Web processes in such a way as to increase the overall IO versus CPU time ratio, and therefore focus them on quickly issuing http with high concurrency of requests.  This means that the <b>Web delegates high-cpu logic to the Cloud</b> , waits for its execution, then receives the result of the calculations.  Accordingly, due to the asynchronous architecture of the nodejs, while waiting for the Web can perform other requests. <br><br>  <b>Clustering</b> <br>  The Web and Cloud architecture is very similar, except that instead of http, the Cloud socket is ‚Äúlistening‚Äù to the redis queue. <br><br>  Clustering node processes occurs according to the following principles: <br>  1. On each physical server, one supervisor process is running ( <a href="http://learnboost.github.com/cluster/">node-cluster</a> ) <br>  2. The child processes of the supervisor are our Web s and Cloud s, the number of which is always equal to the number of server cores. <br>  3. The supervisor controls the memory consumption of each child process and, in case of exceeding the specified rate, restarts it (after waiting for the completion of the current requests of this process). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/def/bcb/10b/defbcb10b7d524ce3b07516f18778b08.png" alt="Tactoom nodejs cluster" title="Tactoom nodejs cluster"><br><br><h4>  Fibers </h4><br>  The entire high-level application layer is written using <a href="https://github.com/0ctave/node-sync">node-sync (fibers)</a> , without which I can hardly imagine its development at all.  The fact is that such complicated things as the same static construction are very difficult to implement on the ‚Äúofficial‚Äù callback-driven paradigm, if not stupid.  Those who have not yet seen the code of the same <a href="http://npmjs.org/">npm</a> , I strongly recommend <a href="">to look at it</a> , and try to understand what is happening there, and most importantly - why.  And the holivars and trolling that grow around the nodejs asynchronous paradigm almost every day, to put it mildly, make me puzzled. <br><br>  Learn more about node-sync in my article: <br>  <a href="http://habrahabr.ru/blogs/nodejs/116124/">node-sync - pseudo-synchronous programming on nodejs using fibers</a> <br><br><h4>  Web </h4><br>  The general logic of the Web application is implemented on the <a href="http://expressjs.com/">expressjs</a> style express.  Except that each request is wrapped in a separate Fiber, within which all operations are performed in a synchronous style. <br><br>  Because it was impossible to override some parts of the expressjs functionality, in particular, routing, it had to be removed from npm and included in the main project repository.  The same applies to a number of other modules (especially those developed by <a href="https://github.com/LearnBoost/">LearnBoost</a> ), because contributing to their projects is very hard and <a href="https://github.com/LearnBoost/stylus/pull/227">not always possible</a> . <br><br>  CSS is generated via <a href="http://thechangelog.com/post/3036532096/stylus-expressive-robust-feature-rich-css-language">stylus</a> .  It is really very convenient. <br>  Template engine - <a href="https://github.com/visionmedia/ejs">ejs</a> (both on the server and on the client). <br>  Download files - <a href="https://github.com/visionmedia/connect-form">connect-form</a> . <br><br>  The web is very fast because all modules and initialization are loaded into the process memory at startup.  I try to keep the average response time of the Web process to any page - up to 300ms (excluding uploading images, registration, etc.).  Conducting profiling, I was surprised to find that 70% of this time is taken by the work of <a href="http://mongoosejs.com/">mongoose</a> (mongodb ORM for nodejs) - more on this below. <br><br>  <b>i18n</b> <br>  I‚Äôve been looking for a suitable solution for internationalization in nodejs for a long time, and my searches converged on <a href="https://github.com/andris9/node-gettext/">node-gettext</a> with a little doping.  It works like a clock, the locale files are tightened "on the fly" by server nodejs processes during the update. <br><br>  <b>Cache</b> <br>  The caching functionality with all its logic fit into two screens of code.  Redis is used as a cache backend. <br><br>  <b>Memory</b> <br>  In Web processes, memory flows like water, as it later turned out, because of mongoose.  One process (during the day, during the average load) eats up to 800MB in two hours, after which it is restarted by the supervisor. <br>  It is quite difficult to look for memory leaks in nodejs, if you know interesting ways - let me know. <br><br><h4>  Data </h4><br>  As shown, the <a href="http://www.mongodb.org/">mongodb</a> schema-less paradigm <a href="http://www.mongodb.org/">is</a> ideal for the Tactoom model.  The database itself behaves well (weighs 376MB, of which 122MB is an index), the data is selected exclusively by indices, so the result of any query is no more than 30ms, even under high load (most requests are &lt;1ms in general). <br><br>  If it is interesting, in the second part I can tell you in more detail how mongodb was ‚Äútamed‚Äù for a number of non-trivial tasks (and how <i>it</i> was <i>not</i> possible). <br><br>  <b>mongoosejs</b> (mongodb ORM for nodejs) <br>  About him I want to say separately.  Selecting a list of 20 users: requesting and selecting data in mongo takes 2ms, data transfer is 10ms, then mongoose does something else <i>200ms</i> (I <i>am</i> already silent about memory) and as a result I get objects.  If you rewrite it to a lower-level <a href="https://github.com/christkv/node-mongodb-native">node-mongodb-native</a> , then all this will take 30ms. <br>  Gradually, I had to rewrite almost everything on mongodb-native, while increasing the system speed as a whole every 10. <br><br><h4>  Statics </h4><br>  All Tactoom statics are stored on <a href="http://www.rackspace.com/cloud/cloud_hosting_products/files/">Rackspace Cloud Storage</a> .  In this case, I use the static domain <b>cdn <i>X</i> .infosocial.net</b> , where <i>X</i> is 1..n.  This domain sends through DNS to the internal domain of the container in Cloud Storage, allowing browsers to load static files in parallel.  Each static file is stored in two copies (plain and gzip) and has a unique name in which the version is sewn.  If the file version is updated, the address will change, and browsers will download the new file. <br><br>  <b>The</b> application statics are compiled (client js and css, pictures) via a samopisny mechanism that determines modified files (via git-log), minify, makes a gzip copy and uploads them to the CDN.  The build script also monitors the modified images and updates their addresses in the corresponding css files. <br>  The list (mapping) of the static addresses of all files is stored in Redis.  This list loads into memory each Web process at startup or when updating static versions. <br>  In fact, the de-deployment of any static changes is done by one team, which does everything itself.  And it does not require any reloading, since the nodejs applications pick up the modified static file addresses on the fly through redis pub / sub. <br><br>  <b>User statics are</b> also stored on Rackspace, but unlike application statics, it has no versions, but simply undergoes a certain canonization, which allows using the hash of the picture to get addresses of all its sizes on a CDN. <br><br>  For definitions of a host (cdn <i>X</i> ) on which the specific static file is stored, consistent hashing is used. <br><br><h4>  Server architecture </h4><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0a9/e54/645/0a9e54645ad99ff429bf9d06f3e35c34.png"></a> <br>  In fact, Tactoom is scattered on 3 tight areas: <br>  <b>1. Rackspace</b> - a platform for fast scaling and storing static <br>  <b>2. Platform in Europe</b> - here our physical servers <br>  <b>3. The secret</b> (here logs are rotated, background calculations are made and statistics are collected) <br><br>  Only one server is watching the world - nginx, with open ports 80 and 4000. The latter is used for COMET connections. <br>  The remaining servers communicate with each other via direct ip, closed from the world via iptables. <br><br>  <b>: 80</b> <br>  nginx proxies requests through upstream configuration to Web servers.  At the moment there are two upstream: <b>tac_main</b> and <b>tac_media</b> .  Each of them contains a list of Web servers running node-cluster on port 3000, each Web server has its own priority when distributing requests. <br>  <b>tac_main</b> is a cluster of Web servers that are close to the database and are responsible for issuing most of the web pages to registered Tactoom users. <br>  <b>tac_media</b> is a cluster of Web servers located close to the CDN.  Through them all operations on loading and resizing images take place. <br><br>  The <i>webN</i> and <i>cloudN servers are</i> depicted to show where I add servers for habraeffect and other nice events. <br>  New servers go up in 10 minutes - in the image stored on the CDN. <br><br>  <b>: 4000</b> <br>  Here is the usual proxy-pass to the <b>comet</b> server, where the Beseda application <a href="https://github.com/geometria-lab/Beseda">jets</a> COMET <a href="https://github.com/geometria-lab/Beseda">works</a> , which I will discuss in the second part. <br><br>  <b>tac1, tac2, data1</b> <br>  These are the main Tactoom servers: XEON X3440 4x2.53 GHz 16 GB 2x1500 GB Raid1. <br>  On each, the Mongod process works, they are all combined in <a href="http://www.mongodb.org/display/DOCS/Replica%2BSets">ReplicaSet</a> with automatic failover and distribution of read operations to the slaves. <br><br>  On tac1 - the main Web cluster, on tac2 - Cloud cluster.  Each cluster has 8 nodejs processes. <br><br>  In the near future, we will create another upstream <b>tac_search</b> for which only search queries will be routed.  It will be Web-cluster, which I put next to <b>elasticsearch</b> (about him in the second part) server. <br><br><h4>  findings </h4><br>  Quoting the slogan of the creators of NodeJS: <br>  <i>‚ÄúBecause nothing blocks, less-than-expert programmers are able to develop fast systems.‚Äù</i> <br>  <i>"Due to the fact that nothing is blocked, less-than-experts can develop fast systems."</i> <br><br><ol><li>  This is a lie.  I have been using nodejs for almost 2 years now and I know from my own experience that in order to develop ‚Äúfast systems‚Äù on it, you need not less experience (or even more) than on any other technology.  In reality, with the callback-driven paradigm in nodejs and javascript features in general, it‚Äôs rather easier to make a mistake (and then look for it for a very long time) than to win in performance. </li><li>  On the other hand, the <a href="http://teddziuba.com/2011/10/node-js-is-cancer.html">trolling of</a> Mr. Ted Dziuba is also complete nonsense, for the example with the Fibonacci numbers is sucked from the finger.  Only a person who does not understand how Eventloop works and why it is needed at all will do this (which, incidentally, is proved by point 1). </li></ol><br><br>  After <a href="http://devconf.ru/offers/27">reporting</a> to <a href="http://devconf.ru/">DevConf</a> this spring, I am often asked questions about whether to make a new project on NodeJS.  My answer to all: <br>  If you have a lot of time and you are ready to invest it in the development of a new, crude and controversial technology - go ahead.  But if you have deadlines / customers / investors in front of you and you don‚Äôt have much experience with server-side JS behind your back - it‚Äôs <b>not worth it</b> . <br><br>  As practice has shown, to raise the project on NodeJS is real.  It works.  But it cost me a lot.  That only costs node open-source community, which I still try to have time to write. <br><br><h4>  Part 2 </h4><br>  The second part of the article will be on the other day.  Here is a brief list of what I'll write about in it: <br>  1. Search (elasticsearch) <br>  2. Mail (google app engine) <br>  3. Deployment (capistrano, npm) <br>  4. Queues (redis, kue) <br>  5. COMET server (beseda) <br><br>  Too much information for one article. <br>  If I see interesting questions in the comments, I will answer them in the second part. <br><br><h4>  PS </h4><br><ol><li>  There will be no <a href="http://lurkmore.ru/%25D0%2595%25D0%25B4%25D0%25B0">food</a> .  Any comments containing criticism will be ignored without reference to your own achievements. </li><li>  We are looking for front-end ninja, details <a href="http://tactoom.com/octave/4e9462fe77abb80d79001746">here.</a> </li><li>  Let me remind you that Tactoom is in closed beta testing.  Registration is limited.  Leave the email, and you may soon come to invite. </li></ol><br><br>  UPD 19.10: <br>  The second part is delayed, because a lot of work. </div><p>Source: <a href="https://habr.com/ru/post/130345/">https://habr.com/ru/post/130345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../130339/index.html">Numberama. Reviving your favorite game on iOS</a></li>
<li><a href="../130341/index.html">Yandex can not find a song about Putin</a></li>
<li><a href="../130342/index.html">The results of the action with Groupon. Practical experience</a></li>
<li><a href="../130343/index.html">Acer Aspire 7560G: an impressive desktop with a new-generation AMD quad-core processor</a></li>
<li><a href="../130344/index.html">Signed domain zone SU!</a></li>
<li><a href="../130346/index.html">Microsoft supports Hadoop</a></li>
<li><a href="../130347/index.html">Application Expressions</a></li>
<li><a href="../130348/index.html">Google Maps on the WebGL engine</a></li>
<li><a href="../130351/index.html">Presentation of Apple iPhone 4S - Russian translation</a></li>
<li><a href="../130352/index.html">Creating YouTube Player for Nokia N9 in QML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>