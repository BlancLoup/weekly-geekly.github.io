<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithms for searching palindromes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today I want to tell you about the algorithms for counting the number of palindromes per line: what it is for, where it is used, how to do it quickly,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithms for searching palindromes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/702/028/fbe/702028fbe69563ea59ef496b913fdc40.png" alt="image"><br><br>  Today I want to tell you about the algorithms for counting the number of palindromes per line: what it is for, where it is used, how to do it quickly, what pitfalls await us and much more.  Consider the various ways to solve this problem, find out the pros and cons of each method.  This article will be an overview: if I do not describe something here, I will try to always give you a set of links, where everything is described and painted in detail.  I hope that the material will be of interest to both newcomers in the field of algorithms and experienced programmers.  Well, if I could interest you, then please under the cat! <br><a name="habracut"></a><br>  For a start, it is worth remembering what a palindrome is. <br><br>  A palindrome is a number (for example, 404), a letter combination, a word, or text that can be read in the same direction in both directions.  Sometimes a palindrome is called any symmetrical set of symbols with respect to its middle. (Excerpt from <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B4%25D1%2580%25D0%25BE%25D0%25BC">Wikipedia</a> ) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The definition is very easy and understandable.  We in this post will consider palindromes-words (pop, cook, etc.).  But this does not mean that the algorithms are not applicable for other situations.  Just slightly narrow the area. <br><br>  What might you need to look for palindromes? <br><br>  In fact, it is not very often that one has to look for palindromes in everyday life.  Painfully specific is the task.  If we talk about string algorithms, then we find the same search for a substring in a string more often than finding the number of palindromes.  Therefore, the coverage in the literature is much weaker. <br><br>  One of the main applications is sports / Olympiad programming.  There are enough tasks for this.  Tasks are written, and participants already think how to solve it.  From personal experience, I would say that I met such tasks only a couple of times, but they were all from the category ‚Äúhere‚Äôs your task, you don‚Äôt think, but just write an algorithm.‚Äù  That is, not interesting tasks that develop simply mechanical memory by stuffing algorithms. <br><br>  A more practical application of finding palindromes is biological algorithms.  According to the same Wikipedia and Wiki links below, the palindromic nature of biological compounds plays an important role on the properties of various biological compounds.  I am weak in biology, so if you are interested, you can find more detailed information yourself. <br><br>  Great, we found out that we will be engaged in not entirely useless things.  Let's move on to the algorithms! <br><br>  Note: in all the algorithms below, a single character is not counted as a palindrome.  As you understand, it is easy to fix, if single characters also need to be taken into account. <br><br><h4>  0) The most banal algorithm with asymptotics O (N ^ 3) </h4><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SlowN3::isPalindrom(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftBorder, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightBorder) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(leftBorder &lt;= rightBorder) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(str[leftBorder] != str[rightBorder]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ++leftBorder; --rightBorder; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> SlowN3::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ()() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftBorder = <span class="hljs-number"><span class="hljs-number">0</span></span>;leftBorder &lt; str.length(); ++leftBorder) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rightBorder = leftBorder + <span class="hljs-number"><span class="hljs-number">1</span></span>; rightBorder &lt; str.length(); ++rightBorder) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isPalindrom(leftBorder, rightBorder) ) { ++cntPalindromes; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cntPalindromes; }</code> </pre> <br>  I want to warn you right away that all the sources will be in C ++, and these will be significant parts of the classes that may be of interest to us. <br><br>  The algorithm is the most ‚Äúforehead‚Äù: there is a string, there is a pointer to the beginning of the substring of the given string, there is a pointer to the end of the given substring.  In two nested loops, we iterate over the boundaries of the substrings and tritely check whether our substring is a palindrome.  Nothing complicated. <br><br>  But this is all terribly slow.  Why?  Yes, because we are square N times (N we will always have the length of the string) iterate over the boundaries of the weaving substring, and then also for O (N) in the worst case we perform a check for each substring for palindrome. <br><br>  There are some advantages to this method: <br><br>  + Easy to implement.  Indeed, it is very difficult to leave a bug here. <br>  + Easy to read.  You just looked, and already understood that yes how it works here. <br>  + Small hidden constant.  As it is known, not only an asymptotic estimate (here we work only with the worst cases), but also a hidden constant, affects the running time of the algorithm.  This algorithm has a hidden constant that is extremely small. <br><br>  Minuses: <br><br>  - Extremely low speed.  As you can see, with a row of one thousand letters 'a', this algorithm will do about 10 ^ 9 iterations, which is very bad.  And what if the string is 100,000 long? <br><br><h4>  1) The most banal algorithm with asymptotics O (N ^ 2) </h4><br>  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SlowN2::oddCount() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indMiddle = <span class="hljs-number"><span class="hljs-number">0</span></span>; indMiddle &lt; str.length(); ++indMiddle) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftBorder = indMiddle - <span class="hljs-number"><span class="hljs-number">1</span></span>, rightBorder = indMiddle + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(leftBorder &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; rightBorder &lt; str.length() &amp;&amp; str[leftBorder] == str[rightBorder]) { ++cntPalindromes; --leftBorder; ++rightBorder; } } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SlowN2::evenCount() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indMiddle = <span class="hljs-number"><span class="hljs-number">0</span></span>; indMiddle &lt; str.length(); ++indMiddle) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> leftBorder = indMiddle, rightBorder = indMiddle + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(leftBorder &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; rightBorder &lt; str.length() &amp;&amp; str[leftBorder] == str[rightBorder]) { ++cntPalindromes; --leftBorder; ++rightBorder; } } }</code> </pre><br>  Here is a little more interesting.  We have a string, and two temporary arrays for palindromes of even and odd length.  And the number in cell i of the array will store the number of palindromes in string s (source line) with center at point i.  For the odd length of the palindrome, the center is easy, but for the even one, we will just play around with the indices and shift the center slightly (as seen in the code).  Our result is the sum of numbers from two arrays. <br><br>  As you can see, nothing complicated again.  But it works much faster than the previous algorithm.  Why?  Let's look at how it all works. <br><br>  We run along the line, sorting through the central symbol of our potential palindrome.  And then just run left and right from the central element as long as the characters are the same.  As soon as they became different, it means that there will be no further palindromes with a center in our selected element, and proceed to the next. <br><br>  And it works quickly on ordinary lines very quickly because our second, nested cycle, which runs until the extreme characters are equal, terminates extremely quickly (assuming that the palindromes in the line are much less than the total number of substrings). <br><br>  Consider the pros and cons of the method. <br><br>  Pros: <br><br>  + Everything is also easy to code.  It is very difficult to make a mistake. <br>  + Small hidden constant <br>  + Behaves well on random strings <br><br>  Minuses: <br><br>  - Still a long time work <br><br>  After this method, the head begins to think, think, think.  And here is the idea!  And what if we modify this method, but we will jump from the central element not by 1 symbol with each iteration, but a little more?  And here we come to the rescue ... <br><br><h4>  2) Use hashes! </h4><br>  This method is a bit more complicated, so I‚Äôll immediately give you the code, and then I will try to explain what kind of magic is going on there (although there is no magic, as you yourself know very well): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Hash::getHash(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indLeft, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indRight) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefixHash[indRight] - (indLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? prefixHash[indLeft - <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Hash::getRevHash(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indLeft, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indRight) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> suffixHash[indLeft] - (indRight &lt; suffixHash.size() - <span class="hljs-number"><span class="hljs-number">1</span></span> ? suffixHash[indRight + <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hash::PrepareSimpleNumbers() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(str.length() &gt; simpleNumbers.size()) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> oldSize = simpleNumbers.size(); simpleNumbers.resize(str.length()); simpleNumbers[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1L</span></span>L; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = oldSize; i &lt; simpleNumbers.size(); ++i) simpleNumbers[i] = simpleNumbers[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] * SimpleBase; } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hash::CountingPrefixHash() { prefixHash[<span class="hljs-number"><span class="hljs-number">0</span></span>] = str[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; prefixHash.size(); ++i) { prefixHash[i] = prefixHash[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] + str[i] * simpleNumbers[i]; } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hash::CountingSuffixHash() { suffixHash[suffixHash.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>] = str[str.length() - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) str.length() - <span class="hljs-number"><span class="hljs-number">2</span></span>, j = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; --i, ++j) { suffixHash[i] = suffixHash[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] + str[i] * simpleNumbers[j]; } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Hash::isPalindrome(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indLeft, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indRight) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getHash(indLeft, indRight) * simpleNumbers[prefixHash.size() - indRight - <span class="hljs-number"><span class="hljs-number">1</span></span>] == getRevHash(indLeft, indRight) * simpleNumbers[indLeft]; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hash::CountingOdd() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; oddCount.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indLeft = <span class="hljs-number"><span class="hljs-number">1</span></span>, indRight = min(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; (oddCount.size() - i)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (indLeft &lt;= indRight) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> middle = (indLeft + indRight) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPalindrome(i - middle + <span class="hljs-number"><span class="hljs-number">1</span></span>, i + middle - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { oddCount[i] = middle - <span class="hljs-number"><span class="hljs-number">1</span></span>; indLeft = middle + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { indRight = middle - <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hash::CountingEven() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; evenCount.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> indLeft = <span class="hljs-number"><span class="hljs-number">1</span></span>, indRight = min(i, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; (evenCount.size() - i)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (indLeft &lt;= indRight) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> middle = (indLeft + indRight) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPalindrome(i - middle, i + middle - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { evenCount[i] = middle; indLeft = middle + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { indRight = middle - <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } } <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> Hash::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()() { PrepareSimpleNumbers(); CountingPrefixHash(); CountingSuffixHash(); CountingOdd(); CountingEven(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; str.length(); ++i) { cntPalindromes += oddCount[i] + evenCount[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cntPalindromes; }</code> </pre><br>  A brief summary of this method: we iterate over the central element of our palindrome, and then dichotomy we try to find the largest radius of our palindrome (radius here means the distance from the central element to the extreme, if we have an even-length palindrome, then we just add a little game with indices to worked).  During the selection, we must somehow quickly compare the substrings for identity.  do it with hashes.  Asymptotics, as it is easy to guess: N is spent on enumeration of the central element, logN in the worst case, we spend on the selection of the palindrome radius, for a unit we compare substrings using hashes.  Total we have O (NlogN), which is very good indeed. <br><br>  Now let's take a closer look at this method. <br><br>  What is our method based on?  Since we iterate through the central element, and then by dichotomy, we select the radius of the largest palindrome with the center in this element, we must quickly take the hash of the left side of our potential palindrome and compare it with the hash of the right side of our potential palindrome. <br><br>  How to do it?  Let's first calculate the hash for each prefix and suffix of the source string.  In the code, this is done by the CountingPrefixHash () and CountingSuffixHash () methods, respectively. <br><br>  Using the getHash () and getRevHash () methods, we can quickly get hashes of the left and right sides of the potential palindrome considered at this stage.  There may be a question why it is impossible to use the same function of hash calculation for the left and right parts.  And all because when we check for palindrome, we read the left side from left to right, and the second from right to left.  And we need to support the hash from left to right and from right to left. <br><br>  The only difficulty left is how to compare these 2 hashes?  And we solve this problem with the help of the isPalindrome () method, which leads the hashes to one base and compares them. <br><br>  The result of each iteration will be the number of palindromes with center i.  We run 2 times for palindromes of even and odd length, the answer to our problem is the sum of all values ‚Äã‚Äãof the oddCount arrays and evenCount <br><br>  In more detail about this method you can read in <a href="https://habrahabr.ru/post/142589/">this article</a> . <br><br>  Pros: <br><br>  + Asymptotically we reduced to NlogN, which is good news.  If we take only the worst cases, then in theory someday we will win <br><br>  Minuses: <br><br>  - Quite hard to write.  Easy to sow bug.  We need some theoretical training in the field of hashes. <br>  - Slowly working on random tests.  You can see for yourself.  And all because of the large hidden constant and because even if we do not have a single palindrome with a center in this element, the algorithm will make logN jumps, and this all takes time. <br>  - Collisions.  As you can see, my source uses a hash, which is usually written in programming contests (yes, I once did this a bit).  So, at competitions this method shows itself well.  Personally, my collisions did not happen.  But I know about ways to calmly fill up this hash (in particular, the method using Thue-Morse lines).  I once heard that there is some kind of fibonacci hash that doesn‚Äôt seem to break on this test, but the information is unreliable.  So be careful with collisions. <br><br>  And if we want a 100% solution without any collision correction and entering a hash on another basis, and so on? <br><br><h4>  3) Algorithm Manaker </h4><br>  Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Find palindroms like 2*N+1 void Manacker::PalN2() { int leftBorder = 0, rightBorder = -1, tempMirror;//start digits for algortihm for(int i = 0; i &lt; str.length(); ++i) { tempMirror = (i &gt; rightBorder ? 0 : std::min(ansPalN2[leftBorder + rightBorder - i], rightBorder - i)) + 1;//find mirror of current index while(i + tempMirror &lt; str.length() &amp;&amp; i - tempMirror &gt;= 0 &amp;&amp; str[i - tempMirror] == str[i + tempMirror])//increase our index { ++tempMirror; } ansPalN2[i] = --tempMirror; if(i + tempMirror &gt; rightBorder)//try to increase our right border of palindrom { leftBorder = i - tempMirror; rightBorder = i + tempMirror; } } } void Manacker::Pal2() { int leftBorder = 0, rightBorder = -1, tempMirror; for(int i = 0; i &lt; str.length(); ++i) { tempMirror = (i &gt; rightBorder ? 0 : std::min(ansPal2[leftBorder + rightBorder - i + 1], rightBorder - i + 1)) + 1; while(i + tempMirror - 1 &lt; str.length() &amp;&amp; i - tempMirror &gt;= 0 &amp;&amp; str[i - tempMirror] == str[i + tempMirror - 1]) { ++tempMirror; } ansPal2[i] = --tempMirror; if(i + tempMirror - 1 &gt; rightBorder) { leftBorder = i - tempMirror; rightBorder = i + tempMirror - 1; } } }</span></span></code> </pre><br>  So, we obtained with the help of hashes the algorithm for NlogN.  But I want faster.  I want something linear.  And here we are in a hurry to help the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B4%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25BD%25D0%25B5%25D0%25B9%25D1%2588%25D0%25B5%25D0%25B9_%25D0%25BF%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25BA%25D0%25B8-%25D0%25BF%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B4%25D1%2580%25D0%25BE%25D0%25BC%25D0%25B0">Manaker Algorithm</a> (by reference you can also see the implementation of the algorithm in Java), which is not only linear, it also has an extremely small hidden constant, which has a positive effect on its speed.  I will not describe the method in detail, since it will be a retelling of this wonderful <a href="http://e-maxx.ru/algo/palindromes_count">link</a> (I myself taught the algorithm for this link).  Here I will give a slightly retold explanation. <br><br>  The algorithm is that we process the string character by symbol, supporting the rightmost palindrome in our string.  And at each iteration we look, our current element is inside the borders of the rightmost palindrome or not.  If it is, then we can extract the answer from the previously calculated values, by simple manipulations with the indices.  If it is not, then we go with exactly the same algorithm described in paragraph 1) of this review: go character by character and compare the mirror elements relative to the center.  Go as long as they are equal.  And do not forget to update after this the boundaries of the right-most palindrome found.  This is in brief.  You can read about some of the pitfalls in this article. <br><br>  What else is interesting: in all the tasks that I solved on the contests (on Olympiad programming), this algorithm was enough.  Very easy to write if you wrote it N times at home and you already know by heart. <br><br>  Pros: <br><br>  + Pretty short code. <br>  + It works very fast.  Not only is the asymptotic behavior of O (N), but also a small hidden constant. <br><br>  Minuses: <br><br>  - The idea is not so simple to come up with this algorithm right away <br>  - You can get confused in all sorts of indices, if you show carelessness when writing code <br><br>  Are there any other ways to solve this problem in linear time? <br><br><h4>  4) Palindrome tree </h4><br>  A little background.  This relatively new data structure was discovered by Mikhail Rubinchik <a href="https://habrahabr.ru/users/rumi13/" class="user_link">rumi13</a> and presented it at the Petrozavodsk training camp.  The structure is extremely interesting, on the one hand, simplicity, and on the other, it allows you to quickly solve a fairly wide range of tasks about palindromes.  And most importantly, it makes it quite simple to count the number of palindromes in a row for O (N) (but I think the palindrome tree itself was far from being invented for this purpose, but for more serious tasks with palindromes). <br><br>  Code: <br><br><pre> <code class="cpp hljs">PalindromicTree::PalindromicTree(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s) : FindPalindrome(s) { initTree(); } PalindromicTree::~PalindromicTree() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>;i &lt; pullWorkNodes.size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pullWorkNodes[i]; } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PalindromicTree::initTree() { root1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node; root1-&gt;len = <span class="hljs-number"><span class="hljs-number">-1</span></span>; root1-&gt;sufflink = root1; root2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node; root2-&gt;len = <span class="hljs-number"><span class="hljs-number">0</span></span>; root2-&gt;sufflink = root1; suff = root2; pullWorkNodes.push_back(root1); pullWorkNodes.push_back(root2); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PalindromicTree::findAddSuffix(Node* &amp;cur, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; curlen) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { curlen = cur-&gt;len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos - <span class="hljs-number"><span class="hljs-number">1</span></span> - curlen &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; str[pos - <span class="hljs-number"><span class="hljs-number">1</span></span> - curlen] == str[pos]) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } cur = cur-&gt;sufflink; } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PalindromicTree::makeSuffixLink(Node* &amp;cur, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; curlen,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> let) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { cur = cur-&gt;sufflink; curlen = cur-&gt;len; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos - <span class="hljs-number"><span class="hljs-number">1</span></span> - curlen &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; str[pos - <span class="hljs-number"><span class="hljs-number">1</span></span> - curlen] == str[pos]) { suff-&gt;sufflink = cur-&gt;next[let]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> PalindromicTree::addLetter(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos) { Node* cur = suff; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> let = str[pos] - <span class="hljs-string"><span class="hljs-string">'a'</span></span>, curlen = <span class="hljs-number"><span class="hljs-number">0</span></span>; findAddSuffix(cur, pos, curlen); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cur-&gt;next[let] != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { suff = cur-&gt;next[let]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } suff = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node; pullWorkNodes.push_back(suff); suff-&gt;len = cur-&gt;len + <span class="hljs-number"><span class="hljs-number">2</span></span>; cur-&gt;next[let] = suff; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (suff-&gt;len == <span class="hljs-number"><span class="hljs-number">1</span></span>) { suff-&gt;sufflink = root2; suff-&gt;num = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } makeSuffixLink(cur, pos, curlen, let); suff-&gt;num = <span class="hljs-number"><span class="hljs-number">1</span></span> + suff-&gt;sufflink-&gt;num; } <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> PalindromicTree::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ()() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; str.length(); ++i) { addLetter(i); cntPalindromes += suff-&gt;num - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cntPalindromes; }</code> </pre><br>  Again, I will retell in brief the essence of this algorithm.  A more detailed explanation can be found in this wonderful <a href="http://adilet.org/blog/25-09-14/">article</a> . <br><br>  So, the idea of ‚Äã‚Äãa tree.  In the tops of our tree there will be only the palindromes themselves: 'a', 'b', 'aba' and so on.  It is clear that we will not store palindromes ourselves, but simply keep from which vertex we came here, and which symbol we added from both sides.  We also have two dummy vertices for convenient implementation of the algorithm. <br><br>  But as in any interesting tree, we also have suffix links.  The suffix link will lead to the summit, which is also a palindrome (well, because we only have palindromes in the vertices) and which is the largest proper suffix of this vertex.  That is, from the vertex 'aba' the link will lead to the vertex 'a'. <br><br>  Next, we in turn add characters to the tree one by one.  And thanks to the tricky arrangement of the tree and the recursive operation of adding (as well as the suffix links under which the transition is made), we update the entire tree. <br><br>  In short, read more information on the link above (if you are not afraid of English) <br><br>  Pros: <br><br>  + If you have previously worked with trees, then it will be very easy for you to understand this idea. <br>  + Allows you to solve a wide range of tasks for palindromes <br><br>  Minuses: <br><br>  - It works slower than the Manaker algorithm. <br>  - You can put the bug.  But, purely subjective, it is more difficult to do here than in the same Manaker algorithm. <br><br>  It is also worth mentioning that using trees there is another solution to this problem.  It consists in using the suffix tree and the fast LCA algorithm (which works for preprocessing O (N) and answering the query O (1). Farah-Colton-Bender algorithm).  But it is not applied in practice, as it is rather complicated and it has an extremely large hidden constant.  It is more of academic interest. <br><br>  What could be more interesting about the algorithms?  That's right, memory consumption and running time. <br>  On the github you can also download a test code that generates random strings and looks for palindromes in them. <br><br>  My testing showed that the expected algorithm number 0 is extremely slow.  The leader, as you can guess, is the Manaker algorithm.  But what is most interesting: the algorithm with O (N ^ 2) wins with an approximately two-fold separation from the algorithm using hashes with O (NlogN), which once again proves that algorithms are not measured by a single asymptotics.  This is due to the peculiarities of the clipping algorithm number 1, and the lack thereof in the method with hashes.  As for the tree of palindromes, it loses to Manucker mainly due to memory operations, as it is necessary to allocate memory for each new vertex.  But if you use, for example, new with placement, the gap will be reduced. <br><br>  Memory all algorithms consume linearly from the size of the input data. <br><br>  This concludes our review.  I hope that you have learned something new for yourself and it was just a little interesting for you!  You can find all the sources in my public repository on <a href="https://github.com/ZaMaZaN4iK/AlgoForPalindromes">Github</a> . <br><br>  PS: If you notice any typos, inaccuracies or you have additions - please unsubscribe in the comments and write in the LAN. <br>  PPS: Feel free to ask questions in the comments - I will try to answer if my competence is enough. <br><br>  Useful links that may be of interest to you after reading this article (some links may be repeated, as they might be skipped in the article itself): <br><br>  0) <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B4%25D1%2580%25D0%25BE%25D0%25BC">What is a palindrome</a> <br>  1) The Manaker Algorithm: <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B4%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25BD%25D0%25B5%25D0%25B9%25D1%2588%25D0%25B5%25D0%25B9_%25D0%25BF%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25BA%25D0%25B8-%25D0%25BF%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25B4%25D1%2580%25D0%25BE%25D0%25BC%25D0%25B0">Wiki</a> , <a href="http://codeforces.com/blog/entry/12143%3Flocale%3Dru">Codeforces</a> , <a href="http://e-maxx.ru/algo/palindromes_count">e-maxx</a> <br>  2) A bit about hashes and their use: <a href="http://e-maxx.ru/algo/string_hashes">e-maxx</a> , <a href="https://habrahabr.ru/post/142589/">Habrahabr</a> <br>  3) Discussion about the obstruction of hashes on Codeforces: <a href="http://codeforces.com/blog/entry/4898">tyts</a> <br>  4) Thue-Morse lines (words): <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%259C%25D0%25BE%25D1%2580%25D1%2581%25D0%25B0_%25E2%2580%2594_%25D0%25A2%25D1%2583%25D1%258D">one</a> , <a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%25A1%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25BE_%25D0%25A2%25D1%2583%25D1%258D-%25D0%259C%25D0%25BE%25D1%2580%25D1%2581%25D0%25B0">two</a> <br>  5) Articles about palindrome tree: <a href="http://adilet.org/blog/25-09-14/">good description</a> , <a href="http://codeforces.com/blog/entry/13959%3Flocale%3Dru">codeforces</a> <br>  6) Here is another series of articles about the search for numbers-palindromes: <a href="https://habrahabr.ru/post/270325/">Habr</a> </div><p>Source: <a href="https://habr.com/ru/post/276195/">https://habr.com/ru/post/276195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276179/index.html">WLAN architecture: what to choose?</a></li>
<li><a href="../276185/index.html">XAML Developer Chips: Embedded Converters</a></li>
<li><a href="../276187/index.html">We are implementing an analogue of Apple iCloud Voicemail using free grammars from Yandex</a></li>
<li><a href="../276189/index.html">Moxy - MVP implementation for Android with a pinch of magic</a></li>
<li><a href="../276193/index.html">Finite Volume method - implementation on the example of thermal conductivity</a></li>
<li><a href="../276205/index.html">Add instructions to the microprocessor MIPS, which work in the pipeline as his own</a></li>
<li><a href="../276209/index.html">Millimetric is back. Now - Open Source</a></li>
<li><a href="../276211/index.html">The study of common Malvari under Android</a></li>
<li><a href="../276213/index.html">OpenSSL eliminates a dangerous vulnerability that allowed an attacker to decrypt HTTPS traffic</a></li>
<li><a href="../276217/index.html">What actually virtual memory can do</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>