<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pointers in Python: what‚Äôs the point?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you have ever worked with such low-level languages ‚Äã‚Äãlike C or C ++, you probably heard about pointers. They allow you to greatly increase the effe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pointers in Python: what‚Äôs the point?</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/_i/vd/cj/_ivdcjv0itamifffxs0i1i-mqh4.jpeg"></div><br>  If you have ever worked with such low-level languages ‚Äã‚Äãlike C or C ++, you probably heard about pointers.  They allow you to greatly increase the effectiveness of different pieces of code.  But they can also confuse newbies - and even experienced developers - and lead to memory management bugs.  Are there any pointers in Python, can I emulate them in some way? <br><br>  Pointers are widely used in C and C ++.  In fact, these are variables that contain the memory addresses for which other variables are located.  To refresh your pointer knowledge, read this <a href="https://www.tutorialspoint.com/cprogramming/c_pointers.htm">review</a> . <br><br>  Thanks to this article, you will better understand the object model in Python and find out why pointers do not really exist in this language.  In case you need to imitate the behavior of pointers, you will learn how to emulate them without a concurrent memory management nightmare. <br><a name="habracut"></a><br>  With this article you will: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Find out why there are no pointers in Python. </li><li>  Learn the difference between C variables and names in Python. </li><li>  Learn how to emulate pointers in Python. </li><li> Use <code>ctypes</code> experiment with real pointers. </li></ul><br>  <b>Note</b> : The term ‚ÄúPython‚Äù here applies to the Python implementation of C, which is known as CPython.  All discussions of the device language are valid for CPython 3.7, but may not correspond to subsequent iterations. <br><br><h2>  Why are there no pointers in Python? </h2><br>  I do not know.  Can pointers exist natively in Python?  Probably, but apparently, pointers contradict the concept of <a href="https://www.python.org/dev/peps/pep-0020/">Zen of Python</a> , because they provoke implicit changes instead of explicit ones.  Often, pointers are quite complex, especially for beginners.  Moreover, they are pushing you to unsuccessful decisions or to do something really dangerous, like reading from a memory area, from where you should not have read. <br><br>  Python tries to abstract from the user implementation details, such as memory addresses.  Often in this language the emphasis is on ease of use, not speed.  Therefore, pointers in Python do not make much sense.  But don't worry, by default the language gives you some advantages of using pointers. <br><br>  To deal with pointers in Python, let's take a quick look at the features of the language implementation.  In particular, you need to understand: <br><br><ol><li>  What are mutable and immutable objects. </li><li>  How are the variables / names in Python. </li></ol><br>  Hold on to your memory addresses, let's go! <br><br><h2>  Objects in Python </h2><br>  Everything in Python is an object.  For example, open the REPL and see how <code>isinstance()</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>isinstance(<span class="hljs-number"><span class="hljs-number">1</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(list(), object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; isinstance(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> ... &gt;&gt;&gt; isinstance(foo, object) <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  This code demonstrates that everything in Python is actually objects.  Each object contains at least three types of data: <br><br><ul><li>  Reference count. <br></li><li>  Type of. <br></li><li>  Value. <br></li></ul><br>  <a href="https://docs.python.org/3/library/sys.html">The reference counter is</a> used to manage memory.  Details about this management are written in <a href="https://realpython.com/python-memory-management/">Memory Management in Python</a> .  The type is used at the CPython level to ensure type safety during execution (runtime).  And the value is the actual value associated with the object. <br><br>  But not all objects are the same.  There is one important difference: objects are changeable and unchangeable.  Understanding this distinction between object types will help you become more aware of the first layer of the onion, which is called "Python Pointers." <br><br><h2>  Mutable and immutable objects </h2><br>  There are two types of objects in Python: <br><br><ol><li>  Immutable objects (can not be changed); <br></li><li>  Variable objects (subject to change). <br></li></ol><br>  Awareness of this difference is the first key to traveling the world of pointers in Python.  Here is a characteristic of the immutability of some popular types: <br><br><div class="scrollable-table"><table><tbody><tr><th width="400">  Type of <br></th><th width="400">  Unchangeable? <br></th></tr><tr><td>  int <br></td><td>  Yes <br></td></tr><tr><td>  float <br></td><td>  Yes <br></td></tr><tr><td>  bool <br></td><td>  Yes <br></td></tr><tr><td>  complex <br></td><td>  Yes <br></td></tr><tr><td>  tuple <br></td><td>  Yes <br></td></tr><tr><td>  frozenset <br></td><td>  Yes <br></td></tr><tr><td>  str <br></td><td>  Yes <br></td></tr><tr><td>  list <br></td><td>  Not <br></td></tr><tr><td>  set <br></td><td>  Not <br></td></tr><tr><td>  dict <br></td><td>  Not <br></td></tr></tbody></table></div><br>  As you can see, many of the commonly used primitive types are immutable.  You can check this by writing some Python code.  You will need two tools from the standard library: <br><br><ol><li>  <code>id()</code> returns the memory address of the object; <br></li><li>  <code>is</code> returns <code>True</code> if and only if two objects have the same memory address. <br></li></ol><br>  You can run this code in the REPL environment: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">5</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049376</span></span></code> </pre> <br>  Here we assign the value <code>x</code> to the variable <code>x</code> .  If you try to change the value using addition, you will get a new object: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-number"><span class="hljs-number">6</span></span> &gt;&gt;&gt; id(x) <span class="hljs-number"><span class="hljs-number">94529957049408</span></span></code> </pre> <br>  Although it may seem that this code simply changes the value of <code>x</code> , in fact you get a <b>new</b> object as an answer. <br><br>  The <code>str</code> type is also immutable: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s = <span class="hljs-string"><span class="hljs-string">"real_python"</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819584048</span></span> &gt;&gt;&gt; s += <span class="hljs-string"><span class="hljs-string">"_rocks"</span></span> &gt;&gt;&gt; s <span class="hljs-string"><span class="hljs-string">'real_python_rocks'</span></span> &gt;&gt;&gt; id(s) <span class="hljs-number"><span class="hljs-number">140637819609424</span></span></code> </pre> <br>  And in this case, <code>s</code> after the operation <code>+=</code> gets a <b>different</b> memory address. <br><br>  <b>Bonus</b> : The <code>+=</code> operator <code>+=</code> converted to various method calls. <br><br>  For some objects, such as a list, <code>+=</code> converts to <code>__iadd__()</code> (local add).  It will change itself and return the same ID.  However, <code>str</code> and <code>int</code> do not have these methods, and as a result <code>__add__()</code> will be called instead of <code>__iadd__()</code> . <br><br>  For more information, see the Python <a href="https://docs.python.org/3/reference/datamodel.html">data model documentation</a> <a href="https://docs.python.org/3/reference/datamodel.html">.</a> <br><br>  If we try to directly change the string value <code>s</code> we get an error: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"R"</span></span></code> </pre> <br>  Reverse tracing (the most recent calls are displayed last): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;mdule&gt; TypeError: <span class="hljs-string"><span class="hljs-string">'str'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  The above code fails and Python reports that <code>str</code> does not support this change, which corresponds to the definition of immutability of type <code>str</code> . <br><br>  Compare with a variable object, for example, with a list: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span> &gt;&gt;&gt; my_list.append(<span class="hljs-number"><span class="hljs-number">4</span></span>) &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  This code demonstrates the main difference between the two types of objects.  Initially, <code>my_list</code> has an ID.  Even after adding to list <code>4</code> , <code>my_list</code> still has <b>the same</b> ID.  The reason is that the <code>list</code> type is mutable. <br><br>  Here is another demonstration of list variability with assignment: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>my_list[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; my_list [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>] &gt;&gt;&gt; id(my_list) <span class="hljs-number"><span class="hljs-number">140637819575368</span></span></code> </pre> <br>  In this code, we changed <code>my_list</code> and set it to <code>0</code> as the first element.  However, the list retained the same ID after this operation.  The next step on our journey to <a href="https://realpython.com/pycon-guide/">knowing Python</a> will be exploring its ecosystem. <br><br><h2>  Understanding Variables </h2><br>  Variables in Python are fundamentally different from variables in C and C ++.  In fact, they are simply not in Python.  <b>Instead of variables here are the names</b> . <br><br>  This may sound pedantic, and for the most part the way it is.  Most often, you can take names in Python as variables, but you need to understand the difference.  This is especially important when studying such a difficult topic as pointers. <br><br>  To make it easier for you to understand, let's see how variables work in C, what they represent, and then compare it with the work of names in Python. <br><br><h3>  Variables in C </h3><br>  Take the code that defines the variable <code>x</code> : <br><br><pre> <code class="python hljs">int x = <span class="hljs-number"><span class="hljs-number">2337</span></span>;</code> </pre> <br>  Execution of this short line goes through several different stages: <br><br><ol><li>  Allocating enough memory for a number. <br></li><li>  Assigning the value of <code>2337</code> to this place in memory. <br></li><li>  The mapping that <code>x</code> indicates to this value. <br></li></ol><br>  Simplified memory may look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f13/e62/d71/f13e62d71774b73aecff45931b6db57f.png"><br><br>  Here, the variable <code>x</code> has a fake address <code>0x7f1</code> and a value of <code>2337</code> .  If you later want to change the value of <code>x</code> , you can do this: <br><br><pre> <code class="python hljs">x = <span class="hljs-number"><span class="hljs-number">2338</span></span>;</code> </pre> <br>  This code assigns the new value of <code>2338</code> to the variable <code>x</code> , thereby overwriting the <b>previous</b> value.  This means that the variable <code>x</code> <b>mutable</b> .  Updated memory for new value: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/347/491/19b/34749119bcba5c4009861aa4e7c40c45.png"><br><br>  Note that the location of <code>x</code> not changed, only the value itself.  It is important.  This tells us that <code>x</code> is <b>a place in memory</b> , not just a name. <br><br>  You can also consider this issue within the concept of ownership.  On the one hand, <code>x</code> owns a place in memory.  First, <code>x</code> is an empty box that can contain only one number (integer) in which integer values ‚Äã‚Äãcan be stored. <br><br>  When you assign <code>x</code> a value, you put the value in the box belonging to <code>x</code> .  If you want to submit a new variable <code>y</code> , you can add this line: <br><br><pre> <code class="python hljs">int y = x;</code> </pre> <br>  This code creates a new box called <code>y</code> and copies the value from <code>x</code> .  Now the memory circuit looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/caa/74d/ed3/caa74ded301b1f527e1b94516f1b1196.png"><br><br>  Note the new location <code>y</code> - <code>0x7f5</code> .  Although the value <code>x</code> was copied in <code>y</code> , the variable <code>y</code> owns the new address in memory.  Therefore, you can overwrite the value of <code>y</code> without affecting <code>x</code> : <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2339</span></span>;</code> </pre> <br>  Now the memory circuit looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcf/f8d/ed4/fcff8ded49647ad0053a45f0773cb4bb.png"><br><br>  I repeat: you changed the value of <code>y</code> , but not the location.  In addition, you did not affect the original variable <code>x</code> . <br><br>  Named in Python is a completely different situation. <br><br><h3>  Python Names </h3><br>  There are no variables in Python, instead of names.  You can use the term "variables" at your discretion, but it is important to know the difference between variables and names. <br><br>  Let's take the equivalent code from the above example in C and write it in Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2337</span></span></code> </pre> <br>  As in C, during the execution of this code passes through several separate stages: <br><br><ol><li>  PyObject is created. <br></li><li>  A number for PyObject is assigned a typecode. <br></li><li>  <code>2337</code> assigned a value for PyObject. <br></li><li>  The name <code>x</code> is created. </li><li>  <code>x</code> indicates a new PyObject. </li><li>  PyObject's link count is incremented by 1. <br></li></ol><br>  <b>Note</b> : <a href="">PyObject</a> is not the same as an object in Python, this entity is typical for CPython and represents the basic structure of all Python objects. <br><br>  PyObject is defined as a C-structure, so if you are wondering why you cannot directly call a typecode or a reference counter, the reason is that you do not have direct access to the structures.  <a href="https://docs.python.org/3/library/sys.html">Calling</a> methods like <a href="https://docs.python.org/3/library/sys.html">sys.getrefcount ()</a> can help get some internal things. <br><br>  If we talk about memory, it may look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d9/ad7/932/9d9ad79327405315461e3880fe3db256.png"><br><br>  Here, the memory circuit is very different from the circuit in C shown above.  Instead of <code>x</code> owning a block of memory in which the value of <code>2337</code> is stored, the newly created Python object owns the memory in which <code>2337</code> lives.  The python name <code>x</code> does not directly own <b>any</b> address in memory, as the C-variable owns a static cell. <br><br>  If you want to assign <code>x</code> new value, try this code: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  The behavior of the system will be different from what happens in C, but will not be too different from the original binding (bind) in Python. <br><br>  In this code: <br><br><ul><li>  A new PyObject is created. <br></li><li>  A number for PyObject is assigned a typecode. <br></li><li>  <code>2</code> assigned a value for PyObject. <br></li><li>  <code>x</code> indicates a new PyObject. <br></li><li>  The reference count of the new PyObject is incremented by 1. <br></li><li>  The reference count of the old PyObject is decremented by 1. <br></li></ul><br>  Now the memory circuit looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/712/860/996/712860996aa37da34fdb69a466cdf5de.png"><br><br>  This illustration demonstrates that <code>x</code> points to an object reference and does not own the memory region as it used to.  You also see that the command <code>x = 2338</code> is not an assignment, but rather a binding of the name <code>x</code> to the link. <br><br>  In addition, the previous object (containing the value of <code>2337</code> ) is now in memory with a reference count of 0, and will be removed <a href="https://docs.python.org/3/faq/design.html%3Fhighlight%3Dgarbage%2520collect">by the garbage collector</a> . <br><br>  You can enter a new name, <code>y</code> , as in the C example: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = x</code> </pre> <br>  A new name will appear in memory, but not necessarily a new object: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/958/adc/410/958adc41013bb5483f0526689a48a871.png"><br><br>  Now you see that a new Python object is <b>not</b> created, only a new name is created that points to the same object.  In addition, the object reference count increased by 1. You can check the equivalence of the identity of objects to confirm their sameness: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  This code shows that <code>x</code> and <code>y</code> are one object.  But make no mistake: <code>y</code> is still immutable.  For example, you can perform an addition operation with <code>y</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y += <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  After the addition call, you will be returned a new Python object.  Now the memory looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/abc/3e7/8bdabc3e7576ab86b00ba9c2b43b57b4.png"><br><br>  A new object has been created, and <code>y</code> now points to it.  It is curious that we would get exactly the same final state if we directly tied <code>y</code> to <code>2339</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>y = <span class="hljs-number"><span class="hljs-number">2339</span></span></code> </pre> <br>  After this expression, we obtain the final state of memory, as in the addition operation.  Let me remind you that in Python you do not assign variables, but bind names to links. <br><br><h3>  About interned objects in Python </h3><br>  Now you understand how new objects are created in Python and how names are attached to them.  It's time to talk about interned objects. <br><br>  We have the following Python code: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  As before, <code>x</code> and <code>y</code> are names pointing to the same Python object.  But this object containing the value <code>1000</code> cannot always have the same memory address.  For example, if you add two numbers and get 1000, you will get another address: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">1000</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">499</span></span> + <span class="hljs-number"><span class="hljs-number">501</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  This time, the string <code>x is y</code> returns <code>False</code> .  If you are embarrassed, do not worry.  Here is what happens when this code is executed: <br><br><ol><li>  A Python object ( <code>1000</code> ) is created. <br></li><li>  It is given the name <code>x</code> . <br></li><li>  A Python object is created ( <code>499</code> ). <br></li><li>  A Python object is created ( <code>501</code> ). <br></li><li>  These two objects add up. <br></li><li>  A new Python object ( <code>1000</code> ) is created. <br></li><li>  It is given the name <code>y</code> . <br></li></ol><br>  <b>Technical explanation</b> : the steps described take place only when this code is executed inside the REPL.  If you take the above example, paste it into a file and run it, then the line <code>x is y</code> returns <code>True</code> . <br><br>  The reason is the CPython compiler's quick <a href="https://en.wikipedia.org/wiki/Peephole_optimization">thinking</a> , which is trying to perform <a href="https://en.wikipedia.org/wiki/Peephole_optimization">peephole optimizations</a> that help, as far as possible, to save code execution steps.  Details can be found in the <a href="">source code of the CPython peephole optimizer</a> . <br><br>  But isn't it wasteful?  Well, yes, but this price you pay for all the great benefits of Python.  You do not need to think about removing such intermediate objects, and do not even need to know about their existence!  The joke is that these operations are performed relatively quickly, and you would not have known about them until this moment. <br><br>  The creators of Python wisely noticed these overheads and decided to make a few optimizations.  Their result is behavior that may surprise newbies: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = <span class="hljs-number"><span class="hljs-number">20</span></span> &gt;&gt;&gt; y = <span class="hljs-number"><span class="hljs-number">19</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt;&gt; x <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  In this example, almost the same code as above, except that we get <code>True</code> .  It's all about interned objects.  Python pre-creates in memory a certain subset of objects and stores them in the global namespace for everyday use. <br><br>  What objects depend on the Python implementation?  In CPython 3.7 interned are: <br><br><ol><li>  Integers in the range of <code>-5</code> to <code>256</code> . <br></li><li>  Strings containing only ASCII letters, numbers, or underscores. <br></li></ol><br>  This is done because these variables are very often used in many programs.  When interning, Python prevents memory allocation for constantly used objects. <br><br>  Lines smaller than 20 characters and containing ASCII letters, numbers, or underscores will be interned, since it is assumed that they will be used as identifiers: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s1) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"realpython"</span></span> &gt;&gt;&gt; id(s2) <span class="hljs-number"><span class="hljs-number">140696485006960</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  Here, <code>s1</code> and <code>s2</code> point to the same address in memory.  If we inserted a non-ASCII letter, digit or underscore, we would get a different result: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>s1 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s2 = <span class="hljs-string"><span class="hljs-string">"Real Python!"</span></span> &gt;&gt;&gt; s1 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> s2 <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br>  In this example, an exclamation point is used, so the strings are not interned and are different objects in memory. <br><br>  <b>Bonus</b> : If you want these objects to refer to the same interned object, you can use <code>sys.intern()</code> .  One way to use this feature is described in the documentation: <br><br><blockquote>  String interning is useful for a slight increase in performance when searching through a dictionary: if the keys in the dictionary and the desired key are interned, then the comparison of keys (after hashing) can be performed by comparing pointers rather than strings.  ( <a href="https://docs.python.org/3/library/sys.html">Source</a> ) </blockquote><br>  Interned objects are often confused by programmers.  Just remember that if you start to doubt, you can always use <code>id()</code> and <code>is</code> to determine the equivalence of objects. <br><br><h2>  Pointer emulation in Python </h2><br>  The fact that pointers are missing natively in Python does not mean that you cannot take advantage of pointers.  There are actually several ways to emulate pointers in Python.  Here we look at two of them: <br><br><ol><li>  Use as pointers of changeable types. <br></li><li>  Application of specially prepared Python objects. <br></li></ol><br><h3>  Use as pointers of changeable types </h3><br>  You already know what changeable types are.  It is because of their variability that we can emulate the behavior of pointers.  Suppose you need to replicate this code: <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  This code takes a pointer to the number ( <code>*x</code> ) and increments the value by 1. Here is the main function to execute the code: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;stdi.h&gt; int main(void) { int y = 2337; printf("y = %d\n", y); add_one(&amp;y); printf("y = %d\n", y); return 0; }</span></span></code> </pre> <br>  In the above fragment, we assigned <code>y</code> value <code>2337</code> , displayed the current value, increased it by 1, and then derived the new value.  Appears on the screen: <br><br><pre> <code class="python hljs">y = <span class="hljs-number"><span class="hljs-number">2337</span></span> y = <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  One way to replicate this behavior in Python is to use a mutable type.  For example, apply the list and change the first element: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> ... x[<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; y = [<span class="hljs-number"><span class="hljs-number">2337</span></span>] &gt;&gt;&gt; add_one(y) &gt;&gt;&gt; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-number"><span class="hljs-number">2338</span></span></code> </pre> <br>  Here <code>add_one(x)</code> refers to the first element and increases its value by 1. Applying the list means that as a result we will get a modified value.  So there are pointers in Python?  Not.  The described behavior became possible because the list is a changeable type.  If you try to use a tuple, you will get an error: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>z = (<span class="hljs-number"><span class="hljs-number">2337</span></span>,) &gt;&gt;&gt; add_one(z)</code> </pre> <br>  Reverse tracing (the most recent are the most recent calls): <br><br><pre> <code class="python hljs"> File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> add_one TypeError: <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> object does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support item assignment</code> </pre> <br>  This code demonstrates the immutability of the tuple, so it does not support the assignment of elements. <br><br>  <code>list</code> not the only changeable type, part pointers are emulated with <code>dict</code> . <br><br>  Suppose you have an application that should track the occurrence of interesting events.  This can be done by creating a dictionary and using one of its elements as a counter: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>counters = {<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>} &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... &gt;&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> ... counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> ... bar() ... &gt;&gt;&gt; foo() &gt;&gt;&gt; counters[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  In this example, the dictionary uses counters to track the number of function calls.  After calling <code>foo()</code> counter increased by 2, as expected.  And all thanks to the variability of <code>dict</code> . <br><br>  Do not forget, this is only an <b>emulation</b> of pointer behavior, it is in no way connected with real pointers in C and C ++.  It can be said that these operations are more expensive than if they were performed in C or C ++. <br><br><h3>  Using Python Objects </h3><br>  <code>dict</code> is a great way to emulate pointers in Python, but sometimes it's tedious to remember which key name you used.  Especially if you use the dictionary in different parts of the application.  A custom Python class can help here. <br><br>  Suppose you need to track metrics in an application.  A great way to abstract from annoying details is to create a class: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }</code> </pre> <br>  This code defines the <code>Metrics</code> class.  He still uses the dictionary to store the actual data that lies in the <code>_metrics</code> member <code>_metrics</code> .  This will give you the desired variability.  Now you just need to access these values.  You can do this using the properties: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... @property def func_calls(self): return self._metrics["func_calls"] @property def cat_pictures_served(self): return self._metrics["cat_pictures_served"]</span></span></code> </pre> <br>  Here we use <a href="https://docs.python.org/3/library/functions.html">@property</a> .  If you are not familiar with decorators, then read the article <a href="https://realpython.com/primer-on-python-decorators/">Primer on Python Decorators</a> .  In this case, the <code>@property</code> decorator allows you to refer to <code>func_calls</code> and <code>cat_pictures_served</code> as if they were attributes: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;&gt;&gt; metrics.cat_pictures_served <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  The fact that you can refer to these names as attributes means that you are abstracted from the fact that these values ‚Äã‚Äãare stored in a dictionary.  In addition, you make attribute names more explicit.  Of course, you should be able to increase the values: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># ... def inc_func_calls(self): self._metrics["func_calls"] += 1 def inc_cat_pics(self): self._metrics["cat_pictures_served"] += 1</span></span></code> </pre> <br>     : <br><br><ol><li> <code>inc_func_calls()</code> </li> <li> <code>inc_cat_pics()</code> </li> </ol><br>      <code>metrics</code> .     ,     ,   : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>metrics = Metrics() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.inc_func_calls() &gt;&gt;&gt; metrics.func_calls <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>     <code>func_calls</code>   <code>inc_func_calls()</code>         Python.    ,     -  <code>metrics</code> ,          . <br><br> <b></b> :   ,   <code>inc_func_calls()</code>  <code>inc_cat_pics()</code>   <code>@property.setter</code>        <code>int</code> ,     . <br><br>      <code>Metrics</code> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Metrics</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics = { <span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, } @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cat_pictures_served</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_func_calls</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"func_calls"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc_cat_pics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self._metrics[<span class="hljs-string"><span class="hljs-string">"cat_pictures_served"</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h2>     ctypes </h2><br>  , -    Python,   CPython?     ctypes    ,   C.      ctypes,    <a href="https://dbader.org/blog/python-ctypes-tutorial">Extending Python With C Libraries and the ¬´ctypes¬ª Module</a> . <br><br>       ,     ,   .     - <code>add_one()</code> : <br><br><pre> <code class="python hljs">void add_one(int *x) { *x += <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br> ,      <code>x</code>  1.   ,      (shared) .  ,      <code>add.c</code> ,      gcc: <br><br><pre> <code class="python hljs">$ gcc -c -Wall -Werror -fpic add.c $ gcc -shared -o libadd1.so add.o</code> </pre> <br>      C   <code>add.o</code> .           <code>libadd1.so</code> . <br><br> <code>libadd1.so</code>      .    ctypes    Python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ctypes &gt;&gt;&gt; add_lib = ctypes.CDLL(<span class="hljs-string"><span class="hljs-string">"./libadd1.so"</span></span>) &gt;&gt;&gt; add_lib.add_one &lt;_FuncPtr object at <span class="hljs-number"><span class="hljs-number">0x7f9f3b8852a0</span></span>&gt;</code> </pre> <br>  ctypes.CDLL  ,     <code>libadd1</code> .      <code>add_one()</code> ,      ,        Python-.     ,    .  Python  ,      . <br><br>         , ctypes       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one = add_lib.add_one &gt;&gt;&gt; add_one.argtypes = [ctypes.POINTER(ctypes.c_int)]</code> </pre> <br>     ,    C. ,        ,       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(<span class="hljs-number"><span class="hljs-number">1</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; ctypes.ArgumentError: argument <span class="hljs-number"><span class="hljs-number">1</span></span>: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeError</span></span></span><span class="hljs-class">'&gt;:</span></span> \ expected LP_c_int instance instead of int</code> </pre> <br> Python    ,  <code>add_one()</code>   ,     .  ,  ctypes      .       : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = ctypes.c_int() &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>      <code>x</code>   <code>0</code> . ctypes    <code>byref()</code> ,      . <br><br> <b></b> :  <b> </b>     <b> </b> . <br><br>          ,       .         ,        . <br><br>   <code>add_one()</code>    : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>add_one(ctypes.byref(x)) <span class="hljs-number"><span class="hljs-number">998793640</span></span> &gt;&gt;&gt; x c_int(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Fine!     1. ,     Python  . <br><br><h2>  Conclusion </h2><br>        Python  .          ,              Python. <br><br>         Python: <br><br><ul><li>          . <br></li><li>   Python-   . <br></li><li>       ctypes. <br></li></ul><br>       Python       . </div><p>Source: <a href="https://habr.com/ru/post/454324/">https://habr.com/ru/post/454324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454314/index.html">10 principles of object-oriented programming that every developer should know</a></li>
<li><a href="../454316/index.html">In the footsteps of the industrial ninja: we invite you to participate in an online competition for industrial safety</a></li>
<li><a href="../454318/index.html">Sounding the past. A guide for historians to convert data into sound</a></li>
<li><a href="../454320/index.html">Labor Market Analysts and Data Scientists</a></li>
<li><a href="../454322/index.html">There is an opinion: the DANE technology for browsers failed</a></li>
<li><a href="../454326/index.html">In addition to Moore - who else formulated the laws of scaling computing systems</a></li>
<li><a href="../45433/index.html">YouTube has become widescreen.</a></li>
<li><a href="../454330/index.html">10 bright reports TechTrain 2018: AI for the masses, interfaces and much more</a></li>
<li><a href="../454332/index.html">How Telegram-bot overcame designer procrastination and helped increase the income of digital agencies</a></li>
<li><a href="../454334/index.html">Moto. Mokai AWS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>